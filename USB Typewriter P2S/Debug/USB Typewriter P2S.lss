
USB Typewriter P2S.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000024c  00800100  00007336  000073ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007336  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000068b  0080034c  0080034c  00007616  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00007616  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00007674  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007c8  00000000  00000000  000076b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00011579  00000000  00000000  00007e7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000033d5  00000000  00000000  000193f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00015690  00000000  00000000  0001c7ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001d00  00000000  00000000  00031e5c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0001bb2b  00000000  00000000  00033b5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000c86c  00000000  00000000  0004f687  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000a40  00000000  00000000  0005bef3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000b9f7  00000000  00000000  0005c933  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	4e c3       	rjmp	.+1692   	; 0x69e <__ctors_end>
       2:	00 00       	nop
       4:	69 c3       	rjmp	.+1746   	; 0x6d8 <__bad_interrupt>
       6:	00 00       	nop
       8:	67 c3       	rjmp	.+1742   	; 0x6d8 <__bad_interrupt>
       a:	00 00       	nop
       c:	65 c3       	rjmp	.+1738   	; 0x6d8 <__bad_interrupt>
       e:	00 00       	nop
      10:	63 c3       	rjmp	.+1734   	; 0x6d8 <__bad_interrupt>
      12:	00 00       	nop
      14:	61 c3       	rjmp	.+1730   	; 0x6d8 <__bad_interrupt>
      16:	00 00       	nop
      18:	5f c3       	rjmp	.+1726   	; 0x6d8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	5d c3       	rjmp	.+1722   	; 0x6d8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	5b c3       	rjmp	.+1718   	; 0x6d8 <__bad_interrupt>
      22:	00 00       	nop
      24:	59 c3       	rjmp	.+1714   	; 0x6d8 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 23 33 	jmp	0x6646	; 0x6646 <__vector_10>
      2c:	55 c3       	rjmp	.+1706   	; 0x6d8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	53 c3       	rjmp	.+1702   	; 0x6d8 <__bad_interrupt>
      32:	00 00       	nop
      34:	51 c3       	rjmp	.+1698   	; 0x6d8 <__bad_interrupt>
      36:	00 00       	nop
      38:	4f c3       	rjmp	.+1694   	; 0x6d8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	4d c3       	rjmp	.+1690   	; 0x6d8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	4b c3       	rjmp	.+1686   	; 0x6d8 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 c5 24 	jmp	0x498a	; 0x498a <__vector_17>
      48:	47 c3       	rjmp	.+1678   	; 0x6d8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	45 c3       	rjmp	.+1674   	; 0x6d8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	43 c3       	rjmp	.+1670   	; 0x6d8 <__bad_interrupt>
      52:	00 00       	nop
      54:	41 c3       	rjmp	.+1666   	; 0x6d8 <__bad_interrupt>
      56:	00 00       	nop
      58:	3f c3       	rjmp	.+1662   	; 0x6d8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	3d c3       	rjmp	.+1658   	; 0x6d8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	3b c3       	rjmp	.+1654   	; 0x6d8 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 21 24 	jmp	0x4842	; 0x4842 <__vector_25>
      68:	0c 94 4f 24 	jmp	0x489e	; 0x489e <__vector_26>
      6c:	35 c3       	rjmp	.+1642   	; 0x6d8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	33 c3       	rjmp	.+1638   	; 0x6d8 <__bad_interrupt>
      72:	00 00       	nop
      74:	31 c3       	rjmp	.+1634   	; 0x6d8 <__bad_interrupt>
      76:	00 00       	nop
      78:	2f c3       	rjmp	.+1630   	; 0x6d8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	2d c3       	rjmp	.+1626   	; 0x6d8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	2b c3       	rjmp	.+1622   	; 0x6d8 <__bad_interrupt>
      82:	00 00       	nop
      84:	29 c3       	rjmp	.+1618   	; 0x6d8 <__bad_interrupt>
      86:	00 00       	nop
      88:	27 c3       	rjmp	.+1614   	; 0x6d8 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	25 c3       	rjmp	.+1610   	; 0x6d8 <__bad_interrupt>
      8e:	00 00       	nop
      90:	23 c3       	rjmp	.+1606   	; 0x6d8 <__bad_interrupt>
      92:	00 00       	nop
      94:	21 c3       	rjmp	.+1602   	; 0x6d8 <__bad_interrupt>
      96:	00 00       	nop
      98:	1f c3       	rjmp	.+1598   	; 0x6d8 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	1d c3       	rjmp	.+1594   	; 0x6d8 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	1b c3       	rjmp	.+1590   	; 0x6d8 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	0c 94 74 0b 	jmp	0x16e8	; 0x16e8 <__vector_41>
      a8:	17 c3       	rjmp	.+1582   	; 0x6d8 <__bad_interrupt>
	...

000000ac <SEND_EMPTY_HID_REPORT>:
      ac:	41 54 2b 4b 52 3d 41 31 2c 30 31 2c 30 30 2c 30     AT+KR=A1,01,00,0
      bc:	30 2c 30 30 2c 30 30 2c 30 30 2c 30 30 2c 30 30     0,00,00,00,00,00
      cc:	2c 30 30 00                                         ,00.

000000d0 <CONNECT_TO_PAIRED_DEVICE>:
      d0:	41 54 2b 43 49 00                                   AT+CI.

000000d6 <MAKE_DISCOVERABLE>:
      d6:	41 54 2b 4d 44 00                                   AT+MD.

000000dc <CLEAR_PAIRED_LIST>:
      dc:	41 54 2b 43 50 00                                   AT+CP.

000000e2 <DISABLE_PIN>:
      e2:	41 54 2b 49 4f 3d 30 33 00                          AT+IO=03.

000000eb <DISABLE_MIM>:
      eb:	41 54 2b 4d 4d 3d 30 30 00                          AT+MM=00.

000000f4 <SET_MODULE_FEATURES>:
      f4:	41 54 2b 46 54 3d 30 30 2c 30 31 2c 46 46 2c 30     AT+FT=00,01,FF,0
     104:	35 2c 30 31 2c 30 32 35 38 00                       5,01,0258.

0000010e <SET_HID_PARAMS>:
     10e:	41 54 2b 50 46 3d 30 30 2c 30 31 2c 30 30 2c 30     AT+PF=00,01,00,0
     11e:	30 2c 30 30 00                                      0,00.

00000123 <SET_PROXY_MODE>:
     123:	41 54 2b 42 50 3d 30 30 2c 30 30 00                 AT+BP=00,00.

0000012f <ENABLE_UI>:
     12f:	41 54 2b 55 49 3d 30 31 00                          AT+UI=01.

00000138 <SET_FRIENDLY_NAME>:
     138:	41 54 2b 4e 4d 3d 55 53 42 20 54 79 70 65 77 72     AT+NM=USB Typewr
     148:	69 74 65 72 20 42 54 00                             iter BT.

00000150 <Str_Assign>:
     150:	20 4b 45 59 20 53 45 4c 45 43 54 45 44 2e 20 50      KEY SELECTED. P
     160:	52 45 53 53 20 41 20 54 59 50 45 57 52 49 54 45     RESS A TYPEWRITE
     170:	52 20 4b 45 59 20 54 4f 20 41 53 53 49 47 4e 2e     R KEY TO ASSIGN.
     180:	2e 2e 20 00                                         .. .

00000184 <Str_How_To_Exit>:
     184:	50 72 65 73 73 20 43 4d 44 20 74 6f 20 73 61 76     Press CMD to sav
     194:	65 20 61 6e 64 20 65 78 69 74 2e 0d 00              e and exit...

000001a1 <Str_How_To_Select>:
     1a1:	50 72 65 73 73 20 41 4c 54 20 74 6f 20 73 65 6c     Press ALT to sel
     1b1:	65 63 74 20 61 20 63 68 61 72 61 63 74 65 72 2e     ect a character.
     1c1:	0d 00                                               ..

000001c3 <Str_How_To_Scroll>:
     1c3:	50 72 65 73 73 20 43 54 52 4c 20 74 6f 20 73 63     Press CTRL to sc
     1d3:	72 6f 6c 6c 20 74 68 72 6f 75 67 68 20 63 68 61     roll through cha
     1e3:	72 61 63 74 65 72 73 2e 0d 00                       racters...

000001ed <Str_S_For_SD>:
     1ed:	50 72 65 73 73 20 53 20 69 66 20 63 68 61 6e 67     Press S if chang
     1fd:	65 73 20 73 68 6f 75 6c 64 20 61 70 70 6c 79 20     es should apply 
     20d:	74 6f 20 53 44 20 6d 6f 64 65 2e 0d 00              to SD mode...

0000021a <Str_U_For_USB>:
     21a:	50 72 65 73 73 20 55 20 69 66 20 63 68 61 6e 67     Press U if chang
     22a:	65 73 20 73 68 6f 75 6c 64 20 61 70 70 6c 79 20     es should apply 
     23a:	74 6f 20 55 53 42 2f 42 54 20 6d 6f 64 65 2e 0d     to USB/BT mode..
	...

0000024b <Str_Manual_Calibration>:
     24b:	4d 41 4e 55 41 4c 20 43 41 4c 49 42 52 41 54 49     MANUAL CALIBRATI
     25b:	4f 4e 20 4d 4f 44 45 2e 2e 2e 0d 00                 ON MODE.....

00000267 <Str_Settings_Saved>:
     267:	53 45 54 54 49 4e 47 53 20 53 41 56 45 44 21 0d     SETTINGS SAVED!.
	...

00000278 <Str_Spacebar_Blocks_Enter>:
     278:	0d 49 47 4e 4f 52 45 20 45 4e 54 45 52 20 4b 45     .IGNORE ENTER KE
     288:	59 20 57 48 45 4e 20 53 50 41 43 45 42 41 52 20     Y WHEN SPACEBAR 
     298:	49 53 20 48 45 4c 44 3f 0d 00                       IS HELD?..

000002a2 <Str_Set_Reed_Time>:
     2a2:	0d 4e 4f 57 20 53 45 54 20 52 45 45 44 20 52 45     .NOW SET REED RE
     2b2:	41 43 54 49 4f 4e 20 54 49 4d 45 2e 2e 2e 0d 00     ACTION TIME.....

000002c2 <Str_Set_Double_Time>:
     2c2:	0d 4e 4f 57 20 53 45 54 20 44 45 4c 41 59 20 42     .NOW SET DELAY B
     2d2:	45 54 57 45 45 4e 20 44 4f 55 42 4c 45 20 4b 45     ETWEEN DOUBLE KE
     2e2:	59 20 50 52 45 53 53 45 53 2e 2e 2e 0d 00           Y PRESSES.....

000002f0 <Str_Set_Release_Time>:
     2f0:	0d 4e 4f 57 20 53 45 54 20 4b 45 59 20 52 45 4c     .NOW SET KEY REL
     300:	45 41 53 45 20 54 49 4d 45 2e 2e 2e 0d 00           EASE TIME.....

0000030e <Str_Set_Reaction_Time>:
     30e:	50 52 45 53 53 20 43 54 52 4c 20 41 4e 44 20 41     PRESS CTRL AND A
     31e:	4c 54 20 54 4f 20 53 45 54 20 4b 45 59 20 52 45     LT TO SET KEY RE
     32e:	41 43 54 49 4f 4e 20 54 49 4d 45 2e 2e 2e 0d 00     ACTION TIME.....

0000033e <Str_Press_CMD>:
     33e:	50 52 45 53 53 20 43 4d 44 20 4b 45 59 20 54 4f     PRESS CMD KEY TO
     34e:	20 43 4f 4e 54 49 4e 55 45 2e 2e 2e 0d 00            CONTINUE.....

0000035c <Str_Adj_Sensitivity>:
     35c:	41 44 4a 55 53 54 49 4e 47 20 4b 45 59 20 53 45     ADJUSTING KEY SE
     36c:	4e 53 49 54 49 56 49 54 59 2e 0d 00                 NSITIVITY...

00000378 <Str_No_Hall>:
     378:	4e 4f 20 48 41 4c 4c 20 45 46 46 45 43 54 20 53     NO HALL EFFECT S
     388:	45 4e 53 4f 52 20 44 45 54 45 43 54 45 44 2e 20     ENSOR DETECTED. 
     398:	28 4e 4f 54 20 41 20 50 52 4f 42 4c 45 4d 29 0d     (NOT A PROBLEM).
	...

000003a9 <Str_Calibrate_Hall>:
     3a9:	48 4f 4c 44 20 44 4f 57 4e 20 41 4e 59 20 4b 45     HOLD DOWN ANY KE
     3b9:	59 20 54 4f 20 43 41 4c 49 42 52 41 54 45 20 48     Y TO CALIBRATE H
     3c9:	41 4c 4c 20 45 46 46 45 43 54 20 53 45 4e 53 4f     ALL EFFECT SENSO
     3d9:	52 2e 2e 2e 0d 00                                   R.....

000003df <Str_Backspace>:
     3df:	42 41 43 4b 53 50 41 43 45 00                       BACKSPACE.

000003e9 <Str_Post>:
     3e9:	53 45 4e 44 00                                      SEND.

000003ee <Str_Second_Enter>:
     3ee:	53 45 43 4f 4e 44 41 52 59 20 45 4e 54 45 52 00     SECONDARY ENTER.

000003fe <Str_Enter>:
     3fe:	45 4e 54 45 52 00                                   ENTER.

00000404 <Str_Spacebar>:
     404:	53 50 41 43 45 42 41 52 00                          SPACEBAR.

0000040d <Str_Quick_Calibrate>:
     40d:	51 55 49 43 4b 20 43 41 4c 49 42 52 41 54 49 4f     QUICK CALIBRATIO
     41d:	4e 20 4d 4f 44 45 2e 2e 2e 0d 00                    N MODE.....

00000428 <Str_No_Dummy_Load>:
     428:	44 55 4d 4d 59 20 4c 4f 41 44 20 44 45 41 43 54     DUMMY LOAD DEACT
     438:	49 56 41 54 45 44 0d 00                             IVATED..

00000440 <Str_Dummy_Load>:
     440:	44 55 4d 4d 59 20 4c 4f 41 44 20 41 43 54 49 56     DUMMY LOAD ACTIV
     450:	41 54 45 44 0d 00                                   ATED..

00000456 <Str_USB_Only>:
     456:	20 4b 45 59 20 54 4f 20 55 53 45 20 44 55 52 49      KEY TO USE DURI
     466:	4e 47 20 55 53 42 2f 42 4c 55 45 54 4f 4f 54 48     NG USB/BLUETOOTH
     476:	20 4d 4f 44 45 3a 00                                 MODE:.

0000047d <Str_SD_Only>:
     47d:	20 4b 45 59 20 54 4f 20 55 53 45 20 44 55 52 49      KEY TO USE DURI
     48d:	4e 47 20 53 44 20 43 41 52 44 20 4d 4f 44 45 3a     NG SD CARD MODE:
	...

0000049e <Str_Shift_Error>:
     49e:	45 52 52 4f 52 2e 2e 2e 53 48 49 46 54 20 4d 55     ERROR...SHIFT MU
     4ae:	53 54 20 42 45 20 41 20 52 45 45 44 20 53 57 49     ST BE A REED SWI
     4be:	54 43 48 2e 0d 00                                   TCH...

000004c4 <Str_Type_The_Following>:
     4c4:	54 59 50 45 20 54 48 45 20 46 4f 4c 4c 4f 57 49     TYPE THE FOLLOWI
     4d4:	4e 47 20 4b 45 59 53 20 28 50 52 45 53 53 20 53     NG KEYS (PRESS S
     4e4:	50 41 43 45 20 54 4f 20 53 4b 49 50 29 2e 2e 2e     PACE TO SKIP)...
     4f4:	0d 00                                               ..

000004f6 <Str_Calibrating>:
     4f6:	43 41 4c 49 42 52 41 54 49 4e 47 2e 2e 2e 0d 00     CALIBRATING.....

00000506 <Str_SD_Mode>:
     506:	53 44 20 43 41 52 44 20 53 54 4f 52 41 47 45 20     SD CARD STORAGE 
     516:	4d 4f 44 45 0d 00                                   MODE..

0000051c <Str_Combo_Mode>:
     51c:	55 53 42 20 4b 45 59 42 4f 41 52 44 2f 43 41 52     USB KEYBOARD/CAR
     52c:	44 20 52 45 41 44 45 52 20 4d 4f 44 45 0d 00        D READER MODE..

0000053b <Str_Light_Mode>:
     53b:	4c 49 47 48 54 20 4d 4f 44 45 20 28 53 44 20 43     LIGHT MODE (SD C
     54b:	41 52 44 20 52 45 41 44 45 52 20 44 49 53 41 42     ARD READER DISAB
     55b:	4c 45 44 29 0d 00                                   LED)..

00000561 <Str_BT_Mode>:
     561:	42 4c 55 45 54 4f 4f 54 48 20 4b 45 59 42 4f 41     BLUETOOTH KEYBOA
     571:	52 44 20 4d 4f 44 45 0d 00                          RD MODE..

0000057a <Str_Typewriter_Mode>:
     57a:	44 45 46 41 55 4c 54 20 53 45 54 54 49 4e 47 3a     DEFAULT SETTING:
     58a:	20 00                                                .

0000058c <Str_Firmware_Ver>:
     58c:	46 49 52 4d 57 41 52 45 20 56 45 52 20 35 2e 33     FIRMWARE VER 5.3
     59c:	2e 30 2e 45 00                                      .0.E.

000005a1 <Str_USB_Typewriter>:
     5a1:	55 53 42 20 54 59 50 45 57 52 49 54 45 52 20 28     USB TYPEWRITER (
     5b1:	54 4d 29 0d 00                                      TM)..

000005b6 <ProductString>:
     5b6:	30 03 55 00 53 00 42 00 20 00 54 00 79 00 70 00     0.U.S.B. .T.y.p.
     5c6:	65 00 77 00 72 00 69 00 74 00 65 00 72 00 20 00     e.w.r.i.t.e.r. .
     5d6:	4b 00 65 00 79 00 62 00 6f 00 61 00 72 00 64 00     K.e.y.b.o.a.r.d.
	...

000005e8 <ManufacturerString>:
     5e8:	26 03 55 00 53 00 42 00 20 00 54 00 59 00 50 00     &.U.S.B. .T.Y.P.
     5f8:	45 00 57 00 52 00 49 00 54 00 45 00 52 00 20 00     E.W.R.I.T.E.R. .
     608:	4c 00 4c 00 43 00 00 00                             L.L.C...

00000610 <LanguageString>:
     610:	04 03 09 04                                         ....

00000614 <ConfigurationDescriptor>:
     614:	09 02 39 00 02 01 00 80 07 09 04 00 00 02 08 06     ..9.............
     624:	50 00 07 05 83 02 40 00 05 07 05 04 02 40 00 05     P.....@......@..
     634:	09 04 01 00 01 03 01 01 00 09 21 11 01 00 01 22     ..........!...."
     644:	3f 00 07 05 81 03 08 00 05                          ?........

0000064d <DeviceDescriptor>:
     64d:	12 01 10 01 00 00 00 08 eb 03 61 20 86 00 01 02     ..........a ....
     65d:	dc 01                                               ..

0000065f <KeyboardReport>:
     65f:	05 01 09 06 a1 01 05 07 19 e0 29 e7 15 00 25 01     ..........)...%.
     66f:	75 01 95 08 81 02 95 01 75 08 81 01 05 08 19 01     u.......u.......
     67f:	29 05 95 05 75 01 91 02 95 01 75 03 91 01 15 00     )...u.....u.....
     68f:	25 ff 05 07 19 00 29 ff 95 06 75 08 81 00 c0        %.....)...u....

0000069e <__ctors_end>:
     69e:	11 24       	eor	r1, r1
     6a0:	1f be       	out	0x3f, r1	; 63
     6a2:	cf ef       	ldi	r28, 0xFF	; 255
     6a4:	da e0       	ldi	r29, 0x0A	; 10
     6a6:	de bf       	out	0x3e, r29	; 62
     6a8:	cd bf       	out	0x3d, r28	; 61

000006aa <__do_copy_data>:
     6aa:	13 e0       	ldi	r17, 0x03	; 3
     6ac:	a0 e0       	ldi	r26, 0x00	; 0
     6ae:	b1 e0       	ldi	r27, 0x01	; 1
     6b0:	e6 e3       	ldi	r30, 0x36	; 54
     6b2:	f3 e7       	ldi	r31, 0x73	; 115
     6b4:	02 c0       	rjmp	.+4      	; 0x6ba <__do_copy_data+0x10>
     6b6:	05 90       	lpm	r0, Z+
     6b8:	0d 92       	st	X+, r0
     6ba:	ac 34       	cpi	r26, 0x4C	; 76
     6bc:	b1 07       	cpc	r27, r17
     6be:	d9 f7       	brne	.-10     	; 0x6b6 <__do_copy_data+0xc>

000006c0 <__do_clear_bss>:
     6c0:	29 e0       	ldi	r18, 0x09	; 9
     6c2:	ac e4       	ldi	r26, 0x4C	; 76
     6c4:	b3 e0       	ldi	r27, 0x03	; 3
     6c6:	01 c0       	rjmp	.+2      	; 0x6ca <.do_clear_bss_start>

000006c8 <.do_clear_bss_loop>:
     6c8:	1d 92       	st	X+, r1

000006ca <.do_clear_bss_start>:
     6ca:	a7 3d       	cpi	r26, 0xD7	; 215
     6cc:	b2 07       	cpc	r27, r18
     6ce:	e1 f7       	brne	.-8      	; 0x6c8 <.do_clear_bss_loop>
     6d0:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <main>
     6d4:	0c 94 99 39 	jmp	0x7332	; 0x7332 <_exit>

000006d8 <__bad_interrupt>:
     6d8:	93 cc       	rjmp	.-1754   	; 0x0 <__vectors>

000006da <Bluetooth_Reset>:
}

void BT_Wake(){
	if (BT_Asleep){
		Bluetooth_Send_PROGMEM_CMD(DISABLE_SLEEP,true); //disable sleep mode
		BT_Asleep = false; //bt is no longer asleep
     6da:	8f 98       	cbi	0x11, 7	; 17
     6dc:	2f e7       	ldi	r18, 0x7F	; 127
     6de:	88 e3       	ldi	r24, 0x38	; 56
     6e0:	91 e0       	ldi	r25, 0x01	; 1
     6e2:	21 50       	subi	r18, 0x01	; 1
     6e4:	80 40       	sbci	r24, 0x00	; 0
     6e6:	90 40       	sbci	r25, 0x00	; 0
     6e8:	e1 f7       	brne	.-8      	; 0x6e2 <Bluetooth_Reset+0x8>
     6ea:	00 c0       	rjmp	.+0      	; 0x6ec <Bluetooth_Reset+0x12>
     6ec:	00 00       	nop
     6ee:	8f 9a       	sbi	0x11, 7	; 17
     6f0:	2f ef       	ldi	r18, 0xFF	; 255
     6f2:	84 e3       	ldi	r24, 0x34	; 52
     6f4:	9c e0       	ldi	r25, 0x0C	; 12
     6f6:	21 50       	subi	r18, 0x01	; 1
     6f8:	80 40       	sbci	r24, 0x00	; 0
     6fa:	90 40       	sbci	r25, 0x00	; 0
     6fc:	e1 f7       	brne	.-8      	; 0x6f6 <Bluetooth_Reset+0x1c>
     6fe:	00 c0       	rjmp	.+0      	; 0x700 <Bluetooth_Reset+0x26>
     700:	00 00       	nop
     702:	76 98       	cbi	0x0e, 6	; 14
     704:	8f e0       	ldi	r24, 0x0F	; 15
     706:	97 e2       	ldi	r25, 0x27	; 39
     708:	01 97       	sbiw	r24, 0x01	; 1
     70a:	f1 f7       	brne	.-4      	; 0x708 <Bluetooth_Reset+0x2e>
     70c:	00 c0       	rjmp	.+0      	; 0x70e <Bluetooth_Reset+0x34>
     70e:	00 00       	nop
     710:	08 95       	ret

00000712 <Get_Response>:
     712:	0f 93       	push	r16
     714:	1f 93       	push	r17
     716:	cf 93       	push	r28
     718:	81 11       	cpse	r24, r1
     71a:	02 c0       	rjmp	.+4      	; 0x720 <Get_Response+0xe>
     71c:	81 e0       	ldi	r24, 0x01	; 1
     71e:	34 c0       	rjmp	.+104    	; 0x788 <Get_Response+0x76>
     720:	2f ef       	ldi	r18, 0xFF	; 255
     722:	80 e7       	ldi	r24, 0x70	; 112
     724:	92 e0       	ldi	r25, 0x02	; 2
     726:	21 50       	subi	r18, 0x01	; 1
     728:	80 40       	sbci	r24, 0x00	; 0
     72a:	90 40       	sbci	r25, 0x00	; 0
     72c:	e1 f7       	brne	.-8      	; 0x726 <Get_Response+0x14>
     72e:	00 c0       	rjmp	.+0      	; 0x730 <Get_Response+0x1e>
     730:	00 00       	nop
     732:	10 92 13 06 	sts	0x0613, r1
     736:	10 92 14 06 	sts	0x0614, r1
     73a:	10 92 15 06 	sts	0x0615, r1
     73e:	10 92 17 06 	sts	0x0617, r1
     742:	03 e1       	ldi	r16, 0x13	; 19
     744:	16 e0       	ldi	r17, 0x06	; 6
     746:	c0 e0       	ldi	r28, 0x00	; 0
     748:	0e 94 92 24 	call	0x4924	; 0x4924 <uart_getc>
     74c:	9c 01       	movw	r18, r24
     74e:	22 27       	eor	r18, r18
     750:	23 2b       	or	r18, r19
     752:	31 f0       	breq	.+12     	; 0x760 <Get_Response+0x4e>
     754:	ec 2f       	mov	r30, r28
     756:	f0 e0       	ldi	r31, 0x00	; 0
     758:	ed 5e       	subi	r30, 0xED	; 237
     75a:	f9 4f       	sbci	r31, 0xF9	; 249
     75c:	10 82       	st	Z, r1
     75e:	0a c0       	rjmp	.+20     	; 0x774 <Get_Response+0x62>
     760:	cf 31       	cpi	r28, 0x1F	; 31
     762:	19 f4       	brne	.+6      	; 0x76a <Get_Response+0x58>
     764:	10 92 32 06 	sts	0x0632, r1
     768:	05 c0       	rjmp	.+10     	; 0x774 <Get_Response+0x62>
     76a:	f8 01       	movw	r30, r16
     76c:	81 93       	st	Z+, r24
     76e:	8f 01       	movw	r16, r30
     770:	cf 5f       	subi	r28, 0xFF	; 255
     772:	ea cf       	rjmp	.-44     	; 0x748 <Get_Response+0x36>
     774:	80 91 13 06 	lds	r24, 0x0613
     778:	8f 34       	cpi	r24, 0x4F	; 79
     77a:	81 f2       	breq	.-96     	; 0x71c <Get_Response+0xa>
     77c:	81 e0       	ldi	r24, 0x01	; 1
     77e:	90 91 15 06 	lds	r25, 0x0615
     782:	9d 33       	cpi	r25, 0x3D	; 61
     784:	09 f0       	breq	.+2      	; 0x788 <Get_Response+0x76>
     786:	80 e0       	ldi	r24, 0x00	; 0
     788:	cf 91       	pop	r28
     78a:	1f 91       	pop	r17
     78c:	0f 91       	pop	r16
     78e:	08 95       	ret

00000790 <Bluetooth_Send_CMD>:
     790:	ef 92       	push	r14
     792:	ff 92       	push	r15
     794:	1f 93       	push	r17
     796:	cf 93       	push	r28
     798:	df 93       	push	r29
     79a:	00 d0       	rcall	.+0      	; 0x79c <Bluetooth_Send_CMD+0xc>
     79c:	cd b7       	in	r28, 0x3d	; 61
     79e:	de b7       	in	r29, 0x3e	; 62
     7a0:	16 2f       	mov	r17, r22
     7a2:	89 83       	std	Y+1, r24	; 0x01
     7a4:	9a 83       	std	Y+2, r25	; 0x02
     7a6:	0e 94 ab 24 	call	0x4956	; 0x4956 <uart_clear_rx_buffer>
     7aa:	89 81       	ldd	r24, Y+1	; 0x01
     7ac:	e8 2e       	mov	r14, r24
     7ae:	9a 81       	ldd	r25, Y+2	; 0x02
     7b0:	f9 2e       	mov	r15, r25
     7b2:	f7 01       	movw	r30, r14
     7b4:	81 91       	ld	r24, Z+
     7b6:	7f 01       	movw	r14, r30
     7b8:	88 23       	and	r24, r24
     7ba:	19 f0       	breq	.+6      	; 0x7c2 <Bluetooth_Send_CMD+0x32>
     7bc:	0e 94 b0 24 	call	0x4960	; 0x4960 <uart_putc>
     7c0:	f8 cf       	rjmp	.-16     	; 0x7b2 <Bluetooth_Send_CMD+0x22>
     7c2:	8d e0       	ldi	r24, 0x0D	; 13
     7c4:	0e 94 b0 24 	call	0x4960	; 0x4960 <uart_putc>
     7c8:	8a e0       	ldi	r24, 0x0A	; 10
     7ca:	0e 94 b0 24 	call	0x4960	; 0x4960 <uart_putc>
     7ce:	81 2f       	mov	r24, r17
     7d0:	0f 90       	pop	r0
     7d2:	0f 90       	pop	r0
     7d4:	df 91       	pop	r29
     7d6:	cf 91       	pop	r28
     7d8:	1f 91       	pop	r17
     7da:	ff 90       	pop	r15
     7dc:	ef 90       	pop	r14
     7de:	99 cf       	rjmp	.-206    	; 0x712 <Get_Response>

000007e0 <Bluetooth_Send_PROGMEM_CMD>:
     7e0:	cf 93       	push	r28
     7e2:	c6 2f       	mov	r28, r22
     7e4:	bc 01       	movw	r22, r24
     7e6:	8c e0       	ldi	r24, 0x0C	; 12
     7e8:	97 e0       	ldi	r25, 0x07	; 7
     7ea:	0e 94 35 36 	call	0x6c6a	; 0x6c6a <strcpy_P>
     7ee:	6c 2f       	mov	r22, r28
     7f0:	8c e0       	ldi	r24, 0x0C	; 12
     7f2:	97 e0       	ldi	r25, 0x07	; 7
     7f4:	cf 91       	pop	r28
     7f6:	cc cf       	rjmp	.-104    	; 0x790 <Bluetooth_Send_CMD>

000007f8 <Bluetooth_Send>:
     7f8:	cf 93       	push	r28
     7fa:	df 93       	push	r29
     7fc:	c8 2f       	mov	r28, r24
     7fe:	d6 2f       	mov	r29, r22
     800:	60 e0       	ldi	r22, 0x00	; 0
     802:	8d e8       	ldi	r24, 0x8D	; 141
     804:	91 e0       	ldi	r25, 0x01	; 1
     806:	c4 df       	rcall	.-120    	; 0x790 <Bluetooth_Send_CMD>
     808:	8f ec       	ldi	r24, 0xCF	; 207
     80a:	97 e0       	ldi	r25, 0x07	; 7
     80c:	01 97       	sbiw	r24, 0x01	; 1
     80e:	f1 f7       	brne	.-4      	; 0x80c <Bluetooth_Send+0x14>
     810:	00 c0       	rjmp	.+0      	; 0x812 <Bluetooth_Send+0x1a>
     812:	00 00       	nop
     814:	c7 ff       	sbrs	r28, 7
     816:	02 c0       	rjmp	.+4      	; 0x81c <Bluetooth_Send+0x24>
     818:	cf 77       	andi	r28, 0x7F	; 127
     81a:	d2 e0       	ldi	r29, 0x02	; 2
     81c:	c4 37       	cpi	r28, 0x74	; 116
     81e:	11 f4       	brne	.+4      	; 0x824 <Bluetooth_Send+0x2c>
     820:	d1 e0       	ldi	r29, 0x01	; 1
     822:	c8 e2       	ldi	r28, 0x28	; 40
     824:	1f 92       	push	r1
     826:	cf 93       	push	r28
     828:	1f 92       	push	r1
     82a:	df 93       	push	r29
     82c:	86 e9       	ldi	r24, 0x96	; 150
     82e:	91 e0       	ldi	r25, 0x01	; 1
     830:	9f 93       	push	r25
     832:	8f 93       	push	r24
     834:	80 e0       	ldi	r24, 0x00	; 0
     836:	91 e0       	ldi	r25, 0x01	; 1
     838:	9f 93       	push	r25
     83a:	8f 93       	push	r24
     83c:	0e 94 8a 36 	call	0x6d14	; 0x6d14 <sprintf>
     840:	60 e0       	ldi	r22, 0x00	; 0
     842:	80 e0       	ldi	r24, 0x00	; 0
     844:	91 e0       	ldi	r25, 0x01	; 1
     846:	a4 df       	rcall	.-184    	; 0x790 <Bluetooth_Send_CMD>
     848:	8f ec       	ldi	r24, 0xCF	; 207
     84a:	97 e0       	ldi	r25, 0x07	; 7
     84c:	01 97       	sbiw	r24, 0x01	; 1
     84e:	f1 f7       	brne	.-4      	; 0x84c <Bluetooth_Send+0x54>
     850:	00 c0       	rjmp	.+0      	; 0x852 <Bluetooth_Send+0x5a>
     852:	00 00       	nop
     854:	8d b7       	in	r24, 0x3d	; 61
     856:	9e b7       	in	r25, 0x3e	; 62
     858:	08 96       	adiw	r24, 0x08	; 8
     85a:	0f b6       	in	r0, 0x3f	; 63
     85c:	f8 94       	cli
     85e:	9e bf       	out	0x3e, r25	; 62
     860:	0f be       	out	0x3f, r0	; 63
     862:	8d bf       	out	0x3d, r24	; 61
     864:	60 e0       	ldi	r22, 0x00	; 0
     866:	8c ea       	ldi	r24, 0xAC	; 172
     868:	90 e0       	ldi	r25, 0x00	; 0
     86a:	df 91       	pop	r29
     86c:	cf 91       	pop	r28
     86e:	b8 cf       	rjmp	.-144    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>

00000870 <Bluetooth_Init>:
     870:	34 df       	rcall	.-408    	; 0x6da <Bluetooth_Reset>
     872:	2f ef       	ldi	r18, 0xFF	; 255
     874:	89 e6       	ldi	r24, 0x69	; 105
     876:	98 e1       	ldi	r25, 0x18	; 24
     878:	21 50       	subi	r18, 0x01	; 1
     87a:	80 40       	sbci	r24, 0x00	; 0
     87c:	90 40       	sbci	r25, 0x00	; 0
     87e:	e1 f7       	brne	.-8      	; 0x878 <Bluetooth_Init+0x8>
     880:	00 c0       	rjmp	.+0      	; 0x882 <Bluetooth_Init+0x12>
     882:	00 00       	nop
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	45 df       	rcall	.-374    	; 0x712 <Get_Response>
     888:	61 e0       	ldi	r22, 0x01	; 1
     88a:	83 e2       	ldi	r24, 0x23	; 35
     88c:	91 e0       	ldi	r25, 0x01	; 1
     88e:	a8 df       	rcall	.-176    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>
     890:	2f ef       	ldi	r18, 0xFF	; 255
     892:	89 e6       	ldi	r24, 0x69	; 105
     894:	98 e1       	ldi	r25, 0x18	; 24
     896:	21 50       	subi	r18, 0x01	; 1
     898:	80 40       	sbci	r24, 0x00	; 0
     89a:	90 40       	sbci	r25, 0x00	; 0
     89c:	e1 f7       	brne	.-8      	; 0x896 <Bluetooth_Init+0x26>
     89e:	00 c0       	rjmp	.+0      	; 0x8a0 <Bluetooth_Init+0x30>
     8a0:	00 00       	nop
     8a2:	81 e0       	ldi	r24, 0x01	; 1
     8a4:	80 93 33 06 	sts	0x0633, r24
     8a8:	08 95       	ret

000008aa <Bluetooth_Configure>:
     8aa:	cf 93       	push	r28
     8ac:	e1 df       	rcall	.-62     	; 0x870 <Bluetooth_Init>
     8ae:	61 e0       	ldi	r22, 0x01	; 1
     8b0:	8f e2       	ldi	r24, 0x2F	; 47
     8b2:	91 e0       	ldi	r25, 0x01	; 1
     8b4:	95 df       	rcall	.-214    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>
     8b6:	c8 2f       	mov	r28, r24
     8b8:	61 e0       	ldi	r22, 0x01	; 1
     8ba:	88 e3       	ldi	r24, 0x38	; 56
     8bc:	91 e0       	ldi	r25, 0x01	; 1
     8be:	90 df       	rcall	.-224    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>
     8c0:	61 e0       	ldi	r22, 0x01	; 1
     8c2:	83 e2       	ldi	r24, 0x23	; 35
     8c4:	91 e0       	ldi	r25, 0x01	; 1
     8c6:	8c df       	rcall	.-232    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>
     8c8:	61 e0       	ldi	r22, 0x01	; 1
     8ca:	8e e0       	ldi	r24, 0x0E	; 14
     8cc:	91 e0       	ldi	r25, 0x01	; 1
     8ce:	88 df       	rcall	.-240    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>
     8d0:	2f ef       	ldi	r18, 0xFF	; 255
     8d2:	84 e3       	ldi	r24, 0x34	; 52
     8d4:	9c e0       	ldi	r25, 0x0C	; 12
     8d6:	21 50       	subi	r18, 0x01	; 1
     8d8:	80 40       	sbci	r24, 0x00	; 0
     8da:	90 40       	sbci	r25, 0x00	; 0
     8dc:	e1 f7       	brne	.-8      	; 0x8d6 <Bluetooth_Configure+0x2c>
     8de:	00 c0       	rjmp	.+0      	; 0x8e0 <Bluetooth_Configure+0x36>
     8e0:	00 00       	nop
     8e2:	61 e0       	ldi	r22, 0x01	; 1
     8e4:	84 ef       	ldi	r24, 0xF4	; 244
     8e6:	90 e0       	ldi	r25, 0x00	; 0
     8e8:	7b df       	rcall	.-266    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>
     8ea:	61 e0       	ldi	r22, 0x01	; 1
     8ec:	8b ee       	ldi	r24, 0xEB	; 235
     8ee:	90 e0       	ldi	r25, 0x00	; 0
     8f0:	77 df       	rcall	.-274    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>
     8f2:	61 e0       	ldi	r22, 0x01	; 1
     8f4:	82 ee       	ldi	r24, 0xE2	; 226
     8f6:	90 e0       	ldi	r25, 0x00	; 0
     8f8:	73 df       	rcall	.-282    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>
     8fa:	61 e0       	ldi	r22, 0x01	; 1
     8fc:	8c ed       	ldi	r24, 0xDC	; 220
     8fe:	90 e0       	ldi	r25, 0x00	; 0
     900:	6f df       	rcall	.-290    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>
     902:	8c 2f       	mov	r24, r28
     904:	cf 91       	pop	r28
     906:	08 95       	ret

00000908 <BluetoothInquire>:
     908:	61 e0       	ldi	r22, 0x01	; 1
     90a:	8c ed       	ldi	r24, 0xDC	; 220
     90c:	90 e0       	ldi	r25, 0x00	; 0
     90e:	68 cf       	rjmp	.-304    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>

00000910 <Get_Bluetooth_State>:
     910:	80 91 33 06 	lds	r24, 0x0633
     914:	08 95       	ret

00000916 <Bluetooth_Connect>:
	}
}

bool Bluetooth_Connect(){
     916:	cf 93       	push	r28
     918:	df 93       	push	r29
     91a:	00 d0       	rcall	.+0      	; 0x91c <Bluetooth_Connect+0x6>
     91c:	00 d0       	rcall	.+0      	; 0x91e <Bluetooth_Connect+0x8>
     91e:	cd b7       	in	r28, 0x3d	; 61
     920:	de b7       	in	r29, 0x3e	; 62
//	if (is_low(BT_CONNECTED)) // if bluetooth is not already connected:
	const char s[4] = "MD=";
     922:	8d e4       	ldi	r24, 0x4D	; 77
     924:	94 e4       	ldi	r25, 0x44	; 68
     926:	ad e3       	ldi	r26, 0x3D	; 61
     928:	b0 e0       	ldi	r27, 0x00	; 0
     92a:	89 83       	std	Y+1, r24	; 0x01
     92c:	9a 83       	std	Y+2, r25	; 0x02
     92e:	ab 83       	std	Y+3, r26	; 0x03
     930:	bc 83       	std	Y+4, r27	; 0x04
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     932:	2f ef       	ldi	r18, 0xFF	; 255
     934:	89 e6       	ldi	r24, 0x69	; 105
     936:	98 e1       	ldi	r25, 0x18	; 24
     938:	21 50       	subi	r18, 0x01	; 1
     93a:	80 40       	sbci	r24, 0x00	; 0
     93c:	90 40       	sbci	r25, 0x00	; 0
     93e:	e1 f7       	brne	.-8      	; 0x938 <Bluetooth_Connect+0x22>
     940:	00 c0       	rjmp	.+0      	; 0x942 <Bluetooth_Connect+0x2c>
     942:	00 00       	nop
	#ifdef BT_DEBUG
		USBSendString("connect\n");
	#endif
	
	Delay_MS(1000);
	Bluetooth_Send_PROGMEM_CMD(ENABLE_UI,false); //enable ui
     944:	60 e0       	ldi	r22, 0x00	; 0
     946:	8f e2       	ldi	r24, 0x2F	; 47
     948:	91 e0       	ldi	r25, 0x01	; 1
     94a:	4a df       	rcall	.-364    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>
	Bluetooth_Send_PROGMEM_CMD(MAKE_DISCOVERABLE,true);
     94c:	61 e0       	ldi	r22, 0x01	; 1
     94e:	86 ed       	ldi	r24, 0xD6	; 214
     950:	90 e0       	ldi	r25, 0x00	; 0
     952:	46 df       	rcall	.-372    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>
	char* numericalresponse = strtok(response,s); //parse result so we only get the part after MD=
     954:	be 01       	movw	r22, r28
     956:	6f 5f       	subi	r22, 0xFF	; 255
     958:	7f 4f       	sbci	r23, 0xFF	; 255
     95a:	83 e1       	ldi	r24, 0x13	; 19
     95c:	96 e0       	ldi	r25, 0x06	; 6
     95e:	0e 94 3c 36 	call	0x6c78	; 0x6c78 <strtok>
	numericalresponse = strtok(NULL, s); // calling function again accesses everything after the delimiter
     962:	be 01       	movw	r22, r28
     964:	6f 5f       	subi	r22, 0xFF	; 255
     966:	7f 4f       	sbci	r23, 0xFF	; 255
     968:	80 e0       	ldi	r24, 0x00	; 0
     96a:	90 e0       	ldi	r25, 0x00	; 0
     96c:	0e 94 3c 36 	call	0x6c78	; 0x6c78 <strtok>
	if (numericalresponse != NULL){ //if there is anything to report.
     970:	00 97       	sbiw	r24, 0x00	; 0
     972:	41 f0       	breq	.+16     	; 0x984 <Bluetooth_Connect+0x6e>
		if((numericalresponse[1] == '0')){ //if this is not discoverable mode...
     974:	fc 01       	movw	r30, r24
     976:	81 81       	ldd	r24, Z+1	; 0x01
     978:	80 33       	cpi	r24, 0x30	; 48
     97a:	21 f4       	brne	.+8      	; 0x984 <Bluetooth_Connect+0x6e>
			Bluetooth_Send_PROGMEM_CMD(CONNECT_TO_PAIRED_DEVICE,true); //then attempt a new connection.
     97c:	61 e0       	ldi	r22, 0x01	; 1
     97e:	80 ed       	ldi	r24, 0xD0	; 208
     980:	90 e0       	ldi	r25, 0x00	; 0
     982:	2e df       	rcall	.-420    	; 0x7e0 <Bluetooth_Send_PROGMEM_CMD>
		}
	}
	return true;
}
     984:	81 e0       	ldi	r24, 0x01	; 1
     986:	0f 90       	pop	r0
     988:	0f 90       	pop	r0
     98a:	0f 90       	pop	r0
     98c:	0f 90       	pop	r0
     98e:	df 91       	pop	r29
     990:	cf 91       	pop	r28
     992:	08 95       	ret

00000994 <SaveCalibration>:
	
}


void SaveCalibration(){
		 USBSendString("SAVING...\r");
     994:	8e eb       	ldi	r24, 0xBE	; 190
     996:	91 e0       	ldi	r25, 0x01	; 1
     998:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
		 eeprom_write_block (KeyCodeLookUpTable, (void *) KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
     99c:	40 e4       	ldi	r20, 0x40	; 64
     99e:	50 e0       	ldi	r21, 0x00	; 0
     9a0:	60 e0       	ldi	r22, 0x00	; 0
     9a2:	70 e0       	ldi	r23, 0x00	; 0
     9a4:	8c e3       	ldi	r24, 0x3C	; 60
     9a6:	96 e0       	ldi	r25, 0x06	; 6
     9a8:	0e 94 48 39 	call	0x7290	; 0x7290 <eeprom_write_block>
		 eeprom_write_block (FnKeyCodeLookUpTable, (void *) FN_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
     9ac:	40 e4       	ldi	r20, 0x40	; 64
     9ae:	50 e0       	ldi	r21, 0x00	; 0
     9b0:	60 e4       	ldi	r22, 0x40	; 64
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	8a e8       	ldi	r24, 0x8A	; 138
     9b6:	99 e0       	ldi	r25, 0x09	; 9
     9b8:	0e 94 48 39 	call	0x7290	; 0x7290 <eeprom_write_block>
		 eeprom_write_block (ShiftKeyCodeLookUpTable, (void *) SHIFT_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
     9bc:	40 e4       	ldi	r20, 0x40	; 64
     9be:	50 e0       	ldi	r21, 0x00	; 0
     9c0:	60 e8       	ldi	r22, 0x80	; 128
     9c2:	70 e0       	ldi	r23, 0x00	; 0
     9c4:	89 e8       	ldi	r24, 0x89	; 137
     9c6:	96 e0       	ldi	r25, 0x06	; 6
     9c8:	0e 94 48 39 	call	0x7290	; 0x7290 <eeprom_write_block>
		 eeprom_write_block (ASCIILookUpTable,(void *) ASCII_ADDR, KEYCODE_ARRAY_LENGTH);
     9cc:	40 e4       	ldi	r20, 0x40	; 64
     9ce:	50 e0       	ldi	r21, 0x00	; 0
     9d0:	60 ec       	ldi	r22, 0xC0	; 192
     9d2:	70 e0       	ldi	r23, 0x00	; 0
     9d4:	89 e4       	ldi	r24, 0x49	; 73
     9d6:	97 e0       	ldi	r25, 0x07	; 7
     9d8:	0e 94 48 39 	call	0x7290	; 0x7290 <eeprom_write_block>
		 eeprom_write_block (ASCIIShiftLookUpTable,(void *) ASCII_SHIFT_ADDR, KEYCODE_ARRAY_LENGTH);
     9dc:	40 e4       	ldi	r20, 0x40	; 64
     9de:	50 e0       	ldi	r21, 0x00	; 0
     9e0:	60 e0       	ldi	r22, 0x00	; 0
     9e2:	71 e0       	ldi	r23, 0x01	; 1
     9e4:	8a ec       	ldi	r24, 0xCA	; 202
     9e6:	96 e0       	ldi	r25, 0x06	; 6
     9e8:	0e 94 48 39 	call	0x7290	; 0x7290 <eeprom_write_block>
		 
		 eeprom_update_byte ((uint8_t *)SHIFT_REED_ADDR, Shift_Reed);
     9ec:	60 91 7e 06 	lds	r22, 0x067E
     9f0:	85 e0       	ldi	r24, 0x05	; 5
     9f2:	92 e0       	ldi	r25, 0x02	; 2
     9f4:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
		 
		 eeprom_update_byte ((uint8_t *)REED_1_POLARITY_ADDR,Reed1Polarity);
     9f8:	60 91 88 06 	lds	r22, 0x0688
     9fc:	86 e0       	ldi	r24, 0x06	; 6
     9fe:	92 e0       	ldi	r25, 0x02	; 2
     a00:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
		 eeprom_update_byte ((uint8_t *)REED_2_POLARITY_ADDR,Reed2Polarity);
     a04:	60 91 36 06 	lds	r22, 0x0636
     a08:	87 e0       	ldi	r24, 0x07	; 7
     a0a:	92 e0       	ldi	r25, 0x02	; 2
     a0c:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
		 eeprom_update_byte ((uint8_t *)REED_3_POLARITY_ADDR,Reed3Polarity);
     a10:	60 91 0a 07 	lds	r22, 0x070A
     a14:	88 e0       	ldi	r24, 0x08	; 8
     a16:	92 e0       	ldi	r25, 0x02	; 2
     a18:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
		 eeprom_update_byte ((uint8_t *)REED_4_POLARITY_ADDR,Reed4Polarity);
     a1c:	60 91 48 07 	lds	r22, 0x0748
     a20:	89 e0       	ldi	r24, 0x09	; 9
     a22:	92 e0       	ldi	r25, 0x02	; 2
     a24:	0c 94 36 39 	jmp	0x726c	; 0x726c <eeprom_update_byte>

00000a28 <DetectHallSensor>:
	TeachASCIIKey(' ',KeyPressed,LOWER); // ascii space key
	USBSend(KEY_ENTER,LOWER);
	
}

bool DetectHallSensor(){
     a28:	cf 93       	push	r28
     a2a:	df 93       	push	r29
	bool HallSensorTest1;
	bool HallSensorTest2;

	
			UseHallSensor = HALL_NOT_PRESENT;  //make sure the hall effect bit is not cleared as soon as it is read.
     a2c:	10 92 0b 07 	sts	0x070B, r1
			HallSensorTest1 = getHallState(); //sample the hall effect sensor bit
     a30:	0e 94 49 2b 	call	0x5692	; 0x5692 <getHallState>
     a34:	d8 2f       	mov	r29, r24
			USBSendPROGString(Str_Calibrate_Hall);
     a36:	89 ea       	ldi	r24, 0xA9	; 169
     a38:	93 e0       	ldi	r25, 0x03	; 3
     a3a:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
     a3e:	2f ef       	ldi	r18, 0xFF	; 255
     a40:	87 ea       	ldi	r24, 0xA7	; 167
     a42:	91 e6       	ldi	r25, 0x61	; 97
     a44:	21 50       	subi	r18, 0x01	; 1
     a46:	80 40       	sbci	r24, 0x00	; 0
     a48:	90 40       	sbci	r25, 0x00	; 0
     a4a:	e1 f7       	brne	.-8      	; 0xa44 <DetectHallSensor+0x1c>
     a4c:	00 c0       	rjmp	.+0      	; 0xa4e <DetectHallSensor+0x26>
     a4e:	00 00       	nop
			Delay_MS(4000);
			HallSensorTest2 = getHallState(); //sample it again
     a50:	0e 94 49 2b 	call	0x5692	; 0x5692 <getHallState>
     a54:	c8 2f       	mov	r28, r24
			if (HallSensorTest1 == HallSensorTest2){ //if it has not changed, hall effect sensor is not present.
     a56:	d8 13       	cpse	r29, r24
     a58:	07 c0       	rjmp	.+14     	; 0xa68 <DetectHallSensor+0x40>
				USBSendPROGString(Str_No_Hall);
     a5a:	88 e7       	ldi	r24, 0x78	; 120
     a5c:	93 e0       	ldi	r25, 0x03	; 3
     a5e:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
				UseHallSensor = HALL_NOT_PRESENT;
     a62:	10 92 0b 07 	sts	0x070B, r1
     a66:	23 c0       	rjmp	.+70     	; 0xaae <DetectHallSensor+0x86>
			}
			else{ // if it has changed, the "active" polarity of the hall effect sensor is HallSensorTest2
				USBSendString("Hall Sensor Detected!\r");
     a68:	89 ec       	ldi	r24, 0xC9	; 201
     a6a:	91 e0       	ldi	r25, 0x01	; 1
     a6c:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
				UseHallSensor = HALL_NOT_ACTIVE;
     a70:	81 e0       	ldi	r24, 0x01	; 1
     a72:	80 93 0b 07 	sts	0x070B, r24
				HallSensorPolarity = HallSensorTest2;
     a76:	c0 93 86 06 	sts	0x0686, r28
				USBSendString("Press CTRL key now to activate Hall Sensor...");
     a7a:	80 ee       	ldi	r24, 0xE0	; 224
     a7c:	91 e0       	ldi	r25, 0x01	; 1
     a7e:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
     a82:	83 e6       	ldi	r24, 0x63	; 99
     a84:	90 e0       	ldi	r25, 0x00	; 0
				for (int i=1; i < 100; i++){
					if(is_low(CTRL_KEY)) UseHallSensor = HALL_ACTIVE; 
     a86:	22 e0       	ldi	r18, 0x02	; 2
     a88:	7c 9b       	sbis	0x0f, 4	; 15
     a8a:	20 93 0b 07 	sts	0x070B, r18
     a8e:	ef e5       	ldi	r30, 0x5F	; 95
     a90:	fa ee       	ldi	r31, 0xEA	; 234
     a92:	31 97       	sbiw	r30, 0x01	; 1
     a94:	f1 f7       	brne	.-4      	; 0xa92 <DetectHallSensor+0x6a>
     a96:	00 c0       	rjmp	.+0      	; 0xa98 <DetectHallSensor+0x70>
     a98:	00 00       	nop
     a9a:	01 97       	sbiw	r24, 0x01	; 1
			else{ // if it has changed, the "active" polarity of the hall effect sensor is HallSensorTest2
				USBSendString("Hall Sensor Detected!\r");
				UseHallSensor = HALL_NOT_ACTIVE;
				HallSensorPolarity = HallSensorTest2;
				USBSendString("Press CTRL key now to activate Hall Sensor...");
				for (int i=1; i < 100; i++){
     a9c:	a9 f7       	brne	.-22     	; 0xa88 <DetectHallSensor+0x60>
					if(is_low(CTRL_KEY)) UseHallSensor = HALL_ACTIVE; 
					Delay_MS(30);
				}
				if (UseHallSensor == HALL_ACTIVE) USBSendString("\rHall Sensor Activated!\r");
     a9e:	80 91 0b 07 	lds	r24, 0x070B
     aa2:	82 30       	cpi	r24, 0x02	; 2
     aa4:	21 f4       	brne	.+8      	; 0xaae <DetectHallSensor+0x86>
     aa6:	8e e0       	ldi	r24, 0x0E	; 14
     aa8:	92 e0       	ldi	r25, 0x02	; 2
     aaa:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
			}
			
			if(is_low(CMD_KEY)){
     aae:	7e 99       	sbic	0x0f, 6	; 15
     ab0:	03 c0       	rjmp	.+6      	; 0xab8 <DetectHallSensor+0x90>
				UseHallSensor = HALL_NOT_ACTIVE; //In the event that the hall sensor is acting erratically or not at all, holding CMD can force it off.
     ab2:	81 e0       	ldi	r24, 0x01	; 1
     ab4:	80 93 0b 07 	sts	0x070B, r24
			}
			
			/*Save the hall effect parameters to eeprom right away:*/
			eeprom_update_byte ((uint8_t *)USE_HALL_SENSOR_ADDR, UseHallSensor);
     ab8:	60 91 0b 07 	lds	r22, 0x070B
     abc:	83 e0       	ldi	r24, 0x03	; 3
     abe:	92 e0       	ldi	r25, 0x02	; 2
     ac0:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
			eeprom_update_byte ((uint8_t *)HALL_SENSOR_POLARITY_ADDR, HallSensorPolarity);
     ac4:	60 91 86 06 	lds	r22, 0x0686
     ac8:	84 e0       	ldi	r24, 0x04	; 4
     aca:	92 e0       	ldi	r25, 0x02	; 2
     acc:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
			
			return UseHallSensor;
     ad0:	81 e0       	ldi	r24, 0x01	; 1
     ad2:	90 91 0b 07 	lds	r25, 0x070B
     ad6:	91 11       	cpse	r25, r1
     ad8:	01 c0       	rjmp	.+2      	; 0xadc <DetectHallSensor+0xb4>
     ada:	80 e0       	ldi	r24, 0x00	; 0
}
     adc:	df 91       	pop	r29
     ade:	cf 91       	pop	r28
     ae0:	08 95       	ret

00000ae2 <WaitForKeypress>:
     ae2:	2f ef       	ldi	r18, 0xFF	; 255
     ae4:	81 ee       	ldi	r24, 0xE1	; 225
     ae6:	94 e0       	ldi	r25, 0x04	; 4
     ae8:	21 50       	subi	r18, 0x01	; 1
     aea:	80 40       	sbci	r24, 0x00	; 0
     aec:	90 40       	sbci	r25, 0x00	; 0
     aee:	e1 f7       	brne	.-8      	; 0xae8 <WaitForKeypress+0x6>
     af0:	00 c0       	rjmp	.+0      	; 0xaf2 <WaitForKeypress+0x10>
     af2:	00 00       	nop
	int KeyPressed = 0;
	
	Delay_MS(200);//implement 500 MS delay before detecting a key.  (prevents rapid re-detection of keys over and over.
	
	while(KeyPressed == 0){ //keep getting a key until there is a key to get.
		KeyPressed = GetKeySimple();
     af4:	0e 94 b2 29 	call	0x5364	; 0x5364 <GetKeySimple>
     af8:	90 e0       	ldi	r25, 0x00	; 0
int WaitForKeypress(){
	int KeyPressed = 0;
	
	Delay_MS(200);//implement 500 MS delay before detecting a key.  (prevents rapid re-detection of keys over and over.
	
	while(KeyPressed == 0){ //keep getting a key until there is a key to get.
     afa:	00 97       	sbiw	r24, 0x00	; 0
     afc:	d9 f3       	breq	.-10     	; 0xaf4 <WaitForKeypress+0x12>
		KeyPressed = GetKeySimple();
	}
	return KeyPressed;
}
     afe:	08 95       	ret

00000b00 <TeachHIDKey>:
	
	
void TeachHIDKey(char teachkey, int keypressed, char Modifier){
     b00:	cf 93       	push	r28
     b02:	df 93       	push	r29
     b04:	eb 01       	movw	r28, r22
	if (Modifier == UPPER){
		ShiftKeyCodeLookUpTable[keypressed] = teachkey;
     b06:	fb 01       	movw	r30, r22
	return KeyPressed;
}
	
	
void TeachHIDKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
     b08:	42 30       	cpi	r20, 0x02	; 2
     b0a:	31 f4       	brne	.+12     	; 0xb18 <TeachHIDKey+0x18>
		ShiftKeyCodeLookUpTable[keypressed] = teachkey;
     b0c:	e7 57       	subi	r30, 0x77	; 119
     b0e:	f9 4f       	sbci	r31, 0xF9	; 249
     b10:	80 83       	st	Z, r24
		USBSendString("SHIFT");
     b12:	87 e2       	ldi	r24, 0x27	; 39
     b14:	92 e0       	ldi	r25, 0x02	; 2
     b16:	07 c0       	rjmp	.+14     	; 0xb26 <TeachHIDKey+0x26>
		USBSend(KEY_EQ,UPPER); //send a + sign
		USBSendNumber(keypressed);
	}
	else if (Modifier == HID_KEYBOARD_MODIFIER_LEFTALT){ //if FN is being held down,
     b18:	44 30       	cpi	r20, 0x04	; 4
     b1a:	61 f4       	brne	.+24     	; 0xb34 <TeachHIDKey+0x34>
		FnKeyCodeLookUpTable[keypressed] = teachkey;
     b1c:	e6 57       	subi	r30, 0x76	; 118
     b1e:	f6 4f       	sbci	r31, 0xF6	; 246
     b20:	80 83       	st	Z, r24
		//send "FN+number"
		USBSendString("FN");
     b22:	8d e2       	ldi	r24, 0x2D	; 45
     b24:	92 e0       	ldi	r25, 0x02	; 2
     b26:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
		USBSend(KEY_EQ,UPPER); //send a + sign
     b2a:	62 e0       	ldi	r22, 0x02	; 2
     b2c:	8e e2       	ldi	r24, 0x2E	; 46
     b2e:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
     b32:	03 c0       	rjmp	.+6      	; 0xb3a <TeachHIDKey+0x3a>
		USBSendNumber(keypressed);
	}
	else{
		KeyCodeLookUpTable[keypressed] = teachkey;
     b34:	e4 5c       	subi	r30, 0xC4	; 196
     b36:	f9 4f       	sbci	r31, 0xF9	; 249
     b38:	80 83       	st	Z, r24
		USBSendNumber(keypressed);
     b3a:	8c 2f       	mov	r24, r28
     b3c:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
     b40:	2f ef       	ldi	r18, 0xFF	; 255
     b42:	84 e3       	ldi	r24, 0x34	; 52
     b44:	9c e0       	ldi	r25, 0x0C	; 12
     b46:	21 50       	subi	r18, 0x01	; 1
     b48:	80 40       	sbci	r24, 0x00	; 0
     b4a:	90 40       	sbci	r25, 0x00	; 0
     b4c:	e1 f7       	brne	.-8      	; 0xb46 <TeachHIDKey+0x46>
     b4e:	00 c0       	rjmp	.+0      	; 0xb50 <TeachHIDKey+0x50>
     b50:	00 00       	nop
	}
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}
     b52:	df 91       	pop	r29
     b54:	cf 91       	pop	r28
     b56:	08 95       	ret

00000b58 <CalibrateReeds>:
		 eeprom_update_byte ((uint8_t *)REED_2_POLARITY_ADDR,Reed2Polarity);
		 eeprom_update_byte ((uint8_t *)REED_3_POLARITY_ADDR,Reed3Polarity);
		 eeprom_update_byte ((uint8_t *)REED_4_POLARITY_ADDR,Reed4Polarity);
}

void CalibrateReeds(){	
     b58:	1f 93       	push	r17
     b5a:	cf 93       	push	r28
     b5c:	df 93       	push	r29
	uint8_t Modifier;
	uint8_t KeyPressed;
	
//-------TEACH BACKSPACE KEY ---------
	USBSendPROGString(Str_Backspace);
     b5e:	8f ed       	ldi	r24, 0xDF	; 223
     b60:	93 e0       	ldi	r25, 0x03	; 3
     b62:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSend(KEY_SPACE,LOWER);
     b66:	60 e0       	ldi	r22, 0x00	; 0
     b68:	8c e2       	ldi	r24, 0x2C	; 44
     b6a:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
     b6e:	b9 df       	rcall	.-142    	; 0xae2 <WaitForKeypress>
     b70:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
     b72:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
     b76:	18 2f       	mov	r17, r24
	
	TeachHIDKey(KEY_BACKSPACE,KeyPressed,Modifier); 
     b78:	dd 27       	eor	r29, r29
     b7a:	48 2f       	mov	r20, r24
     b7c:	be 01       	movw	r22, r28
     b7e:	8a e2       	ldi	r24, 0x2A	; 42
     b80:	bf df       	rcall	.-130    	; 0xb00 <TeachHIDKey>
	if (!(Modifier & FN_MODIFIER)){//sd card does not use fn modifier.
     b82:	12 fd       	sbrc	r17, 2
     b84:	04 c0       	rjmp	.+8      	; 0xb8e <CalibrateReeds+0x36>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     b86:	c7 5b       	subi	r28, 0xB7	; 183
     b88:	d8 4f       	sbci	r29, 0xF8	; 248
     b8a:	88 e0       	ldi	r24, 0x08	; 8
     b8c:	88 83       	st	Y, r24
	
	TeachHIDKey(KEY_BACKSPACE,KeyPressed,Modifier); 
	if (!(Modifier & FN_MODIFIER)){//sd card does not use fn modifier.
		TeachASCIIKey(8,KeyPressed,LOWER); // 8 is ascii backspace
	}
	USBSend(KEY_ENTER,LOWER);
     b8e:	60 e0       	ldi	r22, 0x00	; 0
     b90:	88 e2       	ldi	r24, 0x28	; 40
     b92:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
//------TEACH ESC KEY ----------
	USBSendString("ESC");
     b96:	80 e3       	ldi	r24, 0x30	; 48
     b98:	92 e0       	ldi	r25, 0x02	; 2
     b9a:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
	USBSend(KEY_SPACE,LOWER);
     b9e:	60 e0       	ldi	r22, 0x00	; 0
     ba0:	8c e2       	ldi	r24, 0x2C	; 44
     ba2:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
     ba6:	9d df       	rcall	.-198    	; 0xae2 <WaitForKeypress>
     ba8:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
     baa:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
	TeachHIDKey(KEY_ESC,KeyPressed,Modifier); 
     bae:	be 01       	movw	r22, r28
     bb0:	77 27       	eor	r23, r23
     bb2:	48 2f       	mov	r20, r24
     bb4:	89 e2       	ldi	r24, 0x29	; 41
     bb6:	a4 df       	rcall	.-184    	; 0xb00 <TeachHIDKey>
	//no ascii character stored for this key.
	USBSend(KEY_ENTER,LOWER);
     bb8:	60 e0       	ldi	r22, 0x00	; 0
     bba:	88 e2       	ldi	r24, 0x28	; 40
     bbc:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
	//------TEACH TAB KEY ---------
	USBSendString("TAB");
     bc0:	84 e3       	ldi	r24, 0x34	; 52
     bc2:	92 e0       	ldi	r25, 0x02	; 2
     bc4:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
	USBSend(KEY_SPACE,LOWER);
     bc8:	60 e0       	ldi	r22, 0x00	; 0
     bca:	8c e2       	ldi	r24, 0x2C	; 44
     bcc:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
     bd0:	88 df       	rcall	.-240    	; 0xae2 <WaitForKeypress>
     bd2:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
     bd4:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
     bd8:	18 2f       	mov	r17, r24
	TeachHIDKey(KEY_TAB,KeyPressed,Modifier);
     bda:	dd 27       	eor	r29, r29
     bdc:	48 2f       	mov	r20, r24
     bde:	be 01       	movw	r22, r28
     be0:	8b e2       	ldi	r24, 0x2B	; 43
     be2:	8e df       	rcall	.-228    	; 0xb00 <TeachHIDKey>
	
	if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
     be4:	12 fd       	sbrc	r17, 2
     be6:	09 c0       	rjmp	.+18     	; 0xbfa <CalibrateReeds+0xa2>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     be8:	fe 01       	movw	r30, r28
     bea:	e7 5b       	subi	r30, 0xB7	; 183
     bec:	f8 4f       	sbci	r31, 0xF8	; 248
     bee:	89 e0       	ldi	r24, 0x09	; 9
     bf0:	80 83       	st	Z, r24
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
     bf2:	c6 53       	subi	r28, 0x36	; 54
     bf4:	d9 4f       	sbci	r29, 0xF9	; 249
     bf6:	84 e7       	ldi	r24, 0x74	; 116
     bf8:	88 83       	st	Y, r24
	if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
		TeachASCIIKey('\t',KeyPressed,LOWER); // tab key
		TeachASCIIKey('t',KeyPressed,UPPER); //tab key + shift is still tab
	}

	USBSend(KEY_ENTER,LOWER);
     bfa:	60 e0       	ldi	r22, 0x00	; 0
     bfc:	88 e2       	ldi	r24, 0x28	; 40
     bfe:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
//--------TEACH ENTER KEY --------
	USBSendPROGString(Str_Enter);
     c02:	8e ef       	ldi	r24, 0xFE	; 254
     c04:	93 e0       	ldi	r25, 0x03	; 3
     c06:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSend(KEY_SPACE,LOWER);// used to be a colon
     c0a:	60 e0       	ldi	r22, 0x00	; 0
     c0c:	8c e2       	ldi	r24, 0x2C	; 44
     c0e:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
     c12:	67 df       	rcall	.-306    	; 0xae2 <WaitForKeypress>
	
	//Enter key cannot use modifiers
	TeachHIDKey(KEY_ENTER, KeyPressed, LOWER); //teach the hid keycode array about this key.
     c14:	ec 01       	movw	r28, r24
     c16:	dd 27       	eor	r29, r29
		USBSendString("FN");
		USBSend(KEY_EQ,UPPER); //send a + sign
		USBSendNumber(keypressed);
	}
	else{
		KeyCodeLookUpTable[keypressed] = teachkey;
     c18:	fe 01       	movw	r30, r28
     c1a:	e4 5c       	subi	r30, 0xC4	; 196
     c1c:	f9 4f       	sbci	r31, 0xF9	; 249
     c1e:	18 e2       	ldi	r17, 0x28	; 40
     c20:	10 83       	st	Z, r17
		USBSendNumber(keypressed);
     c22:	8c 2f       	mov	r24, r28
     c24:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
     c28:	2f ef       	ldi	r18, 0xFF	; 255
     c2a:	84 e3       	ldi	r24, 0x34	; 52
     c2c:	9c e0       	ldi	r25, 0x0C	; 12
     c2e:	21 50       	subi	r18, 0x01	; 1
     c30:	80 40       	sbci	r24, 0x00	; 0
     c32:	90 40       	sbci	r25, 0x00	; 0
     c34:	e1 f7       	brne	.-8      	; 0xc2e <CalibrateReeds+0xd6>
     c36:	00 c0       	rjmp	.+0      	; 0xc38 <CalibrateReeds+0xe0>
     c38:	00 00       	nop
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     c3a:	c7 5b       	subi	r28, 0xB7	; 183
     c3c:	d8 4f       	sbci	r29, 0xF8	; 248
     c3e:	8d e0       	ldi	r24, 0x0D	; 13
     c40:	88 83       	st	Y, r24
	KeyPressed = WaitForKeypress();
	
	//Enter key cannot use modifiers
	TeachHIDKey(KEY_ENTER, KeyPressed, LOWER); //teach the hid keycode array about this key.
	TeachASCIIKey('\r',KeyPressed, LOWER);//return carriage for ascii users
	USBSend(KEY_ENTER,LOWER);
     c42:	60 e0       	ldi	r22, 0x00	; 0
     c44:	88 e2       	ldi	r24, 0x28	; 40
     c46:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
//-------TEACH SECONDARY ENTER KEY ----------
	
	USBSendPROGString(Str_Second_Enter);
     c4a:	8e ee       	ldi	r24, 0xEE	; 238
     c4c:	93 e0       	ldi	r25, 0x03	; 3
     c4e:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSend(KEY_SPACE,LOWER);// used to be a colon
     c52:	60 e0       	ldi	r22, 0x00	; 0
     c54:	8c e2       	ldi	r24, 0x2C	; 44
     c56:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress(KEY_EXECUTE);
     c5a:	84 e7       	ldi	r24, 0x74	; 116
     c5c:	90 e0       	ldi	r25, 0x00	; 0
     c5e:	41 df       	rcall	.-382    	; 0xae2 <WaitForKeypress>
	
	//Enter key cannot use modifiers
	TeachHIDKey(KEY_ENTER, KeyPressed, LOWER); //teach the hid keycode array about this key.
     c60:	99 27       	eor	r25, r25
		USBSendString("FN");
		USBSend(KEY_EQ,UPPER); //send a + sign
		USBSendNumber(keypressed);
	}
	else{
		KeyCodeLookUpTable[keypressed] = teachkey;
     c62:	fc 01       	movw	r30, r24
     c64:	e4 5c       	subi	r30, 0xC4	; 196
     c66:	f9 4f       	sbci	r31, 0xF9	; 249
     c68:	10 83       	st	Z, r17
		USBSendNumber(keypressed);
     c6a:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
     c6e:	2f ef       	ldi	r18, 0xFF	; 255
     c70:	84 e3       	ldi	r24, 0x34	; 52
     c72:	9c e0       	ldi	r25, 0x0C	; 12
     c74:	21 50       	subi	r18, 0x01	; 1
     c76:	80 40       	sbci	r24, 0x00	; 0
     c78:	90 40       	sbci	r25, 0x00	; 0
     c7a:	e1 f7       	brne	.-8      	; 0xc74 <CalibrateReeds+0x11c>
     c7c:	00 c0       	rjmp	.+0      	; 0xc7e <CalibrateReeds+0x126>
     c7e:	00 00       	nop
	USBSend(KEY_SPACE,LOWER);// used to be a colon
	KeyPressed = WaitForKeypress(KEY_EXECUTE);
	
	//Enter key cannot use modifiers
	TeachHIDKey(KEY_ENTER, KeyPressed, LOWER); //teach the hid keycode array about this key.
	USBSend(KEY_ENTER,LOWER);
     c80:	60 e0       	ldi	r22, 0x00	; 0
     c82:	88 e2       	ldi	r24, 0x28	; 40
     c84:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
// -------TEACH SEND KEY --------------
	USBSendPROGString(Str_Post);
     c88:	89 ee       	ldi	r24, 0xE9	; 233
     c8a:	93 e0       	ldi	r25, 0x03	; 3
     c8c:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSend(KEY_SPACE,LOWER);// used to be a colon
     c90:	60 e0       	ldi	r22, 0x00	; 0
     c92:	8c e2       	ldi	r24, 0x2C	; 44
     c94:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
     c98:	24 df       	rcall	.-440    	; 0xae2 <WaitForKeypress>
	TeachHIDKey(KEY_EXECUTE, KeyPressed, LOWER); //teach the hid keycode array about this key.
     c9a:	99 27       	eor	r25, r25
		USBSendString("FN");
		USBSend(KEY_EQ,UPPER); //send a + sign
		USBSendNumber(keypressed);
	}
	else{
		KeyCodeLookUpTable[keypressed] = teachkey;
     c9c:	fc 01       	movw	r30, r24
     c9e:	e4 5c       	subi	r30, 0xC4	; 196
     ca0:	f9 4f       	sbci	r31, 0xF9	; 249
     ca2:	94 e7       	ldi	r25, 0x74	; 116
     ca4:	90 83       	st	Z, r25
		USBSendNumber(keypressed);
     ca6:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
     caa:	2f ef       	ldi	r18, 0xFF	; 255
     cac:	84 e3       	ldi	r24, 0x34	; 52
     cae:	9c e0       	ldi	r25, 0x0C	; 12
     cb0:	21 50       	subi	r18, 0x01	; 1
     cb2:	80 40       	sbci	r24, 0x00	; 0
     cb4:	90 40       	sbci	r25, 0x00	; 0
     cb6:	e1 f7       	brne	.-8      	; 0xcb0 <CalibrateReeds+0x158>
     cb8:	00 c0       	rjmp	.+0      	; 0xcba <CalibrateReeds+0x162>
     cba:	00 00       	nop
// -------TEACH SEND KEY --------------
	USBSendPROGString(Str_Post);
	USBSend(KEY_SPACE,LOWER);// used to be a colon
	KeyPressed = WaitForKeypress();
	TeachHIDKey(KEY_EXECUTE, KeyPressed, LOWER); //teach the hid keycode array about this key.
	USBSend(KEY_ENTER,LOWER);
     cbc:	60 e0       	ldi	r22, 0x00	; 0
     cbe:	88 e2       	ldi	r24, 0x28	; 40
     cc0:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
//------TEACH SPACE BAR ---- must be the last thing programmed (because of "Press space to skip" instruction)
	USBSendPROGString(Str_Spacebar);
     cc4:	84 e0       	ldi	r24, 0x04	; 4
     cc6:	94 e0       	ldi	r25, 0x04	; 4
     cc8:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSend(KEY_SPACE,LOWER);
     ccc:	60 e0       	ldi	r22, 0x00	; 0
     cce:	8c e2       	ldi	r24, 0x2C	; 44
     cd0:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
     cd4:	06 df       	rcall	.-500    	; 0xae2 <WaitForKeypress>
	
	TeachHIDKey(KEY_SPACE,KeyPressed,LOWER); //space bar is independent of modifier.
     cd6:	ec 01       	movw	r28, r24
     cd8:	dd 27       	eor	r29, r29
		USBSendString("FN");
		USBSend(KEY_EQ,UPPER); //send a + sign
		USBSendNumber(keypressed);
	}
	else{
		KeyCodeLookUpTable[keypressed] = teachkey;
     cda:	fe 01       	movw	r30, r28
     cdc:	e4 5c       	subi	r30, 0xC4	; 196
     cde:	f9 4f       	sbci	r31, 0xF9	; 249
     ce0:	8c e2       	ldi	r24, 0x2C	; 44
     ce2:	80 83       	st	Z, r24
		USBSendNumber(keypressed);
     ce4:	8c 2f       	mov	r24, r28
     ce6:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
     cea:	2f ef       	ldi	r18, 0xFF	; 255
     cec:	84 e3       	ldi	r24, 0x34	; 52
     cee:	9c e0       	ldi	r25, 0x0C	; 12
     cf0:	21 50       	subi	r18, 0x01	; 1
     cf2:	80 40       	sbci	r24, 0x00	; 0
     cf4:	90 40       	sbci	r25, 0x00	; 0
     cf6:	e1 f7       	brne	.-8      	; 0xcf0 <CalibrateReeds+0x198>
     cf8:	00 c0       	rjmp	.+0      	; 0xcfa <CalibrateReeds+0x1a2>
     cfa:	00 00       	nop
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     cfc:	c7 5b       	subi	r28, 0xB7	; 183
     cfe:	d8 4f       	sbci	r29, 0xF8	; 248
     d00:	80 e2       	ldi	r24, 0x20	; 32
     d02:	88 83       	st	Y, r24
	USBSend(KEY_SPACE,LOWER);
	KeyPressed = WaitForKeypress();
	
	TeachHIDKey(KEY_SPACE,KeyPressed,LOWER); //space bar is independent of modifier.
	TeachASCIIKey(' ',KeyPressed,LOWER); // ascii space key
	USBSend(KEY_ENTER,LOWER);
     d04:	60 e0       	ldi	r22, 0x00	; 0
     d06:	88 e2       	ldi	r24, 0x28	; 40
	
}
     d08:	df 91       	pop	r29
     d0a:	cf 91       	pop	r28
     d0c:	1f 91       	pop	r17
	USBSend(KEY_SPACE,LOWER);
	KeyPressed = WaitForKeypress();
	
	TeachHIDKey(KEY_SPACE,KeyPressed,LOWER); //space bar is independent of modifier.
	TeachASCIIKey(' ',KeyPressed,LOWER); // ascii space key
	USBSend(KEY_ENTER,LOWER);
     d0e:	0c 94 6c 27 	jmp	0x4ed8	; 0x4ed8 <USBSend>

00000d12 <QuickCalibrate>:

void QuickCalibrate(){
	uint8_t KeyPressed; //
	
	
	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
     d12:	80 91 ce 09 	lds	r24, 0x09CE
     d16:	84 30       	cpi	r24, 0x04	; 4
     d18:	e1 f7       	brne	.-8      	; 0xd12 <QuickCalibrate>
     d1a:	2f ef       	ldi	r18, 0xFF	; 255
     d1c:	89 e6       	ldi	r24, 0x69	; 105
     d1e:	98 e1       	ldi	r25, 0x18	; 24
     d20:	21 50       	subi	r18, 0x01	; 1
     d22:	80 40       	sbci	r24, 0x00	; 0
     d24:	90 40       	sbci	r25, 0x00	; 0
     d26:	e1 f7       	brne	.-8      	; 0xd20 <QuickCalibrate+0xe>
     d28:	00 c0       	rjmp	.+0      	; 0xd2a <QuickCalibrate+0x18>
     d2a:	00 00       	nop
	Delay_MS(1000);//wait 1 second.
	
	USBSendPROGString(Str_Quick_Calibrate);
     d2c:	8d e0       	ldi	r24, 0x0D	; 13
     d2e:	94 e0       	ldi	r25, 0x04	; 4
     d30:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	
	/*Measure the reed switch polarities*/
	Reed1Polarity = is_low(REED_1); //if reed_1 is low at start of calibration, then the polarity of reed 1 is active high
     d34:	99 b1       	in	r25, 0x09	; 9
     d36:	81 e0       	ldi	r24, 0x01	; 1
     d38:	92 95       	swap	r25
     d3a:	91 70       	andi	r25, 0x01	; 1
     d3c:	98 27       	eor	r25, r24
     d3e:	90 93 88 06 	sts	0x0688, r25
	Reed2Polarity= is_low(REED_2);
     d42:	99 b1       	in	r25, 0x09	; 9
     d44:	96 fb       	bst	r25, 6
     d46:	99 27       	eor	r25, r25
     d48:	90 f9       	bld	r25, 0
     d4a:	98 27       	eor	r25, r24
     d4c:	90 93 36 06 	sts	0x0636, r25
	Reed3Polarity = is_low(REED_3);
     d50:	99 b1       	in	r25, 0x09	; 9
     d52:	90 95       	com	r25
     d54:	99 1f       	adc	r25, r25
     d56:	99 27       	eor	r25, r25
     d58:	99 1f       	adc	r25, r25
     d5a:	90 93 0a 07 	sts	0x070A, r25
	Reed4Polarity = is_low(REED_4);
     d5e:	93 b1       	in	r25, 0x03	; 3
     d60:	92 95       	swap	r25
     d62:	91 70       	andi	r25, 0x01	; 1
     d64:	89 27       	eor	r24, r25
     d66:	80 93 48 07 	sts	0x0748, r24
	
	
	
	//Find out if user wants to use the hall effect sensor (probably not).
	DetectHallSensor();
     d6a:	5e de       	rcall	.-836    	; 0xa28 <DetectHallSensor>

	USBSendPROGString(Str_Type_The_Following);
     d6c:	84 ec       	ldi	r24, 0xC4	; 196
     d6e:	94 e0       	ldi	r25, 0x04	; 4
     d70:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>

	//--------TEACH SHIFT KEY-----------
	USBSendString("SHIFT");
     d74:	87 e2       	ldi	r24, 0x27	; 39
     d76:	92 e0       	ldi	r25, 0x02	; 2
     d78:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
	Shift_Reed = 0; //reset the shift reed to 0 (undefined) so that WaitForKeypress() doesn't ignore any of the reeds
     d7c:	10 92 7e 06 	sts	0x067E, r1
	USBSend(KEY_SPACE,LOWER);// used to be a colon
     d80:	60 e0       	ldi	r22, 0x00	; 0
     d82:	8c e2       	ldi	r24, 0x2C	; 44
     d84:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
     d88:	ac de       	rcall	.-680    	; 0xae2 <WaitForKeypress>
	if((KeyPressed)&&(KeyPressed <= 8)){ //if keypressed is 1, 2, 3, or 4, it represents a reed switch being held down.
     d8a:	9f ef       	ldi	r25, 0xFF	; 255
     d8c:	98 0f       	add	r25, r24
     d8e:	98 30       	cpi	r25, 0x08	; 8
     d90:	28 f4       	brcc	.+10     	; 0xd9c <QuickCalibrate+0x8a>
		Shift_Reed = KeyPressed;
     d92:	80 93 7e 06 	sts	0x067E, r24
		USBSendNumber(Shift_Reed);
     d96:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
     d9a:	04 c0       	rjmp	.+8      	; 0xda4 <QuickCalibrate+0x92>
	}
	else{
		USBSendPROGString(Str_Shift_Error);
     d9c:	8e e9       	ldi	r24, 0x9E	; 158
     d9e:	94 e0       	ldi	r25, 0x04	; 4
     da0:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	}
	USBSend(KEY_ENTER,LOWER);
     da4:	60 e0       	ldi	r22, 0x00	; 0
     da6:	88 e2       	ldi	r24, 0x28	; 40
     da8:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
	CalibrateReeds();
     dac:	d5 de       	rcall	.-598    	; 0xb58 <CalibrateReeds>
	
	SaveCalibration();
     dae:	f2 dd       	rcall	.-1052   	; 0x994 <SaveCalibration>
	
	USBSendPROGString(Str_Settings_Saved);
     db0:	87 e6       	ldi	r24, 0x67	; 103
     db2:	92 e0       	ldi	r25, 0x02	; 2
     db4:	0c 94 28 28 	jmp	0x5050	; 0x5050 <USBSendPROGString>

00000db8 <TeachASCIIKey>:
	}
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
     db8:	42 30       	cpi	r20, 0x02	; 2
     dba:	21 f4       	brne	.+8      	; 0xdc4 <TeachASCIIKey+0xc>
		ASCIIShiftLookUpTable[keypressed] = teachkey;
     dbc:	fb 01       	movw	r30, r22
     dbe:	e6 53       	subi	r30, 0x36	; 54
     dc0:	f9 4f       	sbci	r31, 0xF9	; 249
     dc2:	05 c0       	rjmp	.+10     	; 0xdce <TeachASCIIKey+0x16>
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
     dc4:	42 fd       	sbrc	r20, 2
     dc6:	04 c0       	rjmp	.+8      	; 0xdd0 <TeachASCIIKey+0x18>
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     dc8:	fb 01       	movw	r30, r22
     dca:	e7 5b       	subi	r30, 0xB7	; 183
     dcc:	f8 4f       	sbci	r31, 0xF8	; 248
     dce:	80 83       	st	Z, r24
     dd0:	08 95       	ret

00000dd2 <Calibrate_Manually>:
		else {USBSendASCII(code);\
		USBSend(KEY_ENTER,LOWER);\
		}\
	}

void Calibrate_Manually(){
     dd2:	0f 93       	push	r16
     dd4:	1f 93       	push	r17
     dd6:	cf 93       	push	r28
	uint8_t codeend2;
	uint8_t keypressed;
	uint8_t modifier;
	char edit_mode = 's';
	
	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
     dd8:	80 91 ce 09 	lds	r24, 0x09CE
     ddc:	84 30       	cpi	r24, 0x04	; 4
     dde:	e1 f7       	brne	.-8      	; 0xdd8 <Calibrate_Manually+0x6>
     de0:	2f ef       	ldi	r18, 0xFF	; 255
     de2:	89 e6       	ldi	r24, 0x69	; 105
     de4:	98 e1       	ldi	r25, 0x18	; 24
     de6:	21 50       	subi	r18, 0x01	; 1
     de8:	80 40       	sbci	r24, 0x00	; 0
     dea:	90 40       	sbci	r25, 0x00	; 0
     dec:	e1 f7       	brne	.-8      	; 0xde6 <Calibrate_Manually+0x14>
     dee:	00 c0       	rjmp	.+0      	; 0xdf0 <Calibrate_Manually+0x1e>
     df0:	00 00       	nop
	Delay_MS(1000);
		
	//tell user what is up
	USBSendPROGString(Str_Manual_Calibration);
     df2:	8b e4       	ldi	r24, 0x4B	; 75
     df4:	92 e0       	ldi	r25, 0x02	; 2
     df6:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSendPROGString(Str_U_For_USB);
     dfa:	8a e1       	ldi	r24, 0x1A	; 26
     dfc:	92 e0       	ldi	r25, 0x02	; 2
     dfe:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSendPROGString(Str_S_For_SD);
     e02:	8d ee       	ldi	r24, 0xED	; 237
     e04:	91 e0       	ldi	r25, 0x01	; 1
     e06:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
//  edit_mode = Get_User_Response();
	USBSendPROGString(Str_How_To_Scroll);
     e0a:	83 ec       	ldi	r24, 0xC3	; 195
     e0c:	91 e0       	ldi	r25, 0x01	; 1
     e0e:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSendPROGString(Str_How_To_Select);
     e12:	81 ea       	ldi	r24, 0xA1	; 161
     e14:	91 e0       	ldi	r25, 0x01	; 1
     e16:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSendPROGString(Str_How_To_Exit);
     e1a:	84 e8       	ldi	r24, 0x84	; 132
     e1c:	91 e0       	ldi	r25, 0x01	; 1
     e1e:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
		codeend2 = 0xFF;
	}
	
	code = codestart1;
	if (edit_mode == 'u'){USBSend(code,LOWER);}
	else {USBSendASCII(code);}
     e22:	81 e2       	ldi	r24, 0x21	; 33
     e24:	0e 94 76 28 	call	0x50ec	; 0x50ec <USBSendASCII>
	USBSend(KEY_ENTER,LOWER);
     e28:	60 e0       	ldi	r22, 0x00	; 0
     e2a:	88 e2       	ldi	r24, 0x28	; 40
     e2c:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
		codeend1 = 0x7E;
		codestart2 = 0xBC;
		codeend2 = 0xFF;
	}
	
	code = codestart1;
     e30:	c1 e2       	ldi	r28, 0x21	; 33
	if (edit_mode == 'u'){USBSend(code,LOWER);}
	else {USBSendASCII(code);}
	USBSend(KEY_ENTER,LOWER);
	
	while(is_high(CMD_KEY)){
     e32:	7e 9b       	sbis	0x0f, 6	; 15
     e34:	49 c0       	rjmp	.+146    	; 0xec8 <Calibrate_Manually+0xf6>
		if(is_low(CTRL_KEY)){
     e36:	7c 99       	sbic	0x0f, 4	; 15
     e38:	18 c0       	rjmp	.+48     	; 0xe6a <Calibrate_Manually+0x98>
			INCREMENT_CODE();
     e3a:	81 e0       	ldi	r24, 0x01	; 1
     e3c:	8c 0f       	add	r24, r28
     e3e:	ce 57       	subi	r28, 0x7E	; 126
     e40:	cd 33       	cpi	r28, 0x3D	; 61
     e42:	10 f0       	brcs	.+4      	; 0xe48 <Calibrate_Manually+0x76>
     e44:	c8 2f       	mov	r28, r24
     e46:	01 c0       	rjmp	.+2      	; 0xe4a <Calibrate_Manually+0x78>
     e48:	cc eb       	ldi	r28, 0xBC	; 188
     e4a:	8c 2f       	mov	r24, r28
     e4c:	0e 94 76 28 	call	0x50ec	; 0x50ec <USBSendASCII>
     e50:	60 e0       	ldi	r22, 0x00	; 0
     e52:	88 e2       	ldi	r24, 0x28	; 40
     e54:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
     e58:	2f ef       	ldi	r18, 0xFF	; 255
     e5a:	84 e3       	ldi	r24, 0x34	; 52
     e5c:	9c e0       	ldi	r25, 0x0C	; 12
     e5e:	21 50       	subi	r18, 0x01	; 1
     e60:	80 40       	sbci	r24, 0x00	; 0
     e62:	90 40       	sbci	r25, 0x00	; 0
     e64:	e1 f7       	brne	.-8      	; 0xe5e <Calibrate_Manually+0x8c>
     e66:	00 c0       	rjmp	.+0      	; 0xe68 <Calibrate_Manually+0x96>
     e68:	00 00       	nop
			Delay_MS(CALIBRATION_DELAY);
		}
		if(is_low(ALT_KEY)){
     e6a:	7d 99       	sbic	0x0f, 5	; 15
     e6c:	e2 cf       	rjmp	.-60     	; 0xe32 <Calibrate_Manually+0x60>
			USBSendPROGString(Str_Assign);
     e6e:	80 e5       	ldi	r24, 0x50	; 80
     e70:	91 e0       	ldi	r25, 0x01	; 1
     e72:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
			
			keypressed = WaitForKeypress();
     e76:	35 de       	rcall	.-918    	; 0xae2 <WaitForKeypress>
     e78:	8c 01       	movw	r16, r24
			modifier = GetModifier();
     e7a:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
			
			if (edit_mode == 'u'){TeachHIDKey(code,keypressed,modifier);}
			else{TeachASCIIKey(code,keypressed,modifier);}
     e7e:	b8 01       	movw	r22, r16
     e80:	77 27       	eor	r23, r23
     e82:	48 2f       	mov	r20, r24
     e84:	8c 2f       	mov	r24, r28
     e86:	98 df       	rcall	.-208    	; 0xdb8 <TeachASCIIKey>
				
			USBSendNumber(keypressed);
     e88:	80 2f       	mov	r24, r16
     e8a:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
			USBSend(KEY_ENTER,LOWER);
     e8e:	60 e0       	ldi	r22, 0x00	; 0
     e90:	88 e2       	ldi	r24, 0x28	; 40
     e92:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
			
			INCREMENT_CODE();
     e96:	81 e0       	ldi	r24, 0x01	; 1
     e98:	8c 0f       	add	r24, r28
     e9a:	ce 57       	subi	r28, 0x7E	; 126
     e9c:	cd 33       	cpi	r28, 0x3D	; 61
     e9e:	10 f0       	brcs	.+4      	; 0xea4 <Calibrate_Manually+0xd2>
     ea0:	c8 2f       	mov	r28, r24
     ea2:	01 c0       	rjmp	.+2      	; 0xea6 <Calibrate_Manually+0xd4>
     ea4:	cc eb       	ldi	r28, 0xBC	; 188
     ea6:	8c 2f       	mov	r24, r28
     ea8:	0e 94 76 28 	call	0x50ec	; 0x50ec <USBSendASCII>
     eac:	60 e0       	ldi	r22, 0x00	; 0
     eae:	88 e2       	ldi	r24, 0x28	; 40
     eb0:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
     eb4:	2f ef       	ldi	r18, 0xFF	; 255
     eb6:	84 e3       	ldi	r24, 0x34	; 52
     eb8:	9c e0       	ldi	r25, 0x0C	; 12
     eba:	21 50       	subi	r18, 0x01	; 1
     ebc:	80 40       	sbci	r24, 0x00	; 0
     ebe:	90 40       	sbci	r25, 0x00	; 0
     ec0:	e1 f7       	brne	.-8      	; 0xeba <Calibrate_Manually+0xe8>
     ec2:	00 c0       	rjmp	.+0      	; 0xec4 <Calibrate_Manually+0xf2>
     ec4:	00 00       	nop
     ec6:	b5 cf       	rjmp	.-150    	; 0xe32 <Calibrate_Manually+0x60>
		
		
		
	}
	
	SaveCalibration(); //save your work.
     ec8:	65 dd       	rcall	.-1334   	; 0x994 <SaveCalibration>
	USBSendPROGString(Str_Settings_Saved);
     eca:	87 e6       	ldi	r24, 0x67	; 103
     ecc:	92 e0       	ldi	r25, 0x02	; 2
	
}
     ece:	cf 91       	pop	r28
     ed0:	1f 91       	pop	r17
     ed2:	0f 91       	pop	r16
		
		
	}
	
	SaveCalibration(); //save your work.
	USBSendPROGString(Str_Settings_Saved);
     ed4:	0c 94 28 28 	jmp	0x5050	; 0x5050 <USBSendPROGString>

00000ed8 <Calibrate>:
	const char Str_How_To_Scroll[]	PROGMEM = "Press CTRL to scroll through characters.\r";
	const char Str_How_To_Select[]  PROGMEM = "Press ALT to select a character.\r";
	const char Str_How_To_Exit[] PROGMEM = "Press CMD to save and exit.\r";
	const char Str_Assign[]	PROGMEM = " KEY SELECTED. PRESS A TYPEWRITER KEY TO ASSIGN... ";

void Calibrate(){
     ed8:	6f 92       	push	r6
     eda:	7f 92       	push	r7
     edc:	8f 92       	push	r8
     ede:	9f 92       	push	r9
     ee0:	af 92       	push	r10
     ee2:	bf 92       	push	r11
     ee4:	cf 92       	push	r12
     ee6:	df 92       	push	r13
     ee8:	ef 92       	push	r14
     eea:	ff 92       	push	r15
     eec:	0f 93       	push	r16
     eee:	1f 93       	push	r17
     ef0:	cf 93       	push	r28
     ef2:	df 93       	push	r29
	uint8_t Modifier;
	uint8_t KeyPressed;
	
	uint8_t Default_Mode;

	ClearKeyCodeTables();//clear keycode tables (in memory)
     ef4:	0e 94 b1 2b 	call	0x5762	; 0x5762 <ClearKeyCodeTables>

	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
     ef8:	80 91 ce 09 	lds	r24, 0x09CE
     efc:	84 30       	cpi	r24, 0x04	; 4
     efe:	e1 f7       	brne	.-8      	; 0xef8 <Calibrate+0x20>
     f00:	2f ef       	ldi	r18, 0xFF	; 255
     f02:	89 e6       	ldi	r24, 0x69	; 105
     f04:	98 e1       	ldi	r25, 0x18	; 24
     f06:	21 50       	subi	r18, 0x01	; 1
     f08:	80 40       	sbci	r24, 0x00	; 0
     f0a:	90 40       	sbci	r25, 0x00	; 0
     f0c:	e1 f7       	brne	.-8      	; 0xf06 <Calibrate+0x2e>
     f0e:	00 c0       	rjmp	.+0      	; 0xf10 <Calibrate+0x38>
     f10:	00 00       	nop
	Delay_MS(1000);//wait 1 second.
	
//--------SEND PROMPT TO USER -----------

    USBSendPROGString(Str_USB_Typewriter);
     f12:	81 ea       	ldi	r24, 0xA1	; 161
     f14:	95 e0       	ldi	r25, 0x05	; 5
     f16:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSendPROGString(Str_Firmware_Ver);
     f1a:	8c e8       	ldi	r24, 0x8C	; 140
     f1c:	95 e0       	ldi	r25, 0x05	; 5
     f1e:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSend(KEY_ENTER,LOWER);
     f22:	60 e0       	ldi	r22, 0x00	; 0
     f24:	88 e2       	ldi	r24, 0x28	; 40
     f26:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
	
	Default_Mode = eeprom_read_byte((uint8_t*)DEFAULT_MODE_ADDR);
     f2a:	8d e0       	ldi	r24, 0x0D	; 13
     f2c:	92 e0       	ldi	r25, 0x02	; 2
     f2e:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
     f32:	c8 2f       	mov	r28, r24
	USBSendPROGString(Str_Typewriter_Mode);
     f34:	8a e7       	ldi	r24, 0x7A	; 122
     f36:	95 e0       	ldi	r25, 0x05	; 5
     f38:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	switch(Default_Mode){
     f3c:	c2 30       	cpi	r28, 0x02	; 2
     f3e:	91 f0       	breq	.+36     	; 0xf64 <Calibrate+0x8c>
     f40:	28 f4       	brcc	.+10     	; 0xf4c <Calibrate+0x74>
     f42:	c1 30       	cpi	r28, 0x01	; 1
     f44:	91 f4       	brne	.+36     	; 0xf6a <Calibrate+0x92>
		case USB_COMBO_MODE: 
			USBSendPROGString(Str_Combo_Mode); 
     f46:	8c e1       	ldi	r24, 0x1C	; 28
     f48:	95 e0       	ldi	r25, 0x05	; 5
     f4a:	09 c0       	rjmp	.+18     	; 0xf5e <Calibrate+0x86>
	USBSend(KEY_ENTER,LOWER);
	
	
	Default_Mode = eeprom_read_byte((uint8_t*)DEFAULT_MODE_ADDR);
	USBSendPROGString(Str_Typewriter_Mode);
	switch(Default_Mode){
     f4c:	c9 30       	cpi	r28, 0x09	; 9
     f4e:	29 f0       	breq	.+10     	; 0xf5a <Calibrate+0x82>
     f50:	cd 30       	cpi	r28, 0x0D	; 13
     f52:	59 f4       	brne	.+22     	; 0xf6a <Calibrate+0x92>
		break;
		case SD_MODE: 
			USBSendPROGString(Str_SD_Mode);
		break;
		case USB_LIGHT_MODE:
			USBSendPROGString(Str_Light_Mode);
     f54:	8b e3       	ldi	r24, 0x3B	; 59
     f56:	95 e0       	ldi	r25, 0x05	; 5
     f58:	02 c0       	rjmp	.+4      	; 0xf5e <Calibrate+0x86>
	switch(Default_Mode){
		case USB_COMBO_MODE: 
			USBSendPROGString(Str_Combo_Mode); 
		break;
		case BLUETOOTH_MODE: 
			USBSendPROGString(Str_BT_Mode); 
     f5a:	81 e6       	ldi	r24, 0x61	; 97
     f5c:	95 e0       	ldi	r25, 0x05	; 5
     f5e:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
		break;
     f62:	07 c0       	rjmp	.+14     	; 0xf72 <Calibrate+0x9a>
		case SD_MODE: 
			USBSendPROGString(Str_SD_Mode);
     f64:	86 e0       	ldi	r24, 0x06	; 6
     f66:	95 e0       	ldi	r25, 0x05	; 5
     f68:	fa cf       	rjmp	.-12     	; 0xf5e <Calibrate+0x86>
		break;
		case USB_LIGHT_MODE:
			USBSendPROGString(Str_Light_Mode);
		break;
		default: USBSendString("Unknown"); break;
     f6a:	88 e3       	ldi	r24, 0x38	; 56
     f6c:	92 e0       	ldi	r25, 0x02	; 2
     f6e:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
	}
	
	USBSendPROGString(Str_Calibrating);
     f72:	86 ef       	ldi	r24, 0xF6	; 246
     f74:	94 e0       	ldi	r25, 0x04	; 4
     f76:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	
	/*Measure the reed switch polarities*/
		Reed1Polarity = is_low(REED_1); //if reed_1 is low at start of calibration, then the polarity of reed 1 is active high
     f7a:	89 b1       	in	r24, 0x09	; 9
     f7c:	c1 e0       	ldi	r28, 0x01	; 1
     f7e:	82 95       	swap	r24
     f80:	81 70       	andi	r24, 0x01	; 1
     f82:	8c 27       	eor	r24, r28
     f84:	80 93 88 06 	sts	0x0688, r24
		Reed2Polarity= is_low(REED_2);
     f88:	89 b1       	in	r24, 0x09	; 9
     f8a:	86 fb       	bst	r24, 6
     f8c:	88 27       	eor	r24, r24
     f8e:	80 f9       	bld	r24, 0
     f90:	8c 27       	eor	r24, r28
     f92:	80 93 36 06 	sts	0x0636, r24
		Reed3Polarity = is_low(REED_3);
     f96:	89 b1       	in	r24, 0x09	; 9
     f98:	80 95       	com	r24
     f9a:	88 1f       	adc	r24, r24
     f9c:	88 27       	eor	r24, r24
     f9e:	88 1f       	adc	r24, r24
     fa0:	80 93 0a 07 	sts	0x070A, r24
		Reed4Polarity = is_low(REED_4);
     fa4:	83 b1       	in	r24, 0x03	; 3
     fa6:	82 95       	swap	r24
     fa8:	81 70       	andi	r24, 0x01	; 1
     faa:	8c 27       	eor	r24, r28
     fac:	80 93 48 07 	sts	0x0748, r24

		DetectHallSensor();
     fb0:	3b dd       	rcall	.-1418   	; 0xa28 <DetectHallSensor>
	
	if (is_low(S2)){//hold down to activate the dummy load
     fb2:	7d 99       	sbic	0x0f, 5	; 15
     fb4:	15 c0       	rjmp	.+42     	; 0xfe0 <Calibrate+0x108>
		if (UseDummyLoad) {
     fb6:	80 91 37 06 	lds	r24, 0x0637
     fba:	88 23       	and	r24, r24
     fbc:	29 f0       	breq	.+10     	; 0xfc8 <Calibrate+0xf0>
			UseDummyLoad = 0; 
     fbe:	10 92 37 06 	sts	0x0637, r1
			USBSendPROGString(Str_No_Dummy_Load);
     fc2:	88 e2       	ldi	r24, 0x28	; 40
     fc4:	94 e0       	ldi	r25, 0x04	; 4
     fc6:	04 c0       	rjmp	.+8      	; 0xfd0 <Calibrate+0xf8>
		}
		else {
		UseDummyLoad = 1; 
     fc8:	c0 93 37 06 	sts	0x0637, r28
		USBSendPROGString(Str_Dummy_Load);
     fcc:	80 e4       	ldi	r24, 0x40	; 64
     fce:	94 e0       	ldi	r25, 0x04	; 4
     fd0:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
		}
		eeprom_update_byte((uint8_t*)DUMMY_LOAD_ADDR, UseDummyLoad);
     fd4:	60 91 37 06 	lds	r22, 0x0637
     fd8:	8f e0       	ldi	r24, 0x0F	; 15
     fda:	92 e0       	ldi	r25, 0x02	; 2
     fdc:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
	}
	
	USBSendPROGString(Str_Type_The_Following);
     fe0:	84 ec       	ldi	r24, 0xC4	; 196
     fe2:	94 e0       	ldi	r25, 0x04	; 4
     fe4:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	
//--------TEACH LETTER KEYS----------
	for (HIDKey = KEY_A; HIDKey <= KEY_Z; HIDKey ++){
     fe8:	c4 e0       	ldi	r28, 0x04	; 4
					
		TeachHIDKey(HIDKey, KeyPressed, Modifier); //all alphanumeric keys programmed as a/A pairs -- no special shift keys allowed.
		ASCIIKey = HIDKey-KEY_A+ASCII_A; //calculated corresponding sd card Ascii key
		
		if(HIDKey  == HID_KEYBOARD_SC_L){ //if the key is l, make sure fn+l=1
			FnKeyCodeLookUpTable[KeyPressed] = KEY_1;
     fea:	ae e1       	ldi	r26, 0x1E	; 30
     fec:	fa 2e       	mov	r15, r26
	
	USBSendPROGString(Str_Type_The_Following);
	
//--------TEACH LETTER KEYS----------
	for (HIDKey = KEY_A; HIDKey <= KEY_Z; HIDKey ++){
		USBSend(HIDKey, UPPER);
     fee:	62 e0       	ldi	r22, 0x02	; 2
     ff0:	8c 2f       	mov	r24, r28
     ff2:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
		USBSend(KEY_SPACE,LOWER);// used to be a colon
     ff6:	60 e0       	ldi	r22, 0x00	; 0
     ff8:	8c e2       	ldi	r24, 0x2C	; 44
     ffa:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
		KeyPressed = WaitForKeypress();
     ffe:	71 dd       	rcall	.-1310   	; 0xae2 <WaitForKeypress>
    1000:	8c 01       	movw	r16, r24
		Modifier = GetModifier();
    1002:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
    1006:	d8 2f       	mov	r29, r24
		
		Modifier &= ~(HID_KEYBOARD_MODIFIER_LEFTSHIFT); //Lower-case version of the modifier indicator (overrid user's shift key)
					
		TeachHIDKey(HIDKey, KeyPressed, Modifier); //all alphanumeric keys programmed as a/A pairs -- no special shift keys allowed.
    1008:	11 27       	eor	r17, r17
		USBSend(HIDKey, UPPER);
		USBSend(KEY_SPACE,LOWER);// used to be a colon
		KeyPressed = WaitForKeypress();
		Modifier = GetModifier();
		
		Modifier &= ~(HID_KEYBOARD_MODIFIER_LEFTSHIFT); //Lower-case version of the modifier indicator (overrid user's shift key)
    100a:	48 2f       	mov	r20, r24
    100c:	4d 7f       	andi	r20, 0xFD	; 253
					
		TeachHIDKey(HIDKey, KeyPressed, Modifier); //all alphanumeric keys programmed as a/A pairs -- no special shift keys allowed.
    100e:	b8 01       	movw	r22, r16
    1010:	8c 2f       	mov	r24, r28
    1012:	76 dd       	rcall	.-1300   	; 0xb00 <TeachHIDKey>
		ASCIIKey = HIDKey-KEY_A+ASCII_A; //calculated corresponding sd card Ascii key
		
		if(HIDKey  == HID_KEYBOARD_SC_L){ //if the key is l, make sure fn+l=1
    1014:	cf 30       	cpi	r28, 0x0F	; 15
    1016:	21 f4       	brne	.+8      	; 0x1020 <Calibrate+0x148>
			FnKeyCodeLookUpTable[KeyPressed] = KEY_1;
    1018:	f8 01       	movw	r30, r16
    101a:	e6 57       	subi	r30, 0x76	; 118
    101c:	f6 4f       	sbci	r31, 0xF6	; 246
    101e:	f0 82       	st	Z, r15
		}
		
		if (!(Modifier & FN_MODIFIER)) { //only bother to program sd card letters if the fn key is not being pressed (sd card doesn't use fn key)
    1020:	d2 fd       	sbrc	r29, 2
    1022:	0c c0       	rjmp	.+24     	; 0x103c <Calibrate+0x164>
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1024:	f8 01       	movw	r30, r16
    1026:	e6 53       	subi	r30, 0x36	; 54
    1028:	f9 4f       	sbci	r31, 0xF9	; 249
		Modifier = GetModifier();
		
		Modifier &= ~(HID_KEYBOARD_MODIFIER_LEFTSHIFT); //Lower-case version of the modifier indicator (overrid user's shift key)
					
		TeachHIDKey(HIDKey, KeyPressed, Modifier); //all alphanumeric keys programmed as a/A pairs -- no special shift keys allowed.
		ASCIIKey = HIDKey-KEY_A+ASCII_A; //calculated corresponding sd card Ascii key
    102a:	8d e3       	ldi	r24, 0x3D	; 61
    102c:	8c 0f       	add	r24, r28
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    102e:	80 83       	st	Z, r24
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1030:	f8 01       	movw	r30, r16
    1032:	e7 5b       	subi	r30, 0xB7	; 183
    1034:	f8 4f       	sbci	r31, 0xF8	; 248
    1036:	8d e5       	ldi	r24, 0x5D	; 93
    1038:	8c 0f       	add	r24, r28
    103a:	80 83       	st	Z, r24
		if (!(Modifier & FN_MODIFIER)) { //only bother to program sd card letters if the fn key is not being pressed (sd card doesn't use fn key)
			TeachASCIIKey(ASCIIKey, KeyPressed, UPPER);  //program this key into memory as an upper case key
			TeachASCIIKey(ASCIIKey+0x20, KeyPressed, LOWER); // and as a lower case key
		}
		
		USBSend(KEY_ENTER,LOWER);
    103c:	60 e0       	ldi	r22, 0x00	; 0
    103e:	88 e2       	ldi	r24, 0x28	; 40
    1040:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	}
	
	USBSendPROGString(Str_Type_The_Following);
	
//--------TEACH LETTER KEYS----------
	for (HIDKey = KEY_A; HIDKey <= KEY_Z; HIDKey ++){
    1044:	cf 5f       	subi	r28, 0xFF	; 255
    1046:	ce 31       	cpi	r28, 0x1E	; 30
    1048:	91 f6       	brne	.-92     	; 0xfee <Calibrate+0x116>
    104a:	f8 e6       	ldi	r31, 0x68	; 104
    104c:	ef 2e       	mov	r14, r31
    104e:	f2 e0       	ldi	r31, 0x02	; 2
    1050:	ff 2e       	mov	r15, r31
    1052:	00 e0       	ldi	r16, 0x00	; 0
    1054:	10 e0       	ldi	r17, 0x00	; 0
		USBSend(KEY_ENTER,LOWER);
	}

//--------TEACH NUMBER KEYS---------
	for (int i = 0; i <= 9; i ++){
			USBSend(HIDNumbers[i], LOWER);
    1056:	f7 01       	movw	r30, r14
    1058:	c1 90       	ld	r12, Z+
    105a:	7f 01       	movw	r14, r30
    105c:	60 e0       	ldi	r22, 0x00	; 0
    105e:	8c 2d       	mov	r24, r12
    1060:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
			USBSend(KEY_SPACE,LOWER);// used to be a colon
    1064:	60 e0       	ldi	r22, 0x00	; 0
    1066:	8c e2       	ldi	r24, 0x2C	; 44
    1068:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
			KeyPressed = WaitForKeypress();
    106c:	3a dd       	rcall	.-1420   	; 0xae2 <WaitForKeypress>
    106e:	ec 01       	movw	r28, r24
			Modifier = GetModifier();
    1070:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
    1074:	d8 2e       	mov	r13, r24
			
			Modifier &= ~(HID_KEYBOARD_MODIFIER_LEFTSHIFT); //numbers are always lower-case (override user's shift key)
			
			TeachHIDKey(HIDNumbers[i], KeyPressed, Modifier); //teach the hid keycode array about this key -- must be lowercase.
    1076:	dd 27       	eor	r29, r29
			USBSend(HIDNumbers[i], LOWER);
			USBSend(KEY_SPACE,LOWER);// used to be a colon
			KeyPressed = WaitForKeypress();
			Modifier = GetModifier();
			
			Modifier &= ~(HID_KEYBOARD_MODIFIER_LEFTSHIFT); //numbers are always lower-case (override user's shift key)
    1078:	48 2f       	mov	r20, r24
    107a:	4d 7f       	andi	r20, 0xFD	; 253
			
			TeachHIDKey(HIDNumbers[i], KeyPressed, Modifier); //teach the hid keycode array about this key -- must be lowercase.
    107c:	be 01       	movw	r22, r28
    107e:	8c 2d       	mov	r24, r12
    1080:	3f dd       	rcall	.-1410   	; 0xb00 <TeachHIDKey>
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
    1082:	d2 fc       	sbrc	r13, 2
    1084:	15 c0       	rjmp	.+42     	; 0x10b0 <Calibrate+0x1d8>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1086:	fe 01       	movw	r30, r28
    1088:	e7 5b       	subi	r30, 0xB7	; 183
    108a:	f8 4f       	sbci	r31, 0xF8	; 248
    108c:	d8 01       	movw	r26, r16
    108e:	a2 5a       	subi	r26, 0xA2	; 162
    1090:	bd 4f       	sbci	r27, 0xFD	; 253
    1092:	8c 91       	ld	r24, X
    1094:	80 83       	st	Z, r24
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1096:	fe 01       	movw	r30, r28
    1098:	e6 53       	subi	r30, 0x36	; 54
    109a:	f9 4f       	sbci	r31, 0xF9	; 249
    109c:	d8 01       	movw	r26, r16
    109e:	ac 5a       	subi	r26, 0xAC	; 172
    10a0:	bd 4f       	sbci	r27, 0xFD	; 253
    10a2:	8c 91       	ld	r24, X
    10a4:	80 83       	st	Z, r24
			TeachHIDKey(HIDNumbers[i], KeyPressed, Modifier); //teach the hid keycode array about this key -- must be lowercase.
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				TeachASCIIKey(ASCIINumbers[i], KeyPressed, LOWER); // and the ascii array about this key
				TeachASCIIKey(ASCIINumSymbols[i],KeyPressed, UPPER); // and the symbols above the numbers on most typewriters, for asii (sd card) use only.
				FnKeyCodeLookUpTable[KeyPressed] = (KEY_F1+i);			}
    10a6:	c6 57       	subi	r28, 0x76	; 118
    10a8:	d6 4f       	sbci	r29, 0xF6	; 246
    10aa:	8a e3       	ldi	r24, 0x3A	; 58
    10ac:	80 0f       	add	r24, r16
    10ae:	88 83       	st	Y, r24
			
			USBSend(KEY_ENTER,LOWER);
    10b0:	60 e0       	ldi	r22, 0x00	; 0
    10b2:	88 e2       	ldi	r24, 0x28	; 40
    10b4:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
		
		USBSend(KEY_ENTER,LOWER);
	}

//--------TEACH NUMBER KEYS---------
	for (int i = 0; i <= 9; i ++){
    10b8:	0f 5f       	subi	r16, 0xFF	; 255
    10ba:	1f 4f       	sbci	r17, 0xFF	; 255
    10bc:	0a 30       	cpi	r16, 0x0A	; 10
    10be:	11 05       	cpc	r17, r1
    10c0:	51 f6       	brne	.-108    	; 0x1056 <Calibrate+0x17e>
			
			USBSend(KEY_ENTER,LOWER);
	}
	
//----TEACH F1, F11, F12
	USBSendString("F1");
    10c2:	80 e4       	ldi	r24, 0x40	; 64
    10c4:	92 e0       	ldi	r25, 0x02	; 2
    10c6:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
	USBSend(KEY_SPACE,LOWER);
    10ca:	60 e0       	ldi	r22, 0x00	; 0
    10cc:	8c e2       	ldi	r24, 0x2C	; 44
    10ce:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
    10d2:	07 dd       	rcall	.-1522   	; 0xae2 <WaitForKeypress>
    10d4:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
    10d6:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
	TeachHIDKey(KEY_F1, KeyPressed, Modifier); 
    10da:	be 01       	movw	r22, r28
    10dc:	77 27       	eor	r23, r23
    10de:	48 2f       	mov	r20, r24
    10e0:	8a e3       	ldi	r24, 0x3A	; 58
    10e2:	0e dd       	rcall	.-1508   	; 0xb00 <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
    10e4:	60 e0       	ldi	r22, 0x00	; 0
    10e6:	88 e2       	ldi	r24, 0x28	; 40
    10e8:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
	USBSendString("F11");
    10ec:	83 e4       	ldi	r24, 0x43	; 67
    10ee:	92 e0       	ldi	r25, 0x02	; 2
    10f0:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
	USBSend(KEY_SPACE,LOWER);
    10f4:	60 e0       	ldi	r22, 0x00	; 0
    10f6:	8c e2       	ldi	r24, 0x2C	; 44
    10f8:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
    10fc:	f2 dc       	rcall	.-1564   	; 0xae2 <WaitForKeypress>
    10fe:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
    1100:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
	TeachHIDKey(KEY_F11, KeyPressed, Modifier);
    1104:	be 01       	movw	r22, r28
    1106:	77 27       	eor	r23, r23
    1108:	48 2f       	mov	r20, r24
    110a:	84 e4       	ldi	r24, 0x44	; 68
    110c:	f9 dc       	rcall	.-1550   	; 0xb00 <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
    110e:	60 e0       	ldi	r22, 0x00	; 0
    1110:	88 e2       	ldi	r24, 0x28	; 40
    1112:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
	USBSendString("F12");
    1116:	87 e4       	ldi	r24, 0x47	; 71
    1118:	92 e0       	ldi	r25, 0x02	; 2
    111a:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
	USBSend(KEY_SPACE,LOWER);
    111e:	60 e0       	ldi	r22, 0x00	; 0
    1120:	8c e2       	ldi	r24, 0x2C	; 44
    1122:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
    1126:	dd dc       	rcall	.-1606   	; 0xae2 <WaitForKeypress>
    1128:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
    112a:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
	TeachHIDKey(KEY_F12, KeyPressed, Modifier);
    112e:	be 01       	movw	r22, r28
    1130:	77 27       	eor	r23, r23
    1132:	48 2f       	mov	r20, r24
    1134:	85 e4       	ldi	r24, 0x45	; 69
    1136:	e4 dc       	rcall	.-1592   	; 0xb00 <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);	
    1138:	60 e0       	ldi	r22, 0x00	; 0
    113a:	88 e2       	ldi	r24, 0x28	; 40
    113c:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
//--------TEACH SHIFT KEY-----------
	USBSendString("SHIFT");
    1140:	87 e2       	ldi	r24, 0x27	; 39
    1142:	92 e0       	ldi	r25, 0x02	; 2
    1144:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
	USBSend(KEY_SPACE,LOWER);// used to be a colon
    1148:	60 e0       	ldi	r22, 0x00	; 0
    114a:	8c e2       	ldi	r24, 0x2C	; 44
    114c:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
    1150:	c8 dc       	rcall	.-1648   	; 0xae2 <WaitForKeypress>
	if((KeyPressed)&&(KeyPressed <= 8)){ //if keypressed is 1, 2, 3, or 4, it represents a reed switch being held down.
    1152:	9f ef       	ldi	r25, 0xFF	; 255
    1154:	98 0f       	add	r25, r24
    1156:	98 30       	cpi	r25, 0x08	; 8
    1158:	28 f4       	brcc	.+10     	; 0x1164 <Calibrate+0x28c>
		Shift_Reed = KeyPressed;
    115a:	80 93 7e 06 	sts	0x067E, r24
		USBSendNumber(Shift_Reed);
    115e:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
    1162:	04 c0       	rjmp	.+8      	; 0x116c <Calibrate+0x294>
	}
	else{
		USBSendPROGString(Str_Shift_Error);
    1164:	8e e9       	ldi	r24, 0x9E	; 158
    1166:	94 e0       	ldi	r25, 0x04	; 4
    1168:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
    116c:	ff ef       	ldi	r31, 0xFF	; 255
    116e:	24 e3       	ldi	r18, 0x34	; 52
    1170:	8c e0       	ldi	r24, 0x0C	; 12
    1172:	f1 50       	subi	r31, 0x01	; 1
    1174:	20 40       	sbci	r18, 0x00	; 0
    1176:	80 40       	sbci	r24, 0x00	; 0
    1178:	e1 f7       	brne	.-8      	; 0x1172 <Calibrate+0x29a>
    117a:	00 c0       	rjmp	.+0      	; 0x117c <Calibrate+0x2a4>
    117c:	00 00       	nop
	}
	Delay_MS(CALIBRATION_DELAY);
	USBSend(KEY_ENTER,LOWER);
    117e:	60 e0       	ldi	r22, 0x00	; 0
    1180:	88 e2       	ldi	r24, 0x28	; 40
    1182:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
//----------TEACH SYMBOL KEYS------------	
	for (HIDKey = KEY_DASH; HIDKey <= KEY_SLASH; HIDKey ++){
    1186:	1d e2       	ldi	r17, 0x2D	; 45
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1188:	0e e2       	ldi	r16, 0x2E	; 46
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    118a:	8f e3       	ldi	r24, 0x3F	; 63
    118c:	f8 2e       	mov	r15, r24
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    118e:	9f e2       	ldi	r25, 0x2F	; 47
    1190:	d9 2e       	mov	r13, r25
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1192:	2a e2       	ldi	r18, 0x2A	; 42
    1194:	c2 2e       	mov	r12, r18
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1196:	30 e6       	ldi	r19, 0x60	; 96
    1198:	b3 2e       	mov	r11, r19
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    119a:	4e e7       	ldi	r20, 0x7E	; 126
    119c:	a4 2e       	mov	r10, r20
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    119e:	5d e3       	ldi	r21, 0x3D	; 61
    11a0:	95 2e       	mov	r9, r21
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    11a2:	6b e2       	ldi	r22, 0x2B	; 43
    11a4:	86 2e       	mov	r8, r22
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    11a6:	7b e3       	ldi	r23, 0x3B	; 59
    11a8:	77 2e       	mov	r7, r23
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    11aa:	ea e3       	ldi	r30, 0x3A	; 58
    11ac:	6e 2e       	mov	r6, r30
	Delay_MS(CALIBRATION_DELAY);
	USBSend(KEY_ENTER,LOWER);
	
//----------TEACH SYMBOL KEYS------------	
	for (HIDKey = KEY_DASH; HIDKey <= KEY_SLASH; HIDKey ++){
			if (HIDKey != HID_KEYBOARD_SC_NON_US_HASHMARK_AND_TILDE){ //don't bother to program the non-us hash key, which is a weird and confusing key.
    11ae:	12 33       	cpi	r17, 0x32	; 50
    11b0:	09 f4       	brne	.+2      	; 0x11b4 <Calibrate+0x2dc>
    11b2:	5b c0       	rjmp	.+182    	; 0x126a <Calibrate+0x392>
			USBSend(HIDKey, LOWER);
    11b4:	60 e0       	ldi	r22, 0x00	; 0
    11b6:	81 2f       	mov	r24, r17
    11b8:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
			USBSend(KEY_SPACE,LOWER);// used to be a colon
    11bc:	60 e0       	ldi	r22, 0x00	; 0
    11be:	8c e2       	ldi	r24, 0x2C	; 44
    11c0:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
			KeyPressed = WaitForKeypress();
    11c4:	8e dc       	rcall	.-1764   	; 0xae2 <WaitForKeypress>
    11c6:	ec 01       	movw	r28, r24
			Modifier = GetModifier();
    11c8:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
    11cc:	e8 2e       	mov	r14, r24
			
			TeachHIDKey(HIDKey, KeyPressed, Modifier); //program these characters, including the modifer used when programming them.
    11ce:	dd 27       	eor	r29, r29
    11d0:	48 2f       	mov	r20, r24
    11d2:	be 01       	movw	r22, r28
    11d4:	81 2f       	mov	r24, r17
    11d6:	94 dc       	rcall	.-1752   	; 0xb00 <TeachHIDKey>
			
			//some of these keys (but not all) are also used for the SD card mode:			
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
    11d8:	e2 fc       	sbrc	r14, 2
    11da:	43 c0       	rjmp	.+134    	; 0x1262 <Calibrate+0x38a>
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
    11dc:	13 33       	cpi	r17, 0x33	; 51
    11de:	41 f4       	brne	.+16     	; 0x11f0 <Calibrate+0x318>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    11e0:	fe 01       	movw	r30, r28
    11e2:	e7 5b       	subi	r30, 0xB7	; 183
    11e4:	f8 4f       	sbci	r31, 0xF8	; 248
    11e6:	70 82       	st	Z, r7
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    11e8:	c6 53       	subi	r28, 0x36	; 54
    11ea:	d9 4f       	sbci	r29, 0xF9	; 249
    11ec:	68 82       	st	Y, r6
    11ee:	39 c0       	rjmp	.+114    	; 0x1262 <Calibrate+0x38a>
			
			//some of these keys (but not all) are also used for the SD card mode:			
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
    11f0:	1e 32       	cpi	r17, 0x2E	; 46
    11f2:	41 f4       	brne	.+16     	; 0x1204 <Calibrate+0x32c>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    11f4:	fe 01       	movw	r30, r28
    11f6:	e7 5b       	subi	r30, 0xB7	; 183
    11f8:	f8 4f       	sbci	r31, 0xF8	; 248
    11fa:	90 82       	st	Z, r9
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    11fc:	c6 53       	subi	r28, 0x36	; 54
    11fe:	d9 4f       	sbci	r29, 0xF9	; 249
    1200:	88 82       	st	Y, r8
    1202:	2f c0       	rjmp	.+94     	; 0x1262 <Calibrate+0x38a>
			//some of these keys (but not all) are also used for the SD card mode:			
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
    1204:	15 33       	cpi	r17, 0x35	; 53
    1206:	41 f4       	brne	.+16     	; 0x1218 <Calibrate+0x340>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1208:	fe 01       	movw	r30, r28
    120a:	e7 5b       	subi	r30, 0xB7	; 183
    120c:	f8 4f       	sbci	r31, 0xF8	; 248
    120e:	b0 82       	st	Z, r11
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1210:	c6 53       	subi	r28, 0x36	; 54
    1212:	d9 4f       	sbci	r29, 0xF9	; 249
    1214:	a8 82       	st	Y, r10
    1216:	25 c0       	rjmp	.+74     	; 0x1262 <Calibrate+0x38a>
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
				if(HIDKey == KEY_DASH){TeachASCIIKey('-', KeyPressed, LOWER); TeachASCIIKey('*', KeyPressed, UPPER);}
    1218:	1d 32       	cpi	r17, 0x2D	; 45
    121a:	41 f4       	brne	.+16     	; 0x122c <Calibrate+0x354>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    121c:	fe 01       	movw	r30, r28
    121e:	e7 5b       	subi	r30, 0xB7	; 183
    1220:	f8 4f       	sbci	r31, 0xF8	; 248
    1222:	10 83       	st	Z, r17
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1224:	c6 53       	subi	r28, 0x36	; 54
    1226:	d9 4f       	sbci	r29, 0xF9	; 249
    1228:	c8 82       	st	Y, r12
    122a:	1b c0       	rjmp	.+54     	; 0x1262 <Calibrate+0x38a>
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
				if(HIDKey == KEY_DASH){TeachASCIIKey('-', KeyPressed, LOWER); TeachASCIIKey('*', KeyPressed, UPPER);}
				if(HIDKey == KEY_SLASH){TeachASCIIKey('/', KeyPressed, LOWER);TeachASCIIKey('?', KeyPressed, UPPER);}
    122c:	18 33       	cpi	r17, 0x38	; 56
    122e:	29 f4       	brne	.+10     	; 0x123a <Calibrate+0x362>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1230:	fe 01       	movw	r30, r28
    1232:	e7 5b       	subi	r30, 0xB7	; 183
    1234:	f8 4f       	sbci	r31, 0xF8	; 248
    1236:	d0 82       	st	Z, r13
    1238:	07 c0       	rjmp	.+14     	; 0x1248 <Calibrate+0x370>
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
				if(HIDKey == KEY_DASH){TeachASCIIKey('-', KeyPressed, LOWER); TeachASCIIKey('*', KeyPressed, UPPER);}
				if(HIDKey == KEY_SLASH){TeachASCIIKey('/', KeyPressed, LOWER);TeachASCIIKey('?', KeyPressed, UPPER);}
				if(HIDKey == KEY_COMMA){TeachASCIIKey(',', KeyPressed, LOWER); TeachASCIIKey('?', KeyPressed, UPPER);}
    123a:	16 33       	cpi	r17, 0x36	; 54
    123c:	49 f4       	brne	.+18     	; 0x1250 <Calibrate+0x378>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    123e:	fe 01       	movw	r30, r28
    1240:	e7 5b       	subi	r30, 0xB7	; 183
    1242:	f8 4f       	sbci	r31, 0xF8	; 248
    1244:	8c e2       	ldi	r24, 0x2C	; 44
    1246:	80 83       	st	Z, r24
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1248:	c6 53       	subi	r28, 0x36	; 54
    124a:	d9 4f       	sbci	r29, 0xF9	; 249
    124c:	f8 82       	st	Y, r15
    124e:	09 c0       	rjmp	.+18     	; 0x1262 <Calibrate+0x38a>
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
				if(HIDKey == KEY_DASH){TeachASCIIKey('-', KeyPressed, LOWER); TeachASCIIKey('*', KeyPressed, UPPER);}
				if(HIDKey == KEY_SLASH){TeachASCIIKey('/', KeyPressed, LOWER);TeachASCIIKey('?', KeyPressed, UPPER);}
				if(HIDKey == KEY_COMMA){TeachASCIIKey(',', KeyPressed, LOWER); TeachASCIIKey('?', KeyPressed, UPPER);}
				if(HIDKey == KEY_PERIOD){TeachASCIIKey('.', KeyPressed, LOWER); TeachASCIIKey('.', KeyPressed, UPPER);}
    1250:	17 33       	cpi	r17, 0x37	; 55
    1252:	39 f4       	brne	.+14     	; 0x1262 <Calibrate+0x38a>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1254:	fe 01       	movw	r30, r28
    1256:	e7 5b       	subi	r30, 0xB7	; 183
    1258:	f8 4f       	sbci	r31, 0xF8	; 248
    125a:	00 83       	st	Z, r16
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    125c:	c6 53       	subi	r28, 0x36	; 54
    125e:	d9 4f       	sbci	r29, 0xF9	; 249
    1260:	08 83       	st	Y, r16
				if(HIDKey == KEY_PERIOD){TeachASCIIKey('.', KeyPressed, LOWER); TeachASCIIKey('.', KeyPressed, UPPER);}
			}
			
			
				
			USBSend(KEY_ENTER,LOWER);
    1262:	60 e0       	ldi	r22, 0x00	; 0
    1264:	88 e2       	ldi	r24, 0x28	; 40
    1266:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	}
	Delay_MS(CALIBRATION_DELAY);
	USBSend(KEY_ENTER,LOWER);
	
//----------TEACH SYMBOL KEYS------------	
	for (HIDKey = KEY_DASH; HIDKey <= KEY_SLASH; HIDKey ++){
    126a:	1f 5f       	subi	r17, 0xFF	; 255
    126c:	19 33       	cpi	r17, 0x39	; 57
    126e:	09 f0       	breq	.+2      	; 0x1272 <Calibrate+0x39a>
    1270:	9e cf       	rjmp	.-196    	; 0x11ae <Calibrate+0x2d6>
		}
	}
	
//-------TEACH VARIOUS UPPER CASE SYMBOLS ---------
	//@ for sd
	USBSend(KEY_2,UPPER);
    1272:	62 e0       	ldi	r22, 0x02	; 2
    1274:	8f e1       	ldi	r24, 0x1F	; 31
    1276:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	USBSendPROGString(Str_SD_Only);
    127a:	8d e7       	ldi	r24, 0x7D	; 125
    127c:	94 e0       	ldi	r25, 0x04	; 4
    127e:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSend(KEY_SPACE,LOWER);
    1282:	60 e0       	ldi	r22, 0x00	; 0
    1284:	8c e2       	ldi	r24, 0x2C	; 44
    1286:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
    128a:	2b dc       	rcall	.-1962   	; 0xae2 <WaitForKeypress>
    128c:	c8 2f       	mov	r28, r24
	Modifier = GetModifier();
    128e:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
	
		if(Modifier==HID_KEYBOARD_MODIFIER_LEFTSHIFT){
    1292:	82 30       	cpi	r24, 0x02	; 2
    1294:	41 f4       	brne	.+16     	; 0x12a6 <Calibrate+0x3ce>
			USBSendString("SHIFT");
    1296:	87 e2       	ldi	r24, 0x27	; 39
    1298:	92 e0       	ldi	r25, 0x02	; 2
    129a:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
			USBSend(KEY_EQ,UPPER); //send a + sign
    129e:	62 e0       	ldi	r22, 0x02	; 2
    12a0:	8e e2       	ldi	r24, 0x2E	; 46
    12a2:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
		}
	USBSendNumber(KeyPressed);
    12a6:	8c 2f       	mov	r24, r28
    12a8:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    12ac:	60 e0       	ldi	r22, 0x00	; 0
    12ae:	88 e2       	ldi	r24, 0x28	; 40
    12b0:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
    12b4:	9f ef       	ldi	r25, 0xFF	; 255
    12b6:	e4 e3       	ldi	r30, 0x34	; 52
    12b8:	fc e0       	ldi	r31, 0x0C	; 12
    12ba:	91 50       	subi	r25, 0x01	; 1
    12bc:	e0 40       	sbci	r30, 0x00	; 0
    12be:	f0 40       	sbci	r31, 0x00	; 0
    12c0:	e1 f7       	brne	.-8      	; 0x12ba <Calibrate+0x3e2>
    12c2:	00 c0       	rjmp	.+0      	; 0x12c4 <Calibrate+0x3ec>
    12c4:	00 00       	nop
	
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
	
	//@ for usb
	USBSend(KEY_2,UPPER);
    12c6:	62 e0       	ldi	r22, 0x02	; 2
    12c8:	8f e1       	ldi	r24, 0x1F	; 31
    12ca:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	USBSendPROGString(Str_USB_Only);
    12ce:	86 e5       	ldi	r24, 0x56	; 86
    12d0:	94 e0       	ldi	r25, 0x04	; 4
    12d2:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	KeyPressed = WaitForKeypress();
    12d6:	05 dc       	rcall	.-2038   	; 0xae2 <WaitForKeypress>
    12d8:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
    12da:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>

	TeachHIDKey(KEY_2|FORCE_UPPER,KeyPressed,Modifier);
    12de:	be 01       	movw	r22, r28
    12e0:	77 27       	eor	r23, r23
    12e2:	48 2f       	mov	r20, r24
    12e4:	8f e9       	ldi	r24, 0x9F	; 159
    12e6:	0c dc       	rcall	.-2024   	; 0xb00 <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
    12e8:	60 e0       	ldi	r22, 0x00	; 0
    12ea:	88 e2       	ldi	r24, 0x28	; 40
    12ec:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
	//?
	USBSend(KEY_SLASH,UPPER);
    12f0:	62 e0       	ldi	r22, 0x02	; 2
    12f2:	88 e3       	ldi	r24, 0x38	; 56
    12f4:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	USBSendPROGString(Str_SD_Only);
    12f8:	8d e7       	ldi	r24, 0x7D	; 125
    12fa:	94 e0       	ldi	r25, 0x04	; 4
    12fc:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSend(KEY_SPACE,LOWER);
    1300:	60 e0       	ldi	r22, 0x00	; 0
    1302:	8c e2       	ldi	r24, 0x2C	; 44
    1304:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
    1308:	ec db       	rcall	.-2088   	; 0xae2 <WaitForKeypress>
    130a:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
    130c:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
    1310:	18 2f       	mov	r17, r24
	TeachASCIIKey('?',KeyPressed,Modifier);
    1312:	be 01       	movw	r22, r28
    1314:	77 27       	eor	r23, r23
    1316:	48 2f       	mov	r20, r24
    1318:	8f e3       	ldi	r24, 0x3F	; 63
    131a:	4e dd       	rcall	.-1380   	; 0xdb8 <TeachASCIIKey>
	if(Modifier==HID_KEYBOARD_MODIFIER_LEFTSHIFT){
    131c:	12 30       	cpi	r17, 0x02	; 2
    131e:	41 f4       	brne	.+16     	; 0x1330 <Calibrate+0x458>
		USBSendString("SHIFT");
    1320:	87 e2       	ldi	r24, 0x27	; 39
    1322:	92 e0       	ldi	r25, 0x02	; 2
    1324:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
		USBSend(KEY_EQ,UPPER); //send a + sign
    1328:	62 e0       	ldi	r22, 0x02	; 2
    132a:	8e e2       	ldi	r24, 0x2E	; 46
    132c:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	}
	USBSendNumber(KeyPressed);
    1330:	8c 2f       	mov	r24, r28
    1332:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    1336:	60 e0       	ldi	r22, 0x00	; 0
    1338:	88 e2       	ldi	r24, 0x28	; 40
    133a:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
    133e:	2f ef       	ldi	r18, 0xFF	; 255
    1340:	84 e3       	ldi	r24, 0x34	; 52
    1342:	9c e0       	ldi	r25, 0x0C	; 12
    1344:	21 50       	subi	r18, 0x01	; 1
    1346:	80 40       	sbci	r24, 0x00	; 0
    1348:	90 40       	sbci	r25, 0x00	; 0
    134a:	e1 f7       	brne	.-8      	; 0x1344 <Calibrate+0x46c>
    134c:	00 c0       	rjmp	.+0      	; 0x134e <Calibrate+0x476>
    134e:	00 00       	nop
	
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
	
//for USB

	USBSend(KEY_SLASH,UPPER);
    1350:	62 e0       	ldi	r22, 0x02	; 2
    1352:	88 e3       	ldi	r24, 0x38	; 56
    1354:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	USBSendPROGString(Str_USB_Only);
    1358:	86 e5       	ldi	r24, 0x56	; 86
    135a:	94 e0       	ldi	r25, 0x04	; 4
    135c:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	KeyPressed = WaitForKeypress();
    1360:	c0 db       	rcall	.-2176   	; 0xae2 <WaitForKeypress>
    1362:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
    1364:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>

	TeachHIDKey(KEY_SLASH|FORCE_UPPER,KeyPressed,Modifier);
    1368:	be 01       	movw	r22, r28
    136a:	77 27       	eor	r23, r23
    136c:	48 2f       	mov	r20, r24
    136e:	88 eb       	ldi	r24, 0xB8	; 184
    1370:	c7 db       	rcall	.-2162   	; 0xb00 <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
    1372:	60 e0       	ldi	r22, 0x00	; 0
    1374:	88 e2       	ldi	r24, 0x28	; 40
    1376:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
	//!
	USBSend(KEY_1|FORCE_UPPER,UPPER);
    137a:	62 e0       	ldi	r22, 0x02	; 2
    137c:	8e e9       	ldi	r24, 0x9E	; 158
    137e:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	USBSend(KEY_SPACE,LOWER);
    1382:	60 e0       	ldi	r22, 0x00	; 0
    1384:	8c e2       	ldi	r24, 0x2C	; 44
    1386:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	KeyPressed = WaitForKeypress();
    138a:	ab db       	rcall	.-2218   	; 0xae2 <WaitForKeypress>
    138c:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
    138e:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
    1392:	18 2f       	mov	r17, r24

	if(!(Modifier&FN_MODIFIER&UPPER)){ //don't bother dealing with complicated combinations of FN and Shift to produce an !
		TeachHIDKey(KEY_1|FORCE_UPPER,KeyPressed,Modifier);
    1394:	dd 27       	eor	r29, r29
    1396:	48 2f       	mov	r20, r24
    1398:	be 01       	movw	r22, r28
    139a:	8e e9       	ldi	r24, 0x9E	; 158
    139c:	b1 db       	rcall	.-2206   	; 0xb00 <TeachHIDKey>
		TeachASCIIKey('!',KeyPressed,Modifier);
    139e:	41 2f       	mov	r20, r17
    13a0:	be 01       	movw	r22, r28
    13a2:	81 e2       	ldi	r24, 0x21	; 33
    13a4:	09 dd       	rcall	.-1518   	; 0xdb8 <TeachASCIIKey>
	}
	 
	USBSend(KEY_ENTER,LOWER);
    13a6:	60 e0       	ldi	r22, 0x00	; 0
    13a8:	88 e2       	ldi	r24, 0x28	; 40
    13aa:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	
	
//------TEACH REED SWITCHES--------//
	CalibrateReeds();
    13ae:	d4 db       	rcall	.-2136   	; 0xb58 <CalibrateReeds>
	
	SaveCalibration();
    13b0:	f1 da       	rcall	.-2590   	; 0x994 <SaveCalibration>
	
	USBSendPROGString(Str_Settings_Saved);
    13b2:	87 e6       	ldi	r24, 0x67	; 103
    13b4:	92 e0       	ldi	r25, 0x02	; 2
	
}
    13b6:	df 91       	pop	r29
    13b8:	cf 91       	pop	r28
    13ba:	1f 91       	pop	r17
    13bc:	0f 91       	pop	r16
    13be:	ff 90       	pop	r15
    13c0:	ef 90       	pop	r14
    13c2:	df 90       	pop	r13
    13c4:	cf 90       	pop	r12
    13c6:	bf 90       	pop	r11
    13c8:	af 90       	pop	r10
    13ca:	9f 90       	pop	r9
    13cc:	8f 90       	pop	r8
    13ce:	7f 90       	pop	r7
    13d0:	6f 90       	pop	r6
//------TEACH REED SWITCHES--------//
	CalibrateReeds();
	
	SaveCalibration();
	
	USBSendPROGString(Str_Settings_Saved);
    13d2:	0c 94 28 28 	jmp	0x5050	; 0x5050 <USBSendPROGString>

000013d6 <Adjust_Sensitivity>:
	else{
		ASCIILookUpTable[keypressed] = teachkey;
	}
}

void Adjust_Sensitivity(){
    13d6:	cf 93       	push	r28
	KeyHoldTime = eeprom_read_byte((uint8_t*)HOLD_TIME_ADDR);
    13d8:	81 e0       	ldi	r24, 0x01	; 1
    13da:	92 e0       	ldi	r25, 0x02	; 2
    13dc:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    13e0:	80 93 c9 06 	sts	0x06C9, r24
	KeyReleaseTime = eeprom_read_byte((uint8_t*)RELEASE_TIME_ADDR);
    13e4:	82 e0       	ldi	r24, 0x02	; 2
    13e6:	92 e0       	ldi	r25, 0x02	; 2
    13e8:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    13ec:	80 93 3a 06 	sts	0x063A, r24
	DoubleTapTime= eeprom_read_byte((uint8_t*)DOUBLE_TAP_ADDR);
    13f0:	80 e0       	ldi	r24, 0x00	; 0
    13f2:	92 e0       	ldi	r25, 0x02	; 2
    13f4:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    13f8:	80 93 7d 06 	sts	0x067D, r24
	
	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
    13fc:	80 91 ce 09 	lds	r24, 0x09CE
    1400:	84 30       	cpi	r24, 0x04	; 4
    1402:	e1 f7       	brne	.-8      	; 0x13fc <Adjust_Sensitivity+0x26>
    1404:	2f ef       	ldi	r18, 0xFF	; 255
    1406:	89 e6       	ldi	r24, 0x69	; 105
    1408:	98 e1       	ldi	r25, 0x18	; 24
    140a:	21 50       	subi	r18, 0x01	; 1
    140c:	80 40       	sbci	r24, 0x00	; 0
    140e:	90 40       	sbci	r25, 0x00	; 0
    1410:	e1 f7       	brne	.-8      	; 0x140a <Adjust_Sensitivity+0x34>
    1412:	00 c0       	rjmp	.+0      	; 0x1414 <Adjust_Sensitivity+0x3e>
    1414:	00 00       	nop
	Delay_MS(1000);//wait 1 second.
	
	USBSendPROGString(Str_Adj_Sensitivity);
    1416:	8c e5       	ldi	r24, 0x5C	; 92
    1418:	93 e0       	ldi	r25, 0x03	; 3
    141a:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSendPROGString(Str_Press_CMD);
    141e:	8e e3       	ldi	r24, 0x3E	; 62
    1420:	93 e0       	ldi	r25, 0x03	; 3
    1422:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	while(is_high(S3)){;}
    1426:	7e 99       	sbic	0x0f, 6	; 15
    1428:	fe cf       	rjmp	.-4      	; 0x1426 <Adjust_Sensitivity+0x50>
	
	USBSendPROGString(Str_Set_Reaction_Time);
    142a:	8e e0       	ldi	r24, 0x0E	; 14
    142c:	93 e0       	ldi	r25, 0x03	; 3
    142e:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSendNumber(KeyHoldTime);
    1432:	80 91 c9 06 	lds	r24, 0x06C9
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
		if(is_low(S1)){KeyHoldTime++;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){KeyHoldTime--;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
    1436:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
    143a:	60 e0       	ldi	r22, 0x00	; 0
    143c:	88 e2       	ldi	r24, 0x28	; 40
    143e:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	while(is_high(S3)){;}
	
	USBSendPROGString(Str_Set_Reaction_Time);
	USBSendNumber(KeyHoldTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    1442:	7e 9b       	sbis	0x0f, 6	; 15
    1444:	15 c0       	rjmp	.+42     	; 0x1470 <Adjust_Sensitivity+0x9a>
		if(is_low(S1)){KeyHoldTime++;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
    1446:	7c 99       	sbic	0x0f, 4	; 15
    1448:	0b c0       	rjmp	.+22     	; 0x1460 <Adjust_Sensitivity+0x8a>
    144a:	80 91 c9 06 	lds	r24, 0x06C9
    144e:	8f 5f       	subi	r24, 0xFF	; 255
    1450:	80 93 c9 06 	sts	0x06C9, r24
    1454:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
    1458:	60 e0       	ldi	r22, 0x00	; 0
    145a:	88 e2       	ldi	r24, 0x28	; 40
    145c:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
		if(is_low(S2)){KeyHoldTime--;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
    1460:	7d 99       	sbic	0x0f, 5	; 15
    1462:	ef cf       	rjmp	.-34     	; 0x1442 <Adjust_Sensitivity+0x6c>
    1464:	80 91 c9 06 	lds	r24, 0x06C9
    1468:	81 50       	subi	r24, 0x01	; 1
    146a:	80 93 c9 06 	sts	0x06C9, r24
    146e:	e3 cf       	rjmp	.-58     	; 0x1436 <Adjust_Sensitivity+0x60>
	}
	
	USBSendPROGString(Str_Set_Release_Time);
    1470:	80 ef       	ldi	r24, 0xF0	; 240
    1472:	92 e0       	ldi	r25, 0x02	; 2
    1474:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSendNumber(KeyReleaseTime);
    1478:	80 91 3a 06 	lds	r24, 0x063A
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
		if(is_low(S1)){KeyReleaseTime++;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){KeyReleaseTime--;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
    147c:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
    1480:	60 e0       	ldi	r22, 0x00	; 0
    1482:	88 e2       	ldi	r24, 0x28	; 40
    1484:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	}
	
	USBSendPROGString(Str_Set_Release_Time);
	USBSendNumber(KeyReleaseTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    1488:	7e 9b       	sbis	0x0f, 6	; 15
    148a:	15 c0       	rjmp	.+42     	; 0x14b6 <Adjust_Sensitivity+0xe0>
		if(is_low(S1)){KeyReleaseTime++;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
    148c:	7c 99       	sbic	0x0f, 4	; 15
    148e:	0b c0       	rjmp	.+22     	; 0x14a6 <Adjust_Sensitivity+0xd0>
    1490:	80 91 3a 06 	lds	r24, 0x063A
    1494:	8f 5f       	subi	r24, 0xFF	; 255
    1496:	80 93 3a 06 	sts	0x063A, r24
    149a:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
    149e:	60 e0       	ldi	r22, 0x00	; 0
    14a0:	88 e2       	ldi	r24, 0x28	; 40
    14a2:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
		if(is_low(S2)){KeyReleaseTime--;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
    14a6:	7d 99       	sbic	0x0f, 5	; 15
    14a8:	ef cf       	rjmp	.-34     	; 0x1488 <Adjust_Sensitivity+0xb2>
    14aa:	80 91 3a 06 	lds	r24, 0x063A
    14ae:	81 50       	subi	r24, 0x01	; 1
    14b0:	80 93 3a 06 	sts	0x063A, r24
    14b4:	e3 cf       	rjmp	.-58     	; 0x147c <Adjust_Sensitivity+0xa6>
	}
	
	USBSendPROGString(Str_Set_Double_Time);
    14b6:	82 ec       	ldi	r24, 0xC2	; 194
    14b8:	92 e0       	ldi	r25, 0x02	; 2
    14ba:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSendNumber(DoubleTapTime);
    14be:	80 91 7d 06 	lds	r24, 0x067D
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
		if(is_low(S1)){DoubleTapTime++;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){DoubleTapTime--;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
    14c2:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
    14c6:	60 e0       	ldi	r22, 0x00	; 0
    14c8:	88 e2       	ldi	r24, 0x28	; 40
    14ca:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	}
	
	USBSendPROGString(Str_Set_Double_Time);
	USBSendNumber(DoubleTapTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    14ce:	7e 9b       	sbis	0x0f, 6	; 15
    14d0:	15 c0       	rjmp	.+42     	; 0x14fc <Adjust_Sensitivity+0x126>
		if(is_low(S1)){DoubleTapTime++;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
    14d2:	7c 99       	sbic	0x0f, 4	; 15
    14d4:	0b c0       	rjmp	.+22     	; 0x14ec <Adjust_Sensitivity+0x116>
    14d6:	80 91 7d 06 	lds	r24, 0x067D
    14da:	8f 5f       	subi	r24, 0xFF	; 255
    14dc:	80 93 7d 06 	sts	0x067D, r24
    14e0:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
    14e4:	60 e0       	ldi	r22, 0x00	; 0
    14e6:	88 e2       	ldi	r24, 0x28	; 40
    14e8:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
		if(is_low(S2)){DoubleTapTime--;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
    14ec:	7d 99       	sbic	0x0f, 5	; 15
    14ee:	ef cf       	rjmp	.-34     	; 0x14ce <Adjust_Sensitivity+0xf8>
    14f0:	80 91 7d 06 	lds	r24, 0x067D
    14f4:	81 50       	subi	r24, 0x01	; 1
    14f6:	80 93 7d 06 	sts	0x067D, r24
    14fa:	e3 cf       	rjmp	.-58     	; 0x14c2 <Adjust_Sensitivity+0xec>
	}
	
	USBSendPROGString(Str_Set_Reed_Time);
    14fc:	82 ea       	ldi	r24, 0xA2	; 162
    14fe:	92 e0       	ldi	r25, 0x02	; 2
    1500:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	USBSendNumber(ReedHoldTime);
    1504:	80 91 7c 06 	lds	r24, 0x067C
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
		if(is_low(S1)){ReedHoldTime++;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
    1508:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
    150c:	60 e0       	ldi	r22, 0x00	; 0
    150e:	88 e2       	ldi	r24, 0x28	; 40
    1510:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
	}
	
	USBSendPROGString(Str_Set_Reed_Time);
	USBSendNumber(ReedHoldTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    1514:	7e 9b       	sbis	0x0f, 6	; 15
    1516:	15 c0       	rjmp	.+42     	; 0x1542 <Adjust_Sensitivity+0x16c>
		if(is_low(S1)){ReedHoldTime++;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
    1518:	7c 99       	sbic	0x0f, 4	; 15
    151a:	0b c0       	rjmp	.+22     	; 0x1532 <Adjust_Sensitivity+0x15c>
    151c:	80 91 7c 06 	lds	r24, 0x067C
    1520:	8f 5f       	subi	r24, 0xFF	; 255
    1522:	80 93 7c 06 	sts	0x067C, r24
    1526:	0e 94 30 28 	call	0x5060	; 0x5060 <USBSendNumber>
    152a:	60 e0       	ldi	r22, 0x00	; 0
    152c:	88 e2       	ldi	r24, 0x28	; 40
    152e:	0e 94 6c 27 	call	0x4ed8	; 0x4ed8 <USBSend>
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
    1532:	7d 99       	sbic	0x0f, 5	; 15
    1534:	ef cf       	rjmp	.-34     	; 0x1514 <Adjust_Sensitivity+0x13e>
    1536:	80 91 7c 06 	lds	r24, 0x067C
    153a:	81 50       	subi	r24, 0x01	; 1
    153c:	80 93 7c 06 	sts	0x067C, r24
    1540:	e3 cf       	rjmp	.-58     	; 0x1508 <Adjust_Sensitivity+0x132>
	}	
	
	USBSendPROGString(Str_Spacebar_Blocks_Enter);
    1542:	88 e7       	ldi	r24, 0x78	; 120
    1544:	92 e0       	ldi	r25, 0x02	; 2
    1546:	0e 94 28 28 	call	0x5050	; 0x5050 <USBSendPROGString>
	Reeds_Are_Independent ? USBSendString("NO\r") : USBSendString("YES\r");
    154a:	80 91 38 06 	lds	r24, 0x0638
    154e:	88 23       	and	r24, r24
    1550:	19 f0       	breq	.+6      	; 0x1558 <Adjust_Sensitivity+0x182>
    1552:	8b e4       	ldi	r24, 0x4B	; 75
    1554:	92 e0       	ldi	r25, 0x02	; 2
    1556:	02 c0       	rjmp	.+4      	; 0x155c <Adjust_Sensitivity+0x186>
    1558:	8f e4       	ldi	r24, 0x4F	; 79
    155a:	92 e0       	ldi	r25, 0x02	; 2
    155c:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
	while(is_high(S3)){
		if(is_low(S1)){Reeds_Are_Independent = false; USBSendString("YES\r");}
		if(is_low(S2)){Reeds_Are_Independent = true; USBSendString("NO\r");}
    1560:	c1 e0       	ldi	r28, 0x01	; 1
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
	}	
	
	USBSendPROGString(Str_Spacebar_Blocks_Enter);
	Reeds_Are_Independent ? USBSendString("NO\r") : USBSendString("YES\r");
	while(is_high(S3)){
    1562:	7e 9b       	sbis	0x0f, 6	; 15
    1564:	15 c0       	rjmp	.+42     	; 0x1590 <Adjust_Sensitivity+0x1ba>
		if(is_low(S1)){Reeds_Are_Independent = false; USBSendString("YES\r");}
    1566:	7c 99       	sbic	0x0f, 4	; 15
    1568:	06 c0       	rjmp	.+12     	; 0x1576 <Adjust_Sensitivity+0x1a0>
    156a:	10 92 38 06 	sts	0x0638, r1
    156e:	8f e4       	ldi	r24, 0x4F	; 79
    1570:	92 e0       	ldi	r25, 0x02	; 2
    1572:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
		if(is_low(S2)){Reeds_Are_Independent = true; USBSendString("NO\r");}
    1576:	7d 99       	sbic	0x0f, 5	; 15
    1578:	06 c0       	rjmp	.+12     	; 0x1586 <Adjust_Sensitivity+0x1b0>
    157a:	c0 93 38 06 	sts	0x0638, r28
    157e:	8b e4       	ldi	r24, 0x4B	; 75
    1580:	92 e0       	ldi	r25, 0x02	; 2
    1582:	0e 94 b7 27 	call	0x4f6e	; 0x4f6e <USBSendString>
		while(is_low(S1)||is_low(S2)){;}//wait until one of the switches is released before looping.
    1586:	7c 9b       	sbis	0x0f, 4	; 15
    1588:	fe cf       	rjmp	.-4      	; 0x1586 <Adjust_Sensitivity+0x1b0>
    158a:	7d 9b       	sbis	0x0f, 5	; 15
    158c:	fc cf       	rjmp	.-8      	; 0x1586 <Adjust_Sensitivity+0x1b0>
    158e:	e9 cf       	rjmp	.-46     	; 0x1562 <Adjust_Sensitivity+0x18c>
	}
	
	eeprom_update_byte((uint8_t*)DOUBLE_TAP_ADDR,DoubleTapTime);
    1590:	60 91 7d 06 	lds	r22, 0x067D
    1594:	80 e0       	ldi	r24, 0x00	; 0
    1596:	92 e0       	ldi	r25, 0x02	; 2
    1598:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)RELEASE_TIME_ADDR,KeyReleaseTime);
    159c:	60 91 3a 06 	lds	r22, 0x063A
    15a0:	82 e0       	ldi	r24, 0x02	; 2
    15a2:	92 e0       	ldi	r25, 0x02	; 2
    15a4:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)HOLD_TIME_ADDR,KeyHoldTime);
    15a8:	60 91 c9 06 	lds	r22, 0x06C9
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	92 e0       	ldi	r25, 0x02	; 2
    15b0:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)REED_HOLD_TIME_ADDR,ReedHoldTime);
    15b4:	60 91 7c 06 	lds	r22, 0x067C
    15b8:	8c e0       	ldi	r24, 0x0C	; 12
    15ba:	92 e0       	ldi	r25, 0x02	; 2
    15bc:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)REEDS_INDEPENDENT_ADDR,Reeds_Are_Independent);
    15c0:	60 91 38 06 	lds	r22, 0x0638
    15c4:	8e e0       	ldi	r24, 0x0E	; 14
    15c6:	92 e0       	ldi	r25, 0x02	; 2
    15c8:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
	
	USBSendPROGString(Str_Settings_Saved);
    15cc:	87 e6       	ldi	r24, 0x67	; 103
    15ce:	92 e0       	ldi	r25, 0x02	; 2
}
    15d0:	cf 91       	pop	r28
	eeprom_update_byte((uint8_t*)RELEASE_TIME_ADDR,KeyReleaseTime);
	eeprom_update_byte((uint8_t*)HOLD_TIME_ADDR,KeyHoldTime);
	eeprom_update_byte((uint8_t*)REED_HOLD_TIME_ADDR,ReedHoldTime);
	eeprom_update_byte((uint8_t*)REEDS_INDEPENDENT_ADDR,Reeds_Are_Independent);
	
	USBSendPROGString(Str_Settings_Saved);
    15d2:	0c 94 28 28 	jmp	0x5050	; 0x5050 <USBSendPROGString>

000015d6 <Config_Interrupts>:


void Config_Interrupts(){

	
	bit_clr(PRR0,PRTIM1); // clear power-reduction bit for timer1
    15d6:	e4 e6       	ldi	r30, 0x64	; 100
    15d8:	f0 e0       	ldi	r31, 0x00	; 0
    15da:	80 81       	ld	r24, Z
    15dc:	87 7f       	andi	r24, 0xF7	; 247
    15de:	80 83       	st	Z, r24
	TCCR1B = BIT(CTC1) | BIT(CS11); //set CTC (clear timer on compare equal mode) and set tmr prescaler to 8 -- page 125 of datasheet
    15e0:	8a e0       	ldi	r24, 0x0A	; 10
    15e2:	80 93 81 00 	sts	0x0081, r24
	
	OCR1AH = TIMER1_COMPARE_HIGH;//high register MUST be written before low register.  Datasheet says so!
    15e6:	87 e2       	ldi	r24, 0x27	; 39
    15e8:	80 93 89 00 	sts	0x0089, r24
	OCR1AL = UINT8_C(TIMER1_COMPARE_LOW); //we only want the first 8 bits of the "low" variable.
    15ec:	80 e1       	ldi	r24, 0x10	; 16
    15ee:	80 93 88 00 	sts	0x0088, r24
	
	bit_set(TIMSK1,OCIE1A); //enable output compare interrupt for timer1
    15f2:	ef e6       	ldi	r30, 0x6F	; 111
    15f4:	f0 e0       	ldi	r31, 0x00	; 0
    15f6:	80 81       	ld	r24, Z
    15f8:	82 60       	ori	r24, 0x02	; 2
    15fa:	80 83       	st	Z, r24
    15fc:	08 95       	ret

000015fe <Config_IO>:
volatile uint8_t GlowDirection; //global variable that sets direction of led glow (fade up or down)


void Config_IO(){
	
	configure_as_input(SD_DETECT);
    15fe:	20 98       	cbi	0x04, 0	; 4
	pullup_on(SD_DETECT);
    1600:	28 9a       	sbi	0x05, 0	; 5
	
	configure_as_input(REED_1);
    1602:	54 98       	cbi	0x0a, 4	; 10
	pullup_on(REED_1);
    1604:	5c 9a       	sbi	0x0b, 4	; 11
	
	configure_as_input(REED_2);
    1606:	56 98       	cbi	0x0a, 6	; 10
	pullup_on(REED_2);	
    1608:	5e 9a       	sbi	0x0b, 6	; 11

	configure_as_input(REED_3);
    160a:	57 98       	cbi	0x0a, 7	; 10
	pullup_on(REED_3);	
    160c:	5f 9a       	sbi	0x0b, 7	; 11
	
	configure_as_input(REED_4);
    160e:	24 98       	cbi	0x04, 4	; 4
	pullup_on(REED_4);	
    1610:	2c 9a       	sbi	0x05, 4	; 5
	
	
	set_high(SD_MISO);
    1612:	2b 9a       	sbi	0x05, 3	; 5
	configure_as_input(SD_MISO);
    1614:	23 98       	cbi	0x04, 3	; 4
	pullup_on(SD_MISO);
    1616:	2b 9a       	sbi	0x05, 3	; 5
	
	set_high(SD_MOSI);
    1618:	2a 9a       	sbi	0x05, 2	; 5
	configure_as_input(SD_MOSI);
    161a:	22 98       	cbi	0x04, 2	; 4
	pullup_on(SD_MOSI);
    161c:	2a 9a       	sbi	0x05, 2	; 5
	
	configure_as_output(SENSE_CLK);
    161e:	6a 9a       	sbi	0x0d, 2	; 13
	
	configure_as_input(SENSE_SER);
    1620:	25 98       	cbi	0x04, 5	; 4
	pullup_on(SENSE_SER);
    1622:	2d 9a       	sbi	0x05, 5	; 5

	set_high(SD_CLK);
    1624:	29 9a       	sbi	0x05, 1	; 5
	configure_as_input(SD_CLK);
    1626:	21 98       	cbi	0x04, 1	; 4
	pullup_on(SD_CLK);
    1628:	29 9a       	sbi	0x05, 1	; 5
	
	set_high(SD_CHIP_SELECT);
    162a:	59 9a       	sbi	0x0b, 1	; 11
	configure_as_output(SD_CHIP_SELECT);
    162c:	51 9a       	sbi	0x0a, 1	; 10
	
	configure_as_input(DUMMY_LOAD);
    162e:	55 98       	cbi	0x0a, 5	; 10
	//no pullup;
	
	set_high(TX);
    1630:	5b 9a       	sbi	0x0b, 3	; 11
	configure_as_output(TX);
    1632:	53 9a       	sbi	0x0a, 3	; 10
	
	configure_as_input(RX);
    1634:	52 98       	cbi	0x0a, 2	; 10
	pullup_on(RX);
    1636:	5a 9a       	sbi	0x0b, 2	; 11
	
	configure_as_input(S1);
    1638:	84 98       	cbi	0x10, 4	; 16
	pullup_on(S1);
    163a:	8c 9a       	sbi	0x11, 4	; 17
	
	configure_as_input(S2);
    163c:	85 98       	cbi	0x10, 5	; 16
	pullup_on(S2);
    163e:	8d 9a       	sbi	0x11, 5	; 17
	
	configure_as_input(S3);
    1640:	86 98       	cbi	0x10, 6	; 16
	pullup_on(S3);
    1642:	8e 9a       	sbi	0x11, 6	; 17
	
	set_low(BT_RESET);// bt is off by default
    1644:	8f 98       	cbi	0x11, 7	; 17
	configure_as_output(BT_RESET); 
    1646:	87 9a       	sbi	0x10, 7	; 16
	
	set_high(BT_BAUD);
    1648:	47 9a       	sbi	0x08, 7	; 8
	configure_as_output(BT_BAUD);
    164a:	3f 9a       	sbi	0x07, 7	; 7
	
	configure_as_input(BT_CONNECTED);
    164c:	81 98       	cbi	0x10, 1	; 16
	pullup_on(BT_CONNECTED);
    164e:	89 9a       	sbi	0x11, 1	; 17
	
	set_high(BT_CTS);
    1650:	76 9a       	sbi	0x0e, 6	; 14
	configure_as_output(BT_CTS);
    1652:	6e 9a       	sbi	0x0d, 6	; 13
	
	set_high(LED1);
    1654:	46 9a       	sbi	0x08, 6	; 8
	configure_as_output(LED1);
    1656:	3e 9a       	sbi	0x07, 6	; 7
	
	set_high(LED2);
    1658:	2e 9a       	sbi	0x05, 6	; 5
	configure_as_output(LED2);
    165a:	26 9a       	sbi	0x04, 6	; 4
    165c:	08 95       	ret

0000165e <GlowGreenLED>:
}

void GlowGreenLED(uint8_t speed, uint8_t mode){

	//green led is also called the ~OC4A pin
	cli();//disable interrupts;
    165e:	f8 94       	cli
	OCR4C = 0xFF; //clear tmr4 when reaching this value
    1660:	9f ef       	ldi	r25, 0xFF	; 255
    1662:	90 93 d1 00 	sts	0x00D1, r25
	TC4H = 0x00; //clearing this register sets timer4 to 8-bit mode
    1666:	10 92 bf 00 	sts	0x00BF, r1
	OCR4A = 0x20; //when counter reaches this value, it triggers LED.
    166a:	90 e2       	ldi	r25, 0x20	; 32
    166c:	90 93 cf 00 	sts	0x00CF, r25
	
	if(mode == SOLID){
		bit_clr(TCCR4E,OC4OE0);//disconnect ~oc4a output
    1670:	90 91 c4 00 	lds	r25, 0x00C4
	cli();//disable interrupts;
	OCR4C = 0xFF; //clear tmr4 when reaching this value
	TC4H = 0x00; //clearing this register sets timer4 to 8-bit mode
	OCR4A = 0x20; //when counter reaches this value, it triggers LED.
	
	if(mode == SOLID){
    1674:	61 30       	cpi	r22, 0x01	; 1
    1676:	51 f4       	brne	.+20     	; 0x168c <GlowGreenLED+0x2e>
		bit_clr(TCCR4E,OC4OE0);//disconnect ~oc4a output
    1678:	9e 7f       	andi	r25, 0xFE	; 254
    167a:	90 93 c4 00 	sts	0x00C4, r25
		bit_clr(TCCR4A,COM4A0); //clear the bit for ~OC4A pin to be active in fast pwm mode
    167e:	90 91 c0 00 	lds	r25, 0x00C0
    1682:	9f 7b       	andi	r25, 0xBF	; 191
    1684:	90 93 c0 00 	sts	0x00C0, r25
		set_low(GREEN_LED);	//manually pull led low
    1688:	46 98       	cbi	0x08, 6	; 8
    168a:	08 c0       	rjmp	.+16     	; 0x169c <GlowGreenLED+0x3e>
	}
	else{
		bit_set(TCCR4E,OC4OE0);//enable the ~oc4a output
    168c:	91 60       	ori	r25, 0x01	; 1
    168e:	90 93 c4 00 	sts	0x00C4, r25
		bit_set(TCCR4A,COM4A0); //set the bit for ~OC4A pin to be active in fast pwm mode
    1692:	90 91 c0 00 	lds	r25, 0x00C0
    1696:	90 64       	ori	r25, 0x40	; 64
    1698:	90 93 c0 00 	sts	0x00C0, r25
	}
	
	
	bit_set(TCCR4A,PWM4A);//activate fast pwm mode
    169c:	90 91 c0 00 	lds	r25, 0x00C0
    16a0:	92 60       	ori	r25, 0x02	; 2
    16a2:	90 93 c0 00 	sts	0x00C0, r25
	bit_set(TIMSK4,TOIE4);//enable timer overflow interrupts.
    16a6:	90 91 72 00 	lds	r25, 0x0072
    16aa:	94 60       	ori	r25, 0x04	; 4
    16ac:	90 93 72 00 	sts	0x0072, r25
	switch(speed){
    16b0:	81 30       	cpi	r24, 0x01	; 1
    16b2:	69 f0       	breq	.+26     	; 0x16ce <GlowGreenLED+0x70>
    16b4:	30 f0       	brcs	.+12     	; 0x16c2 <GlowGreenLED+0x64>
    16b6:	82 30       	cpi	r24, 0x02	; 2
    16b8:	41 f0       	breq	.+16     	; 0x16ca <GlowGreenLED+0x6c>
    16ba:	83 30       	cpi	r24, 0x03	; 3
    16bc:	41 f4       	brne	.+16     	; 0x16ce <GlowGreenLED+0x70>
		break;
		case 2:
			TCCR4B = BIT(CS42)|BIT(CS41)|BIT(CS40);
		break;
		case 3:
			TCCR4B = BIT(CS42)|BIT(CS41);
    16be:	86 e0       	ldi	r24, 0x06	; 6
    16c0:	09 c0       	rjmp	.+18     	; 0x16d4 <GlowGreenLED+0x76>
	
	bit_set(TCCR4A,PWM4A);//activate fast pwm mode
	bit_set(TIMSK4,TOIE4);//enable timer overflow interrupts.
	switch(speed){
		case 0:
			TCCR4B = BIT(CS43)|BIT(CS40);
    16c2:	89 e0       	ldi	r24, 0x09	; 9
    16c4:	80 93 c1 00 	sts	0x00C1, r24
    16c8:	02 c0       	rjmp	.+4      	; 0x16ce <GlowGreenLED+0x70>
		case 1:
			bit_set(TCCR4B,CS43);//enable 1:128 prescaler (should make each tick worth about 10khZ).
		break;
		case 2:
			TCCR4B = BIT(CS42)|BIT(CS41)|BIT(CS40);
    16ca:	87 e0       	ldi	r24, 0x07	; 7
    16cc:	03 c0       	rjmp	.+6      	; 0x16d4 <GlowGreenLED+0x76>
		break;
		case 3:
			TCCR4B = BIT(CS42)|BIT(CS41);
		break;
		default:
			bit_set(TCCR4B,CS43);
    16ce:	80 91 c1 00 	lds	r24, 0x00C1
    16d2:	88 60       	ori	r24, 0x08	; 8
    16d4:	80 93 c1 00 	sts	0x00C1, r24
		break;
	}
		
		GlowDirection = BRIGHTEN;
    16d8:	10 92 35 06 	sts	0x0635, r1
		TCNT4 = 0;//clear the timer to 0;}
    16dc:	10 92 bf 00 	sts	0x00BF, r1
    16e0:	10 92 be 00 	sts	0x00BE, r1

	sei();//enable interrupts again.
    16e4:	78 94       	sei
    16e6:	08 95       	ret

000016e8 <__vector_41>:
}

ISR(TIMER4_OVF_vect){ //called each time timer1 counts up to the OCR1A register (every couple ms)
    16e8:	1f 92       	push	r1
    16ea:	0f 92       	push	r0
    16ec:	0f b6       	in	r0, 0x3f	; 63
    16ee:	0f 92       	push	r0
    16f0:	11 24       	eor	r1, r1
    16f2:	8f 93       	push	r24
    16f4:	9f 93       	push	r25

	uint8_t temp;
	temp = OCR4A;
    16f6:	80 91 cf 00 	lds	r24, 0x00CF
	switch(GlowDirection){
    16fa:	90 91 35 06 	lds	r25, 0x0635
    16fe:	99 23       	and	r25, r25
    1700:	19 f0       	breq	.+6      	; 0x1708 <__vector_41+0x20>
    1702:	92 30       	cpi	r25, 0x02	; 2
    1704:	39 f0       	breq	.+14     	; 0x1714 <__vector_41+0x2c>
    1706:	0a c0       	rjmp	.+20     	; 0x171c <__vector_41+0x34>
	case BRIGHTEN:
		if(temp==0xFF) GlowDirection = DIM;
    1708:	8f 3f       	cpi	r24, 0xFF	; 255
    170a:	31 f4       	brne	.+12     	; 0x1718 <__vector_41+0x30>
    170c:	91 e0       	ldi	r25, 0x01	; 1
    170e:	90 93 35 06 	sts	0x0635, r25
    1712:	10 c0       	rjmp	.+32     	; 0x1734 <__vector_41+0x4c>
		else temp++;
	break;
	case BRIGHTEN_ONLY:
			if(temp!=0xFF) temp++;
    1714:	8f 3f       	cpi	r24, 0xFF	; 255
    1716:	71 f0       	breq	.+28     	; 0x1734 <__vector_41+0x4c>
    1718:	8f 5f       	subi	r24, 0xFF	; 255
    171a:	0c c0       	rjmp	.+24     	; 0x1734 <__vector_41+0x4c>
	break;
	case DIM:
	default:
		if(temp == 0x00){
    171c:	81 11       	cpse	r24, r1
    171e:	09 c0       	rjmp	.+18     	; 0x1732 <__vector_41+0x4a>
			bit_clr(TCCR4A,COM4A0); //disconnect green led output pin
    1720:	90 91 c0 00 	lds	r25, 0x00C0
    1724:	9f 7b       	andi	r25, 0xBF	; 191
    1726:	90 93 c0 00 	sts	0x00C0, r25
			TCCR4B = 0;//clear the timer4 register (disable the timer);
    172a:	10 92 c1 00 	sts	0x00C1, r1
			set_high(GREEN_LED); //turn off led
    172e:	46 9a       	sbi	0x08, 6	; 8
    1730:	01 c0       	rjmp	.+2      	; 0x1734 <__vector_41+0x4c>
		}
		else{
			temp--;
    1732:	81 50       	subi	r24, 0x01	; 1
		}
	break;
	}
	OCR4A = temp;
    1734:	80 93 cf 00 	sts	0x00CF, r24
}
    1738:	9f 91       	pop	r25
    173a:	8f 91       	pop	r24
    173c:	0f 90       	pop	r0
    173e:	0f be       	out	0x3f, r0	; 63
    1740:	0f 90       	pop	r0
    1742:	1f 90       	pop	r1
    1744:	18 95       	reti

00001746 <CALLBACK_USB_GetDescriptor>:
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
    1746:	29 2f       	mov	r18, r25
    1748:	33 27       	eor	r19, r19
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
    174a:	23 30       	cpi	r18, 0x03	; 3
    174c:	31 05       	cpc	r19, r1
    174e:	e1 f0       	breq	.+56     	; 0x1788 <CALLBACK_USB_GetDescriptor+0x42>
    1750:	5c f4       	brge	.+22     	; 0x1768 <CALLBACK_USB_GetDescriptor+0x22>
    1752:	21 30       	cpi	r18, 0x01	; 1
    1754:	31 05       	cpc	r19, r1
    1756:	99 f0       	breq	.+38     	; 0x177e <CALLBACK_USB_GetDescriptor+0x38>
    1758:	22 30       	cpi	r18, 0x02	; 2
    175a:	31 05       	cpc	r19, r1
    175c:	79 f5       	brne	.+94     	; 0x17bc <CALLBACK_USB_GetDescriptor+0x76>
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
    175e:	89 e3       	ldi	r24, 0x39	; 57
    1760:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
    1762:	24 e1       	ldi	r18, 0x14	; 20
    1764:	36 e0       	ldi	r19, 0x06	; 6
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
    1766:	2e c0       	rjmp	.+92     	; 0x17c4 <CALLBACK_USB_GetDescriptor+0x7e>
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
    1768:	21 32       	cpi	r18, 0x21	; 33
    176a:	31 05       	cpc	r19, r1
    176c:	11 f1       	breq	.+68     	; 0x17b2 <CALLBACK_USB_GetDescriptor+0x6c>
    176e:	22 32       	cpi	r18, 0x22	; 34
    1770:	31 05       	cpc	r19, r1
    1772:	21 f5       	brne	.+72     	; 0x17bc <CALLBACK_USB_GetDescriptor+0x76>
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
		case HID_DTYPE_Report:
			Address = &KeyboardReport;
			Size    = sizeof(KeyboardReport);
    1774:	8f e3       	ldi	r24, 0x3F	; 63
    1776:	90 e0       	ldi	r25, 0x00	; 0
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
		case HID_DTYPE_Report:
			Address = &KeyboardReport;
    1778:	2f e5       	ldi	r18, 0x5F	; 95
    177a:	36 e0       	ldi	r19, 0x06	; 6
			Size    = sizeof(KeyboardReport);
			break;
    177c:	23 c0       	rjmp	.+70     	; 0x17c4 <CALLBACK_USB_GetDescriptor+0x7e>

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
    177e:	82 e1       	ldi	r24, 0x12	; 18
    1780:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
    1782:	2d e4       	ldi	r18, 0x4D	; 77
    1784:	36 e0       	ldi	r19, 0x06	; 6
    1786:	1e c0       	rjmp	.+60     	; 0x17c4 <CALLBACK_USB_GetDescriptor+0x7e>
    1788:	99 27       	eor	r25, r25
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
    178a:	81 30       	cpi	r24, 0x01	; 1
    178c:	91 05       	cpc	r25, r1
    178e:	41 f0       	breq	.+16     	; 0x17a0 <CALLBACK_USB_GetDescriptor+0x5a>
    1790:	82 30       	cpi	r24, 0x02	; 2
    1792:	91 05       	cpc	r25, r1
    1794:	41 f0       	breq	.+16     	; 0x17a6 <CALLBACK_USB_GetDescriptor+0x60>
    1796:	89 2b       	or	r24, r25
    1798:	89 f4       	brne	.+34     	; 0x17bc <CALLBACK_USB_GetDescriptor+0x76>
			{
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
    179a:	e0 e1       	ldi	r30, 0x10	; 16
    179c:	f6 e0       	ldi	r31, 0x06	; 6
    179e:	05 c0       	rjmp	.+10     	; 0x17aa <CALLBACK_USB_GetDescriptor+0x64>
					break;
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
    17a0:	e8 ee       	ldi	r30, 0xE8	; 232
    17a2:	f5 e0       	ldi	r31, 0x05	; 5
    17a4:	02 c0       	rjmp	.+4      	; 0x17aa <CALLBACK_USB_GetDescriptor+0x64>
					break;
				case STRING_ID_Product:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
    17a6:	e6 eb       	ldi	r30, 0xB6	; 182
    17a8:	f5 e0       	ldi	r31, 0x05	; 5
    17aa:	84 91       	lpm	r24, Z
    17ac:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case STRING_ID_Product:
					Address = &ProductString;
    17ae:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
    17b0:	09 c0       	rjmp	.+18     	; 0x17c4 <CALLBACK_USB_GetDescriptor+0x7e>
			}

			break;
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
    17b2:	89 e0       	ldi	r24, 0x09	; 9
    17b4:	90 e0       	ldi	r25, 0x00	; 0
					break;
			}

			break;
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
    17b6:	2d e3       	ldi	r18, 0x3D	; 61
    17b8:	36 e0       	ldi	r19, 0x06	; 6
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
    17ba:	04 c0       	rjmp	.+8      	; 0x17c4 <CALLBACK_USB_GetDescriptor+0x7e>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
    17bc:	80 e0       	ldi	r24, 0x00	; 0
    17be:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
    17c0:	20 e0       	ldi	r18, 0x00	; 0
    17c2:	30 e0       	ldi	r19, 0x00	; 0
			Address = &KeyboardReport;
			Size    = sizeof(KeyboardReport);
			break;
	}

	*DescriptorAddress = Address;
    17c4:	fa 01       	movw	r30, r20
    17c6:	31 83       	std	Z+1, r19	; 0x01
    17c8:	20 83       	st	Z, r18
	return Size;
}
    17ca:	08 95       	ret

000017cc <OpenLogFile>:
			CloseLogFile(); // close log file so a new one can be opened later.
}

/** Opens the log file on the Dataflash's FAT formatted partition according to the current date */
FRESULT OpenLogFile(void)
{
    17cc:	cf 93       	push	r28
	
//	if (USB_DeviceState == DEVICE_STATE_Configured){
//		return FR_LOCKED; //the disk is locked if the USB is engaged.  This prevents collision with filesystem read/writes
//	}
	
		diskstatus = f_open(&LogFile, FileName, FA_OPEN_ALWAYS | FA_WRITE);
    17ce:	42 e1       	ldi	r20, 0x12	; 18
    17d0:	64 e2       	ldi	r22, 0x24	; 36
    17d2:	71 e0       	ldi	r23, 0x01	; 1
    17d4:	83 e5       	ldi	r24, 0x53	; 83
    17d6:	93 e0       	ldi	r25, 0x03	; 3
    17d8:	0e 94 41 1c 	call	0x3882	; 0x3882 <f_open>
		f_sync(&LogFile);
    17dc:	83 e5       	ldi	r24, 0x53	; 83
    17de:	93 e0       	ldi	r25, 0x03	; 3
    17e0:	0e 94 fd 1e 	call	0x3dfa	; 0x3dfa <f_sync>
		f_close(&LogFile);
    17e4:	83 e5       	ldi	r24, 0x53	; 83
    17e6:	93 e0       	ldi	r25, 0x03	; 3
    17e8:	0e 94 40 1f 	call	0x3e80	; 0x3e80 <f_close>
		diskstatus = f_open(&LogFile, FileName, FA_OPEN_ALWAYS | FA_WRITE);
    17ec:	42 e1       	ldi	r20, 0x12	; 18
    17ee:	64 e2       	ldi	r22, 0x24	; 36
    17f0:	71 e0       	ldi	r23, 0x01	; 1
    17f2:	83 e5       	ldi	r24, 0x53	; 83
    17f4:	93 e0       	ldi	r25, 0x03	; 3
    17f6:	0e 94 41 1c 	call	0x3882	; 0x3882 <f_open>
    17fa:	c8 2f       	mov	r28, r24
		
		f_lseek(&LogFile, LogFile.fsize);
    17fc:	40 91 5d 03 	lds	r20, 0x035D
    1800:	50 91 5e 03 	lds	r21, 0x035E
    1804:	60 91 5f 03 	lds	r22, 0x035F
    1808:	70 91 60 03 	lds	r23, 0x0360
    180c:	83 e5       	ldi	r24, 0x53	; 83
    180e:	93 e0       	ldi	r25, 0x03	; 3
    1810:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <f_lseek>
	
	return diskstatus;
}
    1814:	8c 2f       	mov	r24, r28
    1816:	cf 91       	pop	r28
    1818:	08 95       	ret

0000181a <CloseLogFile>:

/** Closes the open data log file on the Dataflash's FAT formatted partition */
void CloseLogFile(void)
{
	/* Sync any data waiting to be written, unmount the storage device */
	f_sync(&LogFile);
    181a:	83 e5       	ldi	r24, 0x53	; 83
    181c:	93 e0       	ldi	r25, 0x03	; 3
    181e:	0e 94 fd 1e 	call	0x3dfa	; 0x3dfa <f_sync>
	f_close(&LogFile);
    1822:	83 e5       	ldi	r24, 0x53	; 83
    1824:	93 e0       	ldi	r25, 0x03	; 3
    1826:	0c 94 40 1f 	jmp	0x3e80	; 0x3e80 <f_close>

0000182a <MountFilesystem>:
}

bool MountFilesystem(){
	bool diskstatus;
	diskstatus = f_mount(&DiskFATState,"",1);
    182a:	41 e0       	ldi	r20, 0x01	; 1
    182c:	66 e8       	ldi	r22, 0x86	; 134
    182e:	72 e0       	ldi	r23, 0x02	; 2
    1830:	83 e7       	ldi	r24, 0x73	; 115
    1832:	93 e0       	ldi	r25, 0x03	; 3
    1834:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <f_mount>
    1838:	91 e0       	ldi	r25, 0x01	; 1
    183a:	81 11       	cpse	r24, r1
    183c:	01 c0       	rjmp	.+2      	; 0x1840 <MountFilesystem+0x16>
    183e:	90 e0       	ldi	r25, 0x00	; 0
	return diskstatus;
}
    1840:	89 2f       	mov	r24, r25
    1842:	08 95       	ret

00001844 <get_num_of_sectors>:

uint32_t get_num_of_sectors(){
	static uint32_t tot_sect;
	if(!tot_sect){ //if we have not yet read a valid value into totsect
    1844:	80 91 4f 03 	lds	r24, 0x034F
    1848:	90 91 50 03 	lds	r25, 0x0350
    184c:	a0 91 51 03 	lds	r26, 0x0351
    1850:	b0 91 52 03 	lds	r27, 0x0352
    1854:	89 2b       	or	r24, r25
    1856:	8a 2b       	or	r24, r26
    1858:	8b 2b       	or	r24, r27
    185a:	d9 f4       	brne	.+54     	; 0x1892 <get_num_of_sectors+0x4e>
		tot_sect = (DiskFATState.n_fatent - 2) * DiskFATState.csize;
    185c:	a0 91 75 03 	lds	r26, 0x0375
    1860:	40 91 85 03 	lds	r20, 0x0385
    1864:	50 91 86 03 	lds	r21, 0x0386
    1868:	60 91 87 03 	lds	r22, 0x0387
    186c:	70 91 88 03 	lds	r23, 0x0388
    1870:	9a 01       	movw	r18, r20
    1872:	ab 01       	movw	r20, r22
    1874:	22 50       	subi	r18, 0x02	; 2
    1876:	31 09       	sbc	r19, r1
    1878:	41 09       	sbc	r20, r1
    187a:	51 09       	sbc	r21, r1
    187c:	b0 e0       	ldi	r27, 0x00	; 0
    187e:	0e 94 9c 35 	call	0x6b38	; 0x6b38 <__muluhisi3>
    1882:	60 93 4f 03 	sts	0x034F, r22
    1886:	70 93 50 03 	sts	0x0350, r23
    188a:	80 93 51 03 	sts	0x0351, r24
    188e:	90 93 52 03 	sts	0x0352, r25
	}
	return 	tot_sect;
    1892:	60 91 4f 03 	lds	r22, 0x034F
    1896:	70 91 50 03 	lds	r23, 0x0350
    189a:	80 91 51 03 	lds	r24, 0x0351
    189e:	90 91 52 03 	lds	r25, 0x0352
}
    18a2:	08 95       	ret

000018a4 <WriteToLogFile>:

bool WriteToLogFile(){
    18a4:	1f 93       	push	r17
    18a6:	cf 93       	push	r28
    18a8:	df 93       	push	r29
    18aa:	00 d0       	rcall	.+0      	; 0x18ac <WriteToLogFile+0x8>
    18ac:	cd b7       	in	r28, 0x3d	; 61
    18ae:	de b7       	in	r29, 0x3e	; 62
	UINT BytesWritten;
	uint8_t result;
	
	
	BytesWritten = strlen((char*)SD_Buffer);
    18b0:	ea e8       	ldi	r30, 0x8A	; 138
    18b2:	f7 e0       	ldi	r31, 0x07	; 7
    18b4:	01 90       	ld	r0, Z+
    18b6:	00 20       	and	r0, r0
    18b8:	e9 f7       	brne	.-6      	; 0x18b4 <WriteToLogFile+0x10>
    18ba:	31 97       	sbiw	r30, 0x01	; 1
    18bc:	ea 58       	subi	r30, 0x8A	; 138
    18be:	f7 40       	sbci	r31, 0x07	; 7
    18c0:	fa 83       	std	Y+2, r31	; 0x02
    18c2:	e9 83       	std	Y+1, r30	; 0x01
//	BytesWritten = sprintf(SD_Buffer, "TESTINGTESTING/r/n");//debug 
	f_lseek(&LogFile, LogFile.fsize);
    18c4:	40 91 5d 03 	lds	r20, 0x035D
    18c8:	50 91 5e 03 	lds	r21, 0x035E
    18cc:	60 91 5f 03 	lds	r22, 0x035F
    18d0:	70 91 60 03 	lds	r23, 0x0360
    18d4:	83 e5       	ldi	r24, 0x53	; 83
    18d6:	93 e0       	ldi	r25, 0x03	; 3
    18d8:	0e 94 50 1f 	call	0x3ea0	; 0x3ea0 <f_lseek>
	result = f_write(&LogFile, (void *) SD_Buffer, BytesWritten, &BytesWritten);
    18dc:	49 81       	ldd	r20, Y+1	; 0x01
    18de:	5a 81       	ldd	r21, Y+2	; 0x02
    18e0:	9e 01       	movw	r18, r28
    18e2:	2f 5f       	subi	r18, 0xFF	; 255
    18e4:	3f 4f       	sbci	r19, 0xFF	; 255
    18e6:	6a e8       	ldi	r22, 0x8A	; 138
    18e8:	77 e0       	ldi	r23, 0x07	; 7
    18ea:	83 e5       	ldi	r24, 0x53	; 83
    18ec:	93 e0       	ldi	r25, 0x03	; 3
    18ee:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <f_write>
    18f2:	18 2f       	mov	r17, r24
	SD_Buffer[0] = '\0'; //a simple way to clear the buffer (equivalent to saving an empty string into the buffer)
    18f4:	10 92 8a 07 	sts	0x078A, r1
	f_sync(&LogFile);
    18f8:	83 e5       	ldi	r24, 0x53	; 83
    18fa:	93 e0       	ldi	r25, 0x03	; 3
    18fc:	0e 94 fd 1e 	call	0x3dfa	; 0x3dfa <f_sync>
	
	return result;
    1900:	81 e0       	ldi	r24, 0x01	; 1
    1902:	11 11       	cpse	r17, r1
    1904:	01 c0       	rjmp	.+2      	; 0x1908 <WriteToLogFile+0x64>
    1906:	80 e0       	ldi	r24, 0x00	; 0
	
}
    1908:	0f 90       	pop	r0
    190a:	0f 90       	pop	r0
    190c:	df 91       	pop	r29
    190e:	cf 91       	pop	r28
    1910:	1f 91       	pop	r17
    1912:	08 95       	ret

00001914 <TestSDHardware>:

void TestSDHardware(){
		FRESULT diskstatus;
		
		diskstatus = MountFilesystem();
    1914:	8a df       	rcall	.-236    	; 0x182a <MountFilesystem>
		
		if (diskstatus != FR_OK){
    1916:	88 23       	and	r24, r24
    1918:	21 f0       	breq	.+8      	; 0x1922 <TestSDHardware+0xe>
			Typewriter_Mode = PANIC_MODE;
    191a:	8a e0       	ldi	r24, 0x0A	; 10
    191c:	80 93 89 07 	sts	0x0789, r24
    1920:	08 95       	ret
			return;
		}
		
		strcpy(FileName, "SDHW.TXT");
    1922:	62 e7       	ldi	r22, 0x72	; 114
    1924:	72 e0       	ldi	r23, 0x02	; 2
    1926:	84 e2       	ldi	r24, 0x24	; 36
    1928:	91 e0       	ldi	r25, 0x01	; 1
    192a:	0e 94 5c 36 	call	0x6cb8	; 0x6cb8 <strcpy>
		while(1){
		OpenLogFile();
    192e:	4e df       	rcall	.-356    	; 0x17cc <OpenLogFile>
		strcpy((CHAR*)SD_Buffer,"testphrase\n");
    1930:	6b e7       	ldi	r22, 0x7B	; 123
    1932:	72 e0       	ldi	r23, 0x02	; 2
    1934:	8a e8       	ldi	r24, 0x8A	; 138
    1936:	97 e0       	ldi	r25, 0x07	; 7
    1938:	0e 94 5c 36 	call	0x6cb8	; 0x6cb8 <strcpy>
		WriteToLogFile();
    193c:	b3 df       	rcall	.-154    	; 0x18a4 <WriteToLogFile>
		CloseLogFile();
    193e:	6d df       	rcall	.-294    	; 0x181a <CloseLogFile>
    1940:	2f ef       	ldi	r18, 0xFF	; 255
    1942:	80 e7       	ldi	r24, 0x70	; 112
    1944:	92 e0       	ldi	r25, 0x02	; 2
    1946:	21 50       	subi	r18, 0x01	; 1
    1948:	80 40       	sbci	r24, 0x00	; 0
    194a:	90 40       	sbci	r25, 0x00	; 0
    194c:	e1 f7       	brne	.-8      	; 0x1946 <TestSDHardware+0x32>
    194e:	00 c0       	rjmp	.+0      	; 0x1950 <TestSDHardware+0x3c>
    1950:	00 00       	nop
    1952:	ed cf       	rjmp	.-38     	; 0x192e <TestSDHardware+0x1a>

00001954 <AddToSDBuffer>:

void AddToSDBuffer(char character){
	UINT index;
	static char prevcharacter;
	
	index = strlen((char*)SD_Buffer); //index is moved to the end of the string saved in the SD_Buffer.
    1954:	ea e8       	ldi	r30, 0x8A	; 138
    1956:	f7 e0       	ldi	r31, 0x07	; 7
    1958:	01 90       	ld	r0, Z+
    195a:	00 20       	and	r0, r0
    195c:	e9 f7       	brne	.-6      	; 0x1958 <AddToSDBuffer+0x4>
    195e:	31 97       	sbiw	r30, 0x01	; 1
    1960:	9f 01       	movw	r18, r30
    1962:	2a 58       	subi	r18, 0x8A	; 138
    1964:	37 40       	sbci	r19, 0x07	; 7
	if (index >= SD_BUFFER_LENGTH-10){
    1966:	26 3f       	cpi	r18, 0xF6	; 246
    1968:	91 e0       	ldi	r25, 0x01	; 1
    196a:	39 07       	cpc	r19, r25
    196c:	08 f0       	brcs	.+2      	; 0x1970 <AddToSDBuffer+0x1c>
    196e:	41 c0       	rjmp	.+130    	; 0x19f2 <AddToSDBuffer+0x9e>
		return; //take no action if SD_Buffer is nearly full.  this could over-write other variables and cause a mess.
	}
	
	if (character == '\r'){ //special treatment for return character
    1970:	8d 30       	cpi	r24, 0x0D	; 13
    1972:	81 f5       	brne	.+96     	; 0x19d4 <AddToSDBuffer+0x80>
		if(prevcharacter != '\r'){ //if this is first time \r is pressed, insert a space instead, and save to file.
    1974:	90 91 4e 03 	lds	r25, 0x034E
    1978:	f9 01       	movw	r30, r18
    197a:	e6 57       	subi	r30, 0x76	; 118
    197c:	f8 4f       	sbci	r31, 0xF8	; 248
    197e:	a9 01       	movw	r20, r18
    1980:	4f 5f       	subi	r20, 0xFF	; 255
    1982:	5f 4f       	sbci	r21, 0xFF	; 255
    1984:	9d 30       	cpi	r25, 0x0D	; 13
    1986:	21 f0       	breq	.+8      	; 0x1990 <AddToSDBuffer+0x3c>
			SD_Buffer[index] = ' ';
    1988:	90 e2       	ldi	r25, 0x20	; 32
    198a:	90 83       	st	Z, r25
			SD_Buffer[index+1] = '\0';
    198c:	fa 01       	movw	r30, r20
    198e:	1f c0       	rjmp	.+62     	; 0x19ce <AddToSDBuffer+0x7a>
		}
		else if (SD_Buffer[index-1] == ' '){//if a space was inserted last time in place of \r\n, user has pressed return twice.
    1990:	d9 01       	movw	r26, r18
    1992:	a7 57       	subi	r26, 0x77	; 119
    1994:	b8 4f       	sbci	r27, 0xF8	; 248
    1996:	9c 91       	ld	r25, X
    1998:	b9 01       	movw	r22, r18
    199a:	6e 5f       	subi	r22, 0xFE	; 254
    199c:	7f 4f       	sbci	r23, 0xFF	; 255
    199e:	90 32       	cpi	r25, 0x20	; 32
    19a0:	79 f4       	brne	.+30     	; 0x19c0 <AddToSDBuffer+0x6c>
			SD_Buffer[index-1] = '\r'; //so put the missing \r\n in now
    19a2:	8c 93       	st	X, r24
			SD_Buffer[index] = '\n';
    19a4:	9a e0       	ldi	r25, 0x0A	; 10
    19a6:	90 83       	st	Z, r25
			SD_Buffer[index+1] = '\r';
    19a8:	fa 01       	movw	r30, r20
    19aa:	e6 57       	subi	r30, 0x76	; 118
    19ac:	f8 4f       	sbci	r31, 0xF8	; 248
    19ae:	80 83       	st	Z, r24
			SD_Buffer[index+2] = '\n';
    19b0:	fb 01       	movw	r30, r22
    19b2:	e6 57       	subi	r30, 0x76	; 118
    19b4:	f8 4f       	sbci	r31, 0xF8	; 248
    19b6:	90 83       	st	Z, r25
			SD_Buffer[index+3] = '\0';
    19b8:	f9 01       	movw	r30, r18
    19ba:	e3 57       	subi	r30, 0x73	; 115
    19bc:	f8 4f       	sbci	r31, 0xF8	; 248
    19be:	16 c0       	rjmp	.+44     	; 0x19ec <AddToSDBuffer+0x98>
		}
		else { //but if the last character entered was not recorded as a space (\r has already been pressed several times), then call a spade a spade.
			SD_Buffer[index] = '\r';
    19c0:	80 83       	st	Z, r24
			SD_Buffer[index+1] = '\n';
    19c2:	fa 01       	movw	r30, r20
    19c4:	e6 57       	subi	r30, 0x76	; 118
    19c6:	f8 4f       	sbci	r31, 0xF8	; 248
    19c8:	9a e0       	ldi	r25, 0x0A	; 10
    19ca:	90 83       	st	Z, r25
			SD_Buffer[index+2] = '\0';
    19cc:	fb 01       	movw	r30, r22
    19ce:	e6 57       	subi	r30, 0x76	; 118
    19d0:	f8 4f       	sbci	r31, 0xF8	; 248
    19d2:	0c c0       	rjmp	.+24     	; 0x19ec <AddToSDBuffer+0x98>
		}
	}
	else if (character == '\b'){ //for a backspace character,
		SD_Buffer[index-1] = '\0'; //turn the previous character into an "end of string" character 
    19d4:	f9 01       	movw	r30, r18
			SD_Buffer[index] = '\r';
			SD_Buffer[index+1] = '\n';
			SD_Buffer[index+2] = '\0';
		}
	}
	else if (character == '\b'){ //for a backspace character,
    19d6:	88 30       	cpi	r24, 0x08	; 8
    19d8:	19 f4       	brne	.+6      	; 0x19e0 <AddToSDBuffer+0x8c>
		SD_Buffer[index-1] = '\0'; //turn the previous character into an "end of string" character 
    19da:	e7 57       	subi	r30, 0x77	; 119
    19dc:	f8 4f       	sbci	r31, 0xF8	; 248
    19de:	06 c0       	rjmp	.+12     	; 0x19ec <AddToSDBuffer+0x98>
	}
	else{ //the most common scenario -- put a character at the end of the buffer, then follow with a \0;
		SD_Buffer[index] = character;
    19e0:	e6 57       	subi	r30, 0x76	; 118
    19e2:	f8 4f       	sbci	r31, 0xF8	; 248
    19e4:	80 83       	st	Z, r24
		SD_Buffer[index+1] = '\0';
    19e6:	f9 01       	movw	r30, r18
    19e8:	e5 57       	subi	r30, 0x75	; 117
    19ea:	f8 4f       	sbci	r31, 0xF8	; 248
    19ec:	10 82       	st	Z, r1
	}
	
	prevcharacter = character; // save the character just pressed.
    19ee:	80 93 4e 03 	sts	0x034E, r24
    19f2:	08 95       	ret

000019f4 <LogKeystrokes>:
static FATFS DiskFATState;

/** FAT Fs structure to hold a FAT file handle for the log data write destination. */
static FIL LogFile;

void LogKeystrokes(){
    19f4:	cf 92       	push	r12
    19f6:	df 92       	push	r13
    19f8:	ef 92       	push	r14
    19fa:	ff 92       	push	r15
    19fc:	0f 93       	push	r16
    19fe:	1f 93       	push	r17
    1a00:	cf 93       	push	r28
    1a02:	df 93       	push	r29
    1a04:	cd b7       	in	r28, 0x3d	; 61
    1a06:	de b7       	in	r29, 0x3e	; 62
    1a08:	66 97       	sbiw	r28, 0x16	; 22
    1a0a:	0f b6       	in	r0, 0x3f	; 63
    1a0c:	f8 94       	cli
    1a0e:	de bf       	out	0x3e, r29	; 62
    1a10:	0f be       	out	0x3f, r0	; 63
    1a12:	cd bf       	out	0x3d, r28	; 61
	uint16_t filenum;
	uint8_t code = 0;
	uint8_t modifier;
	uint8_t key;
	
	SD_Buffer[0] = '\0'; // A simple way to erase the SD_Buffer string -- first character is now the end of the string;
    1a14:	10 92 8a 07 	sts	0x078A, r1

	diskstatus = MountFilesystem();
    1a18:	08 df       	rcall	.-496    	; 0x182a <MountFilesystem>
	
	if (diskstatus != FR_OK){
    1a1a:	81 11       	cpse	r24, r1
    1a1c:	3f c0       	rjmp	.+126    	; 0x1a9c <LogKeystrokes+0xa8>
		Typewriter_Mode = PANIC_MODE;
		return;
	}
	else{
		GlowGreenLED(VERY_SLOW,SOLID);
    1a1e:	61 e0       	ldi	r22, 0x01	; 1
    1a20:	80 e0       	ldi	r24, 0x00	; 0
    1a22:	1d de       	rcall	.-966    	; 0x165e <GlowGreenLED>
	}
	
	filenum = eeprom_read_word((uint16_t *)FILENUM_ADDR); //filenum is the last used filenum, plus 1;
    1a24:	8a e0       	ldi	r24, 0x0A	; 10
    1a26:	92 e0       	ldi	r25, 0x02	; 2
    1a28:	0e 94 31 39 	call	0x7262	; 0x7262 <eeprom_read_word>
    1a2c:	8c 01       	movw	r16, r24
	
	if (filenum>9999){
    1a2e:	80 31       	cpi	r24, 0x10	; 16
    1a30:	97 42       	sbci	r25, 0x27	; 39
    1a32:	10 f0       	brcs	.+4      	; 0x1a38 <LogKeystrokes+0x44>
		filenum = 0;
    1a34:	00 e0       	ldi	r16, 0x00	; 0
    1a36:	10 e0       	ldi	r17, 0x00	; 0
	} //filenum can only be 4 digits long.

	do{ //increment filenum until a file name is found that does not already exist ("no file" error)
		filenum++; //increment file number
		sprintf(FileName,"PAGE%04d.TXT",filenum); //filename can only be 8 characters long (not including .TXT).
    1a38:	87 e8       	ldi	r24, 0x87	; 135
    1a3a:	c8 2e       	mov	r12, r24
    1a3c:	82 e0       	ldi	r24, 0x02	; 2
    1a3e:	d8 2e       	mov	r13, r24
    1a40:	94 e2       	ldi	r25, 0x24	; 36
    1a42:	e9 2e       	mov	r14, r25
    1a44:	91 e0       	ldi	r25, 0x01	; 1
    1a46:	f9 2e       	mov	r15, r25
	if (filenum>9999){
		filenum = 0;
	} //filenum can only be 4 digits long.

	do{ //increment filenum until a file name is found that does not already exist ("no file" error)
		filenum++; //increment file number
    1a48:	0f 5f       	subi	r16, 0xFF	; 255
    1a4a:	1f 4f       	sbci	r17, 0xFF	; 255
		sprintf(FileName,"PAGE%04d.TXT",filenum); //filename can only be 8 characters long (not including .TXT).
    1a4c:	1f 93       	push	r17
    1a4e:	0f 93       	push	r16
    1a50:	df 92       	push	r13
    1a52:	cf 92       	push	r12
    1a54:	ff 92       	push	r15
    1a56:	ef 92       	push	r14
    1a58:	0e 94 8a 36 	call	0x6d14	; 0x6d14 <sprintf>
		filestatus = f_stat(FileName, &fileinfo);
    1a5c:	be 01       	movw	r22, r28
    1a5e:	6f 5f       	subi	r22, 0xFF	; 255
    1a60:	7f 4f       	sbci	r23, 0xFF	; 255
    1a62:	84 e2       	ldi	r24, 0x24	; 36
    1a64:	91 e0       	ldi	r25, 0x01	; 1
    1a66:	0e 94 df 20 	call	0x41be	; 0x41be <f_stat>
	}while(filestatus == FR_OK); //at the end of this loop, FileName is unique
    1a6a:	0f 90       	pop	r0
    1a6c:	0f 90       	pop	r0
    1a6e:	0f 90       	pop	r0
    1a70:	0f 90       	pop	r0
    1a72:	0f 90       	pop	r0
    1a74:	0f 90       	pop	r0
    1a76:	88 23       	and	r24, r24
    1a78:	39 f3       	breq	.-50     	; 0x1a48 <LogKeystrokes+0x54>
	
	if (filestatus != FR_NO_FILE){ //if the error was not "no file" something went wrong
    1a7a:	84 30       	cpi	r24, 0x04	; 4
    1a7c:	79 f4       	brne	.+30     	; 0x1a9c <LogKeystrokes+0xa8>
		Typewriter_Mode = PANIC_MODE; // go into panic mode
		return;
	}
	
	while(!code){ // wait for a key to be pressed before actually opening the file -- this stops lots of empty files from being created
		key = GetKey();
    1a7e:	0e 94 da 29 	call	0x53b4	; 0x53b4 <GetKey>
    1a82:	f8 2e       	mov	r15, r24
		modifier = GetModifier();
    1a84:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
		code = GetASCIIKeyCode(key,modifier);
    1a88:	68 2f       	mov	r22, r24
    1a8a:	8f 2d       	mov	r24, r15
    1a8c:	0e 94 36 2b 	call	0x566c	; 0x566c <GetASCIIKeyCode>
	if (filestatus != FR_NO_FILE){ //if the error was not "no file" something went wrong
		Typewriter_Mode = PANIC_MODE; // go into panic mode
		return;
	}
	
	while(!code){ // wait for a key to be pressed before actually opening the file -- this stops lots of empty files from being created
    1a90:	88 23       	and	r24, r24
    1a92:	a9 f3       	breq	.-22     	; 0x1a7e <LogKeystrokes+0x8a>
		key = GetKey();
		modifier = GetModifier();
		code = GetASCIIKeyCode(key,modifier);
	}
	
	AddToSDBuffer(code); //save this first key pressed to the buffer.  there will be more, and those will be handled in the main loop
    1a94:	5f df       	rcall	.-322    	; 0x1954 <AddToSDBuffer>

	if (OpenLogFile()!=FR_OK){ //open the new log file.
    1a96:	9a de       	rcall	.-716    	; 0x17cc <OpenLogFile>
    1a98:	88 23       	and	r24, r24
    1a9a:	21 f0       	breq	.+8      	; 0x1aa4 <LogKeystrokes+0xb0>
		Typewriter_Mode = PANIC_MODE; // go into panic mode
    1a9c:	8a e0       	ldi	r24, 0x0A	; 10
    1a9e:	80 93 89 07 	sts	0x0789, r24
		return;
    1aa2:	62 c0       	rjmp	.+196    	; 0x1b68 <LogKeystrokes+0x174>
	}
	
	eeprom_write_word((uint16_t *)FILENUM_ADDR,filenum); // save the new filenumber for next time
    1aa4:	b8 01       	movw	r22, r16
    1aa6:	8a e0       	ldi	r24, 0x0A	; 10
    1aa8:	92 e0       	ldi	r25, 0x02	; 2
    1aaa:	0e 94 5f 39 	call	0x72be	; 0x72be <eeprom_write_word>
	
	myTimeoutCounter = 0; //reset timeout
    1aae:	10 92 82 06 	sts	0x0682, r1
    1ab2:	10 92 81 06 	sts	0x0681, r1

	while(myTimeoutCounter < (SD_TIMEOUT)){ //keep listening for keys and adding them to buffer. Clear buffer occassionally.
    1ab6:	80 91 81 06 	lds	r24, 0x0681
    1aba:	90 91 82 06 	lds	r25, 0x0682
    1abe:	80 32       	cpi	r24, 0x20	; 32
    1ac0:	9f 4b       	sbci	r25, 0xBF	; 191
    1ac2:	08 f0       	brcs	.+2      	; 0x1ac6 <LogKeystrokes+0xd2>
    1ac4:	4c c0       	rjmp	.+152    	; 0x1b5e <LogKeystrokes+0x16a>
			key = GetKey();
    1ac6:	0e 94 da 29 	call	0x53b4	; 0x53b4 <GetKey>
    1aca:	18 2f       	mov	r17, r24
			modifier = GetModifier();
    1acc:	0e 94 d0 28 	call	0x51a0	; 0x51a0 <GetModifier>
			
			code = GetASCIIKeyCode(key, modifier);
    1ad0:	68 2f       	mov	r22, r24
    1ad2:	81 2f       	mov	r24, r17
    1ad4:	0e 94 36 2b 	call	0x566c	; 0x566c <GetASCIIKeyCode>
    1ad8:	18 2f       	mov	r17, r24
			
			if(code){
    1ada:	88 23       	and	r24, r24
    1adc:	01 f1       	breq	.+64     	; 0x1b1e <LogKeystrokes+0x12a>
				if ((code == 's') && Ignore_Flag) code = 0; //if user is holding down S on startup, don't add this to file.
    1ade:	83 37       	cpi	r24, 0x73	; 115
    1ae0:	21 f4       	brne	.+8      	; 0x1aea <LogKeystrokes+0xf6>
    1ae2:	80 91 83 06 	lds	r24, 0x0683
    1ae6:	81 11       	cpse	r24, r1
    1ae8:	10 e0       	ldi	r17, 0x00	; 0
				Ignore_Flag = 0;
    1aea:	10 92 83 06 	sts	0x0683, r1
				AddToSDBuffer(code); //this adds the character to the sd write buffer.
    1aee:	81 2f       	mov	r24, r17
    1af0:	31 df       	rcall	.-414    	; 0x1954 <AddToSDBuffer>
				myTimeoutCounter = 0; //reset timeout every time a key is pressed.
    1af2:	10 92 82 06 	sts	0x0682, r1
    1af6:	10 92 81 06 	sts	0x0681, r1
			}
			if((code == '\r')||(code == '.')||(code == ',')||(code == '!')||(code == '?')||(code == ':')||(code == '\"')){
    1afa:	1d 30       	cpi	r17, 0x0D	; 13
    1afc:	61 f0       	breq	.+24     	; 0x1b16 <LogKeystrokes+0x122>
    1afe:	81 2f       	mov	r24, r17
    1b00:	8d 7f       	andi	r24, 0xFD	; 253
    1b02:	8c 32       	cpi	r24, 0x2C	; 44
    1b04:	41 f0       	breq	.+16     	; 0x1b16 <LogKeystrokes+0x122>
    1b06:	8f ed       	ldi	r24, 0xDF	; 223
    1b08:	81 0f       	add	r24, r17
    1b0a:	82 30       	cpi	r24, 0x02	; 2
    1b0c:	20 f0       	brcs	.+8      	; 0x1b16 <LogKeystrokes+0x122>
    1b0e:	1f 33       	cpi	r17, 0x3F	; 63
    1b10:	11 f0       	breq	.+4      	; 0x1b16 <LogKeystrokes+0x122>
    1b12:	1a 33       	cpi	r17, 0x3A	; 58
    1b14:	21 f4       	brne	.+8      	; 0x1b1e <LogKeystrokes+0x12a>
				GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
    1b16:	60 e0       	ldi	r22, 0x00	; 0
    1b18:	82 e0       	ldi	r24, 0x02	; 2
    1b1a:	a1 dd       	rcall	.-1214   	; 0x165e <GlowGreenLED>
				WriteToLogFile(); //save your work every time enter key is pressed.
    1b1c:	c3 de       	rcall	.-634    	; 0x18a4 <WriteToLogFile>
    1b1e:	8f ec       	ldi	r24, 0xCF	; 207
    1b20:	97 e0       	ldi	r25, 0x07	; 7
    1b22:	01 97       	sbiw	r24, 0x01	; 1
    1b24:	f1 f7       	brne	.-4      	; 0x1b22 <LogKeystrokes+0x12e>
    1b26:	00 c0       	rjmp	.+0      	; 0x1b28 <LogKeystrokes+0x134>
    1b28:	00 00       	nop
			}
			Delay_MS(SENSE_DELAY);
			
			if ((myTimeoutCounter > SD_SAVE_TIME) && (SD_Buffer[0] != '\0')){
    1b2a:	80 91 81 06 	lds	r24, 0x0681
    1b2e:	90 91 82 06 	lds	r25, 0x0682
    1b32:	89 3b       	cpi	r24, 0xB9	; 185
    1b34:	9b 40       	sbci	r25, 0x0B	; 11
    1b36:	08 f4       	brcc	.+2      	; 0x1b3a <LogKeystrokes+0x146>
    1b38:	be cf       	rjmp	.-132    	; 0x1ab6 <LogKeystrokes+0xc2>
    1b3a:	80 91 8a 07 	lds	r24, 0x078A
    1b3e:	88 23       	and	r24, r24
    1b40:	09 f4       	brne	.+2      	; 0x1b44 <LogKeystrokes+0x150>
    1b42:	b9 cf       	rjmp	.-142    	; 0x1ab6 <LogKeystrokes+0xc2>
				set_low(GREEN_LED);
    1b44:	46 98       	cbi	0x08, 6	; 8
    1b46:	8f ef       	ldi	r24, 0xFF	; 255
    1b48:	9d e3       	ldi	r25, 0x3D	; 61
    1b4a:	29 e4       	ldi	r18, 0x49	; 73
    1b4c:	81 50       	subi	r24, 0x01	; 1
    1b4e:	90 40       	sbci	r25, 0x00	; 0
    1b50:	20 40       	sbci	r18, 0x00	; 0
    1b52:	e1 f7       	brne	.-8      	; 0x1b4c <LogKeystrokes+0x158>
    1b54:	00 c0       	rjmp	.+0      	; 0x1b56 <LogKeystrokes+0x162>
    1b56:	00 00       	nop
				Delay_MS(3000);
				WriteToLogFile();
    1b58:	a5 de       	rcall	.-694    	; 0x18a4 <WriteToLogFile>
				set_high(GREEN_LED);
    1b5a:	46 9a       	sbi	0x08, 6	; 8
    1b5c:	ac cf       	rjmp	.-168    	; 0x1ab6 <LogKeystrokes+0xc2>
			}
	}
	
			GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
    1b5e:	60 e0       	ldi	r22, 0x00	; 0
    1b60:	82 e0       	ldi	r24, 0x02	; 2
    1b62:	7d dd       	rcall	.-1286   	; 0x165e <GlowGreenLED>
			WriteToLogFile(); //save your work then "sleep" -- stop recording keystrokes
    1b64:	9f de       	rcall	.-706    	; 0x18a4 <WriteToLogFile>
			CloseLogFile(); // close log file so a new one can be opened later.
    1b66:	59 de       	rcall	.-846    	; 0x181a <CloseLogFile>
}
    1b68:	66 96       	adiw	r28, 0x16	; 22
    1b6a:	0f b6       	in	r0, 0x3f	; 63
    1b6c:	f8 94       	cli
    1b6e:	de bf       	out	0x3e, r29	; 62
    1b70:	0f be       	out	0x3f, r0	; 63
    1b72:	cd bf       	out	0x3d, r28	; 61
    1b74:	df 91       	pop	r29
    1b76:	cf 91       	pop	r28
    1b78:	1f 91       	pop	r17
    1b7a:	0f 91       	pop	r16
    1b7c:	ff 90       	pop	r15
    1b7e:	ef 90       	pop	r14
    1b80:	df 90       	pop	r13
    1b82:	cf 90       	pop	r12
    1b84:	08 95       	ret

00001b86 <dly_us>:

static
void dly_us (UINT n)	/* Delay n microseconds (avr-gcc -Os) */
{
	do {
		PINB;
    1b86:	23 b1       	in	r18, 0x03	; 3
		PINB;
    1b88:	23 b1       	in	r18, 0x03	; 3
		 //PINB is a throwaway command that wastes one op cycle.  1 PINB commands is recommended for 8MHZ clock.  We can lengthen this or randomize this for EMC reasons.
	} while (--n);
    1b8a:	01 97       	sbiw	r24, 0x01	; 1
    1b8c:	e1 f7       	brne	.-8      	; 0x1b86 <dly_us>
}
    1b8e:	08 95       	ret

00001b90 <xmit_mmc>:
static
void xmit_mmc (
	const BYTE* buff,	/* Data to be sent */
	UINT bc				/* Number of bytes to send */
)
{
    1b90:	fc 01       	movw	r30, r24
    1b92:	68 0f       	add	r22, r24
    1b94:	79 1f       	adc	r23, r25
	BYTE d;


	do {
		d = *buff++;	/* Get a byte to be sent */
    1b96:	91 91       	ld	r25, Z+
		if (d & 0x80) DI_H(); else DI_L();	/* bit7 */
    1b98:	97 ff       	sbrs	r25, 7
    1b9a:	02 c0       	rjmp	.+4      	; 0x1ba0 <xmit_mmc+0x10>
    1b9c:	2a 9a       	sbi	0x05, 2	; 5
    1b9e:	01 c0       	rjmp	.+2      	; 0x1ba2 <xmit_mmc+0x12>
    1ba0:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1ba2:	29 9a       	sbi	0x05, 1	; 5
    1ba4:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x40) DI_H(); else DI_L();	/* bit6 */
    1ba6:	96 ff       	sbrs	r25, 6
    1ba8:	02 c0       	rjmp	.+4      	; 0x1bae <xmit_mmc+0x1e>
    1baa:	2a 9a       	sbi	0x05, 2	; 5
    1bac:	01 c0       	rjmp	.+2      	; 0x1bb0 <xmit_mmc+0x20>
    1bae:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1bb0:	29 9a       	sbi	0x05, 1	; 5
    1bb2:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x20) DI_H(); else DI_L();	/* bit5 */
    1bb4:	95 ff       	sbrs	r25, 5
    1bb6:	02 c0       	rjmp	.+4      	; 0x1bbc <xmit_mmc+0x2c>
    1bb8:	2a 9a       	sbi	0x05, 2	; 5
    1bba:	01 c0       	rjmp	.+2      	; 0x1bbe <xmit_mmc+0x2e>
    1bbc:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1bbe:	29 9a       	sbi	0x05, 1	; 5
    1bc0:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x10) DI_H(); else DI_L();	/* bit4 */
    1bc2:	94 ff       	sbrs	r25, 4
    1bc4:	02 c0       	rjmp	.+4      	; 0x1bca <xmit_mmc+0x3a>
    1bc6:	2a 9a       	sbi	0x05, 2	; 5
    1bc8:	01 c0       	rjmp	.+2      	; 0x1bcc <xmit_mmc+0x3c>
    1bca:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1bcc:	29 9a       	sbi	0x05, 1	; 5
    1bce:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x08) DI_H(); else DI_L();	/* bit3 */
    1bd0:	93 ff       	sbrs	r25, 3
    1bd2:	02 c0       	rjmp	.+4      	; 0x1bd8 <xmit_mmc+0x48>
    1bd4:	2a 9a       	sbi	0x05, 2	; 5
    1bd6:	01 c0       	rjmp	.+2      	; 0x1bda <xmit_mmc+0x4a>
    1bd8:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1bda:	29 9a       	sbi	0x05, 1	; 5
    1bdc:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x04) DI_H(); else DI_L();	/* bit2 */
    1bde:	92 ff       	sbrs	r25, 2
    1be0:	02 c0       	rjmp	.+4      	; 0x1be6 <xmit_mmc+0x56>
    1be2:	2a 9a       	sbi	0x05, 2	; 5
    1be4:	01 c0       	rjmp	.+2      	; 0x1be8 <xmit_mmc+0x58>
    1be6:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1be8:	29 9a       	sbi	0x05, 1	; 5
    1bea:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x02) DI_H(); else DI_L();	/* bit1 */
    1bec:	91 ff       	sbrs	r25, 1
    1bee:	02 c0       	rjmp	.+4      	; 0x1bf4 <xmit_mmc+0x64>
    1bf0:	2a 9a       	sbi	0x05, 2	; 5
    1bf2:	01 c0       	rjmp	.+2      	; 0x1bf6 <xmit_mmc+0x66>
    1bf4:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1bf6:	29 9a       	sbi	0x05, 1	; 5
    1bf8:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x01) DI_H(); else DI_L();	/* bit0 */
    1bfa:	90 ff       	sbrs	r25, 0
    1bfc:	02 c0       	rjmp	.+4      	; 0x1c02 <xmit_mmc+0x72>
    1bfe:	2a 9a       	sbi	0x05, 2	; 5
    1c00:	01 c0       	rjmp	.+2      	; 0x1c04 <xmit_mmc+0x74>
    1c02:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1c04:	29 9a       	sbi	0x05, 1	; 5
    1c06:	29 98       	cbi	0x05, 1	; 5
	} while (--bc);
    1c08:	e6 17       	cp	r30, r22
    1c0a:	f7 07       	cpc	r31, r23
    1c0c:	21 f6       	brne	.-120    	; 0x1b96 <xmit_mmc+0x6>
}
    1c0e:	08 95       	ret

00001c10 <rcvr_mmc>:
)
{
	BYTE r;


	DI_H();	/* Send 0xFF */
    1c10:	2a 9a       	sbi	0x05, 2	; 5
    1c12:	fc 01       	movw	r30, r24
    1c14:	68 0f       	add	r22, r24
    1c16:	79 1f       	adc	r23, r25

	do {
		r = 0;	 if (DO) r++;	/* bit7 */
    1c18:	93 b1       	in	r25, 0x03	; 3
		CK_H(); CK_L();
    1c1a:	29 9a       	sbi	0x05, 1	; 5
    1c1c:	29 98       	cbi	0x05, 1	; 5


	DI_H();	/* Send 0xFF */

	do {
		r = 0;	 if (DO) r++;	/* bit7 */
    1c1e:	93 fb       	bst	r25, 3
    1c20:	99 27       	eor	r25, r25
    1c22:	90 f9       	bld	r25, 0
		CK_H(); CK_L();
		r <<= 1; if (DO) r++;	/* bit6 */
    1c24:	99 0f       	add	r25, r25
    1c26:	1b 99       	sbic	0x03, 3	; 3
    1c28:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1c2a:	29 9a       	sbi	0x05, 1	; 5
    1c2c:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit5 */
    1c2e:	99 0f       	add	r25, r25
    1c30:	1b 99       	sbic	0x03, 3	; 3
    1c32:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1c34:	29 9a       	sbi	0x05, 1	; 5
    1c36:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit4 */
    1c38:	99 0f       	add	r25, r25
    1c3a:	1b 99       	sbic	0x03, 3	; 3
    1c3c:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1c3e:	29 9a       	sbi	0x05, 1	; 5
    1c40:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit3 */
    1c42:	99 0f       	add	r25, r25
    1c44:	1b 99       	sbic	0x03, 3	; 3
    1c46:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1c48:	29 9a       	sbi	0x05, 1	; 5
    1c4a:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit2 */
    1c4c:	99 0f       	add	r25, r25
    1c4e:	1b 99       	sbic	0x03, 3	; 3
    1c50:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1c52:	29 9a       	sbi	0x05, 1	; 5
    1c54:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit1 */
    1c56:	99 0f       	add	r25, r25
    1c58:	1b 99       	sbic	0x03, 3	; 3
    1c5a:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1c5c:	29 9a       	sbi	0x05, 1	; 5
    1c5e:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit0 */
    1c60:	99 0f       	add	r25, r25
    1c62:	1b 99       	sbic	0x03, 3	; 3
    1c64:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1c66:	29 9a       	sbi	0x05, 1	; 5
    1c68:	29 98       	cbi	0x05, 1	; 5
		*buff++ = r;			/* Store a received byte */
    1c6a:	91 93       	st	Z+, r25
	} while (--bc);
    1c6c:	e6 17       	cp	r30, r22
    1c6e:	f7 07       	cpc	r31, r23
    1c70:	99 f6       	brne	.-90     	; 0x1c18 <rcvr_mmc+0x8>
}
    1c72:	08 95       	ret

00001c74 <wait_ready>:
/* Wait for card ready                                                   */
/*-----------------------------------------------------------------------*/

static
int wait_ready (void)	/* 1:OK, 0:Timeout */
{
    1c74:	0f 93       	push	r16
    1c76:	1f 93       	push	r17
    1c78:	cf 93       	push	r28
    1c7a:	df 93       	push	r29
    1c7c:	1f 92       	push	r1
    1c7e:	cd b7       	in	r28, 0x3d	; 61
    1c80:	de b7       	in	r29, 0x3e	; 62
	BYTE d;
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
    1c82:	08 e8       	ldi	r16, 0x88	; 136
    1c84:	13 e1       	ldi	r17, 0x13	; 19
		rcvr_mmc(&d, 1);
    1c86:	61 e0       	ldi	r22, 0x01	; 1
    1c88:	70 e0       	ldi	r23, 0x00	; 0
    1c8a:	ce 01       	movw	r24, r28
    1c8c:	01 96       	adiw	r24, 0x01	; 1
    1c8e:	c0 df       	rcall	.-128    	; 0x1c10 <rcvr_mmc>
		if (d == 0xFF) break;
    1c90:	89 81       	ldd	r24, Y+1	; 0x01
    1c92:	8f 3f       	cpi	r24, 0xFF	; 255
    1c94:	31 f0       	breq	.+12     	; 0x1ca2 <wait_ready+0x2e>
		dly_us(100);
    1c96:	84 e6       	ldi	r24, 0x64	; 100
    1c98:	90 e0       	ldi	r25, 0x00	; 0
    1c9a:	75 df       	rcall	.-278    	; 0x1b86 <dly_us>
{
	BYTE d;
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
    1c9c:	01 50       	subi	r16, 0x01	; 1
    1c9e:	11 09       	sbc	r17, r1
    1ca0:	91 f7       	brne	.-28     	; 0x1c86 <wait_ready+0x12>
		rcvr_mmc(&d, 1);
		if (d == 0xFF) break;
		dly_us(100);
	}

	return tmr ? 1 : 0;
    1ca2:	81 e0       	ldi	r24, 0x01	; 1
    1ca4:	90 e0       	ldi	r25, 0x00	; 0
    1ca6:	01 2b       	or	r16, r17
    1ca8:	11 f4       	brne	.+4      	; 0x1cae <wait_ready+0x3a>
    1caa:	80 e0       	ldi	r24, 0x00	; 0
    1cac:	90 e0       	ldi	r25, 0x00	; 0
}
    1cae:	0f 90       	pop	r0
    1cb0:	df 91       	pop	r29
    1cb2:	cf 91       	pop	r28
    1cb4:	1f 91       	pop	r17
    1cb6:	0f 91       	pop	r16
    1cb8:	08 95       	ret

00001cba <deselect>:
/* Deselect the card and release SPI bus                                 */
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
    1cba:	cf 93       	push	r28
    1cbc:	df 93       	push	r29
    1cbe:	1f 92       	push	r1
    1cc0:	cd b7       	in	r28, 0x3d	; 61
    1cc2:	de b7       	in	r29, 0x3e	; 62
	BYTE d;

	CS_H();
    1cc4:	59 9a       	sbi	0x0b, 1	; 11
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
    1cc6:	61 e0       	ldi	r22, 0x01	; 1
    1cc8:	70 e0       	ldi	r23, 0x00	; 0
    1cca:	ce 01       	movw	r24, r28
    1ccc:	01 96       	adiw	r24, 0x01	; 1
    1cce:	a0 df       	rcall	.-192    	; 0x1c10 <rcvr_mmc>
}
    1cd0:	0f 90       	pop	r0
    1cd2:	df 91       	pop	r29
    1cd4:	cf 91       	pop	r28
    1cd6:	08 95       	ret

00001cd8 <select>:
/* Select the card and wait for ready                                    */
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
    1cd8:	cf 93       	push	r28
    1cda:	df 93       	push	r29
    1cdc:	00 d0       	rcall	.+0      	; 0x1cde <select+0x6>
    1cde:	1f 92       	push	r1
    1ce0:	cd b7       	in	r28, 0x3d	; 61
    1ce2:	de b7       	in	r29, 0x3e	; 62
	BYTE d;

	CS_L();
    1ce4:	59 98       	cbi	0x0b, 1	; 11
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO enabled) */
    1ce6:	61 e0       	ldi	r22, 0x01	; 1
    1ce8:	70 e0       	ldi	r23, 0x00	; 0
    1cea:	ce 01       	movw	r24, r28
    1cec:	01 96       	adiw	r24, 0x01	; 1
    1cee:	90 df       	rcall	.-224    	; 0x1c10 <rcvr_mmc>

	if (wait_ready()) return 1;	/* OK */
    1cf0:	c1 df       	rcall	.-126    	; 0x1c74 <wait_ready>
    1cf2:	00 97       	sbiw	r24, 0x00	; 0
    1cf4:	31 f4       	brne	.+12     	; 0x1d02 <select+0x2a>
	deselect();
    1cf6:	8a 83       	std	Y+2, r24	; 0x02
    1cf8:	9b 83       	std	Y+3, r25	; 0x03
    1cfa:	df df       	rcall	.-66     	; 0x1cba <deselect>
	return 0;			/* Failed */
    1cfc:	8a 81       	ldd	r24, Y+2	; 0x02
    1cfe:	9b 81       	ldd	r25, Y+3	; 0x03
    1d00:	02 c0       	rjmp	.+4      	; 0x1d06 <select+0x2e>
	BYTE d;

	CS_L();
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO enabled) */

	if (wait_ready()) return 1;	/* OK */
    1d02:	81 e0       	ldi	r24, 0x01	; 1
    1d04:	90 e0       	ldi	r25, 0x00	; 0
	deselect();
	return 0;			/* Failed */
}
    1d06:	0f 90       	pop	r0
    1d08:	0f 90       	pop	r0
    1d0a:	0f 90       	pop	r0
    1d0c:	df 91       	pop	r29
    1d0e:	cf 91       	pop	r28
    1d10:	08 95       	ret

00001d12 <rcvr_datablock>:
static
int rcvr_datablock (	/* 1:OK, 0:Failed */
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count */
)
{
    1d12:	cf 92       	push	r12
    1d14:	df 92       	push	r13
    1d16:	ef 92       	push	r14
    1d18:	ff 92       	push	r15
    1d1a:	0f 93       	push	r16
    1d1c:	1f 93       	push	r17
    1d1e:	cf 93       	push	r28
    1d20:	df 93       	push	r29
    1d22:	00 d0       	rcall	.+0      	; 0x1d24 <rcvr_datablock+0x12>
    1d24:	cd b7       	in	r28, 0x3d	; 61
    1d26:	de b7       	in	r29, 0x3e	; 62
    1d28:	7c 01       	movw	r14, r24
    1d2a:	6b 01       	movw	r12, r22
    1d2c:	08 ee       	ldi	r16, 0xE8	; 232
    1d2e:	13 e0       	ldi	r17, 0x03	; 3
	BYTE d[2];
	UINT tmr;


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
		rcvr_mmc(d, 1);
    1d30:	61 e0       	ldi	r22, 0x01	; 1
    1d32:	70 e0       	ldi	r23, 0x00	; 0
    1d34:	ce 01       	movw	r24, r28
    1d36:	01 96       	adiw	r24, 0x01	; 1
    1d38:	6b df       	rcall	.-298    	; 0x1c10 <rcvr_mmc>
		if (d[0] != 0xFF) break;
    1d3a:	89 81       	ldd	r24, Y+1	; 0x01
    1d3c:	8f 3f       	cpi	r24, 0xFF	; 255
    1d3e:	71 f0       	breq	.+28     	; 0x1d5c <rcvr_datablock+0x4a>
		dly_us(100);
	}
	if (d[0] != 0xFE) return 0;		/* If not valid data token, return with error */
    1d40:	89 81       	ldd	r24, Y+1	; 0x01
    1d42:	8e 3f       	cpi	r24, 0xFE	; 254
    1d44:	91 f4       	brne	.+36     	; 0x1d6a <rcvr_datablock+0x58>

	rcvr_mmc(buff, btr);			/* Receive the data block into buffer */
    1d46:	b6 01       	movw	r22, r12
    1d48:	c7 01       	movw	r24, r14
    1d4a:	62 df       	rcall	.-316    	; 0x1c10 <rcvr_mmc>
	rcvr_mmc(d, 2);					/* Discard CRC */
    1d4c:	62 e0       	ldi	r22, 0x02	; 2
    1d4e:	70 e0       	ldi	r23, 0x00	; 0
    1d50:	ce 01       	movw	r24, r28
    1d52:	01 96       	adiw	r24, 0x01	; 1
    1d54:	5d df       	rcall	.-326    	; 0x1c10 <rcvr_mmc>

	return 1;						/* Return with success */
    1d56:	81 e0       	ldi	r24, 0x01	; 1
    1d58:	90 e0       	ldi	r25, 0x00	; 0
    1d5a:	09 c0       	rjmp	.+18     	; 0x1d6e <rcvr_datablock+0x5c>


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
		rcvr_mmc(d, 1);
		if (d[0] != 0xFF) break;
		dly_us(100);
    1d5c:	84 e6       	ldi	r24, 0x64	; 100
    1d5e:	90 e0       	ldi	r25, 0x00	; 0
    1d60:	12 df       	rcall	.-476    	; 0x1b86 <dly_us>
    1d62:	01 50       	subi	r16, 0x01	; 1
    1d64:	11 09       	sbc	r17, r1
{
	BYTE d[2];
	UINT tmr;


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
    1d66:	21 f7       	brne	.-56     	; 0x1d30 <rcvr_datablock+0x1e>
    1d68:	eb cf       	rjmp	.-42     	; 0x1d40 <rcvr_datablock+0x2e>
		rcvr_mmc(d, 1);
		if (d[0] != 0xFF) break;
		dly_us(100);
	}
	if (d[0] != 0xFE) return 0;		/* If not valid data token, return with error */
    1d6a:	80 e0       	ldi	r24, 0x00	; 0
    1d6c:	90 e0       	ldi	r25, 0x00	; 0

	rcvr_mmc(buff, btr);			/* Receive the data block into buffer */
	rcvr_mmc(d, 2);					/* Discard CRC */

	return 1;						/* Return with success */
}
    1d6e:	0f 90       	pop	r0
    1d70:	0f 90       	pop	r0
    1d72:	df 91       	pop	r29
    1d74:	cf 91       	pop	r28
    1d76:	1f 91       	pop	r17
    1d78:	0f 91       	pop	r16
    1d7a:	ff 90       	pop	r15
    1d7c:	ef 90       	pop	r14
    1d7e:	df 90       	pop	r13
    1d80:	cf 90       	pop	r12
    1d82:	08 95       	ret

00001d84 <send_cmd>:
static
BYTE send_cmd (		/* Returns command response (bit7==1:Send failed)*/
	BYTE cmd,		/* Command byte */
	DWORD arg		/* Argument */
)
{
    1d84:	df 92       	push	r13
    1d86:	ef 92       	push	r14
    1d88:	ff 92       	push	r15
    1d8a:	0f 93       	push	r16
    1d8c:	1f 93       	push	r17
    1d8e:	cf 93       	push	r28
    1d90:	df 93       	push	r29
    1d92:	cd b7       	in	r28, 0x3d	; 61
    1d94:	de b7       	in	r29, 0x3e	; 62
    1d96:	27 97       	sbiw	r28, 0x07	; 7
    1d98:	0f b6       	in	r0, 0x3f	; 63
    1d9a:	f8 94       	cli
    1d9c:	de bf       	out	0x3e, r29	; 62
    1d9e:	0f be       	out	0x3f, r0	; 63
    1da0:	cd bf       	out	0x3d, r28	; 61
    1da2:	18 2f       	mov	r17, r24
    1da4:	04 2f       	mov	r16, r20
    1da6:	f5 2e       	mov	r15, r21
    1da8:	e6 2e       	mov	r14, r22
    1daa:	d7 2e       	mov	r13, r23
	BYTE n, d, buf[6];


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
    1dac:	87 ff       	sbrs	r24, 7
    1dae:	08 c0       	rjmp	.+16     	; 0x1dc0 <send_cmd+0x3c>
		cmd &= 0x7F;
		n = send_cmd(CMD55, 0);
    1db0:	40 e0       	ldi	r20, 0x00	; 0
    1db2:	50 e0       	ldi	r21, 0x00	; 0
    1db4:	ba 01       	movw	r22, r20
    1db6:	87 e3       	ldi	r24, 0x37	; 55
    1db8:	e5 df       	rcall	.-54     	; 0x1d84 <send_cmd>
		if (n > 1) return n;
    1dba:	82 30       	cpi	r24, 0x02	; 2
    1dbc:	90 f5       	brcc	.+100    	; 0x1e22 <send_cmd+0x9e>
{
	BYTE n, d, buf[6];


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
    1dbe:	1f 77       	andi	r17, 0x7F	; 127
		n = send_cmd(CMD55, 0);
		if (n > 1) return n;
	}

	/* Select the card and wait for ready except to stop multiple block read */
	if (cmd != CMD12) {
    1dc0:	1c 30       	cpi	r17, 0x0C	; 12
    1dc2:	51 f4       	brne	.+20     	; 0x1dd8 <send_cmd+0x54>
		deselect();
		if (!select()) return 0xFF;
	}

	/* Send a command packet */
	buf[0] = 0x40 | cmd;			/* Start + Command index */
    1dc4:	81 2f       	mov	r24, r17
    1dc6:	80 64       	ori	r24, 0x40	; 64
    1dc8:	89 83       	std	Y+1, r24	; 0x01
	buf[1] = (BYTE)(arg >> 24);		/* Argument[31..24] */
    1dca:	da 82       	std	Y+2, r13	; 0x02
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
    1dcc:	eb 82       	std	Y+3, r14	; 0x03
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
    1dce:	fc 82       	std	Y+4, r15	; 0x04
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
    1dd0:	0d 83       	std	Y+5, r16	; 0x05
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
    1dd2:	11 23       	and	r17, r17
    1dd4:	59 f0       	breq	.+22     	; 0x1dec <send_cmd+0x68>
    1dd6:	06 c0       	rjmp	.+12     	; 0x1de4 <send_cmd+0x60>
		if (n > 1) return n;
	}

	/* Select the card and wait for ready except to stop multiple block read */
	if (cmd != CMD12) {
		deselect();
    1dd8:	70 df       	rcall	.-288    	; 0x1cba <deselect>
		if (!select()) return 0xFF;
    1dda:	7e df       	rcall	.-260    	; 0x1cd8 <select>
    1ddc:	89 2b       	or	r24, r25
    1dde:	91 f7       	brne	.-28     	; 0x1dc4 <send_cmd+0x40>
    1de0:	8f ef       	ldi	r24, 0xFF	; 255
    1de2:	1f c0       	rjmp	.+62     	; 0x1e22 <send_cmd+0x9e>
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
    1de4:	18 30       	cpi	r17, 0x08	; 8
    1de6:	21 f0       	breq	.+8      	; 0x1df0 <send_cmd+0x6c>
	buf[0] = 0x40 | cmd;			/* Start + Command index */
	buf[1] = (BYTE)(arg >> 24);		/* Argument[31..24] */
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
    1de8:	81 e0       	ldi	r24, 0x01	; 1
    1dea:	03 c0       	rjmp	.+6      	; 0x1df2 <send_cmd+0x6e>
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
    1dec:	85 e9       	ldi	r24, 0x95	; 149
    1dee:	01 c0       	rjmp	.+2      	; 0x1df2 <send_cmd+0x6e>
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
    1df0:	87 e8       	ldi	r24, 0x87	; 135
	buf[5] = n;
    1df2:	8e 83       	std	Y+6, r24	; 0x06
	xmit_mmc(buf, 6);
    1df4:	66 e0       	ldi	r22, 0x06	; 6
    1df6:	70 e0       	ldi	r23, 0x00	; 0
    1df8:	ce 01       	movw	r24, r28
    1dfa:	01 96       	adiw	r24, 0x01	; 1
    1dfc:	c9 de       	rcall	.-622    	; 0x1b90 <xmit_mmc>

	/* Receive command response */
	if (cmd == CMD12) rcvr_mmc(&d, 1);	/* Skip a stuff byte when stop reading */
    1dfe:	1c 30       	cpi	r17, 0x0C	; 12
    1e00:	29 f4       	brne	.+10     	; 0x1e0c <send_cmd+0x88>
    1e02:	61 e0       	ldi	r22, 0x01	; 1
    1e04:	70 e0       	ldi	r23, 0x00	; 0
    1e06:	ce 01       	movw	r24, r28
    1e08:	07 96       	adiw	r24, 0x07	; 7
    1e0a:	02 df       	rcall	.-508    	; 0x1c10 <rcvr_mmc>
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
    1e0c:	1a e0       	ldi	r17, 0x0A	; 10

	/* Receive command response */
	if (cmd == CMD12) rcvr_mmc(&d, 1);	/* Skip a stuff byte when stop reading */
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		rcvr_mmc(&d, 1);
    1e0e:	61 e0       	ldi	r22, 0x01	; 1
    1e10:	70 e0       	ldi	r23, 0x00	; 0
    1e12:	ce 01       	movw	r24, r28
    1e14:	07 96       	adiw	r24, 0x07	; 7
    1e16:	fc de       	rcall	.-520    	; 0x1c10 <rcvr_mmc>
	while ((d & 0x80) && --n);
    1e18:	8f 81       	ldd	r24, Y+7	; 0x07
    1e1a:	87 ff       	sbrs	r24, 7
    1e1c:	02 c0       	rjmp	.+4      	; 0x1e22 <send_cmd+0x9e>
    1e1e:	11 50       	subi	r17, 0x01	; 1
    1e20:	b1 f7       	brne	.-20     	; 0x1e0e <send_cmd+0x8a>

	return d;			/* Return with the response value */
}
    1e22:	27 96       	adiw	r28, 0x07	; 7
    1e24:	0f b6       	in	r0, 0x3f	; 63
    1e26:	f8 94       	cli
    1e28:	de bf       	out	0x3e, r29	; 62
    1e2a:	0f be       	out	0x3f, r0	; 63
    1e2c:	cd bf       	out	0x3d, r28	; 61
    1e2e:	df 91       	pop	r29
    1e30:	cf 91       	pop	r28
    1e32:	1f 91       	pop	r17
    1e34:	0f 91       	pop	r16
    1e36:	ff 90       	pop	r15
    1e38:	ef 90       	pop	r14
    1e3a:	df 90       	pop	r13
    1e3c:	08 95       	ret

00001e3e <xmit_datablock>:
static
int xmit_datablock (	/* 1:OK, 0:Failed */
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
    1e3e:	ef 92       	push	r14
    1e40:	ff 92       	push	r15
    1e42:	1f 93       	push	r17
    1e44:	cf 93       	push	r28
    1e46:	df 93       	push	r29
    1e48:	00 d0       	rcall	.+0      	; 0x1e4a <xmit_datablock+0xc>
    1e4a:	cd b7       	in	r28, 0x3d	; 61
    1e4c:	de b7       	in	r29, 0x3e	; 62
    1e4e:	7c 01       	movw	r14, r24
    1e50:	16 2f       	mov	r17, r22
	BYTE d[2];


	if (!wait_ready()) return 0;
    1e52:	10 df       	rcall	.-480    	; 0x1c74 <wait_ready>
    1e54:	00 97       	sbiw	r24, 0x00	; 0
    1e56:	11 f1       	breq	.+68     	; 0x1e9c <xmit_datablock+0x5e>

	d[0] = token;
    1e58:	19 83       	std	Y+1, r17	; 0x01
	xmit_mmc(d, 1);				/* Xmit a token */
    1e5a:	61 e0       	ldi	r22, 0x01	; 1
    1e5c:	70 e0       	ldi	r23, 0x00	; 0
    1e5e:	ce 01       	movw	r24, r28
    1e60:	01 96       	adiw	r24, 0x01	; 1
    1e62:	96 de       	rcall	.-724    	; 0x1b90 <xmit_mmc>
	if (token != 0xFD) {		/* Is it data token? */
    1e64:	1d 3f       	cpi	r17, 0xFD	; 253
    1e66:	c1 f0       	breq	.+48     	; 0x1e98 <xmit_datablock+0x5a>
		xmit_mmc(buff, 512);	/* Xmit the 512 byte data block to MMC */
    1e68:	60 e0       	ldi	r22, 0x00	; 0
    1e6a:	72 e0       	ldi	r23, 0x02	; 2
    1e6c:	c7 01       	movw	r24, r14
    1e6e:	90 de       	rcall	.-736    	; 0x1b90 <xmit_mmc>
		rcvr_mmc(d, 2);			/* Xmit dummy CRC (0xFF,0xFF) */
    1e70:	62 e0       	ldi	r22, 0x02	; 2
    1e72:	70 e0       	ldi	r23, 0x00	; 0
    1e74:	ce 01       	movw	r24, r28
    1e76:	01 96       	adiw	r24, 0x01	; 1
    1e78:	cb de       	rcall	.-618    	; 0x1c10 <rcvr_mmc>
		rcvr_mmc(d, 1);			/* Receive data response */
    1e7a:	61 e0       	ldi	r22, 0x01	; 1
    1e7c:	70 e0       	ldi	r23, 0x00	; 0
    1e7e:	ce 01       	movw	r24, r28
    1e80:	01 96       	adiw	r24, 0x01	; 1
    1e82:	c6 de       	rcall	.-628    	; 0x1c10 <rcvr_mmc>
		if ((d[0] & 0x1F) != 0x05)	/* If not accepted, return with error */
    1e84:	89 81       	ldd	r24, Y+1	; 0x01
    1e86:	8f 71       	andi	r24, 0x1F	; 31
    1e88:	31 e0       	ldi	r19, 0x01	; 1
    1e8a:	20 e0       	ldi	r18, 0x00	; 0
    1e8c:	85 30       	cpi	r24, 0x05	; 5
    1e8e:	09 f0       	breq	.+2      	; 0x1e92 <xmit_datablock+0x54>
    1e90:	30 e0       	ldi	r19, 0x00	; 0
			return 0;
	}

	return 1;
    1e92:	83 2f       	mov	r24, r19
    1e94:	92 2f       	mov	r25, r18
    1e96:	02 c0       	rjmp	.+4      	; 0x1e9c <xmit_datablock+0x5e>
    1e98:	81 e0       	ldi	r24, 0x01	; 1
    1e9a:	90 e0       	ldi	r25, 0x00	; 0
}
    1e9c:	0f 90       	pop	r0
    1e9e:	0f 90       	pop	r0
    1ea0:	df 91       	pop	r29
    1ea2:	cf 91       	pop	r28
    1ea4:	1f 91       	pop	r17
    1ea6:	ff 90       	pop	r15
    1ea8:	ef 90       	pop	r14
    1eaa:	08 95       	ret

00001eac <disk_status>:

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    1eac:	81 11       	cpse	r24, r1
    1eae:	03 c0       	rjmp	.+6      	; 0x1eb6 <disk_status+0xa>

	return Stat;
    1eb0:	80 91 31 01 	lds	r24, 0x0131
    1eb4:	08 95       	ret

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    1eb6:	81 e0       	ldi	r24, 0x01	; 1

	return Stat;
}
    1eb8:	08 95       	ret

00001eba <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
    1eba:	ef 92       	push	r14
    1ebc:	ff 92       	push	r15
    1ebe:	0f 93       	push	r16
    1ec0:	1f 93       	push	r17
    1ec2:	cf 93       	push	r28
    1ec4:	df 93       	push	r29
    1ec6:	00 d0       	rcall	.+0      	; 0x1ec8 <disk_initialize+0xe>
    1ec8:	00 d0       	rcall	.+0      	; 0x1eca <disk_initialize+0x10>
    1eca:	cd b7       	in	r28, 0x3d	; 61
    1ecc:	de b7       	in	r29, 0x3e	; 62
	BYTE n, ty, cmd, buf[4];
	UINT tmr;
	DSTATUS s;


	if (drv) return RES_NOTRDY;
    1ece:	81 11       	cpse	r24, r1
    1ed0:	5f c0       	rjmp	.+190    	; 0x1f90 <disk_initialize+0xd6>

	dly_us(10000);			/* 10ms */
    1ed2:	80 e1       	ldi	r24, 0x10	; 16
    1ed4:	97 e2       	ldi	r25, 0x27	; 39
    1ed6:	57 de       	rcall	.-850    	; 0x1b86 <dly_us>
	CS_INIT(); CS_H();		/* Initialize port pin tied to CS */
    1ed8:	51 9a       	sbi	0x0a, 1	; 10
    1eda:	59 9a       	sbi	0x0b, 1	; 11
	CK_INIT(); CK_L();		/* Initialize port pin tied to SCLK */
    1edc:	29 98       	cbi	0x05, 1	; 5
    1ede:	21 9a       	sbi	0x04, 1	; 4
    1ee0:	29 98       	cbi	0x05, 1	; 5
	DI_INIT();				/* Initialize port pin tied to DI */
    1ee2:	22 9a       	sbi	0x04, 2	; 4
	DO_INIT();				/* Initialize port pin tied to DO */
    1ee4:	2b 9a       	sbi	0x05, 3	; 5
    1ee6:	1a e0       	ldi	r17, 0x0A	; 10

	for (n = 10; n; n--) rcvr_mmc(buf, 1);	/* Apply 80 dummy clocks and the card gets ready to receive command */
    1ee8:	61 e0       	ldi	r22, 0x01	; 1
    1eea:	70 e0       	ldi	r23, 0x00	; 0
    1eec:	ce 01       	movw	r24, r28
    1eee:	01 96       	adiw	r24, 0x01	; 1
    1ef0:	8f de       	rcall	.-738    	; 0x1c10 <rcvr_mmc>
    1ef2:	11 50       	subi	r17, 0x01	; 1
    1ef4:	c9 f7       	brne	.-14     	; 0x1ee8 <disk_initialize+0x2e>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
    1ef6:	40 e0       	ldi	r20, 0x00	; 0
    1ef8:	50 e0       	ldi	r21, 0x00	; 0
    1efa:	ba 01       	movw	r22, r20
    1efc:	80 e0       	ldi	r24, 0x00	; 0
    1efe:	42 df       	rcall	.-380    	; 0x1d84 <send_cmd>
    1f00:	81 30       	cpi	r24, 0x01	; 1
    1f02:	09 f0       	breq	.+2      	; 0x1f06 <disk_initialize+0x4c>
    1f04:	6b c0       	rjmp	.+214    	; 0x1fdc <disk_initialize+0x122>
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
    1f06:	4a ea       	ldi	r20, 0xAA	; 170
    1f08:	51 e0       	ldi	r21, 0x01	; 1
    1f0a:	60 e0       	ldi	r22, 0x00	; 0
    1f0c:	70 e0       	ldi	r23, 0x00	; 0
    1f0e:	88 e0       	ldi	r24, 0x08	; 8
    1f10:	39 df       	rcall	.-398    	; 0x1d84 <send_cmd>
    1f12:	81 30       	cpi	r24, 0x01	; 1
    1f14:	f1 f4       	brne	.+60     	; 0x1f52 <disk_initialize+0x98>
			rcvr_mmc(buf, 4);							/* Get trailing return value of R7 resp */
    1f16:	64 e0       	ldi	r22, 0x04	; 4
    1f18:	70 e0       	ldi	r23, 0x00	; 0
    1f1a:	ce 01       	movw	r24, r28
    1f1c:	01 96       	adiw	r24, 0x01	; 1
    1f1e:	78 de       	rcall	.-784    	; 0x1c10 <rcvr_mmc>
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
    1f20:	8b 81       	ldd	r24, Y+3	; 0x03
    1f22:	81 30       	cpi	r24, 0x01	; 1
    1f24:	09 f0       	breq	.+2      	; 0x1f28 <disk_initialize+0x6e>
    1f26:	5a c0       	rjmp	.+180    	; 0x1fdc <disk_initialize+0x122>
    1f28:	8c 81       	ldd	r24, Y+4	; 0x04
    1f2a:	8a 3a       	cpi	r24, 0xAA	; 170
    1f2c:	09 f0       	breq	.+2      	; 0x1f30 <disk_initialize+0x76>
    1f2e:	56 c0       	rjmp	.+172    	; 0x1fdc <disk_initialize+0x122>
    1f30:	08 ee       	ldi	r16, 0xE8	; 232
    1f32:	13 e0       	ldi	r17, 0x03	; 3
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
    1f34:	40 e0       	ldi	r20, 0x00	; 0
    1f36:	50 e0       	ldi	r21, 0x00	; 0
    1f38:	60 e0       	ldi	r22, 0x00	; 0
    1f3a:	70 e4       	ldi	r23, 0x40	; 64
    1f3c:	89 ea       	ldi	r24, 0xA9	; 169
    1f3e:	22 df       	rcall	.-444    	; 0x1d84 <send_cmd>
    1f40:	88 23       	and	r24, r24
    1f42:	41 f1       	breq	.+80     	; 0x1f94 <disk_initialize+0xda>
					dly_us(1000);
    1f44:	88 ee       	ldi	r24, 0xE8	; 232
    1f46:	93 e0       	ldi	r25, 0x03	; 3
    1f48:	1e de       	rcall	.-964    	; 0x1b86 <dly_us>
    1f4a:	01 50       	subi	r16, 0x01	; 1
    1f4c:	11 09       	sbc	r17, r1
	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			rcvr_mmc(buf, 4);							/* Get trailing return value of R7 resp */
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
    1f4e:	91 f7       	brne	.-28     	; 0x1f34 <disk_initialize+0x7a>
    1f50:	45 c0       	rjmp	.+138    	; 0x1fdc <disk_initialize+0x122>
					rcvr_mmc(buf, 4);
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
    1f52:	40 e0       	ldi	r20, 0x00	; 0
    1f54:	50 e0       	ldi	r21, 0x00	; 0
    1f56:	ba 01       	movw	r22, r20
    1f58:	89 ea       	ldi	r24, 0xA9	; 169
    1f5a:	14 df       	rcall	.-472    	; 0x1d84 <send_cmd>
    1f5c:	82 30       	cpi	r24, 0x02	; 2
    1f5e:	18 f0       	brcs	.+6      	; 0x1f66 <disk_initialize+0xac>
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
    1f60:	01 e0       	ldi	r16, 0x01	; 1
    1f62:	11 e0       	ldi	r17, 0x01	; 1
    1f64:	02 c0       	rjmp	.+4      	; 0x1f6a <disk_initialize+0xb0>
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
    1f66:	09 ea       	ldi	r16, 0xA9	; 169
    1f68:	12 e0       	ldi	r17, 0x02	; 2
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
    1f6a:	88 ee       	ldi	r24, 0xE8	; 232
    1f6c:	e8 2e       	mov	r14, r24
    1f6e:	83 e0       	ldi	r24, 0x03	; 3
    1f70:	f8 2e       	mov	r15, r24
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
				if (send_cmd(cmd, 0) == 0) break;
    1f72:	40 e0       	ldi	r20, 0x00	; 0
    1f74:	50 e0       	ldi	r21, 0x00	; 0
    1f76:	ba 01       	movw	r22, r20
    1f78:	80 2f       	mov	r24, r16
    1f7a:	04 df       	rcall	.-504    	; 0x1d84 <send_cmd>
    1f7c:	88 23       	and	r24, r24
    1f7e:	31 f1       	breq	.+76     	; 0x1fcc <disk_initialize+0x112>
				dly_us(1000);
    1f80:	88 ee       	ldi	r24, 0xE8	; 232
    1f82:	93 e0       	ldi	r25, 0x03	; 3
    1f84:	00 de       	rcall	.-1024   	; 0x1b86 <dly_us>
    1f86:	81 e0       	ldi	r24, 0x01	; 1
    1f88:	e8 1a       	sub	r14, r24
    1f8a:	f1 08       	sbc	r15, r1
			if (send_cmd(ACMD41, 0) <= 1) 	{
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
    1f8c:	91 f7       	brne	.-28     	; 0x1f72 <disk_initialize+0xb8>
    1f8e:	26 c0       	rjmp	.+76     	; 0x1fdc <disk_initialize+0x122>
	BYTE n, ty, cmd, buf[4];
	UINT tmr;
	DSTATUS s;


	if (drv) return RES_NOTRDY;
    1f90:	83 e0       	ldi	r24, 0x03	; 3
    1f92:	26 c0       	rjmp	.+76     	; 0x1fe0 <disk_initialize+0x126>
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
					dly_us(1000);
				}
				if (tmr && send_cmd(CMD58, 0) == 0) {	/* Check CCS bit in the OCR */
    1f94:	40 e0       	ldi	r20, 0x00	; 0
    1f96:	50 e0       	ldi	r21, 0x00	; 0
    1f98:	ba 01       	movw	r22, r20
    1f9a:	8a e3       	ldi	r24, 0x3A	; 58
    1f9c:	f3 de       	rcall	.-538    	; 0x1d84 <send_cmd>
    1f9e:	81 11       	cpse	r24, r1
    1fa0:	1d c0       	rjmp	.+58     	; 0x1fdc <disk_initialize+0x122>
					rcvr_mmc(buf, 4);
    1fa2:	64 e0       	ldi	r22, 0x04	; 4
    1fa4:	70 e0       	ldi	r23, 0x00	; 0
    1fa6:	ce 01       	movw	r24, r28
    1fa8:	01 96       	adiw	r24, 0x01	; 1
    1faa:	32 de       	rcall	.-924    	; 0x1c10 <rcvr_mmc>
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
    1fac:	89 81       	ldd	r24, Y+1	; 0x01
    1fae:	86 fd       	sbrc	r24, 6
    1fb0:	02 c0       	rjmp	.+4      	; 0x1fb6 <disk_initialize+0xfc>
    1fb2:	14 e0       	ldi	r17, 0x04	; 4
    1fb4:	01 c0       	rjmp	.+2      	; 0x1fb8 <disk_initialize+0xfe>
    1fb6:	1c e0       	ldi	r17, 0x0C	; 12
			}
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
    1fb8:	10 93 a1 05 	sts	0x05A1, r17
	
				
	s = ty ? 0 : STA_NOINIT;
    1fbc:	01 e0       	ldi	r16, 0x01	; 1
    1fbe:	11 11       	cpse	r17, r1
    1fc0:	00 e0       	ldi	r16, 0x00	; 0
	Stat = s;
    1fc2:	00 93 31 01 	sts	0x0131, r16

	deselect();
    1fc6:	79 de       	rcall	.-782    	; 0x1cba <deselect>

	return s;
    1fc8:	80 2f       	mov	r24, r16
    1fca:	0a c0       	rjmp	.+20     	; 0x1fe0 <disk_initialize+0x126>
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
				if (send_cmd(cmd, 0) == 0) break;
				dly_us(1000);
			}
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
    1fcc:	40 e0       	ldi	r20, 0x00	; 0
    1fce:	52 e0       	ldi	r21, 0x02	; 2
    1fd0:	60 e0       	ldi	r22, 0x00	; 0
    1fd2:	70 e0       	ldi	r23, 0x00	; 0
    1fd4:	80 e1       	ldi	r24, 0x10	; 16
    1fd6:	d6 de       	rcall	.-596    	; 0x1d84 <send_cmd>
    1fd8:	88 23       	and	r24, r24
    1fda:	71 f3       	breq	.-36     	; 0x1fb8 <disk_initialize+0xfe>
				ty = 0;
    1fdc:	10 e0       	ldi	r17, 0x00	; 0
    1fde:	ec cf       	rjmp	.-40     	; 0x1fb8 <disk_initialize+0xfe>
	Stat = s;

	deselect();

	return s;
}
    1fe0:	0f 90       	pop	r0
    1fe2:	0f 90       	pop	r0
    1fe4:	0f 90       	pop	r0
    1fe6:	0f 90       	pop	r0
    1fe8:	df 91       	pop	r29
    1fea:	cf 91       	pop	r28
    1fec:	1f 91       	pop	r17
    1fee:	0f 91       	pop	r16
    1ff0:	ff 90       	pop	r15
    1ff2:	ef 90       	pop	r14
    1ff4:	08 95       	ret

00001ff6 <disk_read>:
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
    1ff6:	ef 92       	push	r14
    1ff8:	ff 92       	push	r15
    1ffa:	0f 93       	push	r16
    1ffc:	1f 93       	push	r17
    1ffe:	cf 93       	push	r28
    2000:	7b 01       	movw	r14, r22
    2002:	ba 01       	movw	r22, r20
    2004:	a9 01       	movw	r20, r18

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    2006:	81 11       	cpse	r24, r1
    2008:	03 c0       	rjmp	.+6      	; 0x2010 <disk_read+0x1a>

	return Stat;
    200a:	80 91 31 01 	lds	r24, 0x0131
    200e:	01 c0       	rjmp	.+2      	; 0x2012 <disk_read+0x1c>

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    2010:	81 e0       	ldi	r24, 0x01	; 1
)
{
	BYTE cmd;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    2012:	80 fd       	sbrc	r24, 0
    2014:	2d c0       	rjmp	.+90     	; 0x2070 <disk_read+0x7a>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
    2016:	80 91 a1 05 	lds	r24, 0x05A1
    201a:	83 fd       	sbrc	r24, 3
    201c:	07 c0       	rjmp	.+14     	; 0x202c <disk_read+0x36>
    201e:	89 e0       	ldi	r24, 0x09	; 9
    2020:	44 0f       	add	r20, r20
    2022:	55 1f       	adc	r21, r21
    2024:	66 1f       	adc	r22, r22
    2026:	77 1f       	adc	r23, r23
    2028:	8a 95       	dec	r24
    202a:	d1 f7       	brne	.-12     	; 0x2020 <disk_read+0x2a>

	cmd = count > 1 ? CMD18 : CMD17;			/*  READ_MULTIPLE_BLOCK : READ_SINGLE_BLOCK */
    202c:	02 30       	cpi	r16, 0x02	; 2
    202e:	11 05       	cpc	r17, r1
    2030:	10 f4       	brcc	.+4      	; 0x2036 <disk_read+0x40>
    2032:	c1 e1       	ldi	r28, 0x11	; 17
    2034:	01 c0       	rjmp	.+2      	; 0x2038 <disk_read+0x42>
    2036:	c2 e1       	ldi	r28, 0x12	; 18
	if (send_cmd(cmd, sector) == 0) {
    2038:	8c 2f       	mov	r24, r28
    203a:	a4 de       	rcall	.-696    	; 0x1d84 <send_cmd>
    203c:	81 11       	cpse	r24, r1
    203e:	12 c0       	rjmp	.+36     	; 0x2064 <disk_read+0x6e>
		do {
			if (!rcvr_datablock(buff, 512)) break;
    2040:	60 e0       	ldi	r22, 0x00	; 0
    2042:	72 e0       	ldi	r23, 0x02	; 2
    2044:	c7 01       	movw	r24, r14
    2046:	65 de       	rcall	.-822    	; 0x1d12 <rcvr_datablock>
    2048:	89 2b       	or	r24, r25
    204a:	29 f0       	breq	.+10     	; 0x2056 <disk_read+0x60>
			buff += 512;
    204c:	8e ef       	ldi	r24, 0xFE	; 254
    204e:	f8 1a       	sub	r15, r24
		} while (--count);
    2050:	01 50       	subi	r16, 0x01	; 1
    2052:	11 09       	sbc	r17, r1
    2054:	a9 f7       	brne	.-22     	; 0x2040 <disk_read+0x4a>
		if (cmd == CMD18) send_cmd(CMD12, 0);	/* STOP_TRANSMISSION */
    2056:	c2 31       	cpi	r28, 0x12	; 18
    2058:	29 f4       	brne	.+10     	; 0x2064 <disk_read+0x6e>
    205a:	40 e0       	ldi	r20, 0x00	; 0
    205c:	50 e0       	ldi	r21, 0x00	; 0
    205e:	ba 01       	movw	r22, r20
    2060:	8c e0       	ldi	r24, 0x0C	; 12
    2062:	90 de       	rcall	.-736    	; 0x1d84 <send_cmd>
	}
	deselect();
    2064:	2a de       	rcall	.-940    	; 0x1cba <deselect>

	return count ? RES_ERROR : RES_OK;
    2066:	81 e0       	ldi	r24, 0x01	; 1
    2068:	01 2b       	or	r16, r17
    206a:	19 f4       	brne	.+6      	; 0x2072 <disk_read+0x7c>
    206c:	80 e0       	ldi	r24, 0x00	; 0
    206e:	01 c0       	rjmp	.+2      	; 0x2072 <disk_read+0x7c>
)
{
	BYTE cmd;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    2070:	83 e0       	ldi	r24, 0x03	; 3
		if (cmd == CMD18) send_cmd(CMD12, 0);	/* STOP_TRANSMISSION */
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
    2072:	cf 91       	pop	r28
    2074:	1f 91       	pop	r17
    2076:	0f 91       	pop	r16
    2078:	ff 90       	pop	r15
    207a:	ef 90       	pop	r14
    207c:	08 95       	ret

0000207e <disk_write>:
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
    207e:	cf 92       	push	r12
    2080:	df 92       	push	r13
    2082:	ef 92       	push	r14
    2084:	ff 92       	push	r15
    2086:	0f 93       	push	r16
    2088:	1f 93       	push	r17
    208a:	cf 93       	push	r28
    208c:	df 93       	push	r29
    208e:	eb 01       	movw	r28, r22
    2090:	69 01       	movw	r12, r18
    2092:	7a 01       	movw	r14, r20

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    2094:	81 11       	cpse	r24, r1
    2096:	03 c0       	rjmp	.+6      	; 0x209e <disk_write+0x20>

	return Stat;
    2098:	80 91 31 01 	lds	r24, 0x0131
    209c:	01 c0       	rjmp	.+2      	; 0x20a0 <disk_write+0x22>

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    209e:	81 e0       	ldi	r24, 0x01	; 1
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    20a0:	80 fd       	sbrc	r24, 0
    20a2:	43 c0       	rjmp	.+134    	; 0x212a <disk_write+0xac>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
    20a4:	80 91 a1 05 	lds	r24, 0x05A1
    20a8:	83 fd       	sbrc	r24, 3
    20aa:	07 c0       	rjmp	.+14     	; 0x20ba <disk_write+0x3c>
    20ac:	99 e0       	ldi	r25, 0x09	; 9
    20ae:	cc 0c       	add	r12, r12
    20b0:	dd 1c       	adc	r13, r13
    20b2:	ee 1c       	adc	r14, r14
    20b4:	ff 1c       	adc	r15, r15
    20b6:	9a 95       	dec	r25
    20b8:	d1 f7       	brne	.-12     	; 0x20ae <disk_write+0x30>

	if (count == 1) {	/* Single block write */
    20ba:	01 30       	cpi	r16, 0x01	; 1
    20bc:	11 05       	cpc	r17, r1
    20be:	89 f4       	brne	.+34     	; 0x20e2 <disk_write+0x64>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
    20c0:	b7 01       	movw	r22, r14
    20c2:	a6 01       	movw	r20, r12
    20c4:	88 e1       	ldi	r24, 0x18	; 24
    20c6:	5e de       	rcall	.-836    	; 0x1d84 <send_cmd>
    20c8:	81 11       	cpse	r24, r1
    20ca:	29 c0       	rjmp	.+82     	; 0x211e <disk_write+0xa0>
			&& xmit_datablock(buff, 0xFE))
    20cc:	6e ef       	ldi	r22, 0xFE	; 254
    20ce:	ce 01       	movw	r24, r28
    20d0:	b6 de       	rcall	.-660    	; 0x1e3e <xmit_datablock>
    20d2:	31 e0       	ldi	r19, 0x01	; 1
    20d4:	20 e0       	ldi	r18, 0x00	; 0
    20d6:	89 2b       	or	r24, r25
    20d8:	09 f0       	breq	.+2      	; 0x20dc <disk_write+0x5e>
    20da:	30 e0       	ldi	r19, 0x00	; 0
    20dc:	03 2f       	mov	r16, r19
    20de:	12 2f       	mov	r17, r18
    20e0:	1e c0       	rjmp	.+60     	; 0x211e <disk_write+0xa0>
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
    20e2:	86 70       	andi	r24, 0x06	; 6
    20e4:	29 f0       	breq	.+10     	; 0x20f0 <disk_write+0x72>
    20e6:	a8 01       	movw	r20, r16
    20e8:	60 e0       	ldi	r22, 0x00	; 0
    20ea:	70 e0       	ldi	r23, 0x00	; 0
    20ec:	87 e9       	ldi	r24, 0x97	; 151
    20ee:	4a de       	rcall	.-876    	; 0x1d84 <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
    20f0:	b7 01       	movw	r22, r14
    20f2:	a6 01       	movw	r20, r12
    20f4:	89 e1       	ldi	r24, 0x19	; 25
    20f6:	46 de       	rcall	.-884    	; 0x1d84 <send_cmd>
    20f8:	81 11       	cpse	r24, r1
    20fa:	11 c0       	rjmp	.+34     	; 0x211e <disk_write+0xa0>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
    20fc:	6c ef       	ldi	r22, 0xFC	; 252
    20fe:	ce 01       	movw	r24, r28
    2100:	9e de       	rcall	.-708    	; 0x1e3e <xmit_datablock>
    2102:	89 2b       	or	r24, r25
    2104:	21 f0       	breq	.+8      	; 0x210e <disk_write+0x90>
				buff += 512;
    2106:	de 5f       	subi	r29, 0xFE	; 254
			} while (--count);
    2108:	01 50       	subi	r16, 0x01	; 1
    210a:	11 09       	sbc	r17, r1
    210c:	b9 f7       	brne	.-18     	; 0x20fc <disk_write+0x7e>
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
    210e:	6d ef       	ldi	r22, 0xFD	; 253
    2110:	80 e0       	ldi	r24, 0x00	; 0
    2112:	90 e0       	ldi	r25, 0x00	; 0
    2114:	94 de       	rcall	.-728    	; 0x1e3e <xmit_datablock>
    2116:	89 2b       	or	r24, r25
    2118:	11 f4       	brne	.+4      	; 0x211e <disk_write+0xa0>
				count = 1;
    211a:	01 e0       	ldi	r16, 0x01	; 1
    211c:	10 e0       	ldi	r17, 0x00	; 0
		}
	}
	deselect();
    211e:	cd dd       	rcall	.-1126   	; 0x1cba <deselect>

	return count ? RES_ERROR : RES_OK;
    2120:	81 e0       	ldi	r24, 0x01	; 1
    2122:	01 2b       	or	r16, r17
    2124:	19 f4       	brne	.+6      	; 0x212c <disk_write+0xae>
    2126:	80 e0       	ldi	r24, 0x00	; 0
    2128:	01 c0       	rjmp	.+2      	; 0x212c <disk_write+0xae>
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    212a:	83 e0       	ldi	r24, 0x03	; 3
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
    212c:	df 91       	pop	r29
    212e:	cf 91       	pop	r28
    2130:	1f 91       	pop	r17
    2132:	0f 91       	pop	r16
    2134:	ff 90       	pop	r15
    2136:	ef 90       	pop	r14
    2138:	df 90       	pop	r13
    213a:	cf 90       	pop	r12
    213c:	08 95       	ret

0000213e <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
    213e:	0f 93       	push	r16
    2140:	1f 93       	push	r17
    2142:	cf 93       	push	r28
    2144:	df 93       	push	r29
    2146:	cd b7       	in	r28, 0x3d	; 61
    2148:	de b7       	in	r29, 0x3e	; 62
    214a:	60 97       	sbiw	r28, 0x10	; 16
    214c:	0f b6       	in	r0, 0x3f	; 63
    214e:	f8 94       	cli
    2150:	de bf       	out	0x3e, r29	; 62
    2152:	0f be       	out	0x3f, r0	; 63
    2154:	cd bf       	out	0x3d, r28	; 61

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    2156:	81 11       	cpse	r24, r1
    2158:	03 c0       	rjmp	.+6      	; 0x2160 <disk_ioctl+0x22>

	return Stat;
    215a:	80 91 31 01 	lds	r24, 0x0131
    215e:	01 c0       	rjmp	.+2      	; 0x2162 <disk_ioctl+0x24>

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    2160:	81 e0       	ldi	r24, 0x01	; 1
	DRESULT res;
	BYTE n, csd[16];
	DWORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */
    2162:	80 fd       	sbrc	r24, 0
    2164:	7c c0       	rjmp	.+248    	; 0x225e <disk_ioctl+0x120>
    2166:	8a 01       	movw	r16, r20

	res = RES_ERROR;
	switch (ctrl) {
    2168:	61 30       	cpi	r22, 0x01	; 1
    216a:	79 f0       	breq	.+30     	; 0x218a <disk_ioctl+0x4c>
    216c:	40 f0       	brcs	.+16     	; 0x217e <disk_ioctl+0x40>
    216e:	63 30       	cpi	r22, 0x03	; 3
    2170:	09 f0       	breq	.+2      	; 0x2174 <disk_ioctl+0x36>
    2172:	71 c0       	rjmp	.+226    	; 0x2256 <disk_ioctl+0x118>
				res = RES_OK;
			}
			break;

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			*(DWORD*)buff = 128;
    2174:	80 e8       	ldi	r24, 0x80	; 128
    2176:	90 e0       	ldi	r25, 0x00	; 0
    2178:	a0 e0       	ldi	r26, 0x00	; 0
    217a:	b0 e0       	ldi	r27, 0x00	; 0
    217c:	65 c0       	rjmp	.+202    	; 0x2248 <disk_ioctl+0x10a>
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */

	res = RES_ERROR;
	switch (ctrl) {
		case CTRL_SYNC :		/* Make sure that no pending write process */
			if (select()) res = RES_OK;
    217e:	ac dd       	rcall	.-1192   	; 0x1cd8 <select>
    2180:	11 e0       	ldi	r17, 0x01	; 1
    2182:	89 2b       	or	r24, r25
    2184:	09 f4       	brne	.+2      	; 0x2188 <disk_ioctl+0x4a>
    2186:	68 c0       	rjmp	.+208    	; 0x2258 <disk_ioctl+0x11a>
    2188:	64 c0       	rjmp	.+200    	; 0x2252 <disk_ioctl+0x114>
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
    218a:	40 e0       	ldi	r20, 0x00	; 0
    218c:	50 e0       	ldi	r21, 0x00	; 0
    218e:	ba 01       	movw	r22, r20
    2190:	89 e0       	ldi	r24, 0x09	; 9
    2192:	f8 dd       	rcall	.-1040   	; 0x1d84 <send_cmd>
    2194:	88 23       	and	r24, r24
    2196:	11 f0       	breq	.+4      	; 0x219c <disk_ioctl+0x5e>
	DWORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */

	res = RES_ERROR;
    2198:	11 e0       	ldi	r17, 0x01	; 1
    219a:	5e c0       	rjmp	.+188    	; 0x2258 <disk_ioctl+0x11a>
		case CTRL_SYNC :		/* Make sure that no pending write process */
			if (select()) res = RES_OK;
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
    219c:	60 e1       	ldi	r22, 0x10	; 16
    219e:	70 e0       	ldi	r23, 0x00	; 0
    21a0:	ce 01       	movw	r24, r28
    21a2:	01 96       	adiw	r24, 0x01	; 1
    21a4:	b6 dd       	rcall	.-1172   	; 0x1d12 <rcvr_datablock>
    21a6:	89 2b       	or	r24, r25
    21a8:	b9 f3       	breq	.-18     	; 0x2198 <disk_ioctl+0x5a>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
    21aa:	99 81       	ldd	r25, Y+1	; 0x01
    21ac:	92 95       	swap	r25
    21ae:	96 95       	lsr	r25
    21b0:	96 95       	lsr	r25
    21b2:	93 70       	andi	r25, 0x03	; 3
    21b4:	88 85       	ldd	r24, Y+8	; 0x08
    21b6:	49 85       	ldd	r20, Y+9	; 0x09
    21b8:	2a 85       	ldd	r18, Y+10	; 0x0a
    21ba:	91 30       	cpi	r25, 0x01	; 1
    21bc:	e1 f4       	brne	.+56     	; 0x21f6 <disk_ioctl+0xb8>
					cs = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
    21be:	8f 73       	andi	r24, 0x3F	; 63
    21c0:	90 e0       	ldi	r25, 0x00	; 0
    21c2:	a0 e0       	ldi	r26, 0x00	; 0
    21c4:	b0 e0       	ldi	r27, 0x00	; 0
    21c6:	dc 01       	movw	r26, r24
    21c8:	99 27       	eor	r25, r25
    21ca:	88 27       	eor	r24, r24
    21cc:	01 96       	adiw	r24, 0x01	; 1
    21ce:	a1 1d       	adc	r26, r1
    21d0:	b1 1d       	adc	r27, r1
    21d2:	50 e0       	ldi	r21, 0x00	; 0
    21d4:	54 2f       	mov	r21, r20
    21d6:	44 27       	eor	r20, r20
    21d8:	ba 01       	movw	r22, r20
    21da:	62 0f       	add	r22, r18
    21dc:	71 1d       	adc	r23, r1
    21de:	86 0f       	add	r24, r22
    21e0:	97 1f       	adc	r25, r23
    21e2:	a1 1d       	adc	r26, r1
    21e4:	b1 1d       	adc	r27, r1
					*(DWORD*)buff = cs << 10;
    21e6:	7a e0       	ldi	r23, 0x0A	; 10
    21e8:	88 0f       	add	r24, r24
    21ea:	99 1f       	adc	r25, r25
    21ec:	aa 1f       	adc	r26, r26
    21ee:	bb 1f       	adc	r27, r27
    21f0:	7a 95       	dec	r23
    21f2:	d1 f7       	brne	.-12     	; 0x21e8 <disk_ioctl+0xaa>
    21f4:	29 c0       	rjmp	.+82     	; 0x2248 <disk_ioctl+0x10a>
				} else {					/* SDC ver 1.XX or MMC */
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
    21f6:	42 95       	swap	r20
    21f8:	46 95       	lsr	r20
    21fa:	46 95       	lsr	r20
    21fc:	43 70       	andi	r20, 0x03	; 3
    21fe:	f4 e0       	ldi	r31, 0x04	; 4
    2200:	8f 9f       	mul	r24, r31
    2202:	c0 01       	movw	r24, r0
    2204:	11 24       	eor	r1, r1
    2206:	84 0f       	add	r24, r20
    2208:	91 1d       	adc	r25, r1
    220a:	01 96       	adiw	r24, 0x01	; 1
    220c:	4f 81       	ldd	r20, Y+7	; 0x07
    220e:	43 70       	andi	r20, 0x03	; 3
    2210:	50 e0       	ldi	r21, 0x00	; 0
    2212:	54 2f       	mov	r21, r20
    2214:	44 27       	eor	r20, r20
    2216:	55 0f       	add	r21, r21
    2218:	55 0f       	add	r21, r21
    221a:	84 0f       	add	r24, r20
    221c:	95 1f       	adc	r25, r21
    221e:	a0 e0       	ldi	r26, 0x00	; 0
    2220:	b0 e0       	ldi	r27, 0x00	; 0
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					cs = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = cs << 10;
				} else {					/* SDC ver 1.XX or MMC */
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
    2222:	3e 81       	ldd	r19, Y+6	; 0x06
    2224:	43 2f       	mov	r20, r19
    2226:	4f 70       	andi	r20, 0x0F	; 15
    2228:	3b 85       	ldd	r19, Y+11	; 0x0b
    222a:	33 1f       	adc	r19, r19
    222c:	33 27       	eor	r19, r19
    222e:	33 1f       	adc	r19, r19
    2230:	34 0f       	add	r19, r20
    2232:	23 70       	andi	r18, 0x03	; 3
    2234:	22 0f       	add	r18, r18
    2236:	23 0f       	add	r18, r19
					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = cs << (n - 9);
    2238:	27 50       	subi	r18, 0x07	; 7
    223a:	04 c0       	rjmp	.+8      	; 0x2244 <disk_ioctl+0x106>
    223c:	88 0f       	add	r24, r24
    223e:	99 1f       	adc	r25, r25
    2240:	aa 1f       	adc	r26, r26
    2242:	bb 1f       	adc	r27, r27
    2244:	2a 95       	dec	r18
    2246:	d2 f7       	brpl	.-12     	; 0x223c <disk_ioctl+0xfe>
    2248:	f8 01       	movw	r30, r16
    224a:	80 83       	st	Z, r24
    224c:	91 83       	std	Z+1, r25	; 0x01
    224e:	a2 83       	std	Z+2, r26	; 0x02
    2250:	b3 83       	std	Z+3, r27	; 0x03
				}
				res = RES_OK;
    2252:	10 e0       	ldi	r17, 0x00	; 0
    2254:	01 c0       	rjmp	.+2      	; 0x2258 <disk_ioctl+0x11a>
			*(DWORD*)buff = 128;
			res = RES_OK;
			break;

		default:
			res = RES_PARERR;
    2256:	14 e0       	ldi	r17, 0x04	; 4
	}

	deselect();
    2258:	30 dd       	rcall	.-1440   	; 0x1cba <deselect>

	return res;
    225a:	81 2f       	mov	r24, r17
    225c:	01 c0       	rjmp	.+2      	; 0x2260 <disk_ioctl+0x122>
	DRESULT res;
	BYTE n, csd[16];
	DWORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */
    225e:	83 e0       	ldi	r24, 0x03	; 3
	}

	deselect();

	return res;
}
    2260:	60 96       	adiw	r28, 0x10	; 16
    2262:	0f b6       	in	r0, 0x3f	; 63
    2264:	f8 94       	cli
    2266:	de bf       	out	0x3e, r29	; 62
    2268:	0f be       	out	0x3f, r0	; 63
    226a:	cd bf       	out	0x3d, r28	; 61
    226c:	df 91       	pop	r29
    226e:	cf 91       	pop	r28
    2270:	1f 91       	pop	r17
    2272:	0f 91       	pop	r16
    2274:	08 95       	ret

00002276 <mem_cpy>:
			FREE_BUF();
		}
	}

	LEAVE_FF(dp->fs, res);
}
    2276:	cf 93       	push	r28
    2278:	df 93       	push	r29
    227a:	eb 01       	movw	r28, r22
    227c:	dc 01       	movw	r26, r24
    227e:	fa 01       	movw	r30, r20
    2280:	e2 30       	cpi	r30, 0x02	; 2
    2282:	f1 05       	cpc	r31, r1
    2284:	30 f0       	brcs	.+12     	; 0x2292 <mem_cpy+0x1c>
    2286:	29 91       	ld	r18, Y+
    2288:	39 91       	ld	r19, Y+
    228a:	2d 93       	st	X+, r18
    228c:	3d 93       	st	X+, r19
    228e:	32 97       	sbiw	r30, 0x02	; 2
    2290:	f7 cf       	rjmp	.-18     	; 0x2280 <mem_cpy+0xa>
    2292:	9a 01       	movw	r18, r20
    2294:	2e 7f       	andi	r18, 0xFE	; 254
    2296:	dc 01       	movw	r26, r24
    2298:	a2 0f       	add	r26, r18
    229a:	b3 1f       	adc	r27, r19
    229c:	fb 01       	movw	r30, r22
    229e:	e2 0f       	add	r30, r18
    22a0:	f3 1f       	adc	r31, r19
    22a2:	40 ff       	sbrs	r20, 0
    22a4:	02 c0       	rjmp	.+4      	; 0x22aa <mem_cpy+0x34>
    22a6:	20 81       	ld	r18, Z
    22a8:	2c 93       	st	X, r18
    22aa:	df 91       	pop	r29
    22ac:	cf 91       	pop	r28
    22ae:	08 95       	ret

000022b0 <get_fileinfo>:
    22b0:	0f 93       	push	r16
    22b2:	1f 93       	push	r17
    22b4:	cf 93       	push	r28
    22b6:	df 93       	push	r29
    22b8:	8b 01       	movw	r16, r22
    22ba:	fb 01       	movw	r30, r22
    22bc:	39 96       	adiw	r30, 0x09	; 9
    22be:	dc 01       	movw	r26, r24
    22c0:	1e 96       	adiw	r26, 0x0e	; 14
    22c2:	4d 91       	ld	r20, X+
    22c4:	5d 91       	ld	r21, X+
    22c6:	6d 91       	ld	r22, X+
    22c8:	7c 91       	ld	r23, X
    22ca:	51 97       	sbiw	r26, 0x11	; 17
    22cc:	45 2b       	or	r20, r21
    22ce:	46 2b       	or	r20, r22
    22d0:	47 2b       	or	r20, r23
    22d2:	a9 f1       	breq	.+106    	; 0x233e <get_fileinfo+0x8e>
    22d4:	52 96       	adiw	r26, 0x12	; 18
    22d6:	cd 91       	ld	r28, X+
    22d8:	dc 91       	ld	r29, X
    22da:	53 97       	sbiw	r26, 0x13	; 19
    22dc:	ae 01       	movw	r20, r28
    22de:	80 e0       	ldi	r24, 0x00	; 0
    22e0:	90 e0       	ldi	r25, 0x00	; 0
    22e2:	3e e2       	ldi	r19, 0x2E	; 46
    22e4:	01 96       	adiw	r24, 0x01	; 1
    22e6:	da 01       	movw	r26, r20
    22e8:	2d 91       	ld	r18, X+
    22ea:	ad 01       	movw	r20, r26
    22ec:	20 32       	cpi	r18, 0x20	; 32
    22ee:	51 f0       	breq	.+20     	; 0x2304 <get_fileinfo+0x54>
    22f0:	25 30       	cpi	r18, 0x05	; 5
    22f2:	09 f4       	brne	.+2      	; 0x22f6 <get_fileinfo+0x46>
    22f4:	25 ee       	ldi	r18, 0xE5	; 229
    22f6:	89 30       	cpi	r24, 0x09	; 9
    22f8:	91 05       	cpc	r25, r1
    22fa:	11 f4       	brne	.+4      	; 0x2300 <get_fileinfo+0x50>
    22fc:	30 83       	st	Z, r19
    22fe:	31 96       	adiw	r30, 0x01	; 1
    2300:	20 83       	st	Z, r18
    2302:	31 96       	adiw	r30, 0x01	; 1
    2304:	8b 30       	cpi	r24, 0x0B	; 11
    2306:	91 05       	cpc	r25, r1
    2308:	69 f7       	brne	.-38     	; 0x22e4 <get_fileinfo+0x34>
    230a:	8b 85       	ldd	r24, Y+11	; 0x0b
    230c:	d8 01       	movw	r26, r16
    230e:	18 96       	adiw	r26, 0x08	; 8
    2310:	8c 93       	st	X, r24
    2312:	18 97       	sbiw	r26, 0x08	; 8
    2314:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2316:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2318:	6e 8d       	ldd	r22, Y+30	; 0x1e
    231a:	7f 8d       	ldd	r23, Y+31	; 0x1f
    231c:	4d 93       	st	X+, r20
    231e:	5d 93       	st	X+, r21
    2320:	6d 93       	st	X+, r22
    2322:	7c 93       	st	X, r23
    2324:	13 97       	sbiw	r26, 0x03	; 3
    2326:	88 8d       	ldd	r24, Y+24	; 0x18
    2328:	99 8d       	ldd	r25, Y+25	; 0x19
    232a:	15 96       	adiw	r26, 0x05	; 5
    232c:	9c 93       	st	X, r25
    232e:	8e 93       	st	-X, r24
    2330:	14 97       	sbiw	r26, 0x04	; 4
    2332:	8e 89       	ldd	r24, Y+22	; 0x16
    2334:	9f 89       	ldd	r25, Y+23	; 0x17
    2336:	17 96       	adiw	r26, 0x07	; 7
    2338:	9c 93       	st	X, r25
    233a:	8e 93       	st	-X, r24
    233c:	16 97       	sbiw	r26, 0x06	; 6
    233e:	10 82       	st	Z, r1
    2340:	df 91       	pop	r29
    2342:	cf 91       	pop	r28
    2344:	1f 91       	pop	r17
    2346:	0f 91       	pop	r16
    2348:	08 95       	ret

0000234a <get_ldnumber>:
    234a:	fc 01       	movw	r30, r24
    234c:	20 81       	ld	r18, Z
    234e:	31 81       	ldd	r19, Z+1	; 0x01
    2350:	21 15       	cp	r18, r1
    2352:	31 05       	cpc	r19, r1
    2354:	b1 f0       	breq	.+44     	; 0x2382 <get_ldnumber+0x38>
    2356:	f9 01       	movw	r30, r18
    2358:	bf 01       	movw	r22, r30
    235a:	41 91       	ld	r20, Z+
    235c:	41 32       	cpi	r20, 0x21	; 33
    235e:	70 f0       	brcs	.+28     	; 0x237c <get_ldnumber+0x32>
    2360:	4a 33       	cpi	r20, 0x3A	; 58
    2362:	d1 f7       	brne	.-12     	; 0x2358 <get_ldnumber+0xe>
    2364:	f9 01       	movw	r30, r18
    2366:	41 91       	ld	r20, Z+
    2368:	6e 17       	cp	r22, r30
    236a:	7f 07       	cpc	r23, r31
    236c:	51 f4       	brne	.+20     	; 0x2382 <get_ldnumber+0x38>
    236e:	40 33       	cpi	r20, 0x30	; 48
    2370:	41 f4       	brne	.+16     	; 0x2382 <get_ldnumber+0x38>
    2372:	2e 5f       	subi	r18, 0xFE	; 254
    2374:	3f 4f       	sbci	r19, 0xFF	; 255
    2376:	fc 01       	movw	r30, r24
    2378:	31 83       	std	Z+1, r19	; 0x01
    237a:	20 83       	st	Z, r18
    237c:	80 e0       	ldi	r24, 0x00	; 0
    237e:	90 e0       	ldi	r25, 0x00	; 0
    2380:	08 95       	ret
    2382:	8f ef       	ldi	r24, 0xFF	; 255
    2384:	9f ef       	ldi	r25, 0xFF	; 255
    2386:	08 95       	ret

00002388 <validate>:
    2388:	00 97       	sbiw	r24, 0x00	; 0
    238a:	c1 f0       	breq	.+48     	; 0x23bc <validate+0x34>
    238c:	dc 01       	movw	r26, r24
    238e:	ed 91       	ld	r30, X+
    2390:	fc 91       	ld	r31, X
    2392:	11 97       	sbiw	r26, 0x01	; 1
    2394:	30 97       	sbiw	r30, 0x00	; 0
    2396:	91 f0       	breq	.+36     	; 0x23bc <validate+0x34>
    2398:	20 81       	ld	r18, Z
    239a:	22 23       	and	r18, r18
    239c:	79 f0       	breq	.+30     	; 0x23bc <validate+0x34>
    239e:	26 81       	ldd	r18, Z+6	; 0x06
    23a0:	37 81       	ldd	r19, Z+7	; 0x07
    23a2:	12 96       	adiw	r26, 0x02	; 2
    23a4:	8d 91       	ld	r24, X+
    23a6:	9c 91       	ld	r25, X
    23a8:	13 97       	sbiw	r26, 0x03	; 3
    23aa:	28 17       	cp	r18, r24
    23ac:	39 07       	cpc	r19, r25
    23ae:	31 f4       	brne	.+12     	; 0x23bc <validate+0x34>
    23b0:	81 81       	ldd	r24, Z+1	; 0x01
    23b2:	7c dd       	rcall	.-1288   	; 0x1eac <disk_status>
    23b4:	80 fd       	sbrc	r24, 0
    23b6:	04 c0       	rjmp	.+8      	; 0x23c0 <validate+0x38>
    23b8:	80 e0       	ldi	r24, 0x00	; 0
    23ba:	08 95       	ret
    23bc:	89 e0       	ldi	r24, 0x09	; 9
    23be:	08 95       	ret
    23c0:	83 e0       	ldi	r24, 0x03	; 3
    23c2:	08 95       	ret

000023c4 <sync_window>:
    23c4:	8f 92       	push	r8
    23c6:	9f 92       	push	r9
    23c8:	af 92       	push	r10
    23ca:	bf 92       	push	r11
    23cc:	cf 92       	push	r12
    23ce:	df 92       	push	r13
    23d0:	ef 92       	push	r14
    23d2:	ff 92       	push	r15
    23d4:	0f 93       	push	r16
    23d6:	1f 93       	push	r17
    23d8:	cf 93       	push	r28
    23da:	df 93       	push	r29
    23dc:	fc 01       	movw	r30, r24
    23de:	24 81       	ldd	r18, Z+4	; 0x04
    23e0:	21 11       	cpse	r18, r1
    23e2:	02 c0       	rjmp	.+4      	; 0x23e8 <sync_window+0x24>
    23e4:	80 e0       	ldi	r24, 0x00	; 0
    23e6:	40 c0       	rjmp	.+128    	; 0x2468 <sync_window+0xa4>
    23e8:	ec 01       	movw	r28, r24
    23ea:	c2 a4       	ldd	r12, Z+42	; 0x2a
    23ec:	d3 a4       	ldd	r13, Z+43	; 0x2b
    23ee:	e4 a4       	ldd	r14, Z+44	; 0x2c
    23f0:	f5 a4       	ldd	r15, Z+45	; 0x2d
    23f2:	5c 01       	movw	r10, r24
    23f4:	fe e2       	ldi	r31, 0x2E	; 46
    23f6:	af 0e       	add	r10, r31
    23f8:	b1 1c       	adc	r11, r1
    23fa:	01 e0       	ldi	r16, 0x01	; 1
    23fc:	10 e0       	ldi	r17, 0x00	; 0
    23fe:	a7 01       	movw	r20, r14
    2400:	96 01       	movw	r18, r12
    2402:	b5 01       	movw	r22, r10
    2404:	89 81       	ldd	r24, Y+1	; 0x01
    2406:	3b de       	rcall	.-906    	; 0x207e <disk_write>
    2408:	81 11       	cpse	r24, r1
    240a:	2d c0       	rjmp	.+90     	; 0x2466 <sync_window+0xa2>
    240c:	1c 82       	std	Y+4, r1	; 0x04
    240e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2410:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2412:	a8 a1       	ldd	r26, Y+32	; 0x20
    2414:	b9 a1       	ldd	r27, Y+33	; 0x21
    2416:	b7 01       	movw	r22, r14
    2418:	a6 01       	movw	r20, r12
    241a:	48 1b       	sub	r20, r24
    241c:	59 0b       	sbc	r21, r25
    241e:	6a 0b       	sbc	r22, r26
    2420:	7b 0b       	sbc	r23, r27
    2422:	8e 89       	ldd	r24, Y+22	; 0x16
    2424:	9f 89       	ldd	r25, Y+23	; 0x17
    2426:	a8 8d       	ldd	r26, Y+24	; 0x18
    2428:	b9 8d       	ldd	r27, Y+25	; 0x19
    242a:	48 17       	cp	r20, r24
    242c:	59 07       	cpc	r21, r25
    242e:	6a 07       	cpc	r22, r26
    2430:	7b 07       	cpc	r23, r27
    2432:	c0 f6       	brcc	.-80     	; 0x23e4 <sync_window+0x20>
    2434:	8b 80       	ldd	r8, Y+3	; 0x03
    2436:	91 2c       	mov	r9, r1
    2438:	e2 e0       	ldi	r30, 0x02	; 2
    243a:	8e 16       	cp	r8, r30
    243c:	91 04       	cpc	r9, r1
    243e:	90 f2       	brcs	.-92     	; 0x23e4 <sync_window+0x20>
    2440:	8e 89       	ldd	r24, Y+22	; 0x16
    2442:	9f 89       	ldd	r25, Y+23	; 0x17
    2444:	a8 8d       	ldd	r26, Y+24	; 0x18
    2446:	b9 8d       	ldd	r27, Y+25	; 0x19
    2448:	c8 0e       	add	r12, r24
    244a:	d9 1e       	adc	r13, r25
    244c:	ea 1e       	adc	r14, r26
    244e:	fb 1e       	adc	r15, r27
    2450:	01 e0       	ldi	r16, 0x01	; 1
    2452:	10 e0       	ldi	r17, 0x00	; 0
    2454:	a7 01       	movw	r20, r14
    2456:	96 01       	movw	r18, r12
    2458:	b5 01       	movw	r22, r10
    245a:	89 81       	ldd	r24, Y+1	; 0x01
    245c:	10 de       	rcall	.-992    	; 0x207e <disk_write>
    245e:	81 e0       	ldi	r24, 0x01	; 1
    2460:	88 1a       	sub	r8, r24
    2462:	91 08       	sbc	r9, r1
    2464:	e9 cf       	rjmp	.-46     	; 0x2438 <sync_window+0x74>
    2466:	81 e0       	ldi	r24, 0x01	; 1
    2468:	df 91       	pop	r29
    246a:	cf 91       	pop	r28
    246c:	1f 91       	pop	r17
    246e:	0f 91       	pop	r16
    2470:	ff 90       	pop	r15
    2472:	ef 90       	pop	r14
    2474:	df 90       	pop	r13
    2476:	cf 90       	pop	r12
    2478:	bf 90       	pop	r11
    247a:	af 90       	pop	r10
    247c:	9f 90       	pop	r9
    247e:	8f 90       	pop	r8
    2480:	08 95       	ret

00002482 <sync_fs>:
    2482:	0f 93       	push	r16
    2484:	1f 93       	push	r17
    2486:	cf 93       	push	r28
    2488:	df 93       	push	r29
    248a:	ec 01       	movw	r28, r24
    248c:	9b df       	rcall	.-202    	; 0x23c4 <sync_window>
    248e:	98 2f       	mov	r25, r24
    2490:	81 11       	cpse	r24, r1
    2492:	5a c0       	rjmp	.+180    	; 0x2548 <sync_fs+0xc6>
    2494:	88 81       	ld	r24, Y
    2496:	83 30       	cpi	r24, 0x03	; 3
    2498:	09 f0       	breq	.+2      	; 0x249c <sync_fs+0x1a>
    249a:	4d c0       	rjmp	.+154    	; 0x2536 <sync_fs+0xb4>
    249c:	8d 81       	ldd	r24, Y+5	; 0x05
    249e:	81 30       	cpi	r24, 0x01	; 1
    24a0:	09 f0       	breq	.+2      	; 0x24a4 <sync_fs+0x22>
    24a2:	49 c0       	rjmp	.+146    	; 0x2536 <sync_fs+0xb4>
    24a4:	be 01       	movw	r22, r28
    24a6:	62 5d       	subi	r22, 0xD2	; 210
    24a8:	7f 4f       	sbci	r23, 0xFF	; 255
    24aa:	fb 01       	movw	r30, r22
    24ac:	ce 01       	movw	r24, r28
    24ae:	82 5d       	subi	r24, 0xD2	; 210
    24b0:	9d 4f       	sbci	r25, 0xFD	; 253
    24b2:	e8 17       	cp	r30, r24
    24b4:	f9 07       	cpc	r31, r25
    24b6:	11 f0       	breq	.+4      	; 0x24bc <sync_fs+0x3a>
    24b8:	11 92       	st	Z+, r1
    24ba:	fb cf       	rjmp	.-10     	; 0x24b2 <sync_fs+0x30>
    24bc:	85 e5       	ldi	r24, 0x55	; 85
    24be:	9a ea       	ldi	r25, 0xAA	; 170
    24c0:	fe 01       	movw	r30, r28
    24c2:	e4 5d       	subi	r30, 0xD4	; 212
    24c4:	fd 4f       	sbci	r31, 0xFD	; 253
    24c6:	91 83       	std	Z+1, r25	; 0x01
    24c8:	80 83       	st	Z, r24
    24ca:	82 e5       	ldi	r24, 0x52	; 82
    24cc:	92 e5       	ldi	r25, 0x52	; 82
    24ce:	a1 e6       	ldi	r26, 0x61	; 97
    24d0:	b1 e4       	ldi	r27, 0x41	; 65
    24d2:	8e a7       	std	Y+46, r24	; 0x2e
    24d4:	9f a7       	std	Y+47, r25	; 0x2f
    24d6:	a8 ab       	std	Y+48, r26	; 0x30
    24d8:	b9 ab       	std	Y+49, r27	; 0x31
    24da:	82 e7       	ldi	r24, 0x72	; 114
    24dc:	92 e7       	ldi	r25, 0x72	; 114
    24de:	a1 e4       	ldi	r26, 0x41	; 65
    24e0:	b1 e6       	ldi	r27, 0x61	; 97
    24e2:	7a 97       	sbiw	r30, 0x1a	; 26
    24e4:	80 83       	st	Z, r24
    24e6:	91 83       	std	Z+1, r25	; 0x01
    24e8:	a2 83       	std	Z+2, r26	; 0x02
    24ea:	b3 83       	std	Z+3, r27	; 0x03
    24ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    24ee:	9f 85       	ldd	r25, Y+15	; 0x0f
    24f0:	a8 89       	ldd	r26, Y+16	; 0x10
    24f2:	b9 89       	ldd	r27, Y+17	; 0x11
    24f4:	34 96       	adiw	r30, 0x04	; 4
    24f6:	80 83       	st	Z, r24
    24f8:	91 83       	std	Z+1, r25	; 0x01
    24fa:	a2 83       	std	Z+2, r26	; 0x02
    24fc:	b3 83       	std	Z+3, r27	; 0x03
    24fe:	8a 85       	ldd	r24, Y+10	; 0x0a
    2500:	9b 85       	ldd	r25, Y+11	; 0x0b
    2502:	ac 85       	ldd	r26, Y+12	; 0x0c
    2504:	bd 85       	ldd	r27, Y+13	; 0x0d
    2506:	34 96       	adiw	r30, 0x04	; 4
    2508:	80 83       	st	Z, r24
    250a:	91 83       	std	Z+1, r25	; 0x01
    250c:	a2 83       	std	Z+2, r26	; 0x02
    250e:	b3 83       	std	Z+3, r27	; 0x03
    2510:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2512:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2514:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2516:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2518:	9c 01       	movw	r18, r24
    251a:	ad 01       	movw	r20, r26
    251c:	2f 5f       	subi	r18, 0xFF	; 255
    251e:	3f 4f       	sbci	r19, 0xFF	; 255
    2520:	4f 4f       	sbci	r20, 0xFF	; 255
    2522:	5f 4f       	sbci	r21, 0xFF	; 255
    2524:	2a a7       	std	Y+42, r18	; 0x2a
    2526:	3b a7       	std	Y+43, r19	; 0x2b
    2528:	4c a7       	std	Y+44, r20	; 0x2c
    252a:	5d a7       	std	Y+45, r21	; 0x2d
    252c:	01 e0       	ldi	r16, 0x01	; 1
    252e:	10 e0       	ldi	r17, 0x00	; 0
    2530:	89 81       	ldd	r24, Y+1	; 0x01
    2532:	a5 dd       	rcall	.-1206   	; 0x207e <disk_write>
    2534:	1d 82       	std	Y+5, r1	; 0x05
    2536:	40 e0       	ldi	r20, 0x00	; 0
    2538:	50 e0       	ldi	r21, 0x00	; 0
    253a:	60 e0       	ldi	r22, 0x00	; 0
    253c:	89 81       	ldd	r24, Y+1	; 0x01
    253e:	ff dd       	rcall	.-1026   	; 0x213e <disk_ioctl>
    2540:	91 e0       	ldi	r25, 0x01	; 1
    2542:	81 11       	cpse	r24, r1
    2544:	01 c0       	rjmp	.+2      	; 0x2548 <sync_fs+0xc6>
    2546:	90 e0       	ldi	r25, 0x00	; 0
    2548:	89 2f       	mov	r24, r25
    254a:	df 91       	pop	r29
    254c:	cf 91       	pop	r28
    254e:	1f 91       	pop	r17
    2550:	0f 91       	pop	r16
    2552:	08 95       	ret

00002554 <move_window>:
    2554:	8f 92       	push	r8
    2556:	9f 92       	push	r9
    2558:	af 92       	push	r10
    255a:	bf 92       	push	r11
    255c:	ff 92       	push	r15
    255e:	0f 93       	push	r16
    2560:	1f 93       	push	r17
    2562:	cf 93       	push	r28
    2564:	df 93       	push	r29
    2566:	ec 01       	movw	r28, r24
    2568:	4a 01       	movw	r8, r20
    256a:	5b 01       	movw	r10, r22
    256c:	8a a5       	ldd	r24, Y+42	; 0x2a
    256e:	9b a5       	ldd	r25, Y+43	; 0x2b
    2570:	ac a5       	ldd	r26, Y+44	; 0x2c
    2572:	bd a5       	ldd	r27, Y+45	; 0x2d
    2574:	48 17       	cp	r20, r24
    2576:	59 07       	cpc	r21, r25
    2578:	6a 07       	cpc	r22, r26
    257a:	7b 07       	cpc	r23, r27
    257c:	d9 f0       	breq	.+54     	; 0x25b4 <move_window+0x60>
    257e:	ce 01       	movw	r24, r28
    2580:	21 df       	rcall	.-446    	; 0x23c4 <sync_window>
    2582:	f8 2e       	mov	r15, r24
    2584:	81 11       	cpse	r24, r1
    2586:	17 c0       	rjmp	.+46     	; 0x25b6 <move_window+0x62>
    2588:	01 e0       	ldi	r16, 0x01	; 1
    258a:	10 e0       	ldi	r17, 0x00	; 0
    258c:	a5 01       	movw	r20, r10
    258e:	94 01       	movw	r18, r8
    2590:	be 01       	movw	r22, r28
    2592:	62 5d       	subi	r22, 0xD2	; 210
    2594:	7f 4f       	sbci	r23, 0xFF	; 255
    2596:	89 81       	ldd	r24, Y+1	; 0x01
    2598:	2e dd       	rcall	.-1444   	; 0x1ff6 <disk_read>
    259a:	88 23       	and	r24, r24
    259c:	31 f0       	breq	.+12     	; 0x25aa <move_window+0x56>
    259e:	ff 24       	eor	r15, r15
    25a0:	f3 94       	inc	r15
    25a2:	88 24       	eor	r8, r8
    25a4:	8a 94       	dec	r8
    25a6:	98 2c       	mov	r9, r8
    25a8:	54 01       	movw	r10, r8
    25aa:	8a a6       	std	Y+42, r8	; 0x2a
    25ac:	9b a6       	std	Y+43, r9	; 0x2b
    25ae:	ac a6       	std	Y+44, r10	; 0x2c
    25b0:	bd a6       	std	Y+45, r11	; 0x2d
    25b2:	01 c0       	rjmp	.+2      	; 0x25b6 <move_window+0x62>
    25b4:	f1 2c       	mov	r15, r1
    25b6:	8f 2d       	mov	r24, r15
    25b8:	df 91       	pop	r29
    25ba:	cf 91       	pop	r28
    25bc:	1f 91       	pop	r17
    25be:	0f 91       	pop	r16
    25c0:	ff 90       	pop	r15
    25c2:	bf 90       	pop	r11
    25c4:	af 90       	pop	r10
    25c6:	9f 90       	pop	r9
    25c8:	8f 90       	pop	r8
    25ca:	08 95       	ret

000025cc <check_fs>:
    25cc:	cf 93       	push	r28
    25ce:	df 93       	push	r29
    25d0:	ec 01       	movw	r28, r24
    25d2:	1c 82       	std	Y+4, r1	; 0x04
    25d4:	8f ef       	ldi	r24, 0xFF	; 255
    25d6:	9f ef       	ldi	r25, 0xFF	; 255
    25d8:	dc 01       	movw	r26, r24
    25da:	8a a7       	std	Y+42, r24	; 0x2a
    25dc:	9b a7       	std	Y+43, r25	; 0x2b
    25de:	ac a7       	std	Y+44, r26	; 0x2c
    25e0:	bd a7       	std	Y+45, r27	; 0x2d
    25e2:	ce 01       	movw	r24, r28
    25e4:	b7 df       	rcall	.-146    	; 0x2554 <move_window>
    25e6:	81 11       	cpse	r24, r1
    25e8:	22 c0       	rjmp	.+68     	; 0x262e <check_fs+0x62>
    25ea:	fe 01       	movw	r30, r28
    25ec:	e4 5d       	subi	r30, 0xD4	; 212
    25ee:	fd 4f       	sbci	r31, 0xFD	; 253
    25f0:	80 81       	ld	r24, Z
    25f2:	91 81       	ldd	r25, Z+1	; 0x01
    25f4:	85 35       	cpi	r24, 0x55	; 85
    25f6:	9a 4a       	sbci	r25, 0xAA	; 170
    25f8:	e1 f4       	brne	.+56     	; 0x2632 <check_fs+0x66>
    25fa:	e8 5c       	subi	r30, 0xC8	; 200
    25fc:	f1 40       	sbci	r31, 0x01	; 1
    25fe:	80 81       	ld	r24, Z
    2600:	91 81       	ldd	r25, Z+1	; 0x01
    2602:	a2 81       	ldd	r26, Z+2	; 0x02
    2604:	b3 81       	ldd	r27, Z+3	; 0x03
    2606:	bb 27       	eor	r27, r27
    2608:	86 34       	cpi	r24, 0x46	; 70
    260a:	91 44       	sbci	r25, 0x41	; 65
    260c:	a4 45       	sbci	r26, 0x54	; 84
    260e:	b1 05       	cpc	r27, r1
    2610:	91 f0       	breq	.+36     	; 0x2636 <check_fs+0x6a>
    2612:	c0 58       	subi	r28, 0x80	; 128
    2614:	df 4f       	sbci	r29, 0xFF	; 255
    2616:	48 81       	ld	r20, Y
    2618:	59 81       	ldd	r21, Y+1	; 0x01
    261a:	6a 81       	ldd	r22, Y+2	; 0x02
    261c:	7b 81       	ldd	r23, Y+3	; 0x03
    261e:	77 27       	eor	r23, r23
    2620:	81 e0       	ldi	r24, 0x01	; 1
    2622:	46 34       	cpi	r20, 0x46	; 70
    2624:	51 44       	sbci	r21, 0x41	; 65
    2626:	64 45       	sbci	r22, 0x54	; 84
    2628:	71 05       	cpc	r23, r1
    262a:	31 f4       	brne	.+12     	; 0x2638 <check_fs+0x6c>
    262c:	04 c0       	rjmp	.+8      	; 0x2636 <check_fs+0x6a>
    262e:	83 e0       	ldi	r24, 0x03	; 3
    2630:	03 c0       	rjmp	.+6      	; 0x2638 <check_fs+0x6c>
    2632:	82 e0       	ldi	r24, 0x02	; 2
    2634:	01 c0       	rjmp	.+2      	; 0x2638 <check_fs+0x6c>
    2636:	80 e0       	ldi	r24, 0x00	; 0
    2638:	df 91       	pop	r29
    263a:	cf 91       	pop	r28
    263c:	08 95       	ret

0000263e <find_volume>:
    263e:	2f 92       	push	r2
    2640:	3f 92       	push	r3
    2642:	4f 92       	push	r4
    2644:	5f 92       	push	r5
    2646:	6f 92       	push	r6
    2648:	7f 92       	push	r7
    264a:	8f 92       	push	r8
    264c:	9f 92       	push	r9
    264e:	af 92       	push	r10
    2650:	bf 92       	push	r11
    2652:	cf 92       	push	r12
    2654:	df 92       	push	r13
    2656:	ef 92       	push	r14
    2658:	ff 92       	push	r15
    265a:	0f 93       	push	r16
    265c:	1f 93       	push	r17
    265e:	cf 93       	push	r28
    2660:	df 93       	push	r29
    2662:	cd b7       	in	r28, 0x3d	; 61
    2664:	de b7       	in	r29, 0x3e	; 62
    2666:	6d 97       	sbiw	r28, 0x1d	; 29
    2668:	0f b6       	in	r0, 0x3f	; 63
    266a:	f8 94       	cli
    266c:	de bf       	out	0x3e, r29	; 62
    266e:	0f be       	out	0x3f, r0	; 63
    2670:	cd bf       	out	0x3d, r28	; 61
    2672:	5c 01       	movw	r10, r24
    2674:	cb 01       	movw	r24, r22
    2676:	d4 2e       	mov	r13, r20
    2678:	d5 01       	movw	r26, r10
    267a:	1d 92       	st	X+, r1
    267c:	1c 92       	st	X, r1
    267e:	65 de       	rcall	.-822    	; 0x234a <get_ldnumber>
    2680:	7c 01       	movw	r14, r24
    2682:	97 fd       	sbrc	r25, 7
    2684:	18 c2       	rjmp	.+1072   	; 0x2ab6 <find_volume+0x478>
    2686:	fc 01       	movw	r30, r24
    2688:	ee 0f       	add	r30, r30
    268a:	ff 1f       	adc	r31, r31
    268c:	ec 55       	subi	r30, 0x5C	; 92
    268e:	fa 4f       	sbci	r31, 0xFA	; 250
    2690:	00 81       	ld	r16, Z
    2692:	11 81       	ldd	r17, Z+1	; 0x01
    2694:	01 15       	cp	r16, r1
    2696:	11 05       	cpc	r17, r1
    2698:	09 f4       	brne	.+2      	; 0x269c <find_volume+0x5e>
    269a:	0f c2       	rjmp	.+1054   	; 0x2aba <find_volume+0x47c>
    269c:	f5 01       	movw	r30, r10
    269e:	11 83       	std	Z+1, r17	; 0x01
    26a0:	00 83       	st	Z, r16
    26a2:	d8 01       	movw	r26, r16
    26a4:	8c 91       	ld	r24, X
    26a6:	88 23       	and	r24, r24
    26a8:	61 f0       	breq	.+24     	; 0x26c2 <find_volume+0x84>
    26aa:	11 96       	adiw	r26, 0x01	; 1
    26ac:	8c 91       	ld	r24, X
    26ae:	fe db       	rcall	.-2052   	; 0x1eac <disk_status>
    26b0:	80 fd       	sbrc	r24, 0
    26b2:	07 c0       	rjmp	.+14     	; 0x26c2 <find_volume+0x84>
    26b4:	dd 20       	and	r13, r13
    26b6:	09 f4       	brne	.+2      	; 0x26ba <find_volume+0x7c>
    26b8:	02 c2       	rjmp	.+1028   	; 0x2abe <find_volume+0x480>
    26ba:	82 ff       	sbrs	r24, 2
    26bc:	00 c2       	rjmp	.+1024   	; 0x2abe <find_volume+0x480>
    26be:	8a e0       	ldi	r24, 0x0A	; 10
    26c0:	03 c2       	rjmp	.+1030   	; 0x2ac8 <find_volume+0x48a>
    26c2:	f8 01       	movw	r30, r16
    26c4:	10 82       	st	Z, r1
    26c6:	e1 82       	std	Z+1, r14	; 0x01
    26c8:	8e 2d       	mov	r24, r14
    26ca:	f7 db       	rcall	.-2066   	; 0x1eba <disk_initialize>
    26cc:	80 fd       	sbrc	r24, 0
    26ce:	f9 c1       	rjmp	.+1010   	; 0x2ac2 <find_volume+0x484>
    26d0:	dd 20       	and	r13, r13
    26d2:	11 f0       	breq	.+4      	; 0x26d8 <find_volume+0x9a>
    26d4:	82 fd       	sbrc	r24, 2
    26d6:	f3 cf       	rjmp	.-26     	; 0x26be <find_volume+0x80>
    26d8:	40 e0       	ldi	r20, 0x00	; 0
    26da:	50 e0       	ldi	r21, 0x00	; 0
    26dc:	ba 01       	movw	r22, r20
    26de:	c8 01       	movw	r24, r16
    26e0:	75 df       	rcall	.-278    	; 0x25cc <check_fs>
    26e2:	81 30       	cpi	r24, 0x01	; 1
    26e4:	c9 f5       	brne	.+114    	; 0x2758 <find_volume+0x11a>
    26e6:	f8 01       	movw	r30, r16
    26e8:	e0 51       	subi	r30, 0x10	; 16
    26ea:	fe 4f       	sbci	r31, 0xFE	; 254
    26ec:	9e 01       	movw	r18, r28
    26ee:	2f 5f       	subi	r18, 0xFF	; 255
    26f0:	3f 4f       	sbci	r19, 0xFF	; 255
    26f2:	69 01       	movw	r12, r18
    26f4:	c8 01       	movw	r24, r16
    26f6:	80 5d       	subi	r24, 0xD0	; 208
    26f8:	9d 4f       	sbci	r25, 0xFD	; 253
    26fa:	d9 01       	movw	r26, r18
    26fc:	20 81       	ld	r18, Z
    26fe:	22 23       	and	r18, r18
    2700:	29 f0       	breq	.+10     	; 0x270c <find_volume+0xce>
    2702:	44 81       	ldd	r20, Z+4	; 0x04
    2704:	55 81       	ldd	r21, Z+5	; 0x05
    2706:	66 81       	ldd	r22, Z+6	; 0x06
    2708:	77 81       	ldd	r23, Z+7	; 0x07
    270a:	03 c0       	rjmp	.+6      	; 0x2712 <find_volume+0xd4>
    270c:	40 e0       	ldi	r20, 0x00	; 0
    270e:	50 e0       	ldi	r21, 0x00	; 0
    2710:	ba 01       	movw	r22, r20
    2712:	4d 93       	st	X+, r20
    2714:	5d 93       	st	X+, r21
    2716:	6d 93       	st	X+, r22
    2718:	7d 93       	st	X+, r23
    271a:	70 96       	adiw	r30, 0x10	; 16
    271c:	e8 17       	cp	r30, r24
    271e:	f9 07       	cpc	r31, r25
    2720:	69 f7       	brne	.-38     	; 0x26fc <find_volume+0xbe>
    2722:	7e 01       	movw	r14, r28
    2724:	31 e1       	ldi	r19, 0x11	; 17
    2726:	e3 0e       	add	r14, r19
    2728:	f1 1c       	adc	r15, r1
    272a:	d6 01       	movw	r26, r12
    272c:	4d 90       	ld	r4, X+
    272e:	5d 90       	ld	r5, X+
    2730:	6d 90       	ld	r6, X+
    2732:	7d 90       	ld	r7, X+
    2734:	6d 01       	movw	r12, r26
    2736:	41 14       	cp	r4, r1
    2738:	51 04       	cpc	r5, r1
    273a:	61 04       	cpc	r6, r1
    273c:	71 04       	cpc	r7, r1
    273e:	39 f0       	breq	.+14     	; 0x274e <find_volume+0x110>
    2740:	b3 01       	movw	r22, r6
    2742:	a2 01       	movw	r20, r4
    2744:	c8 01       	movw	r24, r16
    2746:	42 df       	rcall	.-380    	; 0x25cc <check_fs>
    2748:	81 11       	cpse	r24, r1
    274a:	02 c0       	rjmp	.+4      	; 0x2750 <find_volume+0x112>
    274c:	0f c0       	rjmp	.+30     	; 0x276c <find_volume+0x12e>
    274e:	82 e0       	ldi	r24, 0x02	; 2
    2750:	ce 14       	cp	r12, r14
    2752:	df 04       	cpc	r13, r15
    2754:	51 f7       	brne	.-44     	; 0x272a <find_volume+0xec>
    2756:	03 c0       	rjmp	.+6      	; 0x275e <find_volume+0x120>
    2758:	41 2c       	mov	r4, r1
    275a:	51 2c       	mov	r5, r1
    275c:	32 01       	movw	r6, r4
    275e:	83 30       	cpi	r24, 0x03	; 3
    2760:	09 f4       	brne	.+2      	; 0x2764 <find_volume+0x126>
    2762:	b1 c1       	rjmp	.+866    	; 0x2ac6 <find_volume+0x488>
    2764:	88 23       	and	r24, r24
    2766:	11 f0       	breq	.+4      	; 0x276c <find_volume+0x12e>
    2768:	8d e0       	ldi	r24, 0x0D	; 13
    276a:	ae c1       	rjmp	.+860    	; 0x2ac8 <find_volume+0x48a>
    276c:	f8 01       	movw	r30, r16
    276e:	81 ad       	ldd	r24, Z+57	; 0x39
    2770:	92 ad       	ldd	r25, Z+58	; 0x3a
    2772:	81 15       	cp	r24, r1
    2774:	92 40       	sbci	r25, 0x02	; 2
    2776:	c1 f7       	brne	.-16     	; 0x2768 <find_volume+0x12a>
    2778:	f8 01       	movw	r30, r16
    277a:	ec 5b       	subi	r30, 0xBC	; 188
    277c:	ff 4f       	sbci	r31, 0xFF	; 255
    277e:	80 80       	ld	r8, Z
    2780:	91 80       	ldd	r9, Z+1	; 0x01
    2782:	a1 2c       	mov	r10, r1
    2784:	b1 2c       	mov	r11, r1
    2786:	81 14       	cp	r8, r1
    2788:	91 04       	cpc	r9, r1
    278a:	a1 04       	cpc	r10, r1
    278c:	b1 04       	cpc	r11, r1
    278e:	29 f4       	brne	.+10     	; 0x279a <find_volume+0x15c>
    2790:	3e 96       	adiw	r30, 0x0e	; 14
    2792:	80 80       	ld	r8, Z
    2794:	91 80       	ldd	r9, Z+1	; 0x01
    2796:	a2 80       	ldd	r10, Z+2	; 0x02
    2798:	b3 80       	ldd	r11, Z+3	; 0x03
    279a:	d8 01       	movw	r26, r16
    279c:	56 96       	adiw	r26, 0x16	; 22
    279e:	8d 92       	st	X+, r8
    27a0:	9d 92       	st	X+, r9
    27a2:	ad 92       	st	X+, r10
    27a4:	bc 92       	st	X, r11
    27a6:	59 97       	sbiw	r26, 0x19	; 25
    27a8:	de 96       	adiw	r26, 0x3e	; 62
    27aa:	4c 91       	ld	r20, X
    27ac:	de 97       	sbiw	r26, 0x3e	; 62
    27ae:	13 96       	adiw	r26, 0x03	; 3
    27b0:	4c 93       	st	X, r20
    27b2:	13 97       	sbiw	r26, 0x03	; 3
    27b4:	8f ef       	ldi	r24, 0xFF	; 255
    27b6:	84 0f       	add	r24, r20
    27b8:	82 30       	cpi	r24, 0x02	; 2
    27ba:	b0 f6       	brcc	.-84     	; 0x2768 <find_volume+0x12a>
    27bc:	db 96       	adiw	r26, 0x3b	; 59
    27be:	ec 91       	ld	r30, X
    27c0:	db 97       	sbiw	r26, 0x3b	; 59
    27c2:	e9 8b       	std	Y+17, r30	; 0x11
    27c4:	12 96       	adiw	r26, 0x02	; 2
    27c6:	ec 93       	st	X, r30
    27c8:	12 97       	sbiw	r26, 0x02	; 2
    27ca:	ee 23       	and	r30, r30
    27cc:	69 f2       	breq	.-102    	; 0x2768 <find_volume+0x12a>
    27ce:	8e 2f       	mov	r24, r30
    27d0:	90 e0       	ldi	r25, 0x00	; 0
    27d2:	9c 01       	movw	r18, r24
    27d4:	21 50       	subi	r18, 0x01	; 1
    27d6:	31 09       	sbc	r19, r1
    27d8:	82 23       	and	r24, r18
    27da:	93 23       	and	r25, r19
    27dc:	89 2b       	or	r24, r25
    27de:	21 f6       	brne	.-120    	; 0x2768 <find_volume+0x12a>
    27e0:	f8 01       	movw	r30, r16
    27e2:	ff 96       	adiw	r30, 0x3f	; 63
    27e4:	20 80       	ld	r2, Z
    27e6:	31 80       	ldd	r3, Z+1	; 0x01
    27e8:	19 96       	adiw	r26, 0x09	; 9
    27ea:	3c 92       	st	X, r3
    27ec:	2e 92       	st	-X, r2
    27ee:	18 97       	sbiw	r26, 0x08	; 8
    27f0:	c1 01       	movw	r24, r2
    27f2:	8f 70       	andi	r24, 0x0F	; 15
    27f4:	99 27       	eor	r25, r25
    27f6:	89 2b       	or	r24, r25
    27f8:	09 f0       	breq	.+2      	; 0x27fc <find_volume+0x1be>
    27fa:	b6 cf       	rjmp	.-148    	; 0x2768 <find_volume+0x12a>
    27fc:	32 96       	adiw	r30, 0x02	; 2
    27fe:	c0 80       	ld	r12, Z
    2800:	d1 80       	ldd	r13, Z+1	; 0x01
    2802:	e1 2c       	mov	r14, r1
    2804:	f1 2c       	mov	r15, r1
    2806:	c1 14       	cp	r12, r1
    2808:	d1 04       	cpc	r13, r1
    280a:	e1 04       	cpc	r14, r1
    280c:	f1 04       	cpc	r15, r1
    280e:	29 f4       	brne	.+10     	; 0x281a <find_volume+0x1dc>
    2810:	3d 96       	adiw	r30, 0x0d	; 13
    2812:	c0 80       	ld	r12, Z
    2814:	d1 80       	ldd	r13, Z+1	; 0x01
    2816:	e2 80       	ldd	r14, Z+2	; 0x02
    2818:	f3 80       	ldd	r15, Z+3	; 0x03
    281a:	d8 01       	movw	r26, r16
    281c:	dc 96       	adiw	r26, 0x3c	; 60
    281e:	ed 91       	ld	r30, X+
    2820:	fc 91       	ld	r31, X
    2822:	dd 97       	sbiw	r26, 0x3d	; 61
    2824:	30 97       	sbiw	r30, 0x00	; 0
    2826:	09 f4       	brne	.+2      	; 0x282a <find_volume+0x1ec>
    2828:	9f cf       	rjmp	.-194    	; 0x2768 <find_volume+0x12a>
    282a:	a4 2f       	mov	r26, r20
    282c:	b0 e0       	ldi	r27, 0x00	; 0
    282e:	a5 01       	movw	r20, r10
    2830:	94 01       	movw	r18, r8
    2832:	0e 94 9c 35 	call	0x6b38	; 0x6b38 <__muluhisi3>
    2836:	6e 8b       	std	Y+22, r22	; 0x16
    2838:	7f 8b       	std	Y+23, r23	; 0x17
    283a:	88 8f       	std	Y+24, r24	; 0x18
    283c:	99 8f       	std	Y+25, r25	; 0x19
    283e:	9f 01       	movw	r18, r30
    2840:	40 e0       	ldi	r20, 0x00	; 0
    2842:	50 e0       	ldi	r21, 0x00	; 0
    2844:	2a 8f       	std	Y+26, r18	; 0x1a
    2846:	3b 8f       	std	Y+27, r19	; 0x1b
    2848:	4c 8f       	std	Y+28, r20	; 0x1c
    284a:	5d 8f       	std	Y+29, r21	; 0x1d
    284c:	c1 01       	movw	r24, r2
    284e:	64 e0       	ldi	r22, 0x04	; 4
    2850:	96 95       	lsr	r25
    2852:	87 95       	ror	r24
    2854:	6a 95       	dec	r22
    2856:	e1 f7       	brne	.-8      	; 0x2850 <find_volume+0x212>
    2858:	28 0f       	add	r18, r24
    285a:	39 1f       	adc	r19, r25
    285c:	41 1d       	adc	r20, r1
    285e:	51 1d       	adc	r21, r1
    2860:	da 01       	movw	r26, r20
    2862:	c9 01       	movw	r24, r18
    2864:	2e 89       	ldd	r18, Y+22	; 0x16
    2866:	3f 89       	ldd	r19, Y+23	; 0x17
    2868:	48 8d       	ldd	r20, Y+24	; 0x18
    286a:	59 8d       	ldd	r21, Y+25	; 0x19
    286c:	28 0f       	add	r18, r24
    286e:	39 1f       	adc	r19, r25
    2870:	4a 1f       	adc	r20, r26
    2872:	5b 1f       	adc	r21, r27
    2874:	2a 8b       	std	Y+18, r18	; 0x12
    2876:	3b 8b       	std	Y+19, r19	; 0x13
    2878:	4c 8b       	std	Y+20, r20	; 0x14
    287a:	5d 8b       	std	Y+21, r21	; 0x15
    287c:	c2 16       	cp	r12, r18
    287e:	d3 06       	cpc	r13, r19
    2880:	e4 06       	cpc	r14, r20
    2882:	f5 06       	cpc	r15, r21
    2884:	08 f4       	brcc	.+2      	; 0x2888 <find_volume+0x24a>
    2886:	70 cf       	rjmp	.-288    	; 0x2768 <find_volume+0x12a>
    2888:	c7 01       	movw	r24, r14
    288a:	b6 01       	movw	r22, r12
    288c:	62 1b       	sub	r22, r18
    288e:	73 0b       	sbc	r23, r19
    2890:	84 0b       	sbc	r24, r20
    2892:	95 0b       	sbc	r25, r21
    2894:	e9 89       	ldd	r30, Y+17	; 0x11
    2896:	2e 2f       	mov	r18, r30
    2898:	30 e0       	ldi	r19, 0x00	; 0
    289a:	40 e0       	ldi	r20, 0x00	; 0
    289c:	50 e0       	ldi	r21, 0x00	; 0
    289e:	0e 94 7a 35 	call	0x6af4	; 0x6af4 <__udivmodsi4>
    28a2:	21 15       	cp	r18, r1
    28a4:	31 05       	cpc	r19, r1
    28a6:	41 05       	cpc	r20, r1
    28a8:	51 05       	cpc	r21, r1
    28aa:	09 f4       	brne	.+2      	; 0x28ae <find_volume+0x270>
    28ac:	5d cf       	rjmp	.-326    	; 0x2768 <find_volume+0x12a>
    28ae:	26 3f       	cpi	r18, 0xF6	; 246
    28b0:	ff e0       	ldi	r31, 0x0F	; 15
    28b2:	3f 07       	cpc	r19, r31
    28b4:	41 05       	cpc	r20, r1
    28b6:	51 05       	cpc	r21, r1
    28b8:	48 f0       	brcs	.+18     	; 0x28cc <find_volume+0x28e>
    28ba:	26 3f       	cpi	r18, 0xF6	; 246
    28bc:	8f ef       	ldi	r24, 0xFF	; 255
    28be:	38 07       	cpc	r19, r24
    28c0:	41 05       	cpc	r20, r1
    28c2:	51 05       	cpc	r21, r1
    28c4:	30 f4       	brcc	.+12     	; 0x28d2 <find_volume+0x294>
    28c6:	92 e0       	ldi	r25, 0x02	; 2
    28c8:	99 8b       	std	Y+17, r25	; 0x11
    28ca:	05 c0       	rjmp	.+10     	; 0x28d6 <find_volume+0x298>
    28cc:	a1 e0       	ldi	r26, 0x01	; 1
    28ce:	a9 8b       	std	Y+17, r26	; 0x11
    28d0:	02 c0       	rjmp	.+4      	; 0x28d6 <find_volume+0x298>
    28d2:	b3 e0       	ldi	r27, 0x03	; 3
    28d4:	b9 8b       	std	Y+17, r27	; 0x11
    28d6:	69 01       	movw	r12, r18
    28d8:	7a 01       	movw	r14, r20
    28da:	e2 e0       	ldi	r30, 0x02	; 2
    28dc:	ce 0e       	add	r12, r30
    28de:	d1 1c       	adc	r13, r1
    28e0:	e1 1c       	adc	r14, r1
    28e2:	f1 1c       	adc	r15, r1
    28e4:	d8 01       	movw	r26, r16
    28e6:	52 96       	adiw	r26, 0x12	; 18
    28e8:	cd 92       	st	X+, r12
    28ea:	dd 92       	st	X+, r13
    28ec:	ed 92       	st	X+, r14
    28ee:	fc 92       	st	X, r15
    28f0:	55 97       	sbiw	r26, 0x15	; 21
    28f2:	f8 01       	movw	r30, r16
    28f4:	42 8e       	std	Z+26, r4	; 0x1a
    28f6:	53 8e       	std	Z+27, r5	; 0x1b
    28f8:	64 8e       	std	Z+28, r6	; 0x1c
    28fa:	75 8e       	std	Z+29, r7	; 0x1d
    28fc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    28fe:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2900:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2902:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2904:	84 0d       	add	r24, r4
    2906:	95 1d       	adc	r25, r5
    2908:	a6 1d       	adc	r26, r6
    290a:	b7 1d       	adc	r27, r7
    290c:	86 8f       	std	Z+30, r24	; 0x1e
    290e:	97 8f       	std	Z+31, r25	; 0x1f
    2910:	a0 a3       	std	Z+32, r26	; 0x20
    2912:	b1 a3       	std	Z+33, r27	; 0x21
    2914:	4a 89       	ldd	r20, Y+18	; 0x12
    2916:	5b 89       	ldd	r21, Y+19	; 0x13
    2918:	6c 89       	ldd	r22, Y+20	; 0x14
    291a:	7d 89       	ldd	r23, Y+21	; 0x15
    291c:	44 0d       	add	r20, r4
    291e:	55 1d       	adc	r21, r5
    2920:	66 1d       	adc	r22, r6
    2922:	77 1d       	adc	r23, r7
    2924:	46 a3       	std	Z+38, r20	; 0x26
    2926:	57 a3       	std	Z+39, r21	; 0x27
    2928:	60 a7       	std	Z+40, r22	; 0x28
    292a:	71 a7       	std	Z+41, r23	; 0x29
    292c:	f9 89       	ldd	r31, Y+17	; 0x11
    292e:	f3 30       	cpi	r31, 0x03	; 3
    2930:	b9 f4       	brne	.+46     	; 0x2960 <find_volume+0x322>
    2932:	23 28       	or	r2, r3
    2934:	09 f0       	breq	.+2      	; 0x2938 <find_volume+0x2fa>
    2936:	18 cf       	rjmp	.-464    	; 0x2768 <find_volume+0x12a>
    2938:	f8 01       	movw	r30, r16
    293a:	e6 5a       	subi	r30, 0xA6	; 166
    293c:	ff 4f       	sbci	r31, 0xFF	; 255
    293e:	80 81       	ld	r24, Z
    2940:	91 81       	ldd	r25, Z+1	; 0x01
    2942:	a2 81       	ldd	r26, Z+2	; 0x02
    2944:	b3 81       	ldd	r27, Z+3	; 0x03
    2946:	f8 01       	movw	r30, r16
    2948:	82 a3       	std	Z+34, r24	; 0x22
    294a:	93 a3       	std	Z+35, r25	; 0x23
    294c:	a4 a3       	std	Z+36, r26	; 0x24
    294e:	b5 a3       	std	Z+37, r27	; 0x25
    2950:	42 e0       	ldi	r20, 0x02	; 2
    2952:	cc 0c       	add	r12, r12
    2954:	dd 1c       	adc	r13, r13
    2956:	ee 1c       	adc	r14, r14
    2958:	ff 1c       	adc	r15, r15
    295a:	4a 95       	dec	r20
    295c:	d1 f7       	brne	.-12     	; 0x2952 <find_volume+0x314>
    295e:	2d c0       	rjmp	.+90     	; 0x29ba <find_volume+0x37c>
    2960:	23 28       	or	r2, r3
    2962:	09 f4       	brne	.+2      	; 0x2966 <find_volume+0x328>
    2964:	01 cf       	rjmp	.-510    	; 0x2768 <find_volume+0x12a>
    2966:	2e 89       	ldd	r18, Y+22	; 0x16
    2968:	3f 89       	ldd	r19, Y+23	; 0x17
    296a:	48 8d       	ldd	r20, Y+24	; 0x18
    296c:	59 8d       	ldd	r21, Y+25	; 0x19
    296e:	82 0f       	add	r24, r18
    2970:	93 1f       	adc	r25, r19
    2972:	a4 1f       	adc	r26, r20
    2974:	b5 1f       	adc	r27, r21
    2976:	f8 01       	movw	r30, r16
    2978:	82 a3       	std	Z+34, r24	; 0x22
    297a:	93 a3       	std	Z+35, r25	; 0x23
    297c:	a4 a3       	std	Z+36, r26	; 0x24
    297e:	b5 a3       	std	Z+37, r27	; 0x25
    2980:	f9 89       	ldd	r31, Y+17	; 0x11
    2982:	f2 30       	cpi	r31, 0x02	; 2
    2984:	29 f4       	brne	.+10     	; 0x2990 <find_volume+0x352>
    2986:	cc 0c       	add	r12, r12
    2988:	dd 1c       	adc	r13, r13
    298a:	ee 1c       	adc	r14, r14
    298c:	ff 1c       	adc	r15, r15
    298e:	15 c0       	rjmp	.+42     	; 0x29ba <find_volume+0x37c>
    2990:	a3 e0       	ldi	r26, 0x03	; 3
    2992:	b0 e0       	ldi	r27, 0x00	; 0
    2994:	a7 01       	movw	r20, r14
    2996:	96 01       	movw	r18, r12
    2998:	0e 94 9c 35 	call	0x6b38	; 0x6b38 <__muluhisi3>
    299c:	dc 01       	movw	r26, r24
    299e:	cb 01       	movw	r24, r22
    29a0:	b6 95       	lsr	r27
    29a2:	a7 95       	ror	r26
    29a4:	97 95       	ror	r25
    29a6:	87 95       	ror	r24
    29a8:	21 e0       	ldi	r18, 0x01	; 1
    29aa:	c2 22       	and	r12, r18
    29ac:	dd 24       	eor	r13, r13
    29ae:	ee 24       	eor	r14, r14
    29b0:	ff 24       	eor	r15, r15
    29b2:	c8 0e       	add	r12, r24
    29b4:	d9 1e       	adc	r13, r25
    29b6:	ea 1e       	adc	r14, r26
    29b8:	fb 1e       	adc	r15, r27
    29ba:	3f ef       	ldi	r19, 0xFF	; 255
    29bc:	c3 0e       	add	r12, r19
    29be:	31 e0       	ldi	r19, 0x01	; 1
    29c0:	d3 1e       	adc	r13, r19
    29c2:	e1 1c       	adc	r14, r1
    29c4:	f1 1c       	adc	r15, r1
    29c6:	89 e0       	ldi	r24, 0x09	; 9
    29c8:	f6 94       	lsr	r15
    29ca:	e7 94       	ror	r14
    29cc:	d7 94       	ror	r13
    29ce:	c7 94       	ror	r12
    29d0:	8a 95       	dec	r24
    29d2:	d1 f7       	brne	.-12     	; 0x29c8 <find_volume+0x38a>
    29d4:	8c 14       	cp	r8, r12
    29d6:	9d 04       	cpc	r9, r13
    29d8:	ae 04       	cpc	r10, r14
    29da:	bf 04       	cpc	r11, r15
    29dc:	08 f4       	brcc	.+2      	; 0x29e0 <find_volume+0x3a2>
    29de:	c4 ce       	rjmp	.-632    	; 0x2768 <find_volume+0x12a>
    29e0:	8f ef       	ldi	r24, 0xFF	; 255
    29e2:	9f ef       	ldi	r25, 0xFF	; 255
    29e4:	dc 01       	movw	r26, r24
    29e6:	f8 01       	movw	r30, r16
    29e8:	86 87       	std	Z+14, r24	; 0x0e
    29ea:	97 87       	std	Z+15, r25	; 0x0f
    29ec:	a0 8b       	std	Z+16, r26	; 0x10
    29ee:	b1 8b       	std	Z+17, r27	; 0x11
    29f0:	82 87       	std	Z+10, r24	; 0x0a
    29f2:	93 87       	std	Z+11, r25	; 0x0b
    29f4:	a4 87       	std	Z+12, r26	; 0x0c
    29f6:	b5 87       	std	Z+13, r27	; 0x0d
    29f8:	80 e8       	ldi	r24, 0x80	; 128
    29fa:	85 83       	std	Z+5, r24	; 0x05
    29fc:	f9 89       	ldd	r31, Y+17	; 0x11
    29fe:	f3 30       	cpi	r31, 0x03	; 3
    2a00:	09 f0       	breq	.+2      	; 0x2a04 <find_volume+0x3c6>
    2a02:	48 c0       	rjmp	.+144    	; 0x2a94 <find_volume+0x456>
    2a04:	f8 01       	movw	r30, r16
    2a06:	e2 5a       	subi	r30, 0xA2	; 162
    2a08:	ff 4f       	sbci	r31, 0xFF	; 255
    2a0a:	80 81       	ld	r24, Z
    2a0c:	91 81       	ldd	r25, Z+1	; 0x01
    2a0e:	01 97       	sbiw	r24, 0x01	; 1
    2a10:	09 f0       	breq	.+2      	; 0x2a14 <find_volume+0x3d6>
    2a12:	40 c0       	rjmp	.+128    	; 0x2a94 <find_volume+0x456>
    2a14:	b3 01       	movw	r22, r6
    2a16:	a2 01       	movw	r20, r4
    2a18:	4f 5f       	subi	r20, 0xFF	; 255
    2a1a:	5f 4f       	sbci	r21, 0xFF	; 255
    2a1c:	6f 4f       	sbci	r22, 0xFF	; 255
    2a1e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a20:	c8 01       	movw	r24, r16
    2a22:	98 dd       	rcall	.-1232   	; 0x2554 <move_window>
    2a24:	81 11       	cpse	r24, r1
    2a26:	36 c0       	rjmp	.+108    	; 0x2a94 <find_volume+0x456>
    2a28:	d8 01       	movw	r26, r16
    2a2a:	15 96       	adiw	r26, 0x05	; 5
    2a2c:	1c 92       	st	X, r1
    2a2e:	f8 01       	movw	r30, r16
    2a30:	e4 5d       	subi	r30, 0xD4	; 212
    2a32:	fd 4f       	sbci	r31, 0xFD	; 253
    2a34:	80 81       	ld	r24, Z
    2a36:	91 81       	ldd	r25, Z+1	; 0x01
    2a38:	85 35       	cpi	r24, 0x55	; 85
    2a3a:	9a 4a       	sbci	r25, 0xAA	; 170
    2a3c:	59 f5       	brne	.+86     	; 0x2a94 <find_volume+0x456>
    2a3e:	f8 01       	movw	r30, r16
    2a40:	86 a5       	ldd	r24, Z+46	; 0x2e
    2a42:	97 a5       	ldd	r25, Z+47	; 0x2f
    2a44:	a0 a9       	ldd	r26, Z+48	; 0x30
    2a46:	b1 a9       	ldd	r27, Z+49	; 0x31
    2a48:	82 35       	cpi	r24, 0x52	; 82
    2a4a:	92 45       	sbci	r25, 0x52	; 82
    2a4c:	a1 46       	sbci	r26, 0x61	; 97
    2a4e:	b1 44       	sbci	r27, 0x41	; 65
    2a50:	09 f5       	brne	.+66     	; 0x2a94 <find_volume+0x456>
    2a52:	f8 01       	movw	r30, r16
    2a54:	ee 5e       	subi	r30, 0xEE	; 238
    2a56:	fd 4f       	sbci	r31, 0xFD	; 253
    2a58:	80 81       	ld	r24, Z
    2a5a:	91 81       	ldd	r25, Z+1	; 0x01
    2a5c:	a2 81       	ldd	r26, Z+2	; 0x02
    2a5e:	b3 81       	ldd	r27, Z+3	; 0x03
    2a60:	82 37       	cpi	r24, 0x72	; 114
    2a62:	92 47       	sbci	r25, 0x72	; 114
    2a64:	a1 44       	sbci	r26, 0x41	; 65
    2a66:	b1 46       	sbci	r27, 0x61	; 97
    2a68:	a9 f4       	brne	.+42     	; 0x2a94 <find_volume+0x456>
    2a6a:	34 96       	adiw	r30, 0x04	; 4
    2a6c:	80 81       	ld	r24, Z
    2a6e:	91 81       	ldd	r25, Z+1	; 0x01
    2a70:	a2 81       	ldd	r26, Z+2	; 0x02
    2a72:	b3 81       	ldd	r27, Z+3	; 0x03
    2a74:	f8 01       	movw	r30, r16
    2a76:	86 87       	std	Z+14, r24	; 0x0e
    2a78:	97 87       	std	Z+15, r25	; 0x0f
    2a7a:	a0 8b       	std	Z+16, r26	; 0x10
    2a7c:	b1 8b       	std	Z+17, r27	; 0x11
    2a7e:	e6 5e       	subi	r30, 0xE6	; 230
    2a80:	fd 4f       	sbci	r31, 0xFD	; 253
    2a82:	80 81       	ld	r24, Z
    2a84:	91 81       	ldd	r25, Z+1	; 0x01
    2a86:	a2 81       	ldd	r26, Z+2	; 0x02
    2a88:	b3 81       	ldd	r27, Z+3	; 0x03
    2a8a:	f8 01       	movw	r30, r16
    2a8c:	82 87       	std	Z+10, r24	; 0x0a
    2a8e:	93 87       	std	Z+11, r25	; 0x0b
    2a90:	a4 87       	std	Z+12, r26	; 0x0c
    2a92:	b5 87       	std	Z+13, r27	; 0x0d
    2a94:	e9 89       	ldd	r30, Y+17	; 0x11
    2a96:	d8 01       	movw	r26, r16
    2a98:	ec 93       	st	X, r30
    2a9a:	80 91 a2 05 	lds	r24, 0x05A2
    2a9e:	90 91 a3 05 	lds	r25, 0x05A3
    2aa2:	01 96       	adiw	r24, 0x01	; 1
    2aa4:	90 93 a3 05 	sts	0x05A3, r25
    2aa8:	80 93 a2 05 	sts	0x05A2, r24
    2aac:	17 96       	adiw	r26, 0x07	; 7
    2aae:	9c 93       	st	X, r25
    2ab0:	8e 93       	st	-X, r24
    2ab2:	16 97       	sbiw	r26, 0x06	; 6
    2ab4:	04 c0       	rjmp	.+8      	; 0x2abe <find_volume+0x480>
    2ab6:	8b e0       	ldi	r24, 0x0B	; 11
    2ab8:	07 c0       	rjmp	.+14     	; 0x2ac8 <find_volume+0x48a>
    2aba:	8c e0       	ldi	r24, 0x0C	; 12
    2abc:	05 c0       	rjmp	.+10     	; 0x2ac8 <find_volume+0x48a>
    2abe:	80 e0       	ldi	r24, 0x00	; 0
    2ac0:	03 c0       	rjmp	.+6      	; 0x2ac8 <find_volume+0x48a>
    2ac2:	83 e0       	ldi	r24, 0x03	; 3
    2ac4:	01 c0       	rjmp	.+2      	; 0x2ac8 <find_volume+0x48a>
    2ac6:	81 e0       	ldi	r24, 0x01	; 1
    2ac8:	6d 96       	adiw	r28, 0x1d	; 29
    2aca:	0f b6       	in	r0, 0x3f	; 63
    2acc:	f8 94       	cli
    2ace:	de bf       	out	0x3e, r29	; 62
    2ad0:	0f be       	out	0x3f, r0	; 63
    2ad2:	cd bf       	out	0x3d, r28	; 61
    2ad4:	df 91       	pop	r29
    2ad6:	cf 91       	pop	r28
    2ad8:	1f 91       	pop	r17
    2ada:	0f 91       	pop	r16
    2adc:	ff 90       	pop	r15
    2ade:	ef 90       	pop	r14
    2ae0:	df 90       	pop	r13
    2ae2:	cf 90       	pop	r12
    2ae4:	bf 90       	pop	r11
    2ae6:	af 90       	pop	r10
    2ae8:	9f 90       	pop	r9
    2aea:	8f 90       	pop	r8
    2aec:	7f 90       	pop	r7
    2aee:	6f 90       	pop	r6
    2af0:	5f 90       	pop	r5
    2af2:	4f 90       	pop	r4
    2af4:	3f 90       	pop	r3
    2af6:	2f 90       	pop	r2
    2af8:	08 95       	ret

00002afa <clust2sect>:
    2afa:	0f 93       	push	r16
    2afc:	1f 93       	push	r17
    2afe:	fc 01       	movw	r30, r24
    2b00:	9a 01       	movw	r18, r20
    2b02:	ab 01       	movw	r20, r22
    2b04:	22 50       	subi	r18, 0x02	; 2
    2b06:	31 09       	sbc	r19, r1
    2b08:	41 09       	sbc	r20, r1
    2b0a:	51 09       	sbc	r21, r1
    2b0c:	82 89       	ldd	r24, Z+18	; 0x12
    2b0e:	93 89       	ldd	r25, Z+19	; 0x13
    2b10:	a4 89       	ldd	r26, Z+20	; 0x14
    2b12:	b5 89       	ldd	r27, Z+21	; 0x15
    2b14:	02 97       	sbiw	r24, 0x02	; 2
    2b16:	a1 09       	sbc	r26, r1
    2b18:	b1 09       	sbc	r27, r1
    2b1a:	28 17       	cp	r18, r24
    2b1c:	39 07       	cpc	r19, r25
    2b1e:	4a 07       	cpc	r20, r26
    2b20:	5b 07       	cpc	r21, r27
    2b22:	68 f4       	brcc	.+26     	; 0x2b3e <clust2sect+0x44>
    2b24:	a2 81       	ldd	r26, Z+2	; 0x02
    2b26:	b0 e0       	ldi	r27, 0x00	; 0
    2b28:	0e 94 9c 35 	call	0x6b38	; 0x6b38 <__muluhisi3>
    2b2c:	06 a1       	ldd	r16, Z+38	; 0x26
    2b2e:	17 a1       	ldd	r17, Z+39	; 0x27
    2b30:	20 a5       	ldd	r18, Z+40	; 0x28
    2b32:	31 a5       	ldd	r19, Z+41	; 0x29
    2b34:	60 0f       	add	r22, r16
    2b36:	71 1f       	adc	r23, r17
    2b38:	82 1f       	adc	r24, r18
    2b3a:	93 1f       	adc	r25, r19
    2b3c:	03 c0       	rjmp	.+6      	; 0x2b44 <clust2sect+0x4a>
    2b3e:	60 e0       	ldi	r22, 0x00	; 0
    2b40:	70 e0       	ldi	r23, 0x00	; 0
    2b42:	cb 01       	movw	r24, r22
    2b44:	1f 91       	pop	r17
    2b46:	0f 91       	pop	r16
    2b48:	08 95       	ret

00002b4a <get_fat>:
    2b4a:	af 92       	push	r10
    2b4c:	bf 92       	push	r11
    2b4e:	cf 92       	push	r12
    2b50:	df 92       	push	r13
    2b52:	ef 92       	push	r14
    2b54:	ff 92       	push	r15
    2b56:	0f 93       	push	r16
    2b58:	1f 93       	push	r17
    2b5a:	cf 93       	push	r28
    2b5c:	df 93       	push	r29
    2b5e:	8c 01       	movw	r16, r24
    2b60:	6a 01       	movw	r12, r20
    2b62:	7b 01       	movw	r14, r22
    2b64:	42 30       	cpi	r20, 0x02	; 2
    2b66:	51 05       	cpc	r21, r1
    2b68:	61 05       	cpc	r22, r1
    2b6a:	71 05       	cpc	r23, r1
    2b6c:	08 f4       	brcc	.+2      	; 0x2b70 <get_fat+0x26>
    2b6e:	a9 c0       	rjmp	.+338    	; 0x2cc2 <get_fat+0x178>
    2b70:	f8 01       	movw	r30, r16
    2b72:	82 89       	ldd	r24, Z+18	; 0x12
    2b74:	93 89       	ldd	r25, Z+19	; 0x13
    2b76:	a4 89       	ldd	r26, Z+20	; 0x14
    2b78:	b5 89       	ldd	r27, Z+21	; 0x15
    2b7a:	48 17       	cp	r20, r24
    2b7c:	59 07       	cpc	r21, r25
    2b7e:	6a 07       	cpc	r22, r26
    2b80:	7b 07       	cpc	r23, r27
    2b82:	08 f0       	brcs	.+2      	; 0x2b86 <get_fat+0x3c>
    2b84:	9e c0       	rjmp	.+316    	; 0x2cc2 <get_fat+0x178>
    2b86:	80 81       	ld	r24, Z
    2b88:	82 30       	cpi	r24, 0x02	; 2
    2b8a:	09 f4       	brne	.+2      	; 0x2b8e <get_fat+0x44>
    2b8c:	4b c0       	rjmp	.+150    	; 0x2c24 <get_fat+0xda>
    2b8e:	83 30       	cpi	r24, 0x03	; 3
    2b90:	09 f4       	brne	.+2      	; 0x2b94 <get_fat+0x4a>
    2b92:	6b c0       	rjmp	.+214    	; 0x2c6a <get_fat+0x120>
    2b94:	81 30       	cpi	r24, 0x01	; 1
    2b96:	09 f0       	breq	.+2      	; 0x2b9a <get_fat+0x50>
    2b98:	94 c0       	rjmp	.+296    	; 0x2cc2 <get_fat+0x178>
    2b9a:	ea 01       	movw	r28, r20
    2b9c:	d6 95       	lsr	r29
    2b9e:	c7 95       	ror	r28
    2ba0:	cc 0d       	add	r28, r12
    2ba2:	dd 1d       	adc	r29, r13
    2ba4:	ce 01       	movw	r24, r28
    2ba6:	89 2f       	mov	r24, r25
    2ba8:	99 27       	eor	r25, r25
    2baa:	86 95       	lsr	r24
    2bac:	46 8d       	ldd	r20, Z+30	; 0x1e
    2bae:	57 8d       	ldd	r21, Z+31	; 0x1f
    2bb0:	60 a1       	ldd	r22, Z+32	; 0x20
    2bb2:	71 a1       	ldd	r23, Z+33	; 0x21
    2bb4:	48 0f       	add	r20, r24
    2bb6:	59 1f       	adc	r21, r25
    2bb8:	61 1d       	adc	r22, r1
    2bba:	71 1d       	adc	r23, r1
    2bbc:	c8 01       	movw	r24, r16
    2bbe:	ca dc       	rcall	.-1644   	; 0x2554 <move_window>
    2bc0:	88 23       	and	r24, r24
    2bc2:	21 f0       	breq	.+8      	; 0x2bcc <get_fat+0x82>
    2bc4:	6f ef       	ldi	r22, 0xFF	; 255
    2bc6:	7f ef       	ldi	r23, 0xFF	; 255
    2bc8:	cb 01       	movw	r24, r22
    2bca:	7f c0       	rjmp	.+254    	; 0x2cca <get_fat+0x180>
    2bcc:	5e 01       	movw	r10, r28
    2bce:	ff ef       	ldi	r31, 0xFF	; 255
    2bd0:	af 1a       	sub	r10, r31
    2bd2:	bf 0a       	sbc	r11, r31
    2bd4:	d1 70       	andi	r29, 0x01	; 1
    2bd6:	c0 0f       	add	r28, r16
    2bd8:	d1 1f       	adc	r29, r17
    2bda:	ce a5       	ldd	r28, Y+46	; 0x2e
    2bdc:	c5 01       	movw	r24, r10
    2bde:	89 2f       	mov	r24, r25
    2be0:	99 27       	eor	r25, r25
    2be2:	86 95       	lsr	r24
    2be4:	f8 01       	movw	r30, r16
    2be6:	46 8d       	ldd	r20, Z+30	; 0x1e
    2be8:	57 8d       	ldd	r21, Z+31	; 0x1f
    2bea:	60 a1       	ldd	r22, Z+32	; 0x20
    2bec:	71 a1       	ldd	r23, Z+33	; 0x21
    2bee:	48 0f       	add	r20, r24
    2bf0:	59 1f       	adc	r21, r25
    2bf2:	61 1d       	adc	r22, r1
    2bf4:	71 1d       	adc	r23, r1
    2bf6:	c8 01       	movw	r24, r16
    2bf8:	ad dc       	rcall	.-1702   	; 0x2554 <move_window>
    2bfa:	81 11       	cpse	r24, r1
    2bfc:	e3 cf       	rjmp	.-58     	; 0x2bc4 <get_fat+0x7a>
    2bfe:	f1 e0       	ldi	r31, 0x01	; 1
    2c00:	bf 22       	and	r11, r31
    2c02:	f8 01       	movw	r30, r16
    2c04:	ea 0d       	add	r30, r10
    2c06:	fb 1d       	adc	r31, r11
    2c08:	86 a5       	ldd	r24, Z+46	; 0x2e
    2c0a:	6c 2f       	mov	r22, r28
    2c0c:	70 e0       	ldi	r23, 0x00	; 0
    2c0e:	78 2b       	or	r23, r24
    2c10:	c0 fe       	sbrs	r12, 0
    2c12:	06 c0       	rjmp	.+12     	; 0x2c20 <get_fat+0xd6>
    2c14:	54 e0       	ldi	r21, 0x04	; 4
    2c16:	76 95       	lsr	r23
    2c18:	67 95       	ror	r22
    2c1a:	5a 95       	dec	r21
    2c1c:	e1 f7       	brne	.-8      	; 0x2c16 <get_fat+0xcc>
    2c1e:	22 c0       	rjmp	.+68     	; 0x2c64 <get_fat+0x11a>
    2c20:	7f 70       	andi	r23, 0x0F	; 15
    2c22:	20 c0       	rjmp	.+64     	; 0x2c64 <get_fat+0x11a>
    2c24:	77 27       	eor	r23, r23
    2c26:	6f 2d       	mov	r22, r15
    2c28:	5e 2d       	mov	r21, r14
    2c2a:	4d 2d       	mov	r20, r13
    2c2c:	f8 01       	movw	r30, r16
    2c2e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c30:	97 8d       	ldd	r25, Z+31	; 0x1f
    2c32:	a0 a1       	ldd	r26, Z+32	; 0x20
    2c34:	b1 a1       	ldd	r27, Z+33	; 0x21
    2c36:	48 0f       	add	r20, r24
    2c38:	59 1f       	adc	r21, r25
    2c3a:	6a 1f       	adc	r22, r26
    2c3c:	7b 1f       	adc	r23, r27
    2c3e:	c8 01       	movw	r24, r16
    2c40:	89 dc       	rcall	.-1774   	; 0x2554 <move_window>
    2c42:	81 11       	cpse	r24, r1
    2c44:	bf cf       	rjmp	.-130    	; 0x2bc4 <get_fat+0x7a>
    2c46:	cc 0c       	add	r12, r12
    2c48:	dd 1c       	adc	r13, r13
    2c4a:	ee 1c       	adc	r14, r14
    2c4c:	ff 1c       	adc	r15, r15
    2c4e:	e8 94       	clt
    2c50:	c0 f8       	bld	r12, 0
    2c52:	f1 e0       	ldi	r31, 0x01	; 1
    2c54:	df 22       	and	r13, r31
    2c56:	ee 24       	eor	r14, r14
    2c58:	ff 24       	eor	r15, r15
    2c5a:	f8 01       	movw	r30, r16
    2c5c:	ec 0d       	add	r30, r12
    2c5e:	fd 1d       	adc	r31, r13
    2c60:	66 a5       	ldd	r22, Z+46	; 0x2e
    2c62:	77 a5       	ldd	r23, Z+47	; 0x2f
    2c64:	80 e0       	ldi	r24, 0x00	; 0
    2c66:	90 e0       	ldi	r25, 0x00	; 0
    2c68:	30 c0       	rjmp	.+96     	; 0x2cca <get_fat+0x180>
    2c6a:	f8 01       	movw	r30, r16
    2c6c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c6e:	97 8d       	ldd	r25, Z+31	; 0x1f
    2c70:	a0 a1       	ldd	r26, Z+32	; 0x20
    2c72:	b1 a1       	ldd	r27, Z+33	; 0x21
    2c74:	27 e0       	ldi	r18, 0x07	; 7
    2c76:	76 95       	lsr	r23
    2c78:	67 95       	ror	r22
    2c7a:	57 95       	ror	r21
    2c7c:	47 95       	ror	r20
    2c7e:	2a 95       	dec	r18
    2c80:	d1 f7       	brne	.-12     	; 0x2c76 <get_fat+0x12c>
    2c82:	48 0f       	add	r20, r24
    2c84:	59 1f       	adc	r21, r25
    2c86:	6a 1f       	adc	r22, r26
    2c88:	7b 1f       	adc	r23, r27
    2c8a:	c8 01       	movw	r24, r16
    2c8c:	63 dc       	rcall	.-1850   	; 0x2554 <move_window>
    2c8e:	81 11       	cpse	r24, r1
    2c90:	99 cf       	rjmp	.-206    	; 0x2bc4 <get_fat+0x7a>
    2c92:	82 e0       	ldi	r24, 0x02	; 2
    2c94:	cc 0c       	add	r12, r12
    2c96:	dd 1c       	adc	r13, r13
    2c98:	ee 1c       	adc	r14, r14
    2c9a:	ff 1c       	adc	r15, r15
    2c9c:	8a 95       	dec	r24
    2c9e:	d1 f7       	brne	.-12     	; 0x2c94 <get_fat+0x14a>
    2ca0:	fc ef       	ldi	r31, 0xFC	; 252
    2ca2:	cf 22       	and	r12, r31
    2ca4:	f1 e0       	ldi	r31, 0x01	; 1
    2ca6:	df 22       	and	r13, r31
    2ca8:	ee 24       	eor	r14, r14
    2caa:	ff 24       	eor	r15, r15
    2cac:	f8 01       	movw	r30, r16
    2cae:	ec 0d       	add	r30, r12
    2cb0:	fd 1d       	adc	r31, r13
    2cb2:	86 a5       	ldd	r24, Z+46	; 0x2e
    2cb4:	97 a5       	ldd	r25, Z+47	; 0x2f
    2cb6:	a0 a9       	ldd	r26, Z+48	; 0x30
    2cb8:	b1 a9       	ldd	r27, Z+49	; 0x31
    2cba:	bc 01       	movw	r22, r24
    2cbc:	cd 01       	movw	r24, r26
    2cbe:	9f 70       	andi	r25, 0x0F	; 15
    2cc0:	04 c0       	rjmp	.+8      	; 0x2cca <get_fat+0x180>
    2cc2:	61 e0       	ldi	r22, 0x01	; 1
    2cc4:	70 e0       	ldi	r23, 0x00	; 0
    2cc6:	80 e0       	ldi	r24, 0x00	; 0
    2cc8:	90 e0       	ldi	r25, 0x00	; 0
    2cca:	df 91       	pop	r29
    2ccc:	cf 91       	pop	r28
    2cce:	1f 91       	pop	r17
    2cd0:	0f 91       	pop	r16
    2cd2:	ff 90       	pop	r15
    2cd4:	ef 90       	pop	r14
    2cd6:	df 90       	pop	r13
    2cd8:	cf 90       	pop	r12
    2cda:	bf 90       	pop	r11
    2cdc:	af 90       	pop	r10
    2cde:	08 95       	ret

00002ce0 <dir_sdi>:
    2ce0:	af 92       	push	r10
    2ce2:	bf 92       	push	r11
    2ce4:	cf 92       	push	r12
    2ce6:	df 92       	push	r13
    2ce8:	ef 92       	push	r14
    2cea:	ff 92       	push	r15
    2cec:	0f 93       	push	r16
    2cee:	1f 93       	push	r17
    2cf0:	cf 93       	push	r28
    2cf2:	df 93       	push	r29
    2cf4:	8c 01       	movw	r16, r24
    2cf6:	eb 01       	movw	r28, r22
    2cf8:	dc 01       	movw	r26, r24
    2cfa:	15 96       	adiw	r26, 0x05	; 5
    2cfc:	7c 93       	st	X, r23
    2cfe:	6e 93       	st	-X, r22
    2d00:	14 97       	sbiw	r26, 0x04	; 4
    2d02:	16 96       	adiw	r26, 0x06	; 6
    2d04:	cd 90       	ld	r12, X+
    2d06:	dd 90       	ld	r13, X+
    2d08:	ed 90       	ld	r14, X+
    2d0a:	fc 90       	ld	r15, X
    2d0c:	19 97       	sbiw	r26, 0x09	; 9
    2d0e:	b1 e0       	ldi	r27, 0x01	; 1
    2d10:	cb 16       	cp	r12, r27
    2d12:	d1 04       	cpc	r13, r1
    2d14:	e1 04       	cpc	r14, r1
    2d16:	f1 04       	cpc	r15, r1
    2d18:	11 f4       	brne	.+4      	; 0x2d1e <dir_sdi+0x3e>
    2d1a:	82 e0       	ldi	r24, 0x02	; 2
    2d1c:	87 c0       	rjmp	.+270    	; 0x2e2c <dir_sdi+0x14c>
    2d1e:	dc 01       	movw	r26, r24
    2d20:	ed 91       	ld	r30, X+
    2d22:	fc 91       	ld	r31, X
    2d24:	82 89       	ldd	r24, Z+18	; 0x12
    2d26:	93 89       	ldd	r25, Z+19	; 0x13
    2d28:	a4 89       	ldd	r26, Z+20	; 0x14
    2d2a:	b5 89       	ldd	r27, Z+21	; 0x15
    2d2c:	c8 16       	cp	r12, r24
    2d2e:	d9 06       	cpc	r13, r25
    2d30:	ea 06       	cpc	r14, r26
    2d32:	fb 06       	cpc	r15, r27
    2d34:	90 f7       	brcc	.-28     	; 0x2d1a <dir_sdi+0x3a>
    2d36:	c1 14       	cp	r12, r1
    2d38:	d1 04       	cpc	r13, r1
    2d3a:	e1 04       	cpc	r14, r1
    2d3c:	f1 04       	cpc	r15, r1
    2d3e:	b9 f4       	brne	.+46     	; 0x2d6e <dir_sdi+0x8e>
    2d40:	80 81       	ld	r24, Z
    2d42:	83 30       	cpi	r24, 0x03	; 3
    2d44:	41 f4       	brne	.+16     	; 0x2d56 <dir_sdi+0x76>
    2d46:	82 a1       	ldd	r24, Z+34	; 0x22
    2d48:	93 a1       	ldd	r25, Z+35	; 0x23
    2d4a:	a4 a1       	ldd	r26, Z+36	; 0x24
    2d4c:	b5 a1       	ldd	r27, Z+37	; 0x25
    2d4e:	00 97       	sbiw	r24, 0x00	; 0
    2d50:	a1 05       	cpc	r26, r1
    2d52:	b1 05       	cpc	r27, r1
    2d54:	51 f4       	brne	.+20     	; 0x2d6a <dir_sdi+0x8a>
    2d56:	80 85       	ldd	r24, Z+8	; 0x08
    2d58:	91 85       	ldd	r25, Z+9	; 0x09
    2d5a:	c8 17       	cp	r28, r24
    2d5c:	d9 07       	cpc	r29, r25
    2d5e:	e8 f6       	brcc	.-70     	; 0x2d1a <dir_sdi+0x3a>
    2d60:	62 a1       	ldd	r22, Z+34	; 0x22
    2d62:	73 a1       	ldd	r23, Z+35	; 0x23
    2d64:	84 a1       	ldd	r24, Z+36	; 0x24
    2d66:	95 a1       	ldd	r25, Z+37	; 0x25
    2d68:	32 c0       	rjmp	.+100    	; 0x2dce <dir_sdi+0xee>
    2d6a:	6c 01       	movw	r12, r24
    2d6c:	7d 01       	movw	r14, r26
    2d6e:	a2 80       	ldd	r10, Z+2	; 0x02
    2d70:	b0 e1       	ldi	r27, 0x10	; 16
    2d72:	ab 9e       	mul	r10, r27
    2d74:	50 01       	movw	r10, r0
    2d76:	11 24       	eor	r1, r1
    2d78:	b7 01       	movw	r22, r14
    2d7a:	a6 01       	movw	r20, r12
    2d7c:	f8 01       	movw	r30, r16
    2d7e:	80 81       	ld	r24, Z
    2d80:	91 81       	ldd	r25, Z+1	; 0x01
    2d82:	ca 15       	cp	r28, r10
    2d84:	db 05       	cpc	r29, r11
    2d86:	00 f1       	brcs	.+64     	; 0x2dc8 <dir_sdi+0xe8>
    2d88:	e0 de       	rcall	.-576    	; 0x2b4a <get_fat>
    2d8a:	ab 01       	movw	r20, r22
    2d8c:	bc 01       	movw	r22, r24
    2d8e:	4f 3f       	cpi	r20, 0xFF	; 255
    2d90:	ef ef       	ldi	r30, 0xFF	; 255
    2d92:	5e 07       	cpc	r21, r30
    2d94:	6e 07       	cpc	r22, r30
    2d96:	7e 07       	cpc	r23, r30
    2d98:	09 f4       	brne	.+2      	; 0x2d9c <dir_sdi+0xbc>
    2d9a:	47 c0       	rjmp	.+142    	; 0x2e2a <dir_sdi+0x14a>
    2d9c:	42 30       	cpi	r20, 0x02	; 2
    2d9e:	51 05       	cpc	r21, r1
    2da0:	61 05       	cpc	r22, r1
    2da2:	71 05       	cpc	r23, r1
    2da4:	08 f4       	brcc	.+2      	; 0x2da8 <dir_sdi+0xc8>
    2da6:	b9 cf       	rjmp	.-142    	; 0x2d1a <dir_sdi+0x3a>
    2da8:	d8 01       	movw	r26, r16
    2daa:	ed 91       	ld	r30, X+
    2dac:	fc 91       	ld	r31, X
    2dae:	82 89       	ldd	r24, Z+18	; 0x12
    2db0:	93 89       	ldd	r25, Z+19	; 0x13
    2db2:	a4 89       	ldd	r26, Z+20	; 0x14
    2db4:	b5 89       	ldd	r27, Z+21	; 0x15
    2db6:	48 17       	cp	r20, r24
    2db8:	59 07       	cpc	r21, r25
    2dba:	6a 07       	cpc	r22, r26
    2dbc:	7b 07       	cpc	r23, r27
    2dbe:	08 f0       	brcs	.+2      	; 0x2dc2 <dir_sdi+0xe2>
    2dc0:	ac cf       	rjmp	.-168    	; 0x2d1a <dir_sdi+0x3a>
    2dc2:	ca 19       	sub	r28, r10
    2dc4:	db 09       	sbc	r29, r11
    2dc6:	da cf       	rjmp	.-76     	; 0x2d7c <dir_sdi+0x9c>
    2dc8:	6a 01       	movw	r12, r20
    2dca:	7b 01       	movw	r14, r22
    2dcc:	96 de       	rcall	.-724    	; 0x2afa <clust2sect>
    2dce:	d8 01       	movw	r26, r16
    2dd0:	1a 96       	adiw	r26, 0x0a	; 10
    2dd2:	cd 92       	st	X+, r12
    2dd4:	dd 92       	st	X+, r13
    2dd6:	ed 92       	st	X+, r14
    2dd8:	fc 92       	st	X, r15
    2dda:	1d 97       	sbiw	r26, 0x0d	; 13
    2ddc:	61 15       	cp	r22, r1
    2dde:	71 05       	cpc	r23, r1
    2de0:	81 05       	cpc	r24, r1
    2de2:	91 05       	cpc	r25, r1
    2de4:	09 f4       	brne	.+2      	; 0x2de8 <dir_sdi+0x108>
    2de6:	99 cf       	rjmp	.-206    	; 0x2d1a <dir_sdi+0x3a>
    2de8:	9e 01       	movw	r18, r28
    2dea:	44 e0       	ldi	r20, 0x04	; 4
    2dec:	36 95       	lsr	r19
    2dee:	27 95       	ror	r18
    2df0:	4a 95       	dec	r20
    2df2:	e1 f7       	brne	.-8      	; 0x2dec <dir_sdi+0x10c>
    2df4:	dc 01       	movw	r26, r24
    2df6:	cb 01       	movw	r24, r22
    2df8:	82 0f       	add	r24, r18
    2dfa:	93 1f       	adc	r25, r19
    2dfc:	a1 1d       	adc	r26, r1
    2dfe:	b1 1d       	adc	r27, r1
    2e00:	f8 01       	movw	r30, r16
    2e02:	86 87       	std	Z+14, r24	; 0x0e
    2e04:	97 87       	std	Z+15, r25	; 0x0f
    2e06:	a0 8b       	std	Z+16, r26	; 0x10
    2e08:	b1 8b       	std	Z+17, r27	; 0x11
    2e0a:	cf 70       	andi	r28, 0x0F	; 15
    2e0c:	dd 27       	eor	r29, r29
    2e0e:	55 e0       	ldi	r21, 0x05	; 5
    2e10:	cc 0f       	add	r28, r28
    2e12:	dd 1f       	adc	r29, r29
    2e14:	5a 95       	dec	r21
    2e16:	e1 f7       	brne	.-8      	; 0x2e10 <dir_sdi+0x130>
    2e18:	ae 96       	adiw	r28, 0x2e	; 46
    2e1a:	80 81       	ld	r24, Z
    2e1c:	91 81       	ldd	r25, Z+1	; 0x01
    2e1e:	c8 0f       	add	r28, r24
    2e20:	d9 1f       	adc	r29, r25
    2e22:	d3 8b       	std	Z+19, r29	; 0x13
    2e24:	c2 8b       	std	Z+18, r28	; 0x12
    2e26:	80 e0       	ldi	r24, 0x00	; 0
    2e28:	01 c0       	rjmp	.+2      	; 0x2e2c <dir_sdi+0x14c>
    2e2a:	81 e0       	ldi	r24, 0x01	; 1
    2e2c:	df 91       	pop	r29
    2e2e:	cf 91       	pop	r28
    2e30:	1f 91       	pop	r17
    2e32:	0f 91       	pop	r16
    2e34:	ff 90       	pop	r15
    2e36:	ef 90       	pop	r14
    2e38:	df 90       	pop	r13
    2e3a:	cf 90       	pop	r12
    2e3c:	bf 90       	pop	r11
    2e3e:	af 90       	pop	r10
    2e40:	08 95       	ret

00002e42 <put_fat>:
    2e42:	2f 92       	push	r2
    2e44:	3f 92       	push	r3
    2e46:	4f 92       	push	r4
    2e48:	5f 92       	push	r5
    2e4a:	6f 92       	push	r6
    2e4c:	7f 92       	push	r7
    2e4e:	8f 92       	push	r8
    2e50:	9f 92       	push	r9
    2e52:	af 92       	push	r10
    2e54:	bf 92       	push	r11
    2e56:	cf 92       	push	r12
    2e58:	df 92       	push	r13
    2e5a:	ef 92       	push	r14
    2e5c:	ff 92       	push	r15
    2e5e:	0f 93       	push	r16
    2e60:	1f 93       	push	r17
    2e62:	cf 93       	push	r28
    2e64:	df 93       	push	r29
    2e66:	00 d0       	rcall	.+0      	; 0x2e68 <put_fat+0x26>
    2e68:	00 d0       	rcall	.+0      	; 0x2e6a <put_fat+0x28>
    2e6a:	cd b7       	in	r28, 0x3d	; 61
    2e6c:	de b7       	in	r29, 0x3e	; 62
    2e6e:	1c 01       	movw	r2, r24
    2e70:	6a 01       	movw	r12, r20
    2e72:	7b 01       	movw	r14, r22
    2e74:	28 01       	movw	r4, r16
    2e76:	39 01       	movw	r6, r18
    2e78:	42 30       	cpi	r20, 0x02	; 2
    2e7a:	51 05       	cpc	r21, r1
    2e7c:	61 05       	cpc	r22, r1
    2e7e:	71 05       	cpc	r23, r1
    2e80:	08 f4       	brcc	.+2      	; 0x2e84 <put_fat+0x42>
    2e82:	e0 c0       	rjmp	.+448    	; 0x3044 <put_fat+0x202>
    2e84:	fc 01       	movw	r30, r24
    2e86:	82 89       	ldd	r24, Z+18	; 0x12
    2e88:	93 89       	ldd	r25, Z+19	; 0x13
    2e8a:	a4 89       	ldd	r26, Z+20	; 0x14
    2e8c:	b5 89       	ldd	r27, Z+21	; 0x15
    2e8e:	48 17       	cp	r20, r24
    2e90:	59 07       	cpc	r21, r25
    2e92:	6a 07       	cpc	r22, r26
    2e94:	7b 07       	cpc	r23, r27
    2e96:	08 f0       	brcs	.+2      	; 0x2e9a <put_fat+0x58>
    2e98:	d5 c0       	rjmp	.+426    	; 0x3044 <put_fat+0x202>
    2e9a:	80 81       	ld	r24, Z
    2e9c:	82 30       	cpi	r24, 0x02	; 2
    2e9e:	09 f4       	brne	.+2      	; 0x2ea2 <put_fat+0x60>
    2ea0:	71 c0       	rjmp	.+226    	; 0x2f84 <put_fat+0x142>
    2ea2:	83 30       	cpi	r24, 0x03	; 3
    2ea4:	09 f4       	brne	.+2      	; 0x2ea8 <put_fat+0x66>
    2ea6:	92 c0       	rjmp	.+292    	; 0x2fcc <put_fat+0x18a>
    2ea8:	81 30       	cpi	r24, 0x01	; 1
    2eaa:	09 f0       	breq	.+2      	; 0x2eae <put_fat+0x6c>
    2eac:	cb c0       	rjmp	.+406    	; 0x3044 <put_fat+0x202>
    2eae:	5a 01       	movw	r10, r20
    2eb0:	b6 94       	lsr	r11
    2eb2:	a7 94       	ror	r10
    2eb4:	a4 0e       	add	r10, r20
    2eb6:	b5 1e       	adc	r11, r21
    2eb8:	c5 01       	movw	r24, r10
    2eba:	89 2f       	mov	r24, r25
    2ebc:	99 27       	eor	r25, r25
    2ebe:	86 95       	lsr	r24
    2ec0:	46 8d       	ldd	r20, Z+30	; 0x1e
    2ec2:	57 8d       	ldd	r21, Z+31	; 0x1f
    2ec4:	60 a1       	ldd	r22, Z+32	; 0x20
    2ec6:	71 a1       	ldd	r23, Z+33	; 0x21
    2ec8:	48 0f       	add	r20, r24
    2eca:	59 1f       	adc	r21, r25
    2ecc:	61 1d       	adc	r22, r1
    2ece:	71 1d       	adc	r23, r1
    2ed0:	c1 01       	movw	r24, r2
    2ed2:	40 db       	rcall	.-2432   	; 0x2554 <move_window>
    2ed4:	81 11       	cpse	r24, r1
    2ed6:	b7 c0       	rjmp	.+366    	; 0x3046 <put_fat+0x204>
    2ed8:	45 01       	movw	r8, r10
    2eda:	ff ef       	ldi	r31, 0xFF	; 255
    2edc:	8f 1a       	sub	r8, r31
    2ede:	9f 0a       	sbc	r9, r31
    2ee0:	21 e0       	ldi	r18, 0x01	; 1
    2ee2:	b2 22       	and	r11, r18
    2ee4:	a2 0c       	add	r10, r2
    2ee6:	b3 1c       	adc	r11, r3
    2ee8:	a7 01       	movw	r20, r14
    2eea:	96 01       	movw	r18, r12
    2eec:	21 70       	andi	r18, 0x01	; 1
    2eee:	33 27       	eor	r19, r19
    2ef0:	44 27       	eor	r20, r20
    2ef2:	55 27       	eor	r21, r21
    2ef4:	29 83       	std	Y+1, r18	; 0x01
    2ef6:	3a 83       	std	Y+2, r19	; 0x02
    2ef8:	4b 83       	std	Y+3, r20	; 0x03
    2efa:	5c 83       	std	Y+4, r21	; 0x04
    2efc:	c0 fe       	sbrs	r12, 0
    2efe:	0b c0       	rjmp	.+22     	; 0x2f16 <put_fat+0xd4>
    2f00:	d5 01       	movw	r26, r10
    2f02:	9e 96       	adiw	r26, 0x2e	; 46
    2f04:	8c 91       	ld	r24, X
    2f06:	28 2f       	mov	r18, r24
    2f08:	2f 70       	andi	r18, 0x0F	; 15
    2f0a:	b0 e1       	ldi	r27, 0x10	; 16
    2f0c:	4b 9e       	mul	r4, r27
    2f0e:	c0 01       	movw	r24, r0
    2f10:	11 24       	eor	r1, r1
    2f12:	82 2b       	or	r24, r18
    2f14:	01 c0       	rjmp	.+2      	; 0x2f18 <put_fat+0xd6>
    2f16:	84 2d       	mov	r24, r4
    2f18:	f5 01       	movw	r30, r10
    2f1a:	86 a7       	std	Z+46, r24	; 0x2e
    2f1c:	81 e0       	ldi	r24, 0x01	; 1
    2f1e:	d1 01       	movw	r26, r2
    2f20:	14 96       	adiw	r26, 0x04	; 4
    2f22:	8c 93       	st	X, r24
    2f24:	14 97       	sbiw	r26, 0x04	; 4
    2f26:	5e 96       	adiw	r26, 0x1e	; 30
    2f28:	4d 91       	ld	r20, X+
    2f2a:	5d 91       	ld	r21, X+
    2f2c:	6d 91       	ld	r22, X+
    2f2e:	7c 91       	ld	r23, X
    2f30:	91 97       	sbiw	r26, 0x21	; 33
    2f32:	c4 01       	movw	r24, r8
    2f34:	89 2f       	mov	r24, r25
    2f36:	99 27       	eor	r25, r25
    2f38:	86 95       	lsr	r24
    2f3a:	48 0f       	add	r20, r24
    2f3c:	59 1f       	adc	r21, r25
    2f3e:	61 1d       	adc	r22, r1
    2f40:	71 1d       	adc	r23, r1
    2f42:	c1 01       	movw	r24, r2
    2f44:	07 db       	rcall	.-2546   	; 0x2554 <move_window>
    2f46:	81 11       	cpse	r24, r1
    2f48:	7e c0       	rjmp	.+252    	; 0x3046 <put_fat+0x204>
    2f4a:	b1 e0       	ldi	r27, 0x01	; 1
    2f4c:	9b 22       	and	r9, r27
    2f4e:	f1 01       	movw	r30, r2
    2f50:	e8 0d       	add	r30, r8
    2f52:	f9 1d       	adc	r31, r9
    2f54:	29 81       	ldd	r18, Y+1	; 0x01
    2f56:	3a 81       	ldd	r19, Y+2	; 0x02
    2f58:	4b 81       	ldd	r20, Y+3	; 0x03
    2f5a:	5c 81       	ldd	r21, Y+4	; 0x04
    2f5c:	23 2b       	or	r18, r19
    2f5e:	24 2b       	or	r18, r20
    2f60:	25 2b       	or	r18, r21
    2f62:	41 f0       	breq	.+16     	; 0x2f74 <put_fat+0x132>
    2f64:	54 e0       	ldi	r21, 0x04	; 4
    2f66:	76 94       	lsr	r7
    2f68:	67 94       	ror	r6
    2f6a:	57 94       	ror	r5
    2f6c:	47 94       	ror	r4
    2f6e:	5a 95       	dec	r21
    2f70:	d1 f7       	brne	.-12     	; 0x2f66 <put_fat+0x124>
    2f72:	06 c0       	rjmp	.+12     	; 0x2f80 <put_fat+0x13e>
    2f74:	26 a5       	ldd	r18, Z+46	; 0x2e
    2f76:	20 7f       	andi	r18, 0xF0	; 240
    2f78:	95 2d       	mov	r25, r5
    2f7a:	9f 70       	andi	r25, 0x0F	; 15
    2f7c:	42 2e       	mov	r4, r18
    2f7e:	49 2a       	or	r4, r25
    2f80:	46 a6       	std	Z+46, r4	; 0x2e
    2f82:	5b c0       	rjmp	.+182    	; 0x303a <put_fat+0x1f8>
    2f84:	77 27       	eor	r23, r23
    2f86:	6f 2d       	mov	r22, r15
    2f88:	5e 2d       	mov	r21, r14
    2f8a:	4d 2d       	mov	r20, r13
    2f8c:	f1 01       	movw	r30, r2
    2f8e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f90:	97 8d       	ldd	r25, Z+31	; 0x1f
    2f92:	a0 a1       	ldd	r26, Z+32	; 0x20
    2f94:	b1 a1       	ldd	r27, Z+33	; 0x21
    2f96:	48 0f       	add	r20, r24
    2f98:	59 1f       	adc	r21, r25
    2f9a:	6a 1f       	adc	r22, r26
    2f9c:	7b 1f       	adc	r23, r27
    2f9e:	c1 01       	movw	r24, r2
    2fa0:	d9 da       	rcall	.-2638   	; 0x2554 <move_window>
    2fa2:	81 11       	cpse	r24, r1
    2fa4:	50 c0       	rjmp	.+160    	; 0x3046 <put_fat+0x204>
    2fa6:	cc 0c       	add	r12, r12
    2fa8:	dd 1c       	adc	r13, r13
    2faa:	ee 1c       	adc	r14, r14
    2fac:	ff 1c       	adc	r15, r15
    2fae:	e8 94       	clt
    2fb0:	c0 f8       	bld	r12, 0
    2fb2:	f1 e0       	ldi	r31, 0x01	; 1
    2fb4:	df 22       	and	r13, r31
    2fb6:	ee 24       	eor	r14, r14
    2fb8:	ff 24       	eor	r15, r15
    2fba:	2e e2       	ldi	r18, 0x2E	; 46
    2fbc:	c2 0e       	add	r12, r18
    2fbe:	d1 1c       	adc	r13, r1
    2fc0:	f1 01       	movw	r30, r2
    2fc2:	ec 0d       	add	r30, r12
    2fc4:	fd 1d       	adc	r31, r13
    2fc6:	51 82       	std	Z+1, r5	; 0x01
    2fc8:	40 82       	st	Z, r4
    2fca:	37 c0       	rjmp	.+110    	; 0x303a <put_fat+0x1f8>
    2fcc:	f1 01       	movw	r30, r2
    2fce:	86 8d       	ldd	r24, Z+30	; 0x1e
    2fd0:	97 8d       	ldd	r25, Z+31	; 0x1f
    2fd2:	a0 a1       	ldd	r26, Z+32	; 0x20
    2fd4:	b1 a1       	ldd	r27, Z+33	; 0x21
    2fd6:	27 e0       	ldi	r18, 0x07	; 7
    2fd8:	76 95       	lsr	r23
    2fda:	67 95       	ror	r22
    2fdc:	57 95       	ror	r21
    2fde:	47 95       	ror	r20
    2fe0:	2a 95       	dec	r18
    2fe2:	d1 f7       	brne	.-12     	; 0x2fd8 <put_fat+0x196>
    2fe4:	48 0f       	add	r20, r24
    2fe6:	59 1f       	adc	r21, r25
    2fe8:	6a 1f       	adc	r22, r26
    2fea:	7b 1f       	adc	r23, r27
    2fec:	c1 01       	movw	r24, r2
    2fee:	b2 da       	rcall	.-2716   	; 0x2554 <move_window>
    2ff0:	81 11       	cpse	r24, r1
    2ff2:	29 c0       	rjmp	.+82     	; 0x3046 <put_fat+0x204>
    2ff4:	92 e0       	ldi	r25, 0x02	; 2
    2ff6:	cc 0c       	add	r12, r12
    2ff8:	dd 1c       	adc	r13, r13
    2ffa:	ee 1c       	adc	r14, r14
    2ffc:	ff 1c       	adc	r15, r15
    2ffe:	9a 95       	dec	r25
    3000:	d1 f7       	brne	.-12     	; 0x2ff6 <put_fat+0x1b4>
    3002:	fc ef       	ldi	r31, 0xFC	; 252
    3004:	cf 22       	and	r12, r31
    3006:	f1 e0       	ldi	r31, 0x01	; 1
    3008:	df 22       	and	r13, r31
    300a:	ee 24       	eor	r14, r14
    300c:	ff 24       	eor	r15, r15
    300e:	2e e2       	ldi	r18, 0x2E	; 46
    3010:	c2 0e       	add	r12, r18
    3012:	d1 1c       	adc	r13, r1
    3014:	f1 01       	movw	r30, r2
    3016:	ec 0d       	add	r30, r12
    3018:	fd 1d       	adc	r31, r13
    301a:	40 81       	ld	r20, Z
    301c:	51 81       	ldd	r21, Z+1	; 0x01
    301e:	62 81       	ldd	r22, Z+2	; 0x02
    3020:	73 81       	ldd	r23, Z+3	; 0x03
    3022:	44 27       	eor	r20, r20
    3024:	55 27       	eor	r21, r21
    3026:	66 27       	eor	r22, r22
    3028:	70 7f       	andi	r23, 0xF0	; 240
    302a:	44 2a       	or	r4, r20
    302c:	55 2a       	or	r5, r21
    302e:	66 2a       	or	r6, r22
    3030:	77 2a       	or	r7, r23
    3032:	40 82       	st	Z, r4
    3034:	51 82       	std	Z+1, r5	; 0x01
    3036:	62 82       	std	Z+2, r6	; 0x02
    3038:	73 82       	std	Z+3, r7	; 0x03
    303a:	91 e0       	ldi	r25, 0x01	; 1
    303c:	d1 01       	movw	r26, r2
    303e:	14 96       	adiw	r26, 0x04	; 4
    3040:	9c 93       	st	X, r25
    3042:	01 c0       	rjmp	.+2      	; 0x3046 <put_fat+0x204>
    3044:	82 e0       	ldi	r24, 0x02	; 2
    3046:	0f 90       	pop	r0
    3048:	0f 90       	pop	r0
    304a:	0f 90       	pop	r0
    304c:	0f 90       	pop	r0
    304e:	df 91       	pop	r29
    3050:	cf 91       	pop	r28
    3052:	1f 91       	pop	r17
    3054:	0f 91       	pop	r16
    3056:	ff 90       	pop	r15
    3058:	ef 90       	pop	r14
    305a:	df 90       	pop	r13
    305c:	cf 90       	pop	r12
    305e:	bf 90       	pop	r11
    3060:	af 90       	pop	r10
    3062:	9f 90       	pop	r9
    3064:	8f 90       	pop	r8
    3066:	7f 90       	pop	r7
    3068:	6f 90       	pop	r6
    306a:	5f 90       	pop	r5
    306c:	4f 90       	pop	r4
    306e:	3f 90       	pop	r3
    3070:	2f 90       	pop	r2
    3072:	08 95       	ret

00003074 <create_chain>:
    3074:	4f 92       	push	r4
    3076:	5f 92       	push	r5
    3078:	6f 92       	push	r6
    307a:	7f 92       	push	r7
    307c:	8f 92       	push	r8
    307e:	9f 92       	push	r9
    3080:	af 92       	push	r10
    3082:	bf 92       	push	r11
    3084:	cf 92       	push	r12
    3086:	df 92       	push	r13
    3088:	ef 92       	push	r14
    308a:	ff 92       	push	r15
    308c:	0f 93       	push	r16
    308e:	1f 93       	push	r17
    3090:	cf 93       	push	r28
    3092:	df 93       	push	r29
    3094:	ec 01       	movw	r28, r24
    3096:	2a 01       	movw	r4, r20
    3098:	3b 01       	movw	r6, r22
    309a:	41 15       	cp	r20, r1
    309c:	51 05       	cpc	r21, r1
    309e:	61 05       	cpc	r22, r1
    30a0:	71 05       	cpc	r23, r1
    30a2:	99 f4       	brne	.+38     	; 0x30ca <create_chain+0x56>
    30a4:	8a 84       	ldd	r8, Y+10	; 0x0a
    30a6:	9b 84       	ldd	r9, Y+11	; 0x0b
    30a8:	ac 84       	ldd	r10, Y+12	; 0x0c
    30aa:	bd 84       	ldd	r11, Y+13	; 0x0d
    30ac:	81 14       	cp	r8, r1
    30ae:	91 04       	cpc	r9, r1
    30b0:	a1 04       	cpc	r10, r1
    30b2:	b1 04       	cpc	r11, r1
    30b4:	59 f1       	breq	.+86     	; 0x310c <create_chain+0x98>
    30b6:	8a 89       	ldd	r24, Y+18	; 0x12
    30b8:	9b 89       	ldd	r25, Y+19	; 0x13
    30ba:	ac 89       	ldd	r26, Y+20	; 0x14
    30bc:	bd 89       	ldd	r27, Y+21	; 0x15
    30be:	88 16       	cp	r8, r24
    30c0:	99 06       	cpc	r9, r25
    30c2:	aa 06       	cpc	r10, r26
    30c4:	bb 06       	cpc	r11, r27
    30c6:	30 f1       	brcs	.+76     	; 0x3114 <create_chain+0xa0>
    30c8:	21 c0       	rjmp	.+66     	; 0x310c <create_chain+0x98>
    30ca:	3f dd       	rcall	.-1410   	; 0x2b4a <get_fat>
    30cc:	6b 01       	movw	r12, r22
    30ce:	7c 01       	movw	r14, r24
    30d0:	62 30       	cpi	r22, 0x02	; 2
    30d2:	71 05       	cpc	r23, r1
    30d4:	81 05       	cpc	r24, r1
    30d6:	91 05       	cpc	r25, r1
    30d8:	08 f4       	brcc	.+2      	; 0x30dc <create_chain+0x68>
    30da:	8a c0       	rjmp	.+276    	; 0x31f0 <create_chain+0x17c>
    30dc:	8f ef       	ldi	r24, 0xFF	; 255
    30de:	c8 16       	cp	r12, r24
    30e0:	d8 06       	cpc	r13, r24
    30e2:	e8 06       	cpc	r14, r24
    30e4:	f8 06       	cpc	r15, r24
    30e6:	29 f4       	brne	.+10     	; 0x30f2 <create_chain+0x7e>
    30e8:	6f ef       	ldi	r22, 0xFF	; 255
    30ea:	7f ef       	ldi	r23, 0xFF	; 255
    30ec:	8f ef       	ldi	r24, 0xFF	; 255
    30ee:	9f ef       	ldi	r25, 0xFF	; 255
    30f0:	86 c0       	rjmp	.+268    	; 0x31fe <create_chain+0x18a>
    30f2:	8a 89       	ldd	r24, Y+18	; 0x12
    30f4:	9b 89       	ldd	r25, Y+19	; 0x13
    30f6:	ac 89       	ldd	r26, Y+20	; 0x14
    30f8:	bd 89       	ldd	r27, Y+21	; 0x15
    30fa:	c8 16       	cp	r12, r24
    30fc:	d9 06       	cpc	r13, r25
    30fe:	ea 06       	cpc	r14, r26
    3100:	fb 06       	cpc	r15, r27
    3102:	08 f4       	brcc	.+2      	; 0x3106 <create_chain+0x92>
    3104:	7a c0       	rjmp	.+244    	; 0x31fa <create_chain+0x186>
    3106:	53 01       	movw	r10, r6
    3108:	42 01       	movw	r8, r4
    310a:	04 c0       	rjmp	.+8      	; 0x3114 <create_chain+0xa0>
    310c:	81 2c       	mov	r8, r1
    310e:	91 2c       	mov	r9, r1
    3110:	54 01       	movw	r10, r8
    3112:	83 94       	inc	r8
    3114:	75 01       	movw	r14, r10
    3116:	64 01       	movw	r12, r8
    3118:	2f ef       	ldi	r18, 0xFF	; 255
    311a:	c2 1a       	sub	r12, r18
    311c:	d2 0a       	sbc	r13, r18
    311e:	e2 0a       	sbc	r14, r18
    3120:	f2 0a       	sbc	r15, r18
    3122:	8a 89       	ldd	r24, Y+18	; 0x12
    3124:	9b 89       	ldd	r25, Y+19	; 0x13
    3126:	ac 89       	ldd	r26, Y+20	; 0x14
    3128:	bd 89       	ldd	r27, Y+21	; 0x15
    312a:	c8 16       	cp	r12, r24
    312c:	d9 06       	cpc	r13, r25
    312e:	ea 06       	cpc	r14, r26
    3130:	fb 06       	cpc	r15, r27
    3132:	68 f0       	brcs	.+26     	; 0x314e <create_chain+0xda>
    3134:	82 e0       	ldi	r24, 0x02	; 2
    3136:	88 16       	cp	r8, r24
    3138:	91 04       	cpc	r9, r1
    313a:	a1 04       	cpc	r10, r1
    313c:	b1 04       	cpc	r11, r1
    313e:	10 f4       	brcc	.+4      	; 0x3144 <create_chain+0xd0>
    3140:	60 e0       	ldi	r22, 0x00	; 0
    3142:	57 c0       	rjmp	.+174    	; 0x31f2 <create_chain+0x17e>
    3144:	82 e0       	ldi	r24, 0x02	; 2
    3146:	c8 2e       	mov	r12, r24
    3148:	d1 2c       	mov	r13, r1
    314a:	e1 2c       	mov	r14, r1
    314c:	f1 2c       	mov	r15, r1
    314e:	b7 01       	movw	r22, r14
    3150:	a6 01       	movw	r20, r12
    3152:	ce 01       	movw	r24, r28
    3154:	fa dc       	rcall	.-1548   	; 0x2b4a <get_fat>
    3156:	8b 01       	movw	r16, r22
    3158:	9c 01       	movw	r18, r24
    315a:	67 2b       	or	r22, r23
    315c:	68 2b       	or	r22, r24
    315e:	69 2b       	or	r22, r25
    3160:	a1 f0       	breq	.+40     	; 0x318a <create_chain+0x116>
    3162:	0f 3f       	cpi	r16, 0xFF	; 255
    3164:	8f ef       	ldi	r24, 0xFF	; 255
    3166:	18 07       	cpc	r17, r24
    3168:	28 07       	cpc	r18, r24
    316a:	38 07       	cpc	r19, r24
    316c:	29 f0       	breq	.+10     	; 0x3178 <create_chain+0x104>
    316e:	01 30       	cpi	r16, 0x01	; 1
    3170:	11 05       	cpc	r17, r1
    3172:	21 05       	cpc	r18, r1
    3174:	31 05       	cpc	r19, r1
    3176:	19 f4       	brne	.+6      	; 0x317e <create_chain+0x10a>
    3178:	b8 01       	movw	r22, r16
    317a:	c9 01       	movw	r24, r18
    317c:	40 c0       	rjmp	.+128    	; 0x31fe <create_chain+0x18a>
    317e:	c8 14       	cp	r12, r8
    3180:	d9 04       	cpc	r13, r9
    3182:	ea 04       	cpc	r14, r10
    3184:	fb 04       	cpc	r15, r11
    3186:	41 f6       	brne	.-112    	; 0x3118 <create_chain+0xa4>
    3188:	db cf       	rjmp	.-74     	; 0x3140 <create_chain+0xcc>
    318a:	0f ef       	ldi	r16, 0xFF	; 255
    318c:	1f ef       	ldi	r17, 0xFF	; 255
    318e:	2f ef       	ldi	r18, 0xFF	; 255
    3190:	3f e0       	ldi	r19, 0x0F	; 15
    3192:	b7 01       	movw	r22, r14
    3194:	a6 01       	movw	r20, r12
    3196:	ce 01       	movw	r24, r28
    3198:	54 de       	rcall	.-856    	; 0x2e42 <put_fat>
    319a:	81 11       	cpse	r24, r1
    319c:	26 c0       	rjmp	.+76     	; 0x31ea <create_chain+0x176>
    319e:	41 14       	cp	r4, r1
    31a0:	51 04       	cpc	r5, r1
    31a2:	61 04       	cpc	r6, r1
    31a4:	71 04       	cpc	r7, r1
    31a6:	c9 f4       	brne	.+50     	; 0x31da <create_chain+0x166>
    31a8:	ca 86       	std	Y+10, r12	; 0x0a
    31aa:	db 86       	std	Y+11, r13	; 0x0b
    31ac:	ec 86       	std	Y+12, r14	; 0x0c
    31ae:	fd 86       	std	Y+13, r15	; 0x0d
    31b0:	8e 85       	ldd	r24, Y+14	; 0x0e
    31b2:	9f 85       	ldd	r25, Y+15	; 0x0f
    31b4:	a8 89       	ldd	r26, Y+16	; 0x10
    31b6:	b9 89       	ldd	r27, Y+17	; 0x11
    31b8:	8f 3f       	cpi	r24, 0xFF	; 255
    31ba:	2f ef       	ldi	r18, 0xFF	; 255
    31bc:	92 07       	cpc	r25, r18
    31be:	a2 07       	cpc	r26, r18
    31c0:	b2 07       	cpc	r27, r18
    31c2:	d9 f0       	breq	.+54     	; 0x31fa <create_chain+0x186>
    31c4:	01 97       	sbiw	r24, 0x01	; 1
    31c6:	a1 09       	sbc	r26, r1
    31c8:	b1 09       	sbc	r27, r1
    31ca:	8e 87       	std	Y+14, r24	; 0x0e
    31cc:	9f 87       	std	Y+15, r25	; 0x0f
    31ce:	a8 8b       	std	Y+16, r26	; 0x10
    31d0:	b9 8b       	std	Y+17, r27	; 0x11
    31d2:	8d 81       	ldd	r24, Y+5	; 0x05
    31d4:	81 60       	ori	r24, 0x01	; 1
    31d6:	8d 83       	std	Y+5, r24	; 0x05
    31d8:	10 c0       	rjmp	.+32     	; 0x31fa <create_chain+0x186>
    31da:	97 01       	movw	r18, r14
    31dc:	86 01       	movw	r16, r12
    31de:	b3 01       	movw	r22, r6
    31e0:	a2 01       	movw	r20, r4
    31e2:	ce 01       	movw	r24, r28
    31e4:	2e de       	rcall	.-932    	; 0x2e42 <put_fat>
    31e6:	88 23       	and	r24, r24
    31e8:	f9 f2       	breq	.-66     	; 0x31a8 <create_chain+0x134>
    31ea:	81 30       	cpi	r24, 0x01	; 1
    31ec:	09 f4       	brne	.+2      	; 0x31f0 <create_chain+0x17c>
    31ee:	7c cf       	rjmp	.-264    	; 0x30e8 <create_chain+0x74>
    31f0:	61 e0       	ldi	r22, 0x01	; 1
    31f2:	70 e0       	ldi	r23, 0x00	; 0
    31f4:	80 e0       	ldi	r24, 0x00	; 0
    31f6:	90 e0       	ldi	r25, 0x00	; 0
    31f8:	02 c0       	rjmp	.+4      	; 0x31fe <create_chain+0x18a>
    31fa:	b6 01       	movw	r22, r12
    31fc:	c7 01       	movw	r24, r14
    31fe:	df 91       	pop	r29
    3200:	cf 91       	pop	r28
    3202:	1f 91       	pop	r17
    3204:	0f 91       	pop	r16
    3206:	ff 90       	pop	r15
    3208:	ef 90       	pop	r14
    320a:	df 90       	pop	r13
    320c:	cf 90       	pop	r12
    320e:	bf 90       	pop	r11
    3210:	af 90       	pop	r10
    3212:	9f 90       	pop	r9
    3214:	8f 90       	pop	r8
    3216:	7f 90       	pop	r7
    3218:	6f 90       	pop	r6
    321a:	5f 90       	pop	r5
    321c:	4f 90       	pop	r4
    321e:	08 95       	ret

00003220 <dir_next>:
    3220:	7f 92       	push	r7
    3222:	8f 92       	push	r8
    3224:	9f 92       	push	r9
    3226:	af 92       	push	r10
    3228:	bf 92       	push	r11
    322a:	cf 92       	push	r12
    322c:	df 92       	push	r13
    322e:	ef 92       	push	r14
    3230:	ff 92       	push	r15
    3232:	0f 93       	push	r16
    3234:	1f 93       	push	r17
    3236:	cf 93       	push	r28
    3238:	df 93       	push	r29
    323a:	ec 01       	movw	r28, r24
    323c:	6b 01       	movw	r12, r22
    323e:	ec 80       	ldd	r14, Y+4	; 0x04
    3240:	fd 80       	ldd	r15, Y+5	; 0x05
    3242:	8f ef       	ldi	r24, 0xFF	; 255
    3244:	e8 1a       	sub	r14, r24
    3246:	f8 0a       	sbc	r15, r24
    3248:	11 f4       	brne	.+4      	; 0x324e <dir_next+0x2e>
    324a:	84 e0       	ldi	r24, 0x04	; 4
    324c:	db c0       	rjmp	.+438    	; 0x3404 <dir_next+0x1e4>
    324e:	4e 85       	ldd	r20, Y+14	; 0x0e
    3250:	5f 85       	ldd	r21, Y+15	; 0x0f
    3252:	68 89       	ldd	r22, Y+16	; 0x10
    3254:	79 89       	ldd	r23, Y+17	; 0x11
    3256:	41 15       	cp	r20, r1
    3258:	51 05       	cpc	r21, r1
    325a:	61 05       	cpc	r22, r1
    325c:	71 05       	cpc	r23, r1
    325e:	a9 f3       	breq	.-22     	; 0x324a <dir_next+0x2a>
    3260:	87 01       	movw	r16, r14
    3262:	0f 70       	andi	r16, 0x0F	; 15
    3264:	11 27       	eor	r17, r17
    3266:	01 15       	cp	r16, r1
    3268:	11 05       	cpc	r17, r1
    326a:	09 f0       	breq	.+2      	; 0x326e <dir_next+0x4e>
    326c:	b9 c0       	rjmp	.+370    	; 0x33e0 <dir_next+0x1c0>
    326e:	4f 5f       	subi	r20, 0xFF	; 255
    3270:	5f 4f       	sbci	r21, 0xFF	; 255
    3272:	6f 4f       	sbci	r22, 0xFF	; 255
    3274:	7f 4f       	sbci	r23, 0xFF	; 255
    3276:	4e 87       	std	Y+14, r20	; 0x0e
    3278:	5f 87       	std	Y+15, r21	; 0x0f
    327a:	68 8b       	std	Y+16, r22	; 0x10
    327c:	79 8b       	std	Y+17, r23	; 0x11
    327e:	4a 85       	ldd	r20, Y+10	; 0x0a
    3280:	5b 85       	ldd	r21, Y+11	; 0x0b
    3282:	6c 85       	ldd	r22, Y+12	; 0x0c
    3284:	7d 85       	ldd	r23, Y+13	; 0x0d
    3286:	88 81       	ld	r24, Y
    3288:	99 81       	ldd	r25, Y+1	; 0x01
    328a:	fc 01       	movw	r30, r24
    328c:	41 15       	cp	r20, r1
    328e:	51 05       	cpc	r21, r1
    3290:	61 05       	cpc	r22, r1
    3292:	71 05       	cpc	r23, r1
    3294:	31 f4       	brne	.+12     	; 0x32a2 <dir_next+0x82>
    3296:	80 85       	ldd	r24, Z+8	; 0x08
    3298:	91 85       	ldd	r25, Z+9	; 0x09
    329a:	e8 16       	cp	r14, r24
    329c:	f9 06       	cpc	r15, r25
    329e:	a8 f6       	brcc	.-86     	; 0x324a <dir_next+0x2a>
    32a0:	9f c0       	rjmp	.+318    	; 0x33e0 <dir_next+0x1c0>
    32a2:	22 81       	ldd	r18, Z+2	; 0x02
    32a4:	30 e0       	ldi	r19, 0x00	; 0
    32a6:	21 50       	subi	r18, 0x01	; 1
    32a8:	31 09       	sbc	r19, r1
    32aa:	f7 01       	movw	r30, r14
    32ac:	a4 e0       	ldi	r26, 0x04	; 4
    32ae:	f6 95       	lsr	r31
    32b0:	e7 95       	ror	r30
    32b2:	aa 95       	dec	r26
    32b4:	e1 f7       	brne	.-8      	; 0x32ae <dir_next+0x8e>
    32b6:	2e 23       	and	r18, r30
    32b8:	3f 23       	and	r19, r31
    32ba:	23 2b       	or	r18, r19
    32bc:	09 f0       	breq	.+2      	; 0x32c0 <dir_next+0xa0>
    32be:	90 c0       	rjmp	.+288    	; 0x33e0 <dir_next+0x1c0>
    32c0:	44 dc       	rcall	.-1912   	; 0x2b4a <get_fat>
    32c2:	4b 01       	movw	r8, r22
    32c4:	5c 01       	movw	r10, r24
    32c6:	62 30       	cpi	r22, 0x02	; 2
    32c8:	71 05       	cpc	r23, r1
    32ca:	81 05       	cpc	r24, r1
    32cc:	91 05       	cpc	r25, r1
    32ce:	10 f4       	brcc	.+4      	; 0x32d4 <dir_next+0xb4>
    32d0:	82 e0       	ldi	r24, 0x02	; 2
    32d2:	98 c0       	rjmp	.+304    	; 0x3404 <dir_next+0x1e4>
    32d4:	8f ef       	ldi	r24, 0xFF	; 255
    32d6:	88 16       	cp	r8, r24
    32d8:	98 06       	cpc	r9, r24
    32da:	a8 06       	cpc	r10, r24
    32dc:	b8 06       	cpc	r11, r24
    32de:	11 f4       	brne	.+4      	; 0x32e4 <dir_next+0xc4>
    32e0:	81 e0       	ldi	r24, 0x01	; 1
    32e2:	90 c0       	rjmp	.+288    	; 0x3404 <dir_next+0x1e4>
    32e4:	88 81       	ld	r24, Y
    32e6:	99 81       	ldd	r25, Y+1	; 0x01
    32e8:	fc 01       	movw	r30, r24
    32ea:	42 89       	ldd	r20, Z+18	; 0x12
    32ec:	53 89       	ldd	r21, Z+19	; 0x13
    32ee:	64 89       	ldd	r22, Z+20	; 0x14
    32f0:	75 89       	ldd	r23, Z+21	; 0x15
    32f2:	84 16       	cp	r8, r20
    32f4:	95 06       	cpc	r9, r21
    32f6:	a6 06       	cpc	r10, r22
    32f8:	b7 06       	cpc	r11, r23
    32fa:	08 f4       	brcc	.+2      	; 0x32fe <dir_next+0xde>
    32fc:	64 c0       	rjmp	.+200    	; 0x33c6 <dir_next+0x1a6>
    32fe:	cd 28       	or	r12, r13
    3300:	09 f4       	brne	.+2      	; 0x3304 <dir_next+0xe4>
    3302:	a3 cf       	rjmp	.-186    	; 0x324a <dir_next+0x2a>
    3304:	4a 85       	ldd	r20, Y+10	; 0x0a
    3306:	5b 85       	ldd	r21, Y+11	; 0x0b
    3308:	6c 85       	ldd	r22, Y+12	; 0x0c
    330a:	7d 85       	ldd	r23, Y+13	; 0x0d
    330c:	b3 de       	rcall	.-666    	; 0x3074 <create_chain>
    330e:	4b 01       	movw	r8, r22
    3310:	5c 01       	movw	r10, r24
    3312:	61 15       	cp	r22, r1
    3314:	71 05       	cpc	r23, r1
    3316:	81 05       	cpc	r24, r1
    3318:	91 05       	cpc	r25, r1
    331a:	09 f4       	brne	.+2      	; 0x331e <dir_next+0xfe>
    331c:	72 c0       	rjmp	.+228    	; 0x3402 <dir_next+0x1e2>
    331e:	61 30       	cpi	r22, 0x01	; 1
    3320:	71 05       	cpc	r23, r1
    3322:	81 05       	cpc	r24, r1
    3324:	91 05       	cpc	r25, r1
    3326:	a1 f2       	breq	.-88     	; 0x32d0 <dir_next+0xb0>
    3328:	8f ef       	ldi	r24, 0xFF	; 255
    332a:	88 16       	cp	r8, r24
    332c:	98 06       	cpc	r9, r24
    332e:	a8 06       	cpc	r10, r24
    3330:	b8 06       	cpc	r11, r24
    3332:	b1 f2       	breq	.-84     	; 0x32e0 <dir_next+0xc0>
    3334:	88 81       	ld	r24, Y
    3336:	99 81       	ldd	r25, Y+1	; 0x01
    3338:	45 d8       	rcall	.-3958   	; 0x23c4 <sync_window>
    333a:	81 11       	cpse	r24, r1
    333c:	d1 cf       	rjmp	.-94     	; 0x32e0 <dir_next+0xc0>
    333e:	88 81       	ld	r24, Y
    3340:	99 81       	ldd	r25, Y+1	; 0x01
    3342:	fc 01       	movw	r30, r24
    3344:	be 96       	adiw	r30, 0x2e	; 46
    3346:	82 5d       	subi	r24, 0xD2	; 210
    3348:	9d 4f       	sbci	r25, 0xFD	; 253
    334a:	e8 17       	cp	r30, r24
    334c:	f9 07       	cpc	r31, r25
    334e:	11 f0       	breq	.+4      	; 0x3354 <dir_next+0x134>
    3350:	11 92       	st	Z+, r1
    3352:	fb cf       	rjmp	.-10     	; 0x334a <dir_next+0x12a>
    3354:	c8 80       	ld	r12, Y
    3356:	d9 80       	ldd	r13, Y+1	; 0x01
    3358:	b5 01       	movw	r22, r10
    335a:	a4 01       	movw	r20, r8
    335c:	c6 01       	movw	r24, r12
    335e:	cd db       	rcall	.-2150   	; 0x2afa <clust2sect>
    3360:	f6 01       	movw	r30, r12
    3362:	62 a7       	std	Z+42, r22	; 0x2a
    3364:	73 a7       	std	Z+43, r23	; 0x2b
    3366:	84 a7       	std	Z+44, r24	; 0x2c
    3368:	95 a7       	std	Z+45, r25	; 0x2d
    336a:	c1 2c       	mov	r12, r1
    336c:	d1 2c       	mov	r13, r1
    336e:	77 24       	eor	r7, r7
    3370:	73 94       	inc	r7
    3372:	e8 81       	ld	r30, Y
    3374:	f9 81       	ldd	r31, Y+1	; 0x01
    3376:	82 81       	ldd	r24, Z+2	; 0x02
    3378:	90 e0       	ldi	r25, 0x00	; 0
    337a:	c8 16       	cp	r12, r24
    337c:	d9 06       	cpc	r13, r25
    337e:	b8 f4       	brcc	.+46     	; 0x33ae <dir_next+0x18e>
    3380:	74 82       	std	Z+4, r7	; 0x04
    3382:	88 81       	ld	r24, Y
    3384:	99 81       	ldd	r25, Y+1	; 0x01
    3386:	1e d8       	rcall	.-4036   	; 0x23c4 <sync_window>
    3388:	81 11       	cpse	r24, r1
    338a:	aa cf       	rjmp	.-172    	; 0x32e0 <dir_next+0xc0>
    338c:	e8 81       	ld	r30, Y
    338e:	f9 81       	ldd	r31, Y+1	; 0x01
    3390:	82 a5       	ldd	r24, Z+42	; 0x2a
    3392:	93 a5       	ldd	r25, Z+43	; 0x2b
    3394:	a4 a5       	ldd	r26, Z+44	; 0x2c
    3396:	b5 a5       	ldd	r27, Z+45	; 0x2d
    3398:	01 96       	adiw	r24, 0x01	; 1
    339a:	a1 1d       	adc	r26, r1
    339c:	b1 1d       	adc	r27, r1
    339e:	82 a7       	std	Z+42, r24	; 0x2a
    33a0:	93 a7       	std	Z+43, r25	; 0x2b
    33a2:	a4 a7       	std	Z+44, r26	; 0x2c
    33a4:	b5 a7       	std	Z+45, r27	; 0x2d
    33a6:	ff ef       	ldi	r31, 0xFF	; 255
    33a8:	cf 1a       	sub	r12, r31
    33aa:	df 0a       	sbc	r13, r31
    33ac:	e2 cf       	rjmp	.-60     	; 0x3372 <dir_next+0x152>
    33ae:	82 a5       	ldd	r24, Z+42	; 0x2a
    33b0:	93 a5       	ldd	r25, Z+43	; 0x2b
    33b2:	a4 a5       	ldd	r26, Z+44	; 0x2c
    33b4:	b5 a5       	ldd	r27, Z+45	; 0x2d
    33b6:	8c 19       	sub	r24, r12
    33b8:	9d 09       	sbc	r25, r13
    33ba:	a1 09       	sbc	r26, r1
    33bc:	b1 09       	sbc	r27, r1
    33be:	82 a7       	std	Z+42, r24	; 0x2a
    33c0:	93 a7       	std	Z+43, r25	; 0x2b
    33c2:	a4 a7       	std	Z+44, r26	; 0x2c
    33c4:	b5 a7       	std	Z+45, r27	; 0x2d
    33c6:	8a 86       	std	Y+10, r8	; 0x0a
    33c8:	9b 86       	std	Y+11, r9	; 0x0b
    33ca:	ac 86       	std	Y+12, r10	; 0x0c
    33cc:	bd 86       	std	Y+13, r11	; 0x0d
    33ce:	b5 01       	movw	r22, r10
    33d0:	a4 01       	movw	r20, r8
    33d2:	88 81       	ld	r24, Y
    33d4:	99 81       	ldd	r25, Y+1	; 0x01
    33d6:	91 db       	rcall	.-2270   	; 0x2afa <clust2sect>
    33d8:	6e 87       	std	Y+14, r22	; 0x0e
    33da:	7f 87       	std	Y+15, r23	; 0x0f
    33dc:	88 8b       	std	Y+16, r24	; 0x10
    33de:	99 8b       	std	Y+17, r25	; 0x11
    33e0:	fd 82       	std	Y+5, r15	; 0x05
    33e2:	ec 82       	std	Y+4, r14	; 0x04
    33e4:	85 e0       	ldi	r24, 0x05	; 5
    33e6:	00 0f       	add	r16, r16
    33e8:	11 1f       	adc	r17, r17
    33ea:	8a 95       	dec	r24
    33ec:	e1 f7       	brne	.-8      	; 0x33e6 <dir_next+0x1c6>
    33ee:	02 5d       	subi	r16, 0xD2	; 210
    33f0:	1f 4f       	sbci	r17, 0xFF	; 255
    33f2:	88 81       	ld	r24, Y
    33f4:	99 81       	ldd	r25, Y+1	; 0x01
    33f6:	08 0f       	add	r16, r24
    33f8:	19 1f       	adc	r17, r25
    33fa:	1b 8b       	std	Y+19, r17	; 0x13
    33fc:	0a 8b       	std	Y+18, r16	; 0x12
    33fe:	80 e0       	ldi	r24, 0x00	; 0
    3400:	01 c0       	rjmp	.+2      	; 0x3404 <dir_next+0x1e4>
    3402:	87 e0       	ldi	r24, 0x07	; 7
    3404:	df 91       	pop	r29
    3406:	cf 91       	pop	r28
    3408:	1f 91       	pop	r17
    340a:	0f 91       	pop	r16
    340c:	ff 90       	pop	r15
    340e:	ef 90       	pop	r14
    3410:	df 90       	pop	r13
    3412:	cf 90       	pop	r12
    3414:	bf 90       	pop	r11
    3416:	af 90       	pop	r10
    3418:	9f 90       	pop	r9
    341a:	8f 90       	pop	r8
    341c:	7f 90       	pop	r7
    341e:	08 95       	ret

00003420 <follow_path>:
    3420:	4f 92       	push	r4
    3422:	5f 92       	push	r5
    3424:	6f 92       	push	r6
    3426:	7f 92       	push	r7
    3428:	9f 92       	push	r9
    342a:	af 92       	push	r10
    342c:	bf 92       	push	r11
    342e:	cf 92       	push	r12
    3430:	df 92       	push	r13
    3432:	ef 92       	push	r14
    3434:	ff 92       	push	r15
    3436:	0f 93       	push	r16
    3438:	1f 93       	push	r17
    343a:	cf 93       	push	r28
    343c:	df 93       	push	r29
    343e:	ec 01       	movw	r28, r24
    3440:	8b 01       	movw	r16, r22
    3442:	db 01       	movw	r26, r22
    3444:	8c 91       	ld	r24, X
    3446:	8f 32       	cpi	r24, 0x2F	; 47
    3448:	11 f0       	breq	.+4      	; 0x344e <follow_path+0x2e>
    344a:	8c 35       	cpi	r24, 0x5C	; 92
    344c:	11 f4       	brne	.+4      	; 0x3452 <follow_path+0x32>
    344e:	0f 5f       	subi	r16, 0xFF	; 255
    3450:	1f 4f       	sbci	r17, 0xFF	; 255
    3452:	1e 82       	std	Y+6, r1	; 0x06
    3454:	1f 82       	std	Y+7, r1	; 0x07
    3456:	18 86       	std	Y+8, r1	; 0x08
    3458:	19 86       	std	Y+9, r1	; 0x09
    345a:	f8 01       	movw	r30, r16
    345c:	80 81       	ld	r24, Z
    345e:	80 32       	cpi	r24, 0x20	; 32
    3460:	28 f0       	brcs	.+10     	; 0x346c <follow_path+0x4c>
    3462:	70 e2       	ldi	r23, 0x20	; 32
    3464:	a7 2e       	mov	r10, r23
    3466:	e5 e0       	ldi	r30, 0x05	; 5
    3468:	be 2e       	mov	r11, r30
    346a:	62 c0       	rjmp	.+196    	; 0x3530 <follow_path+0x110>
    346c:	60 e0       	ldi	r22, 0x00	; 0
    346e:	70 e0       	ldi	r23, 0x00	; 0
    3470:	ce 01       	movw	r24, r28
    3472:	36 dc       	rcall	.-1940   	; 0x2ce0 <dir_sdi>
    3474:	1b 8a       	std	Y+19, r1	; 0x13
    3476:	1a 8a       	std	Y+18, r1	; 0x12
    3478:	f4 c0       	rjmp	.+488    	; 0x3662 <follow_path+0x242>
    347a:	82 01       	movw	r16, r4
    347c:	20 e0       	ldi	r18, 0x00	; 0
    347e:	30 e0       	ldi	r19, 0x00	; 0
    3480:	80 e0       	ldi	r24, 0x00	; 0
    3482:	90 e0       	ldi	r25, 0x00	; 0
    3484:	48 e0       	ldi	r20, 0x08	; 8
    3486:	50 e0       	ldi	r21, 0x00	; 0
    3488:	91 2c       	mov	r9, r1
    348a:	01 96       	adiw	r24, 0x01	; 1
    348c:	d8 01       	movw	r26, r16
    348e:	7d 91       	ld	r23, X+
    3490:	8d 01       	movw	r16, r26
    3492:	71 32       	cpi	r23, 0x21	; 33
    3494:	08 f0       	brcs	.+2      	; 0x3498 <follow_path+0x78>
    3496:	63 c0       	rjmp	.+198    	; 0x355e <follow_path+0x13e>
    3498:	82 01       	movw	r16, r4
    349a:	08 0f       	add	r16, r24
    349c:	19 1f       	adc	r17, r25
    349e:	71 32       	cpi	r23, 0x21	; 33
    34a0:	08 f4       	brcc	.+2      	; 0x34a4 <follow_path+0x84>
    34a2:	87 c0       	rjmp	.+270    	; 0x35b2 <follow_path+0x192>
    34a4:	80 e0       	ldi	r24, 0x00	; 0
    34a6:	23 2b       	or	r18, r19
    34a8:	09 f4       	brne	.+2      	; 0x34ac <follow_path+0x8c>
    34aa:	b7 c0       	rjmp	.+366    	; 0x361a <follow_path+0x1fa>
    34ac:	90 81       	ld	r25, Z
    34ae:	95 3e       	cpi	r25, 0xE5	; 229
    34b0:	09 f4       	brne	.+2      	; 0x34b4 <follow_path+0x94>
    34b2:	b0 82       	st	Z, r11
    34b4:	48 30       	cpi	r20, 0x08	; 8
    34b6:	51 05       	cpc	r21, r1
    34b8:	11 f4       	brne	.+4      	; 0x34be <follow_path+0x9e>
    34ba:	99 0c       	add	r9, r9
    34bc:	99 0c       	add	r9, r9
    34be:	99 2d       	mov	r25, r9
    34c0:	93 70       	andi	r25, 0x03	; 3
    34c2:	91 30       	cpi	r25, 0x01	; 1
    34c4:	09 f4       	brne	.+2      	; 0x34c8 <follow_path+0xa8>
    34c6:	80 61       	ori	r24, 0x10	; 16
    34c8:	99 2d       	mov	r25, r9
    34ca:	9c 70       	andi	r25, 0x0C	; 12
    34cc:	94 30       	cpi	r25, 0x04	; 4
    34ce:	09 f4       	brne	.+2      	; 0x34d2 <follow_path+0xb2>
    34d0:	88 60       	ori	r24, 0x08	; 8
    34d2:	83 87       	std	Z+11, r24	; 0x0b
    34d4:	60 e0       	ldi	r22, 0x00	; 0
    34d6:	70 e0       	ldi	r23, 0x00	; 0
    34d8:	ce 01       	movw	r24, r28
    34da:	02 dc       	rcall	.-2044   	; 0x2ce0 <dir_sdi>
    34dc:	88 23       	and	r24, r24
    34de:	09 f4       	brne	.+2      	; 0x34e2 <follow_path+0xc2>
    34e0:	6a c0       	rjmp	.+212    	; 0x35b6 <follow_path+0x196>
    34e2:	ec 89       	ldd	r30, Y+20	; 0x14
    34e4:	fd 89       	ldd	r31, Y+21	; 0x15
    34e6:	93 85       	ldd	r25, Z+11	; 0x0b
    34e8:	81 11       	cpse	r24, r1
    34ea:	8e c0       	rjmp	.+284    	; 0x3608 <follow_path+0x1e8>
    34ec:	92 fd       	sbrc	r25, 2
    34ee:	91 c0       	rjmp	.+290    	; 0x3612 <follow_path+0x1f2>
    34f0:	4a 89       	ldd	r20, Y+18	; 0x12
    34f2:	5b 89       	ldd	r21, Y+19	; 0x13
    34f4:	fa 01       	movw	r30, r20
    34f6:	83 85       	ldd	r24, Z+11	; 0x0b
    34f8:	84 ff       	sbrs	r24, 4
    34fa:	8d c0       	rjmp	.+282    	; 0x3616 <follow_path+0x1f6>
    34fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    34fe:	93 8d       	ldd	r25, Z+27	; 0x1b
    3500:	a0 e0       	ldi	r26, 0x00	; 0
    3502:	b0 e0       	ldi	r27, 0x00	; 0
    3504:	28 81       	ld	r18, Y
    3506:	39 81       	ldd	r19, Y+1	; 0x01
    3508:	f9 01       	movw	r30, r18
    350a:	20 81       	ld	r18, Z
    350c:	23 30       	cpi	r18, 0x03	; 3
    350e:	61 f4       	brne	.+24     	; 0x3528 <follow_path+0x108>
    3510:	fa 01       	movw	r30, r20
    3512:	44 89       	ldd	r20, Z+20	; 0x14
    3514:	55 89       	ldd	r21, Z+21	; 0x15
    3516:	60 e0       	ldi	r22, 0x00	; 0
    3518:	70 e0       	ldi	r23, 0x00	; 0
    351a:	ba 01       	movw	r22, r20
    351c:	55 27       	eor	r21, r21
    351e:	44 27       	eor	r20, r20
    3520:	84 2b       	or	r24, r20
    3522:	95 2b       	or	r25, r21
    3524:	a6 2b       	or	r26, r22
    3526:	b7 2b       	or	r27, r23
    3528:	8e 83       	std	Y+6, r24	; 0x06
    352a:	9f 83       	std	Y+7, r25	; 0x07
    352c:	a8 87       	std	Y+8, r26	; 0x08
    352e:	b9 87       	std	Y+9, r27	; 0x09
    3530:	28 01       	movw	r4, r16
    3532:	d8 01       	movw	r26, r16
    3534:	9c 91       	ld	r25, X
    3536:	0f 5f       	subi	r16, 0xFF	; 255
    3538:	1f 4f       	sbci	r17, 0xFF	; 255
    353a:	9f 32       	cpi	r25, 0x2F	; 47
    353c:	c9 f3       	breq	.-14     	; 0x3530 <follow_path+0x110>
    353e:	9c 35       	cpi	r25, 0x5C	; 92
    3540:	b9 f3       	breq	.-18     	; 0x3530 <follow_path+0x110>
    3542:	ec 89       	ldd	r30, Y+20	; 0x14
    3544:	fd 89       	ldd	r31, Y+21	; 0x15
    3546:	cf 01       	movw	r24, r30
    3548:	9f 01       	movw	r18, r30
    354a:	25 5f       	subi	r18, 0xF5	; 245
    354c:	3f 4f       	sbci	r19, 0xFF	; 255
    354e:	82 17       	cp	r24, r18
    3550:	93 07       	cpc	r25, r19
    3552:	09 f4       	brne	.+2      	; 0x3556 <follow_path+0x136>
    3554:	92 cf       	rjmp	.-220    	; 0x347a <follow_path+0x5a>
    3556:	dc 01       	movw	r26, r24
    3558:	ad 92       	st	X+, r10
    355a:	cd 01       	movw	r24, r26
    355c:	f8 cf       	rjmp	.-16     	; 0x354e <follow_path+0x12e>
    355e:	7f 32       	cpi	r23, 0x2F	; 47
    3560:	09 f4       	brne	.+2      	; 0x3564 <follow_path+0x144>
    3562:	9a cf       	rjmp	.-204    	; 0x3498 <follow_path+0x78>
    3564:	7c 35       	cpi	r23, 0x5C	; 92
    3566:	09 f4       	brne	.+2      	; 0x356a <follow_path+0x14a>
    3568:	97 cf       	rjmp	.-210    	; 0x3498 <follow_path+0x78>
    356a:	7e 32       	cpi	r23, 0x2E	; 46
    356c:	09 f4       	brne	.+2      	; 0x3570 <follow_path+0x150>
    356e:	57 c0       	rjmp	.+174    	; 0x361e <follow_path+0x1fe>
    3570:	24 17       	cp	r18, r20
    3572:	35 07       	cpc	r19, r21
    3574:	08 f0       	brcs	.+2      	; 0x3578 <follow_path+0x158>
    3576:	51 c0       	rjmp	.+162    	; 0x361a <follow_path+0x1fa>
    3578:	77 ff       	sbrs	r23, 7
    357a:	09 c0       	rjmp	.+18     	; 0x358e <follow_path+0x16e>
    357c:	b9 2d       	mov	r27, r9
    357e:	b3 60       	ori	r27, 0x03	; 3
    3580:	9b 2e       	mov	r9, r27
    3582:	67 2f       	mov	r22, r23
    3584:	70 e0       	ldi	r23, 0x00	; 0
    3586:	6d 5d       	subi	r22, 0xDD	; 221
    3588:	7d 4f       	sbci	r23, 0xFD	; 253
    358a:	db 01       	movw	r26, r22
    358c:	7c 91       	ld	r23, X
    358e:	c7 2e       	mov	r12, r23
    3590:	d1 2c       	mov	r13, r1
    3592:	64 e9       	ldi	r22, 0x94	; 148
    3594:	e6 2e       	mov	r14, r22
    3596:	62 e0       	ldi	r22, 0x02	; 2
    3598:	f6 2e       	mov	r15, r22
    359a:	d7 01       	movw	r26, r14
    359c:	6d 91       	ld	r22, X+
    359e:	7d 01       	movw	r14, r26
    35a0:	66 23       	and	r22, r22
    35a2:	09 f4       	brne	.+2      	; 0x35a6 <follow_path+0x186>
    35a4:	46 c0       	rjmp	.+140    	; 0x3632 <follow_path+0x212>
    35a6:	66 2e       	mov	r6, r22
    35a8:	71 2c       	mov	r7, r1
    35aa:	6c 14       	cp	r6, r12
    35ac:	7d 04       	cpc	r7, r13
    35ae:	a9 f7       	brne	.-22     	; 0x359a <follow_path+0x17a>
    35b0:	34 c0       	rjmp	.+104    	; 0x361a <follow_path+0x1fa>
    35b2:	84 e0       	ldi	r24, 0x04	; 4
    35b4:	78 cf       	rjmp	.-272    	; 0x34a6 <follow_path+0x86>
    35b6:	4e 85       	ldd	r20, Y+14	; 0x0e
    35b8:	5f 85       	ldd	r21, Y+15	; 0x0f
    35ba:	68 89       	ldd	r22, Y+16	; 0x10
    35bc:	79 89       	ldd	r23, Y+17	; 0x11
    35be:	88 81       	ld	r24, Y
    35c0:	99 81       	ldd	r25, Y+1	; 0x01
    35c2:	0e 94 aa 12 	call	0x2554	; 0x2554 <move_window>
    35c6:	81 11       	cpse	r24, r1
    35c8:	8c cf       	rjmp	.-232    	; 0x34e2 <follow_path+0xc2>
    35ca:	ea 89       	ldd	r30, Y+18	; 0x12
    35cc:	fb 89       	ldd	r31, Y+19	; 0x13
    35ce:	80 81       	ld	r24, Z
    35d0:	88 23       	and	r24, r24
    35d2:	b1 f0       	breq	.+44     	; 0x3600 <follow_path+0x1e0>
    35d4:	83 85       	ldd	r24, Z+11	; 0x0b
    35d6:	83 fd       	sbrc	r24, 3
    35d8:	0e c0       	rjmp	.+28     	; 0x35f6 <follow_path+0x1d6>
    35da:	ac 89       	ldd	r26, Y+20	; 0x14
    35dc:	bd 89       	ldd	r27, Y+21	; 0x15
    35de:	af 01       	movw	r20, r30
    35e0:	45 5f       	subi	r20, 0xF5	; 245
    35e2:	5f 4f       	sbci	r21, 0xFF	; 255
    35e4:	e4 17       	cp	r30, r20
    35e6:	f5 07       	cpc	r31, r21
    35e8:	69 f0       	breq	.+26     	; 0x3604 <follow_path+0x1e4>
    35ea:	81 91       	ld	r24, Z+
    35ec:	2d 91       	ld	r18, X+
    35ee:	90 e0       	ldi	r25, 0x00	; 0
    35f0:	82 1b       	sub	r24, r18
    35f2:	91 09       	sbc	r25, r1
    35f4:	b9 f3       	breq	.-18     	; 0x35e4 <follow_path+0x1c4>
    35f6:	60 e0       	ldi	r22, 0x00	; 0
    35f8:	70 e0       	ldi	r23, 0x00	; 0
    35fa:	ce 01       	movw	r24, r28
    35fc:	11 de       	rcall	.-990    	; 0x3220 <dir_next>
    35fe:	6e cf       	rjmp	.-292    	; 0x34dc <follow_path+0xbc>
    3600:	84 e0       	ldi	r24, 0x04	; 4
    3602:	6f cf       	rjmp	.-290    	; 0x34e2 <follow_path+0xc2>
    3604:	80 e0       	ldi	r24, 0x00	; 0
    3606:	6d cf       	rjmp	.-294    	; 0x34e2 <follow_path+0xc2>
    3608:	84 30       	cpi	r24, 0x04	; 4
    360a:	59 f5       	brne	.+86     	; 0x3662 <follow_path+0x242>
    360c:	92 ff       	sbrs	r25, 2
    360e:	03 c0       	rjmp	.+6      	; 0x3616 <follow_path+0x1f6>
    3610:	28 c0       	rjmp	.+80     	; 0x3662 <follow_path+0x242>
    3612:	80 e0       	ldi	r24, 0x00	; 0
    3614:	26 c0       	rjmp	.+76     	; 0x3662 <follow_path+0x242>
    3616:	85 e0       	ldi	r24, 0x05	; 5
    3618:	24 c0       	rjmp	.+72     	; 0x3662 <follow_path+0x242>
    361a:	86 e0       	ldi	r24, 0x06	; 6
    361c:	22 c0       	rjmp	.+68     	; 0x3662 <follow_path+0x242>
    361e:	48 30       	cpi	r20, 0x08	; 8
    3620:	51 05       	cpc	r21, r1
    3622:	d9 f7       	brne	.-10     	; 0x361a <follow_path+0x1fa>
    3624:	99 0c       	add	r9, r9
    3626:	99 0c       	add	r9, r9
    3628:	28 e0       	ldi	r18, 0x08	; 8
    362a:	30 e0       	ldi	r19, 0x00	; 0
    362c:	4b e0       	ldi	r20, 0x0B	; 11
    362e:	50 e0       	ldi	r21, 0x00	; 0
    3630:	2c cf       	rjmp	.-424    	; 0x348a <follow_path+0x6a>
    3632:	6f eb       	ldi	r22, 0xBF	; 191
    3634:	67 0f       	add	r22, r23
    3636:	6a 31       	cpi	r22, 0x1A	; 26
    3638:	20 f4       	brcc	.+8      	; 0x3642 <follow_path+0x222>
    363a:	b9 2d       	mov	r27, r9
    363c:	b2 60       	ori	r27, 0x02	; 2
    363e:	9b 2e       	mov	r9, r27
    3640:	08 c0       	rjmp	.+16     	; 0x3652 <follow_path+0x232>
    3642:	6f e9       	ldi	r22, 0x9F	; 159
    3644:	67 0f       	add	r22, r23
    3646:	6a 31       	cpi	r22, 0x1A	; 26
    3648:	20 f4       	brcc	.+8      	; 0x3652 <follow_path+0x232>
    364a:	69 2d       	mov	r22, r9
    364c:	61 60       	ori	r22, 0x01	; 1
    364e:	96 2e       	mov	r9, r22
    3650:	70 52       	subi	r23, 0x20	; 32
    3652:	7f 01       	movw	r14, r30
    3654:	e2 0e       	add	r14, r18
    3656:	f3 1e       	adc	r15, r19
    3658:	d7 01       	movw	r26, r14
    365a:	7c 93       	st	X, r23
    365c:	2f 5f       	subi	r18, 0xFF	; 255
    365e:	3f 4f       	sbci	r19, 0xFF	; 255
    3660:	14 cf       	rjmp	.-472    	; 0x348a <follow_path+0x6a>
    3662:	df 91       	pop	r29
    3664:	cf 91       	pop	r28
    3666:	1f 91       	pop	r17
    3668:	0f 91       	pop	r16
    366a:	ff 90       	pop	r15
    366c:	ef 90       	pop	r14
    366e:	df 90       	pop	r13
    3670:	cf 90       	pop	r12
    3672:	bf 90       	pop	r11
    3674:	af 90       	pop	r10
    3676:	9f 90       	pop	r9
    3678:	7f 90       	pop	r7
    367a:	6f 90       	pop	r6
    367c:	5f 90       	pop	r5
    367e:	4f 90       	pop	r4
    3680:	08 95       	ret

00003682 <dir_register>:
    3682:	1f 93       	push	r17
    3684:	cf 93       	push	r28
    3686:	df 93       	push	r29
    3688:	ec 01       	movw	r28, r24
    368a:	60 e0       	ldi	r22, 0x00	; 0
    368c:	70 e0       	ldi	r23, 0x00	; 0
    368e:	28 db       	rcall	.-2480   	; 0x2ce0 <dir_sdi>
    3690:	18 2f       	mov	r17, r24
    3692:	81 11       	cpse	r24, r1
    3694:	17 c0       	rjmp	.+46     	; 0x36c4 <dir_register+0x42>
    3696:	4e 85       	ldd	r20, Y+14	; 0x0e
    3698:	5f 85       	ldd	r21, Y+15	; 0x0f
    369a:	68 89       	ldd	r22, Y+16	; 0x10
    369c:	79 89       	ldd	r23, Y+17	; 0x11
    369e:	88 81       	ld	r24, Y
    36a0:	99 81       	ldd	r25, Y+1	; 0x01
    36a2:	0e 94 aa 12 	call	0x2554	; 0x2554 <move_window>
    36a6:	18 2f       	mov	r17, r24
    36a8:	81 11       	cpse	r24, r1
    36aa:	0c c0       	rjmp	.+24     	; 0x36c4 <dir_register+0x42>
    36ac:	ea 89       	ldd	r30, Y+18	; 0x12
    36ae:	fb 89       	ldd	r31, Y+19	; 0x13
    36b0:	80 81       	ld	r24, Z
    36b2:	85 3e       	cpi	r24, 0xE5	; 229
    36b4:	59 f0       	breq	.+22     	; 0x36cc <dir_register+0x4a>
    36b6:	88 23       	and	r24, r24
    36b8:	49 f0       	breq	.+18     	; 0x36cc <dir_register+0x4a>
    36ba:	61 e0       	ldi	r22, 0x01	; 1
    36bc:	70 e0       	ldi	r23, 0x00	; 0
    36be:	ce 01       	movw	r24, r28
    36c0:	af dd       	rcall	.-1186   	; 0x3220 <dir_next>
    36c2:	e6 cf       	rjmp	.-52     	; 0x3690 <dir_register+0xe>
    36c4:	14 30       	cpi	r17, 0x04	; 4
    36c6:	11 f5       	brne	.+68     	; 0x370c <dir_register+0x8a>
    36c8:	17 e0       	ldi	r17, 0x07	; 7
    36ca:	20 c0       	rjmp	.+64     	; 0x370c <dir_register+0x8a>
    36cc:	4e 85       	ldd	r20, Y+14	; 0x0e
    36ce:	5f 85       	ldd	r21, Y+15	; 0x0f
    36d0:	68 89       	ldd	r22, Y+16	; 0x10
    36d2:	79 89       	ldd	r23, Y+17	; 0x11
    36d4:	88 81       	ld	r24, Y
    36d6:	99 81       	ldd	r25, Y+1	; 0x01
    36d8:	0e 94 aa 12 	call	0x2554	; 0x2554 <move_window>
    36dc:	18 2f       	mov	r17, r24
    36de:	81 11       	cpse	r24, r1
    36e0:	15 c0       	rjmp	.+42     	; 0x370c <dir_register+0x8a>
    36e2:	ea 89       	ldd	r30, Y+18	; 0x12
    36e4:	fb 89       	ldd	r31, Y+19	; 0x13
    36e6:	cf 01       	movw	r24, r30
    36e8:	80 96       	adiw	r24, 0x20	; 32
    36ea:	e8 17       	cp	r30, r24
    36ec:	f9 07       	cpc	r31, r25
    36ee:	11 f0       	breq	.+4      	; 0x36f4 <dir_register+0x72>
    36f0:	11 92       	st	Z+, r1
    36f2:	fb cf       	rjmp	.-10     	; 0x36ea <dir_register+0x68>
    36f4:	6c 89       	ldd	r22, Y+20	; 0x14
    36f6:	7d 89       	ldd	r23, Y+21	; 0x15
    36f8:	4b e0       	ldi	r20, 0x0B	; 11
    36fa:	50 e0       	ldi	r21, 0x00	; 0
    36fc:	8a 89       	ldd	r24, Y+18	; 0x12
    36fe:	9b 89       	ldd	r25, Y+19	; 0x13
    3700:	0e 94 3b 11 	call	0x2276	; 0x2276 <mem_cpy>
    3704:	e8 81       	ld	r30, Y
    3706:	f9 81       	ldd	r31, Y+1	; 0x01
    3708:	81 e0       	ldi	r24, 0x01	; 1
    370a:	84 83       	std	Z+4, r24	; 0x04
    370c:	81 2f       	mov	r24, r17
    370e:	df 91       	pop	r29
    3710:	cf 91       	pop	r28
    3712:	1f 91       	pop	r17
    3714:	08 95       	ret

00003716 <remove_chain>:
    3716:	8f 92       	push	r8
    3718:	9f 92       	push	r9
    371a:	af 92       	push	r10
    371c:	bf 92       	push	r11
    371e:	cf 92       	push	r12
    3720:	df 92       	push	r13
    3722:	ef 92       	push	r14
    3724:	ff 92       	push	r15
    3726:	0f 93       	push	r16
    3728:	1f 93       	push	r17
    372a:	cf 93       	push	r28
    372c:	df 93       	push	r29
    372e:	ec 01       	movw	r28, r24
    3730:	6a 01       	movw	r12, r20
    3732:	7b 01       	movw	r14, r22
    3734:	42 30       	cpi	r20, 0x02	; 2
    3736:	51 05       	cpc	r21, r1
    3738:	61 05       	cpc	r22, r1
    373a:	71 05       	cpc	r23, r1
    373c:	10 f4       	brcc	.+4      	; 0x3742 <remove_chain+0x2c>
    373e:	82 e0       	ldi	r24, 0x02	; 2
    3740:	4b c0       	rjmp	.+150    	; 0x37d8 <remove_chain+0xc2>
    3742:	8a 89       	ldd	r24, Y+18	; 0x12
    3744:	9b 89       	ldd	r25, Y+19	; 0x13
    3746:	ac 89       	ldd	r26, Y+20	; 0x14
    3748:	bd 89       	ldd	r27, Y+21	; 0x15
    374a:	48 17       	cp	r20, r24
    374c:	59 07       	cpc	r21, r25
    374e:	6a 07       	cpc	r22, r26
    3750:	7b 07       	cpc	r23, r27
    3752:	a8 f7       	brcc	.-22     	; 0x373e <remove_chain+0x28>
    3754:	8a 89       	ldd	r24, Y+18	; 0x12
    3756:	9b 89       	ldd	r25, Y+19	; 0x13
    3758:	ac 89       	ldd	r26, Y+20	; 0x14
    375a:	bd 89       	ldd	r27, Y+21	; 0x15
    375c:	c8 16       	cp	r12, r24
    375e:	d9 06       	cpc	r13, r25
    3760:	ea 06       	cpc	r14, r26
    3762:	fb 06       	cpc	r15, r27
    3764:	50 f4       	brcc	.+20     	; 0x377a <remove_chain+0x64>
    3766:	b7 01       	movw	r22, r14
    3768:	a6 01       	movw	r20, r12
    376a:	ce 01       	movw	r24, r28
    376c:	ee d9       	rcall	.-3108   	; 0x2b4a <get_fat>
    376e:	4b 01       	movw	r8, r22
    3770:	5c 01       	movw	r10, r24
    3772:	67 2b       	or	r22, r23
    3774:	68 2b       	or	r22, r24
    3776:	69 2b       	or	r22, r25
    3778:	11 f4       	brne	.+4      	; 0x377e <remove_chain+0x68>
    377a:	80 e0       	ldi	r24, 0x00	; 0
    377c:	2d c0       	rjmp	.+90     	; 0x37d8 <remove_chain+0xc2>
    377e:	81 e0       	ldi	r24, 0x01	; 1
    3780:	88 16       	cp	r8, r24
    3782:	91 04       	cpc	r9, r1
    3784:	a1 04       	cpc	r10, r1
    3786:	b1 04       	cpc	r11, r1
    3788:	d1 f2       	breq	.-76     	; 0x373e <remove_chain+0x28>
    378a:	2f ef       	ldi	r18, 0xFF	; 255
    378c:	82 16       	cp	r8, r18
    378e:	92 06       	cpc	r9, r18
    3790:	a2 06       	cpc	r10, r18
    3792:	b2 06       	cpc	r11, r18
    3794:	01 f1       	breq	.+64     	; 0x37d6 <remove_chain+0xc0>
    3796:	00 e0       	ldi	r16, 0x00	; 0
    3798:	10 e0       	ldi	r17, 0x00	; 0
    379a:	98 01       	movw	r18, r16
    379c:	b7 01       	movw	r22, r14
    379e:	a6 01       	movw	r20, r12
    37a0:	ce 01       	movw	r24, r28
    37a2:	4f db       	rcall	.-2402   	; 0x2e42 <put_fat>
    37a4:	81 11       	cpse	r24, r1
    37a6:	18 c0       	rjmp	.+48     	; 0x37d8 <remove_chain+0xc2>
    37a8:	8e 85       	ldd	r24, Y+14	; 0x0e
    37aa:	9f 85       	ldd	r25, Y+15	; 0x0f
    37ac:	a8 89       	ldd	r26, Y+16	; 0x10
    37ae:	b9 89       	ldd	r27, Y+17	; 0x11
    37b0:	8f 3f       	cpi	r24, 0xFF	; 255
    37b2:	2f ef       	ldi	r18, 0xFF	; 255
    37b4:	92 07       	cpc	r25, r18
    37b6:	a2 07       	cpc	r26, r18
    37b8:	b2 07       	cpc	r27, r18
    37ba:	51 f0       	breq	.+20     	; 0x37d0 <remove_chain+0xba>
    37bc:	01 96       	adiw	r24, 0x01	; 1
    37be:	a1 1d       	adc	r26, r1
    37c0:	b1 1d       	adc	r27, r1
    37c2:	8e 87       	std	Y+14, r24	; 0x0e
    37c4:	9f 87       	std	Y+15, r25	; 0x0f
    37c6:	a8 8b       	std	Y+16, r26	; 0x10
    37c8:	b9 8b       	std	Y+17, r27	; 0x11
    37ca:	8d 81       	ldd	r24, Y+5	; 0x05
    37cc:	81 60       	ori	r24, 0x01	; 1
    37ce:	8d 83       	std	Y+5, r24	; 0x05
    37d0:	75 01       	movw	r14, r10
    37d2:	64 01       	movw	r12, r8
    37d4:	bf cf       	rjmp	.-130    	; 0x3754 <remove_chain+0x3e>
    37d6:	81 e0       	ldi	r24, 0x01	; 1
    37d8:	df 91       	pop	r29
    37da:	cf 91       	pop	r28
    37dc:	1f 91       	pop	r17
    37de:	0f 91       	pop	r16
    37e0:	ff 90       	pop	r15
    37e2:	ef 90       	pop	r14
    37e4:	df 90       	pop	r13
    37e6:	cf 90       	pop	r12
    37e8:	bf 90       	pop	r11
    37ea:	af 90       	pop	r10
    37ec:	9f 90       	pop	r9
    37ee:	8f 90       	pop	r8
    37f0:	08 95       	ret

000037f2 <f_mount>:
    37f2:	cf 93       	push	r28
    37f4:	df 93       	push	r29
    37f6:	cd b7       	in	r28, 0x3d	; 61
    37f8:	de b7       	in	r29, 0x3e	; 62
    37fa:	27 97       	sbiw	r28, 0x07	; 7
    37fc:	0f b6       	in	r0, 0x3f	; 63
    37fe:	f8 94       	cli
    3800:	de bf       	out	0x3e, r29	; 62
    3802:	0f be       	out	0x3f, r0	; 63
    3804:	cd bf       	out	0x3d, r28	; 61
    3806:	9c 83       	std	Y+4, r25	; 0x04
    3808:	8b 83       	std	Y+3, r24	; 0x03
    380a:	7e 83       	std	Y+6, r23	; 0x06
    380c:	6d 83       	std	Y+5, r22	; 0x05
    380e:	7a 83       	std	Y+2, r23	; 0x02
    3810:	69 83       	std	Y+1, r22	; 0x01
    3812:	ce 01       	movw	r24, r28
    3814:	01 96       	adiw	r24, 0x01	; 1
    3816:	4f 83       	std	Y+7, r20	; 0x07
    3818:	0e 94 a5 11 	call	0x234a	; 0x234a <get_ldnumber>
    381c:	4f 81       	ldd	r20, Y+7	; 0x07
    381e:	97 fd       	sbrc	r25, 7
    3820:	24 c0       	rjmp	.+72     	; 0x386a <f_mount+0x78>
    3822:	88 0f       	add	r24, r24
    3824:	99 1f       	adc	r25, r25
    3826:	fc 01       	movw	r30, r24
    3828:	ec 55       	subi	r30, 0x5C	; 92
    382a:	fa 4f       	sbci	r31, 0xFA	; 250
    382c:	01 90       	ld	r0, Z+
    382e:	f0 81       	ld	r31, Z
    3830:	e0 2d       	mov	r30, r0
    3832:	30 97       	sbiw	r30, 0x00	; 0
    3834:	09 f0       	breq	.+2      	; 0x3838 <f_mount+0x46>
    3836:	10 82       	st	Z, r1
    3838:	eb 81       	ldd	r30, Y+3	; 0x03
    383a:	fc 81       	ldd	r31, Y+4	; 0x04
    383c:	30 97       	sbiw	r30, 0x00	; 0
    383e:	09 f0       	breq	.+2      	; 0x3842 <f_mount+0x50>
    3840:	10 82       	st	Z, r1
    3842:	2b 81       	ldd	r18, Y+3	; 0x03
    3844:	3c 81       	ldd	r19, Y+4	; 0x04
    3846:	fc 01       	movw	r30, r24
    3848:	ec 55       	subi	r30, 0x5C	; 92
    384a:	fa 4f       	sbci	r31, 0xFA	; 250
    384c:	31 83       	std	Z+1, r19	; 0x01
    384e:	20 83       	st	Z, r18
    3850:	23 2b       	or	r18, r19
    3852:	69 f0       	breq	.+26     	; 0x386e <f_mount+0x7c>
    3854:	41 30       	cpi	r20, 0x01	; 1
    3856:	59 f4       	brne	.+22     	; 0x386e <f_mount+0x7c>
    3858:	40 e0       	ldi	r20, 0x00	; 0
    385a:	be 01       	movw	r22, r28
    385c:	6b 5f       	subi	r22, 0xFB	; 251
    385e:	7f 4f       	sbci	r23, 0xFF	; 255
    3860:	ce 01       	movw	r24, r28
    3862:	03 96       	adiw	r24, 0x03	; 3
    3864:	0e 94 1f 13 	call	0x263e	; 0x263e <find_volume>
    3868:	03 c0       	rjmp	.+6      	; 0x3870 <f_mount+0x7e>
    386a:	8b e0       	ldi	r24, 0x0B	; 11
    386c:	01 c0       	rjmp	.+2      	; 0x3870 <f_mount+0x7e>
    386e:	80 e0       	ldi	r24, 0x00	; 0
    3870:	27 96       	adiw	r28, 0x07	; 7
    3872:	0f b6       	in	r0, 0x3f	; 63
    3874:	f8 94       	cli
    3876:	de bf       	out	0x3e, r29	; 62
    3878:	0f be       	out	0x3f, r0	; 63
    387a:	cd bf       	out	0x3d, r28	; 61
    387c:	df 91       	pop	r29
    387e:	cf 91       	pop	r28
    3880:	08 95       	ret

00003882 <f_open>:
    3882:	4f 92       	push	r4
    3884:	5f 92       	push	r5
    3886:	6f 92       	push	r6
    3888:	7f 92       	push	r7
    388a:	8f 92       	push	r8
    388c:	9f 92       	push	r9
    388e:	af 92       	push	r10
    3890:	bf 92       	push	r11
    3892:	df 92       	push	r13
    3894:	ef 92       	push	r14
    3896:	ff 92       	push	r15
    3898:	0f 93       	push	r16
    389a:	1f 93       	push	r17
    389c:	cf 93       	push	r28
    389e:	df 93       	push	r29
    38a0:	cd b7       	in	r28, 0x3d	; 61
    38a2:	de b7       	in	r29, 0x3e	; 62
    38a4:	a4 97       	sbiw	r28, 0x24	; 36
    38a6:	0f b6       	in	r0, 0x3f	; 63
    38a8:	f8 94       	cli
    38aa:	de bf       	out	0x3e, r29	; 62
    38ac:	0f be       	out	0x3f, r0	; 63
    38ae:	cd bf       	out	0x3d, r28	; 61
    38b0:	7c a3       	std	Y+36, r23	; 0x24
    38b2:	6b a3       	std	Y+35, r22	; 0x23
    38b4:	00 97       	sbiw	r24, 0x00	; 0
    38b6:	09 f4       	brne	.+2      	; 0x38ba <f_open+0x38>
    38b8:	f1 c0       	rjmp	.+482    	; 0x3a9c <f_open+0x21a>
    38ba:	b4 2e       	mov	r11, r20
    38bc:	7c 01       	movw	r14, r24
    38be:	dc 01       	movw	r26, r24
    38c0:	1d 92       	st	X+, r1
    38c2:	1c 92       	st	X, r1
    38c4:	4e 71       	andi	r20, 0x1E	; 30
    38c6:	be 01       	movw	r22, r28
    38c8:	6d 5d       	subi	r22, 0xDD	; 221
    38ca:	7f 4f       	sbci	r23, 0xFF	; 255
    38cc:	ce 01       	movw	r24, r28
    38ce:	01 96       	adiw	r24, 0x01	; 1
    38d0:	0e 94 1f 13 	call	0x263e	; 0x263e <find_volume>
    38d4:	81 11       	cpse	r24, r1
    38d6:	e9 c0       	rjmp	.+466    	; 0x3aaa <f_open+0x228>
    38d8:	ce 01       	movw	r24, r28
    38da:	47 96       	adiw	r24, 0x17	; 23
    38dc:	9e 8b       	std	Y+22, r25	; 0x16
    38de:	8d 8b       	std	Y+21, r24	; 0x15
    38e0:	6b a1       	ldd	r22, Y+35	; 0x23
    38e2:	7c a1       	ldd	r23, Y+36	; 0x24
    38e4:	46 97       	sbiw	r24, 0x16	; 22
    38e6:	9c dd       	rcall	.-1224   	; 0x3420 <follow_path>
    38e8:	0b 89       	ldd	r16, Y+19	; 0x13
    38ea:	1c 89       	ldd	r17, Y+20	; 0x14
    38ec:	81 11       	cpse	r24, r1
    38ee:	04 c0       	rjmp	.+8      	; 0x38f8 <f_open+0x76>
    38f0:	01 15       	cp	r16, r1
    38f2:	11 05       	cpc	r17, r1
    38f4:	09 f4       	brne	.+2      	; 0x38f8 <f_open+0x76>
    38f6:	86 e0       	ldi	r24, 0x06	; 6
    38f8:	bb 2d       	mov	r27, r11
    38fa:	bf 71       	andi	r27, 0x1F	; 31
    38fc:	db 2e       	mov	r13, r27
    38fe:	9b 2d       	mov	r25, r11
    3900:	9c 71       	andi	r25, 0x1C	; 28
    3902:	09 f4       	brne	.+2      	; 0x3906 <f_open+0x84>
    3904:	6d c0       	rjmp	.+218    	; 0x39e0 <f_open+0x15e>
    3906:	88 23       	and	r24, r24
    3908:	69 f0       	breq	.+26     	; 0x3924 <f_open+0xa2>
    390a:	84 30       	cpi	r24, 0x04	; 4
    390c:	19 f4       	brne	.+6      	; 0x3914 <f_open+0x92>
    390e:	ce 01       	movw	r24, r28
    3910:	01 96       	adiw	r24, 0x01	; 1
    3912:	b7 de       	rcall	.-658    	; 0x3682 <dir_register>
    3914:	ed 2d       	mov	r30, r13
    3916:	e8 60       	ori	r30, 0x08	; 8
    3918:	de 2e       	mov	r13, r30
    391a:	0b 89       	ldd	r16, Y+19	; 0x13
    391c:	1c 89       	ldd	r17, Y+20	; 0x14
    391e:	88 23       	and	r24, r24
    3920:	49 f0       	breq	.+18     	; 0x3934 <f_open+0xb2>
    3922:	c3 c0       	rjmp	.+390    	; 0x3aaa <f_open+0x228>
    3924:	d8 01       	movw	r26, r16
    3926:	1b 96       	adiw	r26, 0x0b	; 11
    3928:	8c 91       	ld	r24, X
    392a:	81 71       	andi	r24, 0x11	; 17
    392c:	09 f0       	breq	.+2      	; 0x3930 <f_open+0xae>
    392e:	bc c0       	rjmp	.+376    	; 0x3aa8 <f_open+0x226>
    3930:	b2 fc       	sbrc	r11, 2
    3932:	b6 c0       	rjmp	.+364    	; 0x3aa0 <f_open+0x21e>
    3934:	d3 fe       	sbrs	r13, 3
    3936:	5f c0       	rjmp	.+190    	; 0x39f6 <f_open+0x174>
    3938:	80 e0       	ldi	r24, 0x00	; 0
    393a:	90 e0       	ldi	r25, 0x00	; 0
    393c:	a9 e6       	ldi	r26, 0x69	; 105
    393e:	b5 e4       	ldi	r27, 0x45	; 69
    3940:	f8 01       	movw	r30, r16
    3942:	86 87       	std	Z+14, r24	; 0x0e
    3944:	97 87       	std	Z+15, r25	; 0x0f
    3946:	a0 8b       	std	Z+16, r26	; 0x10
    3948:	b1 8b       	std	Z+17, r27	; 0x11
    394a:	13 86       	std	Z+11, r1	; 0x0b
    394c:	d8 01       	movw	r26, r16
    394e:	14 8e       	std	Z+28, r1	; 0x1c
    3950:	15 8e       	std	Z+29, r1	; 0x1d
    3952:	16 8e       	std	Z+30, r1	; 0x1e
    3954:	17 8e       	std	Z+31, r1	; 0x1f
    3956:	e9 81       	ldd	r30, Y+1	; 0x01
    3958:	fa 81       	ldd	r31, Y+2	; 0x02
    395a:	5a 96       	adiw	r26, 0x1a	; 26
    395c:	8d 90       	ld	r8, X+
    395e:	9c 90       	ld	r9, X
    3960:	5b 97       	sbiw	r26, 0x1b	; 27
    3962:	a1 2c       	mov	r10, r1
    3964:	b1 2c       	mov	r11, r1
    3966:	80 81       	ld	r24, Z
    3968:	83 30       	cpi	r24, 0x03	; 3
    396a:	69 f4       	brne	.+26     	; 0x3986 <f_open+0x104>
    396c:	54 96       	adiw	r26, 0x14	; 20
    396e:	4d 91       	ld	r20, X+
    3970:	5c 91       	ld	r21, X
    3972:	55 97       	sbiw	r26, 0x15	; 21
    3974:	60 e0       	ldi	r22, 0x00	; 0
    3976:	70 e0       	ldi	r23, 0x00	; 0
    3978:	ba 01       	movw	r22, r20
    397a:	55 27       	eor	r21, r21
    397c:	44 27       	eor	r20, r20
    397e:	84 2a       	or	r8, r20
    3980:	95 2a       	or	r9, r21
    3982:	a6 2a       	or	r10, r22
    3984:	b7 2a       	or	r11, r23
    3986:	d8 01       	movw	r26, r16
    3988:	5b 96       	adiw	r26, 0x1b	; 27
    398a:	1c 92       	st	X, r1
    398c:	1e 92       	st	-X, r1
    398e:	5a 97       	sbiw	r26, 0x1a	; 26
    3990:	55 96       	adiw	r26, 0x15	; 21
    3992:	1c 92       	st	X, r1
    3994:	1e 92       	st	-X, r1
    3996:	54 97       	sbiw	r26, 0x14	; 20
    3998:	81 e0       	ldi	r24, 0x01	; 1
    399a:	84 83       	std	Z+4, r24	; 0x04
    399c:	81 14       	cp	r8, r1
    399e:	91 04       	cpc	r9, r1
    39a0:	a1 04       	cpc	r10, r1
    39a2:	b1 04       	cpc	r11, r1
    39a4:	41 f1       	breq	.+80     	; 0x39f6 <f_open+0x174>
    39a6:	42 a4       	ldd	r4, Z+42	; 0x2a
    39a8:	53 a4       	ldd	r5, Z+43	; 0x2b
    39aa:	64 a4       	ldd	r6, Z+44	; 0x2c
    39ac:	75 a4       	ldd	r7, Z+45	; 0x2d
    39ae:	b5 01       	movw	r22, r10
    39b0:	a4 01       	movw	r20, r8
    39b2:	cf 01       	movw	r24, r30
    39b4:	b0 de       	rcall	.-672    	; 0x3716 <remove_chain>
    39b6:	81 11       	cpse	r24, r1
    39b8:	78 c0       	rjmp	.+240    	; 0x3aaa <f_open+0x228>
    39ba:	89 81       	ldd	r24, Y+1	; 0x01
    39bc:	9a 81       	ldd	r25, Y+2	; 0x02
    39be:	b1 e0       	ldi	r27, 0x01	; 1
    39c0:	8b 1a       	sub	r8, r27
    39c2:	91 08       	sbc	r9, r1
    39c4:	a1 08       	sbc	r10, r1
    39c6:	b1 08       	sbc	r11, r1
    39c8:	fc 01       	movw	r30, r24
    39ca:	82 86       	std	Z+10, r8	; 0x0a
    39cc:	93 86       	std	Z+11, r9	; 0x0b
    39ce:	a4 86       	std	Z+12, r10	; 0x0c
    39d0:	b5 86       	std	Z+13, r11	; 0x0d
    39d2:	b3 01       	movw	r22, r6
    39d4:	a2 01       	movw	r20, r4
    39d6:	0e 94 aa 12 	call	0x2554	; 0x2554 <move_window>
    39da:	88 23       	and	r24, r24
    39dc:	61 f0       	breq	.+24     	; 0x39f6 <f_open+0x174>
    39de:	65 c0       	rjmp	.+202    	; 0x3aaa <f_open+0x228>
    39e0:	81 11       	cpse	r24, r1
    39e2:	63 c0       	rjmp	.+198    	; 0x3aaa <f_open+0x228>
    39e4:	d8 01       	movw	r26, r16
    39e6:	1b 96       	adiw	r26, 0x0b	; 11
    39e8:	8c 91       	ld	r24, X
    39ea:	84 fd       	sbrc	r24, 4
    39ec:	5b c0       	rjmp	.+182    	; 0x3aa4 <f_open+0x222>
    39ee:	b1 fe       	sbrs	r11, 1
    39f0:	02 c0       	rjmp	.+4      	; 0x39f6 <f_open+0x174>
    39f2:	80 fd       	sbrc	r24, 0
    39f4:	59 c0       	rjmp	.+178    	; 0x3aa8 <f_open+0x226>
    39f6:	d3 fe       	sbrs	r13, 3
    39f8:	03 c0       	rjmp	.+6      	; 0x3a00 <f_open+0x17e>
    39fa:	bd 2d       	mov	r27, r13
    39fc:	b0 62       	ori	r27, 0x20	; 32
    39fe:	db 2e       	mov	r13, r27
    3a00:	a9 80       	ldd	r10, Y+1	; 0x01
    3a02:	ba 80       	ldd	r11, Y+2	; 0x02
    3a04:	f5 01       	movw	r30, r10
    3a06:	42 a5       	ldd	r20, Z+42	; 0x2a
    3a08:	53 a5       	ldd	r21, Z+43	; 0x2b
    3a0a:	64 a5       	ldd	r22, Z+44	; 0x2c
    3a0c:	75 a5       	ldd	r23, Z+45	; 0x2d
    3a0e:	d7 01       	movw	r26, r14
    3a10:	5a 96       	adiw	r26, 0x1a	; 26
    3a12:	4d 93       	st	X+, r20
    3a14:	5d 93       	st	X+, r21
    3a16:	6d 93       	st	X+, r22
    3a18:	7c 93       	st	X, r23
    3a1a:	5d 97       	sbiw	r26, 0x1d	; 29
    3a1c:	5f 96       	adiw	r26, 0x1f	; 31
    3a1e:	1c 93       	st	X, r17
    3a20:	0e 93       	st	-X, r16
    3a22:	5e 97       	sbiw	r26, 0x1e	; 30
    3a24:	14 96       	adiw	r26, 0x04	; 4
    3a26:	dc 92       	st	X, r13
    3a28:	14 97       	sbiw	r26, 0x04	; 4
    3a2a:	15 96       	adiw	r26, 0x05	; 5
    3a2c:	1c 92       	st	X, r1
    3a2e:	f8 01       	movw	r30, r16
    3a30:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a32:	93 8d       	ldd	r25, Z+27	; 0x1b
    3a34:	a0 e0       	ldi	r26, 0x00	; 0
    3a36:	b0 e0       	ldi	r27, 0x00	; 0
    3a38:	f5 01       	movw	r30, r10
    3a3a:	20 81       	ld	r18, Z
    3a3c:	23 30       	cpi	r18, 0x03	; 3
    3a3e:	61 f4       	brne	.+24     	; 0x3a58 <f_open+0x1d6>
    3a40:	f8 01       	movw	r30, r16
    3a42:	44 89       	ldd	r20, Z+20	; 0x14
    3a44:	55 89       	ldd	r21, Z+21	; 0x15
    3a46:	60 e0       	ldi	r22, 0x00	; 0
    3a48:	70 e0       	ldi	r23, 0x00	; 0
    3a4a:	ba 01       	movw	r22, r20
    3a4c:	55 27       	eor	r21, r21
    3a4e:	44 27       	eor	r20, r20
    3a50:	84 2b       	or	r24, r20
    3a52:	95 2b       	or	r25, r21
    3a54:	a6 2b       	or	r26, r22
    3a56:	b7 2b       	or	r27, r23
    3a58:	f7 01       	movw	r30, r14
    3a5a:	86 87       	std	Z+14, r24	; 0x0e
    3a5c:	97 87       	std	Z+15, r25	; 0x0f
    3a5e:	a0 8b       	std	Z+16, r26	; 0x10
    3a60:	b1 8b       	std	Z+17, r27	; 0x11
    3a62:	f8 01       	movw	r30, r16
    3a64:	84 8d       	ldd	r24, Z+28	; 0x1c
    3a66:	95 8d       	ldd	r25, Z+29	; 0x1d
    3a68:	a6 8d       	ldd	r26, Z+30	; 0x1e
    3a6a:	b7 8d       	ldd	r27, Z+31	; 0x1f
    3a6c:	f7 01       	movw	r30, r14
    3a6e:	82 87       	std	Z+10, r24	; 0x0a
    3a70:	93 87       	std	Z+11, r25	; 0x0b
    3a72:	a4 87       	std	Z+12, r26	; 0x0c
    3a74:	b5 87       	std	Z+13, r27	; 0x0d
    3a76:	16 82       	std	Z+6, r1	; 0x06
    3a78:	17 82       	std	Z+7, r1	; 0x07
    3a7a:	10 86       	std	Z+8, r1	; 0x08
    3a7c:	11 86       	std	Z+9, r1	; 0x09
    3a7e:	16 8a       	std	Z+22, r1	; 0x16
    3a80:	17 8a       	std	Z+23, r1	; 0x17
    3a82:	10 8e       	std	Z+24, r1	; 0x18
    3a84:	11 8e       	std	Z+25, r1	; 0x19
    3a86:	b1 82       	std	Z+1, r11	; 0x01
    3a88:	a0 82       	st	Z, r10
    3a8a:	d5 01       	movw	r26, r10
    3a8c:	16 96       	adiw	r26, 0x06	; 6
    3a8e:	8d 91       	ld	r24, X+
    3a90:	9c 91       	ld	r25, X
    3a92:	17 97       	sbiw	r26, 0x07	; 7
    3a94:	93 83       	std	Z+3, r25	; 0x03
    3a96:	82 83       	std	Z+2, r24	; 0x02
    3a98:	80 e0       	ldi	r24, 0x00	; 0
    3a9a:	07 c0       	rjmp	.+14     	; 0x3aaa <f_open+0x228>
    3a9c:	89 e0       	ldi	r24, 0x09	; 9
    3a9e:	05 c0       	rjmp	.+10     	; 0x3aaa <f_open+0x228>
    3aa0:	88 e0       	ldi	r24, 0x08	; 8
    3aa2:	03 c0       	rjmp	.+6      	; 0x3aaa <f_open+0x228>
    3aa4:	84 e0       	ldi	r24, 0x04	; 4
    3aa6:	01 c0       	rjmp	.+2      	; 0x3aaa <f_open+0x228>
    3aa8:	87 e0       	ldi	r24, 0x07	; 7
    3aaa:	a4 96       	adiw	r28, 0x24	; 36
    3aac:	0f b6       	in	r0, 0x3f	; 63
    3aae:	f8 94       	cli
    3ab0:	de bf       	out	0x3e, r29	; 62
    3ab2:	0f be       	out	0x3f, r0	; 63
    3ab4:	cd bf       	out	0x3d, r28	; 61
    3ab6:	df 91       	pop	r29
    3ab8:	cf 91       	pop	r28
    3aba:	1f 91       	pop	r17
    3abc:	0f 91       	pop	r16
    3abe:	ff 90       	pop	r15
    3ac0:	ef 90       	pop	r14
    3ac2:	df 90       	pop	r13
    3ac4:	bf 90       	pop	r11
    3ac6:	af 90       	pop	r10
    3ac8:	9f 90       	pop	r9
    3aca:	8f 90       	pop	r8
    3acc:	7f 90       	pop	r7
    3ace:	6f 90       	pop	r6
    3ad0:	5f 90       	pop	r5
    3ad2:	4f 90       	pop	r4
    3ad4:	08 95       	ret

00003ad6 <f_write>:
    3ad6:	2f 92       	push	r2
    3ad8:	3f 92       	push	r3
    3ada:	4f 92       	push	r4
    3adc:	5f 92       	push	r5
    3ade:	6f 92       	push	r6
    3ae0:	7f 92       	push	r7
    3ae2:	8f 92       	push	r8
    3ae4:	9f 92       	push	r9
    3ae6:	af 92       	push	r10
    3ae8:	bf 92       	push	r11
    3aea:	cf 92       	push	r12
    3aec:	df 92       	push	r13
    3aee:	ef 92       	push	r14
    3af0:	ff 92       	push	r15
    3af2:	0f 93       	push	r16
    3af4:	1f 93       	push	r17
    3af6:	cf 93       	push	r28
    3af8:	df 93       	push	r29
    3afa:	ec 01       	movw	r28, r24
    3afc:	5b 01       	movw	r10, r22
    3afe:	6a 01       	movw	r12, r20
    3b00:	19 01       	movw	r2, r18
    3b02:	f9 01       	movw	r30, r18
    3b04:	11 82       	std	Z+1, r1	; 0x01
    3b06:	10 82       	st	Z, r1
    3b08:	0e 94 c4 11 	call	0x2388	; 0x2388 <validate>
    3b0c:	81 11       	cpse	r24, r1
    3b0e:	62 c1       	rjmp	.+708    	; 0x3dd4 <f_write+0x2fe>
    3b10:	8d 81       	ldd	r24, Y+5	; 0x05
    3b12:	81 11       	cpse	r24, r1
    3b14:	5f c1       	rjmp	.+702    	; 0x3dd4 <f_write+0x2fe>
    3b16:	8c 81       	ldd	r24, Y+4	; 0x04
    3b18:	81 ff       	sbrs	r24, 1
    3b1a:	5b c1       	rjmp	.+694    	; 0x3dd2 <f_write+0x2fc>
    3b1c:	8e 81       	ldd	r24, Y+6	; 0x06
    3b1e:	9f 81       	ldd	r25, Y+7	; 0x07
    3b20:	a8 85       	ldd	r26, Y+8	; 0x08
    3b22:	b9 85       	ldd	r27, Y+9	; 0x09
    3b24:	ac 01       	movw	r20, r24
    3b26:	bd 01       	movw	r22, r26
    3b28:	4c 0d       	add	r20, r12
    3b2a:	5d 1d       	adc	r21, r13
    3b2c:	61 1d       	adc	r22, r1
    3b2e:	71 1d       	adc	r23, r1
    3b30:	48 17       	cp	r20, r24
    3b32:	59 07       	cpc	r21, r25
    3b34:	6a 07       	cpc	r22, r26
    3b36:	7b 07       	cpc	r23, r27
    3b38:	08 f0       	brcs	.+2      	; 0x3b3c <f_write+0x66>
    3b3a:	a3 c0       	rjmp	.+326    	; 0x3c82 <f_write+0x1ac>
    3b3c:	c1 2c       	mov	r12, r1
    3b3e:	d1 2c       	mov	r13, r1
    3b40:	a0 c0       	rjmp	.+320    	; 0x3c82 <f_write+0x1ac>
    3b42:	4e 81       	ldd	r20, Y+6	; 0x06
    3b44:	5f 81       	ldd	r21, Y+7	; 0x07
    3b46:	68 85       	ldd	r22, Y+8	; 0x08
    3b48:	79 85       	ldd	r23, Y+9	; 0x09
    3b4a:	db 01       	movw	r26, r22
    3b4c:	ca 01       	movw	r24, r20
    3b4e:	91 70       	andi	r25, 0x01	; 1
    3b50:	aa 27       	eor	r26, r26
    3b52:	bb 27       	eor	r27, r27
    3b54:	89 2b       	or	r24, r25
    3b56:	8a 2b       	or	r24, r26
    3b58:	8b 2b       	or	r24, r27
    3b5a:	09 f0       	breq	.+2      	; 0x3b5e <f_write+0x88>
    3b5c:	0a c1       	rjmp	.+532    	; 0x3d72 <f_write+0x29c>
    3b5e:	e8 81       	ld	r30, Y
    3b60:	f9 81       	ldd	r31, Y+1	; 0x01
    3b62:	22 81       	ldd	r18, Z+2	; 0x02
    3b64:	21 50       	subi	r18, 0x01	; 1
    3b66:	2a 01       	movw	r4, r20
    3b68:	3b 01       	movw	r6, r22
    3b6a:	a9 e0       	ldi	r26, 0x09	; 9
    3b6c:	76 94       	lsr	r7
    3b6e:	67 94       	ror	r6
    3b70:	57 94       	ror	r5
    3b72:	47 94       	ror	r4
    3b74:	aa 95       	dec	r26
    3b76:	d1 f7       	brne	.-12     	; 0x3b6c <f_write+0x96>
    3b78:	12 2f       	mov	r17, r18
    3b7a:	14 21       	and	r17, r4
    3b7c:	09 f4       	brne	.+2      	; 0x3b80 <f_write+0xaa>
    3b7e:	86 c0       	rjmp	.+268    	; 0x3c8c <f_write+0x1b6>
    3b80:	88 81       	ld	r24, Y
    3b82:	99 81       	ldd	r25, Y+1	; 0x01
    3b84:	fc 01       	movw	r30, r24
    3b86:	42 a4       	ldd	r4, Z+42	; 0x2a
    3b88:	53 a4       	ldd	r5, Z+43	; 0x2b
    3b8a:	64 a4       	ldd	r6, Z+44	; 0x2c
    3b8c:	75 a4       	ldd	r7, Z+45	; 0x2d
    3b8e:	4e 89       	ldd	r20, Y+22	; 0x16
    3b90:	5f 89       	ldd	r21, Y+23	; 0x17
    3b92:	68 8d       	ldd	r22, Y+24	; 0x18
    3b94:	79 8d       	ldd	r23, Y+25	; 0x19
    3b96:	44 16       	cp	r4, r20
    3b98:	55 06       	cpc	r5, r21
    3b9a:	66 06       	cpc	r6, r22
    3b9c:	77 06       	cpc	r7, r23
    3b9e:	09 f4       	brne	.+2      	; 0x3ba2 <f_write+0xcc>
    3ba0:	c6 c0       	rjmp	.+396    	; 0x3d2e <f_write+0x258>
    3ba2:	88 80       	ld	r8, Y
    3ba4:	99 80       	ldd	r9, Y+1	; 0x01
    3ba6:	4a 89       	ldd	r20, Y+18	; 0x12
    3ba8:	5b 89       	ldd	r21, Y+19	; 0x13
    3baa:	6c 89       	ldd	r22, Y+20	; 0x14
    3bac:	7d 89       	ldd	r23, Y+21	; 0x15
    3bae:	c4 01       	movw	r24, r8
    3bb0:	0e 94 7d 15 	call	0x2afa	; 0x2afa <clust2sect>
    3bb4:	61 15       	cp	r22, r1
    3bb6:	71 05       	cpc	r23, r1
    3bb8:	81 05       	cpc	r24, r1
    3bba:	91 05       	cpc	r25, r1
    3bbc:	09 f4       	brne	.+2      	; 0x3bc0 <f_write+0xea>
    3bbe:	9a c0       	rjmp	.+308    	; 0x3cf4 <f_write+0x21e>
    3bc0:	2b 01       	movw	r4, r22
    3bc2:	3c 01       	movw	r6, r24
    3bc4:	41 0e       	add	r4, r17
    3bc6:	51 1c       	adc	r5, r1
    3bc8:	61 1c       	adc	r6, r1
    3bca:	71 1c       	adc	r7, r1
    3bcc:	76 01       	movw	r14, r12
    3bce:	ef 2c       	mov	r14, r15
    3bd0:	ff 24       	eor	r15, r15
    3bd2:	e6 94       	lsr	r14
    3bd4:	e1 14       	cp	r14, r1
    3bd6:	f1 04       	cpc	r15, r1
    3bd8:	09 f4       	brne	.+2      	; 0x3bdc <f_write+0x106>
    3bda:	af c0       	rjmp	.+350    	; 0x3d3a <f_write+0x264>
    3bdc:	f4 01       	movw	r30, r8
    3bde:	82 81       	ldd	r24, Z+2	; 0x02
    3be0:	21 2f       	mov	r18, r17
    3be2:	30 e0       	ldi	r19, 0x00	; 0
    3be4:	a7 01       	movw	r20, r14
    3be6:	42 0f       	add	r20, r18
    3be8:	53 1f       	adc	r21, r19
    3bea:	90 e0       	ldi	r25, 0x00	; 0
    3bec:	84 17       	cp	r24, r20
    3bee:	95 07       	cpc	r25, r21
    3bf0:	18 f4       	brcc	.+6      	; 0x3bf8 <f_write+0x122>
    3bf2:	7c 01       	movw	r14, r24
    3bf4:	e2 1a       	sub	r14, r18
    3bf6:	f3 0a       	sbc	r15, r19
    3bf8:	87 01       	movw	r16, r14
    3bfa:	a3 01       	movw	r20, r6
    3bfc:	92 01       	movw	r18, r4
    3bfe:	b5 01       	movw	r22, r10
    3c00:	f4 01       	movw	r30, r8
    3c02:	81 81       	ldd	r24, Z+1	; 0x01
    3c04:	0e 94 3f 10 	call	0x207e	; 0x207e <disk_write>
    3c08:	81 11       	cpse	r24, r1
    3c0a:	7c c0       	rjmp	.+248    	; 0x3d04 <f_write+0x22e>
    3c0c:	88 81       	ld	r24, Y
    3c0e:	99 81       	ldd	r25, Y+1	; 0x01
    3c10:	fc 01       	movw	r30, r24
    3c12:	42 a5       	ldd	r20, Z+42	; 0x2a
    3c14:	53 a5       	ldd	r21, Z+43	; 0x2b
    3c16:	64 a5       	ldd	r22, Z+44	; 0x2c
    3c18:	75 a5       	ldd	r23, Z+45	; 0x2d
    3c1a:	44 19       	sub	r20, r4
    3c1c:	55 09       	sbc	r21, r5
    3c1e:	66 09       	sbc	r22, r6
    3c20:	77 09       	sbc	r23, r7
    3c22:	27 01       	movw	r4, r14
    3c24:	61 2c       	mov	r6, r1
    3c26:	71 2c       	mov	r7, r1
    3c28:	44 15       	cp	r20, r4
    3c2a:	55 05       	cpc	r21, r5
    3c2c:	66 05       	cpc	r22, r6
    3c2e:	77 05       	cpc	r23, r7
    3c30:	70 f4       	brcc	.+28     	; 0x3c4e <f_write+0x178>
    3c32:	54 2f       	mov	r21, r20
    3c34:	44 27       	eor	r20, r20
    3c36:	55 0f       	add	r21, r21
    3c38:	b5 01       	movw	r22, r10
    3c3a:	64 0f       	add	r22, r20
    3c3c:	75 1f       	adc	r23, r21
    3c3e:	40 e0       	ldi	r20, 0x00	; 0
    3c40:	52 e0       	ldi	r21, 0x02	; 2
    3c42:	8e 96       	adiw	r24, 0x2e	; 46
    3c44:	0e 94 3b 11 	call	0x2276	; 0x2276 <mem_cpy>
    3c48:	e8 81       	ld	r30, Y
    3c4a:	f9 81       	ldd	r31, Y+1	; 0x01
    3c4c:	14 82       	std	Z+4, r1	; 0x04
    3c4e:	fe 2c       	mov	r15, r14
    3c50:	ee 24       	eor	r14, r14
    3c52:	ff 0c       	add	r15, r15
    3c54:	ae 0c       	add	r10, r14
    3c56:	bf 1c       	adc	r11, r15
    3c58:	8e 81       	ldd	r24, Y+6	; 0x06
    3c5a:	9f 81       	ldd	r25, Y+7	; 0x07
    3c5c:	a8 85       	ldd	r26, Y+8	; 0x08
    3c5e:	b9 85       	ldd	r27, Y+9	; 0x09
    3c60:	8e 0d       	add	r24, r14
    3c62:	9f 1d       	adc	r25, r15
    3c64:	a1 1d       	adc	r26, r1
    3c66:	b1 1d       	adc	r27, r1
    3c68:	8e 83       	std	Y+6, r24	; 0x06
    3c6a:	9f 83       	std	Y+7, r25	; 0x07
    3c6c:	a8 87       	std	Y+8, r26	; 0x08
    3c6e:	b9 87       	std	Y+9, r27	; 0x09
    3c70:	f1 01       	movw	r30, r2
    3c72:	80 81       	ld	r24, Z
    3c74:	91 81       	ldd	r25, Z+1	; 0x01
    3c76:	8e 0d       	add	r24, r14
    3c78:	9f 1d       	adc	r25, r15
    3c7a:	91 83       	std	Z+1, r25	; 0x01
    3c7c:	80 83       	st	Z, r24
    3c7e:	ce 18       	sub	r12, r14
    3c80:	df 08       	sbc	r13, r15
    3c82:	c1 14       	cp	r12, r1
    3c84:	d1 04       	cpc	r13, r1
    3c86:	09 f0       	breq	.+2      	; 0x3c8a <f_write+0x1b4>
    3c88:	5c cf       	rjmp	.-328    	; 0x3b42 <f_write+0x6c>
    3c8a:	1c c0       	rjmp	.+56     	; 0x3cc4 <f_write+0x1ee>
    3c8c:	45 2b       	or	r20, r21
    3c8e:	46 2b       	or	r20, r22
    3c90:	47 2b       	or	r20, r23
    3c92:	69 f4       	brne	.+26     	; 0x3cae <f_write+0x1d8>
    3c94:	6e 85       	ldd	r22, Y+14	; 0x0e
    3c96:	7f 85       	ldd	r23, Y+15	; 0x0f
    3c98:	88 89       	ldd	r24, Y+16	; 0x10
    3c9a:	99 89       	ldd	r25, Y+17	; 0x11
    3c9c:	61 15       	cp	r22, r1
    3c9e:	71 05       	cpc	r23, r1
    3ca0:	81 05       	cpc	r24, r1
    3ca2:	91 05       	cpc	r25, r1
    3ca4:	11 f5       	brne	.+68     	; 0x3cea <f_write+0x214>
    3ca6:	40 e0       	ldi	r20, 0x00	; 0
    3ca8:	50 e0       	ldi	r21, 0x00	; 0
    3caa:	ba 01       	movw	r22, r20
    3cac:	04 c0       	rjmp	.+8      	; 0x3cb6 <f_write+0x1e0>
    3cae:	4a 89       	ldd	r20, Y+18	; 0x12
    3cb0:	5b 89       	ldd	r21, Y+19	; 0x13
    3cb2:	6c 89       	ldd	r22, Y+20	; 0x14
    3cb4:	7d 89       	ldd	r23, Y+21	; 0x15
    3cb6:	cf 01       	movw	r24, r30
    3cb8:	dd d9       	rcall	.-3142   	; 0x3074 <create_chain>
    3cba:	61 15       	cp	r22, r1
    3cbc:	71 05       	cpc	r23, r1
    3cbe:	81 05       	cpc	r24, r1
    3cc0:	91 05       	cpc	r25, r1
    3cc2:	99 f4       	brne	.+38     	; 0x3cea <f_write+0x214>
    3cc4:	8e 81       	ldd	r24, Y+6	; 0x06
    3cc6:	9f 81       	ldd	r25, Y+7	; 0x07
    3cc8:	a8 85       	ldd	r26, Y+8	; 0x08
    3cca:	b9 85       	ldd	r27, Y+9	; 0x09
    3ccc:	4a 85       	ldd	r20, Y+10	; 0x0a
    3cce:	5b 85       	ldd	r21, Y+11	; 0x0b
    3cd0:	6c 85       	ldd	r22, Y+12	; 0x0c
    3cd2:	7d 85       	ldd	r23, Y+13	; 0x0d
    3cd4:	48 17       	cp	r20, r24
    3cd6:	59 07       	cpc	r21, r25
    3cd8:	6a 07       	cpc	r22, r26
    3cda:	7b 07       	cpc	r23, r27
    3cdc:	08 f0       	brcs	.+2      	; 0x3ce0 <f_write+0x20a>
    3cde:	74 c0       	rjmp	.+232    	; 0x3dc8 <f_write+0x2f2>
    3ce0:	8a 87       	std	Y+10, r24	; 0x0a
    3ce2:	9b 87       	std	Y+11, r25	; 0x0b
    3ce4:	ac 87       	std	Y+12, r26	; 0x0c
    3ce6:	bd 87       	std	Y+13, r27	; 0x0d
    3ce8:	6f c0       	rjmp	.+222    	; 0x3dc8 <f_write+0x2f2>
    3cea:	61 30       	cpi	r22, 0x01	; 1
    3cec:	71 05       	cpc	r23, r1
    3cee:	81 05       	cpc	r24, r1
    3cf0:	91 05       	cpc	r25, r1
    3cf2:	11 f4       	brne	.+4      	; 0x3cf8 <f_write+0x222>
    3cf4:	82 e0       	ldi	r24, 0x02	; 2
    3cf6:	07 c0       	rjmp	.+14     	; 0x3d06 <f_write+0x230>
    3cf8:	6f 3f       	cpi	r22, 0xFF	; 255
    3cfa:	ff ef       	ldi	r31, 0xFF	; 255
    3cfc:	7f 07       	cpc	r23, r31
    3cfe:	8f 07       	cpc	r24, r31
    3d00:	9f 07       	cpc	r25, r31
    3d02:	19 f4       	brne	.+6      	; 0x3d0a <f_write+0x234>
    3d04:	81 e0       	ldi	r24, 0x01	; 1
    3d06:	8d 83       	std	Y+5, r24	; 0x05
    3d08:	65 c0       	rjmp	.+202    	; 0x3dd4 <f_write+0x2fe>
    3d0a:	6a 8b       	std	Y+18, r22	; 0x12
    3d0c:	7b 8b       	std	Y+19, r23	; 0x13
    3d0e:	8c 8b       	std	Y+20, r24	; 0x14
    3d10:	9d 8b       	std	Y+21, r25	; 0x15
    3d12:	4e 84       	ldd	r4, Y+14	; 0x0e
    3d14:	5f 84       	ldd	r5, Y+15	; 0x0f
    3d16:	68 88       	ldd	r6, Y+16	; 0x10
    3d18:	79 88       	ldd	r7, Y+17	; 0x11
    3d1a:	45 28       	or	r4, r5
    3d1c:	46 28       	or	r4, r6
    3d1e:	47 28       	or	r4, r7
    3d20:	09 f0       	breq	.+2      	; 0x3d24 <f_write+0x24e>
    3d22:	2e cf       	rjmp	.-420    	; 0x3b80 <f_write+0xaa>
    3d24:	6e 87       	std	Y+14, r22	; 0x0e
    3d26:	7f 87       	std	Y+15, r23	; 0x0f
    3d28:	88 8b       	std	Y+16, r24	; 0x10
    3d2a:	99 8b       	std	Y+17, r25	; 0x11
    3d2c:	29 cf       	rjmp	.-430    	; 0x3b80 <f_write+0xaa>
    3d2e:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <sync_window>
    3d32:	88 23       	and	r24, r24
    3d34:	09 f4       	brne	.+2      	; 0x3d38 <f_write+0x262>
    3d36:	35 cf       	rjmp	.-406    	; 0x3ba2 <f_write+0xcc>
    3d38:	e5 cf       	rjmp	.-54     	; 0x3d04 <f_write+0x22e>
    3d3a:	4e 81       	ldd	r20, Y+6	; 0x06
    3d3c:	5f 81       	ldd	r21, Y+7	; 0x07
    3d3e:	68 85       	ldd	r22, Y+8	; 0x08
    3d40:	79 85       	ldd	r23, Y+9	; 0x09
    3d42:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d44:	9b 85       	ldd	r25, Y+11	; 0x0b
    3d46:	ac 85       	ldd	r26, Y+12	; 0x0c
    3d48:	bd 85       	ldd	r27, Y+13	; 0x0d
    3d4a:	48 17       	cp	r20, r24
    3d4c:	59 07       	cpc	r21, r25
    3d4e:	6a 07       	cpc	r22, r26
    3d50:	7b 07       	cpc	r23, r27
    3d52:	58 f0       	brcs	.+22     	; 0x3d6a <f_write+0x294>
    3d54:	c4 01       	movw	r24, r8
    3d56:	0e 94 e2 11 	call	0x23c4	; 0x23c4 <sync_window>
    3d5a:	81 11       	cpse	r24, r1
    3d5c:	d3 cf       	rjmp	.-90     	; 0x3d04 <f_write+0x22e>
    3d5e:	e8 81       	ld	r30, Y
    3d60:	f9 81       	ldd	r31, Y+1	; 0x01
    3d62:	42 a6       	std	Z+42, r4	; 0x2a
    3d64:	53 a6       	std	Z+43, r5	; 0x2b
    3d66:	64 a6       	std	Z+44, r6	; 0x2c
    3d68:	75 a6       	std	Z+45, r7	; 0x2d
    3d6a:	4e 8a       	std	Y+22, r4	; 0x16
    3d6c:	5f 8a       	std	Y+23, r5	; 0x17
    3d6e:	68 8e       	std	Y+24, r6	; 0x18
    3d70:	79 8e       	std	Y+25, r7	; 0x19
    3d72:	8e 81       	ldd	r24, Y+6	; 0x06
    3d74:	9f 81       	ldd	r25, Y+7	; 0x07
    3d76:	91 70       	andi	r25, 0x01	; 1
    3d78:	20 e0       	ldi	r18, 0x00	; 0
    3d7a:	32 e0       	ldi	r19, 0x02	; 2
    3d7c:	28 1b       	sub	r18, r24
    3d7e:	39 0b       	sbc	r19, r25
    3d80:	76 01       	movw	r14, r12
    3d82:	2c 15       	cp	r18, r12
    3d84:	3d 05       	cpc	r19, r13
    3d86:	08 f4       	brcc	.+2      	; 0x3d8a <f_write+0x2b4>
    3d88:	79 01       	movw	r14, r18
    3d8a:	4e 89       	ldd	r20, Y+22	; 0x16
    3d8c:	5f 89       	ldd	r21, Y+23	; 0x17
    3d8e:	68 8d       	ldd	r22, Y+24	; 0x18
    3d90:	79 8d       	ldd	r23, Y+25	; 0x19
    3d92:	88 81       	ld	r24, Y
    3d94:	99 81       	ldd	r25, Y+1	; 0x01
    3d96:	0e 94 aa 12 	call	0x2554	; 0x2554 <move_window>
    3d9a:	81 11       	cpse	r24, r1
    3d9c:	b3 cf       	rjmp	.-154    	; 0x3d04 <f_write+0x22e>
    3d9e:	8e 81       	ldd	r24, Y+6	; 0x06
    3da0:	9f 81       	ldd	r25, Y+7	; 0x07
    3da2:	a8 85       	ldd	r26, Y+8	; 0x08
    3da4:	b9 85       	ldd	r27, Y+9	; 0x09
    3da6:	91 70       	andi	r25, 0x01	; 1
    3da8:	aa 27       	eor	r26, r26
    3daa:	bb 27       	eor	r27, r27
    3dac:	8e 96       	adiw	r24, 0x2e	; 46
    3dae:	28 81       	ld	r18, Y
    3db0:	39 81       	ldd	r19, Y+1	; 0x01
    3db2:	a7 01       	movw	r20, r14
    3db4:	b5 01       	movw	r22, r10
    3db6:	82 0f       	add	r24, r18
    3db8:	93 1f       	adc	r25, r19
    3dba:	0e 94 3b 11 	call	0x2276	; 0x2276 <mem_cpy>
    3dbe:	e8 81       	ld	r30, Y
    3dc0:	f9 81       	ldd	r31, Y+1	; 0x01
    3dc2:	31 e0       	ldi	r19, 0x01	; 1
    3dc4:	34 83       	std	Z+4, r19	; 0x04
    3dc6:	46 cf       	rjmp	.-372    	; 0x3c54 <f_write+0x17e>
    3dc8:	8c 81       	ldd	r24, Y+4	; 0x04
    3dca:	80 62       	ori	r24, 0x20	; 32
    3dcc:	8c 83       	std	Y+4, r24	; 0x04
    3dce:	80 e0       	ldi	r24, 0x00	; 0
    3dd0:	01 c0       	rjmp	.+2      	; 0x3dd4 <f_write+0x2fe>
    3dd2:	87 e0       	ldi	r24, 0x07	; 7
    3dd4:	df 91       	pop	r29
    3dd6:	cf 91       	pop	r28
    3dd8:	1f 91       	pop	r17
    3dda:	0f 91       	pop	r16
    3ddc:	ff 90       	pop	r15
    3dde:	ef 90       	pop	r14
    3de0:	df 90       	pop	r13
    3de2:	cf 90       	pop	r12
    3de4:	bf 90       	pop	r11
    3de6:	af 90       	pop	r10
    3de8:	9f 90       	pop	r9
    3dea:	8f 90       	pop	r8
    3dec:	7f 90       	pop	r7
    3dee:	6f 90       	pop	r6
    3df0:	5f 90       	pop	r5
    3df2:	4f 90       	pop	r4
    3df4:	3f 90       	pop	r3
    3df6:	2f 90       	pop	r2
    3df8:	08 95       	ret

00003dfa <f_sync>:
    3dfa:	cf 93       	push	r28
    3dfc:	df 93       	push	r29
    3dfe:	ec 01       	movw	r28, r24
    3e00:	0e 94 c4 11 	call	0x2388	; 0x2388 <validate>
    3e04:	81 11       	cpse	r24, r1
    3e06:	39 c0       	rjmp	.+114    	; 0x3e7a <f_sync+0x80>
    3e08:	9c 81       	ldd	r25, Y+4	; 0x04
    3e0a:	95 ff       	sbrs	r25, 5
    3e0c:	36 c0       	rjmp	.+108    	; 0x3e7a <f_sync+0x80>
    3e0e:	4a 8d       	ldd	r20, Y+26	; 0x1a
    3e10:	5b 8d       	ldd	r21, Y+27	; 0x1b
    3e12:	6c 8d       	ldd	r22, Y+28	; 0x1c
    3e14:	7d 8d       	ldd	r23, Y+29	; 0x1d
    3e16:	88 81       	ld	r24, Y
    3e18:	99 81       	ldd	r25, Y+1	; 0x01
    3e1a:	0e 94 aa 12 	call	0x2554	; 0x2554 <move_window>
    3e1e:	81 11       	cpse	r24, r1
    3e20:	2c c0       	rjmp	.+88     	; 0x3e7a <f_sync+0x80>
    3e22:	ee 8d       	ldd	r30, Y+30	; 0x1e
    3e24:	ff 8d       	ldd	r31, Y+31	; 0x1f
    3e26:	83 85       	ldd	r24, Z+11	; 0x0b
    3e28:	80 62       	ori	r24, 0x20	; 32
    3e2a:	83 87       	std	Z+11, r24	; 0x0b
    3e2c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e2e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e30:	ac 85       	ldd	r26, Y+12	; 0x0c
    3e32:	bd 85       	ldd	r27, Y+13	; 0x0d
    3e34:	84 8f       	std	Z+28, r24	; 0x1c
    3e36:	95 8f       	std	Z+29, r25	; 0x1d
    3e38:	a6 8f       	std	Z+30, r26	; 0x1e
    3e3a:	b7 8f       	std	Z+31, r27	; 0x1f
    3e3c:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e3e:	9f 85       	ldd	r25, Y+15	; 0x0f
    3e40:	a8 89       	ldd	r26, Y+16	; 0x10
    3e42:	b9 89       	ldd	r27, Y+17	; 0x11
    3e44:	93 8f       	std	Z+27, r25	; 0x1b
    3e46:	82 8f       	std	Z+26, r24	; 0x1a
    3e48:	b5 8b       	std	Z+21, r27	; 0x15
    3e4a:	a4 8b       	std	Z+20, r26	; 0x14
    3e4c:	80 e0       	ldi	r24, 0x00	; 0
    3e4e:	90 e0       	ldi	r25, 0x00	; 0
    3e50:	a9 e6       	ldi	r26, 0x69	; 105
    3e52:	b5 e4       	ldi	r27, 0x45	; 69
    3e54:	86 8b       	std	Z+22, r24	; 0x16
    3e56:	97 8b       	std	Z+23, r25	; 0x17
    3e58:	a0 8f       	std	Z+24, r26	; 0x18
    3e5a:	b1 8f       	std	Z+25, r27	; 0x19
    3e5c:	13 8a       	std	Z+19, r1	; 0x13
    3e5e:	12 8a       	std	Z+18, r1	; 0x12
    3e60:	8c 81       	ldd	r24, Y+4	; 0x04
    3e62:	8f 7d       	andi	r24, 0xDF	; 223
    3e64:	8c 83       	std	Y+4, r24	; 0x04
    3e66:	e8 81       	ld	r30, Y
    3e68:	f9 81       	ldd	r31, Y+1	; 0x01
    3e6a:	81 e0       	ldi	r24, 0x01	; 1
    3e6c:	84 83       	std	Z+4, r24	; 0x04
    3e6e:	88 81       	ld	r24, Y
    3e70:	99 81       	ldd	r25, Y+1	; 0x01
    3e72:	df 91       	pop	r29
    3e74:	cf 91       	pop	r28
    3e76:	0c 94 41 12 	jmp	0x2482	; 0x2482 <sync_fs>
    3e7a:	df 91       	pop	r29
    3e7c:	cf 91       	pop	r28
    3e7e:	08 95       	ret

00003e80 <f_close>:
    3e80:	cf 93       	push	r28
    3e82:	df 93       	push	r29
    3e84:	ec 01       	movw	r28, r24
    3e86:	b9 df       	rcall	.-142    	; 0x3dfa <f_sync>
    3e88:	81 11       	cpse	r24, r1
    3e8a:	07 c0       	rjmp	.+14     	; 0x3e9a <f_close+0x1a>
    3e8c:	ce 01       	movw	r24, r28
    3e8e:	0e 94 c4 11 	call	0x2388	; 0x2388 <validate>
    3e92:	81 11       	cpse	r24, r1
    3e94:	02 c0       	rjmp	.+4      	; 0x3e9a <f_close+0x1a>
    3e96:	19 82       	std	Y+1, r1	; 0x01
    3e98:	18 82       	st	Y, r1
    3e9a:	df 91       	pop	r29
    3e9c:	cf 91       	pop	r28
    3e9e:	08 95       	ret

00003ea0 <f_lseek>:
    3ea0:	2f 92       	push	r2
    3ea2:	3f 92       	push	r3
    3ea4:	4f 92       	push	r4
    3ea6:	5f 92       	push	r5
    3ea8:	6f 92       	push	r6
    3eaa:	7f 92       	push	r7
    3eac:	8f 92       	push	r8
    3eae:	9f 92       	push	r9
    3eb0:	af 92       	push	r10
    3eb2:	bf 92       	push	r11
    3eb4:	cf 92       	push	r12
    3eb6:	df 92       	push	r13
    3eb8:	ef 92       	push	r14
    3eba:	ff 92       	push	r15
    3ebc:	0f 93       	push	r16
    3ebe:	1f 93       	push	r17
    3ec0:	cf 93       	push	r28
    3ec2:	df 93       	push	r29
    3ec4:	00 d0       	rcall	.+0      	; 0x3ec6 <f_lseek+0x26>
    3ec6:	00 d0       	rcall	.+0      	; 0x3ec8 <f_lseek+0x28>
    3ec8:	cd b7       	in	r28, 0x3d	; 61
    3eca:	de b7       	in	r29, 0x3e	; 62
    3ecc:	1c 01       	movw	r2, r24
    3ece:	6a 01       	movw	r12, r20
    3ed0:	7b 01       	movw	r14, r22
    3ed2:	0e 94 c4 11 	call	0x2388	; 0x2388 <validate>
    3ed6:	81 11       	cpse	r24, r1
    3ed8:	5b c1       	rjmp	.+694    	; 0x4190 <f_lseek+0x2f0>
    3eda:	d1 01       	movw	r26, r2
    3edc:	15 96       	adiw	r26, 0x05	; 5
    3ede:	8c 91       	ld	r24, X
    3ee0:	15 97       	sbiw	r26, 0x05	; 5
    3ee2:	81 11       	cpse	r24, r1
    3ee4:	55 c1       	rjmp	.+682    	; 0x4190 <f_lseek+0x2f0>
    3ee6:	1a 96       	adiw	r26, 0x0a	; 10
    3ee8:	8d 91       	ld	r24, X+
    3eea:	9d 91       	ld	r25, X+
    3eec:	0d 90       	ld	r0, X+
    3eee:	bc 91       	ld	r27, X
    3ef0:	a0 2d       	mov	r26, r0
    3ef2:	8c 15       	cp	r24, r12
    3ef4:	9d 05       	cpc	r25, r13
    3ef6:	ae 05       	cpc	r26, r14
    3ef8:	bf 05       	cpc	r27, r15
    3efa:	30 f4       	brcc	.+12     	; 0x3f08 <f_lseek+0x68>
    3efc:	f1 01       	movw	r30, r2
    3efe:	24 81       	ldd	r18, Z+4	; 0x04
    3f00:	21 fd       	sbrc	r18, 1
    3f02:	02 c0       	rjmp	.+4      	; 0x3f08 <f_lseek+0x68>
    3f04:	6c 01       	movw	r12, r24
    3f06:	7d 01       	movw	r14, r26
    3f08:	d1 01       	movw	r26, r2
    3f0a:	16 96       	adiw	r26, 0x06	; 6
    3f0c:	4d 90       	ld	r4, X+
    3f0e:	5d 90       	ld	r5, X+
    3f10:	6d 90       	ld	r6, X+
    3f12:	7c 90       	ld	r7, X
    3f14:	19 97       	sbiw	r26, 0x09	; 9
    3f16:	f1 01       	movw	r30, r2
    3f18:	16 82       	std	Z+6, r1	; 0x06
    3f1a:	17 82       	std	Z+7, r1	; 0x07
    3f1c:	10 86       	std	Z+8, r1	; 0x08
    3f1e:	11 86       	std	Z+9, r1	; 0x09
    3f20:	c1 14       	cp	r12, r1
    3f22:	d1 04       	cpc	r13, r1
    3f24:	e1 04       	cpc	r14, r1
    3f26:	f1 04       	cpc	r15, r1
    3f28:	21 f4       	brne	.+8      	; 0x3f32 <f_lseek+0x92>
    3f2a:	c1 2c       	mov	r12, r1
    3f2c:	d1 2c       	mov	r13, r1
    3f2e:	76 01       	movw	r14, r12
    3f30:	02 c1       	rjmp	.+516    	; 0x4136 <f_lseek+0x296>
    3f32:	00 81       	ld	r16, Z
    3f34:	11 81       	ldd	r17, Z+1	; 0x01
    3f36:	f8 01       	movw	r30, r16
    3f38:	82 80       	ldd	r8, Z+2	; 0x02
    3f3a:	91 2c       	mov	r9, r1
    3f3c:	a1 2c       	mov	r10, r1
    3f3e:	b1 2c       	mov	r11, r1
    3f40:	39 e0       	ldi	r19, 0x09	; 9
    3f42:	88 0c       	add	r8, r8
    3f44:	99 1c       	adc	r9, r9
    3f46:	aa 1c       	adc	r10, r10
    3f48:	bb 1c       	adc	r11, r11
    3f4a:	3a 95       	dec	r19
    3f4c:	d1 f7       	brne	.-12     	; 0x3f42 <f_lseek+0xa2>
    3f4e:	41 14       	cp	r4, r1
    3f50:	51 04       	cpc	r5, r1
    3f52:	61 04       	cpc	r6, r1
    3f54:	71 04       	cpc	r7, r1
    3f56:	09 f4       	brne	.+2      	; 0x3f5a <f_lseek+0xba>
    3f58:	3f c0       	rjmp	.+126    	; 0x3fd8 <f_lseek+0x138>
    3f5a:	f1 e0       	ldi	r31, 0x01	; 1
    3f5c:	4f 1a       	sub	r4, r31
    3f5e:	51 08       	sbc	r5, r1
    3f60:	61 08       	sbc	r6, r1
    3f62:	71 08       	sbc	r7, r1
    3f64:	c7 01       	movw	r24, r14
    3f66:	b6 01       	movw	r22, r12
    3f68:	61 50       	subi	r22, 0x01	; 1
    3f6a:	71 09       	sbc	r23, r1
    3f6c:	81 09       	sbc	r24, r1
    3f6e:	91 09       	sbc	r25, r1
    3f70:	a5 01       	movw	r20, r10
    3f72:	94 01       	movw	r18, r8
    3f74:	0e 94 7a 35 	call	0x6af4	; 0x6af4 <__udivmodsi4>
    3f78:	29 83       	std	Y+1, r18	; 0x01
    3f7a:	3a 83       	std	Y+2, r19	; 0x02
    3f7c:	4b 83       	std	Y+3, r20	; 0x03
    3f7e:	5c 83       	std	Y+4, r21	; 0x04
    3f80:	c3 01       	movw	r24, r6
    3f82:	b2 01       	movw	r22, r4
    3f84:	a5 01       	movw	r20, r10
    3f86:	94 01       	movw	r18, r8
    3f88:	0e 94 7a 35 	call	0x6af4	; 0x6af4 <__udivmodsi4>
    3f8c:	89 81       	ldd	r24, Y+1	; 0x01
    3f8e:	9a 81       	ldd	r25, Y+2	; 0x02
    3f90:	ab 81       	ldd	r26, Y+3	; 0x03
    3f92:	bc 81       	ldd	r27, Y+4	; 0x04
    3f94:	82 17       	cp	r24, r18
    3f96:	93 07       	cpc	r25, r19
    3f98:	a4 07       	cpc	r26, r20
    3f9a:	b5 07       	cpc	r27, r21
    3f9c:	e8 f0       	brcs	.+58     	; 0x3fd8 <f_lseek+0x138>
    3f9e:	88 27       	eor	r24, r24
    3fa0:	99 27       	eor	r25, r25
    3fa2:	dc 01       	movw	r26, r24
    3fa4:	88 19       	sub	r24, r8
    3fa6:	99 09       	sbc	r25, r9
    3fa8:	aa 09       	sbc	r26, r10
    3faa:	bb 09       	sbc	r27, r11
    3fac:	48 22       	and	r4, r24
    3fae:	59 22       	and	r5, r25
    3fb0:	6a 22       	and	r6, r26
    3fb2:	7b 22       	and	r7, r27
    3fb4:	d1 01       	movw	r26, r2
    3fb6:	16 96       	adiw	r26, 0x06	; 6
    3fb8:	4d 92       	st	X+, r4
    3fba:	5d 92       	st	X+, r5
    3fbc:	6d 92       	st	X+, r6
    3fbe:	7c 92       	st	X, r7
    3fc0:	19 97       	sbiw	r26, 0x09	; 9
    3fc2:	c4 18       	sub	r12, r4
    3fc4:	d5 08       	sbc	r13, r5
    3fc6:	e6 08       	sbc	r14, r6
    3fc8:	f7 08       	sbc	r15, r7
    3fca:	52 96       	adiw	r26, 0x12	; 18
    3fcc:	4d 91       	ld	r20, X+
    3fce:	5d 91       	ld	r21, X+
    3fd0:	6d 91       	ld	r22, X+
    3fd2:	7c 91       	ld	r23, X
    3fd4:	55 97       	sbiw	r26, 0x15	; 21
    3fd6:	31 c0       	rjmp	.+98     	; 0x403a <f_lseek+0x19a>
    3fd8:	f1 01       	movw	r30, r2
    3fda:	46 85       	ldd	r20, Z+14	; 0x0e
    3fdc:	57 85       	ldd	r21, Z+15	; 0x0f
    3fde:	60 89       	ldd	r22, Z+16	; 0x10
    3fe0:	71 89       	ldd	r23, Z+17	; 0x11
    3fe2:	41 15       	cp	r20, r1
    3fe4:	51 05       	cpc	r21, r1
    3fe6:	61 05       	cpc	r22, r1
    3fe8:	71 05       	cpc	r23, r1
    3fea:	11 f5       	brne	.+68     	; 0x4030 <f_lseek+0x190>
    3fec:	40 e0       	ldi	r20, 0x00	; 0
    3fee:	50 e0       	ldi	r21, 0x00	; 0
    3ff0:	ba 01       	movw	r22, r20
    3ff2:	c8 01       	movw	r24, r16
    3ff4:	3f d8       	rcall	.-3970   	; 0x3074 <create_chain>
    3ff6:	ab 01       	movw	r20, r22
    3ff8:	bc 01       	movw	r22, r24
    3ffa:	41 30       	cpi	r20, 0x01	; 1
    3ffc:	51 05       	cpc	r21, r1
    3ffe:	61 05       	cpc	r22, r1
    4000:	71 05       	cpc	r23, r1
    4002:	29 f4       	brne	.+10     	; 0x400e <f_lseek+0x16e>
    4004:	82 e0       	ldi	r24, 0x02	; 2
    4006:	d1 01       	movw	r26, r2
    4008:	15 96       	adiw	r26, 0x05	; 5
    400a:	8c 93       	st	X, r24
    400c:	c1 c0       	rjmp	.+386    	; 0x4190 <f_lseek+0x2f0>
    400e:	4f 3f       	cpi	r20, 0xFF	; 255
    4010:	bf ef       	ldi	r27, 0xFF	; 255
    4012:	5b 07       	cpc	r21, r27
    4014:	6b 07       	cpc	r22, r27
    4016:	7b 07       	cpc	r23, r27
    4018:	21 f4       	brne	.+8      	; 0x4022 <f_lseek+0x182>
    401a:	81 e0       	ldi	r24, 0x01	; 1
    401c:	f1 01       	movw	r30, r2
    401e:	85 83       	std	Z+5, r24	; 0x05
    4020:	b7 c0       	rjmp	.+366    	; 0x4190 <f_lseek+0x2f0>
    4022:	d1 01       	movw	r26, r2
    4024:	1e 96       	adiw	r26, 0x0e	; 14
    4026:	4d 93       	st	X+, r20
    4028:	5d 93       	st	X+, r21
    402a:	6d 93       	st	X+, r22
    402c:	7c 93       	st	X, r23
    402e:	51 97       	sbiw	r26, 0x11	; 17
    4030:	f1 01       	movw	r30, r2
    4032:	42 8b       	std	Z+18, r20	; 0x12
    4034:	53 8b       	std	Z+19, r21	; 0x13
    4036:	64 8b       	std	Z+20, r22	; 0x14
    4038:	75 8b       	std	Z+21, r23	; 0x15
    403a:	41 15       	cp	r20, r1
    403c:	51 05       	cpc	r21, r1
    403e:	61 05       	cpc	r22, r1
    4040:	71 05       	cpc	r23, r1
    4042:	09 f4       	brne	.+2      	; 0x4046 <f_lseek+0x1a6>
    4044:	72 cf       	rjmp	.-284    	; 0x3f2a <f_lseek+0x8a>
    4046:	8c 14       	cp	r8, r12
    4048:	9d 04       	cpc	r9, r13
    404a:	ae 04       	cpc	r10, r14
    404c:	bf 04       	cpc	r11, r15
    404e:	08 f0       	brcs	.+2      	; 0x4052 <f_lseek+0x1b2>
    4050:	46 c0       	rjmp	.+140    	; 0x40de <f_lseek+0x23e>
    4052:	d1 01       	movw	r26, r2
    4054:	14 96       	adiw	r26, 0x04	; 4
    4056:	2c 91       	ld	r18, X
    4058:	14 97       	sbiw	r26, 0x04	; 4
    405a:	8d 91       	ld	r24, X+
    405c:	9c 91       	ld	r25, X
    405e:	21 ff       	sbrs	r18, 1
    4060:	09 c0       	rjmp	.+18     	; 0x4074 <f_lseek+0x1d4>
    4062:	08 d8       	rcall	.-4080   	; 0x3074 <create_chain>
    4064:	ab 01       	movw	r20, r22
    4066:	bc 01       	movw	r22, r24
    4068:	41 15       	cp	r20, r1
    406a:	51 05       	cpc	r21, r1
    406c:	61 05       	cpc	r22, r1
    406e:	71 05       	cpc	r23, r1
    4070:	29 f4       	brne	.+10     	; 0x407c <f_lseek+0x1dc>
    4072:	33 c0       	rjmp	.+102    	; 0x40da <f_lseek+0x23a>
    4074:	0e 94 a5 15 	call	0x2b4a	; 0x2b4a <get_fat>
    4078:	ab 01       	movw	r20, r22
    407a:	bc 01       	movw	r22, r24
    407c:	4f 3f       	cpi	r20, 0xFF	; 255
    407e:	bf ef       	ldi	r27, 0xFF	; 255
    4080:	5b 07       	cpc	r21, r27
    4082:	6b 07       	cpc	r22, r27
    4084:	7b 07       	cpc	r23, r27
    4086:	49 f2       	breq	.-110    	; 0x401a <f_lseek+0x17a>
    4088:	42 30       	cpi	r20, 0x02	; 2
    408a:	51 05       	cpc	r21, r1
    408c:	61 05       	cpc	r22, r1
    408e:	71 05       	cpc	r23, r1
    4090:	08 f4       	brcc	.+2      	; 0x4094 <f_lseek+0x1f4>
    4092:	b8 cf       	rjmp	.-144    	; 0x4004 <f_lseek+0x164>
    4094:	d1 01       	movw	r26, r2
    4096:	ed 91       	ld	r30, X+
    4098:	fc 91       	ld	r31, X
    409a:	82 89       	ldd	r24, Z+18	; 0x12
    409c:	93 89       	ldd	r25, Z+19	; 0x13
    409e:	a4 89       	ldd	r26, Z+20	; 0x14
    40a0:	b5 89       	ldd	r27, Z+21	; 0x15
    40a2:	48 17       	cp	r20, r24
    40a4:	59 07       	cpc	r21, r25
    40a6:	6a 07       	cpc	r22, r26
    40a8:	7b 07       	cpc	r23, r27
    40aa:	08 f0       	brcs	.+2      	; 0x40ae <f_lseek+0x20e>
    40ac:	ab cf       	rjmp	.-170    	; 0x4004 <f_lseek+0x164>
    40ae:	f1 01       	movw	r30, r2
    40b0:	42 8b       	std	Z+18, r20	; 0x12
    40b2:	53 8b       	std	Z+19, r21	; 0x13
    40b4:	64 8b       	std	Z+20, r22	; 0x14
    40b6:	75 8b       	std	Z+21, r23	; 0x15
    40b8:	86 81       	ldd	r24, Z+6	; 0x06
    40ba:	97 81       	ldd	r25, Z+7	; 0x07
    40bc:	a0 85       	ldd	r26, Z+8	; 0x08
    40be:	b1 85       	ldd	r27, Z+9	; 0x09
    40c0:	88 0d       	add	r24, r8
    40c2:	99 1d       	adc	r25, r9
    40c4:	aa 1d       	adc	r26, r10
    40c6:	bb 1d       	adc	r27, r11
    40c8:	86 83       	std	Z+6, r24	; 0x06
    40ca:	97 83       	std	Z+7, r25	; 0x07
    40cc:	a0 87       	std	Z+8, r26	; 0x08
    40ce:	b1 87       	std	Z+9, r27	; 0x09
    40d0:	c8 18       	sub	r12, r8
    40d2:	d9 08       	sbc	r13, r9
    40d4:	ea 08       	sbc	r14, r10
    40d6:	fb 08       	sbc	r15, r11
    40d8:	b6 cf       	rjmp	.-148    	; 0x4046 <f_lseek+0x1a6>
    40da:	75 01       	movw	r14, r10
    40dc:	64 01       	movw	r12, r8
    40de:	f1 01       	movw	r30, r2
    40e0:	86 81       	ldd	r24, Z+6	; 0x06
    40e2:	97 81       	ldd	r25, Z+7	; 0x07
    40e4:	a0 85       	ldd	r26, Z+8	; 0x08
    40e6:	b1 85       	ldd	r27, Z+9	; 0x09
    40e8:	8c 0d       	add	r24, r12
    40ea:	9d 1d       	adc	r25, r13
    40ec:	ae 1d       	adc	r26, r14
    40ee:	bf 1d       	adc	r27, r15
    40f0:	86 83       	std	Z+6, r24	; 0x06
    40f2:	97 83       	std	Z+7, r25	; 0x07
    40f4:	a0 87       	std	Z+8, r26	; 0x08
    40f6:	b1 87       	std	Z+9, r27	; 0x09
    40f8:	d7 01       	movw	r26, r14
    40fa:	c6 01       	movw	r24, r12
    40fc:	91 70       	andi	r25, 0x01	; 1
    40fe:	aa 27       	eor	r26, r26
    4100:	bb 27       	eor	r27, r27
    4102:	89 2b       	or	r24, r25
    4104:	8a 2b       	or	r24, r26
    4106:	8b 2b       	or	r24, r27
    4108:	09 f4       	brne	.+2      	; 0x410c <f_lseek+0x26c>
    410a:	0f cf       	rjmp	.-482    	; 0x3f2a <f_lseek+0x8a>
    410c:	80 81       	ld	r24, Z
    410e:	91 81       	ldd	r25, Z+1	; 0x01
    4110:	0e 94 7d 15 	call	0x2afa	; 0x2afa <clust2sect>
    4114:	61 15       	cp	r22, r1
    4116:	71 05       	cpc	r23, r1
    4118:	81 05       	cpc	r24, r1
    411a:	91 05       	cpc	r25, r1
    411c:	09 f4       	brne	.+2      	; 0x4120 <f_lseek+0x280>
    411e:	72 cf       	rjmp	.-284    	; 0x4004 <f_lseek+0x164>
    4120:	29 e0       	ldi	r18, 0x09	; 9
    4122:	f6 94       	lsr	r15
    4124:	e7 94       	ror	r14
    4126:	d7 94       	ror	r13
    4128:	c7 94       	ror	r12
    412a:	2a 95       	dec	r18
    412c:	d1 f7       	brne	.-12     	; 0x4122 <f_lseek+0x282>
    412e:	c6 0e       	add	r12, r22
    4130:	d7 1e       	adc	r13, r23
    4132:	e8 1e       	adc	r14, r24
    4134:	f9 1e       	adc	r15, r25
    4136:	f1 01       	movw	r30, r2
    4138:	86 81       	ldd	r24, Z+6	; 0x06
    413a:	97 81       	ldd	r25, Z+7	; 0x07
    413c:	a0 85       	ldd	r26, Z+8	; 0x08
    413e:	b1 85       	ldd	r27, Z+9	; 0x09
    4140:	ac 01       	movw	r20, r24
    4142:	bd 01       	movw	r22, r26
    4144:	51 70       	andi	r21, 0x01	; 1
    4146:	66 27       	eor	r22, r22
    4148:	77 27       	eor	r23, r23
    414a:	45 2b       	or	r20, r21
    414c:	46 2b       	or	r20, r22
    414e:	47 2b       	or	r20, r23
    4150:	69 f0       	breq	.+26     	; 0x416c <f_lseek+0x2cc>
    4152:	46 89       	ldd	r20, Z+22	; 0x16
    4154:	57 89       	ldd	r21, Z+23	; 0x17
    4156:	60 8d       	ldd	r22, Z+24	; 0x18
    4158:	71 8d       	ldd	r23, Z+25	; 0x19
    415a:	c4 16       	cp	r12, r20
    415c:	d5 06       	cpc	r13, r21
    415e:	e6 06       	cpc	r14, r22
    4160:	f7 06       	cpc	r15, r23
    4162:	21 f0       	breq	.+8      	; 0x416c <f_lseek+0x2cc>
    4164:	c6 8a       	std	Z+22, r12	; 0x16
    4166:	d7 8a       	std	Z+23, r13	; 0x17
    4168:	e0 8e       	std	Z+24, r14	; 0x18
    416a:	f1 8e       	std	Z+25, r15	; 0x19
    416c:	f1 01       	movw	r30, r2
    416e:	42 85       	ldd	r20, Z+10	; 0x0a
    4170:	53 85       	ldd	r21, Z+11	; 0x0b
    4172:	64 85       	ldd	r22, Z+12	; 0x0c
    4174:	75 85       	ldd	r23, Z+13	; 0x0d
    4176:	48 17       	cp	r20, r24
    4178:	59 07       	cpc	r21, r25
    417a:	6a 07       	cpc	r22, r26
    417c:	7b 07       	cpc	r23, r27
    417e:	38 f4       	brcc	.+14     	; 0x418e <f_lseek+0x2ee>
    4180:	82 87       	std	Z+10, r24	; 0x0a
    4182:	93 87       	std	Z+11, r25	; 0x0b
    4184:	a4 87       	std	Z+12, r26	; 0x0c
    4186:	b5 87       	std	Z+13, r27	; 0x0d
    4188:	84 81       	ldd	r24, Z+4	; 0x04
    418a:	80 62       	ori	r24, 0x20	; 32
    418c:	84 83       	std	Z+4, r24	; 0x04
    418e:	80 e0       	ldi	r24, 0x00	; 0
    4190:	0f 90       	pop	r0
    4192:	0f 90       	pop	r0
    4194:	0f 90       	pop	r0
    4196:	0f 90       	pop	r0
    4198:	df 91       	pop	r29
    419a:	cf 91       	pop	r28
    419c:	1f 91       	pop	r17
    419e:	0f 91       	pop	r16
    41a0:	ff 90       	pop	r15
    41a2:	ef 90       	pop	r14
    41a4:	df 90       	pop	r13
    41a6:	cf 90       	pop	r12
    41a8:	bf 90       	pop	r11
    41aa:	af 90       	pop	r10
    41ac:	9f 90       	pop	r9
    41ae:	8f 90       	pop	r8
    41b0:	7f 90       	pop	r7
    41b2:	6f 90       	pop	r6
    41b4:	5f 90       	pop	r5
    41b6:	4f 90       	pop	r4
    41b8:	3f 90       	pop	r3
    41ba:	2f 90       	pop	r2
    41bc:	08 95       	ret

000041be <f_stat>:

FRESULT f_stat (
	const TCHAR* path,	/* Pointer to the file path */
	FILINFO* fno		/* Pointer to file information to return */
)
{
    41be:	ef 92       	push	r14
    41c0:	ff 92       	push	r15
    41c2:	1f 93       	push	r17
    41c4:	cf 93       	push	r28
    41c6:	df 93       	push	r29
    41c8:	cd b7       	in	r28, 0x3d	; 61
    41ca:	de b7       	in	r29, 0x3e	; 62
    41cc:	a4 97       	sbiw	r28, 0x24	; 36
    41ce:	0f b6       	in	r0, 0x3f	; 63
    41d0:	f8 94       	cli
    41d2:	de bf       	out	0x3e, r29	; 62
    41d4:	0f be       	out	0x3f, r0	; 63
    41d6:	cd bf       	out	0x3d, r28	; 61
    41d8:	9c a3       	std	Y+36, r25	; 0x24
    41da:	8b a3       	std	Y+35, r24	; 0x23
    41dc:	7b 01       	movw	r14, r22
	DIR dj;
	DEF_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
    41de:	40 e0       	ldi	r20, 0x00	; 0
    41e0:	be 01       	movw	r22, r28
    41e2:	6d 5d       	subi	r22, 0xDD	; 221
    41e4:	7f 4f       	sbci	r23, 0xFF	; 255
    41e6:	ce 01       	movw	r24, r28
    41e8:	01 96       	adiw	r24, 0x01	; 1
    41ea:	0e 94 1f 13 	call	0x263e	; 0x263e <find_volume>
    41ee:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    41f0:	81 11       	cpse	r24, r1
    41f2:	19 c0       	rjmp	.+50     	; 0x4226 <f_stat+0x68>
		INIT_BUF(dj);
    41f4:	ce 01       	movw	r24, r28
    41f6:	47 96       	adiw	r24, 0x17	; 23
    41f8:	9e 8b       	std	Y+22, r25	; 0x16
    41fa:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    41fc:	6b a1       	ldd	r22, Y+35	; 0x23
    41fe:	7c a1       	ldd	r23, Y+36	; 0x24
    4200:	46 97       	sbiw	r24, 0x16	; 22
    4202:	0e d9       	rcall	.-3556   	; 0x3420 <follow_path>
    4204:	18 2f       	mov	r17, r24
		if (res == FR_OK) {				/* Follow completed */
    4206:	81 11       	cpse	r24, r1
    4208:	0e c0       	rjmp	.+28     	; 0x4226 <f_stat+0x68>
			if (dj.dir) {		/* Found an object */
    420a:	8b 89       	ldd	r24, Y+19	; 0x13
    420c:	9c 89       	ldd	r25, Y+20	; 0x14
    420e:	89 2b       	or	r24, r25
    4210:	49 f0       	breq	.+18     	; 0x4224 <f_stat+0x66>
				if (fno) get_fileinfo(&dj, fno);
    4212:	e1 14       	cp	r14, r1
    4214:	f1 04       	cpc	r15, r1
    4216:	39 f0       	breq	.+14     	; 0x4226 <f_stat+0x68>
    4218:	b7 01       	movw	r22, r14
    421a:	ce 01       	movw	r24, r28
    421c:	01 96       	adiw	r24, 0x01	; 1
    421e:	0e 94 58 11 	call	0x22b0	; 0x22b0 <get_fileinfo>
    4222:	01 c0       	rjmp	.+2      	; 0x4226 <f_stat+0x68>
			} else {			/* It is root directory */
				res = FR_INVALID_NAME;
    4224:	16 e0       	ldi	r17, 0x06	; 6
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    4226:	81 2f       	mov	r24, r17
    4228:	a4 96       	adiw	r28, 0x24	; 36
    422a:	0f b6       	in	r0, 0x3f	; 63
    422c:	f8 94       	cli
    422e:	de bf       	out	0x3e, r29	; 62
    4230:	0f be       	out	0x3f, r0	; 63
    4232:	cd bf       	out	0x3d, r28	; 61
    4234:	df 91       	pop	r29
    4236:	cf 91       	pop	r28
    4238:	1f 91       	pop	r17
    423a:	ff 90       	pop	r15
    423c:	ef 90       	pop	r14
    423e:	08 95       	ret

00004240 <SCSI_Command_ReadWrite_10>:
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_ReadWrite_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                      const bool IsDataRead)
{
    4240:	bf 92       	push	r11
    4242:	cf 92       	push	r12
    4244:	df 92       	push	r13
    4246:	ef 92       	push	r14
    4248:	ff 92       	push	r15
    424a:	0f 93       	push	r16
    424c:	1f 93       	push	r17
    424e:	cf 93       	push	r28
    4250:	df 93       	push	r29
    4252:	ec 01       	movw	r28, r24
    4254:	b6 2e       	mov	r11, r22

				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
    4256:	c8 a0       	ldd	r12, Y+32	; 0x20
    4258:	df 8c       	ldd	r13, Y+31	; 0x1f
    425a:	ee 8c       	ldd	r14, Y+30	; 0x1e
    425c:	fd 8c       	ldd	r15, Y+29	; 0x1d

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
    425e:	0b a1       	ldd	r16, Y+35	; 0x23
    4260:	1a a1       	ldd	r17, Y+34	; 0x22

	/* Load in the 16-bit total blocks (SCSI uses big-endian, so have to reverse the byte order) */
	TotalBlocks  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[7]);

	/* Check if the block address is outside the maximum allowable value for the LUN */
	if (BlockAddress >= get_num_of_sectors())
    4262:	0e 94 22 0c 	call	0x1844	; 0x1844 <get_num_of_sectors>
    4266:	c6 16       	cp	r12, r22
    4268:	d7 06       	cpc	r13, r23
    426a:	e8 06       	cpc	r14, r24
    426c:	f9 06       	cpc	r15, r25
    426e:	68 f0       	brcs	.+26     	; 0x428a <SCSI_Command_ReadWrite_10+0x4a>
	{
		/* Block address is invalid, update SENSE key and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    4270:	80 91 34 01 	lds	r24, 0x0134
    4274:	80 7f       	andi	r24, 0xF0	; 240
    4276:	85 60       	ori	r24, 0x05	; 5
    4278:	80 93 34 01 	sts	0x0134, r24
    427c:	81 e2       	ldi	r24, 0x21	; 33
    427e:	80 93 3e 01 	sts	0x013E, r24
    4282:	10 92 3f 01 	sts	0x013F, r1
    4286:	80 e0       	ldi	r24, 0x00	; 0
    4288:	22 c0       	rjmp	.+68     	; 0x42ce <SCSI_Command_ReadWrite_10+0x8e>
	}

	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
	  //SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
	  SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
    428a:	98 01       	movw	r18, r16
    428c:	b7 01       	movw	r22, r14
    428e:	a6 01       	movw	r20, r12
    4290:	ce 01       	movw	r24, r28

		return false;
	}

	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
    4292:	bb 20       	and	r11, r11
    4294:	11 f0       	breq	.+4      	; 0x429a <SCSI_Command_ReadWrite_10+0x5a>
	  //SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
	  SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
    4296:	79 d2       	rcall	.+1266   	; 0x478a <SDCardManager_ReadBlocks>
    4298:	01 c0       	rjmp	.+2      	; 0x429c <SCSI_Command_ReadWrite_10+0x5c>
	else
	  SDCardManager_WriteBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
    429a:	d1 d1       	rcall	.+930    	; 0x463e <SDCardManager_WriteBlocks>

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= ((uint32_t)TotalBlocks * VIRTUAL_MEMORY_BLOCK_SIZE);
    429c:	c8 01       	movw	r24, r16
    429e:	a0 e0       	ldi	r26, 0x00	; 0
    42a0:	b0 e0       	ldi	r27, 0x00	; 0
    42a2:	29 e0       	ldi	r18, 0x09	; 9
    42a4:	88 0f       	add	r24, r24
    42a6:	99 1f       	adc	r25, r25
    42a8:	aa 1f       	adc	r26, r26
    42aa:	bb 1f       	adc	r27, r27
    42ac:	2a 95       	dec	r18
    42ae:	d1 f7       	brne	.-12     	; 0x42a4 <SCSI_Command_ReadWrite_10+0x64>
    42b0:	4c 89       	ldd	r20, Y+20	; 0x14
    42b2:	5d 89       	ldd	r21, Y+21	; 0x15
    42b4:	6e 89       	ldd	r22, Y+22	; 0x16
    42b6:	7f 89       	ldd	r23, Y+23	; 0x17
    42b8:	8a 01       	movw	r16, r20
    42ba:	9b 01       	movw	r18, r22
    42bc:	08 1b       	sub	r16, r24
    42be:	19 0b       	sbc	r17, r25
    42c0:	2a 0b       	sbc	r18, r26
    42c2:	3b 0b       	sbc	r19, r27
    42c4:	0c 8b       	std	Y+20, r16	; 0x14
    42c6:	1d 8b       	std	Y+21, r17	; 0x15
    42c8:	2e 8b       	std	Y+22, r18	; 0x16
    42ca:	3f 8b       	std	Y+23, r19	; 0x17

	return true;
    42cc:	81 e0       	ldi	r24, 0x01	; 1
}
    42ce:	df 91       	pop	r29
    42d0:	cf 91       	pop	r28
    42d2:	1f 91       	pop	r17
    42d4:	0f 91       	pop	r16
    42d6:	ff 90       	pop	r15
    42d8:	ef 90       	pop	r14
    42da:	df 90       	pop	r13
    42dc:	cf 90       	pop	r12
    42de:	bf 90       	pop	r11
    42e0:	08 95       	ret

000042e2 <SCSI_DecodeSCSICommand>:
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise
 */
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    42e2:	cf 92       	push	r12
    42e4:	df 92       	push	r13
    42e6:	ef 92       	push	r14
    42e8:	ff 92       	push	r15
    42ea:	0f 93       	push	r16
    42ec:	1f 93       	push	r17
    42ee:	cf 93       	push	r28
    42f0:	df 93       	push	r29
    42f2:	cd b7       	in	r28, 0x3d	; 61
    42f4:	de b7       	in	r29, 0x3e	; 62
    42f6:	28 97       	sbiw	r28, 0x08	; 8
    42f8:	0f b6       	in	r0, 0x3f	; 63
    42fa:	f8 94       	cli
    42fc:	de bf       	out	0x3e, r29	; 62
    42fe:	0f be       	out	0x3f, r0	; 63
    4300:	cd bf       	out	0x3d, r28	; 61
    4302:	8c 01       	movw	r16, r24
	bool CommandSuccess = false;



	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
    4304:	fc 01       	movw	r30, r24
    4306:	83 8d       	ldd	r24, Z+27	; 0x1b
    4308:	8d 31       	cpi	r24, 0x1D	; 29
    430a:	09 f4       	brne	.+2      	; 0x430e <SCSI_DecodeSCSICommand+0x2c>
    430c:	c2 c0       	rjmp	.+388    	; 0x4492 <SCSI_DecodeSCSICommand+0x1b0>
    430e:	88 f4       	brcc	.+34     	; 0x4332 <SCSI_DecodeSCSICommand+0x50>
    4310:	82 31       	cpi	r24, 0x12	; 18
    4312:	09 f1       	breq	.+66     	; 0x4356 <SCSI_DecodeSCSICommand+0x74>
    4314:	38 f4       	brcc	.+14     	; 0x4324 <SCSI_DecodeSCSICommand+0x42>
    4316:	88 23       	and	r24, r24
    4318:	09 f4       	brne	.+2      	; 0x431c <SCSI_DecodeSCSICommand+0x3a>
    431a:	ff c0       	rjmp	.+510    	; 0x451a <SCSI_DecodeSCSICommand+0x238>
    431c:	83 30       	cpi	r24, 0x03	; 3
    431e:	09 f4       	brne	.+2      	; 0x4322 <SCSI_DecodeSCSICommand+0x40>
    4320:	50 c0       	rjmp	.+160    	; 0x43c2 <SCSI_DecodeSCSICommand+0xe0>
    4322:	0a c1       	rjmp	.+532    	; 0x4538 <SCSI_DecodeSCSICommand+0x256>
    4324:	8a 31       	cpi	r24, 0x1A	; 26
    4326:	09 f4       	brne	.+2      	; 0x432a <SCSI_DecodeSCSICommand+0x48>
    4328:	de c0       	rjmp	.+444    	; 0x44e6 <SCSI_DecodeSCSICommand+0x204>
    432a:	8b 31       	cpi	r24, 0x1B	; 27
    432c:	09 f4       	brne	.+2      	; 0x4330 <SCSI_DecodeSCSICommand+0x4e>
    432e:	fe c0       	rjmp	.+508    	; 0x452c <SCSI_DecodeSCSICommand+0x24a>
    4330:	03 c1       	rjmp	.+518    	; 0x4538 <SCSI_DecodeSCSICommand+0x256>
    4332:	88 32       	cpi	r24, 0x28	; 40
    4334:	09 f4       	brne	.+2      	; 0x4338 <SCSI_DecodeSCSICommand+0x56>
    4336:	c8 c0       	rjmp	.+400    	; 0x44c8 <SCSI_DecodeSCSICommand+0x1e6>
    4338:	38 f4       	brcc	.+14     	; 0x4348 <SCSI_DecodeSCSICommand+0x66>
    433a:	8e 31       	cpi	r24, 0x1E	; 30
    433c:	09 f4       	brne	.+2      	; 0x4340 <SCSI_DecodeSCSICommand+0x5e>
    433e:	f6 c0       	rjmp	.+492    	; 0x452c <SCSI_DecodeSCSICommand+0x24a>
    4340:	85 32       	cpi	r24, 0x25	; 37
    4342:	09 f4       	brne	.+2      	; 0x4346 <SCSI_DecodeSCSICommand+0x64>
    4344:	66 c0       	rjmp	.+204    	; 0x4412 <SCSI_DecodeSCSICommand+0x130>
    4346:	f8 c0       	rjmp	.+496    	; 0x4538 <SCSI_DecodeSCSICommand+0x256>
    4348:	8a 32       	cpi	r24, 0x2A	; 42
    434a:	09 f4       	brne	.+2      	; 0x434e <SCSI_DecodeSCSICommand+0x6c>
    434c:	b2 c0       	rjmp	.+356    	; 0x44b2 <SCSI_DecodeSCSICommand+0x1d0>
    434e:	8f 32       	cpi	r24, 0x2F	; 47
    4350:	09 f4       	brne	.+2      	; 0x4354 <SCSI_DecodeSCSICommand+0x72>
    4352:	ec c0       	rjmp	.+472    	; 0x452c <SCSI_DecodeSCSICommand+0x24a>
    4354:	f1 c0       	rjmp	.+482    	; 0x4538 <SCSI_DecodeSCSICommand+0x256>
    4356:	f8 01       	movw	r30, r16
    4358:	e7 8c       	ldd	r14, Z+31	; 0x1f
    435a:	f6 8c       	ldd	r15, Z+30	; 0x1e
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));

	/* Only the standard INQUIRY data is supported, check if any optional INQUIRY bits set */
	if ((MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & ((1 << 0) | (1 << 1))) ||
    435c:	84 8d       	ldd	r24, Z+28	; 0x1c
    435e:	83 70       	andi	r24, 0x03	; 3
    4360:	19 f4       	brne	.+6      	; 0x4368 <SCSI_DecodeSCSICommand+0x86>
    4362:	85 8d       	ldd	r24, Z+29	; 0x1d
    4364:	88 23       	and	r24, r24
    4366:	41 f0       	breq	.+16     	; 0x4378 <SCSI_DecodeSCSICommand+0x96>
	     MSInterfaceInfo->State.CommandBlock.SCSICommandData[2])
	{
		/* Optional but unsupported bits set - update the SENSE key and fail the request */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    4368:	80 91 34 01 	lds	r24, 0x0134
    436c:	80 7f       	andi	r24, 0xF0	; 240
    436e:	85 60       	ori	r24, 0x05	; 5
    4370:	80 93 34 01 	sts	0x0134, r24
    4374:	84 e2       	ldi	r24, 0x24	; 36
    4376:	e7 c0       	rjmp	.+462    	; 0x4546 <SCSI_DecodeSCSICommand+0x264>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));
    4378:	67 01       	movw	r12, r14
    437a:	f5 e2       	ldi	r31, 0x25	; 37
    437c:	ef 16       	cp	r14, r31
    437e:	f1 04       	cpc	r15, r1
    4380:	18 f0       	brcs	.+6      	; 0x4388 <SCSI_DecodeSCSICommand+0xa6>
    4382:	94 e2       	ldi	r25, 0x24	; 36
    4384:	c9 2e       	mov	r12, r25
    4386:	d1 2c       	mov	r13, r1
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
	}

	Endpoint_Write_Stream_LE(&InquiryData, BytesTransferred, NULL);
    4388:	40 e0       	ldi	r20, 0x00	; 0
    438a:	50 e0       	ldi	r21, 0x00	; 0
    438c:	b6 01       	movw	r22, r12
    438e:	83 e2       	ldi	r24, 0x23	; 35
    4390:	93 e0       	ldi	r25, 0x03	; 3
    4392:	0e 94 f8 2f 	call	0x5ff0	; 0x5ff0 <Endpoint_Write_Stream_LE>

	/* Pad out remaining bytes with 0x00 */
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
    4396:	60 e0       	ldi	r22, 0x00	; 0
    4398:	70 e0       	ldi	r23, 0x00	; 0
    439a:	c7 01       	movw	r24, r14
    439c:	8c 19       	sub	r24, r12
    439e:	9d 09       	sbc	r25, r13
    43a0:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <Endpoint_Null_Stream>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    43a4:	80 91 e8 00 	lds	r24, 0x00E8
    43a8:	8e 77       	andi	r24, 0x7E	; 126
    43aa:	80 93 e8 00 	sts	0x00E8, r24

	/* Finalize the stream transfer to send the last packet */
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
    43ae:	f8 01       	movw	r30, r16
    43b0:	84 89       	ldd	r24, Z+20	; 0x14
    43b2:	95 89       	ldd	r25, Z+21	; 0x15
    43b4:	a6 89       	ldd	r26, Z+22	; 0x16
    43b6:	b7 89       	ldd	r27, Z+23	; 0x17
    43b8:	8c 19       	sub	r24, r12
    43ba:	9d 09       	sbc	r25, r13
    43bc:	a1 09       	sbc	r26, r1
    43be:	b1 09       	sbc	r27, r1
    43c0:	a7 c0       	rjmp	.+334    	; 0x4510 <SCSI_DecodeSCSICommand+0x22e>
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint8_t  AllocationLength = MSInterfaceInfo->State.CommandBlock.SCSICommandData[4];
    43c2:	f8 01       	movw	r30, r16
    43c4:	f7 8c       	ldd	r15, Z+31	; 0x1f
	uint8_t  BytesTransferred = MIN(AllocationLength, sizeof(SenseData));
    43c6:	ef 2c       	mov	r14, r15
    43c8:	f2 e1       	ldi	r31, 0x12	; 18
    43ca:	ff 15       	cp	r31, r15
    43cc:	10 f4       	brcc	.+4      	; 0x43d2 <SCSI_DecodeSCSICommand+0xf0>
    43ce:	82 e1       	ldi	r24, 0x12	; 18
    43d0:	e8 2e       	mov	r14, r24

	Endpoint_Write_Stream_LE(&SenseData, BytesTransferred, NULL);
    43d2:	ce 2c       	mov	r12, r14
    43d4:	d1 2c       	mov	r13, r1
    43d6:	40 e0       	ldi	r20, 0x00	; 0
    43d8:	50 e0       	ldi	r21, 0x00	; 0
    43da:	b6 01       	movw	r22, r12
    43dc:	82 e3       	ldi	r24, 0x32	; 50
    43de:	91 e0       	ldi	r25, 0x01	; 1
    43e0:	0e 94 f8 2f 	call	0x5ff0	; 0x5ff0 <Endpoint_Write_Stream_LE>
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
    43e4:	8f 2d       	mov	r24, r15
    43e6:	90 e0       	ldi	r25, 0x00	; 0
    43e8:	60 e0       	ldi	r22, 0x00	; 0
    43ea:	70 e0       	ldi	r23, 0x00	; 0
    43ec:	8c 19       	sub	r24, r12
    43ee:	9d 09       	sbc	r25, r13
    43f0:	0e 94 ba 2f 	call	0x5f74	; 0x5f74 <Endpoint_Null_Stream>
    43f4:	80 91 e8 00 	lds	r24, 0x00E8
    43f8:	8e 77       	andi	r24, 0x7E	; 126
    43fa:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
    43fe:	f8 01       	movw	r30, r16
    4400:	84 89       	ldd	r24, Z+20	; 0x14
    4402:	95 89       	ldd	r25, Z+21	; 0x15
    4404:	a6 89       	ldd	r26, Z+22	; 0x16
    4406:	b7 89       	ldd	r27, Z+23	; 0x17
    4408:	8e 19       	sub	r24, r14
    440a:	91 09       	sbc	r25, r1
    440c:	a1 09       	sbc	r26, r1
    440e:	b1 09       	sbc	r27, r1
    4410:	7f c0       	rjmp	.+254    	; 0x4510 <SCSI_DecodeSCSICommand+0x22e>
			break;
		case SCSI_CMD_REQUEST_SENSE:
			CommandSuccess = SCSI_Command_Request_Sense(MSInterfaceInfo);
			break;
		case SCSI_CMD_READ_CAPACITY_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    4412:	14 d2       	rcall	.+1064   	; 0x483c <SDCardManager_CheckSDCardOperation>
    4414:	81 11       	cpse	r24, r1
    4416:	08 c0       	rjmp	.+16     	; 0x4428 <SCSI_DecodeSCSICommand+0x146>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
    4418:	80 91 34 01 	lds	r24, 0x0134
    441c:	80 7f       	andi	r24, 0xF0	; 240
    441e:	82 60       	ori	r24, 0x02	; 2
    4420:	80 93 34 01 	sts	0x0134, r24
    4424:	8a e3       	ldi	r24, 0x3A	; 58
    4426:	8f c0       	rjmp	.+286    	; 0x4546 <SCSI_DecodeSCSICommand+0x264>
			break;
		case SCSI_CMD_REQUEST_SENSE:
			CommandSuccess = SCSI_Command_Request_Sense(MSInterfaceInfo);
			break;
		case SCSI_CMD_READ_CAPACITY_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    4428:	80 91 89 07 	lds	r24, 0x0789
    442c:	81 30       	cpi	r24, 0x01	; 1
    442e:	a1 f7       	brne	.-24     	; 0x4418 <SCSI_DecodeSCSICommand+0x136>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Read_Capacity_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint32_t LastBlockAddressInLUN;
	uint32_t MediaBlockSize        = VIRTUAL_MEMORY_BLOCK_SIZE;
    4430:	80 e0       	ldi	r24, 0x00	; 0
    4432:	92 e0       	ldi	r25, 0x02	; 2
    4434:	a0 e0       	ldi	r26, 0x00	; 0
    4436:	b0 e0       	ldi	r27, 0x00	; 0
    4438:	89 83       	std	Y+1, r24	; 0x01
    443a:	9a 83       	std	Y+2, r25	; 0x02
    443c:	ab 83       	std	Y+3, r26	; 0x03
    443e:	bc 83       	std	Y+4, r27	; 0x04

	LastBlockAddressInLUN = get_num_of_sectors()-1;
    4440:	0e 94 22 0c 	call	0x1844	; 0x1844 <get_num_of_sectors>
    4444:	dc 01       	movw	r26, r24
    4446:	cb 01       	movw	r24, r22
    4448:	01 97       	sbiw	r24, 0x01	; 1
    444a:	a1 09       	sbc	r26, r1
    444c:	b1 09       	sbc	r27, r1
    444e:	8d 83       	std	Y+5, r24	; 0x05
    4450:	9e 83       	std	Y+6, r25	; 0x06
    4452:	af 83       	std	Y+7, r26	; 0x07
    4454:	b8 87       	std	Y+8, r27	; 0x08

	Endpoint_Write_Stream_BE(&LastBlockAddressInLUN, sizeof(LastBlockAddressInLUN), NULL);
    4456:	40 e0       	ldi	r20, 0x00	; 0
    4458:	50 e0       	ldi	r21, 0x00	; 0
    445a:	64 e0       	ldi	r22, 0x04	; 4
    445c:	70 e0       	ldi	r23, 0x00	; 0
    445e:	ce 01       	movw	r24, r28
    4460:	05 96       	adiw	r24, 0x05	; 5
    4462:	0e 94 42 30 	call	0x6084	; 0x6084 <Endpoint_Write_Stream_BE>
	Endpoint_Write_Stream_BE(&MediaBlockSize, sizeof(MediaBlockSize), NULL);
    4466:	40 e0       	ldi	r20, 0x00	; 0
    4468:	50 e0       	ldi	r21, 0x00	; 0
    446a:	64 e0       	ldi	r22, 0x04	; 4
    446c:	70 e0       	ldi	r23, 0x00	; 0
    446e:	ce 01       	movw	r24, r28
    4470:	01 96       	adiw	r24, 0x01	; 1
    4472:	0e 94 42 30 	call	0x6084	; 0x6084 <Endpoint_Write_Stream_BE>
    4476:	80 91 e8 00 	lds	r24, 0x00E8
    447a:	8e 77       	andi	r24, 0x7E	; 126
    447c:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 8;
    4480:	f8 01       	movw	r30, r16
    4482:	84 89       	ldd	r24, Z+20	; 0x14
    4484:	95 89       	ldd	r25, Z+21	; 0x15
    4486:	a6 89       	ldd	r26, Z+22	; 0x16
    4488:	b7 89       	ldd	r27, Z+23	; 0x17
    448a:	08 97       	sbiw	r24, 0x08	; 8
    448c:	a1 09       	sbc	r26, r1
    448e:	b1 09       	sbc	r27, r1
    4490:	3f c0       	rjmp	.+126    	; 0x4510 <SCSI_DecodeSCSICommand+0x22e>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Send_Diagnostic(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	/* Check to see if the SELF TEST bit is not set */
	if (!(MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & (1 << 2)))
    4492:	f8 01       	movw	r30, r16
    4494:	84 8d       	ldd	r24, Z+28	; 0x1c
    4496:	82 ff       	sbrs	r24, 2
    4498:	67 cf       	rjmp	.-306    	; 0x4368 <SCSI_DecodeSCSICommand+0x86>

		return false;
	}

	/* Check to see if all attached Dataflash ICs are functional */
	if (!(SDCardManager_CheckSDCardOperation()))
    449a:	d0 d1       	rcall	.+928    	; 0x483c <SDCardManager_CheckSDCardOperation>
    449c:	81 11       	cpse	r24, r1
    449e:	46 c0       	rjmp	.+140    	; 0x452c <SCSI_DecodeSCSICommand+0x24a>
	{
		/* Update SENSE key with a hardware error condition and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_HARDWARE_ERROR,
    44a0:	80 91 34 01 	lds	r24, 0x0134
    44a4:	80 7f       	andi	r24, 0xF0	; 240
    44a6:	84 60       	ori	r24, 0x04	; 4
    44a8:	80 93 34 01 	sts	0x0134, r24
    44ac:	10 92 3e 01 	sts	0x013E, r1
    44b0:	4c c0       	rjmp	.+152    	; 0x454a <SCSI_DecodeSCSICommand+0x268>
			break;
		case SCSI_CMD_SEND_DIAGNOSTIC:
			CommandSuccess = SCSI_Command_Send_Diagnostic(MSInterfaceInfo);
			break;
		case SCSI_CMD_WRITE_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    44b2:	c4 d1       	rcall	.+904    	; 0x483c <SDCardManager_CheckSDCardOperation>
    44b4:	88 23       	and	r24, r24
    44b6:	09 f4       	brne	.+2      	; 0x44ba <SCSI_DecodeSCSICommand+0x1d8>
    44b8:	af cf       	rjmp	.-162    	; 0x4418 <SCSI_DecodeSCSICommand+0x136>
    44ba:	80 91 89 07 	lds	r24, 0x0789
    44be:	81 30       	cpi	r24, 0x01	; 1
    44c0:	09 f0       	breq	.+2      	; 0x44c4 <SCSI_DecodeSCSICommand+0x1e2>
    44c2:	aa cf       	rjmp	.-172    	; 0x4418 <SCSI_DecodeSCSICommand+0x136>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
				return false; //return with an error flag -- send a failure response to host.
			}
			
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_WRITE);
    44c4:	60 e0       	ldi	r22, 0x00	; 0
    44c6:	0a c0       	rjmp	.+20     	; 0x44dc <SCSI_DecodeSCSICommand+0x1fa>
			break;
		case SCSI_CMD_READ_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    44c8:	b9 d1       	rcall	.+882    	; 0x483c <SDCardManager_CheckSDCardOperation>
    44ca:	88 23       	and	r24, r24
    44cc:	09 f4       	brne	.+2      	; 0x44d0 <SCSI_DecodeSCSICommand+0x1ee>
    44ce:	a4 cf       	rjmp	.-184    	; 0x4418 <SCSI_DecodeSCSICommand+0x136>
    44d0:	80 91 89 07 	lds	r24, 0x0789
    44d4:	81 30       	cpi	r24, 0x01	; 1
    44d6:	09 f0       	breq	.+2      	; 0x44da <SCSI_DecodeSCSICommand+0x1f8>
    44d8:	9f cf       	rjmp	.-194    	; 0x4418 <SCSI_DecodeSCSICommand+0x136>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
				return false; //return with an error flag -- send a failure response to host.
			}
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
    44da:	61 e0       	ldi	r22, 0x01	; 1
    44dc:	c8 01       	movw	r24, r16
    44de:	b0 de       	rcall	.-672    	; 0x4240 <SCSI_Command_ReadWrite_10>
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
    44e0:	81 11       	cpse	r24, r1
    44e2:	36 c0       	rjmp	.+108    	; 0x4550 <SCSI_DecodeSCSICommand+0x26e>
    44e4:	40 c0       	rjmp	.+128    	; 0x4566 <SCSI_DecodeSCSICommand+0x284>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    44e6:	10 92 f1 00 	sts	0x00F1, r1
    44ea:	10 92 f1 00 	sts	0x00F1, r1
    44ee:	10 92 f1 00 	sts	0x00F1, r1
    44f2:	10 92 f1 00 	sts	0x00F1, r1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    44f6:	80 91 e8 00 	lds	r24, 0x00E8
    44fa:	8e 77       	andi	r24, 0x7E	; 126
    44fc:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_Write_8(DISK_READ_ONLY ? 0x80 : 0x00);
	Endpoint_Write_8(0x00);
	Endpoint_ClearIN();

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 4;
    4500:	f8 01       	movw	r30, r16
    4502:	84 89       	ldd	r24, Z+20	; 0x14
    4504:	95 89       	ldd	r25, Z+21	; 0x15
    4506:	a6 89       	ldd	r26, Z+22	; 0x16
    4508:	b7 89       	ldd	r27, Z+23	; 0x17
    450a:	04 97       	sbiw	r24, 0x04	; 4
    450c:	a1 09       	sbc	r26, r1
    450e:	b1 09       	sbc	r27, r1
    4510:	84 8b       	std	Z+20, r24	; 0x14
    4512:	95 8b       	std	Z+21, r25	; 0x15
    4514:	a6 8b       	std	Z+22, r26	; 0x16
    4516:	b7 8b       	std	Z+23, r27	; 0x17
			}
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
			break;
		case SCSI_CMD_MODE_SENSE_6:
			CommandSuccess = SCSI_Command_ModeSense_6(MSInterfaceInfo);
			break;
    4518:	1b c0       	rjmp	.+54     	; 0x4550 <SCSI_DecodeSCSICommand+0x26e>
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
			break;
		case SCSI_CMD_TEST_UNIT_READY:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    451a:	90 d1       	rcall	.+800    	; 0x483c <SDCardManager_CheckSDCardOperation>
    451c:	88 23       	and	r24, r24
    451e:	09 f4       	brne	.+2      	; 0x4522 <SCSI_DecodeSCSICommand+0x240>
    4520:	7b cf       	rjmp	.-266    	; 0x4418 <SCSI_DecodeSCSICommand+0x136>
    4522:	80 91 89 07 	lds	r24, 0x0789
    4526:	81 30       	cpi	r24, 0x01	; 1
    4528:	09 f0       	breq	.+2      	; 0x452c <SCSI_DecodeSCSICommand+0x24a>
    452a:	76 cf       	rjmp	.-276    	; 0x4418 <SCSI_DecodeSCSICommand+0x136>
		case SCSI_CMD_START_STOP_UNIT:
		case SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
		case SCSI_CMD_VERIFY_10:
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
    452c:	f8 01       	movw	r30, r16
    452e:	14 8a       	std	Z+20, r1	; 0x14
    4530:	15 8a       	std	Z+21, r1	; 0x15
    4532:	16 8a       	std	Z+22, r1	; 0x16
    4534:	17 8a       	std	Z+23, r1	; 0x17
			break;
    4536:	0c c0       	rjmp	.+24     	; 0x4550 <SCSI_DecodeSCSICommand+0x26e>
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
			break;
		default:
			/* Update the SENSE key to reflect the invalid command */
			SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    4538:	80 91 34 01 	lds	r24, 0x0134
    453c:	80 7f       	andi	r24, 0xF0	; 240
    453e:	85 60       	ori	r24, 0x05	; 5
    4540:	80 93 34 01 	sts	0x0134, r24
    4544:	80 e2       	ldi	r24, 0x20	; 32
    4546:	80 93 3e 01 	sts	0x013E, r24
    454a:	10 92 3f 01 	sts	0x013F, r1
		                   SCSI_ASENSE_INVALID_COMMAND,
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
    454e:	0b c0       	rjmp	.+22     	; 0x4566 <SCSI_DecodeSCSICommand+0x284>
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
	{
		SCSI_SET_SENSE(SCSI_SENSE_KEY_GOOD,
    4550:	80 91 34 01 	lds	r24, 0x0134
    4554:	80 7f       	andi	r24, 0xF0	; 240
    4556:	80 93 34 01 	sts	0x0134, r24
    455a:	10 92 3e 01 	sts	0x013E, r1
    455e:	10 92 3f 01 	sts	0x013F, r1
		               SCSI_ASENSE_NO_ADDITIONAL_INFORMATION,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return true;
    4562:	81 e0       	ldi	r24, 0x01	; 1
    4564:	01 c0       	rjmp	.+2      	; 0x4568 <SCSI_DecodeSCSICommand+0x286>
	}

	return false;
    4566:	80 e0       	ldi	r24, 0x00	; 0
}
    4568:	28 96       	adiw	r28, 0x08	; 8
    456a:	0f b6       	in	r0, 0x3f	; 63
    456c:	f8 94       	cli
    456e:	de bf       	out	0x3e, r29	; 62
    4570:	0f be       	out	0x3f, r0	; 63
    4572:	cd bf       	out	0x3d, r28	; 61
    4574:	df 91       	pop	r29
    4576:	cf 91       	pop	r28
    4578:	1f 91       	pop	r17
    457a:	0f 91       	pop	r16
    457c:	ff 90       	pop	r15
    457e:	ef 90       	pop	r14
    4580:	df 90       	pop	r13
    4582:	cf 90       	pop	r12
    4584:	08 95       	ret

00004586 <SDCardManager_Init>:
static bool SDCard_Present= false;

void SDCardManager_Init(void)
{

	if(disk_initialize(0)==FR_OK){ //if the disk initializes correctly
    4586:	80 e0       	ldi	r24, 0x00	; 0
    4588:	0e 94 5d 0f 	call	0x1eba	; 0x1eba <disk_initialize>
    458c:	81 11       	cpse	r24, r1
    458e:	04 c0       	rjmp	.+8      	; 0x4598 <SDCardManager_Init+0x12>
		SDCard_Present = true;
    4590:	81 e0       	ldi	r24, 0x01	; 1
    4592:	80 93 a6 05 	sts	0x05A6, r24
    4596:	08 95       	ret
	}
	else{
		SDCard_Present = false; //tell other functions that the SD Card is missing/malfunctioned
    4598:	10 92 a6 05 	sts	0x05A6, r1
    459c:	08 95       	ret

0000459e <SDCardManager_WriteBlockHandler>:
	}
}


uintptr_t SDCardManager_WriteBlockHandler(uint8_t* buffer, uint16_t offset)
{
    459e:	0f 93       	push	r16
    45a0:	1f 93       	push	r17
    45a2:	cf 93       	push	r28
    45a4:	df 93       	push	r29
    45a6:	8c 01       	movw	r16, r24
    45a8:	eb 01       	movw	r28, r22
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    45aa:	80 91 e8 00 	lds	r24, 0x00E8

	/* Check if the endpoint is currently empty */
	if (!(Endpoint_IsReadWriteAllowed()))
    45ae:	85 ff       	sbrs	r24, 5
    45b0:	36 c0       	rjmp	.+108    	; 0x461e <SDCardManager_WriteBlockHandler+0x80>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    45b2:	80 91 f1 00 	lds	r24, 0x00F1
		if (Endpoint_WaitUntilReady())
		  return 0;
	}
	
	/* Write one 16-byte chunk of data to the dataflash */
	buffer[0+offset] = Endpoint_Read_8();
    45b6:	f8 01       	movw	r30, r16
    45b8:	ec 0f       	add	r30, r28
    45ba:	fd 1f       	adc	r31, r29
    45bc:	80 83       	st	Z, r24
    45be:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[1+offset] = Endpoint_Read_8();
    45c2:	81 83       	std	Z+1, r24	; 0x01
    45c4:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[2+offset] = Endpoint_Read_8();
    45c8:	82 83       	std	Z+2, r24	; 0x02
    45ca:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[3+offset] = Endpoint_Read_8();
    45ce:	83 83       	std	Z+3, r24	; 0x03
    45d0:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[4+offset] = Endpoint_Read_8();
    45d4:	84 83       	std	Z+4, r24	; 0x04
    45d6:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[5+offset] = Endpoint_Read_8();
    45da:	85 83       	std	Z+5, r24	; 0x05
    45dc:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[6+offset] = Endpoint_Read_8();
    45e0:	86 83       	std	Z+6, r24	; 0x06
    45e2:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[7+offset] = Endpoint_Read_8();
    45e6:	87 83       	std	Z+7, r24	; 0x07
    45e8:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[8+offset] = Endpoint_Read_8();
    45ec:	80 87       	std	Z+8, r24	; 0x08
    45ee:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[9+offset] = Endpoint_Read_8();
    45f2:	81 87       	std	Z+9, r24	; 0x09
    45f4:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[10+offset] = Endpoint_Read_8();
    45f8:	82 87       	std	Z+10, r24	; 0x0a
    45fa:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[11+offset] = Endpoint_Read_8();
    45fe:	83 87       	std	Z+11, r24	; 0x0b
    4600:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[12+offset] = Endpoint_Read_8();
    4604:	84 87       	std	Z+12, r24	; 0x0c
    4606:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[13+offset] = Endpoint_Read_8();
    460a:	85 87       	std	Z+13, r24	; 0x0d
    460c:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[14+offset] = Endpoint_Read_8();
    4610:	86 87       	std	Z+14, r24	; 0x0e
    4612:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[15+offset] = Endpoint_Read_8();
    4616:	87 87       	std	Z+15, r24	; 0x0f
	
	return 16;
    4618:	80 e1       	ldi	r24, 0x10	; 16
    461a:	90 e0       	ldi	r25, 0x00	; 0
    461c:	0b c0       	rjmp	.+22     	; 0x4634 <SDCardManager_WriteBlockHandler+0x96>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    461e:	90 91 e8 00 	lds	r25, 0x00E8
    4622:	9b 77       	andi	r25, 0x7B	; 123
    4624:	90 93 e8 00 	sts	0x00E8, r25
	{
		/* Clear the current endpoint bank */
		Endpoint_ClearOUT();
		
		/* Wait until the host has sent another packet */
		if (Endpoint_WaitUntilReady())
    4628:	0e 94 7c 32 	call	0x64f8	; 0x64f8 <Endpoint_WaitUntilReady>
    462c:	88 23       	and	r24, r24
    462e:	09 f2       	breq	.-126    	; 0x45b2 <SDCardManager_WriteBlockHandler+0x14>
		  return 0;
    4630:	80 e0       	ldi	r24, 0x00	; 0
    4632:	90 e0       	ldi	r25, 0x00	; 0
	buffer[13+offset] = Endpoint_Read_8();
	buffer[14+offset] = Endpoint_Read_8();
	buffer[15+offset] = Endpoint_Read_8();
	
	return 16;
}
    4634:	df 91       	pop	r29
    4636:	cf 91       	pop	r28
    4638:	1f 91       	pop	r17
    463a:	0f 91       	pop	r16
    463c:	08 95       	ret

0000463e <SDCardManager_WriteBlocks>:
 *
 *  \param[in] BlockAddress  Data block starting address for the write sequence
 *  \param[in] TotalBlocks   Number of blocks of data to write
 */
void SDCardManager_WriteBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo, uint32_t BlockAddress, uint16_t TotalBlocks)
{
    463e:	8f 92       	push	r8
    4640:	9f 92       	push	r9
    4642:	af 92       	push	r10
    4644:	bf 92       	push	r11
    4646:	cf 92       	push	r12
    4648:	df 92       	push	r13
    464a:	ef 92       	push	r14
    464c:	ff 92       	push	r15
    464e:	0f 93       	push	r16
    4650:	1f 93       	push	r17
    4652:	cf 93       	push	r28
    4654:	df 93       	push	r29
    4656:	6c 01       	movw	r12, r24
    4658:	4a 01       	movw	r8, r20
    465a:	5b 01       	movw	r10, r22
    465c:	79 01       	movw	r14, r18
	uint16_t  BytesWritten;

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
    465e:	0e 94 7c 32 	call	0x64f8	; 0x64f8 <Endpoint_WaitUntilReady>
    4662:	81 11       	cpse	r24, r1
    4664:	33 c0       	rjmp	.+102    	; 0x46cc <SDCardManager_WriteBlocks+0x8e>
	  return;
	
	while (TotalBlocks)
    4666:	e1 14       	cp	r14, r1
    4668:	f1 04       	cpc	r15, r1
    466a:	31 f1       	breq	.+76     	; 0x46b8 <SDCardManager_WriteBlocks+0x7a>
	{
		set_low(RED_LED); //red LED indicates busy status
    466c:	2e 98       	cbi	0x05, 6	; 5
		
		//Reset BytesWritten every time you finish writing a block, Dummy!
		BytesWritten = 0;
    466e:	c0 e0       	ldi	r28, 0x00	; 0
    4670:	d0 e0       	ldi	r29, 0x00	; 0
		
		while((BytesWritten<512)){
			BytesWritten += SDCardManager_WriteBlockHandler((uint8_t*)SD_Buffer, BytesWritten);
    4672:	be 01       	movw	r22, r28
    4674:	8a e8       	ldi	r24, 0x8A	; 138
    4676:	97 e0       	ldi	r25, 0x07	; 7
    4678:	92 df       	rcall	.-220    	; 0x459e <SDCardManager_WriteBlockHandler>
    467a:	c8 0f       	add	r28, r24
    467c:	d9 1f       	adc	r29, r25
			if (USB_DeviceState != DEVICE_STATE_Configured){return;}//if the device is not configured, exit out of this
    467e:	80 91 ce 09 	lds	r24, 0x09CE
    4682:	84 30       	cpi	r24, 0x04	; 4
    4684:	19 f5       	brne	.+70     	; 0x46cc <SDCardManager_WriteBlocks+0x8e>
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
    4686:	f6 01       	movw	r30, r12
    4688:	80 ad       	ldd	r24, Z+56	; 0x38
    468a:	81 11       	cpse	r24, r1
    468c:	1f c0       	rjmp	.+62     	; 0x46cc <SDCardManager_WriteBlocks+0x8e>
		set_low(RED_LED); //red LED indicates busy status
		
		//Reset BytesWritten every time you finish writing a block, Dummy!
		BytesWritten = 0;
		
		while((BytesWritten<512)){
    468e:	c1 15       	cp	r28, r1
    4690:	f2 e0       	ldi	r31, 0x02	; 2
    4692:	df 07       	cpc	r29, r31
    4694:	70 f3       	brcs	.-36     	; 0x4672 <SDCardManager_WriteBlocks+0x34>
			BytesWritten += SDCardManager_WriteBlockHandler((uint8_t*)SD_Buffer, BytesWritten);
			if (USB_DeviceState != DEVICE_STATE_Configured){return;}//if the device is not configured, exit out of this
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
		}
		
		disk_write (0, (uint8_t*)SD_Buffer, BlockAddress, 1);//write to disk 0, from Buffer array, into BlockAddress, Write only 1 sector (block);
    4696:	01 e0       	ldi	r16, 0x01	; 1
    4698:	10 e0       	ldi	r17, 0x00	; 0
    469a:	a5 01       	movw	r20, r10
    469c:	94 01       	movw	r18, r8
    469e:	6a e8       	ldi	r22, 0x8A	; 138
    46a0:	77 e0       	ldi	r23, 0x07	; 7
    46a2:	0e 94 3f 10 	call	0x207e	; 0x207e <disk_write>
	
		/* Decrement the blocks remaining counter and reset the sub block counter */
		BlockAddress++;
    46a6:	8f ef       	ldi	r24, 0xFF	; 255
    46a8:	88 1a       	sub	r8, r24
    46aa:	98 0a       	sbc	r9, r24
    46ac:	a8 0a       	sbc	r10, r24
    46ae:	b8 0a       	sbc	r11, r24
		TotalBlocks--;			
    46b0:	e1 e0       	ldi	r30, 0x01	; 1
    46b2:	ee 1a       	sub	r14, r30
    46b4:	f1 08       	sbc	r15, r1
    46b6:	d7 cf       	rjmp	.-82     	; 0x4666 <SDCardManager_WriteBlocks+0x28>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    46b8:	80 91 e8 00 	lds	r24, 0x00E8
		
	}

	/* If the endpoint is empty, clear it ready for the next packet from the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    46bc:	85 fd       	sbrc	r24, 5
    46be:	05 c0       	rjmp	.+10     	; 0x46ca <SDCardManager_WriteBlocks+0x8c>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    46c0:	80 91 e8 00 	lds	r24, 0x00E8
    46c4:	8b 77       	andi	r24, 0x7B	; 123
    46c6:	80 93 e8 00 	sts	0x00E8, r24
	  Endpoint_ClearOUT();
	  
	  set_high(RED_LED);
    46ca:	2e 9a       	sbi	0x05, 6	; 5
}
    46cc:	df 91       	pop	r29
    46ce:	cf 91       	pop	r28
    46d0:	1f 91       	pop	r17
    46d2:	0f 91       	pop	r16
    46d4:	ff 90       	pop	r15
    46d6:	ef 90       	pop	r14
    46d8:	df 90       	pop	r13
    46da:	cf 90       	pop	r12
    46dc:	bf 90       	pop	r11
    46de:	af 90       	pop	r10
    46e0:	9f 90       	pop	r9
    46e2:	8f 90       	pop	r8
    46e4:	08 95       	ret

000046e6 <SDCardManager_ReadBlockHandler>:
 *  \param[in] BlockAddress  Data block starting address for the read sequence
 *  \param[in] TotalBlocks   Number of blocks of data to read
 *  \output -- number of bytes forwarded successfully.  Return 16 if they are forwarded successfully, 0 if host rejects them.
 */
uint8_t SDCardManager_ReadBlockHandler(uint8_t* buffer, uint16_t offset)
{
    46e6:	ef 92       	push	r14
    46e8:	ff 92       	push	r15
    46ea:	1f 93       	push	r17
    46ec:	cf 93       	push	r28
    46ee:	df 93       	push	r29
    46f0:	7c 01       	movw	r14, r24
    46f2:	eb 01       	movw	r28, r22
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    46f4:	90 91 e8 00 	lds	r25, 0x00E8

	/* Check if the endpoint is currently full */
	if (!(Endpoint_IsReadWriteAllowed()))
    46f8:	19 2f       	mov	r17, r25
    46fa:	10 72       	andi	r17, 0x20	; 32
    46fc:	95 ff       	sbrs	r25, 5
    46fe:	35 c0       	rjmp	.+106    	; 0x476a <SDCardManager_ReadBlockHandler+0x84>
		/* Wait until the endpoint is ready for more data */
		if (Endpoint_WaitUntilReady())
		return 0;
	}
	
	Endpoint_Write_8(buffer[0+offset]);
    4700:	f7 01       	movw	r30, r14
    4702:	ec 0f       	add	r30, r28
    4704:	fd 1f       	adc	r31, r29
    4706:	80 81       	ld	r24, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4708:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[1+offset]);
    470c:	81 81       	ldd	r24, Z+1	; 0x01
    470e:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[2+offset]);
    4712:	82 81       	ldd	r24, Z+2	; 0x02
    4714:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[3+offset]);
    4718:	83 81       	ldd	r24, Z+3	; 0x03
    471a:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[4+offset]);
    471e:	84 81       	ldd	r24, Z+4	; 0x04
    4720:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[5+offset]);
    4724:	85 81       	ldd	r24, Z+5	; 0x05
    4726:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[6+offset]);
    472a:	86 81       	ldd	r24, Z+6	; 0x06
    472c:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[7+offset]);
    4730:	87 81       	ldd	r24, Z+7	; 0x07
    4732:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[8+offset]);
    4736:	80 85       	ldd	r24, Z+8	; 0x08
    4738:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[9+offset]);
    473c:	81 85       	ldd	r24, Z+9	; 0x09
    473e:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[10+offset]);
    4742:	82 85       	ldd	r24, Z+10	; 0x0a
    4744:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[11+offset]);
    4748:	83 85       	ldd	r24, Z+11	; 0x0b
    474a:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[12+offset]);
    474e:	84 85       	ldd	r24, Z+12	; 0x0c
    4750:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[13+offset]);
    4754:	85 85       	ldd	r24, Z+13	; 0x0d
    4756:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[14+offset]);
    475a:	86 85       	ldd	r24, Z+14	; 0x0e
    475c:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[15+offset]);
    4760:	87 85       	ldd	r24, Z+15	; 0x0f
    4762:	80 93 f1 00 	sts	0x00F1, r24
	
	return 16;
    4766:	10 e1       	ldi	r17, 0x10	; 16
    4768:	09 c0       	rjmp	.+18     	; 0x477c <SDCardManager_ReadBlockHandler+0x96>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    476a:	90 91 e8 00 	lds	r25, 0x00E8
    476e:	9e 77       	andi	r25, 0x7E	; 126
    4770:	90 93 e8 00 	sts	0x00E8, r25
	{
		/* Clear the endpoint bank to send its contents to the host */
		Endpoint_ClearIN();
		
		/* Wait until the endpoint is ready for more data */
		if (Endpoint_WaitUntilReady())
    4774:	0e 94 7c 32 	call	0x64f8	; 0x64f8 <Endpoint_WaitUntilReady>
    4778:	88 23       	and	r24, r24
    477a:	11 f2       	breq	.-124    	; 0x4700 <SDCardManager_ReadBlockHandler+0x1a>
	Endpoint_Write_8(buffer[13+offset]);
	Endpoint_Write_8(buffer[14+offset]);
	Endpoint_Write_8(buffer[15+offset]);
	
	return 16;
}
    477c:	81 2f       	mov	r24, r17
    477e:	df 91       	pop	r29
    4780:	cf 91       	pop	r28
    4782:	1f 91       	pop	r17
    4784:	ff 90       	pop	r15
    4786:	ef 90       	pop	r14
    4788:	08 95       	ret

0000478a <SDCardManager_ReadBlocks>:
 *
 *  \param[in] BlockAddress  Data block starting address for the read sequence
 *  \param[in] TotalBlocks   Number of blocks of data to read
 */
void SDCardManager_ReadBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo, uint32_t BlockAddress, uint16_t TotalBlocks)
{
    478a:	8f 92       	push	r8
    478c:	9f 92       	push	r9
    478e:	af 92       	push	r10
    4790:	bf 92       	push	r11
    4792:	cf 92       	push	r12
    4794:	df 92       	push	r13
    4796:	ef 92       	push	r14
    4798:	ff 92       	push	r15
    479a:	0f 93       	push	r16
    479c:	1f 93       	push	r17
    479e:	cf 93       	push	r28
    47a0:	df 93       	push	r29
    47a2:	6c 01       	movw	r12, r24
    47a4:	4a 01       	movw	r8, r20
    47a6:	5b 01       	movw	r10, r22
    47a8:	79 01       	movw	r14, r18
	uint16_t BytesRead;
	
	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
    47aa:	0e 94 7c 32 	call	0x64f8	; 0x64f8 <Endpoint_WaitUntilReady>
    47ae:	81 11       	cpse	r24, r1
    47b0:	38 c0       	rjmp	.+112    	; 0x4822 <SDCardManager_ReadBlocks+0x98>
	  return;
	
	while (TotalBlocks)
    47b2:	e1 14       	cp	r14, r1
    47b4:	f1 04       	cpc	r15, r1
    47b6:	59 f1       	breq	.+86     	; 0x480e <SDCardManager_ReadBlocks+0x84>
	{		
		set_low(RED_LED); //red LED indicates busy status
    47b8:	2e 98       	cbi	0x05, 6	; 5
		//Reset tally of BytesRead every time a new block is accessed.  
		BytesRead = 0;
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)
    47ba:	01 e0       	ldi	r16, 0x01	; 1
    47bc:	10 e0       	ldi	r17, 0x00	; 0
    47be:	a5 01       	movw	r20, r10
    47c0:	94 01       	movw	r18, r8
    47c2:	6a e8       	ldi	r22, 0x8A	; 138
    47c4:	77 e0       	ldi	r23, 0x07	; 7
    47c6:	80 e0       	ldi	r24, 0x00	; 0
    47c8:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <disk_read>
	
	while (TotalBlocks)
	{		
		set_low(RED_LED); //red LED indicates busy status
		//Reset tally of BytesRead every time a new block is accessed.  
		BytesRead = 0;
    47cc:	c0 e0       	ldi	r28, 0x00	; 0
    47ce:	d0 e0       	ldi	r29, 0x00	; 0
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)

		while(BytesRead<512){  //send the results to the usb endpoint buffer, 16 bytes at a time.
			BytesRead += SDCardManager_ReadBlockHandler((uint8_t*)SD_Buffer, BytesRead); // BytesRead increases 16 every time handler is called, if all goes well.
    47d0:	be 01       	movw	r22, r28
    47d2:	8a e8       	ldi	r24, 0x8A	; 138
    47d4:	97 e0       	ldi	r25, 0x07	; 7
    47d6:	87 df       	rcall	.-242    	; 0x46e6 <SDCardManager_ReadBlockHandler>
    47d8:	c8 0f       	add	r28, r24
    47da:	d1 1d       	adc	r29, r1
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
    47dc:	f6 01       	movw	r30, r12
    47de:	80 ad       	ldd	r24, Z+56	; 0x38
    47e0:	81 11       	cpse	r24, r1
    47e2:	1f c0       	rjmp	.+62     	; 0x4822 <SDCardManager_ReadBlocks+0x98>
			if (USB_DeviceState != DEVICE_STATE_Configured){Typewriter_Mode = PANIC_MODE; return;}
    47e4:	80 91 ce 09 	lds	r24, 0x09CE
    47e8:	84 30       	cpi	r24, 0x04	; 4
    47ea:	21 f0       	breq	.+8      	; 0x47f4 <SDCardManager_ReadBlocks+0x6a>
    47ec:	8a e0       	ldi	r24, 0x0A	; 10
    47ee:	80 93 89 07 	sts	0x0789, r24
    47f2:	17 c0       	rjmp	.+46     	; 0x4822 <SDCardManager_ReadBlocks+0x98>
		BytesRead = 0;
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)

		while(BytesRead<512){  //send the results to the usb endpoint buffer, 16 bytes at a time.
    47f4:	c1 15       	cp	r28, r1
    47f6:	f2 e0       	ldi	r31, 0x02	; 2
    47f8:	df 07       	cpc	r29, r31
    47fa:	50 f3       	brcs	.-44     	; 0x47d0 <SDCardManager_ReadBlocks+0x46>
			BytesRead += SDCardManager_ReadBlockHandler((uint8_t*)SD_Buffer, BytesRead); // BytesRead increases 16 every time handler is called, if all goes well.
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
			if (USB_DeviceState != DEVICE_STATE_Configured){Typewriter_Mode = PANIC_MODE; return;}
		}
		/* Decrement the blocks remaining counter */
		BlockAddress++;
    47fc:	8f ef       	ldi	r24, 0xFF	; 255
    47fe:	88 1a       	sub	r8, r24
    4800:	98 0a       	sbc	r9, r24
    4802:	a8 0a       	sbc	r10, r24
    4804:	b8 0a       	sbc	r11, r24
		TotalBlocks--;
    4806:	e1 e0       	ldi	r30, 0x01	; 1
    4808:	ee 1a       	sub	r14, r30
    480a:	f1 08       	sbc	r15, r1
    480c:	d2 cf       	rjmp	.-92     	; 0x47b2 <SDCardManager_ReadBlocks+0x28>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    480e:	80 91 e8 00 	lds	r24, 0x00E8
	}
	
	/* If the endpoint is full, send its contents to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    4812:	85 fd       	sbrc	r24, 5
    4814:	05 c0       	rjmp	.+10     	; 0x4820 <SDCardManager_ReadBlocks+0x96>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4816:	80 91 e8 00 	lds	r24, 0x00E8
    481a:	8e 77       	andi	r24, 0x7E	; 126
    481c:	80 93 e8 00 	sts	0x00E8, r24
	  Endpoint_ClearIN();
	 
	 set_high(RED_LED);
    4820:	2e 9a       	sbi	0x05, 6	; 5
}
    4822:	df 91       	pop	r29
    4824:	cf 91       	pop	r28
    4826:	1f 91       	pop	r17
    4828:	0f 91       	pop	r16
    482a:	ff 90       	pop	r15
    482c:	ef 90       	pop	r14
    482e:	df 90       	pop	r13
    4830:	cf 90       	pop	r12
    4832:	bf 90       	pop	r11
    4834:	af 90       	pop	r10
    4836:	9f 90       	pop	r9
    4838:	8f 90       	pop	r8
    483a:	08 95       	ret

0000483c <SDCardManager_CheckSDCardOperation>:
 *  \return Boolean true if all media chips are working, false otherwise
 */
bool SDCardManager_CheckSDCardOperation(void)
{	
	return SDCard_Present; //return whether or not sd card is present and working.
}
    483c:	80 91 a6 05 	lds	r24, 0x05A6
    4840:	08 95       	ret

00004842 <__vector_25>:
ISR (UART0_RECEIVE_INTERRUPT)	
/*************************************************************************
Function: UART Receive Complete interrupt
Purpose:  called when the UART has received a character
**************************************************************************/
{
    4842:	1f 92       	push	r1
    4844:	0f 92       	push	r0
    4846:	0f b6       	in	r0, 0x3f	; 63
    4848:	0f 92       	push	r0
    484a:	11 24       	eor	r1, r1
    484c:	2f 93       	push	r18
    484e:	8f 93       	push	r24
    4850:	9f 93       	push	r25
    4852:	ef 93       	push	r30
    4854:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART0_STATUS;
    4856:	80 91 c8 00 	lds	r24, 0x00C8
    data = UART0_DATA;
    485a:	90 91 ce 00 	lds	r25, 0x00CE
    
    /* */
#if defined( AT90_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
    485e:	88 71       	andi	r24, 0x18	; 24
#elif defined( AT90USB_USART )
    lastRxError = (usr & (_BV(FE1)|_BV(DOR1)) );
#endif
        
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    4860:	e0 91 a9 05 	lds	r30, 0x05A9
    4864:	ef 5f       	subi	r30, 0xFF	; 255
    4866:	ef 73       	andi	r30, 0x3F	; 63
    
    if ( tmphead == UART_RxTail ) {
    4868:	20 91 a8 05 	lds	r18, 0x05A8
    486c:	e2 17       	cp	r30, r18
    486e:	39 f0       	breq	.+14     	; 0x487e <__vector_25+0x3c>
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART_RxHead = tmphead;
    4870:	e0 93 a9 05 	sts	0x05A9, r30
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    4874:	f0 e0       	ldi	r31, 0x00	; 0
    4876:	e4 55       	subi	r30, 0x54	; 84
    4878:	fa 4f       	sbci	r31, 0xFA	; 250
    487a:	90 83       	st	Z, r25
    487c:	01 c0       	rjmp	.+2      	; 0x4880 <__vector_25+0x3e>
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    
    if ( tmphead == UART_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    487e:	82 e0       	ldi	r24, 0x02	; 2
        /* store new index */
        UART_RxHead = tmphead;
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    }
    UART_LastRxError |= lastRxError;   
    4880:	90 91 a7 05 	lds	r25, 0x05A7
    4884:	89 2b       	or	r24, r25
    4886:	80 93 a7 05 	sts	0x05A7, r24
}
    488a:	ff 91       	pop	r31
    488c:	ef 91       	pop	r30
    488e:	9f 91       	pop	r25
    4890:	8f 91       	pop	r24
    4892:	2f 91       	pop	r18
    4894:	0f 90       	pop	r0
    4896:	0f be       	out	0x3f, r0	; 63
    4898:	0f 90       	pop	r0
    489a:	1f 90       	pop	r1
    489c:	18 95       	reti

0000489e <__vector_26>:
ISR (UART0_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/
{
    489e:	1f 92       	push	r1
    48a0:	0f 92       	push	r0
    48a2:	0f b6       	in	r0, 0x3f	; 63
    48a4:	0f 92       	push	r0
    48a6:	11 24       	eor	r1, r1
    48a8:	8f 93       	push	r24
    48aa:	9f 93       	push	r25
    48ac:	ef 93       	push	r30
    48ae:	ff 93       	push	r31
    unsigned char tmptail;
    
    if ( UART_TxHead != UART_TxTail) {
    48b0:	90 91 ab 05 	lds	r25, 0x05AB
    48b4:	80 91 aa 05 	lds	r24, 0x05AA
    48b8:	98 17       	cp	r25, r24
    48ba:	69 f0       	breq	.+26     	; 0x48d6 <__vector_26+0x38>
        /* calculate and store new buffer index */
        tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
    48bc:	e0 91 aa 05 	lds	r30, 0x05AA
    48c0:	ef 5f       	subi	r30, 0xFF	; 255
    48c2:	ef 70       	andi	r30, 0x0F	; 15
        UART_TxTail = tmptail;
    48c4:	e0 93 aa 05 	sts	0x05AA, r30
        /* get one byte from buffer and write it to UART */
        UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
    48c8:	f0 e0       	ldi	r31, 0x00	; 0
    48ca:	e4 51       	subi	r30, 0x14	; 20
    48cc:	fa 4f       	sbci	r31, 0xFA	; 250
    48ce:	80 81       	ld	r24, Z
    48d0:	80 93 ce 00 	sts	0x00CE, r24
    48d4:	05 c0       	rjmp	.+10     	; 0x48e0 <__vector_26+0x42>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART0_CONTROL &= ~_BV(UART0_UDRIE);
    48d6:	80 91 c9 00 	lds	r24, 0x00C9
    48da:	8f 7d       	andi	r24, 0xDF	; 223
    48dc:	80 93 c9 00 	sts	0x00C9, r24
    }
}
    48e0:	ff 91       	pop	r31
    48e2:	ef 91       	pop	r30
    48e4:	9f 91       	pop	r25
    48e6:	8f 91       	pop	r24
    48e8:	0f 90       	pop	r0
    48ea:	0f be       	out	0x3f, r0	; 63
    48ec:	0f 90       	pop	r0
    48ee:	1f 90       	pop	r1
    48f0:	18 95       	reti

000048f2 <uart_init>:
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart_init(unsigned int baudrate)
{
    UART_TxHead = 0;
    48f2:	10 92 ab 05 	sts	0x05AB, r1
    UART_TxTail = 0;
    48f6:	10 92 aa 05 	sts	0x05AA, r1
    UART_RxHead = 0;
    48fa:	10 92 a9 05 	sts	0x05A9, r1
    UART_RxTail = 0;
    48fe:	10 92 a8 05 	sts	0x05A8, r1
    /* enable UART receiver and transmmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);

#elif defined (ATMEGA_USART)
    /* Set baud rate */
    if ( baudrate & 0x8000 )
    4902:	97 ff       	sbrs	r25, 7
    4904:	04 c0       	rjmp	.+8      	; 0x490e <uart_init+0x1c>
    {
    	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
    4906:	22 e0       	ldi	r18, 0x02	; 2
    4908:	20 93 c8 00 	sts	0x00C8, r18
    	 baudrate &= ~0x8000;
    490c:	9f 77       	andi	r25, 0x7F	; 127
    }
    UBRRH = (unsigned char)(baudrate>>8);
    490e:	90 93 cd 00 	sts	0x00CD, r25
    UBRRL = (unsigned char) baudrate;
    4912:	80 93 cc 00 	sts	0x00CC, r24
   
    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
    4916:	88 e9       	ldi	r24, 0x98	; 152
    4918:	80 93 c9 00 	sts	0x00C9, r24
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
    #ifdef URSEL
    UCSRC = (1<<URSEL)|(3<<UCSZ0);
    #else
    UCSRC = (3<<UCSZ0);
    491c:	86 e0       	ldi	r24, 0x06	; 6
    491e:	80 93 ca 00 	sts	0x00CA, r24
    4922:	08 95       	ret

00004924 <uart_getc>:
{    
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
    4924:	90 91 a9 05 	lds	r25, 0x05A9
    4928:	80 91 a8 05 	lds	r24, 0x05A8
    492c:	98 17       	cp	r25, r24
    492e:	81 f0       	breq	.+32     	; 0x4950 <uart_getc+0x2c>
        return UART_NO_DATA;   /* no data available */
    }
    
    /* calculate /store buffer index */
    tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
    4930:	e0 91 a8 05 	lds	r30, 0x05A8
    4934:	ef 5f       	subi	r30, 0xFF	; 255
    4936:	ef 73       	andi	r30, 0x3F	; 63
    UART_RxTail = tmptail; 
    4938:	e0 93 a8 05 	sts	0x05A8, r30
    
    /* get data from receive buffer */
    data = UART_RxBuf[tmptail];
    493c:	f0 e0       	ldi	r31, 0x00	; 0
    493e:	e4 55       	subi	r30, 0x54	; 84
    4940:	fa 4f       	sbci	r31, 0xFA	; 250
    4942:	80 81       	ld	r24, Z
    
    data = (UART_LastRxError << 8) + data;
    4944:	90 91 a7 05 	lds	r25, 0x05A7
    UART_LastRxError = 0;
    4948:	10 92 a7 05 	sts	0x05A7, r1
    return data;
    494c:	90 e0       	ldi	r25, 0x00	; 0
    494e:	08 95       	ret
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
        return UART_NO_DATA;   /* no data available */
    4950:	80 e0       	ldi	r24, 0x00	; 0
    4952:	91 e0       	ldi	r25, 0x01	; 1
    
    data = (UART_LastRxError << 8) + data;
    UART_LastRxError = 0;
    return data;

}/* uart_getc */
    4954:	08 95       	ret

00004956 <uart_clear_rx_buffer>:

void uart_clear_rx_buffer(){
//the head and tail define the buffer index of the first and last byte of the received data.  
//If they are equal to each other, no data has been received (buffer empty)
	UART_RxHead = 0;
    4956:	10 92 a9 05 	sts	0x05A9, r1
	UART_RxTail = 0; 
    495a:	10 92 a8 05 	sts	0x05A8, r1
    495e:	08 95       	ret

00004960 <uart_putc>:
**************************************************************************/
void uart_putc(unsigned char data)
{
    unsigned char tmphead;
    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
    4960:	90 91 ab 05 	lds	r25, 0x05AB
    4964:	9f 5f       	subi	r25, 0xFF	; 255
    4966:	9f 70       	andi	r25, 0x0F	; 15
    
    while ( tmphead == UART_TxTail ){
    4968:	20 91 aa 05 	lds	r18, 0x05AA
    496c:	92 17       	cp	r25, r18
    496e:	e1 f3       	breq	.-8      	; 0x4968 <uart_putc+0x8>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
    4970:	e9 2f       	mov	r30, r25
    4972:	f0 e0       	ldi	r31, 0x00	; 0
    4974:	e4 51       	subi	r30, 0x14	; 20
    4976:	fa 4f       	sbci	r31, 0xFA	; 250
    4978:	80 83       	st	Z, r24
    UART_TxHead = tmphead;
    497a:	90 93 ab 05 	sts	0x05AB, r25

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
    497e:	80 91 c9 00 	lds	r24, 0x00C9
    4982:	80 62       	ori	r24, 0x20	; 32
    4984:	80 93 c9 00 	sts	0x00C9, r24
    4988:	08 95       	ret

0000498a <__vector_17>:
		return false;
	}
	else{
		return true;
	}
}
    498a:	1f 92       	push	r1
    498c:	0f 92       	push	r0
    498e:	0f b6       	in	r0, 0x3f	; 63
    4990:	0f 92       	push	r0
    4992:	11 24       	eor	r1, r1
    4994:	2f 93       	push	r18
    4996:	3f 93       	push	r19
    4998:	4f 93       	push	r20
    499a:	5f 93       	push	r21
    499c:	6f 93       	push	r22
    499e:	7f 93       	push	r23
    49a0:	8f 93       	push	r24
    49a2:	9f 93       	push	r25
    49a4:	af 93       	push	r26
    49a6:	bf 93       	push	r27
    49a8:	ef 93       	push	r30
    49aa:	ff 93       	push	r31
    49ac:	80 91 7f 06 	lds	r24, 0x067F
    49b0:	90 91 80 06 	lds	r25, 0x0680
    49b4:	01 96       	adiw	r24, 0x01	; 1
    49b6:	90 93 80 06 	sts	0x0680, r25
    49ba:	80 93 7f 06 	sts	0x067F, r24
    49be:	80 91 81 06 	lds	r24, 0x0681
    49c2:	90 91 82 06 	lds	r25, 0x0682
    49c6:	01 96       	adiw	r24, 0x01	; 1
    49c8:	90 93 82 06 	sts	0x0682, r25
    49cc:	80 93 81 06 	sts	0x0681, r24
    49d0:	80 91 89 07 	lds	r24, 0x0789
    49d4:	81 30       	cpi	r24, 0x01	; 1
    49d6:	79 f0       	breq	.+30     	; 0x49f6 <__vector_17+0x6c>
    49d8:	80 91 89 07 	lds	r24, 0x0789
    49dc:	8d 30       	cpi	r24, 0x0D	; 13
    49de:	59 f0       	breq	.+22     	; 0x49f6 <__vector_17+0x6c>
    49e0:	84 e5       	ldi	r24, 0x54	; 84
    49e2:	91 e0       	ldi	r25, 0x01	; 1
    49e4:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <MS_Device_USBTask>
    49e8:	84 e4       	ldi	r24, 0x44	; 68
    49ea:	91 e0       	ldi	r25, 0x01	; 1
    49ec:	0e 94 7c 2d 	call	0x5af8	; 0x5af8 <HID_Device_USBTask>
    49f0:	0e 94 41 35 	call	0x6a82	; 0x6a82 <USB_USBTask>
    49f4:	03 c0       	rjmp	.+6      	; 0x49fc <__vector_17+0x72>
    49f6:	81 e0       	ldi	r24, 0x01	; 1
    49f8:	80 93 39 06 	sts	0x0639, r24
    49fc:	ff 91       	pop	r31
    49fe:	ef 91       	pop	r30
    4a00:	bf 91       	pop	r27
    4a02:	af 91       	pop	r26
    4a04:	9f 91       	pop	r25
    4a06:	8f 91       	pop	r24
    4a08:	7f 91       	pop	r23
    4a0a:	6f 91       	pop	r22
    4a0c:	5f 91       	pop	r21
    4a0e:	4f 91       	pop	r20
    4a10:	3f 91       	pop	r19
    4a12:	2f 91       	pop	r18
    4a14:	0f 90       	pop	r0
    4a16:	0f be       	out	0x3f, r0	; 63
    4a18:	0f 90       	pop	r0
    4a1a:	1f 90       	pop	r1
    4a1c:	18 95       	reti

00004a1e <Task_Manager>:
    4a1e:	80 91 39 06 	lds	r24, 0x0639
    4a22:	81 30       	cpi	r24, 0x01	; 1
    4a24:	29 f4       	brne	.+10     	; 0x4a30 <Task_Manager+0x12>
    4a26:	84 e5       	ldi	r24, 0x54	; 84
    4a28:	91 e0       	ldi	r25, 0x01	; 1
    4a2a:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <MS_Device_USBTask>
    4a2e:	04 c0       	rjmp	.+8      	; 0x4a38 <Task_Manager+0x1a>
    4a30:	80 91 39 06 	lds	r24, 0x0639
    4a34:	83 30       	cpi	r24, 0x03	; 3
    4a36:	29 f4       	brne	.+10     	; 0x4a42 <Task_Manager+0x24>
    4a38:	84 e4       	ldi	r24, 0x44	; 68
    4a3a:	91 e0       	ldi	r25, 0x01	; 1
    4a3c:	0e 94 7c 2d 	call	0x5af8	; 0x5af8 <HID_Device_USBTask>
    4a40:	08 c0       	rjmp	.+16     	; 0x4a52 <Task_Manager+0x34>
    4a42:	80 91 39 06 	lds	r24, 0x0639
    4a46:	82 30       	cpi	r24, 0x02	; 2
    4a48:	31 f4       	brne	.+12     	; 0x4a56 <Task_Manager+0x38>
    4a4a:	84 e5       	ldi	r24, 0x54	; 84
    4a4c:	91 e0       	ldi	r25, 0x01	; 1
    4a4e:	0e 94 a0 2e 	call	0x5d40	; 0x5d40 <MS_Device_USBTask>
    4a52:	0e 94 41 35 	call	0x6a82	; 0x6a82 <USB_USBTask>
    4a56:	10 92 39 06 	sts	0x0639, r1
    4a5a:	08 95       	ret

00004a5c <SetupHardware>:
/** Configures the board hardware and chip peripherals for functionality. */
void SetupHardware()
{

	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
    4a5c:	84 b7       	in	r24, 0x34	; 52
    4a5e:	87 7f       	andi	r24, 0xF7	; 247
    4a60:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    4a62:	0f b6       	in	r0, 0x3f	; 63
    4a64:	f8 94       	cli
    4a66:	a8 95       	wdr
    4a68:	80 91 60 00 	lds	r24, 0x0060
    4a6c:	88 61       	ori	r24, 0x18	; 24
    4a6e:	80 93 60 00 	sts	0x0060, r24
    4a72:	10 92 60 00 	sts	0x0060, r1
    4a76:	0f be       	out	0x3f, r0	; 63
	wdt_disable();
	
	/* Disable JTAG on PortF -- enables Port F pins to function normally.  Datasheet requires this pin to be written repeatedly in order for it to work. 
	("The application software must write this bit to the desired value twice within four cycles to change its value."*/
	MCUCR |= (1 << JTD); 
    4a78:	85 b7       	in	r24, 0x35	; 53
    4a7a:	80 68       	ori	r24, 0x80	; 128
    4a7c:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4a7e:	85 b7       	in	r24, 0x35	; 53
    4a80:	80 68       	ori	r24, 0x80	; 128
    4a82:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4a84:	85 b7       	in	r24, 0x35	; 53
    4a86:	80 68       	ori	r24, 0x80	; 128
    4a88:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4a8a:	85 b7       	in	r24, 0x35	; 53
    4a8c:	80 68       	ori	r24, 0x80	; 128
    4a8e:	85 bf       	out	0x35, r24	; 53
from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
    4a90:	90 e0       	ldi	r25, 0x00	; 0
    4a92:	80 e8       	ldi	r24, 0x80	; 128
    4a94:	0f b6       	in	r0, 0x3f	; 63
    4a96:	f8 94       	cli
    4a98:	80 93 61 00 	sts	0x0061, r24
    4a9c:	90 93 61 00 	sts	0x0061, r25
    4aa0:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
	Config_Interrupts();
    4aa2:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <Config_Interrupts>
	
	/* Hardware Initialization */
	Config_IO();
    4aa6:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <Config_IO>
    4aaa:	2f e7       	ldi	r18, 0x7F	; 127
    4aac:	88 e3       	ldi	r24, 0x38	; 56
    4aae:	91 e0       	ldi	r25, 0x01	; 1
    4ab0:	21 50       	subi	r18, 0x01	; 1
    4ab2:	80 40       	sbci	r24, 0x00	; 0
    4ab4:	90 40       	sbci	r25, 0x00	; 0
    4ab6:	e1 f7       	brne	.-8      	; 0x4ab0 <SetupHardware+0x54>
    4ab8:	00 c0       	rjmp	.+0      	; 0x4aba <SetupHardware+0x5e>
    4aba:	00 00       	nop
	Delay_MS(50); //DELAY 50ms after setting IO.
	
	Reed1Polarity = eeprom_read_byte((uint8_t *)REED_1_POLARITY_ADDR);
    4abc:	86 e0       	ldi	r24, 0x06	; 6
    4abe:	92 e0       	ldi	r25, 0x02	; 2
    4ac0:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    4ac4:	91 e0       	ldi	r25, 0x01	; 1
    4ac6:	81 11       	cpse	r24, r1
    4ac8:	01 c0       	rjmp	.+2      	; 0x4acc <SetupHardware+0x70>
    4aca:	90 e0       	ldi	r25, 0x00	; 0
    4acc:	90 93 88 06 	sts	0x0688, r25
	Reed2Polarity= eeprom_read_byte((uint8_t *)REED_2_POLARITY_ADDR);
    4ad0:	87 e0       	ldi	r24, 0x07	; 7
    4ad2:	92 e0       	ldi	r25, 0x02	; 2
    4ad4:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    4ad8:	91 e0       	ldi	r25, 0x01	; 1
    4ada:	81 11       	cpse	r24, r1
    4adc:	01 c0       	rjmp	.+2      	; 0x4ae0 <SetupHardware+0x84>
    4ade:	90 e0       	ldi	r25, 0x00	; 0
    4ae0:	90 93 36 06 	sts	0x0636, r25
	Reed3Polarity = eeprom_read_byte((uint8_t *)REED_3_POLARITY_ADDR);
    4ae4:	88 e0       	ldi	r24, 0x08	; 8
    4ae6:	92 e0       	ldi	r25, 0x02	; 2
    4ae8:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    4aec:	91 e0       	ldi	r25, 0x01	; 1
    4aee:	81 11       	cpse	r24, r1
    4af0:	01 c0       	rjmp	.+2      	; 0x4af4 <SetupHardware+0x98>
    4af2:	90 e0       	ldi	r25, 0x00	; 0
    4af4:	90 93 0a 07 	sts	0x070A, r25
	Reed4Polarity = eeprom_read_byte((uint8_t *)REED_4_POLARITY_ADDR);
    4af8:	89 e0       	ldi	r24, 0x09	; 9
    4afa:	92 e0       	ldi	r25, 0x02	; 2
    4afc:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    4b00:	91 e0       	ldi	r25, 0x01	; 1
    4b02:	81 11       	cpse	r24, r1
    4b04:	01 c0       	rjmp	.+2      	; 0x4b08 <SetupHardware+0xac>
    4b06:	90 e0       	ldi	r25, 0x00	; 0
    4b08:	90 93 48 07 	sts	0x0748, r25
    4b0c:	08 95       	ret

00004b0e <EVENT_USB_Device_Connect>:
	
}

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
    4b0e:	08 95       	ret

00004b10 <EVENT_USB_Device_Disconnect>:
}

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	if(SDCardManager_CheckSDCardOperation()){ //if there is an SD Card present, flip into sd mode if the computer is shut off.
    4b10:	95 de       	rcall	.-726    	; 0x483c <SDCardManager_CheckSDCardOperation>
    4b12:	88 23       	and	r24, r24
    4b14:	19 f0       	breq	.+6      	; 0x4b1c <EVENT_USB_Device_Disconnect+0xc>
		Typewriter_Mode = SD_MODE;
    4b16:	82 e0       	ldi	r24, 0x02	; 2
    4b18:	80 93 89 07 	sts	0x0789, r24
    4b1c:	08 95       	ret

00004b1e <EVENT_USB_Device_Suspend>:
	}

}

void EVENT_USB_Device_Suspend(void){
    4b1e:	08 95       	ret

00004b20 <EVENT_USB_Device_WakeUp>:
	
}

void EVENT_USB_Device_WakeUp(void){
    4b20:	08 95       	ret

00004b22 <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= HID_Device_ConfigureEndpoints(&Keyboard_HID_Interface);
    4b22:	84 e4       	ldi	r24, 0x44	; 68
    4b24:	91 e0       	ldi	r25, 0x01	; 1
    4b26:	d5 d7       	rcall	.+4010   	; 0x5ad2 <HID_Device_ConfigureEndpoints>
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
    4b28:	84 e5       	ldi	r24, 0x54	; 84
    4b2a:	91 e0       	ldi	r25, 0x01	; 1
    4b2c:	0e 94 83 2e 	call	0x5d06	; 0x5d06 <MS_Device_ConfigureEndpoints>
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
    4b30:	e2 ee       	ldi	r30, 0xE2	; 226
    4b32:	f0 e0       	ldi	r31, 0x00	; 0
    4b34:	80 81       	ld	r24, Z
    4b36:	84 60       	ori	r24, 0x04	; 4
    4b38:	80 83       	st	Z, r24
    4b3a:	08 95       	ret

00004b3c <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	MS_Device_ProcessControlRequest(&Disk_MS_Interface);
    4b3c:	84 e5       	ldi	r24, 0x54	; 84
    4b3e:	91 e0       	ldi	r25, 0x01	; 1
    4b40:	0e 94 42 2e 	call	0x5c84	; 0x5c84 <MS_Device_ProcessControlRequest>
	HID_Device_ProcessControlRequest(&Keyboard_HID_Interface);
    4b44:	84 e4       	ldi	r24, 0x44	; 68
    4b46:	91 e0       	ldi	r25, 0x01	; 1
    4b48:	8a c6       	rjmp	.+3348   	; 0x585e <HID_Device_ProcessControlRequest>

00004b4a <EVENT_USB_Device_StartOfFrame>:
			 *  \param[in,out] HIDInterfaceInfo  Pointer to a structure containing a HID Class configuration and state.
			 */
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo) ATTR_ALWAYS_INLINE ATTR_NON_NULL_PTR_ARG(1);
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
			{
				if (HIDInterfaceInfo->State.IdleMSRemaining)
    4b4a:	80 91 52 01 	lds	r24, 0x0152
    4b4e:	90 91 53 01 	lds	r25, 0x0153
    4b52:	00 97       	sbiw	r24, 0x00	; 0
    4b54:	29 f0       	breq	.+10     	; 0x4b60 <EVENT_USB_Device_StartOfFrame+0x16>
				  HIDInterfaceInfo->State.IdleMSRemaining--;
    4b56:	01 97       	sbiw	r24, 0x01	; 1
    4b58:	90 93 53 01 	sts	0x0153, r25
    4b5c:	80 93 52 01 	sts	0x0152, r24
    4b60:	08 95       	ret

00004b62 <CALLBACK_MS_Device_SCSICommandReceived>:
 */
bool CALLBACK_MS_Device_SCSICommandReceived(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	bool CommandSuccess;

	CommandSuccess = SCSI_DecodeSCSICommand(MSInterfaceInfo);
    4b62:	bf cb       	rjmp	.-2178   	; 0x42e2 <SCSI_DecodeSCSICommand>

00004b64 <CALLBACK_HID_Device_CreateHIDReport>:
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
                                         uint8_t* const ReportID,
                                         const uint8_t ReportType,
                                         void* ReportData,
                                         uint16_t* const ReportSize)
{
    4b64:	0f 93       	push	r16
    4b66:	1f 93       	push	r17
    4b68:	f9 01       	movw	r30, r18
	USB_KeyboardReport_Data_t* KeyboardReport = (USB_KeyboardReport_Data_t*)ReportData;

//	memcpy((void*)KeyboardReport->KeyCode, (void*)KeyBuffer->KeyCode, 6); //copy the keybuffer into the keyboard report being sent to host.
	KeyboardReport->KeyCode[0] = KeyBuffer->KeyCode[0];
    4b6a:	a0 91 84 06 	lds	r26, 0x0684
    4b6e:	b0 91 85 06 	lds	r27, 0x0685
    4b72:	12 96       	adiw	r26, 0x02	; 2
    4b74:	8c 91       	ld	r24, X
    4b76:	82 83       	std	Z+2, r24	; 0x02

	if (Hold_Alt_Down) { //this flag instructs us to hold alt down continuously, so that numpad ascii can be sent.
    4b78:	90 91 87 06 	lds	r25, 0x0687
    4b7c:	99 23       	and	r25, r25
    4b7e:	11 f0       	breq	.+4      	; 0x4b84 <CALLBACK_HID_Device_CreateHIDReport+0x20>
		KeyboardReport->Modifier = HID_KEYBOARD_MODIFIER_LEFTALT;
    4b80:	84 e0       	ldi	r24, 0x04	; 4
    4b82:	04 c0       	rjmp	.+8      	; 0x4b8c <CALLBACK_HID_Device_CreateHIDReport+0x28>
	}
	else if (KeyboardReport->KeyCode[0]){ //if there is a key waiting to be sent, then use the modifier that goes with that key.
    4b84:	88 23       	and	r24, r24
    4b86:	21 f0       	breq	.+8      	; 0x4b90 <CALLBACK_HID_Device_CreateHIDReport+0x2c>
		KeyboardReport->Modifier = KeyBufferMod;
    4b88:	80 91 3b 06 	lds	r24, 0x063B
    4b8c:	80 83       	st	Z, r24
    4b8e:	01 c0       	rjmp	.+2      	; 0x4b92 <CALLBACK_HID_Device_CreateHIDReport+0x2e>
	}
	else{
		KeyboardReport->Modifier = 0; //otherwise, clear the modifiers so the host doesn't think we are holding down shift or alt or whatever for no reason.
    4b90:	10 82       	st	Z, r1
	}
	
//	memset((void*)KeyBuffer->KeyCode,0,6);  //clear keybuffer to clear room for the next key.  This indicates to other routines that the USB buffer is available for sending.
	KeyBuffer->KeyCode[0] = 0;
    4b92:	e0 91 84 06 	lds	r30, 0x0684
    4b96:	f0 91 85 06 	lds	r31, 0x0685
    4b9a:	12 82       	std	Z+2, r1	; 0x02
	KeyBufferMod= 0;
    4b9c:	10 92 3b 06 	sts	0x063B, r1

	*ReportSize = sizeof(USB_KeyboardReport_Data_t);
    4ba0:	88 e0       	ldi	r24, 0x08	; 8
    4ba2:	90 e0       	ldi	r25, 0x00	; 0
    4ba4:	f8 01       	movw	r30, r16
    4ba6:	91 83       	std	Z+1, r25	; 0x01
    4ba8:	80 83       	st	Z, r24
	return false;
}
    4baa:	80 e0       	ldi	r24, 0x00	; 0
    4bac:	1f 91       	pop	r17
    4bae:	0f 91       	pop	r16
    4bb0:	08 95       	ret

00004bb2 <CALLBACK_HID_Device_ProcessHIDReport>:
{
	uint8_t* LEDReport = (uint8_t*)ReportData;
	static bool NumLockActivated;
	static bool CapsLockDeactivated;

		if (!(*LEDReport & HID_KEYBOARD_LED_NUMLOCK) && !(NumLockActivated)){ //if numlock is somehow inactive, and numlock not already deactivated by code,
    4bb2:	f9 01       	movw	r30, r18
    4bb4:	80 81       	ld	r24, Z
    4bb6:	80 fd       	sbrc	r24, 0
    4bb8:	0e c0       	rjmp	.+28     	; 0x4bd6 <CALLBACK_HID_Device_ProcessHIDReport+0x24>
    4bba:	90 91 fd 05 	lds	r25, 0x05FD
    4bbe:	91 11       	cpse	r25, r1
    4bc0:	0a c0       	rjmp	.+20     	; 0x4bd6 <CALLBACK_HID_Device_ProcessHIDReport+0x24>
		  KeyBuffer->KeyCode[0] = HID_KEYBOARD_SC_NUM_LOCK; //press numlock key to activate it.  -- NumLockDeactivated flag makes sure this only happens once per session.
    4bc2:	e0 91 84 06 	lds	r30, 0x0684
    4bc6:	f0 91 85 06 	lds	r31, 0x0685
    4bca:	83 e5       	ldi	r24, 0x53	; 83
    4bcc:	82 83       	std	Z+2, r24	; 0x02
		  NumLockActivated = true;
    4bce:	81 e0       	ldi	r24, 0x01	; 1
    4bd0:	80 93 fd 05 	sts	0x05FD, r24
    4bd4:	08 95       	ret
		}

		else if ((*LEDReport & HID_KEYBOARD_LED_CAPSLOCK) && !(CapsLockDeactivated)){ //if capslock is somehow active,
    4bd6:	81 ff       	sbrs	r24, 1
    4bd8:	0d c0       	rjmp	.+26     	; 0x4bf4 <CALLBACK_HID_Device_ProcessHIDReport+0x42>
    4bda:	80 91 fc 05 	lds	r24, 0x05FC
    4bde:	81 11       	cpse	r24, r1
    4be0:	09 c0       	rjmp	.+18     	; 0x4bf4 <CALLBACK_HID_Device_ProcessHIDReport+0x42>
		 KeyBuffer ->KeyCode[0] = HID_KEYBOARD_SC_CAPS_LOCK; //press capslock key to deactivate it.
    4be2:	e0 91 84 06 	lds	r30, 0x0684
    4be6:	f0 91 85 06 	lds	r31, 0x0685
    4bea:	89 e3       	ldi	r24, 0x39	; 57
    4bec:	82 83       	std	Z+2, r24	; 0x02
		 CapsLockDeactivated = true;
    4bee:	81 e0       	ldi	r24, 0x01	; 1
    4bf0:	80 93 fc 05 	sts	0x05FC, r24
    4bf4:	08 95       	ret

00004bf6 <Init_Mode>:
	//	  KeyBuffer ->KeyCode[0] = HID_KEYBOARD_SC_SCROLL_LOCK; //press scrolllock key to deactivate it.
	
}


void Init_Mode(){
    4bf6:	cf 93       	push	r28
	uint8_t key;
	uint8_t code;
	uint8_t Default_Mode;
	
	Default_Mode = eeprom_read_byte((uint8_t*)DEFAULT_MODE_ADDR);
    4bf8:	8d e0       	ldi	r24, 0x0D	; 13
    4bfa:	92 e0       	ldi	r25, 0x02	; 2
    4bfc:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    4c00:	c8 2f       	mov	r28, r24
	
	key = GetKeySimple(); //read the key that is being held during startup (if any)
    4c02:	b0 d3       	rcall	.+1888   	; 0x5364 <GetKeySimple>
	code = GetASCIIKeyCode(key,UPPER);
    4c04:	62 e0       	ldi	r22, 0x02	; 2
    4c06:	32 d5       	rcall	.+2660   	; 0x566c <GetASCIIKeyCode>
	
	if (is_low(S1)&&is_low(S2)&&is_low(S3)){ //reset device to known state
    4c08:	7c 99       	sbic	0x0f, 4	; 15
    4c0a:	0c c0       	rjmp	.+24     	; 0x4c24 <Init_Mode+0x2e>
    4c0c:	7d 99       	sbic	0x0f, 5	; 15
    4c0e:	0a c0       	rjmp	.+20     	; 0x4c24 <Init_Mode+0x2e>
    4c10:	7e 99       	sbic	0x0f, 6	; 15
    4c12:	08 c0       	rjmp	.+16     	; 0x4c24 <Init_Mode+0x2e>
			Typewriter_Mode = USB_COMBO_MODE;
    4c14:	81 e0       	ldi	r24, 0x01	; 1
    4c16:	80 93 89 07 	sts	0x0789, r24
			Default_Mode = USB_COMBO_MODE;
			GlowGreenLED(SLOW,GLOWING);
    4c1a:	60 e0       	ldi	r22, 0x00	; 0
    4c1c:	0e 94 2f 0b 	call	0x165e	; 0x165e <GlowGreenLED>
			RestoreFactoryDefaults();			
    4c20:	c6 d5       	rcall	.+2956   	; 0x57ae <RestoreFactoryDefaults>
    4c22:	31 c0       	rjmp	.+98     	; 0x4c86 <Init_Mode+0x90>
	}
	else if(is_low(S2)&&is_low(S3)){ //configure bluetooth and test bluetooth -- reset bluetooth module  -- force initialization next time bluetooth is used.
    4c24:	7d 99       	sbic	0x0f, 5	; 15
    4c26:	10 c0       	rjmp	.+32     	; 0x4c48 <Init_Mode+0x52>
    4c28:	7e 99       	sbic	0x0f, 6	; 15
    4c2a:	0e c0       	rjmp	.+28     	; 0x4c48 <Init_Mode+0x52>
			if(Bluetooth_Configure()){
    4c2c:	0e 94 55 04 	call	0x8aa	; 0x8aa <Bluetooth_Configure>
    4c30:	88 23       	and	r24, r24
    4c32:	31 f0       	breq	.+12     	; 0x4c40 <Init_Mode+0x4a>
					#ifndef BT_DEBUG
						USB_Disable(); //leave usb active if this is debug mode.
    4c34:	0e 94 ae 32 	call	0x655c	; 0x655c <USB_Disable>
					#endif
					BluetoothInquire();//clear paired device list and try to pair.
    4c38:	0e 94 84 04 	call	0x908	; 0x908 <BluetoothInquire>
					Typewriter_Mode = BLUETOOTH_MODE;
    4c3c:	89 e0       	ldi	r24, 0x09	; 9
    4c3e:	01 c0       	rjmp	.+2      	; 0x4c42 <Init_Mode+0x4c>
					//Default_Mode = BLUETOOTH_MODE;  //Do not set bluetooth mode as the default, since this mode only TESTS the bluetooth
			}
			else{ //if something goes wrong during configuration...
					Typewriter_Mode = PANIC_MODE; //don't change default mode
    4c40:	8a e0       	ldi	r24, 0x0A	; 10
    4c42:	80 93 89 07 	sts	0x0789, r24
    4c46:	4a c0       	rjmp	.+148    	; 0x4cdc <Init_Mode+0xe6>
			}
	}
	else if(is_low(S1)&&is_low(S2)){
    4c48:	7c 99       	sbic	0x0f, 4	; 15
    4c4a:	04 c0       	rjmp	.+8      	; 0x4c54 <Init_Mode+0x5e>
    4c4c:	7d 99       	sbic	0x0f, 5	; 15
    4c4e:	02 c0       	rjmp	.+4      	; 0x4c54 <Init_Mode+0x5e>
			Typewriter_Mode = MANUAL_CAL_MODE;
    4c50:	8e e0       	ldi	r24, 0x0E	; 14
    4c52:	f7 cf       	rjmp	.-18     	; 0x4c42 <Init_Mode+0x4c>
	}
	else if(is_low(S1)&&is_low(S3)){//quick calibration mode
    4c54:	7c 99       	sbic	0x0f, 4	; 15
    4c56:	04 c0       	rjmp	.+8      	; 0x4c60 <Init_Mode+0x6a>
    4c58:	7e 99       	sbic	0x0f, 6	; 15
    4c5a:	02 c0       	rjmp	.+4      	; 0x4c60 <Init_Mode+0x6a>
			Typewriter_Mode = QUICK_CAL_MODE;
    4c5c:	86 e0       	ldi	r24, 0x06	; 6
    4c5e:	f1 cf       	rjmp	.-30     	; 0x4c42 <Init_Mode+0x4c>
	}
	else if (is_low(S1)){ //hold down S1 during initialization to calibrate
    4c60:	7c 99       	sbic	0x0f, 4	; 15
    4c62:	02 c0       	rjmp	.+4      	; 0x4c68 <Init_Mode+0x72>
			Typewriter_Mode = CAL_MODE;
    4c64:	85 e0       	ldi	r24, 0x05	; 5
    4c66:	ed cf       	rjmp	.-38     	; 0x4c42 <Init_Mode+0x4c>
	}
	else if(is_low(S2)){
    4c68:	7d 99       	sbic	0x0f, 5	; 15
    4c6a:	02 c0       	rjmp	.+4      	; 0x4c70 <Init_Mode+0x7a>
		Typewriter_Mode = SENSITIVITY_MODE;
    4c6c:	83 e0       	ldi	r24, 0x03	; 3
    4c6e:	e9 cf       	rjmp	.-46     	; 0x4c42 <Init_Mode+0x4c>
	}
	else if (is_low(S3)){ //hold down S3 to enter LED indication mode to test reed switches.
    4c70:	7e 99       	sbic	0x0f, 6	; 15
    4c72:	02 c0       	rjmp	.+4      	; 0x4c78 <Init_Mode+0x82>
		Typewriter_Mode = TEST_MODE;
    4c74:	84 e0       	ldi	r24, 0x04	; 4
    4c76:	e5 cf       	rjmp	.-54     	; 0x4c42 <Init_Mode+0x4c>
	}
	else if(code == 'U'){ //if the letter U is being held by user
    4c78:	85 35       	cpi	r24, 0x55	; 85
    4c7a:	39 f4       	brne	.+14     	; 0x4c8a <Init_Mode+0x94>
		Typewriter_Mode = USB_COMBO_MODE;
    4c7c:	81 e0       	ldi	r24, 0x01	; 1
    4c7e:	80 93 89 07 	sts	0x0789, r24
		Default_Mode = USB_COMBO_MODE;	
		Ignore_Flag = 1; //tell sensor routine to ignore this U.
    4c82:	80 93 83 06 	sts	0x0683, r24
	else if (is_low(S3)){ //hold down S3 to enter LED indication mode to test reed switches.
		Typewriter_Mode = TEST_MODE;
	}
	else if(code == 'U'){ //if the letter U is being held by user
		Typewriter_Mode = USB_COMBO_MODE;
		Default_Mode = USB_COMBO_MODE;	
    4c86:	c1 e0       	ldi	r28, 0x01	; 1
    4c88:	29 c0       	rjmp	.+82     	; 0x4cdc <Init_Mode+0xe6>
		Ignore_Flag = 1; //tell sensor routine to ignore this U.
	}
	else if(code == 'S'){//if the letter S is being held by the user
    4c8a:	83 35       	cpi	r24, 0x53	; 83
    4c8c:	79 f4       	brne	.+30     	; 0x4cac <Init_Mode+0xb6>
		if(SDCardManager_CheckSDCardOperation()){ //if an sd card is present and working, put typewriter into sd mode
    4c8e:	d6 dd       	rcall	.-1108   	; 0x483c <SDCardManager_CheckSDCardOperation>
    4c90:	88 23       	and	r24, r24
    4c92:	39 f0       	breq	.+14     	; 0x4ca2 <Init_Mode+0xac>
			Typewriter_Mode = SD_MODE;
    4c94:	82 e0       	ldi	r24, 0x02	; 2
    4c96:	80 93 89 07 	sts	0x0789, r24
			Default_Mode = SD_MODE;
			Ignore_Flag = 1; //tell sensor routine to ignore this S.
    4c9a:	81 e0       	ldi	r24, 0x01	; 1
    4c9c:	80 93 83 06 	sts	0x0683, r24
    4ca0:	03 c0       	rjmp	.+6      	; 0x4ca8 <Init_Mode+0xb2>
		}
		else{
			Typewriter_Mode = PANIC_MODE; //otherwise, panic to indicate malfunction ... don't change default mode.
    4ca2:	8a e0       	ldi	r24, 0x0A	; 10
    4ca4:	80 93 89 07 	sts	0x0789, r24
			Default_Mode = SD_MODE; //even so, sd mode next time you plug in.
    4ca8:	c2 e0       	ldi	r28, 0x02	; 2
    4caa:	18 c0       	rjmp	.+48     	; 0x4cdc <Init_Mode+0xe6>
		}
	}
	else if(code == 'B'){ //if the letter B is being held by the user
    4cac:	82 34       	cpi	r24, 0x42	; 66
    4cae:	69 f4       	brne	.+26     	; 0x4cca <Init_Mode+0xd4>
		#ifndef BT_DEBUG
			USB_Disable(); //if this is not debug mode, disable the usb port.
    4cb0:	0e 94 ae 32 	call	0x655c	; 0x655c <USB_Disable>
		#endif
		if(Bluetooth_Configure()){ // attempt to configure.
    4cb4:	0e 94 55 04 	call	0x8aa	; 0x8aa <Bluetooth_Configure>
    4cb8:	88 23       	and	r24, r24
    4cba:	11 f2       	breq	.-124    	; 0x4c40 <Init_Mode+0x4a>
			BluetoothInquire(); //if configuration is successful, delete the paired device list so device can become discoverable.
    4cbc:	0e 94 84 04 	call	0x908	; 0x908 <BluetoothInquire>
			Typewriter_Mode = BLUETOOTH_MODE;
    4cc0:	89 e0       	ldi	r24, 0x09	; 9
    4cc2:	80 93 89 07 	sts	0x0789, r24
			Default_Mode = BLUETOOTH_MODE;
    4cc6:	c9 e0       	ldi	r28, 0x09	; 9
    4cc8:	09 c0       	rjmp	.+18     	; 0x4cdc <Init_Mode+0xe6>
		}
		else{ //if something goes wrong during configuration...
			Typewriter_Mode = PANIC_MODE; //indicate error
		}
	}
	else if(code == 'L'){
    4cca:	8c 34       	cpi	r24, 0x4C	; 76
    4ccc:	29 f4       	brne	.+10     	; 0x4cd8 <Init_Mode+0xe2>
			Typewriter_Mode = USB_LIGHT_MODE;
    4cce:	8d e0       	ldi	r24, 0x0D	; 13
    4cd0:	80 93 89 07 	sts	0x0789, r24
			Default_Mode = USB_LIGHT_MODE;
    4cd4:	cd e0       	ldi	r28, 0x0D	; 13
    4cd6:	02 c0       	rjmp	.+4      	; 0x4cdc <Init_Mode+0xe6>
	}

	else{
		Typewriter_Mode = Default_Mode; //otherwise just go into the last mode selected by user.
    4cd8:	c0 93 89 07 	sts	0x0789, r28
	}
	
	eeprom_update_byte((uint8_t*)DEFAULT_MODE_ADDR,Default_Mode);  //Save the new default mode (if changed)
    4cdc:	6c 2f       	mov	r22, r28
    4cde:	8d e0       	ldi	r24, 0x0D	; 13
    4ce0:	92 e0       	ldi	r25, 0x02	; 2
}
    4ce2:	cf 91       	pop	r28

	else{
		Typewriter_Mode = Default_Mode; //otherwise just go into the last mode selected by user.
	}
	
	eeprom_update_byte((uint8_t*)DEFAULT_MODE_ADDR,Default_Mode);  //Save the new default mode (if changed)
    4ce4:	0c 94 36 39 	jmp	0x726c	; 0x726c <eeprom_update_byte>

00004ce8 <main>:

/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{	
    4ce8:	cf 93       	push	r28
    4cea:	df 93       	push	r29
    4cec:	1f 92       	push	r1
    4cee:	cd b7       	in	r28, 0x3d	; 61
    4cf0:	de b7       	in	r29, 0x3e	; 62
	uint8_t key;
	uint8_t code;
	uint8_t modifier;
	uint8_t parity;
	
	Typewriter_Mode = INITIALIZING;
    4cf2:	8c e0       	ldi	r24, 0x0C	; 12
    4cf4:	80 93 89 07 	sts	0x0789, r24

	SetupHardware();
    4cf8:	b1 de       	rcall	.-670    	; 0x4a5c <SetupHardware>
	InitializeEeprom();//sets all EEPROM entries to zero if the checksum is incorrect
    4cfa:	88 d5       	rcall	.+2832   	; 0x580c <InitializeEeprom>
	LoadEepromParameters();
    4cfc:	fb d4       	rcall	.+2550   	; 0x56f4 <LoadEepromParameters>
	LoadKeyCodeTables();
    4cfe:	d2 d4       	rcall	.+2468   	; 0x56a4 <LoadKeyCodeTables>
	SDCardManager_Init(); 
    4d00:	42 dc       	rcall	.-1916   	; 0x4586 <SDCardManager_Init>
	USB_Init();//DEBUG ONLY
    4d02:	0e 94 06 33 	call	0x660c	; 0x660c <USB_Init>
	uart_init(UART_BAUD_SELECT(9600,F_CPU));//initialize the uart with a baud rate of x bps
    4d06:	83 e3       	ldi	r24, 0x33	; 51
    4d08:	90 e0       	ldi	r25, 0x00	; 0
    4d0a:	f3 dd       	rcall	.-1050   	; 0x48f2 <uart_init>
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    4d0c:	78 94       	sei

	//USB_Init(); COMMENTED FOR DEBUGGING
	GlobalInterruptEnable();
	
	Init_Mode();
    4d0e:	73 df       	rcall	.-282    	; 0x4bf6 <Init_Mode>
				Calibrate();
				Typewriter_Mode = USB_LIGHT_MODE; //after calibrating, go to usb light mode.
			break;
			case QUICK_CAL_MODE:
				QuickCalibrate();
				Typewriter_Mode = USB_LIGHT_MODE;//after calibrating, go to usb light mode.
    4d10:	1d e0       	ldi	r17, 0x0D	; 13
			case SENSITIVITY_MODE:
				Adjust_Sensitivity();
				Typewriter_Mode = USB_LIGHT_MODE;
			break;
			default:
				Typewriter_Mode = PANIC_MODE;
    4d12:	0a e0       	ldi	r16, 0x0A	; 10
	
	Init_Mode();
//	Delay_MS(INIT_DELAY);
	
	while(1){
		switch (Typewriter_Mode){
    4d14:	80 91 89 07 	lds	r24, 0x0789
    4d18:	86 30       	cpi	r24, 0x06	; 6
    4d1a:	09 f4       	brne	.+2      	; 0x4d1e <main+0x36>
    4d1c:	84 c0       	rjmp	.+264    	; 0x4e26 <main+0x13e>
    4d1e:	9c f4       	brge	.+38     	; 0x4d46 <main+0x5e>
    4d20:	83 30       	cpi	r24, 0x03	; 3
    4d22:	09 f4       	brne	.+2      	; 0x4d26 <main+0x3e>
    4d24:	d1 c0       	rjmp	.+418    	; 0x4ec8 <main+0x1e0>
    4d26:	34 f4       	brge	.+12     	; 0x4d34 <main+0x4c>
    4d28:	81 30       	cpi	r24, 0x01	; 1
    4d2a:	11 f1       	breq	.+68     	; 0x4d70 <main+0x88>
    4d2c:	82 30       	cpi	r24, 0x02	; 2
    4d2e:	09 f4       	brne	.+2      	; 0x4d32 <main+0x4a>
    4d30:	6f c0       	rjmp	.+222    	; 0x4e10 <main+0x128>
    4d32:	cf c0       	rjmp	.+414    	; 0x4ed2 <main+0x1ea>
    4d34:	84 30       	cpi	r24, 0x04	; 4
    4d36:	09 f4       	brne	.+2      	; 0x4d3a <main+0x52>
    4d38:	3d c0       	rjmp	.+122    	; 0x4db4 <main+0xcc>
    4d3a:	85 30       	cpi	r24, 0x05	; 5
    4d3c:	09 f0       	breq	.+2      	; 0x4d40 <main+0x58>
    4d3e:	c9 c0       	rjmp	.+402    	; 0x4ed2 <main+0x1ea>
				if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
				USB_Disable(); //make sure no host is connected before accessing SD card.
				LogKeystrokes();
			break;
			case CAL_MODE:
				Calibrate();
    4d40:	0e 94 6c 07 	call	0xed8	; 0xed8 <Calibrate>
    4d44:	c3 c0       	rjmp	.+390    	; 0x4ecc <main+0x1e4>
	
	Init_Mode();
//	Delay_MS(INIT_DELAY);
	
	while(1){
		switch (Typewriter_Mode){
    4d46:	8b 30       	cpi	r24, 0x0B	; 11
    4d48:	09 f4       	brne	.+2      	; 0x4d4c <main+0x64>
    4d4a:	5e c0       	rjmp	.+188    	; 0x4e08 <main+0x120>
    4d4c:	4c f4       	brge	.+18     	; 0x4d60 <main+0x78>
    4d4e:	89 30       	cpi	r24, 0x09	; 9
    4d50:	09 f4       	brne	.+2      	; 0x4d54 <main+0x6c>
    4d52:	6c c0       	rjmp	.+216    	; 0x4e2c <main+0x144>
    4d54:	8a 30       	cpi	r24, 0x0A	; 10
    4d56:	09 f0       	breq	.+2      	; 0x4d5a <main+0x72>
    4d58:	bc c0       	rjmp	.+376    	; 0x4ed2 <main+0x1ea>
					Delay_MS(SENSE_DELAY);//perform this loop every X ms.
					
				}
			break;
			case PANIC_MODE:
				USB_Disable();
    4d5a:	0e 94 ae 32 	call	0x655c	; 0x655c <USB_Disable>
    4d5e:	9d c0       	rjmp	.+314    	; 0x4e9a <main+0x1b2>
	
	Init_Mode();
//	Delay_MS(INIT_DELAY);
	
	while(1){
		switch (Typewriter_Mode){
    4d60:	8d 30       	cpi	r24, 0x0D	; 13
    4d62:	31 f0       	breq	.+12     	; 0x4d70 <main+0x88>
    4d64:	8e 30       	cpi	r24, 0x0E	; 14
    4d66:	09 f0       	breq	.+2      	; 0x4d6a <main+0x82>
    4d68:	b4 c0       	rjmp	.+360    	; 0x4ed2 <main+0x1ea>
			case QUICK_CAL_MODE:
				QuickCalibrate();
				Typewriter_Mode = USB_LIGHT_MODE;//after calibrating, go to usb light mode.
			break;
			case MANUAL_CAL_MODE:
				Calibrate_Manually();
    4d6a:	0e 94 e9 06 	call	0xdd2	; 0xdd2 <Calibrate_Manually>
    4d6e:	ae c0       	rjmp	.+348    	; 0x4ecc <main+0x1e4>
	
	while(1){
		switch (Typewriter_Mode){
			case USB_LIGHT_MODE:
			case USB_COMBO_MODE:				
			MountFilesystem();//mount the filesystem so that we have info on it
    4d70:	0e 94 15 0c 	call	0x182a	; 0x182a <MountFilesystem>
			while(1){
				key = GetKey();
    4d74:	1f d3       	rcall	.+1598   	; 0x53b4 <GetKey>
    4d76:	18 2f       	mov	r17, r24
				modifier = GetModifier(); 
    4d78:	13 d2       	rcall	.+1062   	; 0x51a0 <GetModifier>
    4d7a:	89 83       	std	Y+1, r24	; 0x01
				code = GetHIDKeyCode(key, &modifier);
    4d7c:	be 01       	movw	r22, r28
    4d7e:	6f 5f       	subi	r22, 0xFF	; 255
    4d80:	7f 4f       	sbci	r23, 0xFF	; 255
    4d82:	81 2f       	mov	r24, r17
    4d84:	55 d4       	rcall	.+2218   	; 0x5630 <GetHIDKeyCode>
					
				if(code){//if the code is valid, send it
    4d86:	88 23       	and	r24, r24
    4d88:	51 f0       	breq	.+20     	; 0x4d9e <main+0xb6>
						if ((code == KEY_U)&&Ignore_Flag) code = 0; //if user is holding down U on startup, don't add this U to file.
    4d8a:	88 31       	cpi	r24, 0x18	; 24
    4d8c:	21 f4       	brne	.+8      	; 0x4d96 <main+0xae>
    4d8e:	90 91 83 06 	lds	r25, 0x0683
    4d92:	91 11       	cpse	r25, r1
    4d94:	80 e0       	ldi	r24, 0x00	; 0
						Ignore_Flag = 0;
    4d96:	10 92 83 06 	sts	0x0683, r1
						USBSend(code,modifier);
    4d9a:	69 81       	ldd	r22, Y+1	; 0x01
    4d9c:	9d d0       	rcall	.+314    	; 0x4ed8 <USBSend>
    4d9e:	8f ec       	ldi	r24, 0xCF	; 207
    4da0:	97 e0       	ldi	r25, 0x07	; 7
    4da2:	01 97       	sbiw	r24, 0x01	; 1
    4da4:	f1 f7       	brne	.-4      	; 0x4da2 <main+0xba>
    4da6:	00 c0       	rjmp	.+0      	; 0x4da8 <main+0xc0>
    4da8:	00 00       	nop
				}
				Delay_MS(SENSE_DELAY);//perform this loop every X ms.
				HID_Device_USBTask(&Keyboard_HID_Interface);
    4daa:	84 e4       	ldi	r24, 0x44	; 68
    4dac:	91 e0       	ldi	r25, 0x01	; 1
    4dae:	a4 d6       	rcall	.+3400   	; 0x5af8 <HID_Device_USBTask>
				Task_Manager(); //do the required usb upkeep tasks, then update the list of scheduled tasks.
    4db0:	36 de       	rcall	.-916    	; 0x4a1e <Task_Manager>
				
			}
    4db2:	e0 cf       	rjmp	.-64     	; 0x4d74 <main+0x8c>
			break;
			case TEST_MODE:
				USB_Disable(); //USB not needed for testing
    4db4:	0e 94 ae 32 	call	0x655c	; 0x655c <USB_Disable>
				while(1){
					UseHallSensor = HALL_NOT_PRESENT;//make sure hall sensor bit is not zeroed out by ReadSensor() as soon as it is read;
					parity = (uint8_t)is_low(REED_1) + (uint8_t)is_low(REED_2)+ (uint8_t)is_low(REED_3) + (uint8_t)is_low(REED_4) + (uint8_t)getHallState();
    4db8:	01 e0       	ldi	r16, 0x01	; 1
			}
			break;
			case TEST_MODE:
				USB_Disable(); //USB not needed for testing
				while(1){
					UseHallSensor = HALL_NOT_PRESENT;//make sure hall sensor bit is not zeroed out by ReadSensor() as soon as it is read;
    4dba:	10 92 0b 07 	sts	0x070B, r1
					parity = (uint8_t)is_low(REED_1) + (uint8_t)is_low(REED_2)+ (uint8_t)is_low(REED_3) + (uint8_t)is_low(REED_4) + (uint8_t)getHallState();
    4dbe:	89 b1       	in	r24, 0x09	; 9
    4dc0:	19 b1       	in	r17, 0x09	; 9
    4dc2:	29 b1       	in	r18, 0x09	; 9
    4dc4:	93 b1       	in	r25, 0x03	; 3
    4dc6:	16 fb       	bst	r17, 6
    4dc8:	11 27       	eor	r17, r17
    4dca:	10 f9       	bld	r17, 0
    4dcc:	10 27       	eor	r17, r16
    4dce:	82 95       	swap	r24
    4dd0:	81 70       	andi	r24, 0x01	; 1
    4dd2:	80 27       	eor	r24, r16
    4dd4:	18 0f       	add	r17, r24
    4dd6:	20 95       	com	r18
    4dd8:	22 1f       	adc	r18, r18
    4dda:	22 27       	eor	r18, r18
    4ddc:	22 1f       	adc	r18, r18
    4dde:	12 0f       	add	r17, r18
    4de0:	92 95       	swap	r25
    4de2:	91 70       	andi	r25, 0x01	; 1
    4de4:	90 27       	eor	r25, r16
    4de6:	19 0f       	add	r17, r25
    4de8:	54 d4       	rcall	.+2216   	; 0x5692 <getHallState>
    4dea:	81 0f       	add	r24, r17
				
					if (parity & 1){  //if first bit of parity is 1, then an odd number of sensors are active.
    4dec:	80 ff       	sbrs	r24, 0
    4dee:	03 c0       	rjmp	.+6      	; 0x4df6 <main+0x10e>
						set_high(LED1);
    4df0:	46 9a       	sbi	0x08, 6	; 8
						set_low(LED2);
    4df2:	2e 98       	cbi	0x05, 6	; 5
    4df4:	02 c0       	rjmp	.+4      	; 0x4dfa <main+0x112>
					}
					else{ //otherwise, an even number (or zero) are active.
						set_low(LED1);
    4df6:	46 98       	cbi	0x08, 6	; 8
						set_high(LED2);
    4df8:	2e 9a       	sbi	0x05, 6	; 5
    4dfa:	8f ec       	ldi	r24, 0xCF	; 207
    4dfc:	97 e0       	ldi	r25, 0x07	; 7
    4dfe:	01 97       	sbiw	r24, 0x01	; 1
    4e00:	f1 f7       	brne	.-4      	; 0x4dfe <main+0x116>
    4e02:	00 c0       	rjmp	.+0      	; 0x4e04 <main+0x11c>
    4e04:	00 00       	nop
    4e06:	d9 cf       	rjmp	.-78     	; 0x4dba <main+0xd2>
					}
					Delay_MS(SENSE_DELAY);
				}
			break;
			case HARDWARE_TEST:				
				USB_Disable(); //make sure no host is connected before accessing SD card.
    4e08:	0e 94 ae 32 	call	0x655c	; 0x655c <USB_Disable>
				TestSDHardware();
    4e0c:	0e 94 8a 0c 	call	0x1914	; 0x1914 <TestSDHardware>
			case SD_MODE:
				if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
    4e10:	80 91 37 06 	lds	r24, 0x0637
    4e14:	88 23       	and	r24, r24
    4e16:	11 f0       	breq	.+4      	; 0x4e1c <main+0x134>
    4e18:	5d 98       	cbi	0x0b, 5	; 11
    4e1a:	55 9a       	sbi	0x0a, 5	; 10
				USB_Disable(); //make sure no host is connected before accessing SD card.
    4e1c:	0e 94 ae 32 	call	0x655c	; 0x655c <USB_Disable>
				LogKeystrokes();
    4e20:	0e 94 fa 0c 	call	0x19f4	; 0x19f4 <LogKeystrokes>
			break;
    4e24:	77 cf       	rjmp	.-274    	; 0x4d14 <main+0x2c>
			case CAL_MODE:
				Calibrate();
				Typewriter_Mode = USB_LIGHT_MODE; //after calibrating, go to usb light mode.
			break;
			case QUICK_CAL_MODE:
				QuickCalibrate();
    4e26:	0e 94 89 06 	call	0xd12	; 0xd12 <QuickCalibrate>
    4e2a:	50 c0       	rjmp	.+160    	; 0x4ecc <main+0x1e4>
				Calibrate_Manually();
				Typewriter_Mode = USB_LIGHT_MODE;
			break;
			case BLUETOOTH_MODE:
				#ifndef BT_DEBUG
					USB_Disable();//don't disable usb if it is debug mode.
    4e2c:	0e 94 ae 32 	call	0x655c	; 0x655c <USB_Disable>
				#endif
				if(Get_Bluetooth_State() != INITIALIZED){Bluetooth_Init();};//initialize bluetooth if it hasn't been already.
    4e30:	0e 94 88 04 	call	0x910	; 0x910 <Get_Bluetooth_State>
    4e34:	81 30       	cpi	r24, 0x01	; 1
    4e36:	11 f0       	breq	.+4      	; 0x4e3c <main+0x154>
    4e38:	0e 94 38 04 	call	0x870	; 0x870 <Bluetooth_Init>
				if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
    4e3c:	80 91 37 06 	lds	r24, 0x0637
    4e40:	88 23       	and	r24, r24
    4e42:	11 f0       	breq	.+4      	; 0x4e48 <main+0x160>
    4e44:	5d 98       	cbi	0x0b, 5	; 11
    4e46:	55 9a       	sbi	0x0a, 5	; 10
				
				while(is_low(BT_CONNECTED)){
    4e48:	79 99       	sbic	0x0f, 1	; 15
    4e4a:	0e c0       	rjmp	.+28     	; 0x4e68 <main+0x180>
					set_low(RED_LED);
    4e4c:	2e 98       	cbi	0x05, 6	; 5
					set_high(GREEN_LED);
    4e4e:	46 9a       	sbi	0x08, 6	; 8
					Bluetooth_Connect();
    4e50:	0e 94 8b 04 	call	0x916	; 0x916 <Bluetooth_Connect>
    4e54:	9f ef       	ldi	r25, 0xFF	; 255
    4e56:	27 ea       	ldi	r18, 0xA7	; 167
    4e58:	81 e6       	ldi	r24, 0x61	; 97
    4e5a:	91 50       	subi	r25, 0x01	; 1
    4e5c:	20 40       	sbci	r18, 0x00	; 0
    4e5e:	80 40       	sbci	r24, 0x00	; 0
    4e60:	e1 f7       	brne	.-8      	; 0x4e5a <main+0x172>
    4e62:	00 c0       	rjmp	.+0      	; 0x4e64 <main+0x17c>
    4e64:	00 00       	nop
    4e66:	f0 cf       	rjmp	.-32     	; 0x4e48 <main+0x160>
					Delay_MS(4000);					
				}//wait for connection to happen, glow red until then.
				
				set_high(RED_LED);//turn off red led if bt is connected.
    4e68:	2e 9a       	sbi	0x05, 6	; 5
				set_low(GREEN_LED);
    4e6a:	46 98       	cbi	0x08, 6	; 8
				while(is_high(BT_CONNECTED)){
    4e6c:	79 9b       	sbis	0x0f, 1	; 15
    4e6e:	52 cf       	rjmp	.-348    	; 0x4d14 <main+0x2c>
					key = GetKey();
    4e70:	a1 d2       	rcall	.+1346   	; 0x53b4 <GetKey>
    4e72:	f8 2e       	mov	r15, r24
					modifier = GetModifier();
    4e74:	95 d1       	rcall	.+810    	; 0x51a0 <GetModifier>
    4e76:	89 83       	std	Y+1, r24	; 0x01
									
					code = GetHIDKeyCode(key, &modifier);
    4e78:	be 01       	movw	r22, r28
    4e7a:	6f 5f       	subi	r22, 0xFF	; 255
    4e7c:	7f 4f       	sbci	r23, 0xFF	; 255
    4e7e:	8f 2d       	mov	r24, r15
    4e80:	d7 d3       	rcall	.+1966   	; 0x5630 <GetHIDKeyCode>
					
					if(code){Bluetooth_Send(code,modifier);}
    4e82:	88 23       	and	r24, r24
    4e84:	19 f0       	breq	.+6      	; 0x4e8c <main+0x1a4>
    4e86:	69 81       	ldd	r22, Y+1	; 0x01
    4e88:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <Bluetooth_Send>
    4e8c:	8f ec       	ldi	r24, 0xCF	; 207
    4e8e:	97 e0       	ldi	r25, 0x07	; 7
    4e90:	01 97       	sbiw	r24, 0x01	; 1
    4e92:	f1 f7       	brne	.-4      	; 0x4e90 <main+0x1a8>
    4e94:	00 c0       	rjmp	.+0      	; 0x4e96 <main+0x1ae>
    4e96:	00 00       	nop
    4e98:	e9 cf       	rjmp	.-46     	; 0x4e6c <main+0x184>
				}
			break;
			case PANIC_MODE:
				USB_Disable();
				while(1){
					set_high(LED2);
    4e9a:	2e 9a       	sbi	0x05, 6	; 5
					set_low(LED1);
    4e9c:	46 98       	cbi	0x08, 6	; 8
    4e9e:	9f ef       	ldi	r25, 0xFF	; 255
    4ea0:	21 ee       	ldi	r18, 0xE1	; 225
    4ea2:	84 e0       	ldi	r24, 0x04	; 4
    4ea4:	91 50       	subi	r25, 0x01	; 1
    4ea6:	20 40       	sbci	r18, 0x00	; 0
    4ea8:	80 40       	sbci	r24, 0x00	; 0
    4eaa:	e1 f7       	brne	.-8      	; 0x4ea4 <main+0x1bc>
    4eac:	00 c0       	rjmp	.+0      	; 0x4eae <main+0x1c6>
    4eae:	00 00       	nop
					Delay_MS(200);
					set_high(LED1);
    4eb0:	46 9a       	sbi	0x08, 6	; 8
					set_low(LED2);
    4eb2:	2e 98       	cbi	0x05, 6	; 5
    4eb4:	9f ef       	ldi	r25, 0xFF	; 255
    4eb6:	21 ee       	ldi	r18, 0xE1	; 225
    4eb8:	84 e0       	ldi	r24, 0x04	; 4
    4eba:	91 50       	subi	r25, 0x01	; 1
    4ebc:	20 40       	sbci	r18, 0x00	; 0
    4ebe:	80 40       	sbci	r24, 0x00	; 0
    4ec0:	e1 f7       	brne	.-8      	; 0x4eba <main+0x1d2>
    4ec2:	00 c0       	rjmp	.+0      	; 0x4ec4 <main+0x1dc>
    4ec4:	00 00       	nop
    4ec6:	e9 cf       	rjmp	.-46     	; 0x4e9a <main+0x1b2>
					Delay_MS(200);
				}		
			break;
			case SENSITIVITY_MODE:
				Adjust_Sensitivity();
    4ec8:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <Adjust_Sensitivity>
				Typewriter_Mode = USB_LIGHT_MODE;
    4ecc:	10 93 89 07 	sts	0x0789, r17
			break;
    4ed0:	21 cf       	rjmp	.-446    	; 0x4d14 <main+0x2c>
			default:
				Typewriter_Mode = PANIC_MODE;
    4ed2:	00 93 89 07 	sts	0x0789, r16
			break;
    4ed6:	1e cf       	rjmp	.-452    	; 0x4d14 <main+0x2c>

00004ed8 <USBSend>:
#include <ctype.h> // allows toupper()

extern USB_ClassInfo_HID_Device_t Keyboard_HID_Interface; //import the keyboard interface object from main routine so we can call usbtask on it.

/*Send a character over usb with a given modifier (shift, ctrl, etc)*/
void USBSend(uint8_t code,uint8_t mod){	
    4ed8:	1f 93       	push	r17
    4eda:	cf 93       	push	r28
    4edc:	df 93       	push	r29
    4ede:	1f 92       	push	r1
    4ee0:	cd b7       	in	r28, 0x3d	; 61
    4ee2:	de b7       	in	r29, 0x3e	; 62
    4ee4:	18 2f       	mov	r17, r24
	
	TMR1_Count = 0;
    4ee6:	10 92 80 06 	sts	0x0680, r1
    4eea:	10 92 7f 06 	sts	0x067F, r1
	while (KeyBuffer->KeyCode[0] && TMR1_Count < USB_SEND_TIMEOUT) {
    4eee:	e0 91 84 06 	lds	r30, 0x0684
    4ef2:	f0 91 85 06 	lds	r31, 0x0685
    4ef6:	82 81       	ldd	r24, Z+2	; 0x02
    4ef8:	88 23       	and	r24, r24
    4efa:	a9 f0       	breq	.+42     	; 0x4f26 <USBSend+0x4e>
    4efc:	80 91 7f 06 	lds	r24, 0x067F
    4f00:	90 91 80 06 	lds	r25, 0x0680
    4f04:	84 36       	cpi	r24, 0x64	; 100
    4f06:	91 05       	cpc	r25, r1
    4f08:	70 f4       	brcc	.+28     	; 0x4f26 <USBSend+0x4e>
		if((Typewriter_Mode == USB_COMBO_MODE) || (Typewriter_Mode == USB_LIGHT_MODE)){ //interrupts do not handle keyboard stuff during this mode.
    4f0a:	80 91 89 07 	lds	r24, 0x0789
    4f0e:	81 30       	cpi	r24, 0x01	; 1
    4f10:	21 f0       	breq	.+8      	; 0x4f1a <USBSend+0x42>
    4f12:	80 91 89 07 	lds	r24, 0x0789
    4f16:	8d 30       	cpi	r24, 0x0D	; 13
    4f18:	51 f7       	brne	.-44     	; 0x4eee <USBSend+0x16>
			HID_Device_USBTask(&Keyboard_HID_Interface);
    4f1a:	84 e4       	ldi	r24, 0x44	; 68
    4f1c:	91 e0       	ldi	r25, 0x01	; 1
    4f1e:	69 83       	std	Y+1, r22	; 0x01
    4f20:	eb d5       	rcall	.+3030   	; 0x5af8 <HID_Device_USBTask>
    4f22:	69 81       	ldd	r22, Y+1	; 0x01
    4f24:	e4 cf       	rjmp	.-56     	; 0x4eee <USBSend+0x16>
		} //if buffer is full, wait.  If timeout expires, stop waiting.
	}
	
	if (code&FORCE_UPPER){ //in this program, we use the MSB of code to indicate that this key MUST be sent as upper case.
    4f26:	17 ff       	sbrs	r17, 7
    4f28:	02 c0       	rjmp	.+4      	; 0x4f2e <USBSend+0x56>
		reg_clr(code,FORCE_UPPER); //clear the MSB,  
    4f2a:	1f 77       	andi	r17, 0x7F	; 127
		mod = UPPER; //and set the modifier to upper case.
    4f2c:	62 e0       	ldi	r22, 0x02	; 2
	}
	
	if(code == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
    4f2e:	14 37       	cpi	r17, 0x74	; 116
    4f30:	11 f4       	brne	.+4      	; 0x4f36 <USBSend+0x5e>
		code = KEY_ENTER;
		mod = HID_KEYBOARD_MODIFIER_LEFTCTRL;
    4f32:	61 e0       	ldi	r22, 0x01	; 1
		reg_clr(code,FORCE_UPPER); //clear the MSB,  
		mod = UPPER; //and set the modifier to upper case.
	}
	
	if(code == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
		code = KEY_ENTER;
    4f34:	18 e2       	ldi	r17, 0x28	; 40
		mod = HID_KEYBOARD_MODIFIER_LEFTCTRL;
	}
	
	cli();//make sure there are no interrupts between setting code and setting the modifier that goes with it.
    4f36:	f8 94       	cli
	KeyBuffer->KeyCode[0] = code; //cue up keycode to be sent during next LUFA HID callback function.
    4f38:	e0 91 84 06 	lds	r30, 0x0684
    4f3c:	f0 91 85 06 	lds	r31, 0x0685
    4f40:	12 83       	std	Z+2, r17	; 0x02
	KeyBufferMod = mod;
    4f42:	60 93 3b 06 	sts	0x063B, r22
	HID_Device_USBTask(&Keyboard_HID_Interface); //Dean Camera says to call this function regularly -- right after sending a character seems like an appropriate time.
    4f46:	84 e4       	ldi	r24, 0x44	; 68
    4f48:	91 e0       	ldi	r25, 0x01	; 1
    4f4a:	d6 d5       	rcall	.+2988   	; 0x5af8 <HID_Device_USBTask>
	sei();//re-enable the interrupts.
    4f4c:	78 94       	sei
    4f4e:	8f e3       	ldi	r24, 0x3F	; 63
    4f50:	9c e9       	ldi	r25, 0x9C	; 156
    4f52:	01 97       	sbiw	r24, 0x01	; 1
    4f54:	f1 f7       	brne	.-4      	; 0x4f52 <USBSend+0x7a>
    4f56:	00 c0       	rjmp	.+0      	; 0x4f58 <USBSend+0x80>
    4f58:	00 00       	nop
	
	Delay_MS(USB_SEND_DELAY);// wait X ms after sending each character.
	
	cli();//make sure no interrupts occur during the usb task.
    4f5a:	f8 94       	cli
	HID_Device_USBTask(&Keyboard_HID_Interface); //do LUFA hid usb tasks
    4f5c:	84 e4       	ldi	r24, 0x44	; 68
    4f5e:	91 e0       	ldi	r25, 0x01	; 1
    4f60:	cb d5       	rcall	.+2966   	; 0x5af8 <HID_Device_USBTask>
	sei();
    4f62:	78 94       	sei
}
    4f64:	0f 90       	pop	r0
    4f66:	df 91       	pop	r29
    4f68:	cf 91       	pop	r28
    4f6a:	1f 91       	pop	r17
    4f6c:	08 95       	ret

00004f6e <USBSendString>:

/*Send a string over USB. Only supports some characters.*/
void USBSendString(char *str){
    4f6e:	ef 92       	push	r14
    4f70:	ff 92       	push	r15
    4f72:	0f 93       	push	r16
    4f74:	1f 93       	push	r17
    4f76:	cf 93       	push	r28
    4f78:	df 93       	push	r29
    4f7a:	8c 01       	movw	r16, r24
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
    4f7c:	fc 01       	movw	r30, r24
    4f7e:	01 90       	ld	r0, Z+
    4f80:	00 20       	and	r0, r0
    4f82:	e9 f7       	brne	.-6      	; 0x4f7e <USBSendString+0x10>
    4f84:	31 97       	sbiw	r30, 0x01	; 1
    4f86:	ef 01       	movw	r28, r30
    4f88:	c8 1b       	sub	r28, r24
    4f8a:	d9 0b       	sbc	r29, r25
	for (int i=0; i<length; i++){
    4f8c:	7c 01       	movw	r14, r24
    4f8e:	c7 01       	movw	r24, r14
    4f90:	80 1b       	sub	r24, r16
    4f92:	91 0b       	sbc	r25, r17
    4f94:	8c 17       	cp	r24, r28
    4f96:	9d 07       	cpc	r25, r29
    4f98:	0c f0       	brlt	.+2      	; 0x4f9c <USBSendString+0x2e>
    4f9a:	53 c0       	rjmp	.+166    	; 0x5042 <USBSendString+0xd4>
		modifier = LOWER;
		if(str[i] == ' '){
    4f9c:	f7 01       	movw	r30, r14
    4f9e:	91 91       	ld	r25, Z+
    4fa0:	7f 01       	movw	r14, r30
    4fa2:	90 32       	cpi	r25, 0x20	; 32
    4fa4:	29 f1       	breq	.+74     	; 0x4ff0 <USBSendString+0x82>
			code = KEY_SPACE;
		}
		else if(str[i] == '('){
    4fa6:	98 32       	cpi	r25, 0x28	; 40
    4fa8:	31 f1       	breq	.+76     	; 0x4ff6 <USBSendString+0x88>
			code = KEY_9;
			modifier = UPPER;
		}
		else if(str[i] == ')'){
    4faa:	99 32       	cpi	r25, 0x29	; 41
    4fac:	39 f1       	breq	.+78     	; 0x4ffc <USBSendString+0x8e>
			code = KEY_0;
			modifier = UPPER;
		}
		else if(str[i] == '/'){
    4fae:	9f 32       	cpi	r25, 0x2F	; 47
    4fb0:	39 f1       	breq	.+78     	; 0x5000 <USBSendString+0x92>
			code = KEY_SLASH;
		}
		else if(str[i] == '?'){
    4fb2:	9f 33       	cpi	r25, 0x3F	; 63
    4fb4:	39 f1       	breq	.+78     	; 0x5004 <USBSendString+0x96>
			code = KEY_SLASH;
			modifier = UPPER;
		}
		else if(str[i] == ':'){
    4fb6:	9a 33       	cpi	r25, 0x3A	; 58
    4fb8:	41 f1       	breq	.+80     	; 0x500a <USBSendString+0x9c>
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
    4fba:	9d 30       	cpi	r25, 0x0D	; 13
    4fbc:	49 f1       	breq	.+82     	; 0x5010 <USBSendString+0xa2>
    4fbe:	9a 30       	cpi	r25, 0x0A	; 10
    4fc0:	39 f1       	breq	.+78     	; 0x5010 <USBSendString+0xa2>
			code = KEY_ENTER;
		}
		else if(str[i] == '.'){
    4fc2:	9e 32       	cpi	r25, 0x2E	; 46
    4fc4:	41 f1       	breq	.+80     	; 0x5016 <USBSendString+0xa8>
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if(str[i] == '='){
    4fc6:	9d 33       	cpi	r25, 0x3D	; 61
    4fc8:	49 f1       	breq	.+82     	; 0x501c <USBSendString+0xae>
			code = KEY_EQ;
			modifier = LOWER;
		}
		else if(str[i] == '!'){
    4fca:	91 32       	cpi	r25, 0x21	; 33
    4fcc:	51 f1       	breq	.+84     	; 0x5022 <USBSendString+0xb4>
			code = KEY_1;
			modifier = UPPER;
		}
		else if(str[i] == '0'){
    4fce:	90 33       	cpi	r25, 0x30	; 48
    4fd0:	59 f1       	breq	.+86     	; 0x5028 <USBSendString+0xba>
			code = KEY_0;
		}
		else if((str[i] >= ASCII_1 )&&(str[i] <= ASCII_9)){
    4fd2:	8f ec       	ldi	r24, 0xCF	; 207
    4fd4:	89 0f       	add	r24, r25
    4fd6:	89 30       	cpi	r24, 0x09	; 9
    4fd8:	20 f4       	brcc	.+8      	; 0x4fe2 <USBSendString+0x74>
			code = str[i] - ASCII_1 + KEY_1; //translate ascii to hid number code 
    4fda:	8d ee       	ldi	r24, 0xED	; 237
    4fdc:	89 0f       	add	r24, r25
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    4fde:	60 e0       	ldi	r22, 0x00	; 0
    4fe0:	25 c0       	rjmp	.+74     	; 0x502c <USBSendString+0xbe>
		}
		else if((str[i] >= ASCII_1 )&&(str[i] <= ASCII_9)){
			code = str[i] - ASCII_1 + KEY_1; //translate ascii to hid number code 
		}
		else{
			code = toupper(str[i]);//make sure code is uppercase.
    4fe2:	89 2f       	mov	r24, r25
    4fe4:	90 e0       	ldi	r25, 0x00	; 0
    4fe6:	0e 94 2d 36 	call	0x6c5a	; 0x6c5a <toupper>
			code = code-ASCII_A+KEY_A;  //Convert the character (which is uppercase Ascii)  to an USB HID Keycode.
    4fea:	8d 53       	subi	r24, 0x3D	; 61
			modifier = UPPER;
    4fec:	62 e0       	ldi	r22, 0x02	; 2
    4fee:	1e c0       	rjmp	.+60     	; 0x502c <USBSendString+0xbe>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    4ff0:	60 e0       	ldi	r22, 0x00	; 0
		if(str[i] == ' '){
			code = KEY_SPACE;
    4ff2:	8c e2       	ldi	r24, 0x2C	; 44
    4ff4:	1b c0       	rjmp	.+54     	; 0x502c <USBSendString+0xbe>
		}
		else if(str[i] == '('){
			code = KEY_9;
			modifier = UPPER;
    4ff6:	62 e0       	ldi	r22, 0x02	; 2
		modifier = LOWER;
		if(str[i] == ' '){
			code = KEY_SPACE;
		}
		else if(str[i] == '('){
			code = KEY_9;
    4ff8:	86 e2       	ldi	r24, 0x26	; 38
    4ffa:	18 c0       	rjmp	.+48     	; 0x502c <USBSendString+0xbe>
			modifier = UPPER;
		}
		else if(str[i] == ')'){
			code = KEY_0;
			modifier = UPPER;
    4ffc:	62 e0       	ldi	r22, 0x02	; 2
    4ffe:	15 c0       	rjmp	.+42     	; 0x502a <USBSendString+0xbc>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5000:	60 e0       	ldi	r22, 0x00	; 0
    5002:	01 c0       	rjmp	.+2      	; 0x5006 <USBSendString+0x98>
		else if(str[i] == '/'){
			code = KEY_SLASH;
		}
		else if(str[i] == '?'){
			code = KEY_SLASH;
			modifier = UPPER;
    5004:	62 e0       	ldi	r22, 0x02	; 2
		}
		else if(str[i] == '/'){
			code = KEY_SLASH;
		}
		else if(str[i] == '?'){
			code = KEY_SLASH;
    5006:	88 e3       	ldi	r24, 0x38	; 56
    5008:	11 c0       	rjmp	.+34     	; 0x502c <USBSendString+0xbe>
			modifier = UPPER;
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
    500a:	62 e0       	ldi	r22, 0x02	; 2
		else if(str[i] == '?'){
			code = KEY_SLASH;
			modifier = UPPER;
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
    500c:	83 e3       	ldi	r24, 0x33	; 51
    500e:	0e c0       	rjmp	.+28     	; 0x502c <USBSendString+0xbe>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5010:	60 e0       	ldi	r22, 0x00	; 0
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
			code = KEY_ENTER;
    5012:	88 e2       	ldi	r24, 0x28	; 40
    5014:	0b c0       	rjmp	.+22     	; 0x502c <USBSendString+0xbe>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5016:	60 e0       	ldi	r22, 0x00	; 0
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
			code = KEY_ENTER;
		}
		else if(str[i] == '.'){
			code = KEY_PERIOD;
    5018:	87 e3       	ldi	r24, 0x37	; 55
    501a:	08 c0       	rjmp	.+16     	; 0x502c <USBSendString+0xbe>
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if(str[i] == '='){
			code = KEY_EQ;
			modifier = LOWER;
    501c:	60 e0       	ldi	r22, 0x00	; 0
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if(str[i] == '='){
			code = KEY_EQ;
    501e:	8e e2       	ldi	r24, 0x2E	; 46
    5020:	05 c0       	rjmp	.+10     	; 0x502c <USBSendString+0xbe>
			modifier = LOWER;
		}
		else if(str[i] == '!'){
			code = KEY_1;
			modifier = UPPER;
    5022:	62 e0       	ldi	r22, 0x02	; 2
		else if(str[i] == '='){
			code = KEY_EQ;
			modifier = LOWER;
		}
		else if(str[i] == '!'){
			code = KEY_1;
    5024:	8e e1       	ldi	r24, 0x1E	; 30
    5026:	02 c0       	rjmp	.+4      	; 0x502c <USBSendString+0xbe>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5028:	60 e0       	ldi	r22, 0x00	; 0
		else if(str[i] == '!'){
			code = KEY_1;
			modifier = UPPER;
		}
		else if(str[i] == '0'){
			code = KEY_0;
    502a:	87 e2       	ldi	r24, 0x27	; 39
		else{
			code = toupper(str[i]);//make sure code is uppercase.
			code = code-ASCII_A+KEY_A;  //Convert the character (which is uppercase Ascii)  to an USB HID Keycode.
			modifier = UPPER;
		}
		USBSend(code,modifier);
    502c:	55 df       	rcall	.-342    	; 0x4ed8 <USBSend>
    502e:	ff e7       	ldi	r31, 0x7F	; 127
    5030:	28 e3       	ldi	r18, 0x38	; 56
    5032:	81 e0       	ldi	r24, 0x01	; 1
    5034:	f1 50       	subi	r31, 0x01	; 1
    5036:	20 40       	sbci	r18, 0x00	; 0
    5038:	80 40       	sbci	r24, 0x00	; 0
    503a:	e1 f7       	brne	.-8      	; 0x5034 <USBSendString+0xc6>
    503c:	00 c0       	rjmp	.+0      	; 0x503e <USBSendString+0xd0>
    503e:	00 00       	nop
    5040:	a6 cf       	rjmp	.-180    	; 0x4f8e <USBSendString+0x20>
		Delay_MS(STRING_SEND_DELAY);
	}
} 
    5042:	df 91       	pop	r29
    5044:	cf 91       	pop	r28
    5046:	1f 91       	pop	r17
    5048:	0f 91       	pop	r16
    504a:	ff 90       	pop	r15
    504c:	ef 90       	pop	r14
    504e:	08 95       	ret

00005050 <USBSendPROGString>:

/*Send a string literal to Bluetooth Module, using a string stored in program memory instead of data memory (this saves RAM)*/
void USBSendPROGString(const char*  ProgStr){
	strcpy_P(StringBuffer, (char*) ProgStr);
    5050:	bc 01       	movw	r22, r24
    5052:	8c e0       	ldi	r24, 0x0C	; 12
    5054:	97 e0       	ldi	r25, 0x07	; 7
    5056:	0e 94 35 36 	call	0x6c6a	; 0x6c6a <strcpy_P>
	USBSendString(StringBuffer);
    505a:	8c e0       	ldi	r24, 0x0C	; 12
    505c:	97 e0       	ldi	r25, 0x07	; 7
    505e:	87 cf       	rjmp	.-242    	; 0x4f6e <USBSendString>

00005060 <USBSendNumber>:
}

/*Send a number between 0 and 255 over usb)*/
void USBSendNumber(uint8_t number){
    5060:	1f 93       	push	r17
    5062:	cf 93       	push	r28
    5064:	df 93       	push	r29
    5066:	28 2f       	mov	r18, r24
	uint8_t ones ;
	uint8_t tens;
	
	ones = number%10;
    5068:	6a e0       	ldi	r22, 0x0A	; 10
    506a:	0e 94 5b 35 	call	0x6ab6	; 0x6ab6 <__udivmodqi4>
    506e:	c9 2f       	mov	r28, r25
	tens = ((number - ones)%100)/10;
    5070:	82 2f       	mov	r24, r18
    5072:	90 e0       	ldi	r25, 0x00	; 0
    5074:	8c 1b       	sub	r24, r28
    5076:	91 09       	sbc	r25, r1
    5078:	64 e6       	ldi	r22, 0x64	; 100
    507a:	70 e0       	ldi	r23, 0x00	; 0
    507c:	0e 94 67 35 	call	0x6ace	; 0x6ace <__divmodhi4>
    5080:	6a e0       	ldi	r22, 0x0A	; 10
    5082:	70 e0       	ldi	r23, 0x00	; 0
    5084:	0e 94 67 35 	call	0x6ace	; 0x6ace <__divmodhi4>
    5088:	d6 2f       	mov	r29, r22
    508a:	16 2f       	mov	r17, r22
	
	if (number >= 200){
    508c:	28 3c       	cpi	r18, 0xC8	; 200
    508e:	18 f0       	brcs	.+6      	; 0x5096 <USBSendNumber+0x36>
		USBSend(KEY_2,LOWER);
    5090:	60 e0       	ldi	r22, 0x00	; 0
    5092:	8f e1       	ldi	r24, 0x1F	; 31
    5094:	04 c0       	rjmp	.+8      	; 0x509e <USBSendNumber+0x3e>
	}
	else if (number >= 100){
    5096:	24 36       	cpi	r18, 0x64	; 100
    5098:	18 f0       	brcs	.+6      	; 0x50a0 <USBSendNumber+0x40>
		USBSend(KEY_1,LOWER);
    509a:	60 e0       	ldi	r22, 0x00	; 0
    509c:	8e e1       	ldi	r24, 0x1E	; 30
    509e:	1c df       	rcall	.-456    	; 0x4ed8 <USBSend>
	}
	
	if (tens != 0){
		USBSend(29+tens,LOWER);
    50a0:	60 e0       	ldi	r22, 0x00	; 0
	}
	else if (number >= 100){
		USBSend(KEY_1,LOWER);
	}
	
	if (tens != 0){
    50a2:	11 23       	and	r17, r17
    50a4:	19 f0       	breq	.+6      	; 0x50ac <USBSendNumber+0x4c>
		USBSend(29+tens,LOWER);
    50a6:	8d e1       	ldi	r24, 0x1D	; 29
    50a8:	8d 0f       	add	r24, r29
    50aa:	01 c0       	rjmp	.+2      	; 0x50ae <USBSendNumber+0x4e>
	}
	else{
		USBSend(39,LOWER);
    50ac:	87 e2       	ldi	r24, 0x27	; 39
    50ae:	14 df       	rcall	.-472    	; 0x4ed8 <USBSend>
    50b0:	2f ef       	ldi	r18, 0xFF	; 255
    50b2:	80 e7       	ldi	r24, 0x70	; 112
    50b4:	92 e0       	ldi	r25, 0x02	; 2
    50b6:	21 50       	subi	r18, 0x01	; 1
    50b8:	80 40       	sbci	r24, 0x00	; 0
    50ba:	90 40       	sbci	r25, 0x00	; 0
    50bc:	e1 f7       	brne	.-8      	; 0x50b6 <USBSendNumber+0x56>
    50be:	00 c0       	rjmp	.+0      	; 0x50c0 <USBSendNumber+0x60>
    50c0:	00 00       	nop
	}

	Delay_MS(100);
	
	if (ones!=0){
		USBSend(29+ones,LOWER);
    50c2:	60 e0       	ldi	r22, 0x00	; 0
		USBSend(39,LOWER);
	}

	Delay_MS(100);
	
	if (ones!=0){
    50c4:	cc 23       	and	r28, r28
    50c6:	19 f0       	breq	.+6      	; 0x50ce <USBSendNumber+0x6e>
		USBSend(29+ones,LOWER);
    50c8:	8d e1       	ldi	r24, 0x1D	; 29
    50ca:	8c 0f       	add	r24, r28
    50cc:	01 c0       	rjmp	.+2      	; 0x50d0 <USBSendNumber+0x70>
	}
	else{
		USBSend(39,LOWER);
    50ce:	87 e2       	ldi	r24, 0x27	; 39
    50d0:	03 df       	rcall	.-506    	; 0x4ed8 <USBSend>
    50d2:	2f ef       	ldi	r18, 0xFF	; 255
    50d4:	80 e7       	ldi	r24, 0x70	; 112
    50d6:	92 e0       	ldi	r25, 0x02	; 2
    50d8:	21 50       	subi	r18, 0x01	; 1
    50da:	80 40       	sbci	r24, 0x00	; 0
    50dc:	90 40       	sbci	r25, 0x00	; 0
    50de:	e1 f7       	brne	.-8      	; 0x50d8 <USBSendNumber+0x78>
    50e0:	00 c0       	rjmp	.+0      	; 0x50e2 <USBSendNumber+0x82>
    50e2:	00 00       	nop
	}
	
	Delay_MS(100);

}
    50e4:	df 91       	pop	r29
    50e6:	cf 91       	pop	r28
    50e8:	1f 91       	pop	r17
    50ea:	08 95       	ret

000050ec <USBSendASCII>:

/*Send an ascii character between 0 and 255 over usb)*/
void USBSendASCII(uint8_t number){
    50ec:	0f 93       	push	r16
    50ee:	1f 93       	push	r17
    50f0:	cf 93       	push	r28
    50f2:	df 93       	push	r29
    50f4:	c8 2f       	mov	r28, r24
	uint8_t ones ;
	uint8_t tens;
	
	ones = number%10;
    50f6:	6a e0       	ldi	r22, 0x0A	; 10
    50f8:	0e 94 5b 35 	call	0x6ab6	; 0x6ab6 <__udivmodqi4>
    50fc:	d9 2f       	mov	r29, r25
	tens = ((number - ones)%100)/10;
    50fe:	8c 2f       	mov	r24, r28
    5100:	90 e0       	ldi	r25, 0x00	; 0
    5102:	8d 1b       	sub	r24, r29
    5104:	91 09       	sbc	r25, r1
    5106:	64 e6       	ldi	r22, 0x64	; 100
    5108:	70 e0       	ldi	r23, 0x00	; 0
    510a:	0e 94 67 35 	call	0x6ace	; 0x6ace <__divmodhi4>
    510e:	6a e0       	ldi	r22, 0x0A	; 10
    5110:	70 e0       	ldi	r23, 0x00	; 0
    5112:	0e 94 67 35 	call	0x6ace	; 0x6ace <__divmodhi4>
    5116:	16 2f       	mov	r17, r22
    5118:	06 2f       	mov	r16, r22
	
	Hold_Alt_Down = true; //hold down the alt key
    511a:	81 e0       	ldi	r24, 0x01	; 1
    511c:	80 93 87 06 	sts	0x0687, r24
    5120:	2f ef       	ldi	r18, 0xFF	; 255
    5122:	80 e7       	ldi	r24, 0x70	; 112
    5124:	92 e0       	ldi	r25, 0x02	; 2
    5126:	21 50       	subi	r18, 0x01	; 1
    5128:	80 40       	sbci	r24, 0x00	; 0
    512a:	90 40       	sbci	r25, 0x00	; 0
    512c:	e1 f7       	brne	.-8      	; 0x5126 <USBSendASCII+0x3a>
    512e:	00 c0       	rjmp	.+0      	; 0x5130 <USBSendASCII+0x44>
    5130:	00 00       	nop
	
	Delay_MS(100);
	
	USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT, LOWER); //send a leading 0
    5132:	60 e0       	ldi	r22, 0x00	; 0
    5134:	82 e6       	ldi	r24, 0x62	; 98
    5136:	d0 de       	rcall	.-608    	; 0x4ed8 <USBSend>
	
	//send hundreds digit
	if (number >= 200){  
		USBSend(HID_KEYBOARD_SC_KEYPAD_2_AND_DOWN_ARROW,LOWER);
    5138:	60 e0       	ldi	r22, 0x00	; 0
	Delay_MS(100);
	
	USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT, LOWER); //send a leading 0
	
	//send hundreds digit
	if (number >= 200){  
    513a:	c8 3c       	cpi	r28, 0xC8	; 200
    513c:	10 f0       	brcs	.+4      	; 0x5142 <USBSendASCII+0x56>
		USBSend(HID_KEYBOARD_SC_KEYPAD_2_AND_DOWN_ARROW,LOWER);
    513e:	8a e5       	ldi	r24, 0x5A	; 90
    5140:	05 c0       	rjmp	.+10     	; 0x514c <USBSendASCII+0x60>
	}
	else if (number >= 100){
    5142:	c4 36       	cpi	r28, 0x64	; 100
    5144:	10 f0       	brcs	.+4      	; 0x514a <USBSendASCII+0x5e>
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END, LOWER);
    5146:	89 e5       	ldi	r24, 0x59	; 89
    5148:	01 c0       	rjmp	.+2      	; 0x514c <USBSendASCII+0x60>
	}
	else{
		USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT, LOWER);
    514a:	82 e6       	ldi	r24, 0x62	; 98
    514c:	c5 de       	rcall	.-630    	; 0x4ed8 <USBSend>
	}
	
	//send tens digit
	if (tens != 0){
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END + tens,LOWER); //send 1-9
    514e:	60 e0       	ldi	r22, 0x00	; 0
	else{
		USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT, LOWER);
	}
	
	//send tens digit
	if (tens != 0){
    5150:	00 23       	and	r16, r16
    5152:	19 f0       	breq	.+6      	; 0x515a <USBSendASCII+0x6e>
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END + tens,LOWER); //send 1-9
    5154:	89 e5       	ldi	r24, 0x59	; 89
    5156:	81 0f       	add	r24, r17
    5158:	01 c0       	rjmp	.+2      	; 0x515c <USBSendASCII+0x70>
	}
	else{
		USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT,LOWER); //send 0
    515a:	82 e6       	ldi	r24, 0x62	; 98
    515c:	bd de       	rcall	.-646    	; 0x4ed8 <USBSend>
    515e:	2f ef       	ldi	r18, 0xFF	; 255
    5160:	80 e7       	ldi	r24, 0x70	; 112
    5162:	92 e0       	ldi	r25, 0x02	; 2
    5164:	21 50       	subi	r18, 0x01	; 1
    5166:	80 40       	sbci	r24, 0x00	; 0
    5168:	90 40       	sbci	r25, 0x00	; 0
    516a:	e1 f7       	brne	.-8      	; 0x5164 <USBSendASCII+0x78>
    516c:	00 c0       	rjmp	.+0      	; 0x516e <USBSendASCII+0x82>
    516e:	00 00       	nop

	Delay_MS(100);
	
	//send ones digit
	if (ones!=0){
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END + ones,LOWER);
    5170:	60 e0       	ldi	r22, 0x00	; 0
	}

	Delay_MS(100);
	
	//send ones digit
	if (ones!=0){
    5172:	dd 23       	and	r29, r29
    5174:	19 f0       	breq	.+6      	; 0x517c <USBSendASCII+0x90>
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END + ones,LOWER);
    5176:	89 e5       	ldi	r24, 0x59	; 89
    5178:	8d 0f       	add	r24, r29
    517a:	01 c0       	rjmp	.+2      	; 0x517e <USBSendASCII+0x92>
	}
	else{
		USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT,LOWER);
    517c:	82 e6       	ldi	r24, 0x62	; 98
    517e:	ac de       	rcall	.-680    	; 0x4ed8 <USBSend>
    5180:	2f ef       	ldi	r18, 0xFF	; 255
    5182:	80 e7       	ldi	r24, 0x70	; 112
    5184:	92 e0       	ldi	r25, 0x02	; 2
    5186:	21 50       	subi	r18, 0x01	; 1
    5188:	80 40       	sbci	r24, 0x00	; 0
    518a:	90 40       	sbci	r25, 0x00	; 0
    518c:	e1 f7       	brne	.-8      	; 0x5186 <USBSendASCII+0x9a>
    518e:	00 c0       	rjmp	.+0      	; 0x5190 <USBSendASCII+0xa4>
    5190:	00 00       	nop
	}
	
	Delay_MS(100);
	
	//release alt key
	Hold_Alt_Down = false;
    5192:	10 92 87 06 	sts	0x0687, r1

}
    5196:	df 91       	pop	r29
    5198:	cf 91       	pop	r28
    519a:	1f 91       	pop	r17
    519c:	0f 91       	pop	r16
    519e:	08 95       	ret

000051a0 <GetModifier>:

uint8_t GetModifier(){
	uint8_t Modifier = 0;
	bool ShiftIsPressed = false;
	
	switch (Shift_Reed){
    51a0:	80 91 7e 06 	lds	r24, 0x067E
    51a4:	82 30       	cpi	r24, 0x02	; 2
    51a6:	99 f0       	breq	.+38     	; 0x51ce <GetModifier+0x2e>
    51a8:	40 f4       	brcc	.+16     	; 0x51ba <GetModifier+0x1a>
    51aa:	81 30       	cpi	r24, 0x01	; 1
    51ac:	09 f5       	brne	.+66     	; 0x51f0 <GetModifier+0x50>
	case 0: ShiftIsPressed = false; break;// if shift reed is 0, no shift key has been programed;
	case 1: ShiftIsPressed = (is_high(REED_1) == Reed1Polarity); break; //test if reed_1 is at the active level (high/low) indicated by reed1polarity
    51ae:	89 b1       	in	r24, 0x09	; 9
    51b0:	82 95       	swap	r24
    51b2:	81 70       	andi	r24, 0x01	; 1
    51b4:	90 91 88 06 	lds	r25, 0x0688
    51b8:	17 c0       	rjmp	.+46     	; 0x51e8 <GetModifier+0x48>

uint8_t GetModifier(){
	uint8_t Modifier = 0;
	bool ShiftIsPressed = false;
	
	switch (Shift_Reed){
    51ba:	83 30       	cpi	r24, 0x03	; 3
    51bc:	79 f0       	breq	.+30     	; 0x51dc <GetModifier+0x3c>
    51be:	84 30       	cpi	r24, 0x04	; 4
    51c0:	b9 f4       	brne	.+46     	; 0x51f0 <GetModifier+0x50>
	case 0: ShiftIsPressed = false; break;// if shift reed is 0, no shift key has been programed;
	case 1: ShiftIsPressed = (is_high(REED_1) == Reed1Polarity); break; //test if reed_1 is at the active level (high/low) indicated by reed1polarity
	case 2: ShiftIsPressed = (is_high(REED_2) == Reed2Polarity); break;
	case 3: ShiftIsPressed = (is_high(REED_3) == Reed3Polarity); break;
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
    51c2:	83 b1       	in	r24, 0x03	; 3
    51c4:	82 95       	swap	r24
    51c6:	81 70       	andi	r24, 0x01	; 1
    51c8:	90 91 48 07 	lds	r25, 0x0748
    51cc:	0d c0       	rjmp	.+26     	; 0x51e8 <GetModifier+0x48>
	bool ShiftIsPressed = false;
	
	switch (Shift_Reed){
	case 0: ShiftIsPressed = false; break;// if shift reed is 0, no shift key has been programed;
	case 1: ShiftIsPressed = (is_high(REED_1) == Reed1Polarity); break; //test if reed_1 is at the active level (high/low) indicated by reed1polarity
	case 2: ShiftIsPressed = (is_high(REED_2) == Reed2Polarity); break;
    51ce:	89 b1       	in	r24, 0x09	; 9
    51d0:	86 fb       	bst	r24, 6
    51d2:	88 27       	eor	r24, r24
    51d4:	80 f9       	bld	r24, 0
    51d6:	90 91 36 06 	lds	r25, 0x0636
    51da:	06 c0       	rjmp	.+12     	; 0x51e8 <GetModifier+0x48>
	case 3: ShiftIsPressed = (is_high(REED_3) == Reed3Polarity); break;
    51dc:	89 b1       	in	r24, 0x09	; 9
    51de:	88 1f       	adc	r24, r24
    51e0:	88 27       	eor	r24, r24
    51e2:	88 1f       	adc	r24, r24
    51e4:	90 91 0a 07 	lds	r25, 0x070A
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
    51e8:	89 13       	cpse	r24, r25
    51ea:	02 c0       	rjmp	.+4      	; 0x51f0 <GetModifier+0x50>
	default: ShiftIsPressed = false;
	}
	
	if(ShiftIsPressed) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTSHIFT;}
    51ec:	82 e0       	ldi	r24, 0x02	; 2
    51ee:	01 c0       	rjmp	.+2      	; 0x51f2 <GetModifier+0x52>

const uint8_t REED_BITS[] = {62,61,60,59}; //these are the bits of the sensor array that represent the reed switches


uint8_t GetModifier(){
	uint8_t Modifier = 0;
    51f0:	80 e0       	ldi	r24, 0x00	; 0
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
	default: ShiftIsPressed = false;
	}
	
	if(ShiftIsPressed) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTSHIFT;}
	if(is_low(CTRL_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTCTRL;}
    51f2:	7c 9b       	sbis	0x0f, 4	; 15
    51f4:	81 60       	ori	r24, 0x01	; 1
	if(is_low(ALT_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTALT;}
    51f6:	7d 9b       	sbis	0x0f, 5	; 15
    51f8:	84 60       	ori	r24, 0x04	; 4
	if(is_low(CMD_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTGUI;}
    51fa:	7e 9b       	sbis	0x0f, 6	; 15
    51fc:	88 60       	ori	r24, 0x08	; 8
	
	return Modifier;
}
    51fe:	08 95       	ret

00005200 <ReadSensor>:
			return 0; //if no keys or reeds need sending, return 0
		}

}

unsigned long long ReadSensor(){
    5200:	7f 92       	push	r7
    5202:	8f 92       	push	r8
    5204:	9f 92       	push	r9
    5206:	af 92       	push	r10
    5208:	bf 92       	push	r11
    520a:	cf 92       	push	r12
    520c:	df 92       	push	r13
    520e:	ef 92       	push	r14
    5210:	ff 92       	push	r15
    5212:	0f 93       	push	r16
    5214:	1f 93       	push	r17
    5216:	cf 93       	push	r28
    5218:	df 93       	push	r29
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    521a:	f8 94       	cli
		unsigned long long Readout = 0;	
		bool HallReading;
		
		GlobalInterruptDisable();
		set_high(SENSE_CLK);
    521c:	72 9a       	sbi	0x0e, 2	; 14
    521e:	8f ec       	ldi	r24, 0xCF	; 207
    5220:	97 e0       	ldi	r25, 0x07	; 7
    5222:	01 97       	sbiw	r24, 0x01	; 1
    5224:	f1 f7       	brne	.-4      	; 0x5222 <ReadSensor+0x22>
    5226:	00 c0       	rjmp	.+0      	; 0x5228 <ReadSensor+0x28>
    5228:	00 00       	nop
		Delay_MS(1); //Sensor board has an LP filter and an inverter on the _LOAD signal.  Wait X ms for the low-pass filter on the _LOAD signal to fire low. 
		set_low(SENSE_CLK);
    522a:	72 98       	cbi	0x0e, 2	; 14
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    522c:	78 94       	sei
    522e:	8f ec       	ldi	r24, 0xCF	; 207
    5230:	97 e0       	ldi	r25, 0x07	; 7
    5232:	01 97       	sbiw	r24, 0x01	; 1
    5234:	f1 f7       	brne	.-4      	; 0x5232 <ReadSensor+0x32>
    5236:	00 c0       	rjmp	.+0      	; 0x5238 <ReadSensor+0x38>
    5238:	00 00       	nop
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
    523a:	e1 2c       	mov	r14, r1
    523c:	f1 2c       	mov	r15, r1
		}

}

unsigned long long ReadSensor(){
		unsigned long long Readout = 0;	
    523e:	71 2c       	mov	r7, r1
    5240:	10 e0       	ldi	r17, 0x00	; 0
    5242:	d0 e0       	ldi	r29, 0x00	; 0
    5244:	c0 e0       	ldi	r28, 0x00	; 0
    5246:	b0 e0       	ldi	r27, 0x00	; 0
    5248:	a0 e0       	ldi	r26, 0x00	; 0
    524a:	f0 e0       	ldi	r31, 0x00	; 0
    524c:	e0 e0       	ldi	r30, 0x00	; 0
		set_low(SENSE_CLK);
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
			if (is_low(SENSE_SER)) { 
    524e:	1d 99       	sbic	0x03, 5	; 3
    5250:	13 c0       	rjmp	.+38     	; 0x5278 <ReadSensor+0x78>
				longlongbit_set(Readout,i);// if the readout for one of the sensor pins comes back low, that key has been pressed -- store it as a 1 in the readout.
    5252:	21 e0       	ldi	r18, 0x01	; 1
    5254:	30 e0       	ldi	r19, 0x00	; 0
    5256:	40 e0       	ldi	r20, 0x00	; 0
    5258:	50 e0       	ldi	r21, 0x00	; 0
    525a:	60 e0       	ldi	r22, 0x00	; 0
    525c:	70 e0       	ldi	r23, 0x00	; 0
    525e:	80 e0       	ldi	r24, 0x00	; 0
    5260:	90 e0       	ldi	r25, 0x00	; 0
    5262:	0e 2d       	mov	r16, r14
    5264:	0e 94 ae 35 	call	0x6b5c	; 0x6b5c <__ashldi3>
    5268:	72 2a       	or	r7, r18
    526a:	13 2b       	or	r17, r19
    526c:	d4 2b       	or	r29, r20
    526e:	c5 2b       	or	r28, r21
    5270:	b6 2b       	or	r27, r22
    5272:	a7 2b       	or	r26, r23
    5274:	f8 2b       	or	r31, r24
    5276:	e9 2b       	or	r30, r25
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    5278:	f8 94       	cli
			}	
			
			GlobalInterruptDisable();//if sense clk stays high too long, it could falsely trigger _Load signal.
			set_high(SENSE_CLK);
    527a:	72 9a       	sbi	0x0e, 2	; 14
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    527c:	9a e1       	ldi	r25, 0x1A	; 26
    527e:	9a 95       	dec	r25
    5280:	f1 f7       	brne	.-4      	; 0x527e <ReadSensor+0x7e>
    5282:	00 c0       	rjmp	.+0      	; 0x5284 <ReadSensor+0x84>
			_delay_us(CLK_POS_PULSE); //delay for the required pulsewidth
			set_low(SENSE_CLK);
    5284:	72 98       	cbi	0x0e, 2	; 14
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    5286:	78 94       	sei
    5288:	8a e6       	ldi	r24, 0x6A	; 106
    528a:	8a 95       	dec	r24
    528c:	f1 f7       	brne	.-4      	; 0x528a <ReadSensor+0x8a>
    528e:	00 c0       	rjmp	.+0      	; 0x5290 <ReadSensor+0x90>
		Delay_MS(1); //Sensor board has an LP filter and an inverter on the _LOAD signal.  Wait X ms for the low-pass filter on the _LOAD signal to fire low. 
		set_low(SENSE_CLK);
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
    5290:	9f ef       	ldi	r25, 0xFF	; 255
    5292:	e9 1a       	sub	r14, r25
    5294:	f9 0a       	sbc	r15, r25
    5296:	80 e3       	ldi	r24, 0x30	; 48
    5298:	e8 16       	cp	r14, r24
    529a:	f1 04       	cpc	r15, r1
    529c:	c1 f6       	brne	.-80     	; 0x524e <ReadSensor+0x4e>

		}
		
		/*The hall effect sensor on the end of the sensor board is only installed in certain cases -
		- its job is to tell if the entire crossbar has moved(active), or if it is at rest (therefore no keys should be detected)*/
		if(UseHallSensor == HALL_ACTIVE){ //when the hall effect sensor is installed and activated
    529e:	80 91 0b 07 	lds	r24, 0x070B
    52a2:	82 30       	cpi	r24, 0x02	; 2
    52a4:	e9 f4       	brne	.+58     	; 0x52e0 <ReadSensor+0xe0>
			HallReading = Readout & LONGLONGBIT(HALL_SENSOR_BIT); //one of the bits of the sensor readout gives the state of the hall sensor
    52a6:	27 2d       	mov	r18, r7
    52a8:	31 2f       	mov	r19, r17
    52aa:	4d 2f       	mov	r20, r29
    52ac:	5c 2f       	mov	r21, r28
    52ae:	6b 2f       	mov	r22, r27
    52b0:	7a 2f       	mov	r23, r26
    52b2:	8f 2f       	mov	r24, r31
    52b4:	9e 2f       	mov	r25, r30
    52b6:	0c e2       	ldi	r16, 0x2C	; 44
    52b8:	0e 94 c9 35 	call	0x6b92	; 0x6b92 <__lshrdi3>
    52bc:	49 01       	movw	r8, r18
    52be:	91 e0       	ldi	r25, 0x01	; 1
    52c0:	89 22       	and	r8, r25
    52c2:	99 24       	eor	r9, r9
			if(HallReading != HallSensorPolarity){
    52c4:	80 91 86 06 	lds	r24, 0x0686
    52c8:	90 e0       	ldi	r25, 0x00	; 0
    52ca:	88 16       	cp	r8, r24
    52cc:	99 06       	cpc	r9, r25
    52ce:	41 f0       	breq	.+16     	; 0x52e0 <ReadSensor+0xe0>
				Readout = 0; //then if the hall effect sensor is not triggered, readout of keys is invalid -- clear it (including the hall sensor bit). 
    52d0:	71 2c       	mov	r7, r1
    52d2:	10 e0       	ldi	r17, 0x00	; 0
    52d4:	d0 e0       	ldi	r29, 0x00	; 0
    52d6:	c0 e0       	ldi	r28, 0x00	; 0
    52d8:	b0 e0       	ldi	r27, 0x00	; 0
    52da:	a0 e0       	ldi	r26, 0x00	; 0
    52dc:	f0 e0       	ldi	r31, 0x00	; 0
    52de:	e0 e0       	ldi	r30, 0x00	; 0
			}
		}

		//add the reed switches to the last 4 bits of the readout array -- if the reed switch is for the shift key, ignore it!
		if (Shift_Reed != 1 && is_high(REED_1)==(bool)Reed1Polarity){ Readout |= LONGLONGBIT(REED_BITS[0]);} //63rd bit of readout (or something like that) represents Reed1
    52e0:	80 91 7e 06 	lds	r24, 0x067E
    52e4:	81 30       	cpi	r24, 0x01	; 1
    52e6:	51 f0       	breq	.+20     	; 0x52fc <ReadSensor+0xfc>
    52e8:	99 b1       	in	r25, 0x09	; 9
    52ea:	92 95       	swap	r25
    52ec:	91 70       	andi	r25, 0x01	; 1
    52ee:	20 91 88 06 	lds	r18, 0x0688
    52f2:	92 13       	cpse	r25, r18
    52f4:	01 c0       	rjmp	.+2      	; 0x52f8 <ReadSensor+0xf8>
    52f6:	e0 64       	ori	r30, 0x40	; 64
		if (Shift_Reed != 2 && is_high(REED_2)==(bool)Reed2Polarity){ Readout |= LONGLONGBIT(REED_BITS[1]);} //62nd bit of readout (or something like that) represents Reed2
    52f8:	82 30       	cpi	r24, 0x02	; 2
    52fa:	59 f0       	breq	.+22     	; 0x5312 <ReadSensor+0x112>
    52fc:	99 b1       	in	r25, 0x09	; 9
    52fe:	96 fb       	bst	r25, 6
    5300:	99 27       	eor	r25, r25
    5302:	90 f9       	bld	r25, 0
    5304:	20 91 36 06 	lds	r18, 0x0636
    5308:	92 13       	cpse	r25, r18
    530a:	01 c0       	rjmp	.+2      	; 0x530e <ReadSensor+0x10e>
    530c:	e0 62       	ori	r30, 0x20	; 32
		if (Shift_Reed != 3 && is_high(REED_3)==(bool)Reed3Polarity){ Readout |= LONGLONGBIT(REED_BITS[2]);} //61st bit of readout (or something like that) represents Reed3
    530e:	83 30       	cpi	r24, 0x03	; 3
    5310:	59 f0       	breq	.+22     	; 0x5328 <ReadSensor+0x128>
    5312:	99 b1       	in	r25, 0x09	; 9
    5314:	99 1f       	adc	r25, r25
    5316:	99 27       	eor	r25, r25
    5318:	99 1f       	adc	r25, r25
    531a:	20 91 0a 07 	lds	r18, 0x070A
    531e:	92 13       	cpse	r25, r18
    5320:	01 c0       	rjmp	.+2      	; 0x5324 <ReadSensor+0x124>
    5322:	e0 61       	ori	r30, 0x10	; 16
		if (Shift_Reed != 4 && is_high(REED_4)==(bool)Reed4Polarity){ Readout |= LONGLONGBIT(REED_BITS[3]);} //60th bit of readout (or something like that) represents Reed4
    5324:	84 30       	cpi	r24, 0x04	; 4
    5326:	41 f0       	breq	.+16     	; 0x5338 <ReadSensor+0x138>
    5328:	83 b1       	in	r24, 0x03	; 3
    532a:	82 95       	swap	r24
    532c:	81 70       	andi	r24, 0x01	; 1
    532e:	90 91 48 07 	lds	r25, 0x0748
    5332:	89 13       	cpse	r24, r25
    5334:	01 c0       	rjmp	.+2      	; 0x5338 <ReadSensor+0x138>
    5336:	e8 60       	ori	r30, 0x08	; 8
		
		return Readout;
}
    5338:	27 2d       	mov	r18, r7
    533a:	31 2f       	mov	r19, r17
    533c:	4d 2f       	mov	r20, r29
    533e:	5c 2f       	mov	r21, r28
    5340:	6b 2f       	mov	r22, r27
    5342:	7a 2f       	mov	r23, r26
    5344:	8f 2f       	mov	r24, r31
    5346:	9e 2f       	mov	r25, r30
    5348:	df 91       	pop	r29
    534a:	cf 91       	pop	r28
    534c:	1f 91       	pop	r17
    534e:	0f 91       	pop	r16
    5350:	ff 90       	pop	r15
    5352:	ef 90       	pop	r14
    5354:	df 90       	pop	r13
    5356:	cf 90       	pop	r12
    5358:	bf 90       	pop	r11
    535a:	af 90       	pop	r10
    535c:	9f 90       	pop	r9
    535e:	8f 90       	pop	r8
    5360:	7f 90       	pop	r7
    5362:	08 95       	ret

00005364 <GetKeySimple>:
	if(is_low(CMD_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTGUI;}
	
	return Modifier;
}

uint8_t GetKeySimple(){
    5364:	ff 92       	push	r15
    5366:	0f 93       	push	r16
    5368:	1f 93       	push	r17
    536a:	cf 93       	push	r28
    536c:	df 93       	push	r29
	unsigned long long SensorReadout; //create 64-bit "long long" binary variable and set it all to 0s.
	uint8_t Key;
	
	Key=0;//by default, there is no key to send, unless one is detected later.
	
	SensorReadout = ReadSensor();
    536e:	48 df       	rcall	.-368    	; 0x5200 <ReadSensor>
    5370:	f2 2e       	mov	r15, r18
    5372:	03 2f       	mov	r16, r19
    5374:	14 2f       	mov	r17, r20
    5376:	d5 2f       	mov	r29, r21
    5378:	c6 2f       	mov	r28, r22
    537a:	e7 2f       	mov	r30, r23
    537c:	b8 2f       	mov	r27, r24
    537e:	f9 2f       	mov	r31, r25
	if(UseHallSensor != HALL_NOT_PRESENT){
    5380:	80 91 0b 07 	lds	r24, 0x070B
    5384:	81 11       	cpse	r24, r1
		SensorReadout &= ~LONGLONGBIT(HALL_SENSOR_BIT); //discard the hall effect bit of the array -- it is not an actual key, so don't report it as one.
    5386:	ef 7e       	andi	r30, 0xEF	; 239
	}

	if(SensorReadout){
    5388:	2f 2d       	mov	r18, r15
    538a:	30 2f       	mov	r19, r16
    538c:	41 2f       	mov	r20, r17
    538e:	5d 2f       	mov	r21, r29
    5390:	6c 2f       	mov	r22, r28
    5392:	7e 2f       	mov	r23, r30
    5394:	8b 2f       	mov	r24, r27
    5396:	9f 2f       	mov	r25, r31
    5398:	a0 e0       	ldi	r26, 0x00	; 0
    539a:	0e 94 e5 35 	call	0x6bca	; 0x6bca <__cmpdi2_s8>
    539e:	19 f0       	breq	.+6      	; 0x53a6 <GetKeySimple+0x42>
		Key = (uint8_t) __builtin_clzll(SensorReadout); //this function finds the first nonzero bit in the bitfield SensorReadout (by counting leading zeros)
    53a0:	0e 94 a6 35 	call	0x6b4c	; 0x6b4c <__clzdi2>
    53a4:	01 c0       	rjmp	.+2      	; 0x53a8 <GetKeySimple+0x44>
	}
	else{
		Key = 0;
    53a6:	80 e0       	ldi	r24, 0x00	; 0
	}
	return  Key;
	
}
    53a8:	df 91       	pop	r29
    53aa:	cf 91       	pop	r28
    53ac:	1f 91       	pop	r17
    53ae:	0f 91       	pop	r16
    53b0:	ff 90       	pop	r15
    53b2:	08 95       	ret

000053b4 <GetKey>:
	
uint8_t GetKey(){
    53b4:	2f 92       	push	r2
    53b6:	3f 92       	push	r3
    53b8:	4f 92       	push	r4
    53ba:	5f 92       	push	r5
    53bc:	6f 92       	push	r6
    53be:	7f 92       	push	r7
    53c0:	8f 92       	push	r8
    53c2:	9f 92       	push	r9
    53c4:	af 92       	push	r10
    53c6:	bf 92       	push	r11
    53c8:	cf 92       	push	r12
    53ca:	df 92       	push	r13
    53cc:	ef 92       	push	r14
    53ce:	ff 92       	push	r15
    53d0:	0f 93       	push	r16
    53d2:	1f 93       	push	r17
    53d4:	cf 93       	push	r28
    53d6:	df 93       	push	r29
    53d8:	00 d0       	rcall	.+0      	; 0x53da <GetKey+0x26>
    53da:	1f 92       	push	r1
    53dc:	cd b7       	in	r28, 0x3d	; 61
    53de:	de b7       	in	r29, 0x3e	; 62
		bool OKtoSendReed = false; //go ahead to send a reed switch
		
		uint8_t ReedToSend = 0;
	
/*READ INPUT FROM SENSOR STRIP*/	
		SensorReadout = ReadSensor();
    53e0:	0f df       	rcall	.-482    	; 0x5200 <ReadSensor>
    53e2:	49 01       	movw	r8, r18
    53e4:	14 2f       	mov	r17, r20
    53e6:	59 83       	std	Y+1, r21	; 0x01
    53e8:	f6 2f       	mov	r31, r22
    53ea:	e7 2f       	mov	r30, r23
    53ec:	48 2e       	mov	r4, r24
    53ee:	39 2e       	mov	r3, r25
		
		if (UseHallSensor != HALL_NOT_PRESENT){ //if the user has not installed the hall sensor, don't do this part.
    53f0:	80 91 0b 07 	lds	r24, 0x070B
    53f4:	81 11       	cpse	r24, r1
			SensorReadout &= ~LONGLONGBIT(HALL_SENSOR_BIT); //after detecting it, discard the hall effect bit of the array -- it is not an actual key, so don't report it as one.
    53f6:	ef 7e       	andi	r30, 0xEF	; 239
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
			int reednumber = i+1;
			int j;
			
			if (Reeds_Are_Independent) j = i; //
    53f8:	50 90 38 06 	lds	r5, 0x0638
			else j = 0; //setting j = 0 means "If any reed is active, all reeds are considered active also (and are therefore won't be sent when pressed)
			
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
				if (ReedDebounce[i] < ReedHoldTime){//increment the debounce entry if not already maxed out.
    53fc:	20 90 7c 06 	lds	r2, 0x067C
    5400:	8f e0       	ldi	r24, 0x0F	; 15
    5402:	e8 2e       	mov	r14, r24
    5404:	86 e0       	ldi	r24, 0x06	; 6
    5406:	f8 2e       	mov	r15, r24
    5408:	97 e4       	ldi	r25, 0x47	; 71
    540a:	a9 2e       	mov	r10, r25
    540c:	93 e0       	ldi	r25, 0x03	; 3
    540e:	b9 2e       	mov	r11, r25
    5410:	c1 2c       	mov	r12, r1
    5412:	d1 2c       	mov	r13, r1
		static uint8_t ReedDebounce[4]; //array tracking the debounce times of all four reed switches.  
		
		bool OKtoSendKey = false; //non static bool that gives the go-ahead to send a key over the usb/bluetooth bus.  Indicates that the key has been pressed first time.
		bool OKtoSendReed = false; //go ahead to send a reed switch
		
		uint8_t ReedToSend = 0;
    5414:	71 2c       	mov	r7, r1
		static uint8_t KeyReleaseCounter;
		static bool ActiveReeds[4];//array showing all currently active reeds.
		static uint8_t ReedDebounce[4]; //array tracking the debounce times of all four reed switches.  
		
		bool OKtoSendKey = false; //non static bool that gives the go-ahead to send a key over the usb/bluetooth bus.  Indicates that the key has been pressed first time.
		bool OKtoSendReed = false; //go ahead to send a reed switch
    5416:	61 2c       	mov	r6, r1
/*READ AND DEBOUNCE REED SWITCH INPUTS*/

		/*Detect which reeds have been pressed, and if they have been sent to the host already or if they still need to be*/
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
			int reednumber = i+1;
    5418:	db 82       	std	Y+3, r13	; 0x03
    541a:	ca 82       	std	Y+2, r12	; 0x02
			int j;
			
			if (Reeds_Are_Independent) j = i; //
    541c:	51 10       	cpse	r5, r1
    541e:	02 c0       	rjmp	.+4      	; 0x5424 <GetKey+0x70>
			else j = 0; //setting j = 0 means "If any reed is active, all reeds are considered active also (and are therefore won't be sent when pressed)
    5420:	1b 82       	std	Y+3, r1	; 0x03
    5422:	1a 82       	std	Y+2, r1	; 0x02
			
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
    5424:	d5 01       	movw	r26, r10
    5426:	0d 91       	ld	r16, X+
    5428:	5d 01       	movw	r10, r26
    542a:	bf ef       	ldi	r27, 0xFF	; 255
    542c:	cb 1a       	sub	r12, r27
    542e:	db 0a       	sbc	r13, r27
    5430:	94 01       	movw	r18, r8
    5432:	41 2f       	mov	r20, r17
    5434:	59 81       	ldd	r21, Y+1	; 0x01
    5436:	6f 2f       	mov	r22, r31
    5438:	7e 2f       	mov	r23, r30
    543a:	84 2d       	mov	r24, r4
    543c:	93 2d       	mov	r25, r3
    543e:	0e 94 c9 35 	call	0x6b92	; 0x6b92 <__lshrdi3>
    5442:	21 70       	andi	r18, 0x01	; 1
    5444:	30 e0       	ldi	r19, 0x00	; 0
    5446:	40 e0       	ldi	r20, 0x00	; 0
    5448:	50 e0       	ldi	r21, 0x00	; 0
    544a:	60 e0       	ldi	r22, 0x00	; 0
    544c:	70 e0       	ldi	r23, 0x00	; 0
    544e:	80 e0       	ldi	r24, 0x00	; 0
    5450:	90 e0       	ldi	r25, 0x00	; 0
    5452:	a0 e0       	ldi	r26, 0x00	; 0
    5454:	0e 94 e5 35 	call	0x6bca	; 0x6bca <__cmpdi2_s8>
    5458:	99 f0       	breq	.+38     	; 0x5480 <GetKey+0xcc>
				if (ReedDebounce[i] < ReedHoldTime){//increment the debounce entry if not already maxed out.
    545a:	d7 01       	movw	r26, r14
    545c:	8c 91       	ld	r24, X
    545e:	82 15       	cp	r24, r2
    5460:	10 f4       	brcc	.+4      	; 0x5466 <GetKey+0xb2>
					ReedDebounce[i] ++;
    5462:	8f 5f       	subi	r24, 0xFF	; 255
    5464:	31 c0       	rjmp	.+98     	; 0x54c8 <GetKey+0x114>
				} 
				else if (!ActiveReeds[j]){ //if the debounce has reached KeyHoldTime, but the reed isn't already listed as active
    5466:	aa 81       	ldd	r26, Y+2	; 0x02
    5468:	bb 81       	ldd	r27, Y+3	; 0x03
    546a:	a5 5f       	subi	r26, 0xF5	; 245
    546c:	b9 4f       	sbci	r27, 0xF9	; 249
    546e:	8c 91       	ld	r24, X
    5470:	81 11       	cpse	r24, r1
    5472:	2b c0       	rjmp	.+86     	; 0x54ca <GetKey+0x116>
						ActiveReeds[j] = true; //then list it as active.
    5474:	81 e0       	ldi	r24, 0x01	; 1
    5476:	8c 93       	st	X, r24
						ReedToSend = reednumber; //code 1,2,3, or 4 indicates which reed has been pressed
    5478:	7c 2c       	mov	r7, r12
						OKtoSendReed = true;//and tell the routine to send it
    547a:	66 24       	eor	r6, r6
    547c:	63 94       	inc	r6
    547e:	25 c0       	rjmp	.+74     	; 0x54ca <GetKey+0x116>
				}
			} 
			else if (Reeds_Are_Independent){//if the reed is not detected, and we are tracking them separately.
    5480:	55 20       	and	r5, r5
    5482:	39 f0       	breq	.+14     	; 0x5492 <GetKey+0xde>
				if(ReedDebounce[i] == 0) ActiveReeds[j] = false; //then if the debounce counter has run down, consider the reed to be released.
    5484:	d7 01       	movw	r26, r14
    5486:	8c 91       	ld	r24, X
    5488:	88 23       	and	r24, r24
    548a:	99 f0       	breq	.+38     	; 0x54b2 <GetKey+0xfe>
				else ReedDebounce[i]--; //if not already zero, decrement the counter
    548c:	81 50       	subi	r24, 0x01	; 1
    548e:	d7 01       	movw	r26, r14
    5490:	1b c0       	rjmp	.+54     	; 0x54c8 <GetKey+0x114>
			}
			else if (!Reeds_Are_Independent){ //if reeds are not considered independent, all reeds must be released before another can fire.
				if((ReedDebounce[0] == 0)&&(ReedDebounce[1] == 0)&&(ReedDebounce[2]== 0)&&(ReedDebounce[3]==0)){ //so wait for all reeds to be released
    5492:	80 91 0f 06 	lds	r24, 0x060F
    5496:	81 11       	cpse	r24, r1
    5498:	12 c0       	rjmp	.+36     	; 0x54be <GetKey+0x10a>
    549a:	80 91 10 06 	lds	r24, 0x0610
    549e:	81 11       	cpse	r24, r1
    54a0:	0e c0       	rjmp	.+28     	; 0x54be <GetKey+0x10a>
    54a2:	80 91 11 06 	lds	r24, 0x0611
    54a6:	81 11       	cpse	r24, r1
    54a8:	0a c0       	rjmp	.+20     	; 0x54be <GetKey+0x10a>
    54aa:	80 91 12 06 	lds	r24, 0x0612
    54ae:	81 11       	cpse	r24, r1
    54b0:	06 c0       	rjmp	.+12     	; 0x54be <GetKey+0x10a>
					ActiveReeds[j] = false; // only if all reeds are released do we allow a new reed to be pressed.
    54b2:	aa 81       	ldd	r26, Y+2	; 0x02
    54b4:	bb 81       	ldd	r27, Y+3	; 0x03
    54b6:	a5 5f       	subi	r26, 0xF5	; 245
    54b8:	b9 4f       	sbci	r27, 0xF9	; 249
    54ba:	1c 92       	st	X, r1
    54bc:	06 c0       	rjmp	.+12     	; 0x54ca <GetKey+0x116>
				}
				else if (ReedDebounce[i]) {ReedDebounce[i]--;} //decrement debounce counter for this reed.
    54be:	d7 01       	movw	r26, r14
    54c0:	8c 91       	ld	r24, X
    54c2:	88 23       	and	r24, r24
    54c4:	11 f0       	breq	.+4      	; 0x54ca <GetKey+0x116>
    54c6:	81 50       	subi	r24, 0x01	; 1
    54c8:	8c 93       	st	X, r24
    54ca:	bf ef       	ldi	r27, 0xFF	; 255
    54cc:	eb 1a       	sub	r14, r27
    54ce:	fb 0a       	sbc	r15, r27
		
/*READ AND DEBOUNCE REED SWITCH INPUTS*/

		/*Detect which reeds have been pressed, and if they have been sent to the host already or if they still need to be*/
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
    54d0:	84 e0       	ldi	r24, 0x04	; 4
    54d2:	c8 16       	cp	r12, r24
    54d4:	d1 04       	cpc	r13, r1
    54d6:	09 f0       	breq	.+2      	; 0x54da <GetKey+0x126>
    54d8:	9f cf       	rjmp	.-194    	; 0x5418 <GetKey+0x64>
		

		

/*APPLY VARIOUS MASKS TO SIMPLIFY SENSOR READOUT*/	
		SensorReadout = SensorReadout & KEY_SENSOR_MASK;//discard the reed switch bits and the sensor bit -- look only at the key sensor contacts.
    54da:	f9 80       	ldd	r15, Y+1	; 0x01
		if (SensorReadout == KEY_SENSOR_MASK){
    54dc:	94 01       	movw	r18, r8
    54de:	41 2f       	mov	r20, r17
    54e0:	5f 2d       	mov	r21, r15
    54e2:	6f 2f       	mov	r22, r31
    54e4:	7e 2f       	mov	r23, r30
    54e6:	80 e0       	ldi	r24, 0x00	; 0
    54e8:	90 e0       	ldi	r25, 0x00	; 0
    54ea:	2f 3f       	cpi	r18, 0xFF	; 255
    54ec:	af ef       	ldi	r26, 0xFF	; 255
    54ee:	3a 07       	cpc	r19, r26
    54f0:	4a 07       	cpc	r20, r26
    54f2:	5a 07       	cpc	r21, r26
    54f4:	6a 07       	cpc	r22, r26
    54f6:	7a 07       	cpc	r23, r26
    54f8:	81 05       	cpc	r24, r1
    54fa:	91 05       	cpc	r25, r1
    54fc:	09 f4       	brne	.+2      	; 0x5500 <GetKey+0x14c>
    54fe:	55 c0       	rjmp	.+170    	; 0x55aa <GetKey+0x1f6>
			SensorReadout = 0;// if masked sensor readout is all ones, sensor is probably not plugged in -- discard.
		}
		else if(ActiveKey){
    5500:	80 91 0a 06 	lds	r24, 0x060A
    5504:	88 23       	and	r24, r24
    5506:	79 f0       	breq	.+30     	; 0x5526 <GetKey+0x172>
			SensorReadout = (SensorReadout & KEYMASK(ActiveKey)); //if a key was detected last time, mask all others -- only look at that key this time -- prevents confusion from multiple keys.
    5508:	af e3       	ldi	r26, 0x3F	; 63
    550a:	b0 e0       	ldi	r27, 0x00	; 0
    550c:	a8 1b       	sub	r26, r24
    550e:	b1 09       	sbc	r27, r1
    5510:	21 e0       	ldi	r18, 0x01	; 1
    5512:	30 e0       	ldi	r19, 0x00	; 0
    5514:	40 e0       	ldi	r20, 0x00	; 0
    5516:	50 e0       	ldi	r21, 0x00	; 0
    5518:	60 e0       	ldi	r22, 0x00	; 0
    551a:	70 e0       	ldi	r23, 0x00	; 0
    551c:	80 e0       	ldi	r24, 0x00	; 0
    551e:	0a 2f       	mov	r16, r26
    5520:	0e 94 ae 35 	call	0x6b5c	; 0x6b5c <__ashldi3>
    5524:	27 c0       	rjmp	.+78     	; 0x5574 <GetKey+0x1c0>
		}
		else if(PreviousKey){ //if no key was detected, but a key was recently detected (maybe it was just released, or maybe it bounced off)
    5526:	90 91 09 06 	lds	r25, 0x0609
    552a:	99 23       	and	r25, r25
    552c:	49 f1       	breq	.+82     	; 0x5580 <GetKey+0x1cc>
			DoubleTapCounter++;
    552e:	80 91 08 06 	lds	r24, 0x0608
    5532:	8f 5f       	subi	r24, 0xFF	; 255
    5534:	80 93 08 06 	sts	0x0608, r24
			if (DoubleTapCounter >= DoubleTapTime){ //once the double tap timer has expired, reset everything and stop ignoring previous key.
    5538:	20 91 7d 06 	lds	r18, 0x067D
    553c:	82 17       	cp	r24, r18
    553e:	28 f0       	brcs	.+10     	; 0x554a <GetKey+0x196>
				DoubleTapCounter = 0;
    5540:	10 92 08 06 	sts	0x0608, r1
				PreviousKey = 0; 
    5544:	10 92 09 06 	sts	0x0609, r1
    5548:	1b c0       	rjmp	.+54     	; 0x5580 <GetKey+0x1cc>
			}		
			else{ //if timer has not expired yet, ignore the previous key pressed.
				SensorReadout = (SensorReadout & ~KEYMASK(PreviousKey)); //whatever the previous active key pressed was, ignore it.
    554a:	af e3       	ldi	r26, 0x3F	; 63
    554c:	b0 e0       	ldi	r27, 0x00	; 0
    554e:	a9 1b       	sub	r26, r25
    5550:	b1 09       	sbc	r27, r1
    5552:	21 e0       	ldi	r18, 0x01	; 1
    5554:	30 e0       	ldi	r19, 0x00	; 0
    5556:	40 e0       	ldi	r20, 0x00	; 0
    5558:	50 e0       	ldi	r21, 0x00	; 0
    555a:	60 e0       	ldi	r22, 0x00	; 0
    555c:	70 e0       	ldi	r23, 0x00	; 0
    555e:	80 e0       	ldi	r24, 0x00	; 0
    5560:	90 e0       	ldi	r25, 0x00	; 0
    5562:	0a 2f       	mov	r16, r26
    5564:	0e 94 ae 35 	call	0x6b5c	; 0x6b5c <__ashldi3>
    5568:	20 95       	com	r18
    556a:	30 95       	com	r19
    556c:	40 95       	com	r20
    556e:	50 95       	com	r21
    5570:	60 95       	com	r22
    5572:	70 95       	com	r23
    5574:	82 22       	and	r8, r18
    5576:	93 22       	and	r9, r19
    5578:	14 23       	and	r17, r20
    557a:	f5 22       	and	r15, r21
    557c:	f6 23       	and	r31, r22
    557e:	e7 23       	and	r30, r23
			}
		}
		
/*DETERMINE WHICH CONTACT, IF ANY, HAS DETECTED A KEY THIS ROUND*/	
		if(SensorReadout){ //if sensor readout is not all zeros
    5580:	94 01       	movw	r18, r8
    5582:	41 2f       	mov	r20, r17
    5584:	5f 2d       	mov	r21, r15
    5586:	6f 2f       	mov	r22, r31
    5588:	7e 2f       	mov	r23, r30
    558a:	80 e0       	ldi	r24, 0x00	; 0
    558c:	90 e0       	ldi	r25, 0x00	; 0
    558e:	a0 e0       	ldi	r26, 0x00	; 0
    5590:	0e 94 e5 35 	call	0x6bca	; 0x6bca <__cmpdi2_s8>
    5594:	51 f0       	breq	.+20     	; 0x55aa <GetKey+0x1f6>
			DetectedKey = (uint8_t) __builtin_clzll(SensorReadout); //get the position of the first "one" in the sparse key detection array 
    5596:	0e 94 a6 35 	call	0x6b4c	; 0x6b4c <__clzdi2>
			DetectedKey = 0;
		}
		
/*DEBOUNCE KEY READING*/
		if(DetectedKey){//if there is a detected key this time,
			 KeyHoldCounter++;  
    559a:	90 91 07 06 	lds	r25, 0x0607
    559e:	9f 5f       	subi	r25, 0xFF	; 255
    55a0:	90 93 07 06 	sts	0x0607, r25
			 KeyReleaseCounter=0;		 
    55a4:	10 92 06 06 	sts	0x0606, r1
    55a8:	08 c0       	rjmp	.+16     	; 0x55ba <GetKey+0x206>
		}
		else {
			KeyReleaseCounter++; 
    55aa:	80 91 06 06 	lds	r24, 0x0606
    55ae:	8f 5f       	subi	r24, 0xFF	; 255
    55b0:	80 93 06 06 	sts	0x0606, r24
			KeyHoldCounter = 0;  
    55b4:	10 92 07 06 	sts	0x0607, r1
    55b8:	80 e0       	ldi	r24, 0x00	; 0
		}
		
		if (KeyHoldCounter >= KeyHoldTime){
    55ba:	90 91 c9 06 	lds	r25, 0x06C9
    55be:	20 91 07 06 	lds	r18, 0x0607
    55c2:	29 17       	cp	r18, r25
    55c4:	58 f0       	brcs	.+22     	; 0x55dc <GetKey+0x228>
			KeyHoldCounter = KeyHoldTime; // can't get higher than keyholdtime
    55c6:	90 93 07 06 	sts	0x0607, r25
			if (DetectedKey != ActiveKey){ // if this is a new active key (just pressed) then set the active key to the new value, and give go-ahead to send it.
    55ca:	90 91 0a 06 	lds	r25, 0x060A
    55ce:	89 17       	cp	r24, r25
    55d0:	b1 f0       	breq	.+44     	; 0x55fe <GetKey+0x24a>
				ActiveKey = DetectedKey; //the current key is the new active key
    55d2:	80 93 0a 06 	sts	0x060A, r24
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
    55d6:	66 20       	and	r6, r6
    55d8:	a9 f0       	breq	.+42     	; 0x5604 <GetKey+0x250>
    55da:	0f c0       	rjmp	.+30     	; 0x55fa <GetKey+0x246>
			if (DetectedKey != ActiveKey){ // if this is a new active key (just pressed) then set the active key to the new value, and give go-ahead to send it.
				ActiveKey = DetectedKey; //the current key is the new active key
				OKtoSendKey = true;
			}
		}
		else if (KeyReleaseCounter >= KeyReleaseTime){
    55dc:	80 91 3a 06 	lds	r24, 0x063A
    55e0:	90 91 06 06 	lds	r25, 0x0606
    55e4:	98 17       	cp	r25, r24
    55e6:	58 f0       	brcs	.+22     	; 0x55fe <GetKey+0x24a>
			KeyReleaseCounter = KeyReleaseTime; //
    55e8:	80 93 06 06 	sts	0x0606, r24
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
    55ec:	80 91 0a 06 	lds	r24, 0x060A
    55f0:	80 93 09 06 	sts	0x0609, r24
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
    55f4:	10 92 0a 06 	sts	0x060A, r1
    55f8:	02 c0       	rjmp	.+4      	; 0x55fe <GetKey+0x24a>
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
			return ReedToSend;
    55fa:	87 2d       	mov	r24, r7
    55fc:	03 c0       	rjmp	.+6      	; 0x5604 <GetKey+0x250>
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
    55fe:	61 10       	cpse	r6, r1
    5600:	fc cf       	rjmp	.-8      	; 0x55fa <GetKey+0x246>
		}
		else if(OKtoSendKey){ //otherwise, if there is a key to send, report it
			return ActiveKey; 
		}
		else{
			return 0; //if no keys or reeds need sending, return 0
    5602:	80 e0       	ldi	r24, 0x00	; 0
		}

}
    5604:	0f 90       	pop	r0
    5606:	0f 90       	pop	r0
    5608:	0f 90       	pop	r0
    560a:	df 91       	pop	r29
    560c:	cf 91       	pop	r28
    560e:	1f 91       	pop	r17
    5610:	0f 91       	pop	r16
    5612:	ff 90       	pop	r15
    5614:	ef 90       	pop	r14
    5616:	df 90       	pop	r13
    5618:	cf 90       	pop	r12
    561a:	bf 90       	pop	r11
    561c:	af 90       	pop	r10
    561e:	9f 90       	pop	r9
    5620:	8f 90       	pop	r8
    5622:	7f 90       	pop	r7
    5624:	6f 90       	pop	r6
    5626:	5f 90       	pop	r5
    5628:	4f 90       	pop	r4
    562a:	3f 90       	pop	r3
    562c:	2f 90       	pop	r2
    562e:	08 95       	ret

00005630 <GetHIDKeyCode>:
		if (Shift_Reed != 4 && is_high(REED_4)==(bool)Reed4Polarity){ Readout |= LONGLONGBIT(REED_BITS[3]);} //60th bit of readout (or something like that) represents Reed4
		
		return Readout;
}

uint8_t GetHIDKeyCode(uint8_t key, uint8_t* modifier){ 
    5630:	fb 01       	movw	r30, r22
	uint8_t code;

	if ((*modifier & HID_KEYBOARD_MODIFIER_LEFTALT) && FnKeyCodeLookUpTable[key]){ //if the FN key is held down, look up key in FN array.
    5632:	90 81       	ld	r25, Z
    5634:	28 2f       	mov	r18, r24
    5636:	30 e0       	ldi	r19, 0x00	; 0
    5638:	92 ff       	sbrs	r25, 2
    563a:	08 c0       	rjmp	.+16     	; 0x564c <GetHIDKeyCode+0x1c>
    563c:	d9 01       	movw	r26, r18
    563e:	a6 57       	subi	r26, 0x76	; 118
    5640:	b6 4f       	sbci	r27, 0xF6	; 246
    5642:	8c 91       	ld	r24, X
    5644:	88 23       	and	r24, r24
    5646:	11 f0       	breq	.+4      	; 0x564c <GetHIDKeyCode+0x1c>
		code = FnKeyCodeLookUpTable[key];
		*modifier &= ~HID_KEYBOARD_MODIFIER_LEFTALT;// if the key is in the function table, it is a special key.  The alt modifier should not be sent..
    5648:	9b 7f       	andi	r25, 0xFB	; 251
    564a:	09 c0       	rjmp	.+18     	; 0x565e <GetHIDKeyCode+0x2e>

	}
	else if ((*modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT) && ShiftKeyCodeLookUpTable[key]){
    564c:	91 ff       	sbrs	r25, 1
    564e:	09 c0       	rjmp	.+18     	; 0x5662 <GetHIDKeyCode+0x32>
    5650:	d9 01       	movw	r26, r18
    5652:	a7 57       	subi	r26, 0x77	; 119
    5654:	b9 4f       	sbci	r27, 0xF9	; 249
    5656:	8c 91       	ld	r24, X
    5658:	88 23       	and	r24, r24
    565a:	19 f0       	breq	.+6      	; 0x5662 <GetHIDKeyCode+0x32>
		code = ShiftKeyCodeLookUpTable[key];
		*modifier &= ~HID_KEYBOARD_MODIFIER_LEFTSHIFT;// if the key is in the shift table, it is a special key.  The shift modifier should not be sent..
    565c:	9d 7f       	andi	r25, 0xFD	; 253
    565e:	90 83       	st	Z, r25
    5660:	08 95       	ret
	}
	else {
		code = KeyCodeLookUpTable[key]; //otherwise, look up the key in the regular array.
    5662:	f9 01       	movw	r30, r18
    5664:	e4 5c       	subi	r30, 0xC4	; 196
    5666:	f9 4f       	sbci	r31, 0xF9	; 249
    5668:	80 81       	ld	r24, Z
	}
	return code;
}
    566a:	08 95       	ret

0000566c <GetASCIIKeyCode>:

uint8_t GetASCIIKeyCode(uint8_t key, uint8_t modifier){
	uint8_t code;
	
	if(key == 0){
    566c:	88 23       	and	r24, r24
    566e:	79 f0       	breq	.+30     	; 0x568e <GetASCIIKeyCode+0x22>
    5670:	28 2f       	mov	r18, r24
    5672:	30 e0       	ldi	r19, 0x00	; 0
		return 0;
	}
	
	if ((modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT) && ASCIIShiftLookUpTable[key]){
    5674:	61 ff       	sbrs	r22, 1
    5676:	06 c0       	rjmp	.+12     	; 0x5684 <GetASCIIKeyCode+0x18>
    5678:	f9 01       	movw	r30, r18
    567a:	e6 53       	subi	r30, 0x36	; 54
    567c:	f9 4f       	sbci	r31, 0xF9	; 249
    567e:	80 81       	ld	r24, Z
    5680:	81 11       	cpse	r24, r1
    5682:	06 c0       	rjmp	.+12     	; 0x5690 <GetASCIIKeyCode+0x24>
		code = ASCIIShiftLookUpTable[key];
		}
	else {
		code = ASCIILookUpTable[key];
    5684:	f9 01       	movw	r30, r18
    5686:	e7 5b       	subi	r30, 0xB7	; 183
    5688:	f8 4f       	sbci	r31, 0xF8	; 248
    568a:	80 81       	ld	r24, Z
    568c:	08 95       	ret

uint8_t GetASCIIKeyCode(uint8_t key, uint8_t modifier){
	uint8_t code;
	
	if(key == 0){
		return 0;
    568e:	80 e0       	ldi	r24, 0x00	; 0
		}
	else {
		code = ASCIILookUpTable[key];
	}
	return code;
}
    5690:	08 95       	ret

00005692 <getHallState>:

bool getHallState(){ //don't call this function from inside ReadSensor !  It will cause an infinite loop...
    5692:	0f 93       	push	r16
	bool hallstate;
	hallstate = (ReadSensor() & LONGLONGBIT(HALL_SENSOR_BIT));
    5694:	b5 dd       	rcall	.-1174   	; 0x5200 <ReadSensor>
    5696:	0c e2       	ldi	r16, 0x2C	; 44
    5698:	0e 94 c9 35 	call	0x6b92	; 0x6b92 <__lshrdi3>
	return hallstate;
}
    569c:	82 2f       	mov	r24, r18
    569e:	81 70       	andi	r24, 0x01	; 1
    56a0:	0f 91       	pop	r16
    56a2:	08 95       	ret

000056a4 <LoadKeyCodeTables>:

	

void LoadKeyCodeTables(){
	 eeprom_read_block (( void *) KeyCodeLookUpTable, (void *) KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    56a4:	40 e4       	ldi	r20, 0x40	; 64
    56a6:	50 e0       	ldi	r21, 0x00	; 0
    56a8:	60 e0       	ldi	r22, 0x00	; 0
    56aa:	70 e0       	ldi	r23, 0x00	; 0
    56ac:	8c e3       	ldi	r24, 0x3C	; 60
    56ae:	96 e0       	ldi	r25, 0x06	; 6
    56b0:	0e 94 19 39 	call	0x7232	; 0x7232 <eeprom_read_block>
	 eeprom_read_block (( void *) FnKeyCodeLookUpTable, (void *) FN_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    56b4:	40 e4       	ldi	r20, 0x40	; 64
    56b6:	50 e0       	ldi	r21, 0x00	; 0
    56b8:	60 e4       	ldi	r22, 0x40	; 64
    56ba:	70 e0       	ldi	r23, 0x00	; 0
    56bc:	8a e8       	ldi	r24, 0x8A	; 138
    56be:	99 e0       	ldi	r25, 0x09	; 9
    56c0:	0e 94 19 39 	call	0x7232	; 0x7232 <eeprom_read_block>
	 eeprom_read_block (( void *) ShiftKeyCodeLookUpTable, (void *) SHIFT_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    56c4:	40 e4       	ldi	r20, 0x40	; 64
    56c6:	50 e0       	ldi	r21, 0x00	; 0
    56c8:	60 e8       	ldi	r22, 0x80	; 128
    56ca:	70 e0       	ldi	r23, 0x00	; 0
    56cc:	89 e8       	ldi	r24, 0x89	; 137
    56ce:	96 e0       	ldi	r25, 0x06	; 6
    56d0:	0e 94 19 39 	call	0x7232	; 0x7232 <eeprom_read_block>
	 eeprom_read_block (( void *) ASCIILookUpTable, (void *) ASCII_ADDR, KEYCODE_ARRAY_LENGTH);
    56d4:	40 e4       	ldi	r20, 0x40	; 64
    56d6:	50 e0       	ldi	r21, 0x00	; 0
    56d8:	60 ec       	ldi	r22, 0xC0	; 192
    56da:	70 e0       	ldi	r23, 0x00	; 0
    56dc:	89 e4       	ldi	r24, 0x49	; 73
    56de:	97 e0       	ldi	r25, 0x07	; 7
    56e0:	0e 94 19 39 	call	0x7232	; 0x7232 <eeprom_read_block>
	 eeprom_read_block (( void *) ASCIIShiftLookUpTable, (void *) ASCII_SHIFT_ADDR, KEYCODE_ARRAY_LENGTH);
    56e4:	40 e4       	ldi	r20, 0x40	; 64
    56e6:	50 e0       	ldi	r21, 0x00	; 0
    56e8:	60 e0       	ldi	r22, 0x00	; 0
    56ea:	71 e0       	ldi	r23, 0x01	; 1
    56ec:	8a ec       	ldi	r24, 0xCA	; 202
    56ee:	96 e0       	ldi	r25, 0x06	; 6
    56f0:	0c 94 19 39 	jmp	0x7232	; 0x7232 <eeprom_read_block>

000056f4 <LoadEepromParameters>:

}

void LoadEepromParameters(){	
	 KeyReleaseTime = eeprom_read_byte((uint8_t *)RELEASE_TIME_ADDR);
    56f4:	82 e0       	ldi	r24, 0x02	; 2
    56f6:	92 e0       	ldi	r25, 0x02	; 2
    56f8:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    56fc:	80 93 3a 06 	sts	0x063A, r24
	 KeyHoldTime = eeprom_read_byte((uint8_t *)HOLD_TIME_ADDR);
    5700:	81 e0       	ldi	r24, 0x01	; 1
    5702:	92 e0       	ldi	r25, 0x02	; 2
    5704:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    5708:	80 93 c9 06 	sts	0x06C9, r24
	 DoubleTapTime = eeprom_read_byte((uint8_t *)DOUBLE_TAP_ADDR);
    570c:	80 e0       	ldi	r24, 0x00	; 0
    570e:	92 e0       	ldi	r25, 0x02	; 2
    5710:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    5714:	80 93 7d 06 	sts	0x067D, r24
	 ReedHoldTime = eeprom_read_byte((uint8_t *)REED_HOLD_TIME_ADDR);
    5718:	8c e0       	ldi	r24, 0x0C	; 12
    571a:	92 e0       	ldi	r25, 0x02	; 2
    571c:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    5720:	80 93 7c 06 	sts	0x067C, r24
	 UseHallSensor = eeprom_read_byte((uint8_t *)USE_HALL_SENSOR_ADDR);
    5724:	83 e0       	ldi	r24, 0x03	; 3
    5726:	92 e0       	ldi	r25, 0x02	; 2
    5728:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    572c:	80 93 0b 07 	sts	0x070B, r24
	 HallSensorPolarity = eeprom_read_byte((uint8_t *)HALL_SENSOR_POLARITY_ADDR);
    5730:	84 e0       	ldi	r24, 0x04	; 4
    5732:	92 e0       	ldi	r25, 0x02	; 2
    5734:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    5738:	80 93 86 06 	sts	0x0686, r24
	 Shift_Reed = eeprom_read_byte((uint8_t *)SHIFT_REED_ADDR);
    573c:	85 e0       	ldi	r24, 0x05	; 5
    573e:	92 e0       	ldi	r25, 0x02	; 2
    5740:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    5744:	80 93 7e 06 	sts	0x067E, r24
	 Reeds_Are_Independent = eeprom_read_byte((uint8_t *)REEDS_INDEPENDENT_ADDR);
    5748:	8e e0       	ldi	r24, 0x0E	; 14
    574a:	92 e0       	ldi	r25, 0x02	; 2
    574c:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    5750:	80 93 38 06 	sts	0x0638, r24
	 UseDummyLoad = eeprom_read_byte((uint8_t*)DUMMY_LOAD_ADDR);
    5754:	8f e0       	ldi	r24, 0x0F	; 15
    5756:	92 e0       	ldi	r25, 0x02	; 2
    5758:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    575c:	80 93 37 06 	sts	0x0637, r24
    5760:	08 95       	ret

00005762 <ClearKeyCodeTables>:
//	 BluetoothConfigured = eeprom_read_byte((uint8_t*)BLUETOOTH_CONFIGURED_ADDR);
}

void ClearKeyCodeTables(){
	memset (&KeyCodeLookUpTable[0] , 0, KEYCODE_ARRAY_LENGTH);
    5762:	80 e4       	ldi	r24, 0x40	; 64
    5764:	ec e3       	ldi	r30, 0x3C	; 60
    5766:	f6 e0       	ldi	r31, 0x06	; 6
    5768:	df 01       	movw	r26, r30
    576a:	98 2f       	mov	r25, r24
    576c:	1d 92       	st	X+, r1
    576e:	9a 95       	dec	r25
    5770:	e9 f7       	brne	.-6      	; 0x576c <ClearKeyCodeTables+0xa>
	memset (&FnKeyCodeLookUpTable[0] , 0, KEYCODE_ARRAY_LENGTH);
    5772:	ea e8       	ldi	r30, 0x8A	; 138
    5774:	f9 e0       	ldi	r31, 0x09	; 9
    5776:	df 01       	movw	r26, r30
    5778:	98 2f       	mov	r25, r24
    577a:	1d 92       	st	X+, r1
    577c:	9a 95       	dec	r25
    577e:	e9 f7       	brne	.-6      	; 0x577a <ClearKeyCodeTables+0x18>
	memset (&ShiftKeyCodeLookUpTable[0], 0, KEYCODE_ARRAY_LENGTH);
    5780:	e9 e8       	ldi	r30, 0x89	; 137
    5782:	f6 e0       	ldi	r31, 0x06	; 6
    5784:	df 01       	movw	r26, r30
    5786:	98 2f       	mov	r25, r24
    5788:	1d 92       	st	X+, r1
    578a:	9a 95       	dec	r25
    578c:	e9 f7       	brne	.-6      	; 0x5788 <ClearKeyCodeTables+0x26>
	memset (&ASCIILookUpTable[0],0,KEYCODE_ARRAY_LENGTH);
    578e:	e9 e4       	ldi	r30, 0x49	; 73
    5790:	f7 e0       	ldi	r31, 0x07	; 7
    5792:	df 01       	movw	r26, r30
    5794:	98 2f       	mov	r25, r24
    5796:	1d 92       	st	X+, r1
    5798:	9a 95       	dec	r25
    579a:	e9 f7       	brne	.-6      	; 0x5796 <ClearKeyCodeTables+0x34>
	memset (&ASCIIShiftLookUpTable[0],0,KEYCODE_ARRAY_LENGTH);
    579c:	ea ec       	ldi	r30, 0xCA	; 202
    579e:	f6 e0       	ldi	r31, 0x06	; 6
    57a0:	df 01       	movw	r26, r30
    57a2:	1d 92       	st	X+, r1
    57a4:	8a 95       	dec	r24
    57a6:	e9 f7       	brne	.-6      	; 0x57a2 <ClearKeyCodeTables+0x40>

	Shift_Reed = 0;
    57a8:	10 92 7e 06 	sts	0x067E, r1
    57ac:	08 95       	ret

000057ae <RestoreFactoryDefaults>:
		eeprom_write_byte((uint8_t*)EEP_CHECKSUM_ADDR, EEP_CHECKSUM);//write the checksum to the eeprom to indicate that eeprom has been properly initialized.
	}
}

void RestoreFactoryDefaults(){
			eeprom_update_byte((uint8_t*)DOUBLE_TAP_ADDR, DEFAULT_DOUBLE_TAP_TIME);
    57ae:	65 e0       	ldi	r22, 0x05	; 5
    57b0:	80 e0       	ldi	r24, 0x00	; 0
    57b2:	92 e0       	ldi	r25, 0x02	; 2
    57b4:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)HOLD_TIME_ADDR, DEFAULT_HOLD_TIME);
    57b8:	66 e0       	ldi	r22, 0x06	; 6
    57ba:	81 e0       	ldi	r24, 0x01	; 1
    57bc:	92 e0       	ldi	r25, 0x02	; 2
    57be:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)RELEASE_TIME_ADDR, DEFAULT_RELEASE_TIME);
    57c2:	63 e0       	ldi	r22, 0x03	; 3
    57c4:	82 e0       	ldi	r24, 0x02	; 2
    57c6:	92 e0       	ldi	r25, 0x02	; 2
    57c8:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)REED_HOLD_TIME_ADDR, DEFAULT_REED_HOLD_TIME);
    57cc:	63 e0       	ldi	r22, 0x03	; 3
    57ce:	8c e0       	ldi	r24, 0x0C	; 12
    57d0:	92 e0       	ldi	r25, 0x02	; 2
    57d2:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)REEDS_INDEPENDENT_ADDR,REEDS_ARE_INDEPENDENT_BY_DEFAULT);
    57d6:	60 e0       	ldi	r22, 0x00	; 0
    57d8:	8e e0       	ldi	r24, 0x0E	; 14
    57da:	92 e0       	ldi	r25, 0x02	; 2
    57dc:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)DEFAULT_MODE_ADDR,USB_COMBO_MODE);
    57e0:	61 e0       	ldi	r22, 0x01	; 1
    57e2:	8d e0       	ldi	r24, 0x0D	; 13
    57e4:	92 e0       	ldi	r25, 0x02	; 2
    57e6:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)DUMMY_LOAD_ADDR,0); //do not use dummy load unless told to.
    57ea:	60 e0       	ldi	r22, 0x00	; 0
    57ec:	8f e0       	ldi	r24, 0x0F	; 15
    57ee:	92 e0       	ldi	r25, 0x02	; 2
    57f0:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
			eeprom_write_word((uint16_t *)FILENUM_ADDR,0);//reset sd card file number to zero.
    57f4:	60 e0       	ldi	r22, 0x00	; 0
    57f6:	70 e0       	ldi	r23, 0x00	; 0
    57f8:	8a e0       	ldi	r24, 0x0A	; 10
    57fa:	92 e0       	ldi	r25, 0x02	; 2
    57fc:	0e 94 5f 39 	call	0x72be	; 0x72be <eeprom_write_word>
			eeprom_write_byte((uint8_t*)USE_HALL_SENSOR_ADDR,HALL_NOT_PRESENT);
    5800:	60 e0       	ldi	r22, 0x00	; 0
    5802:	83 e0       	ldi	r24, 0x03	; 3
    5804:	92 e0       	ldi	r25, 0x02	; 2
    5806:	0e 94 51 39 	call	0x72a2	; 0x72a2 <eeprom_write_byte>
			
			LoadEepromParameters(); //load new defaults into RAM
    580a:	74 cf       	rjmp	.-280    	; 0x56f4 <LoadEepromParameters>

0000580c <InitializeEeprom>:

	Shift_Reed = 0;
//	UseHallSensor = HALL_NOT_PRESENT;	
}

void InitializeEeprom(){
    580c:	cf 93       	push	r28
    580e:	df 93       	push	r29
	int i;
	if (eeprom_read_byte((uint8_t*)EEP_CHECKSUM_ADDR) != EEP_CHECKSUM){
    5810:	8f ef       	ldi	r24, 0xFF	; 255
    5812:	93 e0       	ldi	r25, 0x03	; 3
    5814:	0e 94 29 39 	call	0x7252	; 0x7252 <eeprom_read_byte>
    5818:	87 34       	cpi	r24, 0x47	; 71
    581a:	f1 f0       	breq	.+60     	; 0x5858 <InitializeEeprom+0x4c>
    581c:	c0 e0       	ldi	r28, 0x00	; 0
    581e:	d0 e0       	ldi	r29, 0x00	; 0
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
    5820:	60 e0       	ldi	r22, 0x00	; 0
    5822:	ce 01       	movw	r24, r28
    5824:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>

void InitializeEeprom(){
	int i;
	if (eeprom_read_byte((uint8_t*)EEP_CHECKSUM_ADDR) != EEP_CHECKSUM){
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
    5828:	21 96       	adiw	r28, 0x01	; 1
    582a:	c1 35       	cpi	r28, 0x51	; 81
    582c:	81 e0       	ldi	r24, 0x01	; 1
    582e:	d8 07       	cpc	r29, r24
    5830:	b9 f7       	brne	.-18     	; 0x5820 <InitializeEeprom+0x14>
    5832:	c0 e0       	ldi	r28, 0x00	; 0
    5834:	d2 e0       	ldi	r29, 0x02	; 2
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		for(i=EEP_BANK2; i<=EEP_BANK2_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
    5836:	60 e0       	ldi	r22, 0x00	; 0
    5838:	ce 01       	movw	r24, r28
    583a:	0e 94 36 39 	call	0x726c	; 0x726c <eeprom_update_byte>
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		for(i=EEP_BANK2; i<=EEP_BANK2_END; i++){
    583e:	21 96       	adiw	r28, 0x01	; 1
    5840:	c2 31       	cpi	r28, 0x12	; 18
    5842:	82 e0       	ldi	r24, 0x02	; 2
    5844:	d8 07       	cpc	r29, r24
    5846:	b9 f7       	brne	.-18     	; 0x5836 <InitializeEeprom+0x2a>
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		RestoreFactoryDefaults();
    5848:	b2 df       	rcall	.-156    	; 0x57ae <RestoreFactoryDefaults>

		eeprom_write_byte((uint8_t*)EEP_CHECKSUM_ADDR, EEP_CHECKSUM);//write the checksum to the eeprom to indicate that eeprom has been properly initialized.
    584a:	67 e4       	ldi	r22, 0x47	; 71
    584c:	8f ef       	ldi	r24, 0xFF	; 255
    584e:	93 e0       	ldi	r25, 0x03	; 3
	}
}
    5850:	df 91       	pop	r29
    5852:	cf 91       	pop	r28
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		RestoreFactoryDefaults();

		eeprom_write_byte((uint8_t*)EEP_CHECKSUM_ADDR, EEP_CHECKSUM);//write the checksum to the eeprom to indicate that eeprom has been properly initialized.
    5854:	0c 94 51 39 	jmp	0x72a2	; 0x72a2 <eeprom_write_byte>
	}
}
    5858:	df 91       	pop	r29
    585a:	cf 91       	pop	r28
    585c:	08 95       	ret

0000585e <HID_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_HID_DRIVER
#define  __INCLUDE_FROM_HID_DEVICE_C
#include "HIDClassDevice.h"

void HID_Device_ProcessControlRequest(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
    585e:	6f 92       	push	r6
    5860:	7f 92       	push	r7
    5862:	8f 92       	push	r8
    5864:	9f 92       	push	r9
    5866:	af 92       	push	r10
    5868:	bf 92       	push	r11
    586a:	cf 92       	push	r12
    586c:	df 92       	push	r13
    586e:	ef 92       	push	r14
    5870:	ff 92       	push	r15
    5872:	0f 93       	push	r16
    5874:	1f 93       	push	r17
    5876:	cf 93       	push	r28
    5878:	df 93       	push	r29
    587a:	00 d0       	rcall	.+0      	; 0x587c <HID_Device_ProcessControlRequest+0x1e>
    587c:	1f 92       	push	r1
    587e:	cd b7       	in	r28, 0x3d	; 61
    5880:	de b7       	in	r29, 0x3e	; 62
    5882:	7c 01       	movw	r14, r24
				Endpoint_ClearStatusStage();
			}

			break;
	}
}
    5884:	cd b6       	in	r12, 0x3d	; 61
    5886:	de b6       	in	r13, 0x3e	; 62
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5888:	80 91 e8 00 	lds	r24, 0x00E8
#define  __INCLUDE_FROM_HID_DEVICE_C
#include "HIDClassDevice.h"

void HID_Device_ProcessControlRequest(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	if (!(Endpoint_IsSETUPReceived()))
    588c:	83 ff       	sbrs	r24, 3
    588e:	0a c1       	rjmp	.+532    	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
	  return;

	if (USB_ControlRequest.wIndex != HIDInterfaceInfo->Config.InterfaceNumber)
    5890:	f7 01       	movw	r30, r14
    5892:	80 81       	ld	r24, Z
    5894:	90 e0       	ldi	r25, 0x00	; 0
    5896:	20 91 d3 09 	lds	r18, 0x09D3
    589a:	30 91 d4 09 	lds	r19, 0x09D4
    589e:	28 17       	cp	r18, r24
    58a0:	39 07       	cpc	r19, r25
    58a2:	09 f0       	breq	.+2      	; 0x58a6 <HID_Device_ProcessControlRequest+0x48>
    58a4:	ff c0       	rjmp	.+510    	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
	  return;

	switch (USB_ControlRequest.bRequest)
    58a6:	80 91 d0 09 	lds	r24, 0x09D0
    58aa:	83 30       	cpi	r24, 0x03	; 3
    58ac:	09 f4       	brne	.+2      	; 0x58b0 <HID_Device_ProcessControlRequest+0x52>
    58ae:	a1 c0       	rjmp	.+322    	; 0x59f2 <HID_Device_ProcessControlRequest+0x194>
    58b0:	30 f4       	brcc	.+12     	; 0x58be <HID_Device_ProcessControlRequest+0x60>
    58b2:	81 30       	cpi	r24, 0x01	; 1
    58b4:	71 f0       	breq	.+28     	; 0x58d2 <HID_Device_ProcessControlRequest+0x74>
    58b6:	82 30       	cpi	r24, 0x02	; 2
    58b8:	09 f4       	brne	.+2      	; 0x58bc <HID_Device_ProcessControlRequest+0x5e>
    58ba:	d8 c0       	rjmp	.+432    	; 0x5a6c <HID_Device_ProcessControlRequest+0x20e>
    58bc:	f3 c0       	rjmp	.+486    	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
    58be:	8a 30       	cpi	r24, 0x0A	; 10
    58c0:	09 f4       	brne	.+2      	; 0x58c4 <HID_Device_ProcessControlRequest+0x66>
    58c2:	bc c0       	rjmp	.+376    	; 0x5a3c <HID_Device_ProcessControlRequest+0x1de>
    58c4:	8b 30       	cpi	r24, 0x0B	; 11
    58c6:	09 f4       	brne	.+2      	; 0x58ca <HID_Device_ProcessControlRequest+0x6c>
    58c8:	a5 c0       	rjmp	.+330    	; 0x5a14 <HID_Device_ProcessControlRequest+0x1b6>
    58ca:	89 30       	cpi	r24, 0x09	; 9
    58cc:	09 f0       	breq	.+2      	; 0x58d0 <HID_Device_ProcessControlRequest+0x72>
    58ce:	ea c0       	rjmp	.+468    	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
    58d0:	53 c0       	rjmp	.+166    	; 0x5978 <HID_Device_ProcessControlRequest+0x11a>
	{
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    58d2:	80 91 cf 09 	lds	r24, 0x09CF
    58d6:	81 3a       	cpi	r24, 0xA1	; 161
    58d8:	09 f0       	breq	.+2      	; 0x58dc <HID_Device_ProcessControlRequest+0x7e>
    58da:	e4 c0       	rjmp	.+456    	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
    58dc:	8d b6       	in	r8, 0x3d	; 61
    58de:	9e b6       	in	r9, 0x3e	; 62
			{
				uint16_t ReportSize = 0;
    58e0:	1a 82       	std	Y+2, r1	; 0x02
    58e2:	19 82       	std	Y+1, r1	; 0x01
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
    58e4:	80 91 d1 09 	lds	r24, 0x09D1
    58e8:	10 91 d2 09 	lds	r17, 0x09D2
    58ec:	8b 83       	std	Y+3, r24	; 0x03
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
				uint8_t  ReportData[HIDInterfaceInfo->Config.PrevReportINBufferSize];
    58ee:	f7 01       	movw	r30, r14
    58f0:	80 85       	ldd	r24, Z+8	; 0x08
    58f2:	48 2f       	mov	r20, r24
    58f4:	50 e0       	ldi	r21, 0x00	; 0
    58f6:	8d b7       	in	r24, 0x3d	; 61
    58f8:	9e b7       	in	r25, 0x3e	; 62
    58fa:	84 1b       	sub	r24, r20
    58fc:	95 0b       	sbc	r25, r21
    58fe:	0f b6       	in	r0, 0x3f	; 63
    5900:	f8 94       	cli
    5902:	9e bf       	out	0x3e, r25	; 62
    5904:	0f be       	out	0x3f, r0	; 63
    5906:	8d bf       	out	0x3d, r24	; 61
    5908:	ed b7       	in	r30, 0x3d	; 61
    590a:	fe b7       	in	r31, 0x3e	; 62
    590c:	31 96       	adiw	r30, 0x01	; 1
    590e:	5f 01       	movw	r10, r30

				memset(ReportData, 0, sizeof(ReportData));
    5910:	60 e0       	ldi	r22, 0x00	; 0
    5912:	70 e0       	ldi	r23, 0x00	; 0
    5914:	cf 01       	movw	r24, r30
    5916:	0e 94 55 36 	call	0x6caa	; 0x6caa <memset>
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				uint16_t ReportSize = 0;
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
    591a:	4f ef       	ldi	r20, 0xFF	; 255
    591c:	41 0f       	add	r20, r17
				uint8_t  ReportData[HIDInterfaceInfo->Config.PrevReportINBufferSize];

				memset(ReportData, 0, sizeof(ReportData));

				CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, ReportType, ReportData, &ReportSize);
    591e:	8e 01       	movw	r16, r28
    5920:	0f 5f       	subi	r16, 0xFF	; 255
    5922:	1f 4f       	sbci	r17, 0xFF	; 255
    5924:	95 01       	movw	r18, r10
    5926:	be 01       	movw	r22, r28
    5928:	6d 5f       	subi	r22, 0xFD	; 253
    592a:	7f 4f       	sbci	r23, 0xFF	; 255
    592c:	c7 01       	movw	r24, r14
    592e:	1a d9       	rcall	.-3532   	; 0x4b64 <CALLBACK_HID_Device_CreateHIDReport>

				if (HIDInterfaceInfo->Config.PrevReportINBuffer != NULL)
    5930:	f7 01       	movw	r30, r14
    5932:	86 81       	ldd	r24, Z+6	; 0x06
    5934:	97 81       	ldd	r25, Z+7	; 0x07
    5936:	00 97       	sbiw	r24, 0x00	; 0
    5938:	29 f0       	breq	.+10     	; 0x5944 <HID_Device_ProcessControlRequest+0xe6>
				{
					memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportData,
    593a:	40 85       	ldd	r20, Z+8	; 0x08
    593c:	50 e0       	ldi	r21, 0x00	; 0
    593e:	b5 01       	movw	r22, r10
    5940:	0e 94 4c 36 	call	0x6c98	; 0x6c98 <memcpy>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5944:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5948:	80 91 e8 00 	lds	r24, 0x00E8
    594c:	87 7f       	andi	r24, 0xF7	; 247
    594e:	80 93 e8 00 	sts	0x00E8, r24

				Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

				Endpoint_ClearSETUP();

				if (ReportID)
    5952:	8b 81       	ldd	r24, Y+3	; 0x03
    5954:	81 11       	cpse	r24, r1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5956:	80 93 f1 00 	sts	0x00F1, r24
				  Endpoint_Write_8(ReportID);

				Endpoint_Write_Control_Stream_LE(ReportData, ReportSize);
    595a:	69 81       	ldd	r22, Y+1	; 0x01
    595c:	7a 81       	ldd	r23, Y+2	; 0x02
    595e:	c5 01       	movw	r24, r10
    5960:	2b d4       	rcall	.+2134   	; 0x61b8 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    5962:	80 91 e8 00 	lds	r24, 0x00E8
    5966:	8b 77       	andi	r24, 0x7B	; 123
    5968:	80 93 e8 00 	sts	0x00E8, r24
    596c:	0f b6       	in	r0, 0x3f	; 63
    596e:	f8 94       	cli
    5970:	9e be       	out	0x3e, r9	; 62
    5972:	0f be       	out	0x3f, r0	; 63
    5974:	8d be       	out	0x3d, r8	; 61
    5976:	96 c0       	rjmp	.+300    	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
				Endpoint_ClearOUT();
			}

			break;
		case HID_REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5978:	80 91 cf 09 	lds	r24, 0x09CF
    597c:	81 32       	cpi	r24, 0x21	; 33
    597e:	09 f0       	breq	.+2      	; 0x5982 <HID_Device_ProcessControlRequest+0x124>
    5980:	91 c0       	rjmp	.+290    	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
    5982:	ad b6       	in	r10, 0x3d	; 61
    5984:	be b6       	in	r11, 0x3e	; 62
			{
				uint16_t ReportSize = USB_ControlRequest.wLength;
    5986:	00 91 d5 09 	lds	r16, 0x09D5
    598a:	10 91 d6 09 	lds	r17, 0x09D6
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
    598e:	70 90 d1 09 	lds	r7, 0x09D1
    5992:	60 90 d2 09 	lds	r6, 0x09D2
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
				uint8_t  ReportData[ReportSize];
    5996:	8d b7       	in	r24, 0x3d	; 61
    5998:	9e b7       	in	r25, 0x3e	; 62
    599a:	80 1b       	sub	r24, r16
    599c:	91 0b       	sbc	r25, r17
    599e:	0f b6       	in	r0, 0x3f	; 63
    59a0:	f8 94       	cli
    59a2:	9e bf       	out	0x3e, r25	; 62
    59a4:	0f be       	out	0x3f, r0	; 63
    59a6:	8d bf       	out	0x3d, r24	; 61
    59a8:	ed b7       	in	r30, 0x3d	; 61
    59aa:	fe b7       	in	r31, 0x3e	; 62
    59ac:	31 96       	adiw	r30, 0x01	; 1
    59ae:	4f 01       	movw	r8, r30
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    59b0:	80 91 e8 00 	lds	r24, 0x00E8
    59b4:	87 7f       	andi	r24, 0xF7	; 247
    59b6:	80 93 e8 00 	sts	0x00E8, r24

				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(ReportData, ReportSize);
    59ba:	b8 01       	movw	r22, r16
    59bc:	cf 01       	movw	r24, r30
    59be:	5f d4       	rcall	.+2238   	; 0x627e <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    59c0:	80 91 e8 00 	lds	r24, 0x00E8
    59c4:	8e 77       	andi	r24, 0x7E	; 126
    59c6:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();

				CALLBACK_HID_Device_ProcessHIDReport(HIDInterfaceInfo, ReportID, ReportType,
    59ca:	21 e0       	ldi	r18, 0x01	; 1
    59cc:	71 10       	cpse	r7, r1
    59ce:	01 c0       	rjmp	.+2      	; 0x59d2 <HID_Device_ProcessControlRequest+0x174>
    59d0:	20 e0       	ldi	r18, 0x00	; 0
    59d2:	30 e0       	ldi	r19, 0x00	; 0
    59d4:	02 1b       	sub	r16, r18
    59d6:	13 0b       	sbc	r17, r19
				                                     &ReportData[ReportID ? 1 : 0], ReportSize - (ReportID ? 1 : 0));
    59d8:	28 0d       	add	r18, r8
    59da:	39 1d       	adc	r19, r9
		case HID_REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				uint16_t ReportSize = USB_ControlRequest.wLength;
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
    59dc:	4f ef       	ldi	r20, 0xFF	; 255
    59de:	46 0d       	add	r20, r6

				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(ReportData, ReportSize);
				Endpoint_ClearIN();

				CALLBACK_HID_Device_ProcessHIDReport(HIDInterfaceInfo, ReportID, ReportType,
    59e0:	67 2d       	mov	r22, r7
    59e2:	c7 01       	movw	r24, r14
    59e4:	e6 d8       	rcall	.-3636   	; 0x4bb2 <CALLBACK_HID_Device_ProcessHIDReport>
    59e6:	0f b6       	in	r0, 0x3f	; 63
    59e8:	f8 94       	cli
    59ea:	be be       	out	0x3e, r11	; 62
    59ec:	0f be       	out	0x3f, r0	; 63
    59ee:	ad be       	out	0x3d, r10	; 61
    59f0:	59 c0       	rjmp	.+178    	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
				                                     &ReportData[ReportID ? 1 : 0], ReportSize - (ReportID ? 1 : 0));
			}

			break;
		case HID_REQ_GetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    59f2:	80 91 cf 09 	lds	r24, 0x09CF
    59f6:	81 3a       	cpi	r24, 0xA1	; 161
    59f8:	09 f0       	breq	.+2      	; 0x59fc <HID_Device_ProcessControlRequest+0x19e>
    59fa:	54 c0       	rjmp	.+168    	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    59fc:	80 91 e8 00 	lds	r24, 0x00E8
    5a00:	87 7f       	andi	r24, 0xF7	; 247
    5a02:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5a06:	80 91 e8 00 	lds	r24, 0x00E8
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    5a0a:	80 ff       	sbrs	r24, 0
    5a0c:	fc cf       	rjmp	.-8      	; 0x5a06 <HID_Device_ProcessControlRequest+0x1a8>
				Endpoint_Write_8(HIDInterfaceInfo->State.UsingReportProtocol);
    5a0e:	f7 01       	movw	r30, r14
    5a10:	81 85       	ldd	r24, Z+9	; 0x09
    5a12:	40 c0       	rjmp	.+128    	; 0x5a94 <HID_Device_ProcessControlRequest+0x236>
				Endpoint_ClearStatusStage();
			}

			break;
		case HID_REQ_SetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5a14:	80 91 cf 09 	lds	r24, 0x09CF
    5a18:	81 32       	cpi	r24, 0x21	; 33
    5a1a:	09 f0       	breq	.+2      	; 0x5a1e <HID_Device_ProcessControlRequest+0x1c0>
    5a1c:	43 c0       	rjmp	.+134    	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5a1e:	80 91 e8 00 	lds	r24, 0x00E8
    5a22:	87 7f       	andi	r24, 0xF7	; 247
    5a24:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    5a28:	48 d5       	rcall	.+2704   	; 0x64ba <Endpoint_ClearStatusStage>

				HIDInterfaceInfo->State.UsingReportProtocol = ((USB_ControlRequest.wValue & 0xFF) != 0x00);
    5a2a:	90 91 d1 09 	lds	r25, 0x09D1
    5a2e:	81 e0       	ldi	r24, 0x01	; 1
    5a30:	91 11       	cpse	r25, r1
    5a32:	01 c0       	rjmp	.+2      	; 0x5a36 <HID_Device_ProcessControlRequest+0x1d8>
    5a34:	80 e0       	ldi	r24, 0x00	; 0
    5a36:	f7 01       	movw	r30, r14
    5a38:	81 87       	std	Z+9, r24	; 0x09
    5a3a:	34 c0       	rjmp	.+104    	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
			}

			break;
		case HID_REQ_SetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5a3c:	80 91 cf 09 	lds	r24, 0x09CF
    5a40:	81 32       	cpi	r24, 0x21	; 33
    5a42:	81 f5       	brne	.+96     	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
    5a44:	80 91 e8 00 	lds	r24, 0x00E8
    5a48:	87 7f       	andi	r24, 0xF7	; 247
    5a4a:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    5a4e:	35 d5       	rcall	.+2666   	; 0x64ba <Endpoint_ClearStatusStage>

				HIDInterfaceInfo->State.IdleCount = ((USB_ControlRequest.wValue & 0xFF00) >> 6);
    5a50:	80 91 d1 09 	lds	r24, 0x09D1
    5a54:	90 91 d2 09 	lds	r25, 0x09D2
    5a58:	88 27       	eor	r24, r24
    5a5a:	36 e0       	ldi	r19, 0x06	; 6
    5a5c:	96 95       	lsr	r25
    5a5e:	87 95       	ror	r24
    5a60:	3a 95       	dec	r19
    5a62:	e1 f7       	brne	.-8      	; 0x5a5c <HID_Device_ProcessControlRequest+0x1fe>
    5a64:	f7 01       	movw	r30, r14
    5a66:	95 87       	std	Z+13, r25	; 0x0d
    5a68:	84 87       	std	Z+12, r24	; 0x0c
    5a6a:	1c c0       	rjmp	.+56     	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
			}

			break;
		case HID_REQ_GetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    5a6c:	80 91 cf 09 	lds	r24, 0x09CF
    5a70:	81 3a       	cpi	r24, 0xA1	; 161
    5a72:	c1 f4       	brne	.+48     	; 0x5aa4 <HID_Device_ProcessControlRequest+0x246>
    5a74:	80 91 e8 00 	lds	r24, 0x00E8
    5a78:	87 7f       	andi	r24, 0xF7	; 247
    5a7a:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5a7e:	80 91 e8 00 	lds	r24, 0x00E8
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    5a82:	80 ff       	sbrs	r24, 0
    5a84:	fc cf       	rjmp	.-8      	; 0x5a7e <HID_Device_ProcessControlRequest+0x220>
				Endpoint_Write_8(HIDInterfaceInfo->State.IdleCount >> 2);
    5a86:	f7 01       	movw	r30, r14
    5a88:	84 85       	ldd	r24, Z+12	; 0x0c
    5a8a:	95 85       	ldd	r25, Z+13	; 0x0d
    5a8c:	96 95       	lsr	r25
    5a8e:	87 95       	ror	r24
    5a90:	96 95       	lsr	r25
    5a92:	87 95       	ror	r24
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5a94:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5a98:	80 91 e8 00 	lds	r24, 0x00E8
    5a9c:	8e 77       	andi	r24, 0x7E	; 126
    5a9e:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    5aa2:	0b d5       	rcall	.+2582   	; 0x64ba <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    5aa4:	0f b6       	in	r0, 0x3f	; 63
    5aa6:	f8 94       	cli
    5aa8:	de be       	out	0x3e, r13	; 62
    5aaa:	0f be       	out	0x3f, r0	; 63
    5aac:	cd be       	out	0x3d, r12	; 61
    5aae:	0f 90       	pop	r0
    5ab0:	0f 90       	pop	r0
    5ab2:	0f 90       	pop	r0
    5ab4:	df 91       	pop	r29
    5ab6:	cf 91       	pop	r28
    5ab8:	1f 91       	pop	r17
    5aba:	0f 91       	pop	r16
    5abc:	ff 90       	pop	r15
    5abe:	ef 90       	pop	r14
    5ac0:	df 90       	pop	r13
    5ac2:	cf 90       	pop	r12
    5ac4:	bf 90       	pop	r11
    5ac6:	af 90       	pop	r10
    5ac8:	9f 90       	pop	r9
    5aca:	8f 90       	pop	r8
    5acc:	7f 90       	pop	r7
    5ace:	6f 90       	pop	r6
    5ad0:	08 95       	ret

00005ad2 <HID_Device_ConfigureEndpoints>:

bool HID_Device_ConfigureEndpoints(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	memset(&HIDInterfaceInfo->State, 0x00, sizeof(HIDInterfaceInfo->State));
    5ad2:	fc 01       	movw	r30, r24
    5ad4:	39 96       	adiw	r30, 0x09	; 9
    5ad6:	27 e0       	ldi	r18, 0x07	; 7
    5ad8:	df 01       	movw	r26, r30
    5ada:	1d 92       	st	X+, r1
    5adc:	2a 95       	dec	r18
    5ade:	e9 f7       	brne	.-6      	; 0x5ada <HID_Device_ConfigureEndpoints+0x8>
	HIDInterfaceInfo->State.UsingReportProtocol = true;
    5ae0:	21 e0       	ldi	r18, 0x01	; 1
    5ae2:	fc 01       	movw	r30, r24
    5ae4:	21 87       	std	Z+9, r18	; 0x09
	HIDInterfaceInfo->State.IdleCount           = 500;
    5ae6:	24 ef       	ldi	r18, 0xF4	; 244
    5ae8:	31 e0       	ldi	r19, 0x01	; 1
    5aea:	35 87       	std	Z+13, r19	; 0x0d
    5aec:	24 87       	std	Z+12, r18	; 0x0c

	HIDInterfaceInfo->Config.ReportINEndpoint.Type = EP_TYPE_INTERRUPT;
    5aee:	23 e0       	ldi	r18, 0x03	; 3
    5af0:	24 83       	std	Z+4, r18	; 0x04

	if (!(Endpoint_ConfigureEndpointTable(&HIDInterfaceInfo->Config.ReportINEndpoint, 1)))
    5af2:	61 e0       	ldi	r22, 0x01	; 1
    5af4:	01 96       	adiw	r24, 0x01	; 1
    5af6:	99 c4       	rjmp	.+2354   	; 0x642a <Endpoint_ConfigureEndpointTable>

00005af8 <HID_Device_USBTask>:

	return true;
}

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
    5af8:	4f 92       	push	r4
    5afa:	5f 92       	push	r5
    5afc:	6f 92       	push	r6
    5afe:	7f 92       	push	r7
    5b00:	8f 92       	push	r8
    5b02:	9f 92       	push	r9
    5b04:	af 92       	push	r10
    5b06:	bf 92       	push	r11
    5b08:	cf 92       	push	r12
    5b0a:	df 92       	push	r13
    5b0c:	ef 92       	push	r14
    5b0e:	ff 92       	push	r15
    5b10:	0f 93       	push	r16
    5b12:	1f 93       	push	r17
    5b14:	cf 93       	push	r28
    5b16:	df 93       	push	r29
    5b18:	00 d0       	rcall	.+0      	; 0x5b1a <HID_Device_USBTask+0x22>
    5b1a:	1f 92       	push	r1
    5b1c:	cd b7       	in	r28, 0x3d	; 61
    5b1e:	de b7       	in	r29, 0x3e	; 62
    5b20:	7c 01       	movw	r14, r24
			Endpoint_ClearIN();
		}

		HIDInterfaceInfo->State.PrevFrameNum = USB_Device_GetFrameNumber();
	}
}
    5b22:	ad b6       	in	r10, 0x3d	; 61
    5b24:	be b6       	in	r11, 0x3e	; 62
	return true;
}

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	if (USB_DeviceState != DEVICE_STATE_Configured)
    5b26:	80 91 ce 09 	lds	r24, 0x09CE
    5b2a:	84 30       	cpi	r24, 0x04	; 4
    5b2c:	09 f0       	breq	.+2      	; 0x5b30 <HID_Device_USBTask+0x38>
    5b2e:	91 c0       	rjmp	.+290    	; 0x5c52 <HID_Device_USBTask+0x15a>
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    5b30:	80 91 e4 00 	lds	r24, 0x00E4
    5b34:	90 91 e5 00 	lds	r25, 0x00E5
	  return;

	if (HIDInterfaceInfo->State.PrevFrameNum == USB_Device_GetFrameNumber())
    5b38:	f7 01       	movw	r30, r14
    5b3a:	22 85       	ldd	r18, Z+10	; 0x0a
    5b3c:	33 85       	ldd	r19, Z+11	; 0x0b
    5b3e:	28 17       	cp	r18, r24
    5b40:	39 07       	cpc	r19, r25
    5b42:	09 f4       	brne	.+2      	; 0x5b46 <HID_Device_USBTask+0x4e>
    5b44:	86 c0       	rjmp	.+268    	; 0x5c52 <HID_Device_USBTask+0x15a>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5b46:	81 81       	ldd	r24, Z+1	; 0x01
    5b48:	8f 70       	andi	r24, 0x0F	; 15
    5b4a:	80 93 e9 00 	sts	0x00E9, r24
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    5b4e:	80 91 e8 00 	lds	r24, 0x00E8
		#endif
	}

	Endpoint_SelectEndpoint(HIDInterfaceInfo->Config.ReportINEndpoint.Address);

	if (Endpoint_IsReadWriteAllowed())
    5b52:	85 ff       	sbrs	r24, 5
    5b54:	7e c0       	rjmp	.+252    	; 0x5c52 <HID_Device_USBTask+0x15a>
    5b56:	8d b6       	in	r8, 0x3d	; 61
    5b58:	9e b6       	in	r9, 0x3e	; 62
	{
		uint8_t  ReportINData[HIDInterfaceInfo->Config.PrevReportINBufferSize];
    5b5a:	40 85       	ldd	r20, Z+8	; 0x08
    5b5c:	50 e0       	ldi	r21, 0x00	; 0
    5b5e:	8d b7       	in	r24, 0x3d	; 61
    5b60:	9e b7       	in	r25, 0x3e	; 62
    5b62:	84 1b       	sub	r24, r20
    5b64:	95 0b       	sbc	r25, r21
    5b66:	0f b6       	in	r0, 0x3f	; 63
    5b68:	f8 94       	cli
    5b6a:	9e bf       	out	0x3e, r25	; 62
    5b6c:	0f be       	out	0x3f, r0	; 63
    5b6e:	8d bf       	out	0x3d, r24	; 61
    5b70:	ed b7       	in	r30, 0x3d	; 61
    5b72:	fe b7       	in	r31, 0x3e	; 62
    5b74:	31 96       	adiw	r30, 0x01	; 1
    5b76:	6f 01       	movw	r12, r30
		uint8_t  ReportID     = 0;
    5b78:	1b 82       	std	Y+3, r1	; 0x03
		uint16_t ReportINSize = 0;
    5b7a:	1a 82       	std	Y+2, r1	; 0x02
    5b7c:	19 82       	std	Y+1, r1	; 0x01

		memset(ReportINData, 0, sizeof(ReportINData));
    5b7e:	60 e0       	ldi	r22, 0x00	; 0
    5b80:	70 e0       	ldi	r23, 0x00	; 0
    5b82:	cf 01       	movw	r24, r30
    5b84:	0e 94 55 36 	call	0x6caa	; 0x6caa <memset>

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
    5b88:	8e 01       	movw	r16, r28
    5b8a:	0f 5f       	subi	r16, 0xFF	; 255
    5b8c:	1f 4f       	sbci	r17, 0xFF	; 255
    5b8e:	96 01       	movw	r18, r12
    5b90:	40 e0       	ldi	r20, 0x00	; 0
    5b92:	be 01       	movw	r22, r28
    5b94:	6d 5f       	subi	r22, 0xFD	; 253
    5b96:	7f 4f       	sbci	r23, 0xFF	; 255
    5b98:	c7 01       	movw	r24, r14
    5b9a:	0e 94 b2 25 	call	0x4b64	; 0x4b64 <CALLBACK_HID_Device_CreateHIDReport>
    5b9e:	48 2e       	mov	r4, r24
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
		bool IdlePeriodElapsed = (HIDInterfaceInfo->State.IdleCount && !(HIDInterfaceInfo->State.IdleMSRemaining));
    5ba0:	f7 01       	movw	r30, r14
    5ba2:	84 85       	ldd	r24, Z+12	; 0x0c
    5ba4:	95 85       	ldd	r25, Z+13	; 0x0d
    5ba6:	89 2b       	or	r24, r25
    5ba8:	51 f0       	breq	.+20     	; 0x5bbe <HID_Device_USBTask+0xc6>
    5baa:	91 e0       	ldi	r25, 0x01	; 1
    5bac:	80 e0       	ldi	r24, 0x00	; 0
    5bae:	26 85       	ldd	r18, Z+14	; 0x0e
    5bb0:	37 85       	ldd	r19, Z+15	; 0x0f
    5bb2:	23 2b       	or	r18, r19
    5bb4:	09 f0       	breq	.+2      	; 0x5bb8 <HID_Device_USBTask+0xc0>
    5bb6:	90 e0       	ldi	r25, 0x00	; 0
    5bb8:	09 2f       	mov	r16, r25
    5bba:	18 2f       	mov	r17, r24
    5bbc:	02 c0       	rjmp	.+4      	; 0x5bc2 <HID_Device_USBTask+0xca>
    5bbe:	00 e0       	ldi	r16, 0x00	; 0
    5bc0:	10 e0       	ldi	r17, 0x00	; 0

		if (HIDInterfaceInfo->Config.PrevReportINBuffer != NULL)
    5bc2:	f7 01       	movw	r30, r14
    5bc4:	66 80       	ldd	r6, Z+6	; 0x06
    5bc6:	77 80       	ldd	r7, Z+7	; 0x07
    5bc8:	61 14       	cp	r6, r1
    5bca:	71 04       	cpc	r7, r1
    5bcc:	99 f0       	breq	.+38     	; 0x5bf4 <HID_Device_USBTask+0xfc>
		{
			StatesChanged = (memcmp(ReportINData, HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINSize) != 0);
    5bce:	49 81       	ldd	r20, Y+1	; 0x01
    5bd0:	5a 81       	ldd	r21, Y+2	; 0x02
    5bd2:	b3 01       	movw	r22, r6
    5bd4:	c6 01       	movw	r24, r12
    5bd6:	0e 94 3f 36 	call	0x6c7e	; 0x6c7e <memcmp>
    5bda:	55 24       	eor	r5, r5
    5bdc:	53 94       	inc	r5
    5bde:	89 2b       	or	r24, r25
    5be0:	09 f4       	brne	.+2      	; 0x5be4 <HID_Device_USBTask+0xec>
    5be2:	51 2c       	mov	r5, r1
			memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINData, HIDInterfaceInfo->Config.PrevReportINBufferSize);
    5be4:	f7 01       	movw	r30, r14
    5be6:	40 85       	ldd	r20, Z+8	; 0x08
    5be8:	50 e0       	ldi	r21, 0x00	; 0
    5bea:	b6 01       	movw	r22, r12
    5bec:	c3 01       	movw	r24, r6
    5bee:	0e 94 4c 36 	call	0x6c98	; 0x6c98 <memcpy>
    5bf2:	01 c0       	rjmp	.+2      	; 0x5bf6 <HID_Device_USBTask+0xfe>

		memset(ReportINData, 0, sizeof(ReportINData));

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
    5bf4:	51 2c       	mov	r5, r1
		{
			StatesChanged = (memcmp(ReportINData, HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINSize) != 0);
			memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINData, HIDInterfaceInfo->Config.PrevReportINBufferSize);
		}

		if (ReportINSize && (ForceSend || StatesChanged || IdlePeriodElapsed))
    5bf6:	89 81       	ldd	r24, Y+1	; 0x01
    5bf8:	9a 81       	ldd	r25, Y+2	; 0x02
    5bfa:	89 2b       	or	r24, r25
    5bfc:	f1 f0       	breq	.+60     	; 0x5c3a <HID_Device_USBTask+0x142>
    5bfe:	41 10       	cpse	r4, r1
    5c00:	04 c0       	rjmp	.+8      	; 0x5c0a <HID_Device_USBTask+0x112>
    5c02:	51 10       	cpse	r5, r1
    5c04:	02 c0       	rjmp	.+4      	; 0x5c0a <HID_Device_USBTask+0x112>
    5c06:	01 2b       	or	r16, r17
    5c08:	c1 f0       	breq	.+48     	; 0x5c3a <HID_Device_USBTask+0x142>
		{
			HIDInterfaceInfo->State.IdleMSRemaining = HIDInterfaceInfo->State.IdleCount;
    5c0a:	f7 01       	movw	r30, r14
    5c0c:	84 85       	ldd	r24, Z+12	; 0x0c
    5c0e:	95 85       	ldd	r25, Z+13	; 0x0d
    5c10:	97 87       	std	Z+15, r25	; 0x0f
    5c12:	86 87       	std	Z+14, r24	; 0x0e
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5c14:	81 81       	ldd	r24, Z+1	; 0x01
    5c16:	8f 70       	andi	r24, 0x0F	; 15
    5c18:	80 93 e9 00 	sts	0x00E9, r24

			Endpoint_SelectEndpoint(HIDInterfaceInfo->Config.ReportINEndpoint.Address);

			if (ReportID)
    5c1c:	8b 81       	ldd	r24, Y+3	; 0x03
    5c1e:	81 11       	cpse	r24, r1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5c20:	80 93 f1 00 	sts	0x00F1, r24
			  Endpoint_Write_8(ReportID);

			Endpoint_Write_Stream_LE(ReportINData, ReportINSize, NULL);
    5c24:	69 81       	ldd	r22, Y+1	; 0x01
    5c26:	7a 81       	ldd	r23, Y+2	; 0x02
    5c28:	40 e0       	ldi	r20, 0x00	; 0
    5c2a:	50 e0       	ldi	r21, 0x00	; 0
    5c2c:	c6 01       	movw	r24, r12
    5c2e:	e0 d1       	rcall	.+960    	; 0x5ff0 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5c30:	80 91 e8 00 	lds	r24, 0x00E8
    5c34:	8e 77       	andi	r24, 0x7E	; 126
    5c36:	80 93 e8 00 	sts	0x00E8, r24
    5c3a:	80 91 e4 00 	lds	r24, 0x00E4
    5c3e:	90 91 e5 00 	lds	r25, 0x00E5

			Endpoint_ClearIN();
		}

		HIDInterfaceInfo->State.PrevFrameNum = USB_Device_GetFrameNumber();
    5c42:	f7 01       	movw	r30, r14
    5c44:	93 87       	std	Z+11, r25	; 0x0b
    5c46:	82 87       	std	Z+10, r24	; 0x0a
    5c48:	0f b6       	in	r0, 0x3f	; 63
    5c4a:	f8 94       	cli
    5c4c:	9e be       	out	0x3e, r9	; 62
    5c4e:	0f be       	out	0x3f, r0	; 63
    5c50:	8d be       	out	0x3d, r8	; 61
	}
}
    5c52:	0f b6       	in	r0, 0x3f	; 63
    5c54:	f8 94       	cli
    5c56:	be be       	out	0x3e, r11	; 62
    5c58:	0f be       	out	0x3f, r0	; 63
    5c5a:	ad be       	out	0x3d, r10	; 61
    5c5c:	0f 90       	pop	r0
    5c5e:	0f 90       	pop	r0
    5c60:	0f 90       	pop	r0
    5c62:	df 91       	pop	r29
    5c64:	cf 91       	pop	r28
    5c66:	1f 91       	pop	r17
    5c68:	0f 91       	pop	r16
    5c6a:	ff 90       	pop	r15
    5c6c:	ef 90       	pop	r14
    5c6e:	df 90       	pop	r13
    5c70:	cf 90       	pop	r12
    5c72:	bf 90       	pop	r11
    5c74:	af 90       	pop	r10
    5c76:	9f 90       	pop	r9
    5c78:	8f 90       	pop	r8
    5c7a:	7f 90       	pop	r7
    5c7c:	6f 90       	pop	r6
    5c7e:	5f 90       	pop	r5
    5c80:	4f 90       	pop	r4
    5c82:	08 95       	ret

00005c84 <MS_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_MS_DRIVER
#define  __INCLUDE_FROM_MASSSTORAGE_DEVICE_C
#include "MassStorageClassDevice.h"

void MS_Device_ProcessControlRequest(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    5c84:	cf 93       	push	r28
    5c86:	df 93       	push	r29
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5c88:	20 91 e8 00 	lds	r18, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    5c8c:	23 ff       	sbrs	r18, 3
    5c8e:	38 c0       	rjmp	.+112    	; 0x5d00 <MS_Device_ProcessControlRequest+0x7c>
	  return;

	if (USB_ControlRequest.wIndex != MSInterfaceInfo->Config.InterfaceNumber)
    5c90:	fc 01       	movw	r30, r24
    5c92:	20 81       	ld	r18, Z
    5c94:	30 e0       	ldi	r19, 0x00	; 0
    5c96:	40 91 d3 09 	lds	r20, 0x09D3
    5c9a:	50 91 d4 09 	lds	r21, 0x09D4
    5c9e:	42 17       	cp	r20, r18
    5ca0:	53 07       	cpc	r21, r19
    5ca2:	71 f5       	brne	.+92     	; 0x5d00 <MS_Device_ProcessControlRequest+0x7c>
	  return;

	switch (USB_ControlRequest.bRequest)
    5ca4:	20 91 d0 09 	lds	r18, 0x09D0
    5ca8:	2e 3f       	cpi	r18, 0xFE	; 254
    5caa:	81 f0       	breq	.+32     	; 0x5ccc <MS_Device_ProcessControlRequest+0x48>
    5cac:	2f 3f       	cpi	r18, 0xFF	; 255
    5cae:	41 f5       	brne	.+80     	; 0x5d00 <MS_Device_ProcessControlRequest+0x7c>
	{
		case MS_REQ_MassStorageReset:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5cb0:	20 91 cf 09 	lds	r18, 0x09CF
    5cb4:	21 32       	cpi	r18, 0x21	; 33
    5cb6:	21 f5       	brne	.+72     	; 0x5d00 <MS_Device_ProcessControlRequest+0x7c>
    5cb8:	ec 01       	movw	r28, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5cba:	80 91 e8 00 	lds	r24, 0x00E8
    5cbe:	87 7f       	andi	r24, 0xF7	; 247
    5cc0:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    5cc4:	fa d3       	rcall	.+2036   	; 0x64ba <Endpoint_ClearStatusStage>

				MSInterfaceInfo->State.IsMassStoreReset = true;
    5cc6:	81 e0       	ldi	r24, 0x01	; 1
    5cc8:	88 af       	std	Y+56, r24	; 0x38
    5cca:	1a c0       	rjmp	.+52     	; 0x5d00 <MS_Device_ProcessControlRequest+0x7c>
			}

			break;
		case MS_REQ_GetMaxLUN:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    5ccc:	20 91 cf 09 	lds	r18, 0x09CF
    5cd0:	21 3a       	cpi	r18, 0xA1	; 161
    5cd2:	b1 f4       	brne	.+44     	; 0x5d00 <MS_Device_ProcessControlRequest+0x7c>
    5cd4:	20 91 e8 00 	lds	r18, 0x00E8
    5cd8:	27 7f       	andi	r18, 0xF7	; 247
    5cda:	20 93 e8 00 	sts	0x00E8, r18
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5cde:	20 91 e8 00 	lds	r18, 0x00E8
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    5ce2:	20 ff       	sbrs	r18, 0
    5ce4:	fc cf       	rjmp	.-8      	; 0x5cde <MS_Device_ProcessControlRequest+0x5a>
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
    5ce6:	fc 01       	movw	r30, r24
    5ce8:	83 85       	ldd	r24, Z+11	; 0x0b
    5cea:	81 50       	subi	r24, 0x01	; 1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5cec:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5cf0:	80 91 e8 00 	lds	r24, 0x00E8
    5cf4:	8e 77       	andi	r24, 0x7E	; 126
    5cf6:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearStatusStage();
			}

			break;
	}
}
    5cfa:	df 91       	pop	r29
    5cfc:	cf 91       	pop	r28
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    5cfe:	dd c3       	rjmp	.+1978   	; 0x64ba <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    5d00:	df 91       	pop	r29
    5d02:	cf 91       	pop	r28
    5d04:	08 95       	ret

00005d06 <MS_Device_ConfigureEndpoints>:

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    5d06:	cf 93       	push	r28
    5d08:	df 93       	push	r29
    5d0a:	ec 01       	movw	r28, r24
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));
    5d0c:	fc 01       	movw	r30, r24
    5d0e:	3c 96       	adiw	r30, 0x0c	; 12
    5d10:	8d e2       	ldi	r24, 0x2D	; 45
    5d12:	df 01       	movw	r26, r30
    5d14:	1d 92       	st	X+, r1
    5d16:	8a 95       	dec	r24
    5d18:	e9 f7       	brne	.-6      	; 0x5d14 <MS_Device_ConfigureEndpoints+0xe>

	MSInterfaceInfo->Config.DataINEndpoint.Type  = EP_TYPE_BULK;
    5d1a:	82 e0       	ldi	r24, 0x02	; 2
    5d1c:	8c 83       	std	Y+4, r24	; 0x04
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;
    5d1e:	89 87       	std	Y+9, r24	; 0x09

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
    5d20:	61 e0       	ldi	r22, 0x01	; 1
    5d22:	ce 01       	movw	r24, r28
    5d24:	01 96       	adiw	r24, 0x01	; 1
    5d26:	81 d3       	rcall	.+1794   	; 0x642a <Endpoint_ConfigureEndpointTable>
    5d28:	88 23       	and	r24, r24
    5d2a:	31 f0       	breq	.+12     	; 0x5d38 <MS_Device_ConfigureEndpoints+0x32>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
    5d2c:	61 e0       	ldi	r22, 0x01	; 1
    5d2e:	ce 01       	movw	r24, r28
    5d30:	06 96       	adiw	r24, 0x06	; 6
	  return false;

	return true;
}
    5d32:	df 91       	pop	r29
    5d34:	cf 91       	pop	r28
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
    5d36:	79 c3       	rjmp	.+1778   	; 0x642a <Endpoint_ConfigureEndpointTable>
	  return false;

	return true;
}
    5d38:	80 e0       	ldi	r24, 0x00	; 0
    5d3a:	df 91       	pop	r29
    5d3c:	cf 91       	pop	r28
    5d3e:	08 95       	ret

00005d40 <MS_Device_USBTask>:

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    5d40:	ef 92       	push	r14
    5d42:	ff 92       	push	r15
    5d44:	0f 93       	push	r16
    5d46:	1f 93       	push	r17
    5d48:	cf 93       	push	r28
    5d4a:	df 93       	push	r29
    5d4c:	00 d0       	rcall	.+0      	; 0x5d4e <MS_Device_USBTask+0xe>
    5d4e:	cd b7       	in	r28, 0x3d	; 61
    5d50:	de b7       	in	r29, 0x3e	; 62
	if (USB_DeviceState != DEVICE_STATE_Configured)
    5d52:	20 91 ce 09 	lds	r18, 0x09CE
    5d56:	24 30       	cpi	r18, 0x04	; 4
    5d58:	09 f0       	breq	.+2      	; 0x5d5c <MS_Device_USBTask+0x1c>
    5d5a:	03 c1       	rjmp	.+518    	; 0x5f62 <MS_Device_USBTask+0x222>
    5d5c:	8c 01       	movw	r16, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5d5e:	fc 01       	movw	r30, r24
    5d60:	86 81       	ldd	r24, Z+6	; 0x06
    5d62:	8f 70       	andi	r24, 0x0F	; 15
    5d64:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    5d68:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	if (Endpoint_IsOUTReceived())
    5d6c:	82 ff       	sbrs	r24, 2
    5d6e:	c0 c0       	rjmp	.+384    	; 0x5ef0 <MS_Device_USBTask+0x1b0>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5d70:	86 81       	ldd	r24, Z+6	; 0x06
    5d72:	8f 70       	andi	r24, 0x0F	; 15
    5d74:	80 93 e9 00 	sts	0x00E9, r24
{
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	BytesProcessed = 0;
    5d78:	1a 82       	std	Y+2, r1	; 0x02
    5d7a:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    5d7c:	78 01       	movw	r14, r16
    5d7e:	fc e0       	ldi	r31, 0x0C	; 12
    5d80:	ef 0e       	add	r14, r31
    5d82:	f1 1c       	adc	r15, r1
    5d84:	ae 01       	movw	r20, r28
    5d86:	4f 5f       	subi	r20, 0xFF	; 255
    5d88:	5f 4f       	sbci	r21, 0xFF	; 255
    5d8a:	6f e0       	ldi	r22, 0x0F	; 15
    5d8c:	70 e0       	ldi	r23, 0x00	; 0
    5d8e:	c7 01       	movw	r24, r14
    5d90:	c9 d1       	rcall	.+914    	; 0x6124 <Endpoint_Read_Stream_LE>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    5d92:	f8 01       	movw	r30, r16
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    5d94:	85 30       	cpi	r24, 0x05	; 5
    5d96:	21 f4       	brne	.+8      	; 0x5da0 <MS_Device_USBTask+0x60>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    5d98:	80 ad       	ldd	r24, Z+56	; 0x38
    5d9a:	88 23       	and	r24, r24
    5d9c:	99 f3       	breq	.-26     	; 0x5d84 <MS_Device_USBTask+0x44>
    5d9e:	a8 c0       	rjmp	.+336    	; 0x5ef0 <MS_Device_USBTask+0x1b0>
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
    5da0:	84 85       	ldd	r24, Z+12	; 0x0c
    5da2:	95 85       	ldd	r25, Z+13	; 0x0d
    5da4:	a6 85       	ldd	r26, Z+14	; 0x0e
    5da6:	b7 85       	ldd	r27, Z+15	; 0x0f
    5da8:	85 35       	cpi	r24, 0x55	; 85
    5daa:	93 45       	sbci	r25, 0x53	; 83
    5dac:	a2 44       	sbci	r26, 0x42	; 66
    5dae:	b3 44       	sbci	r27, 0x43	; 67
    5db0:	61 f4       	brne	.+24     	; 0x5dca <MS_Device_USBTask+0x8a>
    5db2:	f8 01       	movw	r30, r16
    5db4:	91 8d       	ldd	r25, Z+25	; 0x19
    5db6:	83 85       	ldd	r24, Z+11	; 0x0b
    5db8:	98 17       	cp	r25, r24
    5dba:	38 f4       	brcc	.+14     	; 0x5dca <MS_Device_USBTask+0x8a>
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    5dbc:	80 8d       	ldd	r24, Z+24	; 0x18
    5dbe:	8f 71       	andi	r24, 0x1F	; 31
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
    5dc0:	21 f4       	brne	.+8      	; 0x5dca <MS_Device_USBTask+0x8a>
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    5dc2:	82 8d       	ldd	r24, Z+26	; 0x1a
    5dc4:	81 50       	subi	r24, 0x01	; 1
    5dc6:	80 31       	cpi	r24, 0x10	; 16
    5dc8:	80 f0       	brcs	.+32     	; 0x5dea <MS_Device_USBTask+0xaa>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    5dca:	80 91 eb 00 	lds	r24, 0x00EB
    5dce:	80 62       	ori	r24, 0x20	; 32
    5dd0:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5dd4:	f8 01       	movw	r30, r16
    5dd6:	81 81       	ldd	r24, Z+1	; 0x01
    5dd8:	8f 70       	andi	r24, 0x0F	; 15
    5dda:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    5dde:	80 91 eb 00 	lds	r24, 0x00EB
    5de2:	80 62       	ori	r24, 0x20	; 32
    5de4:	80 93 eb 00 	sts	0x00EB, r24
    5de8:	83 c0       	rjmp	.+262    	; 0x5ef0 <MS_Device_USBTask+0x1b0>
		Endpoint_StallTransaction();

		return false;
	}

	BytesProcessed = 0;
    5dea:	1a 82       	std	Y+2, r1	; 0x02
    5dec:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    5dee:	78 01       	movw	r14, r16
    5df0:	fb e1       	ldi	r31, 0x1B	; 27
    5df2:	ef 0e       	add	r14, r31
    5df4:	f1 1c       	adc	r15, r1
    5df6:	f8 01       	movw	r30, r16
    5df8:	62 8d       	ldd	r22, Z+26	; 0x1a
    5dfa:	70 e0       	ldi	r23, 0x00	; 0
    5dfc:	ae 01       	movw	r20, r28
    5dfe:	4f 5f       	subi	r20, 0xFF	; 255
    5e00:	5f 4f       	sbci	r21, 0xFF	; 255
    5e02:	c7 01       	movw	r24, r14
    5e04:	8f d1       	rcall	.+798    	; 0x6124 <Endpoint_Read_Stream_LE>
    5e06:	85 30       	cpi	r24, 0x05	; 5
    5e08:	29 f4       	brne	.+10     	; 0x5e14 <MS_Device_USBTask+0xd4>
	                                MSInterfaceInfo->State.CommandBlock.SCSICommandLength, &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    5e0a:	f8 01       	movw	r30, r16
    5e0c:	80 ad       	ldd	r24, Z+56	; 0x38
    5e0e:	88 23       	and	r24, r24
    5e10:	91 f3       	breq	.-28     	; 0x5df6 <MS_Device_USBTask+0xb6>
    5e12:	6e c0       	rjmp	.+220    	; 0x5ef0 <MS_Device_USBTask+0x1b0>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    5e14:	80 91 e8 00 	lds	r24, 0x00E8
    5e18:	8b 77       	andi	r24, 0x7B	; 123
    5e1a:	80 93 e8 00 	sts	0x00E8, r24

	if (Endpoint_IsOUTReceived())
	{
		if (MS_Device_ReadInCommandBlock(MSInterfaceInfo))
		{
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
    5e1e:	f8 01       	movw	r30, r16
    5e20:	80 8d       	ldd	r24, Z+24	; 0x18
    5e22:	87 ff       	sbrs	r24, 7
    5e24:	04 c0       	rjmp	.+8      	; 0x5e2e <MS_Device_USBTask+0xee>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5e26:	81 81       	ldd	r24, Z+1	; 0x01
    5e28:	8f 70       	andi	r24, 0x0F	; 15
    5e2a:	80 93 e9 00 	sts	0x00E9, r24
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

			bool SCSICommandResult = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo);
    5e2e:	c8 01       	movw	r24, r16
    5e30:	0e 94 b1 25 	call	0x4b62	; 0x4b62 <CALLBACK_MS_Device_SCSICommandReceived>

			MSInterfaceInfo->State.CommandStatus.Status              = (SCSICommandResult) ? MS_SCSI_COMMAND_Pass : MS_SCSI_COMMAND_Fail;
    5e34:	91 e0       	ldi	r25, 0x01	; 1
    5e36:	98 27       	eor	r25, r24
    5e38:	f8 01       	movw	r30, r16
    5e3a:	97 ab       	std	Z+55, r25	; 0x37
			MSInterfaceInfo->State.CommandStatus.Signature           = CPU_TO_LE32(MS_CSW_SIGNATURE);
    5e3c:	45 e5       	ldi	r20, 0x55	; 85
    5e3e:	53 e5       	ldi	r21, 0x53	; 83
    5e40:	62 e4       	ldi	r22, 0x42	; 66
    5e42:	73 e5       	ldi	r23, 0x53	; 83
    5e44:	43 a7       	std	Z+43, r20	; 0x2b
    5e46:	54 a7       	std	Z+44, r21	; 0x2c
    5e48:	65 a7       	std	Z+45, r22	; 0x2d
    5e4a:	76 a7       	std	Z+46, r23	; 0x2e
			MSInterfaceInfo->State.CommandStatus.Tag                 = MSInterfaceInfo->State.CommandBlock.Tag;
    5e4c:	40 89       	ldd	r20, Z+16	; 0x10
    5e4e:	51 89       	ldd	r21, Z+17	; 0x11
    5e50:	62 89       	ldd	r22, Z+18	; 0x12
    5e52:	73 89       	ldd	r23, Z+19	; 0x13
    5e54:	47 a7       	std	Z+47, r20	; 0x2f
    5e56:	50 ab       	std	Z+48, r21	; 0x30
    5e58:	61 ab       	std	Z+49, r22	; 0x31
    5e5a:	72 ab       	std	Z+50, r23	; 0x32
			MSInterfaceInfo->State.CommandStatus.DataTransferResidue = MSInterfaceInfo->State.CommandBlock.DataTransferLength;
    5e5c:	44 89       	ldd	r20, Z+20	; 0x14
    5e5e:	55 89       	ldd	r21, Z+21	; 0x15
    5e60:	66 89       	ldd	r22, Z+22	; 0x16
    5e62:	77 89       	ldd	r23, Z+23	; 0x17
    5e64:	43 ab       	std	Z+51, r20	; 0x33
    5e66:	54 ab       	std	Z+52, r21	; 0x34
    5e68:	65 ab       	std	Z+53, r22	; 0x35
    5e6a:	76 ab       	std	Z+54, r23	; 0x36

			if (!(SCSICommandResult) && (le32_to_cpu(MSInterfaceInfo->State.CommandStatus.DataTransferResidue)))
    5e6c:	81 11       	cpse	r24, r1
    5e6e:	09 c0       	rjmp	.+18     	; 0x5e82 <MS_Device_USBTask+0x142>
    5e70:	45 2b       	or	r20, r21
    5e72:	46 2b       	or	r20, r22
    5e74:	47 2b       	or	r20, r23
    5e76:	29 f0       	breq	.+10     	; 0x5e82 <MS_Device_USBTask+0x142>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    5e78:	80 91 eb 00 	lds	r24, 0x00EB
    5e7c:	80 62       	ori	r24, 0x20	; 32
    5e7e:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5e82:	f8 01       	movw	r30, r16
    5e84:	86 81       	ldd	r24, Z+6	; 0x06
    5e86:	8f 70       	andi	r24, 0x0F	; 15
    5e88:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    5e8c:	80 91 eb 00 	lds	r24, 0x00EB

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	while (Endpoint_IsStalled())
    5e90:	85 ff       	sbrs	r24, 5
    5e92:	06 c0       	rjmp	.+12     	; 0x5ea0 <MS_Device_USBTask+0x160>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
    5e94:	f6 d5       	rcall	.+3052   	; 0x6a82 <USB_USBTask>
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    5e96:	f8 01       	movw	r30, r16
    5e98:	80 ad       	ldd	r24, Z+56	; 0x38
    5e9a:	88 23       	and	r24, r24
    5e9c:	b9 f3       	breq	.-18     	; 0x5e8c <MS_Device_USBTask+0x14c>
    5e9e:	28 c0       	rjmp	.+80     	; 0x5ef0 <MS_Device_USBTask+0x1b0>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5ea0:	f8 01       	movw	r30, r16
    5ea2:	81 81       	ldd	r24, Z+1	; 0x01
    5ea4:	8f 70       	andi	r24, 0x0F	; 15
    5ea6:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    5eaa:	80 91 eb 00 	lds	r24, 0x00EB
		  return;
	}

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

	while (Endpoint_IsStalled())
    5eae:	85 ff       	sbrs	r24, 5
    5eb0:	06 c0       	rjmp	.+12     	; 0x5ebe <MS_Device_USBTask+0x17e>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
    5eb2:	e7 d5       	rcall	.+3022   	; 0x6a82 <USB_USBTask>
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    5eb4:	f8 01       	movw	r30, r16
    5eb6:	80 ad       	ldd	r24, Z+56	; 0x38
    5eb8:	88 23       	and	r24, r24
    5eba:	b9 f3       	breq	.-18     	; 0x5eaa <MS_Device_USBTask+0x16a>
    5ebc:	19 c0       	rjmp	.+50     	; 0x5ef0 <MS_Device_USBTask+0x1b0>
		  return;
	}

	uint16_t BytesProcessed = 0;
    5ebe:	1a 82       	std	Y+2, r1	; 0x02
    5ec0:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    5ec2:	78 01       	movw	r14, r16
    5ec4:	fb e2       	ldi	r31, 0x2B	; 43
    5ec6:	ef 0e       	add	r14, r31
    5ec8:	f1 1c       	adc	r15, r1
    5eca:	ae 01       	movw	r20, r28
    5ecc:	4f 5f       	subi	r20, 0xFF	; 255
    5ece:	5f 4f       	sbci	r21, 0xFF	; 255
    5ed0:	6d e0       	ldi	r22, 0x0D	; 13
    5ed2:	70 e0       	ldi	r23, 0x00	; 0
    5ed4:	c7 01       	movw	r24, r14
    5ed6:	8c d0       	rcall	.+280    	; 0x5ff0 <Endpoint_Write_Stream_LE>
    5ed8:	85 30       	cpi	r24, 0x05	; 5
    5eda:	29 f4       	brne	.+10     	; 0x5ee6 <MS_Device_USBTask+0x1a6>
	                                sizeof(MS_CommandStatusWrapper_t), &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    5edc:	f8 01       	movw	r30, r16
    5ede:	80 ad       	ldd	r24, Z+56	; 0x38
    5ee0:	88 23       	and	r24, r24
    5ee2:	99 f3       	breq	.-26     	; 0x5eca <MS_Device_USBTask+0x18a>
    5ee4:	05 c0       	rjmp	.+10     	; 0x5ef0 <MS_Device_USBTask+0x1b0>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5ee6:	80 91 e8 00 	lds	r24, 0x00E8
    5eea:	8e 77       	andi	r24, 0x7E	; 126
    5eec:	80 93 e8 00 	sts	0x00E8, r24

			MS_Device_ReturnCommandStatus(MSInterfaceInfo);
		}
	}

	if (MSInterfaceInfo->State.IsMassStoreReset)
    5ef0:	f8 01       	movw	r30, r16
    5ef2:	80 ad       	ldd	r24, Z+56	; 0x38
    5ef4:	88 23       	and	r24, r24
    5ef6:	a9 f1       	breq	.+106    	; 0x5f62 <MS_Device_USBTask+0x222>
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    5ef8:	26 81       	ldd	r18, Z+6	; 0x06
    5efa:	2f 70       	andi	r18, 0x0F	; 15
    5efc:	81 e0       	ldi	r24, 0x01	; 1
    5efe:	90 e0       	ldi	r25, 0x00	; 0
    5f00:	ac 01       	movw	r20, r24
    5f02:	02 c0       	rjmp	.+4      	; 0x5f08 <MS_Device_USBTask+0x1c8>
    5f04:	44 0f       	add	r20, r20
    5f06:	55 1f       	adc	r21, r21
    5f08:	2a 95       	dec	r18
    5f0a:	e2 f7       	brpl	.-8      	; 0x5f04 <MS_Device_USBTask+0x1c4>
    5f0c:	40 93 ea 00 	sts	0x00EA, r20
				UERST = 0;
    5f10:	10 92 ea 00 	sts	0x00EA, r1
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    5f14:	21 81       	ldd	r18, Z+1	; 0x01
    5f16:	2f 70       	andi	r18, 0x0F	; 15
    5f18:	01 c0       	rjmp	.+2      	; 0x5f1c <MS_Device_USBTask+0x1dc>
    5f1a:	88 0f       	add	r24, r24
    5f1c:	2a 95       	dec	r18
    5f1e:	ea f7       	brpl	.-6      	; 0x5f1a <MS_Device_USBTask+0x1da>
    5f20:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    5f24:	10 92 ea 00 	sts	0x00EA, r1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5f28:	86 81       	ldd	r24, Z+6	; 0x06
    5f2a:	8f 70       	andi	r24, 0x0F	; 15
    5f2c:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    5f30:	80 91 eb 00 	lds	r24, 0x00EB
    5f34:	80 61       	ori	r24, 0x10	; 16
    5f36:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    5f3a:	80 91 eb 00 	lds	r24, 0x00EB
    5f3e:	88 60       	ori	r24, 0x08	; 8
    5f40:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5f44:	81 81       	ldd	r24, Z+1	; 0x01
    5f46:	8f 70       	andi	r24, 0x0F	; 15
    5f48:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    5f4c:	80 91 eb 00 	lds	r24, 0x00EB
    5f50:	80 61       	ori	r24, 0x10	; 16
    5f52:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    5f56:	80 91 eb 00 	lds	r24, 0x00EB
    5f5a:	88 60       	ori	r24, 0x08	; 8
    5f5c:	80 93 eb 00 	sts	0x00EB, r24
		Endpoint_ResetDataToggle();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);
		Endpoint_ClearStall();
		Endpoint_ResetDataToggle();

		MSInterfaceInfo->State.IsMassStoreReset = false;
    5f60:	10 ae       	std	Z+56, r1	; 0x38
	}
}
    5f62:	0f 90       	pop	r0
    5f64:	0f 90       	pop	r0
    5f66:	df 91       	pop	r29
    5f68:	cf 91       	pop	r28
    5f6a:	1f 91       	pop	r17
    5f6c:	0f 91       	pop	r16
    5f6e:	ff 90       	pop	r15
    5f70:	ef 90       	pop	r14
    5f72:	08 95       	ret

00005f74 <Endpoint_Null_Stream>:
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    5f74:	ef 92       	push	r14
    5f76:	ff 92       	push	r15
    5f78:	0f 93       	push	r16
    5f7a:	1f 93       	push	r17
    5f7c:	cf 93       	push	r28
    5f7e:	df 93       	push	r29
    5f80:	ec 01       	movw	r28, r24
    5f82:	7b 01       	movw	r14, r22
    5f84:	b9 d2       	rcall	.+1394   	; 0x64f8 <Endpoint_WaitUntilReady>
    5f86:	81 11       	cpse	r24, r1
    5f88:	2c c0       	rjmp	.+88     	; 0x5fe2 <Endpoint_Null_Stream+0x6e>
    5f8a:	e1 14       	cp	r14, r1
    5f8c:	f1 04       	cpc	r15, r1
    5f8e:	29 f0       	breq	.+10     	; 0x5f9a <Endpoint_Null_Stream+0x26>
    5f90:	f7 01       	movw	r30, r14
    5f92:	80 81       	ld	r24, Z
    5f94:	91 81       	ldd	r25, Z+1	; 0x01
    5f96:	c8 1b       	sub	r28, r24
    5f98:	d9 0b       	sbc	r29, r25
    5f9a:	00 e0       	ldi	r16, 0x00	; 0
    5f9c:	10 e0       	ldi	r17, 0x00	; 0
    5f9e:	20 97       	sbiw	r28, 0x00	; 0
    5fa0:	f9 f0       	breq	.+62     	; 0x5fe0 <Endpoint_Null_Stream+0x6c>
    5fa2:	80 91 e8 00 	lds	r24, 0x00E8
    5fa6:	85 fd       	sbrc	r24, 5
    5fa8:	15 c0       	rjmp	.+42     	; 0x5fd4 <Endpoint_Null_Stream+0x60>
    5faa:	80 91 e8 00 	lds	r24, 0x00E8
    5fae:	8e 77       	andi	r24, 0x7E	; 126
    5fb0:	80 93 e8 00 	sts	0x00E8, r24
    5fb4:	e1 14       	cp	r14, r1
    5fb6:	f1 04       	cpc	r15, r1
    5fb8:	49 f0       	breq	.+18     	; 0x5fcc <Endpoint_Null_Stream+0x58>
    5fba:	f7 01       	movw	r30, r14
    5fbc:	80 81       	ld	r24, Z
    5fbe:	91 81       	ldd	r25, Z+1	; 0x01
    5fc0:	08 0f       	add	r16, r24
    5fc2:	19 1f       	adc	r17, r25
    5fc4:	11 83       	std	Z+1, r17	; 0x01
    5fc6:	00 83       	st	Z, r16
    5fc8:	85 e0       	ldi	r24, 0x05	; 5
    5fca:	0b c0       	rjmp	.+22     	; 0x5fe2 <Endpoint_Null_Stream+0x6e>
    5fcc:	95 d2       	rcall	.+1322   	; 0x64f8 <Endpoint_WaitUntilReady>
    5fce:	88 23       	and	r24, r24
    5fd0:	31 f3       	breq	.-52     	; 0x5f9e <Endpoint_Null_Stream+0x2a>
    5fd2:	07 c0       	rjmp	.+14     	; 0x5fe2 <Endpoint_Null_Stream+0x6e>
    5fd4:	10 92 f1 00 	sts	0x00F1, r1
    5fd8:	21 97       	sbiw	r28, 0x01	; 1
    5fda:	0f 5f       	subi	r16, 0xFF	; 255
    5fdc:	1f 4f       	sbci	r17, 0xFF	; 255
    5fde:	df cf       	rjmp	.-66     	; 0x5f9e <Endpoint_Null_Stream+0x2a>
    5fe0:	80 e0       	ldi	r24, 0x00	; 0
    5fe2:	df 91       	pop	r29
    5fe4:	cf 91       	pop	r28
    5fe6:	1f 91       	pop	r17
    5fe8:	0f 91       	pop	r16
    5fea:	ff 90       	pop	r15
    5fec:	ef 90       	pop	r14
    5fee:	08 95       	ret

00005ff0 <Endpoint_Write_Stream_LE>:
    5ff0:	cf 92       	push	r12
    5ff2:	df 92       	push	r13
    5ff4:	ef 92       	push	r14
    5ff6:	ff 92       	push	r15
    5ff8:	0f 93       	push	r16
    5ffa:	1f 93       	push	r17
    5ffc:	cf 93       	push	r28
    5ffe:	df 93       	push	r29
    6000:	ec 01       	movw	r28, r24
    6002:	8b 01       	movw	r16, r22
    6004:	7a 01       	movw	r14, r20
    6006:	78 d2       	rcall	.+1264   	; 0x64f8 <Endpoint_WaitUntilReady>
    6008:	81 11       	cpse	r24, r1
    600a:	33 c0       	rjmp	.+102    	; 0x6072 <Endpoint_Write_Stream_LE+0x82>
    600c:	e1 14       	cp	r14, r1
    600e:	f1 04       	cpc	r15, r1
    6010:	39 f0       	breq	.+14     	; 0x6020 <Endpoint_Write_Stream_LE+0x30>
    6012:	f7 01       	movw	r30, r14
    6014:	80 81       	ld	r24, Z
    6016:	91 81       	ldd	r25, Z+1	; 0x01
    6018:	08 1b       	sub	r16, r24
    601a:	19 0b       	sbc	r17, r25
    601c:	c8 0f       	add	r28, r24
    601e:	d9 1f       	adc	r29, r25
    6020:	c1 2c       	mov	r12, r1
    6022:	d1 2c       	mov	r13, r1
    6024:	01 15       	cp	r16, r1
    6026:	11 05       	cpc	r17, r1
    6028:	19 f1       	breq	.+70     	; 0x6070 <Endpoint_Write_Stream_LE+0x80>
    602a:	80 91 e8 00 	lds	r24, 0x00E8
    602e:	85 fd       	sbrc	r24, 5
    6030:	16 c0       	rjmp	.+44     	; 0x605e <Endpoint_Write_Stream_LE+0x6e>
    6032:	80 91 e8 00 	lds	r24, 0x00E8
    6036:	8e 77       	andi	r24, 0x7E	; 126
    6038:	80 93 e8 00 	sts	0x00E8, r24
    603c:	22 d5       	rcall	.+2628   	; 0x6a82 <USB_USBTask>
    603e:	e1 14       	cp	r14, r1
    6040:	f1 04       	cpc	r15, r1
    6042:	49 f0       	breq	.+18     	; 0x6056 <Endpoint_Write_Stream_LE+0x66>
    6044:	f7 01       	movw	r30, r14
    6046:	80 81       	ld	r24, Z
    6048:	91 81       	ldd	r25, Z+1	; 0x01
    604a:	c8 0e       	add	r12, r24
    604c:	d9 1e       	adc	r13, r25
    604e:	d1 82       	std	Z+1, r13	; 0x01
    6050:	c0 82       	st	Z, r12
    6052:	85 e0       	ldi	r24, 0x05	; 5
    6054:	0e c0       	rjmp	.+28     	; 0x6072 <Endpoint_Write_Stream_LE+0x82>
    6056:	50 d2       	rcall	.+1184   	; 0x64f8 <Endpoint_WaitUntilReady>
    6058:	88 23       	and	r24, r24
    605a:	21 f3       	breq	.-56     	; 0x6024 <Endpoint_Write_Stream_LE+0x34>
    605c:	0a c0       	rjmp	.+20     	; 0x6072 <Endpoint_Write_Stream_LE+0x82>
    605e:	89 91       	ld	r24, Y+
    6060:	80 93 f1 00 	sts	0x00F1, r24
    6064:	01 50       	subi	r16, 0x01	; 1
    6066:	11 09       	sbc	r17, r1
    6068:	ff ef       	ldi	r31, 0xFF	; 255
    606a:	cf 1a       	sub	r12, r31
    606c:	df 0a       	sbc	r13, r31
    606e:	da cf       	rjmp	.-76     	; 0x6024 <Endpoint_Write_Stream_LE+0x34>
    6070:	80 e0       	ldi	r24, 0x00	; 0
    6072:	df 91       	pop	r29
    6074:	cf 91       	pop	r28
    6076:	1f 91       	pop	r17
    6078:	0f 91       	pop	r16
    607a:	ff 90       	pop	r15
    607c:	ef 90       	pop	r14
    607e:	df 90       	pop	r13
    6080:	cf 90       	pop	r12
    6082:	08 95       	ret

00006084 <Endpoint_Write_Stream_BE>:
    6084:	cf 92       	push	r12
    6086:	df 92       	push	r13
    6088:	ef 92       	push	r14
    608a:	ff 92       	push	r15
    608c:	0f 93       	push	r16
    608e:	1f 93       	push	r17
    6090:	cf 93       	push	r28
    6092:	df 93       	push	r29
    6094:	ec 01       	movw	r28, r24
    6096:	8b 01       	movw	r16, r22
    6098:	7a 01       	movw	r14, r20
    609a:	2e d2       	rcall	.+1116   	; 0x64f8 <Endpoint_WaitUntilReady>
    609c:	81 11       	cpse	r24, r1
    609e:	39 c0       	rjmp	.+114    	; 0x6112 <Endpoint_Write_Stream_BE+0x8e>
    60a0:	98 01       	movw	r18, r16
    60a2:	21 50       	subi	r18, 0x01	; 1
    60a4:	31 09       	sbc	r19, r1
    60a6:	c2 0f       	add	r28, r18
    60a8:	d3 1f       	adc	r29, r19
    60aa:	e1 14       	cp	r14, r1
    60ac:	f1 04       	cpc	r15, r1
    60ae:	39 f0       	breq	.+14     	; 0x60be <Endpoint_Write_Stream_BE+0x3a>
    60b0:	f7 01       	movw	r30, r14
    60b2:	80 81       	ld	r24, Z
    60b4:	91 81       	ldd	r25, Z+1	; 0x01
    60b6:	08 1b       	sub	r16, r24
    60b8:	19 0b       	sbc	r17, r25
    60ba:	c8 1b       	sub	r28, r24
    60bc:	d9 0b       	sbc	r29, r25
    60be:	c1 2c       	mov	r12, r1
    60c0:	d1 2c       	mov	r13, r1
    60c2:	01 15       	cp	r16, r1
    60c4:	11 05       	cpc	r17, r1
    60c6:	21 f1       	breq	.+72     	; 0x6110 <Endpoint_Write_Stream_BE+0x8c>
    60c8:	80 91 e8 00 	lds	r24, 0x00E8
    60cc:	85 fd       	sbrc	r24, 5
    60ce:	16 c0       	rjmp	.+44     	; 0x60fc <Endpoint_Write_Stream_BE+0x78>
    60d0:	80 91 e8 00 	lds	r24, 0x00E8
    60d4:	8e 77       	andi	r24, 0x7E	; 126
    60d6:	80 93 e8 00 	sts	0x00E8, r24
    60da:	d3 d4       	rcall	.+2470   	; 0x6a82 <USB_USBTask>
    60dc:	e1 14       	cp	r14, r1
    60de:	f1 04       	cpc	r15, r1
    60e0:	49 f0       	breq	.+18     	; 0x60f4 <Endpoint_Write_Stream_BE+0x70>
    60e2:	f7 01       	movw	r30, r14
    60e4:	80 81       	ld	r24, Z
    60e6:	91 81       	ldd	r25, Z+1	; 0x01
    60e8:	c8 0e       	add	r12, r24
    60ea:	d9 1e       	adc	r13, r25
    60ec:	d1 82       	std	Z+1, r13	; 0x01
    60ee:	c0 82       	st	Z, r12
    60f0:	85 e0       	ldi	r24, 0x05	; 5
    60f2:	0f c0       	rjmp	.+30     	; 0x6112 <Endpoint_Write_Stream_BE+0x8e>
    60f4:	01 d2       	rcall	.+1026   	; 0x64f8 <Endpoint_WaitUntilReady>
    60f6:	88 23       	and	r24, r24
    60f8:	21 f3       	breq	.-56     	; 0x60c2 <Endpoint_Write_Stream_BE+0x3e>
    60fa:	0b c0       	rjmp	.+22     	; 0x6112 <Endpoint_Write_Stream_BE+0x8e>
    60fc:	88 81       	ld	r24, Y
    60fe:	80 93 f1 00 	sts	0x00F1, r24
    6102:	21 97       	sbiw	r28, 0x01	; 1
    6104:	01 50       	subi	r16, 0x01	; 1
    6106:	11 09       	sbc	r17, r1
    6108:	ff ef       	ldi	r31, 0xFF	; 255
    610a:	cf 1a       	sub	r12, r31
    610c:	df 0a       	sbc	r13, r31
    610e:	d9 cf       	rjmp	.-78     	; 0x60c2 <Endpoint_Write_Stream_BE+0x3e>
    6110:	80 e0       	ldi	r24, 0x00	; 0
    6112:	df 91       	pop	r29
    6114:	cf 91       	pop	r28
    6116:	1f 91       	pop	r17
    6118:	0f 91       	pop	r16
    611a:	ff 90       	pop	r15
    611c:	ef 90       	pop	r14
    611e:	df 90       	pop	r13
    6120:	cf 90       	pop	r12
    6122:	08 95       	ret

00006124 <Endpoint_Read_Stream_LE>:
    6124:	cf 92       	push	r12
    6126:	df 92       	push	r13
    6128:	ef 92       	push	r14
    612a:	ff 92       	push	r15
    612c:	0f 93       	push	r16
    612e:	1f 93       	push	r17
    6130:	cf 93       	push	r28
    6132:	df 93       	push	r29
    6134:	ec 01       	movw	r28, r24
    6136:	8b 01       	movw	r16, r22
    6138:	7a 01       	movw	r14, r20
    613a:	de d1       	rcall	.+956    	; 0x64f8 <Endpoint_WaitUntilReady>
    613c:	81 11       	cpse	r24, r1
    613e:	33 c0       	rjmp	.+102    	; 0x61a6 <Endpoint_Read_Stream_LE+0x82>
    6140:	e1 14       	cp	r14, r1
    6142:	f1 04       	cpc	r15, r1
    6144:	39 f0       	breq	.+14     	; 0x6154 <Endpoint_Read_Stream_LE+0x30>
    6146:	f7 01       	movw	r30, r14
    6148:	80 81       	ld	r24, Z
    614a:	91 81       	ldd	r25, Z+1	; 0x01
    614c:	08 1b       	sub	r16, r24
    614e:	19 0b       	sbc	r17, r25
    6150:	c8 0f       	add	r28, r24
    6152:	d9 1f       	adc	r29, r25
    6154:	c1 2c       	mov	r12, r1
    6156:	d1 2c       	mov	r13, r1
    6158:	01 15       	cp	r16, r1
    615a:	11 05       	cpc	r17, r1
    615c:	19 f1       	breq	.+70     	; 0x61a4 <Endpoint_Read_Stream_LE+0x80>
    615e:	80 91 e8 00 	lds	r24, 0x00E8
    6162:	85 fd       	sbrc	r24, 5
    6164:	16 c0       	rjmp	.+44     	; 0x6192 <Endpoint_Read_Stream_LE+0x6e>
    6166:	80 91 e8 00 	lds	r24, 0x00E8
    616a:	8b 77       	andi	r24, 0x7B	; 123
    616c:	80 93 e8 00 	sts	0x00E8, r24
    6170:	88 d4       	rcall	.+2320   	; 0x6a82 <USB_USBTask>
    6172:	e1 14       	cp	r14, r1
    6174:	f1 04       	cpc	r15, r1
    6176:	49 f0       	breq	.+18     	; 0x618a <Endpoint_Read_Stream_LE+0x66>
    6178:	f7 01       	movw	r30, r14
    617a:	80 81       	ld	r24, Z
    617c:	91 81       	ldd	r25, Z+1	; 0x01
    617e:	c8 0e       	add	r12, r24
    6180:	d9 1e       	adc	r13, r25
    6182:	d1 82       	std	Z+1, r13	; 0x01
    6184:	c0 82       	st	Z, r12
    6186:	85 e0       	ldi	r24, 0x05	; 5
    6188:	0e c0       	rjmp	.+28     	; 0x61a6 <Endpoint_Read_Stream_LE+0x82>
    618a:	b6 d1       	rcall	.+876    	; 0x64f8 <Endpoint_WaitUntilReady>
    618c:	88 23       	and	r24, r24
    618e:	21 f3       	breq	.-56     	; 0x6158 <Endpoint_Read_Stream_LE+0x34>
    6190:	0a c0       	rjmp	.+20     	; 0x61a6 <Endpoint_Read_Stream_LE+0x82>
    6192:	80 91 f1 00 	lds	r24, 0x00F1
    6196:	89 93       	st	Y+, r24
    6198:	01 50       	subi	r16, 0x01	; 1
    619a:	11 09       	sbc	r17, r1
    619c:	ff ef       	ldi	r31, 0xFF	; 255
    619e:	cf 1a       	sub	r12, r31
    61a0:	df 0a       	sbc	r13, r31
    61a2:	da cf       	rjmp	.-76     	; 0x6158 <Endpoint_Read_Stream_LE+0x34>
    61a4:	80 e0       	ldi	r24, 0x00	; 0
    61a6:	df 91       	pop	r29
    61a8:	cf 91       	pop	r28
    61aa:	1f 91       	pop	r17
    61ac:	0f 91       	pop	r16
    61ae:	ff 90       	pop	r15
    61b0:	ef 90       	pop	r14
    61b2:	df 90       	pop	r13
    61b4:	cf 90       	pop	r12
    61b6:	08 95       	ret

000061b8 <Endpoint_Write_Control_Stream_LE>:
    61b8:	20 91 d5 09 	lds	r18, 0x09D5
    61bc:	30 91 d6 09 	lds	r19, 0x09D6
    61c0:	26 17       	cp	r18, r22
    61c2:	37 07       	cpc	r19, r23
    61c4:	48 f0       	brcs	.+18     	; 0x61d8 <Endpoint_Write_Control_Stream_LE+0x20>
    61c6:	61 15       	cp	r22, r1
    61c8:	71 05       	cpc	r23, r1
    61ca:	39 f4       	brne	.+14     	; 0x61da <Endpoint_Write_Control_Stream_LE+0x22>
    61cc:	20 91 e8 00 	lds	r18, 0x00E8
    61d0:	2e 77       	andi	r18, 0x7E	; 126
    61d2:	20 93 e8 00 	sts	0x00E8, r18
    61d6:	01 c0       	rjmp	.+2      	; 0x61da <Endpoint_Write_Control_Stream_LE+0x22>
    61d8:	b9 01       	movw	r22, r18
    61da:	40 e0       	ldi	r20, 0x00	; 0
    61dc:	61 15       	cp	r22, r1
    61de:	71 05       	cpc	r23, r1
    61e0:	a9 f1       	breq	.+106    	; 0x624c <Endpoint_Write_Control_Stream_LE+0x94>
    61e2:	20 91 ce 09 	lds	r18, 0x09CE
    61e6:	22 23       	and	r18, r18
    61e8:	09 f4       	brne	.+2      	; 0x61ec <Endpoint_Write_Control_Stream_LE+0x34>
    61ea:	43 c0       	rjmp	.+134    	; 0x6272 <Endpoint_Write_Control_Stream_LE+0xba>
    61ec:	25 30       	cpi	r18, 0x05	; 5
    61ee:	09 f4       	brne	.+2      	; 0x61f2 <Endpoint_Write_Control_Stream_LE+0x3a>
    61f0:	42 c0       	rjmp	.+132    	; 0x6276 <Endpoint_Write_Control_Stream_LE+0xbe>
    61f2:	20 91 e8 00 	lds	r18, 0x00E8
    61f6:	23 fd       	sbrc	r18, 3
    61f8:	40 c0       	rjmp	.+128    	; 0x627a <Endpoint_Write_Control_Stream_LE+0xc2>
    61fa:	20 91 e8 00 	lds	r18, 0x00E8
    61fe:	22 fd       	sbrc	r18, 2
    6200:	32 c0       	rjmp	.+100    	; 0x6266 <Endpoint_Write_Control_Stream_LE+0xae>
    6202:	20 91 e8 00 	lds	r18, 0x00E8
    6206:	20 ff       	sbrs	r18, 0
    6208:	e9 cf       	rjmp	.-46     	; 0x61dc <Endpoint_Write_Control_Stream_LE+0x24>
    620a:	40 91 f3 00 	lds	r20, 0x00F3
    620e:	20 91 f2 00 	lds	r18, 0x00F2
    6212:	30 e0       	ldi	r19, 0x00	; 0
    6214:	34 2b       	or	r19, r20
    6216:	fc 01       	movw	r30, r24
    6218:	cf 01       	movw	r24, r30
    621a:	61 15       	cp	r22, r1
    621c:	71 05       	cpc	r23, r1
    621e:	59 f0       	breq	.+22     	; 0x6236 <Endpoint_Write_Control_Stream_LE+0x7e>
    6220:	28 30       	cpi	r18, 0x08	; 8
    6222:	31 05       	cpc	r19, r1
    6224:	40 f4       	brcc	.+16     	; 0x6236 <Endpoint_Write_Control_Stream_LE+0x7e>
    6226:	81 91       	ld	r24, Z+
    6228:	80 93 f1 00 	sts	0x00F1, r24
    622c:	61 50       	subi	r22, 0x01	; 1
    622e:	71 09       	sbc	r23, r1
    6230:	2f 5f       	subi	r18, 0xFF	; 255
    6232:	3f 4f       	sbci	r19, 0xFF	; 255
    6234:	f1 cf       	rjmp	.-30     	; 0x6218 <Endpoint_Write_Control_Stream_LE+0x60>
    6236:	41 e0       	ldi	r20, 0x01	; 1
    6238:	28 30       	cpi	r18, 0x08	; 8
    623a:	31 05       	cpc	r19, r1
    623c:	09 f0       	breq	.+2      	; 0x6240 <Endpoint_Write_Control_Stream_LE+0x88>
    623e:	40 e0       	ldi	r20, 0x00	; 0
    6240:	20 91 e8 00 	lds	r18, 0x00E8
    6244:	2e 77       	andi	r18, 0x7E	; 126
    6246:	20 93 e8 00 	sts	0x00E8, r18
    624a:	c8 cf       	rjmp	.-112    	; 0x61dc <Endpoint_Write_Control_Stream_LE+0x24>
    624c:	41 11       	cpse	r20, r1
    624e:	c9 cf       	rjmp	.-110    	; 0x61e2 <Endpoint_Write_Control_Stream_LE+0x2a>
    6250:	0a c0       	rjmp	.+20     	; 0x6266 <Endpoint_Write_Control_Stream_LE+0xae>
    6252:	80 91 ce 09 	lds	r24, 0x09CE
    6256:	88 23       	and	r24, r24
    6258:	61 f0       	breq	.+24     	; 0x6272 <Endpoint_Write_Control_Stream_LE+0xba>
    625a:	85 30       	cpi	r24, 0x05	; 5
    625c:	61 f0       	breq	.+24     	; 0x6276 <Endpoint_Write_Control_Stream_LE+0xbe>
    625e:	80 91 e8 00 	lds	r24, 0x00E8
    6262:	83 fd       	sbrc	r24, 3
    6264:	0a c0       	rjmp	.+20     	; 0x627a <Endpoint_Write_Control_Stream_LE+0xc2>
    6266:	80 91 e8 00 	lds	r24, 0x00E8
    626a:	82 ff       	sbrs	r24, 2
    626c:	f2 cf       	rjmp	.-28     	; 0x6252 <Endpoint_Write_Control_Stream_LE+0x9a>
    626e:	80 e0       	ldi	r24, 0x00	; 0
    6270:	08 95       	ret
    6272:	82 e0       	ldi	r24, 0x02	; 2
    6274:	08 95       	ret
    6276:	83 e0       	ldi	r24, 0x03	; 3
    6278:	08 95       	ret
    627a:	81 e0       	ldi	r24, 0x01	; 1
    627c:	08 95       	ret

0000627e <Endpoint_Read_Control_Stream_LE>:
    627e:	61 15       	cp	r22, r1
    6280:	71 05       	cpc	r23, r1
    6282:	29 f4       	brne	.+10     	; 0x628e <Endpoint_Read_Control_Stream_LE+0x10>
    6284:	20 91 e8 00 	lds	r18, 0x00E8
    6288:	2b 77       	andi	r18, 0x7B	; 123
    628a:	20 93 e8 00 	sts	0x00E8, r18
    628e:	fc 01       	movw	r30, r24
    6290:	61 15       	cp	r22, r1
    6292:	71 05       	cpc	r23, r1
    6294:	41 f1       	breq	.+80     	; 0x62e6 <Endpoint_Read_Control_Stream_LE+0x68>
    6296:	80 91 ce 09 	lds	r24, 0x09CE
    629a:	88 23       	and	r24, r24
    629c:	61 f1       	breq	.+88     	; 0x62f6 <Endpoint_Read_Control_Stream_LE+0x78>
    629e:	85 30       	cpi	r24, 0x05	; 5
    62a0:	61 f1       	breq	.+88     	; 0x62fa <Endpoint_Read_Control_Stream_LE+0x7c>
    62a2:	80 91 e8 00 	lds	r24, 0x00E8
    62a6:	83 fd       	sbrc	r24, 3
    62a8:	24 c0       	rjmp	.+72     	; 0x62f2 <Endpoint_Read_Control_Stream_LE+0x74>
    62aa:	80 91 e8 00 	lds	r24, 0x00E8
    62ae:	82 ff       	sbrs	r24, 2
    62b0:	ef cf       	rjmp	.-34     	; 0x6290 <Endpoint_Read_Control_Stream_LE+0x12>
    62b2:	20 91 f3 00 	lds	r18, 0x00F3
    62b6:	80 91 f2 00 	lds	r24, 0x00F2
    62ba:	90 e0       	ldi	r25, 0x00	; 0
    62bc:	92 2b       	or	r25, r18
    62be:	89 2b       	or	r24, r25
    62c0:	31 f0       	breq	.+12     	; 0x62ce <Endpoint_Read_Control_Stream_LE+0x50>
    62c2:	80 91 f1 00 	lds	r24, 0x00F1
    62c6:	81 93       	st	Z+, r24
    62c8:	61 50       	subi	r22, 0x01	; 1
    62ca:	71 09       	sbc	r23, r1
    62cc:	91 f7       	brne	.-28     	; 0x62b2 <Endpoint_Read_Control_Stream_LE+0x34>
    62ce:	80 91 e8 00 	lds	r24, 0x00E8
    62d2:	8b 77       	andi	r24, 0x7B	; 123
    62d4:	80 93 e8 00 	sts	0x00E8, r24
    62d8:	db cf       	rjmp	.-74     	; 0x6290 <Endpoint_Read_Control_Stream_LE+0x12>
    62da:	80 91 ce 09 	lds	r24, 0x09CE
    62de:	88 23       	and	r24, r24
    62e0:	51 f0       	breq	.+20     	; 0x62f6 <Endpoint_Read_Control_Stream_LE+0x78>
    62e2:	85 30       	cpi	r24, 0x05	; 5
    62e4:	51 f0       	breq	.+20     	; 0x62fa <Endpoint_Read_Control_Stream_LE+0x7c>
    62e6:	80 91 e8 00 	lds	r24, 0x00E8
    62ea:	80 ff       	sbrs	r24, 0
    62ec:	f6 cf       	rjmp	.-20     	; 0x62da <Endpoint_Read_Control_Stream_LE+0x5c>
    62ee:	80 e0       	ldi	r24, 0x00	; 0
    62f0:	08 95       	ret
    62f2:	81 e0       	ldi	r24, 0x01	; 1
    62f4:	08 95       	ret
    62f6:	82 e0       	ldi	r24, 0x02	; 2
    62f8:	08 95       	ret
    62fa:	83 e0       	ldi	r24, 0x03	; 3
    62fc:	08 95       	ret

000062fe <Endpoint_Write_Control_PStream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    62fe:	20 91 d5 09 	lds	r18, 0x09D5
    6302:	30 91 d6 09 	lds	r19, 0x09D6
    6306:	26 17       	cp	r18, r22
    6308:	37 07       	cpc	r19, r23
    630a:	48 f0       	brcs	.+18     	; 0x631e <Endpoint_Write_Control_PStream_LE+0x20>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    630c:	61 15       	cp	r22, r1
    630e:	71 05       	cpc	r23, r1
    6310:	39 f4       	brne	.+14     	; 0x6320 <Endpoint_Write_Control_PStream_LE+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6312:	20 91 e8 00 	lds	r18, 0x00E8
    6316:	2e 77       	andi	r18, 0x7E	; 126
    6318:	20 93 e8 00 	sts	0x00E8, r18
    631c:	01 c0       	rjmp	.+2      	; 0x6320 <Endpoint_Write_Control_PStream_LE+0x22>
    631e:	b9 01       	movw	r22, r18
    6320:	fc 01       	movw	r30, r24
    6322:	20 e0       	ldi	r18, 0x00	; 0
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    6324:	61 15       	cp	r22, r1
    6326:	71 05       	cpc	r23, r1
    6328:	91 f1       	breq	.+100    	; 0x638e <Endpoint_Write_Control_PStream_LE+0x90>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    632a:	80 91 ce 09 	lds	r24, 0x09CE

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    632e:	88 23       	and	r24, r24
    6330:	09 f4       	brne	.+2      	; 0x6334 <Endpoint_Write_Control_PStream_LE+0x36>
    6332:	40 c0       	rjmp	.+128    	; 0x63b4 <Endpoint_Write_Control_PStream_LE+0xb6>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    6334:	85 30       	cpi	r24, 0x05	; 5
    6336:	09 f4       	brne	.+2      	; 0x633a <Endpoint_Write_Control_PStream_LE+0x3c>
    6338:	3f c0       	rjmp	.+126    	; 0x63b8 <Endpoint_Write_Control_PStream_LE+0xba>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    633a:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    633e:	83 fd       	sbrc	r24, 3
    6340:	3d c0       	rjmp	.+122    	; 0x63bc <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6342:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    6346:	82 fd       	sbrc	r24, 2
    6348:	2f c0       	rjmp	.+94     	; 0x63a8 <Endpoint_Write_Control_PStream_LE+0xaa>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    634a:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    634e:	80 ff       	sbrs	r24, 0
    6350:	e9 cf       	rjmp	.-46     	; 0x6324 <Endpoint_Write_Control_PStream_LE+0x26>
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
    6352:	20 91 f3 00 	lds	r18, 0x00F3
    6356:	80 91 f2 00 	lds	r24, 0x00F2
    635a:	90 e0       	ldi	r25, 0x00	; 0
    635c:	92 2b       	or	r25, r18
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    635e:	61 15       	cp	r22, r1
    6360:	71 05       	cpc	r23, r1
    6362:	59 f0       	breq	.+22     	; 0x637a <Endpoint_Write_Control_PStream_LE+0x7c>
    6364:	88 30       	cpi	r24, 0x08	; 8
    6366:	91 05       	cpc	r25, r1
    6368:	40 f4       	brcc	.+16     	; 0x637a <Endpoint_Write_Control_PStream_LE+0x7c>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    636a:	24 91       	lpm	r18, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    636c:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    6370:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    6372:	61 50       	subi	r22, 0x01	; 1
    6374:	71 09       	sbc	r23, r1
				BytesInEndpoint++;
    6376:	01 96       	adiw	r24, 0x01	; 1
    6378:	f2 cf       	rjmp	.-28     	; 0x635e <Endpoint_Write_Control_PStream_LE+0x60>
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    637a:	21 e0       	ldi	r18, 0x01	; 1
    637c:	08 97       	sbiw	r24, 0x08	; 8
    637e:	09 f0       	breq	.+2      	; 0x6382 <Endpoint_Write_Control_PStream_LE+0x84>
    6380:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6382:	80 91 e8 00 	lds	r24, 0x00E8
    6386:	8e 77       	andi	r24, 0x7E	; 126
    6388:	80 93 e8 00 	sts	0x00E8, r24
    638c:	cb cf       	rjmp	.-106    	; 0x6324 <Endpoint_Write_Control_PStream_LE+0x26>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    638e:	21 11       	cpse	r18, r1
    6390:	cc cf       	rjmp	.-104    	; 0x632a <Endpoint_Write_Control_PStream_LE+0x2c>
    6392:	0a c0       	rjmp	.+20     	; 0x63a8 <Endpoint_Write_Control_PStream_LE+0xaa>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    6394:	80 91 ce 09 	lds	r24, 0x09CE

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    6398:	88 23       	and	r24, r24
    639a:	61 f0       	breq	.+24     	; 0x63b4 <Endpoint_Write_Control_PStream_LE+0xb6>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    639c:	85 30       	cpi	r24, 0x05	; 5
    639e:	61 f0       	breq	.+24     	; 0x63b8 <Endpoint_Write_Control_PStream_LE+0xba>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    63a0:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    63a4:	83 fd       	sbrc	r24, 3
    63a6:	0a c0       	rjmp	.+20     	; 0x63bc <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    63a8:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    63ac:	82 ff       	sbrs	r24, 2
    63ae:	f2 cf       	rjmp	.-28     	; 0x6394 <Endpoint_Write_Control_PStream_LE+0x96>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    63b0:	80 e0       	ldi	r24, 0x00	; 0
    63b2:	08 95       	ret
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    63b4:	82 e0       	ldi	r24, 0x02	; 2
    63b6:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    63b8:	83 e0       	ldi	r24, 0x03	; 3
    63ba:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    63bc:	81 e0       	ldi	r24, 0x01	; 1
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    63be:	08 95       	ret

000063c0 <Endpoint_ConfigureEndpoint_Prv>:
		UEIENX  = 0;
		UEINTX  = 0;
		UECFG1X = 0;
		Endpoint_DisableEndpoint();
	}
}
    63c0:	98 2f       	mov	r25, r24
    63c2:	97 30       	cpi	r25, 0x07	; 7
    63c4:	58 f5       	brcc	.+86     	; 0x641c <Endpoint_ConfigureEndpoint_Prv+0x5c>
    63c6:	90 93 e9 00 	sts	0x00E9, r25
    63ca:	98 17       	cp	r25, r24
    63cc:	39 f0       	breq	.+14     	; 0x63dc <Endpoint_ConfigureEndpoint_Prv+0x1c>
    63ce:	70 91 ec 00 	lds	r23, 0x00EC
    63d2:	20 91 ed 00 	lds	r18, 0x00ED
    63d6:	50 91 f0 00 	lds	r21, 0x00F0
    63da:	03 c0       	rjmp	.+6      	; 0x63e2 <Endpoint_ConfigureEndpoint_Prv+0x22>
    63dc:	24 2f       	mov	r18, r20
    63de:	76 2f       	mov	r23, r22
    63e0:	50 e0       	ldi	r21, 0x00	; 0
    63e2:	21 ff       	sbrs	r18, 1
    63e4:	19 c0       	rjmp	.+50     	; 0x6418 <Endpoint_ConfigureEndpoint_Prv+0x58>
    63e6:	30 91 eb 00 	lds	r19, 0x00EB
    63ea:	3e 7f       	andi	r19, 0xFE	; 254
    63ec:	30 93 eb 00 	sts	0x00EB, r19
    63f0:	30 91 ed 00 	lds	r19, 0x00ED
    63f4:	3d 7f       	andi	r19, 0xFD	; 253
    63f6:	30 93 ed 00 	sts	0x00ED, r19
    63fa:	30 91 eb 00 	lds	r19, 0x00EB
    63fe:	31 60       	ori	r19, 0x01	; 1
    6400:	30 93 eb 00 	sts	0x00EB, r19
    6404:	70 93 ec 00 	sts	0x00EC, r23
    6408:	20 93 ed 00 	sts	0x00ED, r18
    640c:	50 93 f0 00 	sts	0x00F0, r21
    6410:	20 91 ee 00 	lds	r18, 0x00EE
    6414:	27 ff       	sbrs	r18, 7
    6416:	07 c0       	rjmp	.+14     	; 0x6426 <Endpoint_ConfigureEndpoint_Prv+0x66>
    6418:	9f 5f       	subi	r25, 0xFF	; 255
    641a:	d3 cf       	rjmp	.-90     	; 0x63c2 <Endpoint_ConfigureEndpoint_Prv+0x2>
    641c:	8f 70       	andi	r24, 0x0F	; 15
    641e:	80 93 e9 00 	sts	0x00E9, r24
    6422:	81 e0       	ldi	r24, 0x01	; 1
    6424:	08 95       	ret
    6426:	80 e0       	ldi	r24, 0x00	; 0
    6428:	08 95       	ret

0000642a <Endpoint_ConfigureEndpointTable>:
    642a:	ef 92       	push	r14
    642c:	ff 92       	push	r15
    642e:	0f 93       	push	r16
    6430:	1f 93       	push	r17
    6432:	cf 93       	push	r28
    6434:	df 93       	push	r29
    6436:	e6 2e       	mov	r14, r22
    6438:	ec 01       	movw	r28, r24
    643a:	8c 01       	movw	r16, r24
    643c:	0c 5f       	subi	r16, 0xFC	; 252
    643e:	1f 4f       	sbci	r17, 0xFF	; 255
    6440:	f1 2c       	mov	r15, r1
    6442:	fe 14       	cp	r15, r14
    6444:	91 f1       	breq	.+100    	; 0x64aa <Endpoint_ConfigureEndpointTable+0x80>
    6446:	58 81       	ld	r21, Y
    6448:	55 23       	and	r21, r21
    644a:	51 f1       	breq	.+84     	; 0x64a0 <Endpoint_ConfigureEndpointTable+0x76>
    644c:	f8 01       	movw	r30, r16
    644e:	20 81       	ld	r18, Z
    6450:	69 81       	ldd	r22, Y+1	; 0x01
    6452:	7a 81       	ldd	r23, Y+2	; 0x02
    6454:	31 97       	sbiw	r30, 0x01	; 1
    6456:	90 81       	ld	r25, Z
    6458:	85 2f       	mov	r24, r21
    645a:	8f 70       	andi	r24, 0x0F	; 15
    645c:	87 30       	cpi	r24, 0x07	; 7
    645e:	10 f0       	brcs	.+4      	; 0x6464 <Endpoint_ConfigureEndpointTable+0x3a>
    6460:	80 e0       	ldi	r24, 0x00	; 0
    6462:	24 c0       	rjmp	.+72     	; 0x64ac <Endpoint_ConfigureEndpointTable+0x82>
    6464:	22 30       	cpi	r18, 0x02	; 2
    6466:	10 f4       	brcc	.+4      	; 0x646c <Endpoint_ConfigureEndpointTable+0x42>
    6468:	42 e0       	ldi	r20, 0x02	; 2
    646a:	01 c0       	rjmp	.+2      	; 0x646e <Endpoint_ConfigureEndpointTable+0x44>
    646c:	46 e0       	ldi	r20, 0x06	; 6
    646e:	e8 e0       	ldi	r30, 0x08	; 8
    6470:	f0 e0       	ldi	r31, 0x00	; 0
    6472:	20 e0       	ldi	r18, 0x00	; 0
    6474:	e6 17       	cp	r30, r22
    6476:	f7 07       	cpc	r31, r23
    6478:	20 f4       	brcc	.+8      	; 0x6482 <Endpoint_ConfigureEndpointTable+0x58>
    647a:	2f 5f       	subi	r18, 0xFF	; 255
    647c:	ee 0f       	add	r30, r30
    647e:	ff 1f       	adc	r31, r31
    6480:	f9 cf       	rjmp	.-14     	; 0x6474 <Endpoint_ConfigureEndpointTable+0x4a>
    6482:	22 95       	swap	r18
    6484:	20 7f       	andi	r18, 0xF0	; 240
    6486:	42 2b       	or	r20, r18
    6488:	f0 e4       	ldi	r31, 0x40	; 64
    648a:	9f 9f       	mul	r25, r31
    648c:	90 01       	movw	r18, r0
    648e:	11 24       	eor	r1, r1
    6490:	55 1f       	adc	r21, r21
    6492:	55 27       	eor	r21, r21
    6494:	55 1f       	adc	r21, r21
    6496:	65 2f       	mov	r22, r21
    6498:	62 2b       	or	r22, r18
    649a:	92 df       	rcall	.-220    	; 0x63c0 <Endpoint_ConfigureEndpoint_Prv>
    649c:	88 23       	and	r24, r24
    649e:	01 f3       	breq	.-64     	; 0x6460 <Endpoint_ConfigureEndpointTable+0x36>
    64a0:	f3 94       	inc	r15
    64a2:	25 96       	adiw	r28, 0x05	; 5
    64a4:	0b 5f       	subi	r16, 0xFB	; 251
    64a6:	1f 4f       	sbci	r17, 0xFF	; 255
    64a8:	cc cf       	rjmp	.-104    	; 0x6442 <Endpoint_ConfigureEndpointTable+0x18>
    64aa:	81 e0       	ldi	r24, 0x01	; 1
    64ac:	df 91       	pop	r29
    64ae:	cf 91       	pop	r28
    64b0:	1f 91       	pop	r17
    64b2:	0f 91       	pop	r16
    64b4:	ff 90       	pop	r15
    64b6:	ef 90       	pop	r14
    64b8:	08 95       	ret

000064ba <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    64ba:	80 91 cf 09 	lds	r24, 0x09CF
    64be:	87 ff       	sbrs	r24, 7
    64c0:	11 c0       	rjmp	.+34     	; 0x64e4 <Endpoint_ClearStatusStage+0x2a>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    64c2:	80 91 e8 00 	lds	r24, 0x00E8
	{
		while (!(Endpoint_IsOUTReceived()))
    64c6:	82 fd       	sbrc	r24, 2
    64c8:	05 c0       	rjmp	.+10     	; 0x64d4 <Endpoint_ClearStatusStage+0x1a>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    64ca:	80 91 ce 09 	lds	r24, 0x09CE
    64ce:	81 11       	cpse	r24, r1
    64d0:	f8 cf       	rjmp	.-16     	; 0x64c2 <Endpoint_ClearStatusStage+0x8>
    64d2:	11 c0       	rjmp	.+34     	; 0x64f6 <Endpoint_ClearStatusStage+0x3c>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    64d4:	80 91 e8 00 	lds	r24, 0x00E8
    64d8:	8b 77       	andi	r24, 0x7B	; 123
    64da:	0b c0       	rjmp	.+22     	; 0x64f2 <Endpoint_ClearStatusStage+0x38>
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    64dc:	80 91 ce 09 	lds	r24, 0x09CE
    64e0:	88 23       	and	r24, r24
    64e2:	49 f0       	breq	.+18     	; 0x64f6 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    64e4:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    64e8:	80 ff       	sbrs	r24, 0
    64ea:	f8 cf       	rjmp	.-16     	; 0x64dc <Endpoint_ClearStatusStage+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    64ec:	80 91 e8 00 	lds	r24, 0x00E8
    64f0:	8e 77       	andi	r24, 0x7E	; 126
    64f2:	80 93 e8 00 	sts	0x00E8, r24
    64f6:	08 95       	ret

000064f8 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    64f8:	20 91 e4 00 	lds	r18, 0x00E4
    64fc:	30 91 e5 00 	lds	r19, 0x00E5
    6500:	95 e6       	ldi	r25, 0x65	; 101
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    6502:	40 91 ec 00 	lds	r20, 0x00EC
    6506:	84 2f       	mov	r24, r20
    6508:	81 70       	andi	r24, 0x01	; 1
    650a:	40 ff       	sbrs	r20, 0
    650c:	22 c0       	rjmp	.+68     	; 0x6552 <Endpoint_WaitUntilReady+0x5a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    650e:	80 91 e8 00 	lds	r24, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    6512:	80 fd       	sbrc	r24, 0
    6514:	1c c0       	rjmp	.+56     	; 0x654e <Endpoint_WaitUntilReady+0x56>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    6516:	80 91 ce 09 	lds	r24, 0x09CE

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    651a:	88 23       	and	r24, r24
    651c:	91 f0       	breq	.+36     	; 0x6542 <Endpoint_WaitUntilReady+0x4a>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    651e:	85 30       	cpi	r24, 0x05	; 5
    6520:	91 f0       	breq	.+36     	; 0x6546 <Endpoint_WaitUntilReady+0x4e>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    6522:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    6526:	85 fd       	sbrc	r24, 5
    6528:	10 c0       	rjmp	.+32     	; 0x654a <Endpoint_WaitUntilReady+0x52>
    652a:	40 91 e4 00 	lds	r20, 0x00E4
    652e:	50 91 e5 00 	lds	r21, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    6532:	42 17       	cp	r20, r18
    6534:	53 07       	cpc	r21, r19
    6536:	29 f3       	breq	.-54     	; 0x6502 <Endpoint_WaitUntilReady+0xa>
    6538:	9a 01       	movw	r18, r20
    653a:	91 50       	subi	r25, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    653c:	11 f7       	brne	.-60     	; 0x6502 <Endpoint_WaitUntilReady+0xa>
			  return ENDPOINT_READYWAIT_Timeout;
    653e:	84 e0       	ldi	r24, 0x04	; 4
    6540:	08 95       	ret
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    6542:	82 e0       	ldi	r24, 0x02	; 2
    6544:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    6546:	83 e0       	ldi	r24, 0x03	; 3
    6548:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    654a:	81 e0       	ldi	r24, 0x01	; 1
    654c:	08 95       	ret
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    654e:	80 e0       	ldi	r24, 0x00	; 0
    6550:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6552:	40 91 e8 00 	lds	r20, 0x00E8
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    6556:	42 ff       	sbrs	r20, 2
    6558:	de cf       	rjmp	.-68     	; 0x6516 <Endpoint_WaitUntilReady+0x1e>

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    655a:	08 95       	ret

0000655c <USB_Disable>:
	USB_ResetInterface();
}

void USB_Disable(void)
{
	USB_INT_DisableAllInterrupts();
    655c:	67 d0       	rcall	.+206    	; 0x662c <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    655e:	6e d0       	rcall	.+220    	; 0x663c <USB_INT_ClearAllInterrupts>
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    6560:	e0 ee       	ldi	r30, 0xE0	; 224
    6562:	f0 e0       	ldi	r31, 0x00	; 0
    6564:	80 81       	ld	r24, Z
    6566:	81 60       	ori	r24, 0x01	; 1
    6568:	80 83       	st	Z, r24
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USBCON &= ~(1 << USBE);
    656a:	e8 ed       	ldi	r30, 0xD8	; 216
    656c:	f0 e0       	ldi	r31, 0x00	; 0
    656e:	80 81       	ld	r24, Z
    6570:	8f 77       	andi	r24, 0x7F	; 127
    6572:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    6574:	19 bc       	out	0x29, r1	; 41

			static inline void USB_REG_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_Off(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON &= ~(1 << UVREGE);
    6576:	a7 ed       	ldi	r26, 0xD7	; 215
    6578:	b0 e0       	ldi	r27, 0x00	; 0
    657a:	8c 91       	ld	r24, X
    657c:	8e 7f       	andi	r24, 0xFE	; 254
    657e:	8c 93       	st	X, r24
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    6580:	80 81       	ld	r24, Z
    6582:	8f 7e       	andi	r24, 0xEF	; 239
    6584:	80 83       	st	Z, r24

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
    6586:	10 92 cd 09 	sts	0x09CD, r1
    658a:	08 95       	ret

0000658c <USB_ResetInterface>:
}

void USB_ResetInterface(void)
{
    658c:	0f 93       	push	r16
    658e:	1f 93       	push	r17
    6590:	cf 93       	push	r28
    6592:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    6594:	4b d0       	rcall	.+150    	; 0x662c <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    6596:	52 d0       	rcall	.+164    	; 0x663c <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    6598:	c8 ed       	ldi	r28, 0xD8	; 216
    659a:	d0 e0       	ldi	r29, 0x00	; 0
    659c:	88 81       	ld	r24, Y
    659e:	8f 77       	andi	r24, 0x7F	; 127
    65a0:	88 83       	st	Y, r24
				USBCON |=  (1 << USBE);
    65a2:	88 81       	ld	r24, Y
    65a4:	80 68       	ori	r24, 0x80	; 128
    65a6:	88 83       	st	Y, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    65a8:	88 81       	ld	r24, Y
    65aa:	8f 7d       	andi	r24, 0xDF	; 223
    65ac:	88 83       	st	Y, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    65ae:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    65b0:	10 92 ce 09 	sts	0x09CE, r1
	USB_Device_ConfigurationNumber  = 0;
    65b4:	10 92 ca 09 	sts	0x09CA, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    65b8:	10 92 cc 09 	sts	0x09CC, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    65bc:	10 92 cb 09 	sts	0x09CB, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    65c0:	00 ee       	ldi	r16, 0xE0	; 224
    65c2:	10 e0       	ldi	r17, 0x00	; 0
    65c4:	f8 01       	movw	r30, r16
    65c6:	80 81       	ld	r24, Z
    65c8:	8b 7f       	andi	r24, 0xFB	; 251
    65ca:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    65cc:	88 81       	ld	r24, Y
    65ce:	81 60       	ori	r24, 0x01	; 1
    65d0:	88 83       	st	Y, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    65d2:	42 e0       	ldi	r20, 0x02	; 2
    65d4:	60 e0       	ldi	r22, 0x00	; 0
    65d6:	80 e0       	ldi	r24, 0x00	; 0
    65d8:	f3 de       	rcall	.-538    	; 0x63c0 <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    65da:	e1 ee       	ldi	r30, 0xE1	; 225
    65dc:	f0 e0       	ldi	r31, 0x00	; 0
    65de:	80 81       	ld	r24, Z
    65e0:	8e 7f       	andi	r24, 0xFE	; 254
    65e2:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    65e4:	e2 ee       	ldi	r30, 0xE2	; 226
    65e6:	f0 e0       	ldi	r31, 0x00	; 0
    65e8:	80 81       	ld	r24, Z
    65ea:	81 60       	ori	r24, 0x01	; 1
    65ec:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    65ee:	80 81       	ld	r24, Z
    65f0:	88 60       	ori	r24, 0x08	; 8
    65f2:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    65f4:	f8 01       	movw	r30, r16
    65f6:	80 81       	ld	r24, Z
    65f8:	8e 7f       	andi	r24, 0xFE	; 254
    65fa:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    65fc:	88 81       	ld	r24, Y
    65fe:	80 61       	ori	r24, 0x10	; 16
    6600:	88 83       	st	Y, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    6602:	df 91       	pop	r29
    6604:	cf 91       	pop	r28
    6606:	1f 91       	pop	r17
    6608:	0f 91       	pop	r16
    660a:	08 95       	ret

0000660c <USB_Init>:
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    660c:	e8 ed       	ldi	r30, 0xD8	; 216
    660e:	f0 e0       	ldi	r31, 0x00	; 0
    6610:	80 81       	ld	r24, Z
    6612:	8f 7e       	andi	r24, 0xEF	; 239
    6614:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    6616:	e7 ed       	ldi	r30, 0xD7	; 215
    6618:	f0 e0       	ldi	r31, 0x00	; 0
    661a:	80 81       	ld	r24, Z
    661c:	81 60       	ori	r24, 0x01	; 1
    661e:	80 83       	st	Z, r24
	  USB_REG_Off();

	if (!(USB_Options & USB_OPT_MANUAL_PLL))
	{
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = (1 << PDIV2);
    6620:	84 e0       	ldi	r24, 0x04	; 4
    6622:	82 bf       	out	0x32, r24	; 50
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    6624:	81 e0       	ldi	r24, 0x01	; 1
    6626:	80 93 cd 09 	sts	0x09CD, r24

	USB_ResetInterface();
    662a:	b0 cf       	rjmp	.-160    	; 0x658c <USB_ResetInterface>

0000662c <USB_INT_DisableAllInterrupts>:
void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
    662c:	e8 ed       	ldi	r30, 0xD8	; 216
    662e:	f0 e0       	ldi	r31, 0x00	; 0
    6630:	80 81       	ld	r24, Z
    6632:	8e 7f       	andi	r24, 0xFE	; 254
    6634:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    6636:	10 92 e2 00 	sts	0x00E2, r1
    663a:	08 95       	ret

0000663c <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    663c:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    6640:	10 92 e1 00 	sts	0x00E1, r1
    6644:	08 95       	ret

00006646 <__vector_10>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    6646:	1f 92       	push	r1
    6648:	0f 92       	push	r0
    664a:	0f b6       	in	r0, 0x3f	; 63
    664c:	0f 92       	push	r0
    664e:	11 24       	eor	r1, r1
    6650:	2f 93       	push	r18
    6652:	3f 93       	push	r19
    6654:	4f 93       	push	r20
    6656:	5f 93       	push	r21
    6658:	6f 93       	push	r22
    665a:	7f 93       	push	r23
    665c:	8f 93       	push	r24
    665e:	9f 93       	push	r25
    6660:	af 93       	push	r26
    6662:	bf 93       	push	r27
    6664:	ef 93       	push	r30
    6666:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    6668:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    666c:	82 ff       	sbrs	r24, 2
    666e:	0b c0       	rjmp	.+22     	; 0x6686 <__vector_10+0x40>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    6670:	80 91 e2 00 	lds	r24, 0x00E2
    6674:	82 ff       	sbrs	r24, 2
    6676:	07 c0       	rjmp	.+14     	; 0x6686 <__vector_10+0x40>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    6678:	80 91 e1 00 	lds	r24, 0x00E1
    667c:	8b 7f       	andi	r24, 0xFB	; 251
    667e:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    6682:	0e 94 a5 25 	call	0x4b4a	; 0x4b4a <EVENT_USB_Device_StartOfFrame>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    6686:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    668a:	80 ff       	sbrs	r24, 0
    668c:	1d c0       	rjmp	.+58     	; 0x66c8 <__vector_10+0x82>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    668e:	80 91 d8 00 	lds	r24, 0x00D8
    6692:	80 ff       	sbrs	r24, 0
    6694:	19 c0       	rjmp	.+50     	; 0x66c8 <__vector_10+0x82>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    6696:	80 91 da 00 	lds	r24, 0x00DA
    669a:	8e 7f       	andi	r24, 0xFE	; 254
    669c:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    66a0:	80 91 d9 00 	lds	r24, 0x00D9

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    66a4:	19 bc       	out	0x29, r1	; 41
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    66a6:	80 ff       	sbrs	r24, 0
    66a8:	0b c0       	rjmp	.+22     	; 0x66c0 <__vector_10+0x7a>
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    66aa:	82 e0       	ldi	r24, 0x02	; 2
    66ac:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    66ae:	09 b4       	in	r0, 0x29	; 41
    66b0:	00 fe       	sbrs	r0, 0
    66b2:	fd cf       	rjmp	.-6      	; 0x66ae <__vector_10+0x68>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    66b4:	81 e0       	ldi	r24, 0x01	; 1
    66b6:	80 93 ce 09 	sts	0x09CE, r24
			EVENT_USB_Device_Connect();
    66ba:	0e 94 87 25 	call	0x4b0e	; 0x4b0e <EVENT_USB_Device_Connect>
    66be:	04 c0       	rjmp	.+8      	; 0x66c8 <__vector_10+0x82>
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    66c0:	10 92 ce 09 	sts	0x09CE, r1
			EVENT_USB_Device_Disconnect();
    66c4:	0e 94 88 25 	call	0x4b10	; 0x4b10 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    66c8:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    66cc:	80 ff       	sbrs	r24, 0
    66ce:	19 c0       	rjmp	.+50     	; 0x6702 <__vector_10+0xbc>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    66d0:	80 91 e2 00 	lds	r24, 0x00E2
    66d4:	80 ff       	sbrs	r24, 0
    66d6:	15 c0       	rjmp	.+42     	; 0x6702 <__vector_10+0xbc>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    66d8:	80 91 e2 00 	lds	r24, 0x00E2
    66dc:	8e 7f       	andi	r24, 0xFE	; 254
    66de:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    66e2:	80 91 e2 00 	lds	r24, 0x00E2
    66e6:	80 61       	ori	r24, 0x10	; 16
    66e8:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    66ec:	80 91 d8 00 	lds	r24, 0x00D8
    66f0:	80 62       	ori	r24, 0x20	; 32
    66f2:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    66f6:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    66f8:	85 e0       	ldi	r24, 0x05	; 5
    66fa:	80 93 ce 09 	sts	0x09CE, r24
		EVENT_USB_Device_Suspend();
    66fe:	0e 94 8f 25 	call	0x4b1e	; 0x4b1e <EVENT_USB_Device_Suspend>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    6702:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    6706:	84 ff       	sbrs	r24, 4
    6708:	2f c0       	rjmp	.+94     	; 0x6768 <__vector_10+0x122>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    670a:	80 91 e2 00 	lds	r24, 0x00E2
    670e:	84 ff       	sbrs	r24, 4
    6710:	2b c0       	rjmp	.+86     	; 0x6768 <__vector_10+0x122>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    6712:	19 bc       	out	0x29, r1	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    6714:	82 e0       	ldi	r24, 0x02	; 2
    6716:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    6718:	09 b4       	in	r0, 0x29	; 41
    671a:	00 fe       	sbrs	r0, 0
    671c:	fd cf       	rjmp	.-6      	; 0x6718 <__vector_10+0xd2>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    671e:	80 91 d8 00 	lds	r24, 0x00D8
    6722:	8f 7d       	andi	r24, 0xDF	; 223
    6724:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    6728:	80 91 e1 00 	lds	r24, 0x00E1
    672c:	8f 7e       	andi	r24, 0xEF	; 239
    672e:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    6732:	80 91 e2 00 	lds	r24, 0x00E2
    6736:	8f 7e       	andi	r24, 0xEF	; 239
    6738:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    673c:	80 91 e2 00 	lds	r24, 0x00E2
    6740:	81 60       	ori	r24, 0x01	; 1
    6742:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    6746:	80 91 ca 09 	lds	r24, 0x09CA
    674a:	88 23       	and	r24, r24
    674c:	11 f0       	breq	.+4      	; 0x6752 <__vector_10+0x10c>
		  USB_DeviceState = DEVICE_STATE_Configured;
    674e:	84 e0       	ldi	r24, 0x04	; 4
    6750:	07 c0       	rjmp	.+14     	; 0x6760 <__vector_10+0x11a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    6752:	80 91 e3 00 	lds	r24, 0x00E3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    6756:	87 fd       	sbrc	r24, 7
    6758:	02 c0       	rjmp	.+4      	; 0x675e <__vector_10+0x118>
    675a:	81 e0       	ldi	r24, 0x01	; 1
    675c:	01 c0       	rjmp	.+2      	; 0x6760 <__vector_10+0x11a>
    675e:	83 e0       	ldi	r24, 0x03	; 3
    6760:	80 93 ce 09 	sts	0x09CE, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    6764:	0e 94 90 25 	call	0x4b20	; 0x4b20 <EVENT_USB_Device_WakeUp>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    6768:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    676c:	83 ff       	sbrs	r24, 3
    676e:	22 c0       	rjmp	.+68     	; 0x67b4 <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    6770:	80 91 e2 00 	lds	r24, 0x00E2
    6774:	83 ff       	sbrs	r24, 3
    6776:	1e c0       	rjmp	.+60     	; 0x67b4 <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    6778:	80 91 e1 00 	lds	r24, 0x00E1
    677c:	87 7f       	andi	r24, 0xF7	; 247
    677e:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    6782:	82 e0       	ldi	r24, 0x02	; 2
    6784:	80 93 ce 09 	sts	0x09CE, r24
		USB_Device_ConfigurationNumber = 0;
    6788:	10 92 ca 09 	sts	0x09CA, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    678c:	80 91 e1 00 	lds	r24, 0x00E1
    6790:	8e 7f       	andi	r24, 0xFE	; 254
    6792:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    6796:	80 91 e2 00 	lds	r24, 0x00E2
    679a:	8e 7f       	andi	r24, 0xFE	; 254
    679c:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    67a0:	80 91 e2 00 	lds	r24, 0x00E2
    67a4:	80 61       	ori	r24, 0x10	; 16
    67a6:	80 93 e2 00 	sts	0x00E2, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    67aa:	42 e0       	ldi	r20, 0x02	; 2
    67ac:	60 e0       	ldi	r22, 0x00	; 0
    67ae:	80 e0       	ldi	r24, 0x00	; 0
    67b0:	07 de       	rcall	.-1010   	; 0x63c0 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    67b2:	66 d1       	rcall	.+716    	; 0x6a80 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    67b4:	ff 91       	pop	r31
    67b6:	ef 91       	pop	r30
    67b8:	bf 91       	pop	r27
    67ba:	af 91       	pop	r26
    67bc:	9f 91       	pop	r25
    67be:	8f 91       	pop	r24
    67c0:	7f 91       	pop	r23
    67c2:	6f 91       	pop	r22
    67c4:	5f 91       	pop	r21
    67c6:	4f 91       	pop	r20
    67c8:	3f 91       	pop	r19
    67ca:	2f 91       	pop	r18
    67cc:	0f 90       	pop	r0
    67ce:	0f be       	out	0x3f, r0	; 63
    67d0:	0f 90       	pop	r0
    67d2:	1f 90       	pop	r1
    67d4:	18 95       	reti

000067d6 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    67d6:	1f 93       	push	r17
    67d8:	cf 93       	push	r28
    67da:	df 93       	push	r29
    67dc:	cd b7       	in	r28, 0x3d	; 61
    67de:	de b7       	in	r29, 0x3e	; 62
    67e0:	aa 97       	sbiw	r28, 0x2a	; 42
    67e2:	0f b6       	in	r0, 0x3f	; 63
    67e4:	f8 94       	cli
    67e6:	de bf       	out	0x3e, r29	; 62
    67e8:	0f be       	out	0x3f, r0	; 63
    67ea:	cd bf       	out	0x3d, r28	; 61
    67ec:	ef ec       	ldi	r30, 0xCF	; 207
    67ee:	f9 e0       	ldi	r31, 0x09	; 9
    67f0:	88 e0       	ldi	r24, 0x08	; 8
    67f2:	8e 0f       	add	r24, r30
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    67f4:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    67f8:	91 93       	st	Z+, r25
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    67fa:	8e 13       	cpse	r24, r30
    67fc:	fb cf       	rjmp	.-10     	; 0x67f4 <USB_Device_ProcessControlRequest+0x1e>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    67fe:	0e 94 9e 25 	call	0x4b3c	; 0x4b3c <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6802:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    6806:	83 ff       	sbrs	r24, 3
    6808:	23 c1       	rjmp	.+582    	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    680a:	80 91 cf 09 	lds	r24, 0x09CF

		switch (USB_ControlRequest.bRequest)
    680e:	90 91 d0 09 	lds	r25, 0x09D0
    6812:	95 30       	cpi	r25, 0x05	; 5
    6814:	09 f4       	brne	.+2      	; 0x6818 <USB_Device_ProcessControlRequest+0x42>
    6816:	78 c0       	rjmp	.+240    	; 0x6908 <USB_Device_ProcessControlRequest+0x132>
    6818:	30 f4       	brcc	.+12     	; 0x6826 <USB_Device_ProcessControlRequest+0x50>
    681a:	91 30       	cpi	r25, 0x01	; 1
    681c:	81 f1       	breq	.+96     	; 0x687e <USB_Device_ProcessControlRequest+0xa8>
    681e:	68 f0       	brcs	.+26     	; 0x683a <USB_Device_ProcessControlRequest+0x64>
    6820:	93 30       	cpi	r25, 0x03	; 3
    6822:	69 f1       	breq	.+90     	; 0x687e <USB_Device_ProcessControlRequest+0xa8>
    6824:	15 c1       	rjmp	.+554    	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
    6826:	98 30       	cpi	r25, 0x08	; 8
    6828:	09 f4       	brne	.+2      	; 0x682c <USB_Device_ProcessControlRequest+0x56>
    682a:	e3 c0       	rjmp	.+454    	; 0x69f2 <USB_Device_ProcessControlRequest+0x21c>
    682c:	99 30       	cpi	r25, 0x09	; 9
    682e:	09 f4       	brne	.+2      	; 0x6832 <USB_Device_ProcessControlRequest+0x5c>
    6830:	f2 c0       	rjmp	.+484    	; 0x6a16 <USB_Device_ProcessControlRequest+0x240>
    6832:	96 30       	cpi	r25, 0x06	; 6
    6834:	09 f0       	breq	.+2      	; 0x6838 <USB_Device_ProcessControlRequest+0x62>
    6836:	0c c1       	rjmp	.+536    	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
    6838:	89 c0       	rjmp	.+274    	; 0x694c <USB_Device_ProcessControlRequest+0x176>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    683a:	80 38       	cpi	r24, 0x80	; 128
    683c:	81 f0       	breq	.+32     	; 0x685e <USB_Device_ProcessControlRequest+0x88>
    683e:	82 38       	cpi	r24, 0x82	; 130
    6840:	09 f0       	breq	.+2      	; 0x6844 <USB_Device_ProcessControlRequest+0x6e>
    6842:	06 c1       	rjmp	.+524    	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6844:	80 91 d3 09 	lds	r24, 0x09D3
    6848:	8f 70       	andi	r24, 0x0F	; 15
    684a:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    684e:	80 91 eb 00 	lds	r24, 0x00EB
    6852:	85 fb       	bst	r24, 5
    6854:	88 27       	eor	r24, r24
    6856:	80 f9       	bld	r24, 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6858:	10 92 e9 00 	sts	0x00E9, r1
    685c:	06 c0       	rjmp	.+12     	; 0x686a <USB_Device_ProcessControlRequest+0x94>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    685e:	80 91 cb 09 	lds	r24, 0x09CB
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    6862:	90 91 cc 09 	lds	r25, 0x09CC
    6866:	91 11       	cpse	r25, r1
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    6868:	82 60       	ori	r24, 0x02	; 2
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    686a:	90 91 e8 00 	lds	r25, 0x00E8
    686e:	97 7f       	andi	r25, 0xF7	; 247
    6870:	90 93 e8 00 	sts	0x00E8, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    6874:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
    6878:	10 92 f1 00 	sts	0x00F1, r1
    687c:	c5 c0       	rjmp	.+394    	; 0x6a08 <USB_Device_ProcessControlRequest+0x232>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    687e:	28 2f       	mov	r18, r24
    6880:	2d 7f       	andi	r18, 0xFD	; 253
    6882:	09 f0       	breq	.+2      	; 0x6886 <USB_Device_ProcessControlRequest+0xb0>
    6884:	e5 c0       	rjmp	.+458    	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    6886:	88 23       	and	r24, r24
    6888:	19 f0       	breq	.+6      	; 0x6890 <USB_Device_ProcessControlRequest+0xba>
    688a:	82 30       	cpi	r24, 0x02	; 2
    688c:	61 f0       	breq	.+24     	; 0x68a6 <USB_Device_ProcessControlRequest+0xd0>
    688e:	e0 c0       	rjmp	.+448    	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    6890:	80 91 d1 09 	lds	r24, 0x09D1
    6894:	81 30       	cpi	r24, 0x01	; 1
    6896:	09 f0       	breq	.+2      	; 0x689a <USB_Device_ProcessControlRequest+0xc4>
    6898:	db c0       	rjmp	.+438    	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    689a:	93 30       	cpi	r25, 0x03	; 3
    689c:	09 f0       	breq	.+2      	; 0x68a0 <USB_Device_ProcessControlRequest+0xca>
    689e:	80 e0       	ldi	r24, 0x00	; 0
    68a0:	80 93 cc 09 	sts	0x09CC, r24
    68a4:	2b c0       	rjmp	.+86     	; 0x68fc <USB_Device_ProcessControlRequest+0x126>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    68a6:	80 91 d1 09 	lds	r24, 0x09D1
    68aa:	81 11       	cpse	r24, r1
    68ac:	27 c0       	rjmp	.+78     	; 0x68fc <USB_Device_ProcessControlRequest+0x126>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    68ae:	80 91 d3 09 	lds	r24, 0x09D3
    68b2:	8f 70       	andi	r24, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    68b4:	09 f4       	brne	.+2      	; 0x68b8 <USB_Device_ProcessControlRequest+0xe2>
    68b6:	cc c0       	rjmp	.+408    	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    68b8:	80 93 e9 00 	sts	0x00E9, r24
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    68bc:	20 91 eb 00 	lds	r18, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    68c0:	20 ff       	sbrs	r18, 0
    68c2:	1c c0       	rjmp	.+56     	; 0x68fc <USB_Device_ProcessControlRequest+0x126>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    68c4:	93 30       	cpi	r25, 0x03	; 3
    68c6:	21 f4       	brne	.+8      	; 0x68d0 <USB_Device_ProcessControlRequest+0xfa>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    68c8:	80 91 eb 00 	lds	r24, 0x00EB
    68cc:	80 62       	ori	r24, 0x20	; 32
    68ce:	14 c0       	rjmp	.+40     	; 0x68f8 <USB_Device_ProcessControlRequest+0x122>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    68d0:	90 91 eb 00 	lds	r25, 0x00EB
    68d4:	90 61       	ori	r25, 0x10	; 16
    68d6:	90 93 eb 00 	sts	0x00EB, r25
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    68da:	21 e0       	ldi	r18, 0x01	; 1
    68dc:	30 e0       	ldi	r19, 0x00	; 0
    68de:	a9 01       	movw	r20, r18
    68e0:	02 c0       	rjmp	.+4      	; 0x68e6 <USB_Device_ProcessControlRequest+0x110>
    68e2:	44 0f       	add	r20, r20
    68e4:	55 1f       	adc	r21, r21
    68e6:	8a 95       	dec	r24
    68e8:	e2 f7       	brpl	.-8      	; 0x68e2 <USB_Device_ProcessControlRequest+0x10c>
    68ea:	40 93 ea 00 	sts	0x00EA, r20
				UERST = 0;
    68ee:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    68f2:	80 91 eb 00 	lds	r24, 0x00EB
    68f6:	88 60       	ori	r24, 0x08	; 8
    68f8:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    68fc:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6900:	80 91 e8 00 	lds	r24, 0x00E8
    6904:	87 7f       	andi	r24, 0xF7	; 247
    6906:	83 c0       	rjmp	.+262    	; 0x6a0e <USB_Device_ProcessControlRequest+0x238>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    6908:	81 11       	cpse	r24, r1
    690a:	a2 c0       	rjmp	.+324    	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    690c:	10 91 d1 09 	lds	r17, 0x09D1
    6910:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    6912:	80 91 e3 00 	lds	r24, 0x00E3
    6916:	80 78       	andi	r24, 0x80	; 128
    6918:	81 2b       	or	r24, r17
    691a:	80 93 e3 00 	sts	0x00E3, r24
    691e:	80 91 e8 00 	lds	r24, 0x00E8
    6922:	87 7f       	andi	r24, 0xF7	; 247
    6924:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    6928:	c8 dd       	rcall	.-1136   	; 0x64ba <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    692a:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    692e:	80 ff       	sbrs	r24, 0
    6930:	fc cf       	rjmp	.-8      	; 0x692a <USB_Device_ProcessControlRequest+0x154>
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;

				UDADDR |= (1 << ADDEN);
    6932:	80 91 e3 00 	lds	r24, 0x00E3
    6936:	80 68       	ori	r24, 0x80	; 128
    6938:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    693c:	11 11       	cpse	r17, r1
    693e:	02 c0       	rjmp	.+4      	; 0x6944 <USB_Device_ProcessControlRequest+0x16e>
    6940:	82 e0       	ldi	r24, 0x02	; 2
    6942:	01 c0       	rjmp	.+2      	; 0x6946 <USB_Device_ProcessControlRequest+0x170>
    6944:	83 e0       	ldi	r24, 0x03	; 3
    6946:	80 93 ce 09 	sts	0x09CE, r24
    694a:	82 c0       	rjmp	.+260    	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    694c:	80 58       	subi	r24, 0x80	; 128
    694e:	82 30       	cpi	r24, 0x02	; 2
    6950:	08 f0       	brcs	.+2      	; 0x6954 <USB_Device_ProcessControlRequest+0x17e>
    6952:	7e c0       	rjmp	.+252    	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    6954:	80 91 d1 09 	lds	r24, 0x09D1
    6958:	90 91 d2 09 	lds	r25, 0x09D2
    695c:	8c 3d       	cpi	r24, 0xDC	; 220
    695e:	53 e0       	ldi	r21, 0x03	; 3
    6960:	95 07       	cpc	r25, r21
    6962:	71 f5       	brne	.+92     	; 0x69c0 <USB_Device_ProcessControlRequest+0x1ea>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    6964:	83 e0       	ldi	r24, 0x03	; 3
    6966:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    6968:	8a e2       	ldi	r24, 0x2A	; 42
    696a:	89 83       	std	Y+1, r24	; 0x01
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    696c:	4f b7       	in	r20, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    696e:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    6970:	de 01       	movw	r26, r28
    6972:	13 96       	adiw	r26, 0x03	; 3
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    6974:	20 e0       	ldi	r18, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    6976:	3e e0       	ldi	r19, 0x0E	; 14

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    6978:	51 e2       	ldi	r21, 0x21	; 33
    697a:	e3 2f       	mov	r30, r19
    697c:	f0 e0       	ldi	r31, 0x00	; 0
    697e:	50 93 57 00 	sts	0x0057, r21
    6982:	e4 91       	lpm	r30, Z

					if (SerialCharNum & 0x01)
    6984:	20 ff       	sbrs	r18, 0
    6986:	03 c0       	rjmp	.+6      	; 0x698e <USB_Device_ProcessControlRequest+0x1b8>
					{
						SerialByte >>= 4;
    6988:	e2 95       	swap	r30
    698a:	ef 70       	andi	r30, 0x0F	; 15
						SigReadAddress++;
    698c:	3f 5f       	subi	r19, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    698e:	ef 70       	andi	r30, 0x0F	; 15
    6990:	8e 2f       	mov	r24, r30
    6992:	90 e0       	ldi	r25, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    6994:	ea 30       	cpi	r30, 0x0A	; 10
    6996:	10 f0       	brcs	.+4      	; 0x699c <USB_Device_ProcessControlRequest+0x1c6>
    6998:	c7 96       	adiw	r24, 0x37	; 55
    699a:	01 c0       	rjmp	.+2      	; 0x699e <USB_Device_ProcessControlRequest+0x1c8>
    699c:	c0 96       	adiw	r24, 0x30	; 48
    699e:	8d 93       	st	X+, r24
    69a0:	9d 93       	st	X+, r25
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    69a2:	2f 5f       	subi	r18, 0xFF	; 255
    69a4:	24 31       	cpi	r18, 0x14	; 20
    69a6:	49 f7       	brne	.-46     	; 0x697a <USB_Device_ProcessControlRequest+0x1a4>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    69a8:	4f bf       	out	0x3f, r20	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    69aa:	80 91 e8 00 	lds	r24, 0x00E8
    69ae:	87 7f       	andi	r24, 0xF7	; 247
    69b0:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    69b4:	6a e2       	ldi	r22, 0x2A	; 42
    69b6:	70 e0       	ldi	r23, 0x00	; 0
    69b8:	ce 01       	movw	r24, r28
    69ba:	01 96       	adiw	r24, 0x01	; 1
    69bc:	fd db       	rcall	.-2054   	; 0x61b8 <Endpoint_Write_Control_Stream_LE>
    69be:	13 c0       	rjmp	.+38     	; 0x69e6 <USB_Device_ProcessControlRequest+0x210>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    69c0:	ae 01       	movw	r20, r28
    69c2:	4f 5f       	subi	r20, 0xFF	; 255
    69c4:	5f 4f       	sbci	r21, 0xFF	; 255
    69c6:	60 91 d3 09 	lds	r22, 0x09D3
    69ca:	0e 94 a3 0b 	call	0x1746	; 0x1746 <CALLBACK_USB_GetDescriptor>
    69ce:	bc 01       	movw	r22, r24
    69d0:	89 2b       	or	r24, r25
    69d2:	09 f4       	brne	.+2      	; 0x69d6 <USB_Device_ProcessControlRequest+0x200>
    69d4:	3d c0       	rjmp	.+122    	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
    69d6:	90 91 e8 00 	lds	r25, 0x00E8
    69da:	97 7f       	andi	r25, 0xF7	; 247
    69dc:	90 93 e8 00 	sts	0x00E8, r25
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    69e0:	89 81       	ldd	r24, Y+1	; 0x01
    69e2:	9a 81       	ldd	r25, Y+2	; 0x02
    69e4:	8c dc       	rcall	.-1768   	; 0x62fe <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    69e6:	80 91 e8 00 	lds	r24, 0x00E8
    69ea:	8b 77       	andi	r24, 0x7B	; 123
    69ec:	80 93 e8 00 	sts	0x00E8, r24
    69f0:	2f c0       	rjmp	.+94     	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    69f2:	80 38       	cpi	r24, 0x80	; 128
    69f4:	69 f5       	brne	.+90     	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    69f6:	80 91 e8 00 	lds	r24, 0x00E8
    69fa:	87 7f       	andi	r24, 0xF7	; 247
    69fc:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    6a00:	80 91 ca 09 	lds	r24, 0x09CA
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    6a04:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6a08:	80 91 e8 00 	lds	r24, 0x00E8
    6a0c:	8e 77       	andi	r24, 0x7E	; 126
    6a0e:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    6a12:	53 dd       	rcall	.-1370   	; 0x64ba <Endpoint_ClearStatusStage>
    6a14:	1d c0       	rjmp	.+58     	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    6a16:	81 11       	cpse	r24, r1
    6a18:	1b c0       	rjmp	.+54     	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    6a1a:	90 91 d1 09 	lds	r25, 0x09D1
    6a1e:	92 30       	cpi	r25, 0x02	; 2
    6a20:	b8 f4       	brcc	.+46     	; 0x6a50 <USB_Device_ProcessControlRequest+0x27a>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6a22:	80 91 e8 00 	lds	r24, 0x00E8
    6a26:	87 7f       	andi	r24, 0xF7	; 247
    6a28:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    6a2c:	90 93 ca 09 	sts	0x09CA, r25

	Endpoint_ClearStatusStage();
    6a30:	44 dd       	rcall	.-1400   	; 0x64ba <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    6a32:	80 91 ca 09 	lds	r24, 0x09CA
    6a36:	81 11       	cpse	r24, r1
    6a38:	06 c0       	rjmp	.+12     	; 0x6a46 <USB_Device_ProcessControlRequest+0x270>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    6a3a:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    6a3e:	87 fd       	sbrc	r24, 7
    6a40:	02 c0       	rjmp	.+4      	; 0x6a46 <USB_Device_ProcessControlRequest+0x270>
    6a42:	81 e0       	ldi	r24, 0x01	; 1
    6a44:	01 c0       	rjmp	.+2      	; 0x6a48 <USB_Device_ProcessControlRequest+0x272>
    6a46:	84 e0       	ldi	r24, 0x04	; 4
    6a48:	80 93 ce 09 	sts	0x09CE, r24

	EVENT_USB_Device_ConfigurationChanged();
    6a4c:	0e 94 91 25 	call	0x4b22	; 0x4b22 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6a50:	80 91 e8 00 	lds	r24, 0x00E8
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    6a54:	83 ff       	sbrs	r24, 3
    6a56:	0a c0       	rjmp	.+20     	; 0x6a6c <USB_Device_ProcessControlRequest+0x296>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6a58:	80 91 e8 00 	lds	r24, 0x00E8
    6a5c:	87 7f       	andi	r24, 0xF7	; 247
    6a5e:	80 93 e8 00 	sts	0x00E8, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6a62:	80 91 eb 00 	lds	r24, 0x00EB
    6a66:	80 62       	ori	r24, 0x20	; 32
    6a68:	80 93 eb 00 	sts	0x00EB, r24
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    6a6c:	aa 96       	adiw	r28, 0x2a	; 42
    6a6e:	0f b6       	in	r0, 0x3f	; 63
    6a70:	f8 94       	cli
    6a72:	de bf       	out	0x3e, r29	; 62
    6a74:	0f be       	out	0x3f, r0	; 63
    6a76:	cd bf       	out	0x3d, r28	; 61
    6a78:	df 91       	pop	r29
    6a7a:	cf 91       	pop	r28
    6a7c:	1f 91       	pop	r17
    6a7e:	08 95       	ret

00006a80 <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    6a80:	08 95       	ret

00006a82 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    6a82:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    6a84:	80 91 ce 09 	lds	r24, 0x09CE
    6a88:	88 23       	and	r24, r24
    6a8a:	99 f0       	breq	.+38     	; 0x6ab2 <USB_USBTask+0x30>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    6a8c:	c0 91 e9 00 	lds	r28, 0x00E9
    6a90:	cf 70       	andi	r28, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    6a92:	90 91 ec 00 	lds	r25, 0x00EC
    6a96:	89 2f       	mov	r24, r25
    6a98:	81 70       	andi	r24, 0x01	; 1
    6a9a:	90 fd       	sbrc	r25, 0
    6a9c:	80 e8       	ldi	r24, 0x80	; 128
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    6a9e:	c8 2b       	or	r28, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6aa0:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6aa4:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    6aa8:	83 fd       	sbrc	r24, 3
	  USB_Device_ProcessControlRequest();
    6aaa:	95 de       	rcall	.-726    	; 0x67d6 <USB_Device_ProcessControlRequest>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6aac:	cf 70       	andi	r28, 0x0F	; 15
    6aae:	c0 93 e9 00 	sts	0x00E9, r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    6ab2:	cf 91       	pop	r28
    6ab4:	08 95       	ret

00006ab6 <__udivmodqi4>:
    6ab6:	99 1b       	sub	r25, r25
    6ab8:	79 e0       	ldi	r23, 0x09	; 9
    6aba:	04 c0       	rjmp	.+8      	; 0x6ac4 <__udivmodqi4_ep>

00006abc <__udivmodqi4_loop>:
    6abc:	99 1f       	adc	r25, r25
    6abe:	96 17       	cp	r25, r22
    6ac0:	08 f0       	brcs	.+2      	; 0x6ac4 <__udivmodqi4_ep>
    6ac2:	96 1b       	sub	r25, r22

00006ac4 <__udivmodqi4_ep>:
    6ac4:	88 1f       	adc	r24, r24
    6ac6:	7a 95       	dec	r23
    6ac8:	c9 f7       	brne	.-14     	; 0x6abc <__udivmodqi4_loop>
    6aca:	80 95       	com	r24
    6acc:	08 95       	ret

00006ace <__divmodhi4>:
    6ace:	97 fb       	bst	r25, 7
    6ad0:	07 2e       	mov	r0, r23
    6ad2:	16 f4       	brtc	.+4      	; 0x6ad8 <__divmodhi4+0xa>
    6ad4:	00 94       	com	r0
    6ad6:	06 d0       	rcall	.+12     	; 0x6ae4 <__divmodhi4_neg1>
    6ad8:	77 fd       	sbrc	r23, 7
    6ada:	08 d0       	rcall	.+16     	; 0x6aec <__divmodhi4_neg2>
    6adc:	82 d0       	rcall	.+260    	; 0x6be2 <__udivmodhi4>
    6ade:	07 fc       	sbrc	r0, 7
    6ae0:	05 d0       	rcall	.+10     	; 0x6aec <__divmodhi4_neg2>
    6ae2:	3e f4       	brtc	.+14     	; 0x6af2 <__divmodhi4_exit>

00006ae4 <__divmodhi4_neg1>:
    6ae4:	90 95       	com	r25
    6ae6:	81 95       	neg	r24
    6ae8:	9f 4f       	sbci	r25, 0xFF	; 255
    6aea:	08 95       	ret

00006aec <__divmodhi4_neg2>:
    6aec:	70 95       	com	r23
    6aee:	61 95       	neg	r22
    6af0:	7f 4f       	sbci	r23, 0xFF	; 255

00006af2 <__divmodhi4_exit>:
    6af2:	08 95       	ret

00006af4 <__udivmodsi4>:
    6af4:	a1 e2       	ldi	r26, 0x21	; 33
    6af6:	1a 2e       	mov	r1, r26
    6af8:	aa 1b       	sub	r26, r26
    6afa:	bb 1b       	sub	r27, r27
    6afc:	fd 01       	movw	r30, r26
    6afe:	0d c0       	rjmp	.+26     	; 0x6b1a <__udivmodsi4_ep>

00006b00 <__udivmodsi4_loop>:
    6b00:	aa 1f       	adc	r26, r26
    6b02:	bb 1f       	adc	r27, r27
    6b04:	ee 1f       	adc	r30, r30
    6b06:	ff 1f       	adc	r31, r31
    6b08:	a2 17       	cp	r26, r18
    6b0a:	b3 07       	cpc	r27, r19
    6b0c:	e4 07       	cpc	r30, r20
    6b0e:	f5 07       	cpc	r31, r21
    6b10:	20 f0       	brcs	.+8      	; 0x6b1a <__udivmodsi4_ep>
    6b12:	a2 1b       	sub	r26, r18
    6b14:	b3 0b       	sbc	r27, r19
    6b16:	e4 0b       	sbc	r30, r20
    6b18:	f5 0b       	sbc	r31, r21

00006b1a <__udivmodsi4_ep>:
    6b1a:	66 1f       	adc	r22, r22
    6b1c:	77 1f       	adc	r23, r23
    6b1e:	88 1f       	adc	r24, r24
    6b20:	99 1f       	adc	r25, r25
    6b22:	1a 94       	dec	r1
    6b24:	69 f7       	brne	.-38     	; 0x6b00 <__udivmodsi4_loop>
    6b26:	60 95       	com	r22
    6b28:	70 95       	com	r23
    6b2a:	80 95       	com	r24
    6b2c:	90 95       	com	r25
    6b2e:	9b 01       	movw	r18, r22
    6b30:	ac 01       	movw	r20, r24
    6b32:	bd 01       	movw	r22, r26
    6b34:	cf 01       	movw	r24, r30
    6b36:	08 95       	ret

00006b38 <__muluhisi3>:
    6b38:	81 d0       	rcall	.+258    	; 0x6c3c <__umulhisi3>
    6b3a:	a5 9f       	mul	r26, r21
    6b3c:	90 0d       	add	r25, r0
    6b3e:	b4 9f       	mul	r27, r20
    6b40:	90 0d       	add	r25, r0
    6b42:	a4 9f       	mul	r26, r20
    6b44:	80 0d       	add	r24, r0
    6b46:	91 1d       	adc	r25, r1
    6b48:	11 24       	eor	r1, r1
    6b4a:	08 95       	ret

00006b4c <__clzdi2>:
    6b4c:	5e d0       	rcall	.+188    	; 0x6c0a <__clzsi2>
    6b4e:	85 ff       	sbrs	r24, 5
    6b50:	08 95       	ret
    6b52:	b9 01       	movw	r22, r18
    6b54:	ca 01       	movw	r24, r20
    6b56:	59 d0       	rcall	.+178    	; 0x6c0a <__clzsi2>
    6b58:	80 5e       	subi	r24, 0xE0	; 224
    6b5a:	08 95       	ret

00006b5c <__ashldi3>:
    6b5c:	0f 93       	push	r16
    6b5e:	08 30       	cpi	r16, 0x08	; 8
    6b60:	90 f0       	brcs	.+36     	; 0x6b86 <__ashldi3+0x2a>
    6b62:	98 2f       	mov	r25, r24
    6b64:	87 2f       	mov	r24, r23
    6b66:	76 2f       	mov	r23, r22
    6b68:	65 2f       	mov	r22, r21
    6b6a:	54 2f       	mov	r21, r20
    6b6c:	43 2f       	mov	r20, r19
    6b6e:	32 2f       	mov	r19, r18
    6b70:	22 27       	eor	r18, r18
    6b72:	08 50       	subi	r16, 0x08	; 8
    6b74:	f4 cf       	rjmp	.-24     	; 0x6b5e <__ashldi3+0x2>
    6b76:	22 0f       	add	r18, r18
    6b78:	33 1f       	adc	r19, r19
    6b7a:	44 1f       	adc	r20, r20
    6b7c:	55 1f       	adc	r21, r21
    6b7e:	66 1f       	adc	r22, r22
    6b80:	77 1f       	adc	r23, r23
    6b82:	88 1f       	adc	r24, r24
    6b84:	99 1f       	adc	r25, r25
    6b86:	0a 95       	dec	r16
    6b88:	b2 f7       	brpl	.-20     	; 0x6b76 <__ashldi3+0x1a>
    6b8a:	0f 91       	pop	r16
    6b8c:	08 95       	ret

00006b8e <__ashrdi3>:
    6b8e:	97 fb       	bst	r25, 7
    6b90:	10 f8       	bld	r1, 0

00006b92 <__lshrdi3>:
    6b92:	16 94       	lsr	r1
    6b94:	00 08       	sbc	r0, r0
    6b96:	0f 93       	push	r16
    6b98:	08 30       	cpi	r16, 0x08	; 8
    6b9a:	98 f0       	brcs	.+38     	; 0x6bc2 <__lshrdi3+0x30>
    6b9c:	08 50       	subi	r16, 0x08	; 8
    6b9e:	23 2f       	mov	r18, r19
    6ba0:	34 2f       	mov	r19, r20
    6ba2:	45 2f       	mov	r20, r21
    6ba4:	56 2f       	mov	r21, r22
    6ba6:	67 2f       	mov	r22, r23
    6ba8:	78 2f       	mov	r23, r24
    6baa:	89 2f       	mov	r24, r25
    6bac:	90 2d       	mov	r25, r0
    6bae:	f4 cf       	rjmp	.-24     	; 0x6b98 <__lshrdi3+0x6>
    6bb0:	05 94       	asr	r0
    6bb2:	97 95       	ror	r25
    6bb4:	87 95       	ror	r24
    6bb6:	77 95       	ror	r23
    6bb8:	67 95       	ror	r22
    6bba:	57 95       	ror	r21
    6bbc:	47 95       	ror	r20
    6bbe:	37 95       	ror	r19
    6bc0:	27 95       	ror	r18
    6bc2:	0a 95       	dec	r16
    6bc4:	aa f7       	brpl	.-22     	; 0x6bb0 <__lshrdi3+0x1e>
    6bc6:	0f 91       	pop	r16
    6bc8:	08 95       	ret

00006bca <__cmpdi2_s8>:
    6bca:	00 24       	eor	r0, r0
    6bcc:	a7 fd       	sbrc	r26, 7
    6bce:	00 94       	com	r0
    6bd0:	2a 17       	cp	r18, r26
    6bd2:	30 05       	cpc	r19, r0
    6bd4:	40 05       	cpc	r20, r0
    6bd6:	50 05       	cpc	r21, r0
    6bd8:	60 05       	cpc	r22, r0
    6bda:	70 05       	cpc	r23, r0
    6bdc:	80 05       	cpc	r24, r0
    6bde:	90 05       	cpc	r25, r0
    6be0:	08 95       	ret

00006be2 <__udivmodhi4>:
    6be2:	aa 1b       	sub	r26, r26
    6be4:	bb 1b       	sub	r27, r27
    6be6:	51 e1       	ldi	r21, 0x11	; 17
    6be8:	07 c0       	rjmp	.+14     	; 0x6bf8 <__udivmodhi4_ep>

00006bea <__udivmodhi4_loop>:
    6bea:	aa 1f       	adc	r26, r26
    6bec:	bb 1f       	adc	r27, r27
    6bee:	a6 17       	cp	r26, r22
    6bf0:	b7 07       	cpc	r27, r23
    6bf2:	10 f0       	brcs	.+4      	; 0x6bf8 <__udivmodhi4_ep>
    6bf4:	a6 1b       	sub	r26, r22
    6bf6:	b7 0b       	sbc	r27, r23

00006bf8 <__udivmodhi4_ep>:
    6bf8:	88 1f       	adc	r24, r24
    6bfa:	99 1f       	adc	r25, r25
    6bfc:	5a 95       	dec	r21
    6bfe:	a9 f7       	brne	.-22     	; 0x6bea <__udivmodhi4_loop>
    6c00:	80 95       	com	r24
    6c02:	90 95       	com	r25
    6c04:	bc 01       	movw	r22, r24
    6c06:	cd 01       	movw	r24, r26
    6c08:	08 95       	ret

00006c0a <__clzsi2>:
    6c0a:	06 d0       	rcall	.+12     	; 0x6c18 <__clzhi2>
    6c0c:	84 ff       	sbrs	r24, 4
    6c0e:	08 95       	ret
    6c10:	cb 01       	movw	r24, r22
    6c12:	02 d0       	rcall	.+4      	; 0x6c18 <__clzhi2>
    6c14:	80 5f       	subi	r24, 0xF0	; 240
    6c16:	08 95       	ret

00006c18 <__clzhi2>:
    6c18:	aa 27       	eor	r26, r26
    6c1a:	99 23       	and	r25, r25
    6c1c:	29 f4       	brne	.+10     	; 0x6c28 <__clzhi2+0x10>
    6c1e:	a8 5f       	subi	r26, 0xF8	; 248
    6c20:	98 2b       	or	r25, r24
    6c22:	11 f4       	brne	.+4      	; 0x6c28 <__clzhi2+0x10>
    6c24:	80 e1       	ldi	r24, 0x10	; 16
    6c26:	08 95       	ret
    6c28:	90 31       	cpi	r25, 0x10	; 16
    6c2a:	18 f4       	brcc	.+6      	; 0x6c32 <__clzhi2+0x1a>
    6c2c:	ad 5f       	subi	r26, 0xFD	; 253
    6c2e:	92 95       	swap	r25
    6c30:	a3 95       	inc	r26
    6c32:	99 0f       	add	r25, r25
    6c34:	e8 f7       	brcc	.-6      	; 0x6c30 <__clzhi2+0x18>
    6c36:	8a 2f       	mov	r24, r26
    6c38:	99 27       	eor	r25, r25
    6c3a:	08 95       	ret

00006c3c <__umulhisi3>:
    6c3c:	a2 9f       	mul	r26, r18
    6c3e:	b0 01       	movw	r22, r0
    6c40:	b3 9f       	mul	r27, r19
    6c42:	c0 01       	movw	r24, r0
    6c44:	a3 9f       	mul	r26, r19
    6c46:	70 0d       	add	r23, r0
    6c48:	81 1d       	adc	r24, r1
    6c4a:	11 24       	eor	r1, r1
    6c4c:	91 1d       	adc	r25, r1
    6c4e:	b2 9f       	mul	r27, r18
    6c50:	70 0d       	add	r23, r0
    6c52:	81 1d       	adc	r24, r1
    6c54:	11 24       	eor	r1, r1
    6c56:	91 1d       	adc	r25, r1
    6c58:	08 95       	ret

00006c5a <toupper>:
    6c5a:	91 11       	cpse	r25, r1
    6c5c:	08 95       	ret
    6c5e:	81 56       	subi	r24, 0x61	; 97
    6c60:	8a 51       	subi	r24, 0x1A	; 26
    6c62:	08 f4       	brcc	.+2      	; 0x6c66 <toupper+0xc>
    6c64:	80 52       	subi	r24, 0x20	; 32
    6c66:	85 58       	subi	r24, 0x85	; 133
    6c68:	08 95       	ret

00006c6a <strcpy_P>:
    6c6a:	fb 01       	movw	r30, r22
    6c6c:	dc 01       	movw	r26, r24
    6c6e:	05 90       	lpm	r0, Z+
    6c70:	0d 92       	st	X+, r0
    6c72:	00 20       	and	r0, r0
    6c74:	e1 f7       	brne	.-8      	; 0x6c6e <strcpy_P+0x4>
    6c76:	08 95       	ret

00006c78 <strtok>:
    6c78:	4c e4       	ldi	r20, 0x4C	; 76
    6c7a:	53 e0       	ldi	r21, 0x03	; 3
    6c7c:	24 c0       	rjmp	.+72     	; 0x6cc6 <strtok_r>

00006c7e <memcmp>:
    6c7e:	fb 01       	movw	r30, r22
    6c80:	dc 01       	movw	r26, r24
    6c82:	04 c0       	rjmp	.+8      	; 0x6c8c <memcmp+0xe>
    6c84:	8d 91       	ld	r24, X+
    6c86:	01 90       	ld	r0, Z+
    6c88:	80 19       	sub	r24, r0
    6c8a:	21 f4       	brne	.+8      	; 0x6c94 <memcmp+0x16>
    6c8c:	41 50       	subi	r20, 0x01	; 1
    6c8e:	50 40       	sbci	r21, 0x00	; 0
    6c90:	c8 f7       	brcc	.-14     	; 0x6c84 <memcmp+0x6>
    6c92:	88 1b       	sub	r24, r24
    6c94:	99 0b       	sbc	r25, r25
    6c96:	08 95       	ret

00006c98 <memcpy>:
    6c98:	fb 01       	movw	r30, r22
    6c9a:	dc 01       	movw	r26, r24
    6c9c:	02 c0       	rjmp	.+4      	; 0x6ca2 <memcpy+0xa>
    6c9e:	01 90       	ld	r0, Z+
    6ca0:	0d 92       	st	X+, r0
    6ca2:	41 50       	subi	r20, 0x01	; 1
    6ca4:	50 40       	sbci	r21, 0x00	; 0
    6ca6:	d8 f7       	brcc	.-10     	; 0x6c9e <memcpy+0x6>
    6ca8:	08 95       	ret

00006caa <memset>:
    6caa:	dc 01       	movw	r26, r24
    6cac:	01 c0       	rjmp	.+2      	; 0x6cb0 <memset+0x6>
    6cae:	6d 93       	st	X+, r22
    6cb0:	41 50       	subi	r20, 0x01	; 1
    6cb2:	50 40       	sbci	r21, 0x00	; 0
    6cb4:	e0 f7       	brcc	.-8      	; 0x6cae <memset+0x4>
    6cb6:	08 95       	ret

00006cb8 <strcpy>:
    6cb8:	fb 01       	movw	r30, r22
    6cba:	dc 01       	movw	r26, r24
    6cbc:	01 90       	ld	r0, Z+
    6cbe:	0d 92       	st	X+, r0
    6cc0:	00 20       	and	r0, r0
    6cc2:	e1 f7       	brne	.-8      	; 0x6cbc <strcpy+0x4>
    6cc4:	08 95       	ret

00006cc6 <strtok_r>:
    6cc6:	fa 01       	movw	r30, r20
    6cc8:	a1 91       	ld	r26, Z+
    6cca:	b0 81       	ld	r27, Z
    6ccc:	00 97       	sbiw	r24, 0x00	; 0
    6cce:	19 f4       	brne	.+6      	; 0x6cd6 <strtok_r+0x10>
    6cd0:	10 97       	sbiw	r26, 0x00	; 0
    6cd2:	e1 f0       	breq	.+56     	; 0x6d0c <strtok_r+0x46>
    6cd4:	cd 01       	movw	r24, r26
    6cd6:	dc 01       	movw	r26, r24
    6cd8:	cd 01       	movw	r24, r26
    6cda:	0d 90       	ld	r0, X+
    6cdc:	00 20       	and	r0, r0
    6cde:	11 f4       	brne	.+4      	; 0x6ce4 <strtok_r+0x1e>
    6ce0:	c0 01       	movw	r24, r0
    6ce2:	13 c0       	rjmp	.+38     	; 0x6d0a <strtok_r+0x44>
    6ce4:	fb 01       	movw	r30, r22
    6ce6:	21 91       	ld	r18, Z+
    6ce8:	22 23       	and	r18, r18
    6cea:	19 f0       	breq	.+6      	; 0x6cf2 <strtok_r+0x2c>
    6cec:	20 15       	cp	r18, r0
    6cee:	d9 f7       	brne	.-10     	; 0x6ce6 <strtok_r+0x20>
    6cf0:	f3 cf       	rjmp	.-26     	; 0x6cd8 <strtok_r+0x12>
    6cf2:	fb 01       	movw	r30, r22
    6cf4:	21 91       	ld	r18, Z+
    6cf6:	20 15       	cp	r18, r0
    6cf8:	19 f4       	brne	.+6      	; 0x6d00 <strtok_r+0x3a>
    6cfa:	1e 92       	st	-X, r1
    6cfc:	11 96       	adiw	r26, 0x01	; 1
    6cfe:	06 c0       	rjmp	.+12     	; 0x6d0c <strtok_r+0x46>
    6d00:	22 23       	and	r18, r18
    6d02:	c1 f7       	brne	.-16     	; 0x6cf4 <strtok_r+0x2e>
    6d04:	0d 90       	ld	r0, X+
    6d06:	00 20       	and	r0, r0
    6d08:	a1 f7       	brne	.-24     	; 0x6cf2 <strtok_r+0x2c>
    6d0a:	d0 01       	movw	r26, r0
    6d0c:	fa 01       	movw	r30, r20
    6d0e:	a1 93       	st	Z+, r26
    6d10:	b0 83       	st	Z, r27
    6d12:	08 95       	ret

00006d14 <sprintf>:
    6d14:	ae e0       	ldi	r26, 0x0E	; 14
    6d16:	b0 e0       	ldi	r27, 0x00	; 0
    6d18:	ef e8       	ldi	r30, 0x8F	; 143
    6d1a:	f6 e3       	ldi	r31, 0x36	; 54
    6d1c:	e1 c2       	rjmp	.+1474   	; 0x72e0 <__prologue_saves__+0x1c>
    6d1e:	0d 89       	ldd	r16, Y+21	; 0x15
    6d20:	1e 89       	ldd	r17, Y+22	; 0x16
    6d22:	86 e0       	ldi	r24, 0x06	; 6
    6d24:	8c 83       	std	Y+4, r24	; 0x04
    6d26:	1a 83       	std	Y+2, r17	; 0x02
    6d28:	09 83       	std	Y+1, r16	; 0x01
    6d2a:	8f ef       	ldi	r24, 0xFF	; 255
    6d2c:	9f e7       	ldi	r25, 0x7F	; 127
    6d2e:	9e 83       	std	Y+6, r25	; 0x06
    6d30:	8d 83       	std	Y+5, r24	; 0x05
    6d32:	ae 01       	movw	r20, r28
    6d34:	47 5e       	subi	r20, 0xE7	; 231
    6d36:	5f 4f       	sbci	r21, 0xFF	; 255
    6d38:	6f 89       	ldd	r22, Y+23	; 0x17
    6d3a:	78 8d       	ldd	r23, Y+24	; 0x18
    6d3c:	ce 01       	movw	r24, r28
    6d3e:	01 96       	adiw	r24, 0x01	; 1
    6d40:	09 d0       	rcall	.+18     	; 0x6d54 <vfprintf>
    6d42:	2f 81       	ldd	r18, Y+7	; 0x07
    6d44:	38 85       	ldd	r19, Y+8	; 0x08
    6d46:	f8 01       	movw	r30, r16
    6d48:	e2 0f       	add	r30, r18
    6d4a:	f3 1f       	adc	r31, r19
    6d4c:	10 82       	st	Z, r1
    6d4e:	2e 96       	adiw	r28, 0x0e	; 14
    6d50:	e4 e0       	ldi	r30, 0x04	; 4
    6d52:	e2 c2       	rjmp	.+1476   	; 0x7318 <__epilogue_restores__+0x1c>

00006d54 <vfprintf>:
    6d54:	ac e0       	ldi	r26, 0x0C	; 12
    6d56:	b0 e0       	ldi	r27, 0x00	; 0
    6d58:	ef ea       	ldi	r30, 0xAF	; 175
    6d5a:	f6 e3       	ldi	r31, 0x36	; 54
    6d5c:	b3 c2       	rjmp	.+1382   	; 0x72c4 <__prologue_saves__>
    6d5e:	7c 01       	movw	r14, r24
    6d60:	6b 01       	movw	r12, r22
    6d62:	8a 01       	movw	r16, r20
    6d64:	fc 01       	movw	r30, r24
    6d66:	17 82       	std	Z+7, r1	; 0x07
    6d68:	16 82       	std	Z+6, r1	; 0x06
    6d6a:	83 81       	ldd	r24, Z+3	; 0x03
    6d6c:	81 ff       	sbrs	r24, 1
    6d6e:	b0 c1       	rjmp	.+864    	; 0x70d0 <vfprintf+0x37c>
    6d70:	ce 01       	movw	r24, r28
    6d72:	01 96       	adiw	r24, 0x01	; 1
    6d74:	4c 01       	movw	r8, r24
    6d76:	f7 01       	movw	r30, r14
    6d78:	93 81       	ldd	r25, Z+3	; 0x03
    6d7a:	f6 01       	movw	r30, r12
    6d7c:	93 fd       	sbrc	r25, 3
    6d7e:	85 91       	lpm	r24, Z+
    6d80:	93 ff       	sbrs	r25, 3
    6d82:	81 91       	ld	r24, Z+
    6d84:	6f 01       	movw	r12, r30
    6d86:	88 23       	and	r24, r24
    6d88:	09 f4       	brne	.+2      	; 0x6d8c <vfprintf+0x38>
    6d8a:	9e c1       	rjmp	.+828    	; 0x70c8 <vfprintf+0x374>
    6d8c:	85 32       	cpi	r24, 0x25	; 37
    6d8e:	39 f4       	brne	.+14     	; 0x6d9e <vfprintf+0x4a>
    6d90:	93 fd       	sbrc	r25, 3
    6d92:	85 91       	lpm	r24, Z+
    6d94:	93 ff       	sbrs	r25, 3
    6d96:	81 91       	ld	r24, Z+
    6d98:	6f 01       	movw	r12, r30
    6d9a:	85 32       	cpi	r24, 0x25	; 37
    6d9c:	21 f4       	brne	.+8      	; 0x6da6 <vfprintf+0x52>
    6d9e:	b7 01       	movw	r22, r14
    6da0:	90 e0       	ldi	r25, 0x00	; 0
    6da2:	b1 d1       	rcall	.+866    	; 0x7106 <fputc>
    6da4:	e8 cf       	rjmp	.-48     	; 0x6d76 <vfprintf+0x22>
    6da6:	51 2c       	mov	r5, r1
    6da8:	31 2c       	mov	r3, r1
    6daa:	20 e0       	ldi	r18, 0x00	; 0
    6dac:	20 32       	cpi	r18, 0x20	; 32
    6dae:	a0 f4       	brcc	.+40     	; 0x6dd8 <vfprintf+0x84>
    6db0:	8b 32       	cpi	r24, 0x2B	; 43
    6db2:	69 f0       	breq	.+26     	; 0x6dce <vfprintf+0x7a>
    6db4:	30 f4       	brcc	.+12     	; 0x6dc2 <vfprintf+0x6e>
    6db6:	80 32       	cpi	r24, 0x20	; 32
    6db8:	59 f0       	breq	.+22     	; 0x6dd0 <vfprintf+0x7c>
    6dba:	83 32       	cpi	r24, 0x23	; 35
    6dbc:	69 f4       	brne	.+26     	; 0x6dd8 <vfprintf+0x84>
    6dbe:	20 61       	ori	r18, 0x10	; 16
    6dc0:	2c c0       	rjmp	.+88     	; 0x6e1a <vfprintf+0xc6>
    6dc2:	8d 32       	cpi	r24, 0x2D	; 45
    6dc4:	39 f0       	breq	.+14     	; 0x6dd4 <vfprintf+0x80>
    6dc6:	80 33       	cpi	r24, 0x30	; 48
    6dc8:	39 f4       	brne	.+14     	; 0x6dd8 <vfprintf+0x84>
    6dca:	21 60       	ori	r18, 0x01	; 1
    6dcc:	26 c0       	rjmp	.+76     	; 0x6e1a <vfprintf+0xc6>
    6dce:	22 60       	ori	r18, 0x02	; 2
    6dd0:	24 60       	ori	r18, 0x04	; 4
    6dd2:	23 c0       	rjmp	.+70     	; 0x6e1a <vfprintf+0xc6>
    6dd4:	28 60       	ori	r18, 0x08	; 8
    6dd6:	21 c0       	rjmp	.+66     	; 0x6e1a <vfprintf+0xc6>
    6dd8:	27 fd       	sbrc	r18, 7
    6dda:	27 c0       	rjmp	.+78     	; 0x6e2a <vfprintf+0xd6>
    6ddc:	30 ed       	ldi	r19, 0xD0	; 208
    6dde:	38 0f       	add	r19, r24
    6de0:	3a 30       	cpi	r19, 0x0A	; 10
    6de2:	78 f4       	brcc	.+30     	; 0x6e02 <vfprintf+0xae>
    6de4:	26 ff       	sbrs	r18, 6
    6de6:	06 c0       	rjmp	.+12     	; 0x6df4 <vfprintf+0xa0>
    6de8:	fa e0       	ldi	r31, 0x0A	; 10
    6dea:	5f 9e       	mul	r5, r31
    6dec:	30 0d       	add	r19, r0
    6dee:	11 24       	eor	r1, r1
    6df0:	53 2e       	mov	r5, r19
    6df2:	13 c0       	rjmp	.+38     	; 0x6e1a <vfprintf+0xc6>
    6df4:	8a e0       	ldi	r24, 0x0A	; 10
    6df6:	38 9e       	mul	r3, r24
    6df8:	30 0d       	add	r19, r0
    6dfa:	11 24       	eor	r1, r1
    6dfc:	33 2e       	mov	r3, r19
    6dfe:	20 62       	ori	r18, 0x20	; 32
    6e00:	0c c0       	rjmp	.+24     	; 0x6e1a <vfprintf+0xc6>
    6e02:	8e 32       	cpi	r24, 0x2E	; 46
    6e04:	21 f4       	brne	.+8      	; 0x6e0e <vfprintf+0xba>
    6e06:	26 fd       	sbrc	r18, 6
    6e08:	5f c1       	rjmp	.+702    	; 0x70c8 <vfprintf+0x374>
    6e0a:	20 64       	ori	r18, 0x40	; 64
    6e0c:	06 c0       	rjmp	.+12     	; 0x6e1a <vfprintf+0xc6>
    6e0e:	8c 36       	cpi	r24, 0x6C	; 108
    6e10:	11 f4       	brne	.+4      	; 0x6e16 <vfprintf+0xc2>
    6e12:	20 68       	ori	r18, 0x80	; 128
    6e14:	02 c0       	rjmp	.+4      	; 0x6e1a <vfprintf+0xc6>
    6e16:	88 36       	cpi	r24, 0x68	; 104
    6e18:	41 f4       	brne	.+16     	; 0x6e2a <vfprintf+0xd6>
    6e1a:	f6 01       	movw	r30, r12
    6e1c:	93 fd       	sbrc	r25, 3
    6e1e:	85 91       	lpm	r24, Z+
    6e20:	93 ff       	sbrs	r25, 3
    6e22:	81 91       	ld	r24, Z+
    6e24:	6f 01       	movw	r12, r30
    6e26:	81 11       	cpse	r24, r1
    6e28:	c1 cf       	rjmp	.-126    	; 0x6dac <vfprintf+0x58>
    6e2a:	98 2f       	mov	r25, r24
    6e2c:	9f 7d       	andi	r25, 0xDF	; 223
    6e2e:	95 54       	subi	r25, 0x45	; 69
    6e30:	93 30       	cpi	r25, 0x03	; 3
    6e32:	28 f4       	brcc	.+10     	; 0x6e3e <vfprintf+0xea>
    6e34:	0c 5f       	subi	r16, 0xFC	; 252
    6e36:	1f 4f       	sbci	r17, 0xFF	; 255
    6e38:	ff e3       	ldi	r31, 0x3F	; 63
    6e3a:	f9 83       	std	Y+1, r31	; 0x01
    6e3c:	0d c0       	rjmp	.+26     	; 0x6e58 <vfprintf+0x104>
    6e3e:	83 36       	cpi	r24, 0x63	; 99
    6e40:	31 f0       	breq	.+12     	; 0x6e4e <vfprintf+0xfa>
    6e42:	83 37       	cpi	r24, 0x73	; 115
    6e44:	71 f0       	breq	.+28     	; 0x6e62 <vfprintf+0x10e>
    6e46:	83 35       	cpi	r24, 0x53	; 83
    6e48:	09 f0       	breq	.+2      	; 0x6e4c <vfprintf+0xf8>
    6e4a:	57 c0       	rjmp	.+174    	; 0x6efa <vfprintf+0x1a6>
    6e4c:	21 c0       	rjmp	.+66     	; 0x6e90 <vfprintf+0x13c>
    6e4e:	f8 01       	movw	r30, r16
    6e50:	80 81       	ld	r24, Z
    6e52:	89 83       	std	Y+1, r24	; 0x01
    6e54:	0e 5f       	subi	r16, 0xFE	; 254
    6e56:	1f 4f       	sbci	r17, 0xFF	; 255
    6e58:	44 24       	eor	r4, r4
    6e5a:	43 94       	inc	r4
    6e5c:	51 2c       	mov	r5, r1
    6e5e:	54 01       	movw	r10, r8
    6e60:	14 c0       	rjmp	.+40     	; 0x6e8a <vfprintf+0x136>
    6e62:	38 01       	movw	r6, r16
    6e64:	f2 e0       	ldi	r31, 0x02	; 2
    6e66:	6f 0e       	add	r6, r31
    6e68:	71 1c       	adc	r7, r1
    6e6a:	f8 01       	movw	r30, r16
    6e6c:	a0 80       	ld	r10, Z
    6e6e:	b1 80       	ldd	r11, Z+1	; 0x01
    6e70:	26 ff       	sbrs	r18, 6
    6e72:	03 c0       	rjmp	.+6      	; 0x6e7a <vfprintf+0x126>
    6e74:	65 2d       	mov	r22, r5
    6e76:	70 e0       	ldi	r23, 0x00	; 0
    6e78:	02 c0       	rjmp	.+4      	; 0x6e7e <vfprintf+0x12a>
    6e7a:	6f ef       	ldi	r22, 0xFF	; 255
    6e7c:	7f ef       	ldi	r23, 0xFF	; 255
    6e7e:	c5 01       	movw	r24, r10
    6e80:	2c 87       	std	Y+12, r18	; 0x0c
    6e82:	36 d1       	rcall	.+620    	; 0x70f0 <strnlen>
    6e84:	2c 01       	movw	r4, r24
    6e86:	83 01       	movw	r16, r6
    6e88:	2c 85       	ldd	r18, Y+12	; 0x0c
    6e8a:	2f 77       	andi	r18, 0x7F	; 127
    6e8c:	22 2e       	mov	r2, r18
    6e8e:	16 c0       	rjmp	.+44     	; 0x6ebc <vfprintf+0x168>
    6e90:	38 01       	movw	r6, r16
    6e92:	f2 e0       	ldi	r31, 0x02	; 2
    6e94:	6f 0e       	add	r6, r31
    6e96:	71 1c       	adc	r7, r1
    6e98:	f8 01       	movw	r30, r16
    6e9a:	a0 80       	ld	r10, Z
    6e9c:	b1 80       	ldd	r11, Z+1	; 0x01
    6e9e:	26 ff       	sbrs	r18, 6
    6ea0:	03 c0       	rjmp	.+6      	; 0x6ea8 <vfprintf+0x154>
    6ea2:	65 2d       	mov	r22, r5
    6ea4:	70 e0       	ldi	r23, 0x00	; 0
    6ea6:	02 c0       	rjmp	.+4      	; 0x6eac <vfprintf+0x158>
    6ea8:	6f ef       	ldi	r22, 0xFF	; 255
    6eaa:	7f ef       	ldi	r23, 0xFF	; 255
    6eac:	c5 01       	movw	r24, r10
    6eae:	2c 87       	std	Y+12, r18	; 0x0c
    6eb0:	14 d1       	rcall	.+552    	; 0x70da <strnlen_P>
    6eb2:	2c 01       	movw	r4, r24
    6eb4:	2c 85       	ldd	r18, Y+12	; 0x0c
    6eb6:	20 68       	ori	r18, 0x80	; 128
    6eb8:	22 2e       	mov	r2, r18
    6eba:	83 01       	movw	r16, r6
    6ebc:	23 fc       	sbrc	r2, 3
    6ebe:	19 c0       	rjmp	.+50     	; 0x6ef2 <vfprintf+0x19e>
    6ec0:	83 2d       	mov	r24, r3
    6ec2:	90 e0       	ldi	r25, 0x00	; 0
    6ec4:	48 16       	cp	r4, r24
    6ec6:	59 06       	cpc	r5, r25
    6ec8:	a0 f4       	brcc	.+40     	; 0x6ef2 <vfprintf+0x19e>
    6eca:	b7 01       	movw	r22, r14
    6ecc:	80 e2       	ldi	r24, 0x20	; 32
    6ece:	90 e0       	ldi	r25, 0x00	; 0
    6ed0:	1a d1       	rcall	.+564    	; 0x7106 <fputc>
    6ed2:	3a 94       	dec	r3
    6ed4:	f5 cf       	rjmp	.-22     	; 0x6ec0 <vfprintf+0x16c>
    6ed6:	f5 01       	movw	r30, r10
    6ed8:	27 fc       	sbrc	r2, 7
    6eda:	85 91       	lpm	r24, Z+
    6edc:	27 fe       	sbrs	r2, 7
    6ede:	81 91       	ld	r24, Z+
    6ee0:	5f 01       	movw	r10, r30
    6ee2:	b7 01       	movw	r22, r14
    6ee4:	90 e0       	ldi	r25, 0x00	; 0
    6ee6:	0f d1       	rcall	.+542    	; 0x7106 <fputc>
    6ee8:	31 10       	cpse	r3, r1
    6eea:	3a 94       	dec	r3
    6eec:	f1 e0       	ldi	r31, 0x01	; 1
    6eee:	4f 1a       	sub	r4, r31
    6ef0:	51 08       	sbc	r5, r1
    6ef2:	41 14       	cp	r4, r1
    6ef4:	51 04       	cpc	r5, r1
    6ef6:	79 f7       	brne	.-34     	; 0x6ed6 <vfprintf+0x182>
    6ef8:	de c0       	rjmp	.+444    	; 0x70b6 <vfprintf+0x362>
    6efa:	84 36       	cpi	r24, 0x64	; 100
    6efc:	11 f0       	breq	.+4      	; 0x6f02 <vfprintf+0x1ae>
    6efe:	89 36       	cpi	r24, 0x69	; 105
    6f00:	31 f5       	brne	.+76     	; 0x6f4e <vfprintf+0x1fa>
    6f02:	f8 01       	movw	r30, r16
    6f04:	27 ff       	sbrs	r18, 7
    6f06:	07 c0       	rjmp	.+14     	; 0x6f16 <vfprintf+0x1c2>
    6f08:	60 81       	ld	r22, Z
    6f0a:	71 81       	ldd	r23, Z+1	; 0x01
    6f0c:	82 81       	ldd	r24, Z+2	; 0x02
    6f0e:	93 81       	ldd	r25, Z+3	; 0x03
    6f10:	0c 5f       	subi	r16, 0xFC	; 252
    6f12:	1f 4f       	sbci	r17, 0xFF	; 255
    6f14:	08 c0       	rjmp	.+16     	; 0x6f26 <vfprintf+0x1d2>
    6f16:	60 81       	ld	r22, Z
    6f18:	71 81       	ldd	r23, Z+1	; 0x01
    6f1a:	07 2e       	mov	r0, r23
    6f1c:	00 0c       	add	r0, r0
    6f1e:	88 0b       	sbc	r24, r24
    6f20:	99 0b       	sbc	r25, r25
    6f22:	0e 5f       	subi	r16, 0xFE	; 254
    6f24:	1f 4f       	sbci	r17, 0xFF	; 255
    6f26:	2f 76       	andi	r18, 0x6F	; 111
    6f28:	72 2e       	mov	r7, r18
    6f2a:	97 ff       	sbrs	r25, 7
    6f2c:	09 c0       	rjmp	.+18     	; 0x6f40 <vfprintf+0x1ec>
    6f2e:	90 95       	com	r25
    6f30:	80 95       	com	r24
    6f32:	70 95       	com	r23
    6f34:	61 95       	neg	r22
    6f36:	7f 4f       	sbci	r23, 0xFF	; 255
    6f38:	8f 4f       	sbci	r24, 0xFF	; 255
    6f3a:	9f 4f       	sbci	r25, 0xFF	; 255
    6f3c:	20 68       	ori	r18, 0x80	; 128
    6f3e:	72 2e       	mov	r7, r18
    6f40:	2a e0       	ldi	r18, 0x0A	; 10
    6f42:	30 e0       	ldi	r19, 0x00	; 0
    6f44:	a4 01       	movw	r20, r8
    6f46:	17 d1       	rcall	.+558    	; 0x7176 <__ultoa_invert>
    6f48:	a8 2e       	mov	r10, r24
    6f4a:	a8 18       	sub	r10, r8
    6f4c:	43 c0       	rjmp	.+134    	; 0x6fd4 <vfprintf+0x280>
    6f4e:	85 37       	cpi	r24, 0x75	; 117
    6f50:	29 f4       	brne	.+10     	; 0x6f5c <vfprintf+0x208>
    6f52:	2f 7e       	andi	r18, 0xEF	; 239
    6f54:	b2 2e       	mov	r11, r18
    6f56:	2a e0       	ldi	r18, 0x0A	; 10
    6f58:	30 e0       	ldi	r19, 0x00	; 0
    6f5a:	25 c0       	rjmp	.+74     	; 0x6fa6 <vfprintf+0x252>
    6f5c:	f2 2f       	mov	r31, r18
    6f5e:	f9 7f       	andi	r31, 0xF9	; 249
    6f60:	bf 2e       	mov	r11, r31
    6f62:	8f 36       	cpi	r24, 0x6F	; 111
    6f64:	c1 f0       	breq	.+48     	; 0x6f96 <vfprintf+0x242>
    6f66:	18 f4       	brcc	.+6      	; 0x6f6e <vfprintf+0x21a>
    6f68:	88 35       	cpi	r24, 0x58	; 88
    6f6a:	79 f0       	breq	.+30     	; 0x6f8a <vfprintf+0x236>
    6f6c:	ad c0       	rjmp	.+346    	; 0x70c8 <vfprintf+0x374>
    6f6e:	80 37       	cpi	r24, 0x70	; 112
    6f70:	19 f0       	breq	.+6      	; 0x6f78 <vfprintf+0x224>
    6f72:	88 37       	cpi	r24, 0x78	; 120
    6f74:	21 f0       	breq	.+8      	; 0x6f7e <vfprintf+0x22a>
    6f76:	a8 c0       	rjmp	.+336    	; 0x70c8 <vfprintf+0x374>
    6f78:	2f 2f       	mov	r18, r31
    6f7a:	20 61       	ori	r18, 0x10	; 16
    6f7c:	b2 2e       	mov	r11, r18
    6f7e:	b4 fe       	sbrs	r11, 4
    6f80:	0d c0       	rjmp	.+26     	; 0x6f9c <vfprintf+0x248>
    6f82:	8b 2d       	mov	r24, r11
    6f84:	84 60       	ori	r24, 0x04	; 4
    6f86:	b8 2e       	mov	r11, r24
    6f88:	09 c0       	rjmp	.+18     	; 0x6f9c <vfprintf+0x248>
    6f8a:	24 ff       	sbrs	r18, 4
    6f8c:	0a c0       	rjmp	.+20     	; 0x6fa2 <vfprintf+0x24e>
    6f8e:	9f 2f       	mov	r25, r31
    6f90:	96 60       	ori	r25, 0x06	; 6
    6f92:	b9 2e       	mov	r11, r25
    6f94:	06 c0       	rjmp	.+12     	; 0x6fa2 <vfprintf+0x24e>
    6f96:	28 e0       	ldi	r18, 0x08	; 8
    6f98:	30 e0       	ldi	r19, 0x00	; 0
    6f9a:	05 c0       	rjmp	.+10     	; 0x6fa6 <vfprintf+0x252>
    6f9c:	20 e1       	ldi	r18, 0x10	; 16
    6f9e:	30 e0       	ldi	r19, 0x00	; 0
    6fa0:	02 c0       	rjmp	.+4      	; 0x6fa6 <vfprintf+0x252>
    6fa2:	20 e1       	ldi	r18, 0x10	; 16
    6fa4:	32 e0       	ldi	r19, 0x02	; 2
    6fa6:	f8 01       	movw	r30, r16
    6fa8:	b7 fe       	sbrs	r11, 7
    6faa:	07 c0       	rjmp	.+14     	; 0x6fba <vfprintf+0x266>
    6fac:	60 81       	ld	r22, Z
    6fae:	71 81       	ldd	r23, Z+1	; 0x01
    6fb0:	82 81       	ldd	r24, Z+2	; 0x02
    6fb2:	93 81       	ldd	r25, Z+3	; 0x03
    6fb4:	0c 5f       	subi	r16, 0xFC	; 252
    6fb6:	1f 4f       	sbci	r17, 0xFF	; 255
    6fb8:	06 c0       	rjmp	.+12     	; 0x6fc6 <vfprintf+0x272>
    6fba:	60 81       	ld	r22, Z
    6fbc:	71 81       	ldd	r23, Z+1	; 0x01
    6fbe:	80 e0       	ldi	r24, 0x00	; 0
    6fc0:	90 e0       	ldi	r25, 0x00	; 0
    6fc2:	0e 5f       	subi	r16, 0xFE	; 254
    6fc4:	1f 4f       	sbci	r17, 0xFF	; 255
    6fc6:	a4 01       	movw	r20, r8
    6fc8:	d6 d0       	rcall	.+428    	; 0x7176 <__ultoa_invert>
    6fca:	a8 2e       	mov	r10, r24
    6fcc:	a8 18       	sub	r10, r8
    6fce:	fb 2d       	mov	r31, r11
    6fd0:	ff 77       	andi	r31, 0x7F	; 127
    6fd2:	7f 2e       	mov	r7, r31
    6fd4:	76 fe       	sbrs	r7, 6
    6fd6:	0b c0       	rjmp	.+22     	; 0x6fee <vfprintf+0x29a>
    6fd8:	37 2d       	mov	r19, r7
    6fda:	3e 7f       	andi	r19, 0xFE	; 254
    6fdc:	a5 14       	cp	r10, r5
    6fde:	50 f4       	brcc	.+20     	; 0x6ff4 <vfprintf+0x2a0>
    6fe0:	74 fe       	sbrs	r7, 4
    6fe2:	0a c0       	rjmp	.+20     	; 0x6ff8 <vfprintf+0x2a4>
    6fe4:	72 fc       	sbrc	r7, 2
    6fe6:	08 c0       	rjmp	.+16     	; 0x6ff8 <vfprintf+0x2a4>
    6fe8:	37 2d       	mov	r19, r7
    6fea:	3e 7e       	andi	r19, 0xEE	; 238
    6fec:	05 c0       	rjmp	.+10     	; 0x6ff8 <vfprintf+0x2a4>
    6fee:	ba 2c       	mov	r11, r10
    6ff0:	37 2d       	mov	r19, r7
    6ff2:	03 c0       	rjmp	.+6      	; 0x6ffa <vfprintf+0x2a6>
    6ff4:	ba 2c       	mov	r11, r10
    6ff6:	01 c0       	rjmp	.+2      	; 0x6ffa <vfprintf+0x2a6>
    6ff8:	b5 2c       	mov	r11, r5
    6ffa:	34 ff       	sbrs	r19, 4
    6ffc:	0d c0       	rjmp	.+26     	; 0x7018 <vfprintf+0x2c4>
    6ffe:	fe 01       	movw	r30, r28
    7000:	ea 0d       	add	r30, r10
    7002:	f1 1d       	adc	r31, r1
    7004:	80 81       	ld	r24, Z
    7006:	80 33       	cpi	r24, 0x30	; 48
    7008:	11 f4       	brne	.+4      	; 0x700e <vfprintf+0x2ba>
    700a:	39 7e       	andi	r19, 0xE9	; 233
    700c:	09 c0       	rjmp	.+18     	; 0x7020 <vfprintf+0x2cc>
    700e:	32 ff       	sbrs	r19, 2
    7010:	06 c0       	rjmp	.+12     	; 0x701e <vfprintf+0x2ca>
    7012:	b3 94       	inc	r11
    7014:	b3 94       	inc	r11
    7016:	04 c0       	rjmp	.+8      	; 0x7020 <vfprintf+0x2cc>
    7018:	83 2f       	mov	r24, r19
    701a:	86 78       	andi	r24, 0x86	; 134
    701c:	09 f0       	breq	.+2      	; 0x7020 <vfprintf+0x2cc>
    701e:	b3 94       	inc	r11
    7020:	33 fd       	sbrc	r19, 3
    7022:	12 c0       	rjmp	.+36     	; 0x7048 <vfprintf+0x2f4>
    7024:	30 ff       	sbrs	r19, 0
    7026:	06 c0       	rjmp	.+12     	; 0x7034 <vfprintf+0x2e0>
    7028:	5a 2c       	mov	r5, r10
    702a:	b3 14       	cp	r11, r3
    702c:	18 f4       	brcc	.+6      	; 0x7034 <vfprintf+0x2e0>
    702e:	53 0c       	add	r5, r3
    7030:	5b 18       	sub	r5, r11
    7032:	b3 2c       	mov	r11, r3
    7034:	b3 14       	cp	r11, r3
    7036:	60 f4       	brcc	.+24     	; 0x7050 <vfprintf+0x2fc>
    7038:	b7 01       	movw	r22, r14
    703a:	80 e2       	ldi	r24, 0x20	; 32
    703c:	90 e0       	ldi	r25, 0x00	; 0
    703e:	3c 87       	std	Y+12, r19	; 0x0c
    7040:	62 d0       	rcall	.+196    	; 0x7106 <fputc>
    7042:	b3 94       	inc	r11
    7044:	3c 85       	ldd	r19, Y+12	; 0x0c
    7046:	f6 cf       	rjmp	.-20     	; 0x7034 <vfprintf+0x2e0>
    7048:	b3 14       	cp	r11, r3
    704a:	10 f4       	brcc	.+4      	; 0x7050 <vfprintf+0x2fc>
    704c:	3b 18       	sub	r3, r11
    704e:	01 c0       	rjmp	.+2      	; 0x7052 <vfprintf+0x2fe>
    7050:	31 2c       	mov	r3, r1
    7052:	34 ff       	sbrs	r19, 4
    7054:	11 c0       	rjmp	.+34     	; 0x7078 <vfprintf+0x324>
    7056:	b7 01       	movw	r22, r14
    7058:	80 e3       	ldi	r24, 0x30	; 48
    705a:	90 e0       	ldi	r25, 0x00	; 0
    705c:	3c 87       	std	Y+12, r19	; 0x0c
    705e:	53 d0       	rcall	.+166    	; 0x7106 <fputc>
    7060:	3c 85       	ldd	r19, Y+12	; 0x0c
    7062:	32 ff       	sbrs	r19, 2
    7064:	16 c0       	rjmp	.+44     	; 0x7092 <vfprintf+0x33e>
    7066:	31 fd       	sbrc	r19, 1
    7068:	03 c0       	rjmp	.+6      	; 0x7070 <vfprintf+0x31c>
    706a:	88 e7       	ldi	r24, 0x78	; 120
    706c:	90 e0       	ldi	r25, 0x00	; 0
    706e:	02 c0       	rjmp	.+4      	; 0x7074 <vfprintf+0x320>
    7070:	88 e5       	ldi	r24, 0x58	; 88
    7072:	90 e0       	ldi	r25, 0x00	; 0
    7074:	b7 01       	movw	r22, r14
    7076:	0c c0       	rjmp	.+24     	; 0x7090 <vfprintf+0x33c>
    7078:	83 2f       	mov	r24, r19
    707a:	86 78       	andi	r24, 0x86	; 134
    707c:	51 f0       	breq	.+20     	; 0x7092 <vfprintf+0x33e>
    707e:	31 ff       	sbrs	r19, 1
    7080:	02 c0       	rjmp	.+4      	; 0x7086 <vfprintf+0x332>
    7082:	8b e2       	ldi	r24, 0x2B	; 43
    7084:	01 c0       	rjmp	.+2      	; 0x7088 <vfprintf+0x334>
    7086:	80 e2       	ldi	r24, 0x20	; 32
    7088:	37 fd       	sbrc	r19, 7
    708a:	8d e2       	ldi	r24, 0x2D	; 45
    708c:	b7 01       	movw	r22, r14
    708e:	90 e0       	ldi	r25, 0x00	; 0
    7090:	3a d0       	rcall	.+116    	; 0x7106 <fputc>
    7092:	a5 14       	cp	r10, r5
    7094:	30 f4       	brcc	.+12     	; 0x70a2 <vfprintf+0x34e>
    7096:	b7 01       	movw	r22, r14
    7098:	80 e3       	ldi	r24, 0x30	; 48
    709a:	90 e0       	ldi	r25, 0x00	; 0
    709c:	34 d0       	rcall	.+104    	; 0x7106 <fputc>
    709e:	5a 94       	dec	r5
    70a0:	f8 cf       	rjmp	.-16     	; 0x7092 <vfprintf+0x33e>
    70a2:	aa 94       	dec	r10
    70a4:	f4 01       	movw	r30, r8
    70a6:	ea 0d       	add	r30, r10
    70a8:	f1 1d       	adc	r31, r1
    70aa:	80 81       	ld	r24, Z
    70ac:	b7 01       	movw	r22, r14
    70ae:	90 e0       	ldi	r25, 0x00	; 0
    70b0:	2a d0       	rcall	.+84     	; 0x7106 <fputc>
    70b2:	a1 10       	cpse	r10, r1
    70b4:	f6 cf       	rjmp	.-20     	; 0x70a2 <vfprintf+0x34e>
    70b6:	33 20       	and	r3, r3
    70b8:	09 f4       	brne	.+2      	; 0x70bc <vfprintf+0x368>
    70ba:	5d ce       	rjmp	.-838    	; 0x6d76 <vfprintf+0x22>
    70bc:	b7 01       	movw	r22, r14
    70be:	80 e2       	ldi	r24, 0x20	; 32
    70c0:	90 e0       	ldi	r25, 0x00	; 0
    70c2:	21 d0       	rcall	.+66     	; 0x7106 <fputc>
    70c4:	3a 94       	dec	r3
    70c6:	f7 cf       	rjmp	.-18     	; 0x70b6 <vfprintf+0x362>
    70c8:	f7 01       	movw	r30, r14
    70ca:	86 81       	ldd	r24, Z+6	; 0x06
    70cc:	97 81       	ldd	r25, Z+7	; 0x07
    70ce:	02 c0       	rjmp	.+4      	; 0x70d4 <vfprintf+0x380>
    70d0:	8f ef       	ldi	r24, 0xFF	; 255
    70d2:	9f ef       	ldi	r25, 0xFF	; 255
    70d4:	2c 96       	adiw	r28, 0x0c	; 12
    70d6:	e2 e1       	ldi	r30, 0x12	; 18
    70d8:	11 c1       	rjmp	.+546    	; 0x72fc <__epilogue_restores__>

000070da <strnlen_P>:
    70da:	fc 01       	movw	r30, r24
    70dc:	05 90       	lpm	r0, Z+
    70de:	61 50       	subi	r22, 0x01	; 1
    70e0:	70 40       	sbci	r23, 0x00	; 0
    70e2:	01 10       	cpse	r0, r1
    70e4:	d8 f7       	brcc	.-10     	; 0x70dc <strnlen_P+0x2>
    70e6:	80 95       	com	r24
    70e8:	90 95       	com	r25
    70ea:	8e 0f       	add	r24, r30
    70ec:	9f 1f       	adc	r25, r31
    70ee:	08 95       	ret

000070f0 <strnlen>:
    70f0:	fc 01       	movw	r30, r24
    70f2:	61 50       	subi	r22, 0x01	; 1
    70f4:	70 40       	sbci	r23, 0x00	; 0
    70f6:	01 90       	ld	r0, Z+
    70f8:	01 10       	cpse	r0, r1
    70fa:	d8 f7       	brcc	.-10     	; 0x70f2 <strnlen+0x2>
    70fc:	80 95       	com	r24
    70fe:	90 95       	com	r25
    7100:	8e 0f       	add	r24, r30
    7102:	9f 1f       	adc	r25, r31
    7104:	08 95       	ret

00007106 <fputc>:
    7106:	0f 93       	push	r16
    7108:	1f 93       	push	r17
    710a:	cf 93       	push	r28
    710c:	df 93       	push	r29
    710e:	fb 01       	movw	r30, r22
    7110:	23 81       	ldd	r18, Z+3	; 0x03
    7112:	21 fd       	sbrc	r18, 1
    7114:	03 c0       	rjmp	.+6      	; 0x711c <fputc+0x16>
    7116:	8f ef       	ldi	r24, 0xFF	; 255
    7118:	9f ef       	ldi	r25, 0xFF	; 255
    711a:	28 c0       	rjmp	.+80     	; 0x716c <fputc+0x66>
    711c:	22 ff       	sbrs	r18, 2
    711e:	16 c0       	rjmp	.+44     	; 0x714c <fputc+0x46>
    7120:	46 81       	ldd	r20, Z+6	; 0x06
    7122:	57 81       	ldd	r21, Z+7	; 0x07
    7124:	24 81       	ldd	r18, Z+4	; 0x04
    7126:	35 81       	ldd	r19, Z+5	; 0x05
    7128:	42 17       	cp	r20, r18
    712a:	53 07       	cpc	r21, r19
    712c:	44 f4       	brge	.+16     	; 0x713e <fputc+0x38>
    712e:	a0 81       	ld	r26, Z
    7130:	b1 81       	ldd	r27, Z+1	; 0x01
    7132:	9d 01       	movw	r18, r26
    7134:	2f 5f       	subi	r18, 0xFF	; 255
    7136:	3f 4f       	sbci	r19, 0xFF	; 255
    7138:	31 83       	std	Z+1, r19	; 0x01
    713a:	20 83       	st	Z, r18
    713c:	8c 93       	st	X, r24
    713e:	26 81       	ldd	r18, Z+6	; 0x06
    7140:	37 81       	ldd	r19, Z+7	; 0x07
    7142:	2f 5f       	subi	r18, 0xFF	; 255
    7144:	3f 4f       	sbci	r19, 0xFF	; 255
    7146:	37 83       	std	Z+7, r19	; 0x07
    7148:	26 83       	std	Z+6, r18	; 0x06
    714a:	10 c0       	rjmp	.+32     	; 0x716c <fputc+0x66>
    714c:	eb 01       	movw	r28, r22
    714e:	09 2f       	mov	r16, r25
    7150:	18 2f       	mov	r17, r24
    7152:	00 84       	ldd	r0, Z+8	; 0x08
    7154:	f1 85       	ldd	r31, Z+9	; 0x09
    7156:	e0 2d       	mov	r30, r0
    7158:	09 95       	icall
    715a:	89 2b       	or	r24, r25
    715c:	e1 f6       	brne	.-72     	; 0x7116 <fputc+0x10>
    715e:	8e 81       	ldd	r24, Y+6	; 0x06
    7160:	9f 81       	ldd	r25, Y+7	; 0x07
    7162:	01 96       	adiw	r24, 0x01	; 1
    7164:	9f 83       	std	Y+7, r25	; 0x07
    7166:	8e 83       	std	Y+6, r24	; 0x06
    7168:	81 2f       	mov	r24, r17
    716a:	90 2f       	mov	r25, r16
    716c:	df 91       	pop	r29
    716e:	cf 91       	pop	r28
    7170:	1f 91       	pop	r17
    7172:	0f 91       	pop	r16
    7174:	08 95       	ret

00007176 <__ultoa_invert>:
    7176:	fa 01       	movw	r30, r20
    7178:	aa 27       	eor	r26, r26
    717a:	28 30       	cpi	r18, 0x08	; 8
    717c:	51 f1       	breq	.+84     	; 0x71d2 <__ultoa_invert+0x5c>
    717e:	20 31       	cpi	r18, 0x10	; 16
    7180:	81 f1       	breq	.+96     	; 0x71e2 <__ultoa_invert+0x6c>
    7182:	e8 94       	clt
    7184:	6f 93       	push	r22
    7186:	6e 7f       	andi	r22, 0xFE	; 254
    7188:	6e 5f       	subi	r22, 0xFE	; 254
    718a:	7f 4f       	sbci	r23, 0xFF	; 255
    718c:	8f 4f       	sbci	r24, 0xFF	; 255
    718e:	9f 4f       	sbci	r25, 0xFF	; 255
    7190:	af 4f       	sbci	r26, 0xFF	; 255
    7192:	b1 e0       	ldi	r27, 0x01	; 1
    7194:	3e d0       	rcall	.+124    	; 0x7212 <__ultoa_invert+0x9c>
    7196:	b4 e0       	ldi	r27, 0x04	; 4
    7198:	3c d0       	rcall	.+120    	; 0x7212 <__ultoa_invert+0x9c>
    719a:	67 0f       	add	r22, r23
    719c:	78 1f       	adc	r23, r24
    719e:	89 1f       	adc	r24, r25
    71a0:	9a 1f       	adc	r25, r26
    71a2:	a1 1d       	adc	r26, r1
    71a4:	68 0f       	add	r22, r24
    71a6:	79 1f       	adc	r23, r25
    71a8:	8a 1f       	adc	r24, r26
    71aa:	91 1d       	adc	r25, r1
    71ac:	a1 1d       	adc	r26, r1
    71ae:	6a 0f       	add	r22, r26
    71b0:	71 1d       	adc	r23, r1
    71b2:	81 1d       	adc	r24, r1
    71b4:	91 1d       	adc	r25, r1
    71b6:	a1 1d       	adc	r26, r1
    71b8:	20 d0       	rcall	.+64     	; 0x71fa <__ultoa_invert+0x84>
    71ba:	09 f4       	brne	.+2      	; 0x71be <__ultoa_invert+0x48>
    71bc:	68 94       	set
    71be:	3f 91       	pop	r19
    71c0:	2a e0       	ldi	r18, 0x0A	; 10
    71c2:	26 9f       	mul	r18, r22
    71c4:	11 24       	eor	r1, r1
    71c6:	30 19       	sub	r19, r0
    71c8:	30 5d       	subi	r19, 0xD0	; 208
    71ca:	31 93       	st	Z+, r19
    71cc:	de f6       	brtc	.-74     	; 0x7184 <__ultoa_invert+0xe>
    71ce:	cf 01       	movw	r24, r30
    71d0:	08 95       	ret
    71d2:	46 2f       	mov	r20, r22
    71d4:	47 70       	andi	r20, 0x07	; 7
    71d6:	40 5d       	subi	r20, 0xD0	; 208
    71d8:	41 93       	st	Z+, r20
    71da:	b3 e0       	ldi	r27, 0x03	; 3
    71dc:	0f d0       	rcall	.+30     	; 0x71fc <__ultoa_invert+0x86>
    71de:	c9 f7       	brne	.-14     	; 0x71d2 <__ultoa_invert+0x5c>
    71e0:	f6 cf       	rjmp	.-20     	; 0x71ce <__ultoa_invert+0x58>
    71e2:	46 2f       	mov	r20, r22
    71e4:	4f 70       	andi	r20, 0x0F	; 15
    71e6:	40 5d       	subi	r20, 0xD0	; 208
    71e8:	4a 33       	cpi	r20, 0x3A	; 58
    71ea:	18 f0       	brcs	.+6      	; 0x71f2 <__ultoa_invert+0x7c>
    71ec:	49 5d       	subi	r20, 0xD9	; 217
    71ee:	31 fd       	sbrc	r19, 1
    71f0:	40 52       	subi	r20, 0x20	; 32
    71f2:	41 93       	st	Z+, r20
    71f4:	02 d0       	rcall	.+4      	; 0x71fa <__ultoa_invert+0x84>
    71f6:	a9 f7       	brne	.-22     	; 0x71e2 <__ultoa_invert+0x6c>
    71f8:	ea cf       	rjmp	.-44     	; 0x71ce <__ultoa_invert+0x58>
    71fa:	b4 e0       	ldi	r27, 0x04	; 4
    71fc:	a6 95       	lsr	r26
    71fe:	97 95       	ror	r25
    7200:	87 95       	ror	r24
    7202:	77 95       	ror	r23
    7204:	67 95       	ror	r22
    7206:	ba 95       	dec	r27
    7208:	c9 f7       	brne	.-14     	; 0x71fc <__ultoa_invert+0x86>
    720a:	00 97       	sbiw	r24, 0x00	; 0
    720c:	61 05       	cpc	r22, r1
    720e:	71 05       	cpc	r23, r1
    7210:	08 95       	ret
    7212:	9b 01       	movw	r18, r22
    7214:	ac 01       	movw	r20, r24
    7216:	0a 2e       	mov	r0, r26
    7218:	06 94       	lsr	r0
    721a:	57 95       	ror	r21
    721c:	47 95       	ror	r20
    721e:	37 95       	ror	r19
    7220:	27 95       	ror	r18
    7222:	ba 95       	dec	r27
    7224:	c9 f7       	brne	.-14     	; 0x7218 <__ultoa_invert+0xa2>
    7226:	62 0f       	add	r22, r18
    7228:	73 1f       	adc	r23, r19
    722a:	84 1f       	adc	r24, r20
    722c:	95 1f       	adc	r25, r21
    722e:	a0 1d       	adc	r26, r0
    7230:	08 95       	ret

00007232 <eeprom_read_block>:
    7232:	dc 01       	movw	r26, r24
    7234:	cb 01       	movw	r24, r22

00007236 <eeprom_read_blraw>:
    7236:	fc 01       	movw	r30, r24
    7238:	f9 99       	sbic	0x1f, 1	; 31
    723a:	fe cf       	rjmp	.-4      	; 0x7238 <eeprom_read_blraw+0x2>
    723c:	06 c0       	rjmp	.+12     	; 0x724a <eeprom_read_blraw+0x14>
    723e:	f2 bd       	out	0x22, r31	; 34
    7240:	e1 bd       	out	0x21, r30	; 33
    7242:	f8 9a       	sbi	0x1f, 0	; 31
    7244:	31 96       	adiw	r30, 0x01	; 1
    7246:	00 b4       	in	r0, 0x20	; 32
    7248:	0d 92       	st	X+, r0
    724a:	41 50       	subi	r20, 0x01	; 1
    724c:	50 40       	sbci	r21, 0x00	; 0
    724e:	b8 f7       	brcc	.-18     	; 0x723e <eeprom_read_blraw+0x8>
    7250:	08 95       	ret

00007252 <eeprom_read_byte>:
    7252:	f9 99       	sbic	0x1f, 1	; 31
    7254:	fe cf       	rjmp	.-4      	; 0x7252 <eeprom_read_byte>
    7256:	92 bd       	out	0x22, r25	; 34
    7258:	81 bd       	out	0x21, r24	; 33
    725a:	f8 9a       	sbi	0x1f, 0	; 31
    725c:	99 27       	eor	r25, r25
    725e:	80 b5       	in	r24, 0x20	; 32
    7260:	08 95       	ret

00007262 <eeprom_read_word>:
    7262:	a8 e1       	ldi	r26, 0x18	; 24
    7264:	b0 e0       	ldi	r27, 0x00	; 0
    7266:	42 e0       	ldi	r20, 0x02	; 2
    7268:	50 e0       	ldi	r21, 0x00	; 0
    726a:	e5 cf       	rjmp	.-54     	; 0x7236 <eeprom_read_blraw>

0000726c <eeprom_update_byte>:
    726c:	26 2f       	mov	r18, r22

0000726e <eeprom_update_r18>:
    726e:	f9 99       	sbic	0x1f, 1	; 31
    7270:	fe cf       	rjmp	.-4      	; 0x726e <eeprom_update_r18>
    7272:	92 bd       	out	0x22, r25	; 34
    7274:	81 bd       	out	0x21, r24	; 33
    7276:	f8 9a       	sbi	0x1f, 0	; 31
    7278:	01 97       	sbiw	r24, 0x01	; 1
    727a:	00 b4       	in	r0, 0x20	; 32
    727c:	02 16       	cp	r0, r18
    727e:	39 f0       	breq	.+14     	; 0x728e <eeprom_update_r18+0x20>
    7280:	1f ba       	out	0x1f, r1	; 31
    7282:	20 bd       	out	0x20, r18	; 32
    7284:	0f b6       	in	r0, 0x3f	; 63
    7286:	f8 94       	cli
    7288:	fa 9a       	sbi	0x1f, 2	; 31
    728a:	f9 9a       	sbi	0x1f, 1	; 31
    728c:	0f be       	out	0x3f, r0	; 63
    728e:	08 95       	ret

00007290 <eeprom_write_block>:
    7290:	dc 01       	movw	r26, r24
    7292:	cb 01       	movw	r24, r22
    7294:	02 c0       	rjmp	.+4      	; 0x729a <eeprom_write_block+0xa>
    7296:	2d 91       	ld	r18, X+
    7298:	05 d0       	rcall	.+10     	; 0x72a4 <eeprom_write_r18>
    729a:	41 50       	subi	r20, 0x01	; 1
    729c:	50 40       	sbci	r21, 0x00	; 0
    729e:	d8 f7       	brcc	.-10     	; 0x7296 <eeprom_write_block+0x6>
    72a0:	08 95       	ret

000072a2 <eeprom_write_byte>:
    72a2:	26 2f       	mov	r18, r22

000072a4 <eeprom_write_r18>:
    72a4:	f9 99       	sbic	0x1f, 1	; 31
    72a6:	fe cf       	rjmp	.-4      	; 0x72a4 <eeprom_write_r18>
    72a8:	1f ba       	out	0x1f, r1	; 31
    72aa:	92 bd       	out	0x22, r25	; 34
    72ac:	81 bd       	out	0x21, r24	; 33
    72ae:	20 bd       	out	0x20, r18	; 32
    72b0:	0f b6       	in	r0, 0x3f	; 63
    72b2:	f8 94       	cli
    72b4:	fa 9a       	sbi	0x1f, 2	; 31
    72b6:	f9 9a       	sbi	0x1f, 1	; 31
    72b8:	0f be       	out	0x3f, r0	; 63
    72ba:	01 96       	adiw	r24, 0x01	; 1
    72bc:	08 95       	ret

000072be <eeprom_write_word>:
    72be:	f1 df       	rcall	.-30     	; 0x72a2 <eeprom_write_byte>
    72c0:	27 2f       	mov	r18, r23
    72c2:	f0 cf       	rjmp	.-32     	; 0x72a4 <eeprom_write_r18>

000072c4 <__prologue_saves__>:
    72c4:	2f 92       	push	r2
    72c6:	3f 92       	push	r3
    72c8:	4f 92       	push	r4
    72ca:	5f 92       	push	r5
    72cc:	6f 92       	push	r6
    72ce:	7f 92       	push	r7
    72d0:	8f 92       	push	r8
    72d2:	9f 92       	push	r9
    72d4:	af 92       	push	r10
    72d6:	bf 92       	push	r11
    72d8:	cf 92       	push	r12
    72da:	df 92       	push	r13
    72dc:	ef 92       	push	r14
    72de:	ff 92       	push	r15
    72e0:	0f 93       	push	r16
    72e2:	1f 93       	push	r17
    72e4:	cf 93       	push	r28
    72e6:	df 93       	push	r29
    72e8:	cd b7       	in	r28, 0x3d	; 61
    72ea:	de b7       	in	r29, 0x3e	; 62
    72ec:	ca 1b       	sub	r28, r26
    72ee:	db 0b       	sbc	r29, r27
    72f0:	0f b6       	in	r0, 0x3f	; 63
    72f2:	f8 94       	cli
    72f4:	de bf       	out	0x3e, r29	; 62
    72f6:	0f be       	out	0x3f, r0	; 63
    72f8:	cd bf       	out	0x3d, r28	; 61
    72fa:	09 94       	ijmp

000072fc <__epilogue_restores__>:
    72fc:	2a 88       	ldd	r2, Y+18	; 0x12
    72fe:	39 88       	ldd	r3, Y+17	; 0x11
    7300:	48 88       	ldd	r4, Y+16	; 0x10
    7302:	5f 84       	ldd	r5, Y+15	; 0x0f
    7304:	6e 84       	ldd	r6, Y+14	; 0x0e
    7306:	7d 84       	ldd	r7, Y+13	; 0x0d
    7308:	8c 84       	ldd	r8, Y+12	; 0x0c
    730a:	9b 84       	ldd	r9, Y+11	; 0x0b
    730c:	aa 84       	ldd	r10, Y+10	; 0x0a
    730e:	b9 84       	ldd	r11, Y+9	; 0x09
    7310:	c8 84       	ldd	r12, Y+8	; 0x08
    7312:	df 80       	ldd	r13, Y+7	; 0x07
    7314:	ee 80       	ldd	r14, Y+6	; 0x06
    7316:	fd 80       	ldd	r15, Y+5	; 0x05
    7318:	0c 81       	ldd	r16, Y+4	; 0x04
    731a:	1b 81       	ldd	r17, Y+3	; 0x03
    731c:	aa 81       	ldd	r26, Y+2	; 0x02
    731e:	b9 81       	ldd	r27, Y+1	; 0x01
    7320:	ce 0f       	add	r28, r30
    7322:	d1 1d       	adc	r29, r1
    7324:	0f b6       	in	r0, 0x3f	; 63
    7326:	f8 94       	cli
    7328:	de bf       	out	0x3e, r29	; 62
    732a:	0f be       	out	0x3f, r0	; 63
    732c:	cd bf       	out	0x3d, r28	; 61
    732e:	ed 01       	movw	r28, r26
    7330:	08 95       	ret

00007332 <_exit>:
    7332:	f8 94       	cli

00007334 <__stop_program>:
    7334:	ff cf       	rjmp	.-2      	; 0x7334 <__stop_program>
