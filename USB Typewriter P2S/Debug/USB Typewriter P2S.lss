
USB Typewriter P2S.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001e0  00800100  0000780c  000078a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000780c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006d7  008002e0  008002e0  00007a80  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00007a80  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00007adc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007f8  00000000  00000000  00007b1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00011b9c  00000000  00000000  00008314  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003161  00000000  00000000  00019eb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00015b93  00000000  00000000  0001d011  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001dc4  00000000  00000000  00032ba4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0001c28d  00000000  00000000  00034968  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000d969  00000000  00000000  00050bf5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000ab8  00000000  00000000  0005e55e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000bac8  00000000  00000000  0005f016  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	87 c3       	rjmp	.+1806   	; 0x710 <__ctors_end>
       2:	00 00       	nop
       4:	a2 c3       	rjmp	.+1860   	; 0x74a <__bad_interrupt>
       6:	00 00       	nop
       8:	a0 c3       	rjmp	.+1856   	; 0x74a <__bad_interrupt>
       a:	00 00       	nop
       c:	9e c3       	rjmp	.+1852   	; 0x74a <__bad_interrupt>
       e:	00 00       	nop
      10:	9c c3       	rjmp	.+1848   	; 0x74a <__bad_interrupt>
      12:	00 00       	nop
      14:	9a c3       	rjmp	.+1844   	; 0x74a <__bad_interrupt>
      16:	00 00       	nop
      18:	98 c3       	rjmp	.+1840   	; 0x74a <__bad_interrupt>
      1a:	00 00       	nop
      1c:	96 c3       	rjmp	.+1836   	; 0x74a <__bad_interrupt>
      1e:	00 00       	nop
      20:	94 c3       	rjmp	.+1832   	; 0x74a <__bad_interrupt>
      22:	00 00       	nop
      24:	92 c3       	rjmp	.+1828   	; 0x74a <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 77 35 	jmp	0x6aee	; 0x6aee <__vector_10>
      2c:	8e c3       	rjmp	.+1820   	; 0x74a <__bad_interrupt>
      2e:	00 00       	nop
      30:	8c c3       	rjmp	.+1816   	; 0x74a <__bad_interrupt>
      32:	00 00       	nop
      34:	8a c3       	rjmp	.+1812   	; 0x74a <__bad_interrupt>
      36:	00 00       	nop
      38:	88 c3       	rjmp	.+1808   	; 0x74a <__bad_interrupt>
      3a:	00 00       	nop
      3c:	86 c3       	rjmp	.+1804   	; 0x74a <__bad_interrupt>
      3e:	00 00       	nop
      40:	84 c3       	rjmp	.+1800   	; 0x74a <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 13 27 	jmp	0x4e26	; 0x4e26 <__vector_17>
      48:	80 c3       	rjmp	.+1792   	; 0x74a <__bad_interrupt>
      4a:	00 00       	nop
      4c:	7e c3       	rjmp	.+1788   	; 0x74a <__bad_interrupt>
      4e:	00 00       	nop
      50:	7c c3       	rjmp	.+1784   	; 0x74a <__bad_interrupt>
      52:	00 00       	nop
      54:	7a c3       	rjmp	.+1780   	; 0x74a <__bad_interrupt>
      56:	00 00       	nop
      58:	78 c3       	rjmp	.+1776   	; 0x74a <__bad_interrupt>
      5a:	00 00       	nop
      5c:	76 c3       	rjmp	.+1772   	; 0x74a <__bad_interrupt>
      5e:	00 00       	nop
      60:	74 c3       	rjmp	.+1768   	; 0x74a <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 6f 26 	jmp	0x4cde	; 0x4cde <__vector_25>
      68:	0c 94 9d 26 	jmp	0x4d3a	; 0x4d3a <__vector_26>
      6c:	6e c3       	rjmp	.+1756   	; 0x74a <__bad_interrupt>
      6e:	00 00       	nop
      70:	6c c3       	rjmp	.+1752   	; 0x74a <__bad_interrupt>
      72:	00 00       	nop
      74:	6a c3       	rjmp	.+1748   	; 0x74a <__bad_interrupt>
      76:	00 00       	nop
      78:	68 c3       	rjmp	.+1744   	; 0x74a <__bad_interrupt>
      7a:	00 00       	nop
      7c:	66 c3       	rjmp	.+1740   	; 0x74a <__bad_interrupt>
      7e:	00 00       	nop
      80:	64 c3       	rjmp	.+1736   	; 0x74a <__bad_interrupt>
      82:	00 00       	nop
      84:	62 c3       	rjmp	.+1732   	; 0x74a <__bad_interrupt>
      86:	00 00       	nop
      88:	60 c3       	rjmp	.+1728   	; 0x74a <__bad_interrupt>
      8a:	00 00       	nop
      8c:	5e c3       	rjmp	.+1724   	; 0x74a <__bad_interrupt>
      8e:	00 00       	nop
      90:	5c c3       	rjmp	.+1720   	; 0x74a <__bad_interrupt>
      92:	00 00       	nop
      94:	5a c3       	rjmp	.+1716   	; 0x74a <__bad_interrupt>
      96:	00 00       	nop
      98:	58 c3       	rjmp	.+1712   	; 0x74a <__bad_interrupt>
      9a:	00 00       	nop
      9c:	56 c3       	rjmp	.+1708   	; 0x74a <__bad_interrupt>
      9e:	00 00       	nop
      a0:	54 c3       	rjmp	.+1704   	; 0x74a <__bad_interrupt>
      a2:	00 00       	nop
      a4:	0c 94 a7 0d 	jmp	0x1b4e	; 0x1b4e <__vector_41>
      a8:	50 c3       	rjmp	.+1696   	; 0x74a <__bad_interrupt>
	...

000000ac <SET_BYPASS_MODE>:
      ac:	41 54 2b 42 50 3d 30 34 2c 30 37 2c 30 30 00        AT+BP=04,07,00.

000000bb <CONNECT_TO_PAIRED_DEVICE>:
      bb:	41 54 2b 43 54 00                                   AT+CT.

000000c1 <CHECK_DISCOVERABLE>:
      c1:	41 54 2b 4d 44 00                                   AT+MD.

000000c7 <DISABLE_SLEEP>:
      c7:	41 54 2b 53 50 3d 30 30 00                          AT+SP=00.

000000d0 <CLEAR_PAIRED_LIST>:
      d0:	41 54 2b 43 50 00                                   AT+CP.

000000d6 <DISABLE_MASTERSHIP>:
      d6:	41 54 2b 4d 54 3d 30 30 00                          AT+MT=00.

000000df <SET_BT_COD>:
      df:	41 54 2b 43 44 3d 30 30 30 35 34 30 00              AT+CD=000540.

000000ec <ENABLE_PIN>:
      ec:	41 54 2b 49 4f 3d 30 31 00                          AT+IO=01.

000000f5 <DISABLE_PIN>:
      f5:	41 54 2b 49 4f 3d 30 33 00                          AT+IO=03.

000000fe <ENABLE_MIM>:
      fe:	41 54 2b 4d 4d 3d 30 32 00                          AT+MM=02.

00000107 <DISABLE_MIM>:
     107:	41 54 2b 4d 4d 3d 30 30 00                          AT+MM=00.

00000110 <SET_MODULE_FEATURES>:
     110:	41 54 2b 46 54 3d 46 46 2c 30 31 2c 46 46 2c 31     AT+FT=FF,01,FF,1
     120:	30 2c 30 31 2c 30 31 30 30 00                       0,01,0100.

0000012a <SET_BAUD_RATE>:
     12a:	41 54 2b 42 52 3d 30 42 00                          AT+BR=0B.

00000133 <SET_HID_PARAMS>:
     133:	41 54 2b 50 46 3d 30 30 2c 30 31 2c 30 30 00        AT+PF=00,01,00.

00000142 <SET_PROXY_MODE>:
     142:	41 54 2b 42 50 3d 30 30 2c 30 30 00                 AT+BP=00,00.

0000014e <ENABLE_UI>:
     14e:	41 54 2b 55 49 3d 30 31 00                          AT+UI=01.

00000157 <SET_FRIENDLY_NAME>:
     157:	41 54 2b 4e 4d 3d 55 53 42 20 54 79 70 65 77 72     AT+NM=USB Typewr
     167:	69 74 65 72 20 42 54 00                             iter BT.

0000016f <Str_BT_Not_Found>:
     16f:	4e 4f 20 42 4c 55 45 54 4f 4f 54 48 20 4d 4f 44     NO BLUETOOTH MOD
     17f:	55 4c 45 20 44 45 54 45 43 54 45 44 2e 2e 2e 0d     ULE DETECTED....
	...

00000190 <Str_Header>:
     190:	0d 43 48 41 52 3a 09 43 4f 4e 54 41 43 54 23 3a     .CHAR:.CONTACT#:
     1a0:	0d 00                                               ..

000001a2 <Str_Reed>:
     1a2:	52 45 45 44 00                                      REED.

000001a7 <Str_Shift_Plus>:
     1a7:	53 48 49 46 54 2b 00                                SHIFT+.

000001ae <Str_How_To_Exit>:
     1ae:	50 72 65 73 73 20 43 4d 44 2b 53 50 41 43 45 42     Press CMD+SPACEB
     1be:	41 52 20 74 6f 20 73 61 76 65 20 63 68 61 6e 67     AR to save chang
     1ce:	65 73 20 61 6e 64 20 65 78 69 74 2e 0d 00           es and exit...

000001dc <Str_How_To_Scroll_Back>:
     1dc:	50 72 65 73 73 20 43 54 52 4c 2b 53 50 41 43 45     Press CTRL+SPACE
     1ec:	42 41 52 20 74 6f 20 73 63 72 6f 6c 6c 20 62 61     BAR to scroll ba
     1fc:	63 6b 77 61 72 64 73 2e 0d 00                       ckwards...

00000206 <Str_How_To_Scroll>:
     206:	50 72 65 73 73 20 53 50 41 43 45 42 41 52 20 74     Press SPACEBAR t
     216:	6f 20 73 63 72 6f 6c 6c 20 74 68 72 6f 75 67 68     o scroll through
     226:	20 63 68 61 72 61 63 74 65 72 73 2e 0d 00            characters...

00000234 <Str_S_For_SD>:
     234:	50 72 65 73 73 20 53 20 69 66 20 63 68 61 6e 67     Press S if chang
     244:	65 73 20 73 68 6f 75 6c 64 20 61 70 70 6c 79 20     es should apply 
     254:	74 6f 20 53 44 20 6d 6f 64 65 2e 0d 00              to SD mode...

00000261 <Str_U_For_USB>:
     261:	50 72 65 73 73 20 55 20 69 66 20 63 68 61 6e 67     Press U if chang
     271:	65 73 20 73 68 6f 75 6c 64 20 61 70 70 6c 79 20     es should apply 
     281:	74 6f 20 55 53 42 2f 42 54 20 6d 6f 64 65 2e 0d     to USB/BT mode..
	...

00000292 <Str_Manual_Calibration>:
     292:	4d 41 4e 55 41 4c 20 43 41 4c 49 42 52 41 54 49     MANUAL CALIBRATI
     2a2:	4f 4e 20 4d 4f 44 45 2e 2e 2e 0d 00                 ON MODE.....

000002ae <Str_Settings_Saved>:
     2ae:	53 45 54 54 49 4e 47 53 20 53 41 56 45 44 21 0d     SETTINGS SAVED!.
	...

000002bf <Str_Spacebar_Blocks_Enter>:
     2bf:	0d 49 47 4e 4f 52 45 20 45 4e 54 45 52 20 4b 45     .IGNORE ENTER KE
     2cf:	59 20 57 48 45 4e 20 53 50 41 43 45 42 41 52 20     Y WHEN SPACEBAR 
     2df:	49 53 20 48 45 4c 44 3f 0d 00                       IS HELD?..

000002e9 <Str_Set_Reed_Time>:
     2e9:	0d 4e 4f 57 20 53 45 54 20 52 45 45 44 20 52 45     .NOW SET REED RE
     2f9:	41 43 54 49 4f 4e 20 54 49 4d 45 2e 2e 2e 0d 00     ACTION TIME.....

00000309 <Str_Set_Double_Time>:
     309:	0d 4e 4f 57 20 53 45 54 20 44 45 4c 41 59 20 42     .NOW SET DELAY B
     319:	45 54 57 45 45 4e 20 44 4f 55 42 4c 45 20 4b 45     ETWEEN DOUBLE KE
     329:	59 20 50 52 45 53 53 45 53 2e 2e 2e 0d 00           Y PRESSES.....

00000337 <Str_Set_Release_Time>:
     337:	0d 4e 4f 57 20 53 45 54 20 4b 45 59 20 52 45 4c     .NOW SET KEY REL
     347:	45 41 53 45 20 54 49 4d 45 2e 2e 2e 0d 00           EASE TIME.....

00000355 <Str_Set_Reaction_Time>:
     355:	50 52 45 53 53 20 43 54 52 4c 20 41 4e 44 20 41     PRESS CTRL AND A
     365:	4c 54 20 54 4f 20 53 45 54 20 4b 45 59 20 52 45     LT TO SET KEY RE
     375:	41 43 54 49 4f 4e 20 54 49 4d 45 2e 2e 2e 0d 00     ACTION TIME.....

00000385 <Str_Press_CMD>:
     385:	50 52 45 53 53 20 43 4d 44 20 4b 45 59 20 54 4f     PRESS CMD KEY TO
     395:	20 43 4f 4e 54 49 4e 55 45 2e 2e 2e 0d 00            CONTINUE.....

000003a3 <Str_Adj_Sensitivity>:
     3a3:	41 44 4a 55 53 54 49 4e 47 20 4b 45 59 20 53 45     ADJUSTING KEY SE
     3b3:	4e 53 49 54 49 56 49 54 59 2e 0d 00                 NSITIVITY...

000003bf <Str_No_Hall>:
     3bf:	4e 4f 20 48 41 4c 4c 20 45 46 46 45 43 54 20 53     NO HALL EFFECT S
     3cf:	45 4e 53 4f 52 20 44 45 54 45 43 54 45 44 2e 20     ENSOR DETECTED. 
     3df:	28 4e 4f 54 20 41 20 50 52 4f 42 4c 45 4d 29 0d     (NOT A PROBLEM).
	...

000003f0 <Str_Calibrate_Hall>:
     3f0:	48 4f 4c 44 20 44 4f 57 4e 20 41 4e 59 20 4b 45     HOLD DOWN ANY KE
     400:	59 20 54 4f 20 43 41 4c 49 42 52 41 54 45 20 48     Y TO CALIBRATE H
     410:	41 4c 4c 20 45 46 46 45 43 54 20 53 45 4e 53 4f     ALL EFFECT SENSO
     420:	52 2e 2e 2e 0d 00                                   R.....

00000426 <Str_Backspace>:
     426:	42 41 43 4b 53 50 41 43 45 00                       BACKSPACE.

00000430 <Str_Post>:
     430:	53 45 4e 44 09 00                                   SEND..

00000436 <Str_Second_Enter>:
     436:	53 45 43 4f 4e 44 20 45 4e 54 45 52 00              SECOND ENTER.

00000443 <Str_Esc>:
     443:	45 53 43 09 00                                      ESC..

00000448 <Str_Tab>:
     448:	54 41 42 09 00                                      TAB..

0000044d <Str_Enter>:
     44d:	45 4e 54 45 52 09 00                                ENTER..

00000454 <Str_Spacebar>:
     454:	53 50 41 43 45 42 41 52 00                          SPACEBAR.

0000045d <Str_Quick_Calibrate>:
     45d:	51 55 49 43 4b 20 43 41 4c 49 42 52 41 54 49 4f     QUICK CALIBRATIO
     46d:	4e 20 4d 4f 44 45 2e 2e 2e 0d 00                    N MODE.....

00000478 <Str_No_Dummy_Load>:
     478:	44 55 4d 4d 59 20 4c 4f 41 44 20 44 45 41 43 54     DUMMY LOAD DEACT
     488:	49 56 41 54 45 44 0d 00                             IVATED..

00000490 <Str_Dummy_Load>:
     490:	44 55 4d 4d 59 20 4c 4f 41 44 20 41 43 54 49 56     DUMMY LOAD ACTIV
     4a0:	41 54 45 44 0d 00                                   ATED..

000004a6 <Str_USB_Only>:
     4a6:	20 28 44 55 52 49 4e 47 20 55 53 42 2f 42 54 20      (DURING USB/BT 
     4b6:	4d 4f 44 45 29 3a 20 20 20 09 00                    MODE):   ..

000004c1 <Str_SD_Only>:
     4c1:	20 28 44 55 52 49 4e 47 20 53 44 20 43 41 52 44      (DURING SD CARD
     4d1:	20 4d 4f 44 45 29 3a 09 00                           MODE):..

000004da <Str_Shift_Error>:
     4da:	45 52 52 4f 52 2e 2e 2e 53 48 49 46 54 20 4d 55     ERROR...SHIFT MU
     4ea:	53 54 20 42 45 20 41 20 52 45 45 44 20 53 57 49     ST BE A REED SWI
     4fa:	54 43 48 2e 0d 00                                   TCH...

00000500 <Str_Type_The_Following>:
     500:	54 59 50 45 20 54 48 45 20 46 4f 4c 4c 4f 57 49     TYPE THE FOLLOWI
     510:	4e 47 20 4b 45 59 53 20 28 50 52 45 53 53 20 53     NG KEYS (PRESS S
     520:	50 41 43 45 20 54 4f 20 53 4b 49 50 29 2e 2e 2e     PACE TO SKIP)...
     530:	0d 00                                               ..

00000532 <Str_Calibrating>:
     532:	43 41 4c 49 42 52 41 54 49 4e 47 2e 2e 2e 0d 00     CALIBRATING.....

00000542 <Str_SD_Mode>:
     542:	53 44 20 43 41 52 44 20 53 54 4f 52 41 47 45 20     SD CARD STORAGE 
     552:	4d 4f 44 45 0d 00                                   MODE..

00000558 <Str_Combo_Mode>:
     558:	55 53 42 20 4b 45 59 42 4f 41 52 44 2f 43 41 52     USB KEYBOARD/CAR
     568:	44 20 52 45 41 44 45 52 20 4d 4f 44 45 0d 00        D READER MODE..

00000577 <Str_Light_Mode>:
     577:	4c 49 47 48 54 20 4d 4f 44 45 20 28 53 44 20 43     LIGHT MODE (SD C
     587:	41 52 44 20 52 45 41 44 45 52 20 44 49 53 41 42     ARD READER DISAB
     597:	4c 45 44 29 0d 00                                   LED)..

0000059d <Str_BT_Mode>:
     59d:	42 4c 55 45 54 4f 4f 54 48 20 4b 45 59 42 4f 41     BLUETOOTH KEYBOA
     5ad:	52 44 20 4d 4f 44 45 0d 00                          RD MODE..

000005b6 <Str_Typewriter_Mode>:
     5b6:	44 45 46 41 55 4c 54 20 53 45 54 54 49 4e 47 3a     DEFAULT SETTING:
     5c6:	20 00                                                .

000005c8 <Str_Firmware_Ver>:
     5c8:	46 49 52 4d 57 41 52 45 20 56 45 52 20 35 2e 37     FIRMWARE VER 5.7
     5d8:	2e 30 2e 45 48 00                                   .0.EH.

000005de <Str_USB_Typewriter>:
     5de:	55 53 42 20 54 59 50 45 57 52 49 54 45 52 20 28     USB TYPEWRITER (
     5ee:	54 4d 29 0d 00                                      TM)..

000005f3 <str_down>:
     5f3:	44 4f 57 4e 00                                      DOWN.

000005f8 <str_up>:
     5f8:	55 50 00                                            UP.

000005fb <str_right>:
     5fb:	52 49 47 48 54 00                                   RIGHT.

00000601 <str_left>:
     601:	4c 45 46 54 00                                      LEFT.

00000606 <hid_arrows>:
     606:	50 4f 52 51                                         PORQ

0000060a <ASCIINumSymbols>:
     60a:	21 22 23 24 25 5f 26 27 28 29                       !"#$%_&'()

00000614 <ASCIINumbers>:
     614:	31 32 33 34 35 36 37 38 39 30                       1234567890

0000061e <HIDNumbers>:
     61e:	1e 1f 20 21 22 23 24 25 26 27                       .. !"#$%&'

00000628 <ProductString>:
     628:	30 03 55 00 53 00 42 00 20 00 54 00 79 00 70 00     0.U.S.B. .T.y.p.
     638:	65 00 77 00 72 00 69 00 74 00 65 00 72 00 20 00     e.w.r.i.t.e.r. .
     648:	4b 00 65 00 79 00 62 00 6f 00 61 00 72 00 64 00     K.e.y.b.o.a.r.d.
	...

0000065a <ManufacturerString>:
     65a:	26 03 55 00 53 00 42 00 20 00 54 00 59 00 50 00     &.U.S.B. .T.Y.P.
     66a:	45 00 57 00 52 00 49 00 54 00 45 00 52 00 20 00     E.W.R.I.T.E.R. .
     67a:	4c 00 4c 00 43 00 00 00                             L.L.C...

00000682 <LanguageString>:
     682:	04 03 09 04                                         ....

00000686 <ConfigurationDescriptor>:
     686:	09 02 39 00 02 01 00 80 07 09 04 00 00 02 08 06     ..9.............
     696:	50 00 07 05 83 02 40 00 05 07 05 04 02 40 00 05     P.....@......@..
     6a6:	09 04 01 00 01 03 01 01 00 09 21 11 01 00 01 22     ..........!...."
     6b6:	3f 00 07 05 81 03 08 00 05                          ?........

000006bf <DeviceDescriptor>:
     6bf:	12 01 10 01 00 00 00 08 eb 03 61 20 86 00 01 02     ..........a ....
     6cf:	dc 01                                               ..

000006d1 <KeyboardReport>:
     6d1:	05 01 09 06 a1 01 05 07 19 e0 29 e7 15 00 25 01     ..........)...%.
     6e1:	75 01 95 08 81 02 95 01 75 08 81 01 05 08 19 01     u.......u.......
     6f1:	29 05 95 05 75 01 91 02 95 01 75 03 91 01 15 00     )...u.....u.....
     701:	25 ff 05 07 19 00 29 ff 95 06 75 08 81 00 c0        %.....)...u....

00000710 <__ctors_end>:
     710:	11 24       	eor	r1, r1
     712:	1f be       	out	0x3f, r1	; 63
     714:	cf ef       	ldi	r28, 0xFF	; 255
     716:	da e0       	ldi	r29, 0x0A	; 10
     718:	de bf       	out	0x3e, r29	; 62
     71a:	cd bf       	out	0x3d, r28	; 61

0000071c <__do_copy_data>:
     71c:	12 e0       	ldi	r17, 0x02	; 2
     71e:	a0 e0       	ldi	r26, 0x00	; 0
     720:	b1 e0       	ldi	r27, 0x01	; 1
     722:	ec e0       	ldi	r30, 0x0C	; 12
     724:	f8 e7       	ldi	r31, 0x78	; 120
     726:	02 c0       	rjmp	.+4      	; 0x72c <__do_copy_data+0x10>
     728:	05 90       	lpm	r0, Z+
     72a:	0d 92       	st	X+, r0
     72c:	a0 3e       	cpi	r26, 0xE0	; 224
     72e:	b1 07       	cpc	r27, r17
     730:	d9 f7       	brne	.-10     	; 0x728 <__do_copy_data+0xc>

00000732 <__do_clear_bss>:
     732:	29 e0       	ldi	r18, 0x09	; 9
     734:	a0 ee       	ldi	r26, 0xE0	; 224
     736:	b2 e0       	ldi	r27, 0x02	; 2
     738:	01 c0       	rjmp	.+2      	; 0x73c <.do_clear_bss_start>

0000073a <.do_clear_bss_loop>:
     73a:	1d 92       	st	X+, r1

0000073c <.do_clear_bss_start>:
     73c:	a7 3b       	cpi	r26, 0xB7	; 183
     73e:	b2 07       	cpc	r27, r18
     740:	e1 f7       	brne	.-8      	; 0x73a <.do_clear_bss_loop>
     742:	0e 94 ca 28 	call	0x5194	; 0x5194 <main>
     746:	0c 94 04 3c 	jmp	0x7808	; 0x7808 <_exit>

0000074a <__bad_interrupt>:
     74a:	5a cc       	rjmp	.-1868   	; 0x0 <__vectors>

0000074c <Get_Response.part.0>:
			code = code - '0'; //code number is converted from ascii to decimal by subtracting ascii 0.
			pin = pin + (pinplace*code);
			pinplace = pinplace / 10;
		}
	}
	Bluetooth_Send_Pin(pin);
     74c:	0f 93       	push	r16
     74e:	1f 93       	push	r17
     750:	cf 93       	push	r28
     752:	2f ef       	ldi	r18, 0xFF	; 255
     754:	80 e7       	ldi	r24, 0x70	; 112
     756:	92 e0       	ldi	r25, 0x02	; 2
     758:	21 50       	subi	r18, 0x01	; 1
     75a:	80 40       	sbci	r24, 0x00	; 0
     75c:	90 40       	sbci	r25, 0x00	; 0
     75e:	e1 f7       	brne	.-8      	; 0x758 <Get_Response.part.0+0xc>
     760:	00 c0       	rjmp	.+0      	; 0x762 <Get_Response.part.0+0x16>
     762:	00 00       	nop
     764:	10 92 d7 05 	sts	0x05D7, r1	; 0x8005d7 <response>
     768:	10 92 d8 05 	sts	0x05D8, r1	; 0x8005d8 <response+0x1>
     76c:	10 92 d9 05 	sts	0x05D9, r1	; 0x8005d9 <response+0x2>
     770:	10 92 db 05 	sts	0x05DB, r1	; 0x8005db <response+0x4>
     774:	07 ed       	ldi	r16, 0xD7	; 215
     776:	15 e0       	ldi	r17, 0x05	; 5
     778:	c0 e0       	ldi	r28, 0x00	; 0
     77a:	0e 94 e0 26 	call	0x4dc0	; 0x4dc0 <uart_getc>
     77e:	9c 01       	movw	r18, r24
     780:	22 27       	eor	r18, r18
     782:	23 2b       	or	r18, r19
     784:	31 f0       	breq	.+12     	; 0x792 <Get_Response.part.0+0x46>
     786:	ec 2f       	mov	r30, r28
     788:	f0 e0       	ldi	r31, 0x00	; 0
     78a:	e9 52       	subi	r30, 0x29	; 41
     78c:	fa 4f       	sbci	r31, 0xFA	; 250
     78e:	10 82       	st	Z, r1
     790:	0a c0       	rjmp	.+20     	; 0x7a6 <Get_Response.part.0+0x5a>
     792:	cb 33       	cpi	r28, 0x3B	; 59
     794:	19 f4       	brne	.+6      	; 0x79c <Get_Response.part.0+0x50>
     796:	10 92 12 06 	sts	0x0612, r1	; 0x800612 <response+0x3b>
     79a:	05 c0       	rjmp	.+10     	; 0x7a6 <Get_Response.part.0+0x5a>
     79c:	f8 01       	movw	r30, r16
     79e:	81 93       	st	Z+, r24
     7a0:	8f 01       	movw	r16, r30
     7a2:	cf 5f       	subi	r28, 0xFF	; 255
     7a4:	ea cf       	rjmp	.-44     	; 0x77a <Get_Response.part.0+0x2e>
     7a6:	90 91 d7 05 	lds	r25, 0x05D7	; 0x8005d7 <response>
     7aa:	9f 34       	cpi	r25, 0x4F	; 79
     7ac:	59 f0       	breq	.+22     	; 0x7c4 <Get_Response.part.0+0x78>
     7ae:	80 91 d9 05 	lds	r24, 0x05D9	; 0x8005d9 <response+0x2>
     7b2:	8d 33       	cpi	r24, 0x3D	; 61
     7b4:	39 f0       	breq	.+14     	; 0x7c4 <Get_Response.part.0+0x78>
     7b6:	81 e0       	ldi	r24, 0x01	; 1
     7b8:	93 34       	cpi	r25, 0x43	; 67
     7ba:	29 f0       	breq	.+10     	; 0x7c6 <Get_Response.part.0+0x7a>
     7bc:	92 34       	cpi	r25, 0x42	; 66
     7be:	19 f0       	breq	.+6      	; 0x7c6 <Get_Response.part.0+0x7a>
     7c0:	80 e0       	ldi	r24, 0x00	; 0
     7c2:	01 c0       	rjmp	.+2      	; 0x7c6 <Get_Response.part.0+0x7a>
     7c4:	81 e0       	ldi	r24, 0x01	; 1
     7c6:	cf 91       	pop	r28
     7c8:	1f 91       	pop	r17
     7ca:	0f 91       	pop	r16
     7cc:	08 95       	ret

000007ce <Bluetooth_Send>:
     7ce:	cf 93       	push	r28
     7d0:	df 93       	push	r29
     7d2:	c8 2f       	mov	r28, r24
     7d4:	d6 2f       	mov	r29, r22
     7d6:	87 ff       	sbrs	r24, 7
     7d8:	02 c0       	rjmp	.+4      	; 0x7de <Bluetooth_Send+0x10>
     7da:	cf 77       	andi	r28, 0x7F	; 127
     7dc:	d2 e0       	ldi	r29, 0x02	; 2
     7de:	c4 37       	cpi	r28, 0x74	; 116
     7e0:	11 f4       	brne	.+4      	; 0x7e6 <Bluetooth_Send+0x18>
     7e2:	d1 e0       	ldi	r29, 0x01	; 1
     7e4:	c8 e2       	ldi	r28, 0x28	; 40
     7e6:	81 ea       	ldi	r24, 0xA1	; 161
     7e8:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     7ec:	81 e0       	ldi	r24, 0x01	; 1
     7ee:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     7f2:	8d 2f       	mov	r24, r29
     7f4:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     7f8:	80 e0       	ldi	r24, 0x00	; 0
     7fa:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     7fe:	8c 2f       	mov	r24, r28
     800:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     804:	80 e0       	ldi	r24, 0x00	; 0
     806:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     80a:	80 e0       	ldi	r24, 0x00	; 0
     80c:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     810:	80 e0       	ldi	r24, 0x00	; 0
     812:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     81c:	80 e0       	ldi	r24, 0x00	; 0
     81e:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     822:	8f ec       	ldi	r24, 0xCF	; 207
     824:	97 e0       	ldi	r25, 0x07	; 7
     826:	01 97       	sbiw	r24, 0x01	; 1
     828:	f1 f7       	brne	.-4      	; 0x826 <Bluetooth_Send+0x58>
     82a:	00 c0       	rjmp	.+0      	; 0x82c <Bluetooth_Send+0x5e>
     82c:	00 00       	nop
     82e:	81 ea       	ldi	r24, 0xA1	; 161
     830:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     834:	81 e0       	ldi	r24, 0x01	; 1
     836:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     83a:	80 e0       	ldi	r24, 0x00	; 0
     83c:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     840:	80 e0       	ldi	r24, 0x00	; 0
     842:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     846:	80 e0       	ldi	r24, 0x00	; 0
     848:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     84c:	80 e0       	ldi	r24, 0x00	; 0
     84e:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     852:	80 e0       	ldi	r24, 0x00	; 0
     854:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     858:	80 e0       	ldi	r24, 0x00	; 0
     85a:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     85e:	80 e0       	ldi	r24, 0x00	; 0
     860:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     864:	80 e0       	ldi	r24, 0x00	; 0
     866:	df 91       	pop	r29
     868:	cf 91       	pop	r28
     86a:	0c 94 fe 26 	jmp	0x4dfc	; 0x4dfc <uart_putc>

0000086e <Bluetooth_Toggle_iOS_Keyboard>:
     86e:	81 ea       	ldi	r24, 0xA1	; 161
     870:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     874:	82 e0       	ldi	r24, 0x02	; 2
     876:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     87a:	88 e0       	ldi	r24, 0x08	; 8
     87c:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     880:	80 e0       	ldi	r24, 0x00	; 0
     882:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     886:	8f e0       	ldi	r24, 0x0F	; 15
     888:	97 e2       	ldi	r25, 0x27	; 39
     88a:	01 97       	sbiw	r24, 0x01	; 1
     88c:	f1 f7       	brne	.-4      	; 0x88a <Bluetooth_Toggle_iOS_Keyboard+0x1c>
     88e:	00 c0       	rjmp	.+0      	; 0x890 <Bluetooth_Toggle_iOS_Keyboard+0x22>
     890:	00 00       	nop
     892:	81 ea       	ldi	r24, 0xA1	; 161
     894:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     898:	82 e0       	ldi	r24, 0x02	; 2
     89a:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     89e:	80 e0       	ldi	r24, 0x00	; 0
     8a0:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     8a4:	80 e0       	ldi	r24, 0x00	; 0
     8a6:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     8aa:	50 cf       	rjmp	.-352    	; 0x74c <Get_Response.part.0>

000008ac <Bluetooth_Reset>:
     8ac:	8f 98       	cbi	0x11, 7	; 17
     8ae:	2f eb       	ldi	r18, 0xBF	; 191
     8b0:	84 ed       	ldi	r24, 0xD4	; 212
     8b2:	91 e0       	ldi	r25, 0x01	; 1
     8b4:	21 50       	subi	r18, 0x01	; 1
     8b6:	80 40       	sbci	r24, 0x00	; 0
     8b8:	90 40       	sbci	r25, 0x00	; 0
     8ba:	e1 f7       	brne	.-8      	; 0x8b4 <Bluetooth_Reset+0x8>
     8bc:	00 c0       	rjmp	.+0      	; 0x8be <Bluetooth_Reset+0x12>
     8be:	00 00       	nop
     8c0:	8f 9a       	sbi	0x11, 7	; 17
     8c2:	2f ef       	ldi	r18, 0xFF	; 255
     8c4:	84 e3       	ldi	r24, 0x34	; 52
     8c6:	9c e0       	ldi	r25, 0x0C	; 12
     8c8:	21 50       	subi	r18, 0x01	; 1
     8ca:	80 40       	sbci	r24, 0x00	; 0
     8cc:	90 40       	sbci	r25, 0x00	; 0
     8ce:	e1 f7       	brne	.-8      	; 0x8c8 <Bluetooth_Reset+0x1c>
     8d0:	00 c0       	rjmp	.+0      	; 0x8d2 <Bluetooth_Reset+0x26>
     8d2:	00 00       	nop
     8d4:	08 95       	ret

000008d6 <Get_Response>:
     8d6:	81 11       	cpse	r24, r1
     8d8:	39 cf       	rjmp	.-398    	; 0x74c <Get_Response.part.0>
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	08 95       	ret

000008de <Bluetooth_Send_CMD>:
     8de:	ff 92       	push	r15
     8e0:	0f 93       	push	r16
     8e2:	1f 93       	push	r17
     8e4:	cf 93       	push	r28
     8e6:	df 93       	push	r29
     8e8:	f8 2e       	mov	r15, r24
     8ea:	09 2f       	mov	r16, r25
     8ec:	16 2f       	mov	r17, r22
     8ee:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <uart_clear_rx_buffer>
     8f2:	cf 2d       	mov	r28, r15
     8f4:	d0 2f       	mov	r29, r16
     8f6:	89 91       	ld	r24, Y+
     8f8:	88 23       	and	r24, r24
     8fa:	19 f0       	breq	.+6      	; 0x902 <Bluetooth_Send_CMD+0x24>
     8fc:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     900:	fa cf       	rjmp	.-12     	; 0x8f6 <Bluetooth_Send_CMD+0x18>
     902:	8d e0       	ldi	r24, 0x0D	; 13
     904:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     908:	8a e0       	ldi	r24, 0x0A	; 10
     90a:	0e 94 fe 26 	call	0x4dfc	; 0x4dfc <uart_putc>
     90e:	81 e0       	ldi	r24, 0x01	; 1
     910:	11 23       	and	r17, r17
     912:	31 f0       	breq	.+12     	; 0x920 <Bluetooth_Send_CMD+0x42>
     914:	df 91       	pop	r29
     916:	cf 91       	pop	r28
     918:	1f 91       	pop	r17
     91a:	0f 91       	pop	r16
     91c:	ff 90       	pop	r15
     91e:	db cf       	rjmp	.-74     	; 0x8d6 <Get_Response>
     920:	df 91       	pop	r29
     922:	cf 91       	pop	r28
     924:	1f 91       	pop	r17
     926:	0f 91       	pop	r16
     928:	ff 90       	pop	r15
     92a:	08 95       	ret

0000092c <Bluetooth_Send_PROGMEM_CMD>:
     92c:	cf 93       	push	r28
     92e:	c6 2f       	mov	r28, r22
     930:	bc 01       	movw	r22, r24
     932:	8c ee       	ldi	r24, 0xEC	; 236
     934:	96 e0       	ldi	r25, 0x06	; 6
     936:	0e 94 8e 38 	call	0x711c	; 0x711c <strcpy_P>
     93a:	6c 2f       	mov	r22, r28
     93c:	8c ee       	ldi	r24, 0xEC	; 236
     93e:	96 e0       	ldi	r25, 0x06	; 6
     940:	cf 91       	pop	r28
     942:	cd cf       	rjmp	.-102    	; 0x8de <Bluetooth_Send_CMD>

00000944 <Bluetooth_Enter_Proxy_Mode>:
     944:	2f ef       	ldi	r18, 0xFF	; 255
     946:	89 e6       	ldi	r24, 0x69	; 105
     948:	98 e1       	ldi	r25, 0x18	; 24
     94a:	21 50       	subi	r18, 0x01	; 1
     94c:	80 40       	sbci	r24, 0x00	; 0
     94e:	90 40       	sbci	r25, 0x00	; 0
     950:	e1 f7       	brne	.-8      	; 0x94a <Bluetooth_Enter_Proxy_Mode+0x6>
     952:	00 c0       	rjmp	.+0      	; 0x954 <Bluetooth_Enter_Proxy_Mode+0x10>
     954:	00 00       	nop
     956:	61 e0       	ldi	r22, 0x01	; 1
     958:	82 e4       	ldi	r24, 0x42	; 66
     95a:	91 e0       	ldi	r25, 0x01	; 1
     95c:	e7 df       	rcall	.-50     	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     95e:	2f ef       	ldi	r18, 0xFF	; 255
     960:	83 ed       	ldi	r24, 0xD3	; 211
     962:	90 e3       	ldi	r25, 0x30	; 48
     964:	21 50       	subi	r18, 0x01	; 1
     966:	80 40       	sbci	r24, 0x00	; 0
     968:	90 40       	sbci	r25, 0x00	; 0
     96a:	e1 f7       	brne	.-8      	; 0x964 <Bluetooth_Enter_Proxy_Mode+0x20>
     96c:	00 c0       	rjmp	.+0      	; 0x96e <Bluetooth_Enter_Proxy_Mode+0x2a>
     96e:	00 00       	nop
     970:	08 95       	ret

00000972 <Bluetooth_Exit_Proxy_Mode>:
     972:	61 e0       	ldi	r22, 0x01	; 1
     974:	8c ea       	ldi	r24, 0xAC	; 172
     976:	90 e0       	ldi	r25, 0x00	; 0
     978:	d9 cf       	rjmp	.-78     	; 0x92c <Bluetooth_Send_PROGMEM_CMD>

0000097a <Bluetooth_Init>:
     97a:	cf 93       	push	r28
     97c:	df 93       	push	r29
     97e:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <uart_clear_rx_buffer>
     982:	83 e3       	ldi	r24, 0x33	; 51
     984:	90 e0       	ldi	r25, 0x00	; 0
     986:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <uart_init>
     98a:	90 df       	rcall	.-224    	; 0x8ac <Bluetooth_Reset>
     98c:	2f ef       	ldi	r18, 0xFF	; 255
     98e:	89 e6       	ldi	r24, 0x69	; 105
     990:	98 e1       	ldi	r25, 0x18	; 24
     992:	21 50       	subi	r18, 0x01	; 1
     994:	80 40       	sbci	r24, 0x00	; 0
     996:	90 40       	sbci	r25, 0x00	; 0
     998:	e1 f7       	brne	.-8      	; 0x992 <Bluetooth_Init+0x18>
     99a:	00 c0       	rjmp	.+0      	; 0x99c <Bluetooth_Init+0x22>
     99c:	00 00       	nop
     99e:	d6 de       	rcall	.-596    	; 0x74c <Get_Response.part.0>
     9a0:	88 23       	and	r24, r24
     9a2:	69 f1       	breq	.+90     	; 0x9fe <Bluetooth_Init+0x84>
     9a4:	cf df       	rcall	.-98     	; 0x944 <Bluetooth_Enter_Proxy_Mode>
     9a6:	ca e0       	ldi	r28, 0x0A	; 10
     9a8:	d0 e0       	ldi	r29, 0x00	; 0
     9aa:	61 e0       	ldi	r22, 0x01	; 1
     9ac:	8a e2       	ldi	r24, 0x2A	; 42
     9ae:	91 e0       	ldi	r25, 0x01	; 1
     9b0:	bd df       	rcall	.-134    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     9b2:	88 23       	and	r24, r24
     9b4:	c1 f0       	breq	.+48     	; 0x9e6 <Bluetooth_Init+0x6c>
     9b6:	2f ef       	ldi	r18, 0xFF	; 255
     9b8:	80 e7       	ldi	r24, 0x70	; 112
     9ba:	92 e0       	ldi	r25, 0x02	; 2
     9bc:	21 50       	subi	r18, 0x01	; 1
     9be:	80 40       	sbci	r24, 0x00	; 0
     9c0:	90 40       	sbci	r25, 0x00	; 0
     9c2:	e1 f7       	brne	.-8      	; 0x9bc <Bluetooth_Init+0x42>
     9c4:	00 c0       	rjmp	.+0      	; 0x9c6 <Bluetooth_Init+0x4c>
     9c6:	00 00       	nop
     9c8:	88 e0       	ldi	r24, 0x08	; 8
     9ca:	90 e0       	ldi	r25, 0x00	; 0
     9cc:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <uart_init>
     9d0:	d0 df       	rcall	.-96     	; 0x972 <Bluetooth_Exit_Proxy_Mode>
     9d2:	2f ef       	ldi	r18, 0xFF	; 255
     9d4:	80 e7       	ldi	r24, 0x70	; 112
     9d6:	92 e0       	ldi	r25, 0x02	; 2
     9d8:	21 50       	subi	r18, 0x01	; 1
     9da:	80 40       	sbci	r24, 0x00	; 0
     9dc:	90 40       	sbci	r25, 0x00	; 0
     9de:	e1 f7       	brne	.-8      	; 0x9d8 <Bluetooth_Init+0x5e>
     9e0:	00 c0       	rjmp	.+0      	; 0x9e2 <Bluetooth_Init+0x68>
     9e2:	00 00       	nop
     9e4:	0c c0       	rjmp	.+24     	; 0x9fe <Bluetooth_Init+0x84>
     9e6:	2f ef       	ldi	r18, 0xFF	; 255
     9e8:	80 e7       	ldi	r24, 0x70	; 112
     9ea:	92 e0       	ldi	r25, 0x02	; 2
     9ec:	21 50       	subi	r18, 0x01	; 1
     9ee:	80 40       	sbci	r24, 0x00	; 0
     9f0:	90 40       	sbci	r25, 0x00	; 0
     9f2:	e1 f7       	brne	.-8      	; 0x9ec <Bluetooth_Init+0x72>
     9f4:	00 c0       	rjmp	.+0      	; 0x9f6 <Bluetooth_Init+0x7c>
     9f6:	00 00       	nop
     9f8:	21 97       	sbiw	r28, 0x01	; 1
     9fa:	b9 f6       	brne	.-82     	; 0x9aa <Bluetooth_Init+0x30>
     9fc:	dc cf       	rjmp	.-72     	; 0x9b6 <Bluetooth_Init+0x3c>
     9fe:	88 e0       	ldi	r24, 0x08	; 8
     a00:	90 e0       	ldi	r25, 0x00	; 0
     a02:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <uart_init>
     a06:	88 e0       	ldi	r24, 0x08	; 8
     a08:	90 e0       	ldi	r25, 0x00	; 0
     a0a:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <uart_init>
     a0e:	88 e0       	ldi	r24, 0x08	; 8
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <uart_init>
     a16:	88 e0       	ldi	r24, 0x08	; 8
     a18:	90 e0       	ldi	r25, 0x00	; 0
     a1a:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <uart_init>
     a1e:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <uart_clear_rx_buffer>
     a22:	44 df       	rcall	.-376    	; 0x8ac <Bluetooth_Reset>
     a24:	2f ef       	ldi	r18, 0xFF	; 255
     a26:	8e e9       	ldi	r24, 0x9E	; 158
     a28:	94 e2       	ldi	r25, 0x24	; 36
     a2a:	21 50       	subi	r18, 0x01	; 1
     a2c:	80 40       	sbci	r24, 0x00	; 0
     a2e:	90 40       	sbci	r25, 0x00	; 0
     a30:	e1 f7       	brne	.-8      	; 0xa2a <Bluetooth_Init+0xb0>
     a32:	00 c0       	rjmp	.+0      	; 0xa34 <Bluetooth_Init+0xba>
     a34:	00 00       	nop
     a36:	8a de       	rcall	.-748    	; 0x74c <Get_Response.part.0>
     a38:	81 e0       	ldi	r24, 0x01	; 1
     a3a:	80 93 13 06 	sts	0x0613, r24	; 0x800613 <BT_State>
     a3e:	df 91       	pop	r29
     a40:	cf 91       	pop	r28
     a42:	08 95       	ret

00000a44 <Bluetooth_Test>:
     a44:	cf 93       	push	r28
     a46:	99 df       	rcall	.-206    	; 0x97a <Bluetooth_Init>
     a48:	7d df       	rcall	.-262    	; 0x944 <Bluetooth_Enter_Proxy_Mode>
     a4a:	61 e0       	ldi	r22, 0x01	; 1
     a4c:	8e e4       	ldi	r24, 0x4E	; 78
     a4e:	91 e0       	ldi	r25, 0x01	; 1
     a50:	6d df       	rcall	.-294    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     a52:	c8 2f       	mov	r28, r24
     a54:	8e df       	rcall	.-228    	; 0x972 <Bluetooth_Exit_Proxy_Mode>
     a56:	8c 2f       	mov	r24, r28
     a58:	cf 91       	pop	r28
     a5a:	08 95       	ret

00000a5c <Bluetooth_Configure>:
     a5c:	1f 93       	push	r17
     a5e:	cf 93       	push	r28
     a60:	df 93       	push	r29
     a62:	8b df       	rcall	.-234    	; 0x97a <Bluetooth_Init>
     a64:	6f df       	rcall	.-290    	; 0x944 <Bluetooth_Enter_Proxy_Mode>
     a66:	ca e0       	ldi	r28, 0x0A	; 10
     a68:	d0 e0       	ldi	r29, 0x00	; 0
     a6a:	61 e0       	ldi	r22, 0x01	; 1
     a6c:	8e e4       	ldi	r24, 0x4E	; 78
     a6e:	91 e0       	ldi	r25, 0x01	; 1
     a70:	5d df       	rcall	.-326    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     a72:	81 11       	cpse	r24, r1
     a74:	0c c0       	rjmp	.+24     	; 0xa8e <Bluetooth_Configure+0x32>
     a76:	21 97       	sbiw	r28, 0x01	; 1
     a78:	2f ef       	ldi	r18, 0xFF	; 255
     a7a:	80 e7       	ldi	r24, 0x70	; 112
     a7c:	92 e0       	ldi	r25, 0x02	; 2
     a7e:	21 50       	subi	r18, 0x01	; 1
     a80:	80 40       	sbci	r24, 0x00	; 0
     a82:	90 40       	sbci	r25, 0x00	; 0
     a84:	e1 f7       	brne	.-8      	; 0xa7e <Bluetooth_Configure+0x22>
     a86:	00 c0       	rjmp	.+0      	; 0xa88 <Bluetooth_Configure+0x2c>
     a88:	00 00       	nop
     a8a:	20 97       	sbiw	r28, 0x00	; 0
     a8c:	71 f7       	brne	.-36     	; 0xa6a <Bluetooth_Configure+0xe>
     a8e:	11 e0       	ldi	r17, 0x01	; 1
     a90:	20 97       	sbiw	r28, 0x00	; 0
     a92:	09 f4       	brne	.+2      	; 0xa96 <Bluetooth_Configure+0x3a>
     a94:	10 e0       	ldi	r17, 0x00	; 0
     a96:	cd 2b       	or	r28, r29
     a98:	09 f4       	brne	.+2      	; 0xa9c <Bluetooth_Configure+0x40>
     a9a:	38 c0       	rjmp	.+112    	; 0xb0c <__stack+0xd>
     a9c:	61 e0       	ldi	r22, 0x01	; 1
     a9e:	83 e3       	ldi	r24, 0x33	; 51
     aa0:	91 e0       	ldi	r25, 0x01	; 1
     aa2:	44 df       	rcall	.-376    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     aa4:	2f ef       	ldi	r18, 0xFF	; 255
     aa6:	89 e6       	ldi	r24, 0x69	; 105
     aa8:	98 e1       	ldi	r25, 0x18	; 24
     aaa:	21 50       	subi	r18, 0x01	; 1
     aac:	80 40       	sbci	r24, 0x00	; 0
     aae:	90 40       	sbci	r25, 0x00	; 0
     ab0:	e1 f7       	brne	.-8      	; 0xaaa <Bluetooth_Configure+0x4e>
     ab2:	00 c0       	rjmp	.+0      	; 0xab4 <Bluetooth_Configure+0x58>
     ab4:	00 00       	nop
     ab6:	61 e0       	ldi	r22, 0x01	; 1
     ab8:	87 e5       	ldi	r24, 0x57	; 87
     aba:	91 e0       	ldi	r25, 0x01	; 1
     abc:	37 df       	rcall	.-402    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     abe:	61 e0       	ldi	r22, 0x01	; 1
     ac0:	80 e1       	ldi	r24, 0x10	; 16
     ac2:	91 e0       	ldi	r25, 0x01	; 1
     ac4:	33 df       	rcall	.-410    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     ac6:	80 91 69 01 	lds	r24, 0x0169	; 0x800169 <EnablePinCode>
     aca:	61 e0       	ldi	r22, 0x01	; 1
     acc:	88 23       	and	r24, r24
     ace:	39 f0       	breq	.+14     	; 0xade <Bluetooth_Configure+0x82>
     ad0:	8c ee       	ldi	r24, 0xEC	; 236
     ad2:	90 e0       	ldi	r25, 0x00	; 0
     ad4:	2b df       	rcall	.-426    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     ad6:	61 e0       	ldi	r22, 0x01	; 1
     ad8:	8e ef       	ldi	r24, 0xFE	; 254
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	06 c0       	rjmp	.+12     	; 0xaea <Bluetooth_Configure+0x8e>
     ade:	87 e0       	ldi	r24, 0x07	; 7
     ae0:	91 e0       	ldi	r25, 0x01	; 1
     ae2:	24 df       	rcall	.-440    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     ae4:	61 e0       	ldi	r22, 0x01	; 1
     ae6:	85 ef       	ldi	r24, 0xF5	; 245
     ae8:	90 e0       	ldi	r25, 0x00	; 0
     aea:	20 df       	rcall	.-448    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     aec:	61 e0       	ldi	r22, 0x01	; 1
     aee:	8f ed       	ldi	r24, 0xDF	; 223
     af0:	90 e0       	ldi	r25, 0x00	; 0
     af2:	1c df       	rcall	.-456    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     af4:	61 e0       	ldi	r22, 0x01	; 1
     af6:	86 ed       	ldi	r24, 0xD6	; 214
     af8:	90 e0       	ldi	r25, 0x00	; 0
     afa:	18 df       	rcall	.-464    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     afc:	61 e0       	ldi	r22, 0x01	; 1
     afe:	87 ec       	ldi	r24, 0xC7	; 199
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	14 df       	rcall	.-472    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     b04:	61 e0       	ldi	r22, 0x01	; 1
     b06:	80 ed       	ldi	r24, 0xD0	; 208
     b08:	90 e0       	ldi	r25, 0x00	; 0
     b0a:	10 df       	rcall	.-480    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     b0c:	32 df       	rcall	.-412    	; 0x972 <Bluetooth_Exit_Proxy_Mode>
     b0e:	81 2f       	mov	r24, r17
     b10:	df 91       	pop	r29
     b12:	cf 91       	pop	r28
     b14:	1f 91       	pop	r17
     b16:	08 95       	ret

00000b18 <BluetoothInquire>:
     b18:	61 e0       	ldi	r22, 0x01	; 1
     b1a:	80 ed       	ldi	r24, 0xD0	; 208
     b1c:	90 e0       	ldi	r25, 0x00	; 0
     b1e:	06 cf       	rjmp	.-500    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>

00000b20 <Bluetooth_Connect>:
     b20:	cf 93       	push	r28
     b22:	df 93       	push	r29
     b24:	00 d0       	rcall	.+0      	; 0xb26 <Bluetooth_Connect+0x6>
     b26:	00 d0       	rcall	.+0      	; 0xb28 <Bluetooth_Connect+0x8>
     b28:	cd b7       	in	r28, 0x3d	; 61
     b2a:	de b7       	in	r29, 0x3e	; 62
     b2c:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <EnablePinCode+0x1>
     b30:	90 91 6b 01 	lds	r25, 0x016B	; 0x80016b <EnablePinCode+0x2>
     b34:	a0 91 6c 01 	lds	r26, 0x016C	; 0x80016c <EnablePinCode+0x3>
     b38:	b0 91 6d 01 	lds	r27, 0x016D	; 0x80016d <EnablePinCode+0x4>
     b3c:	89 83       	std	Y+1, r24	; 0x01
     b3e:	9a 83       	std	Y+2, r25	; 0x02
     b40:	ab 83       	std	Y+3, r26	; 0x03
     b42:	bc 83       	std	Y+4, r27	; 0x04
     b44:	ff de       	rcall	.-514    	; 0x944 <Bluetooth_Enter_Proxy_Mode>
     b46:	2f ef       	ldi	r18, 0xFF	; 255
     b48:	89 e6       	ldi	r24, 0x69	; 105
     b4a:	98 e1       	ldi	r25, 0x18	; 24
     b4c:	21 50       	subi	r18, 0x01	; 1
     b4e:	80 40       	sbci	r24, 0x00	; 0
     b50:	90 40       	sbci	r25, 0x00	; 0
     b52:	e1 f7       	brne	.-8      	; 0xb4c <Bluetooth_Connect+0x2c>
     b54:	00 c0       	rjmp	.+0      	; 0xb56 <Bluetooth_Connect+0x36>
     b56:	00 00       	nop
     b58:	60 e0       	ldi	r22, 0x00	; 0
     b5a:	8e e4       	ldi	r24, 0x4E	; 78
     b5c:	91 e0       	ldi	r25, 0x01	; 1
     b5e:	e6 de       	rcall	.-564    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     b60:	61 e0       	ldi	r22, 0x01	; 1
     b62:	81 ec       	ldi	r24, 0xC1	; 193
     b64:	90 e0       	ldi	r25, 0x00	; 0
     b66:	e2 de       	rcall	.-572    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     b68:	be 01       	movw	r22, r28
     b6a:	6f 5f       	subi	r22, 0xFF	; 255
     b6c:	7f 4f       	sbci	r23, 0xFF	; 255
     b6e:	87 ed       	ldi	r24, 0xD7	; 215
     b70:	95 e0       	ldi	r25, 0x05	; 5
     b72:	0e 94 95 38 	call	0x712a	; 0x712a <strtok>
     b76:	be 01       	movw	r22, r28
     b78:	6f 5f       	subi	r22, 0xFF	; 255
     b7a:	7f 4f       	sbci	r23, 0xFF	; 255
     b7c:	80 e0       	ldi	r24, 0x00	; 0
     b7e:	90 e0       	ldi	r25, 0x00	; 0
     b80:	0e 94 95 38 	call	0x712a	; 0x712a <strtok>
     b84:	00 97       	sbiw	r24, 0x00	; 0
     b86:	51 f0       	breq	.+20     	; 0xb9c <Bluetooth_Connect+0x7c>
     b88:	fc 01       	movw	r30, r24
     b8a:	81 81       	ldd	r24, Z+1	; 0x01
     b8c:	80 33       	cpi	r24, 0x30	; 48
     b8e:	31 f4       	brne	.+12     	; 0xb9c <Bluetooth_Connect+0x7c>
     b90:	79 99       	sbic	0x0f, 1	; 15
     b92:	04 c0       	rjmp	.+8      	; 0xb9c <Bluetooth_Connect+0x7c>
     b94:	61 e0       	ldi	r22, 0x01	; 1
     b96:	8b eb       	ldi	r24, 0xBB	; 187
     b98:	90 e0       	ldi	r25, 0x00	; 0
     b9a:	c8 de       	rcall	.-624    	; 0x92c <Bluetooth_Send_PROGMEM_CMD>
     b9c:	ea de       	rcall	.-556    	; 0x972 <Bluetooth_Exit_Proxy_Mode>
     b9e:	81 e0       	ldi	r24, 0x01	; 1
     ba0:	0f 90       	pop	r0
     ba2:	0f 90       	pop	r0
     ba4:	0f 90       	pop	r0
     ba6:	0f 90       	pop	r0
     ba8:	df 91       	pop	r29
     baa:	cf 91       	pop	r28
     bac:	08 95       	ret

00000bae <Get_Bluetooth_State>:
#error "BT MODULE NAME INVALID"
#endif

uint8_t Get_Bluetooth_State(){
	return BT_State;
}
     bae:	80 91 13 06 	lds	r24, 0x0613	; 0x800613 <BT_State>
     bb2:	08 95       	ret

00000bb4 <ToggleDummyLoad>:
	USBSendPROGString(Str_Settings_Saved);
	
}

void ToggleDummyLoad(){
		if (UseDummyLoad) {
     bb4:	80 91 17 06 	lds	r24, 0x0617	; 0x800617 <UseDummyLoad>
     bb8:	88 23       	and	r24, r24
     bba:	29 f0       	breq	.+10     	; 0xbc6 <ToggleDummyLoad+0x12>
				UseDummyLoad = 0;
     bbc:	10 92 17 06 	sts	0x0617, r1	; 0x800617 <UseDummyLoad>
				USBSendPROGString(Str_No_Dummy_Load);
     bc0:	88 e7       	ldi	r24, 0x78	; 120
     bc2:	94 e0       	ldi	r25, 0x04	; 4
     bc4:	05 c0       	rjmp	.+10     	; 0xbd0 <ToggleDummyLoad+0x1c>
		}
		else {
				UseDummyLoad = 1;
     bc6:	81 e0       	ldi	r24, 0x01	; 1
     bc8:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <UseDummyLoad>
				USBSendPROGString(Str_Dummy_Load);
     bcc:	80 e9       	ldi	r24, 0x90	; 144
     bce:	94 e0       	ldi	r25, 0x04	; 4
     bd0:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
		}
		eeprom_update_byte((uint8_t*)DUMMY_LOAD_ADDR, UseDummyLoad);
     bd4:	60 91 17 06 	lds	r22, 0x0617	; 0x800617 <UseDummyLoad>
     bd8:	8f e0       	ldi	r24, 0x0F	; 15
     bda:	92 e0       	ldi	r25, 0x02	; 2
     bdc:	0c 94 a1 3b 	jmp	0x7742	; 0x7742 <eeprom_update_byte>

00000be0 <SaveCalibration>:
	
}


void SaveCalibration(){
		 USBSendString("SAVING...\r");
     be0:	8e e6       	ldi	r24, 0x6E	; 110
     be2:	91 e0       	ldi	r25, 0x01	; 1
     be4:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
		 eeprom_write_block (KeyCodeLookUpTable, (void *) KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
     be8:	40 e4       	ldi	r20, 0x40	; 64
     bea:	50 e0       	ldi	r21, 0x00	; 0
     bec:	60 e0       	ldi	r22, 0x00	; 0
     bee:	70 e0       	ldi	r23, 0x00	; 0
     bf0:	8c e1       	ldi	r24, 0x1C	; 28
     bf2:	96 e0       	ldi	r25, 0x06	; 6
     bf4:	0e 94 b3 3b 	call	0x7766	; 0x7766 <eeprom_write_block>
		 eeprom_write_block (FnKeyCodeLookUpTable, (void *) FN_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
     bf8:	40 e4       	ldi	r20, 0x40	; 64
     bfa:	50 e0       	ldi	r21, 0x00	; 0
     bfc:	60 e4       	ldi	r22, 0x40	; 64
     bfe:	70 e0       	ldi	r23, 0x00	; 0
     c00:	8a e6       	ldi	r24, 0x6A	; 106
     c02:	99 e0       	ldi	r25, 0x09	; 9
     c04:	0e 94 b3 3b 	call	0x7766	; 0x7766 <eeprom_write_block>
		 eeprom_write_block (ShiftKeyCodeLookUpTable, (void *) SHIFT_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
     c08:	40 e4       	ldi	r20, 0x40	; 64
     c0a:	50 e0       	ldi	r21, 0x00	; 0
     c0c:	60 e8       	ldi	r22, 0x80	; 128
     c0e:	70 e0       	ldi	r23, 0x00	; 0
     c10:	89 e6       	ldi	r24, 0x69	; 105
     c12:	96 e0       	ldi	r25, 0x06	; 6
     c14:	0e 94 b3 3b 	call	0x7766	; 0x7766 <eeprom_write_block>
		 eeprom_write_block (ASCIILookUpTable,(void *) ASCII_ADDR, KEYCODE_ARRAY_LENGTH);
     c18:	40 e4       	ldi	r20, 0x40	; 64
     c1a:	50 e0       	ldi	r21, 0x00	; 0
     c1c:	60 ec       	ldi	r22, 0xC0	; 192
     c1e:	70 e0       	ldi	r23, 0x00	; 0
     c20:	89 e2       	ldi	r24, 0x29	; 41
     c22:	97 e0       	ldi	r25, 0x07	; 7
     c24:	0e 94 b3 3b 	call	0x7766	; 0x7766 <eeprom_write_block>
		 eeprom_write_block (ASCIIShiftLookUpTable,(void *) ASCII_SHIFT_ADDR, KEYCODE_ARRAY_LENGTH);
     c28:	40 e4       	ldi	r20, 0x40	; 64
     c2a:	50 e0       	ldi	r21, 0x00	; 0
     c2c:	60 e0       	ldi	r22, 0x00	; 0
     c2e:	71 e0       	ldi	r23, 0x01	; 1
     c30:	8a ea       	ldi	r24, 0xAA	; 170
     c32:	96 e0       	ldi	r25, 0x06	; 6
     c34:	0e 94 b3 3b 	call	0x7766	; 0x7766 <eeprom_write_block>
		 
		 eeprom_update_byte ((uint8_t *)SHIFT_REED_ADDR, Shift_Reed);
     c38:	60 91 5e 06 	lds	r22, 0x065E	; 0x80065e <Shift_Reed>
     c3c:	85 e0       	ldi	r24, 0x05	; 5
     c3e:	92 e0       	ldi	r25, 0x02	; 2
     c40:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
		 
		 eeprom_update_byte ((uint8_t *)REED_1_POLARITY_ADDR,Reed1Polarity);
     c44:	60 91 68 06 	lds	r22, 0x0668	; 0x800668 <Reed1Polarity>
     c48:	86 e0       	ldi	r24, 0x06	; 6
     c4a:	92 e0       	ldi	r25, 0x02	; 2
     c4c:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
		 eeprom_update_byte ((uint8_t *)REED_2_POLARITY_ADDR,Reed2Polarity);
     c50:	60 91 16 06 	lds	r22, 0x0616	; 0x800616 <Reed2Polarity>
     c54:	87 e0       	ldi	r24, 0x07	; 7
     c56:	92 e0       	ldi	r25, 0x02	; 2
     c58:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
		 eeprom_update_byte ((uint8_t *)REED_3_POLARITY_ADDR,Reed3Polarity);
     c5c:	60 91 ea 06 	lds	r22, 0x06EA	; 0x8006ea <Reed3Polarity>
     c60:	88 e0       	ldi	r24, 0x08	; 8
     c62:	92 e0       	ldi	r25, 0x02	; 2
     c64:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
		 eeprom_update_byte ((uint8_t *)REED_4_POLARITY_ADDR,Reed4Polarity);
     c68:	60 91 28 07 	lds	r22, 0x0728	; 0x800728 <Reed4Polarity>
     c6c:	89 e0       	ldi	r24, 0x09	; 9
     c6e:	92 e0       	ldi	r25, 0x02	; 2
     c70:	0c 94 a1 3b 	jmp	0x7742	; 0x7742 <eeprom_update_byte>

00000c74 <DetectHallSensor>:
	TeachASCIIKey(' ',KeyPressed,LOWER); // ascii space key
	USBSend(KEY_ENTER,LOWER);
	
}

bool DetectHallSensor(){
     c74:	cf 93       	push	r28
     c76:	df 93       	push	r29
	bool HallSensorTest1;
	bool HallSensorTest2;

	
			UseHallSensor = HALL_NOT_PRESENT;  //make sure the hall effect bit is not cleared as soon as it is read.
     c78:	10 92 eb 06 	sts	0x06EB, r1	; 0x8006eb <UseHallSensor>
			HallSensorTest1 = getHallState(); //sample the hall effect sensor bit
     c7c:	0e 94 bf 2d 	call	0x5b7e	; 0x5b7e <getHallState>
     c80:	d8 2f       	mov	r29, r24
			USBSendPROGString(Str_Calibrate_Hall);
     c82:	80 ef       	ldi	r24, 0xF0	; 240
     c84:	93 e0       	ldi	r25, 0x03	; 3
     c86:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     c8a:	2f ef       	ldi	r18, 0xFF	; 255
     c8c:	87 ea       	ldi	r24, 0xA7	; 167
     c8e:	91 e6       	ldi	r25, 0x61	; 97
     c90:	21 50       	subi	r18, 0x01	; 1
     c92:	80 40       	sbci	r24, 0x00	; 0
     c94:	90 40       	sbci	r25, 0x00	; 0
     c96:	e1 f7       	brne	.-8      	; 0xc90 <DetectHallSensor+0x1c>
     c98:	00 c0       	rjmp	.+0      	; 0xc9a <DetectHallSensor+0x26>
     c9a:	00 00       	nop
			Delay_MS(4000);
			HallSensorTest2 = getHallState(); //sample it again
     c9c:	0e 94 bf 2d 	call	0x5b7e	; 0x5b7e <getHallState>
     ca0:	c8 2f       	mov	r28, r24
			if (HallSensorTest1 == HallSensorTest2){ //if it has not changed, hall effect sensor is not present.
     ca2:	d8 13       	cpse	r29, r24
     ca4:	07 c0       	rjmp	.+14     	; 0xcb4 <DetectHallSensor+0x40>
				USBSendPROGString(Str_No_Hall);
     ca6:	8f eb       	ldi	r24, 0xBF	; 191
     ca8:	93 e0       	ldi	r25, 0x03	; 3
     caa:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
				UseHallSensor = HALL_NOT_PRESENT;
     cae:	10 92 eb 06 	sts	0x06EB, r1	; 0x8006eb <UseHallSensor>
     cb2:	23 c0       	rjmp	.+70     	; 0xcfa <DetectHallSensor+0x86>
			}
			else{ // if it has changed, the "active" polarity of the hall effect sensor is HallSensorTest2
				USBSendString("Hall Sensor Detected!\r");
     cb4:	89 e7       	ldi	r24, 0x79	; 121
     cb6:	91 e0       	ldi	r25, 0x01	; 1
     cb8:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
				UseHallSensor = HALL_NOT_ACTIVE;
     cbc:	81 e0       	ldi	r24, 0x01	; 1
     cbe:	80 93 eb 06 	sts	0x06EB, r24	; 0x8006eb <UseHallSensor>
				HallSensorPolarity = HallSensorTest2;
     cc2:	c0 93 66 06 	sts	0x0666, r28	; 0x800666 <HallSensorPolarity>
				USBSendString("Press CTRL key now to activate Hall Sensor...");
     cc6:	80 e9       	ldi	r24, 0x90	; 144
     cc8:	91 e0       	ldi	r25, 0x01	; 1
     cca:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
     cce:	83 e6       	ldi	r24, 0x63	; 99
     cd0:	90 e0       	ldi	r25, 0x00	; 0
				for (int i=1; i < 100; i++){
					if(is_low(CTRL_KEY)) UseHallSensor = HALL_ACTIVE; 
     cd2:	22 e0       	ldi	r18, 0x02	; 2
     cd4:	7c 9b       	sbis	0x0f, 4	; 15
     cd6:	20 93 eb 06 	sts	0x06EB, r18	; 0x8006eb <UseHallSensor>
     cda:	ef e5       	ldi	r30, 0x5F	; 95
     cdc:	fa ee       	ldi	r31, 0xEA	; 234
     cde:	31 97       	sbiw	r30, 0x01	; 1
     ce0:	f1 f7       	brne	.-4      	; 0xcde <DetectHallSensor+0x6a>
     ce2:	00 c0       	rjmp	.+0      	; 0xce4 <DetectHallSensor+0x70>
     ce4:	00 00       	nop
     ce6:	01 97       	sbiw	r24, 0x01	; 1
			else{ // if it has changed, the "active" polarity of the hall effect sensor is HallSensorTest2
				USBSendString("Hall Sensor Detected!\r");
				UseHallSensor = HALL_NOT_ACTIVE;
				HallSensorPolarity = HallSensorTest2;
				USBSendString("Press CTRL key now to activate Hall Sensor...");
				for (int i=1; i < 100; i++){
     ce8:	a9 f7       	brne	.-22     	; 0xcd4 <DetectHallSensor+0x60>
					if(is_low(CTRL_KEY)) UseHallSensor = HALL_ACTIVE; 
					Delay_MS(30);
				}
				if (UseHallSensor == HALL_ACTIVE) USBSendString("\rHall Sensor Activated!\r");
     cea:	80 91 eb 06 	lds	r24, 0x06EB	; 0x8006eb <UseHallSensor>
     cee:	82 30       	cpi	r24, 0x02	; 2
     cf0:	21 f4       	brne	.+8      	; 0xcfa <DetectHallSensor+0x86>
     cf2:	8e eb       	ldi	r24, 0xBE	; 190
     cf4:	91 e0       	ldi	r25, 0x01	; 1
     cf6:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
			}
			
			if(is_low(CMD_KEY)){
     cfa:	7e 99       	sbic	0x0f, 6	; 15
     cfc:	03 c0       	rjmp	.+6      	; 0xd04 <DetectHallSensor+0x90>
				UseHallSensor = HALL_NOT_ACTIVE; //In the event that the hall sensor is acting erratically or not at all, holding CMD can force it off.
     cfe:	81 e0       	ldi	r24, 0x01	; 1
     d00:	80 93 eb 06 	sts	0x06EB, r24	; 0x8006eb <UseHallSensor>
			}
			
			/*Save the hall effect parameters to eeprom right away:*/
			eeprom_update_byte ((uint8_t *)USE_HALL_SENSOR_ADDR, UseHallSensor);
     d04:	60 91 eb 06 	lds	r22, 0x06EB	; 0x8006eb <UseHallSensor>
     d08:	83 e0       	ldi	r24, 0x03	; 3
     d0a:	92 e0       	ldi	r25, 0x02	; 2
     d0c:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
			eeprom_update_byte ((uint8_t *)HALL_SENSOR_POLARITY_ADDR, HallSensorPolarity);
     d10:	60 91 66 06 	lds	r22, 0x0666	; 0x800666 <HallSensorPolarity>
     d14:	84 e0       	ldi	r24, 0x04	; 4
     d16:	92 e0       	ldi	r25, 0x02	; 2
     d18:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
			
			return UseHallSensor;
     d1c:	81 e0       	ldi	r24, 0x01	; 1
     d1e:	90 91 eb 06 	lds	r25, 0x06EB	; 0x8006eb <UseHallSensor>
     d22:	91 11       	cpse	r25, r1
     d24:	01 c0       	rjmp	.+2      	; 0xd28 <DetectHallSensor+0xb4>
     d26:	80 e0       	ldi	r24, 0x00	; 0
}
     d28:	df 91       	pop	r29
     d2a:	cf 91       	pop	r28
     d2c:	08 95       	ret

00000d2e <WaitForKeypress>:
     d2e:	2f ef       	ldi	r18, 0xFF	; 255
     d30:	81 ee       	ldi	r24, 0xE1	; 225
     d32:	94 e0       	ldi	r25, 0x04	; 4
     d34:	21 50       	subi	r18, 0x01	; 1
     d36:	80 40       	sbci	r24, 0x00	; 0
     d38:	90 40       	sbci	r25, 0x00	; 0
     d3a:	e1 f7       	brne	.-8      	; 0xd34 <WaitForKeypress+0x6>
     d3c:	00 c0       	rjmp	.+0      	; 0xd3e <WaitForKeypress+0x10>
     d3e:	00 00       	nop
	int KeyPressed = 0;
	
	Delay_MS(200);//implement 500 MS delay before detecting a key.  (prevents rapid re-detection of keys over and over.
	
	while(KeyPressed == 0){ //keep getting a key until there is a key to get.
		KeyPressed = GetKeySimple();
     d40:	0e 94 21 2c 	call	0x5842	; 0x5842 <GetKeySimple>
     d44:	90 e0       	ldi	r25, 0x00	; 0
int WaitForKeypress(){
	int KeyPressed = 0;
	
	Delay_MS(200);//implement 500 MS delay before detecting a key.  (prevents rapid re-detection of keys over and over.
	
	while(KeyPressed == 0){ //keep getting a key until there is a key to get.
     d46:	00 97       	sbiw	r24, 0x00	; 0
     d48:	d9 f3       	breq	.-10     	; 0xd40 <WaitForKeypress+0x12>
		KeyPressed = GetKeySimple();
	}
	return KeyPressed;
}
     d4a:	08 95       	ret

00000d4c <TeachHIDKey>:
	
	
void TeachHIDKey(char teachkey, int keypressed, char Modifier){
     d4c:	cf 93       	push	r28
     d4e:	df 93       	push	r29
     d50:	eb 01       	movw	r28, r22
	if (Modifier == UPPER){
		ShiftKeyCodeLookUpTable[keypressed] = teachkey;
     d52:	fb 01       	movw	r30, r22
	return KeyPressed;
}
	
	
void TeachHIDKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
     d54:	42 30       	cpi	r20, 0x02	; 2
     d56:	41 f4       	brne	.+16     	; 0xd68 <TeachHIDKey+0x1c>
		ShiftKeyCodeLookUpTable[keypressed] = teachkey;
     d58:	e7 59       	subi	r30, 0x97	; 151
     d5a:	f9 4f       	sbci	r31, 0xF9	; 249
     d5c:	80 83       	st	Z, r24
		USBSendPROGString(Str_Shift_Plus);
     d5e:	87 ea       	ldi	r24, 0xA7	; 167
     d60:	91 e0       	ldi	r25, 0x01	; 1
     d62:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
     d66:	11 c0       	rjmp	.+34     	; 0xd8a <TeachHIDKey+0x3e>
	}
	else if (Modifier == HID_KEYBOARD_MODIFIER_LEFTALT){ //if FN is being held down,
     d68:	44 30       	cpi	r20, 0x04	; 4
     d6a:	61 f4       	brne	.+24     	; 0xd84 <TeachHIDKey+0x38>
		FnKeyCodeLookUpTable[keypressed] = teachkey;
     d6c:	e6 59       	subi	r30, 0x96	; 150
     d6e:	f6 4f       	sbci	r31, 0xF6	; 246
     d70:	80 83       	st	Z, r24
		//send "FN+number"
		USBSendString("FN");
     d72:	87 ed       	ldi	r24, 0xD7	; 215
     d74:	91 e0       	ldi	r25, 0x01	; 1
     d76:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
		USBSend(KEY_EQ,UPPER); //send a + sign
     d7a:	62 e0       	ldi	r22, 0x02	; 2
     d7c:	8e e2       	ldi	r24, 0x2E	; 46
     d7e:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
     d82:	03 c0       	rjmp	.+6      	; 0xd8a <TeachHIDKey+0x3e>
	}
	else{
		KeyCodeLookUpTable[keypressed] = teachkey;
     d84:	e4 5e       	subi	r30, 0xE4	; 228
     d86:	f9 4f       	sbci	r31, 0xF9	; 249
     d88:	80 83       	st	Z, r24
	}
	
	if(keypressed <= NUM_REED_SWITCHES+1){USBSendPROGString(Str_Reed);}
     d8a:	c6 30       	cpi	r28, 0x06	; 6
     d8c:	d1 05       	cpc	r29, r1
     d8e:	24 f4       	brge	.+8      	; 0xd98 <TeachHIDKey+0x4c>
     d90:	82 ea       	ldi	r24, 0xA2	; 162
     d92:	91 e0       	ldi	r25, 0x01	; 1
     d94:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSendNumber(keypressed);
     d98:	8c 2f       	mov	r24, r28
     d9a:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
     d9e:	2f ef       	ldi	r18, 0xFF	; 255
     da0:	84 e3       	ldi	r24, 0x34	; 52
     da2:	9c e0       	ldi	r25, 0x0C	; 12
     da4:	21 50       	subi	r18, 0x01	; 1
     da6:	80 40       	sbci	r24, 0x00	; 0
     da8:	90 40       	sbci	r25, 0x00	; 0
     daa:	e1 f7       	brne	.-8      	; 0xda4 <TeachHIDKey+0x58>
     dac:	00 c0       	rjmp	.+0      	; 0xdae <TeachHIDKey+0x62>
     dae:	00 00       	nop
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}
     db0:	df 91       	pop	r29
     db2:	cf 91       	pop	r28
     db4:	08 95       	ret

00000db6 <CalibrateReeds>:
		 eeprom_update_byte ((uint8_t *)REED_2_POLARITY_ADDR,Reed2Polarity);
		 eeprom_update_byte ((uint8_t *)REED_3_POLARITY_ADDR,Reed3Polarity);
		 eeprom_update_byte ((uint8_t *)REED_4_POLARITY_ADDR,Reed4Polarity);
}

void CalibrateReeds(){	
     db6:	1f 93       	push	r17
     db8:	cf 93       	push	r28
     dba:	df 93       	push	r29
	uint8_t Modifier;
	uint8_t KeyPressed;
	
//-------TEACH BACKSPACE KEY ---------
	USBSendPROGString(Str_Backspace);
     dbc:	86 e2       	ldi	r24, 0x26	; 38
     dbe:	94 e0       	ldi	r25, 0x04	; 4
     dc0:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSend(KEY_TAB,LOWER);
     dc4:	60 e0       	ldi	r22, 0x00	; 0
     dc6:	8b e2       	ldi	r24, 0x2B	; 43
     dc8:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	KeyPressed = WaitForKeypress();
     dcc:	b0 df       	rcall	.-160    	; 0xd2e <WaitForKeypress>
     dce:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
     dd0:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
     dd4:	18 2f       	mov	r17, r24
     dd6:	dd 27       	eor	r29, r29
	
	TeachHIDKey(KEY_BACKSPACE,KeyPressed,Modifier); 
     dd8:	48 2f       	mov	r20, r24
     dda:	be 01       	movw	r22, r28
     ddc:	8a e2       	ldi	r24, 0x2A	; 42
     dde:	b6 df       	rcall	.-148    	; 0xd4c <TeachHIDKey>
	if (!(Modifier & FN_MODIFIER)){//sd card does not use fn modifier.
     de0:	12 fd       	sbrc	r17, 2
     de2:	04 c0       	rjmp	.+8      	; 0xdec <CalibrateReeds+0x36>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     de4:	c7 5d       	subi	r28, 0xD7	; 215
     de6:	d8 4f       	sbci	r29, 0xF8	; 248
     de8:	88 e0       	ldi	r24, 0x08	; 8
     dea:	88 83       	st	Y, r24
	
	TeachHIDKey(KEY_BACKSPACE,KeyPressed,Modifier); 
	if (!(Modifier & FN_MODIFIER)){//sd card does not use fn modifier.
		TeachASCIIKey(8,KeyPressed,LOWER); // 8 is ascii backspace
	}
	USBSend(KEY_ENTER,LOWER);
     dec:	60 e0       	ldi	r22, 0x00	; 0
     dee:	88 e2       	ldi	r24, 0x28	; 40
     df0:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
//------TEACH ESC KEY ----------
	USBSendPROGString(Str_Esc);
     df4:	83 e4       	ldi	r24, 0x43	; 67
     df6:	94 e0       	ldi	r25, 0x04	; 4
     df8:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSend(KEY_TAB,LOWER);
     dfc:	60 e0       	ldi	r22, 0x00	; 0
     dfe:	8b e2       	ldi	r24, 0x2B	; 43
     e00:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	KeyPressed = WaitForKeypress();
     e04:	94 df       	rcall	.-216    	; 0xd2e <WaitForKeypress>
     e06:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
     e08:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
	TeachHIDKey(KEY_ESC,KeyPressed,Modifier); 
     e0c:	be 01       	movw	r22, r28
     e0e:	77 27       	eor	r23, r23
     e10:	48 2f       	mov	r20, r24
     e12:	89 e2       	ldi	r24, 0x29	; 41
     e14:	9b df       	rcall	.-202    	; 0xd4c <TeachHIDKey>
	//no ascii character stored for this key.
	USBSend(KEY_ENTER,LOWER);
     e16:	60 e0       	ldi	r22, 0x00	; 0
     e18:	88 e2       	ldi	r24, 0x28	; 40
     e1a:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
	//------TEACH TAB KEY ---------
	USBSendPROGString(Str_Tab);
     e1e:	88 e4       	ldi	r24, 0x48	; 72
     e20:	94 e0       	ldi	r25, 0x04	; 4
     e22:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSend(KEY_TAB,LOWER);
     e26:	60 e0       	ldi	r22, 0x00	; 0
     e28:	8b e2       	ldi	r24, 0x2B	; 43
     e2a:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	KeyPressed = WaitForKeypress();
     e2e:	7f df       	rcall	.-258    	; 0xd2e <WaitForKeypress>
     e30:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
     e32:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
     e36:	18 2f       	mov	r17, r24
	TeachHIDKey(KEY_TAB,KeyPressed,Modifier);
     e38:	dd 27       	eor	r29, r29
     e3a:	48 2f       	mov	r20, r24
     e3c:	be 01       	movw	r22, r28
     e3e:	8b e2       	ldi	r24, 0x2B	; 43
     e40:	85 df       	rcall	.-246    	; 0xd4c <TeachHIDKey>
	
	if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
     e42:	12 fd       	sbrc	r17, 2
     e44:	09 c0       	rjmp	.+18     	; 0xe58 <CalibrateReeds+0xa2>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     e46:	fe 01       	movw	r30, r28
     e48:	e7 5d       	subi	r30, 0xD7	; 215
     e4a:	f8 4f       	sbci	r31, 0xF8	; 248
     e4c:	89 e0       	ldi	r24, 0x09	; 9
     e4e:	80 83       	st	Z, r24
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
     e50:	c6 55       	subi	r28, 0x56	; 86
     e52:	d9 4f       	sbci	r29, 0xF9	; 249
     e54:	84 e7       	ldi	r24, 0x74	; 116
     e56:	88 83       	st	Y, r24
	if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
		TeachASCIIKey('\t',KeyPressed,LOWER); // tab key
		TeachASCIIKey('t',KeyPressed,UPPER); //tab key + shift is still tab
	}

	USBSend(KEY_ENTER,LOWER);
     e58:	60 e0       	ldi	r22, 0x00	; 0
     e5a:	88 e2       	ldi	r24, 0x28	; 40
     e5c:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
//--------TEACH ENTER KEY --------
	USBSendPROGString(Str_Enter);
     e60:	8d e4       	ldi	r24, 0x4D	; 77
     e62:	94 e0       	ldi	r25, 0x04	; 4
     e64:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSend(KEY_TAB,LOWER);// used to be a colon
     e68:	60 e0       	ldi	r22, 0x00	; 0
     e6a:	8b e2       	ldi	r24, 0x2B	; 43
     e6c:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	KeyPressed = WaitForKeypress();
     e70:	5e df       	rcall	.-324    	; 0xd2e <WaitForKeypress>
     e72:	ec 01       	movw	r28, r24
	
	//Enter key cannot use modifiers
	TeachHIDKey(KEY_ENTER, KeyPressed, LOWER); //teach the hid keycode array about this key.
     e74:	dd 27       	eor	r29, r29
     e76:	40 e0       	ldi	r20, 0x00	; 0
     e78:	be 01       	movw	r22, r28
     e7a:	88 e2       	ldi	r24, 0x28	; 40
     e7c:	67 df       	rcall	.-306    	; 0xd4c <TeachHIDKey>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     e7e:	c7 5d       	subi	r28, 0xD7	; 215
     e80:	d8 4f       	sbci	r29, 0xF8	; 248
     e82:	8d e0       	ldi	r24, 0x0D	; 13
     e84:	88 83       	st	Y, r24
	KeyPressed = WaitForKeypress();
	
	//Enter key cannot use modifiers
	TeachHIDKey(KEY_ENTER, KeyPressed, LOWER); //teach the hid keycode array about this key.
	TeachASCIIKey('\r',KeyPressed, LOWER);//return carriage for ascii users
	USBSend(KEY_ENTER,LOWER);
     e86:	60 e0       	ldi	r22, 0x00	; 0
     e88:	88 e2       	ldi	r24, 0x28	; 40
     e8a:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
//-------TEACH SECONDARY ENTER KEY ----------
	
	USBSendPROGString(Str_Second_Enter);
     e8e:	86 e3       	ldi	r24, 0x36	; 54
     e90:	94 e0       	ldi	r25, 0x04	; 4
     e92:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSend(KEY_TAB,LOWER);// used to be a colon
     e96:	60 e0       	ldi	r22, 0x00	; 0
     e98:	8b e2       	ldi	r24, 0x2B	; 43
	KeyPressed = WaitForKeypress(KEY_EXECUTE);
     e9a:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
     e9e:	84 e7       	ldi	r24, 0x74	; 116
     ea0:	90 e0       	ldi	r25, 0x00	; 0
	
	//Enter key cannot use modifiers
	TeachHIDKey(KEY_ENTER, KeyPressed, LOWER); //teach the hid keycode array about this key.
     ea2:	45 df       	rcall	.-374    	; 0xd2e <WaitForKeypress>
     ea4:	bc 01       	movw	r22, r24
     ea6:	77 27       	eor	r23, r23
     ea8:	40 e0       	ldi	r20, 0x00	; 0
     eaa:	88 e2       	ldi	r24, 0x28	; 40
     eac:	4f df       	rcall	.-354    	; 0xd4c <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
     eae:	60 e0       	ldi	r22, 0x00	; 0
     eb0:	88 e2       	ldi	r24, 0x28	; 40
     eb2:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
// -------TEACH SEND KEY --------------
	USBSendPROGString(Str_Post);
     eb6:	80 e3       	ldi	r24, 0x30	; 48
     eb8:	94 e0       	ldi	r25, 0x04	; 4
	USBSend(KEY_TAB,LOWER);// used to be a colon
     eba:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
     ebe:	60 e0       	ldi	r22, 0x00	; 0
     ec0:	8b e2       	ldi	r24, 0x2B	; 43
	KeyPressed = WaitForKeypress();
     ec2:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	TeachHIDKey(KEY_EXECUTE, KeyPressed, LOWER); //teach the hid keycode array about this key.
     ec6:	33 df       	rcall	.-410    	; 0xd2e <WaitForKeypress>
     ec8:	bc 01       	movw	r22, r24
     eca:	77 27       	eor	r23, r23
     ecc:	40 e0       	ldi	r20, 0x00	; 0
     ece:	84 e7       	ldi	r24, 0x74	; 116
     ed0:	3d df       	rcall	.-390    	; 0xd4c <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
     ed2:	60 e0       	ldi	r22, 0x00	; 0
     ed4:	88 e2       	ldi	r24, 0x28	; 40
     ed6:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
//------TEACH SPACE BAR ---- must be the last thing programmed (because of "Press space to skip" instruction)
	USBSendPROGString(Str_Spacebar);
     eda:	84 e5       	ldi	r24, 0x54	; 84
     edc:	94 e0       	ldi	r25, 0x04	; 4
	USBSend(KEY_TAB,LOWER);
     ede:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
     ee2:	60 e0       	ldi	r22, 0x00	; 0
     ee4:	8b e2       	ldi	r24, 0x2B	; 43
	KeyPressed = WaitForKeypress();
     ee6:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
     eea:	21 df       	rcall	.-446    	; 0xd2e <WaitForKeypress>
     eec:	ec 01       	movw	r28, r24
	
	TeachHIDKey(KEY_SPACE,KeyPressed,LOWER); //space bar is independent of modifier.
     eee:	dd 27       	eor	r29, r29
     ef0:	40 e0       	ldi	r20, 0x00	; 0
     ef2:	be 01       	movw	r22, r28
     ef4:	8c e2       	ldi	r24, 0x2C	; 44
     ef6:	2a df       	rcall	.-428    	; 0xd4c <TeachHIDKey>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     ef8:	c7 5d       	subi	r28, 0xD7	; 215
     efa:	d8 4f       	sbci	r29, 0xF8	; 248
     efc:	80 e2       	ldi	r24, 0x20	; 32
     efe:	88 83       	st	Y, r24
	USBSend(KEY_TAB,LOWER);
	KeyPressed = WaitForKeypress();
	
	TeachHIDKey(KEY_SPACE,KeyPressed,LOWER); //space bar is independent of modifier.
	TeachASCIIKey(' ',KeyPressed,LOWER); // ascii space key
	USBSend(KEY_ENTER,LOWER);
     f00:	60 e0       	ldi	r22, 0x00	; 0
     f02:	88 e2       	ldi	r24, 0x28	; 40
	
}
     f04:	df 91       	pop	r29
     f06:	cf 91       	pop	r28
     f08:	1f 91       	pop	r17
	USBSend(KEY_TAB,LOWER);
	KeyPressed = WaitForKeypress();
	
	TeachHIDKey(KEY_SPACE,KeyPressed,LOWER); //space bar is independent of modifier.
	TeachASCIIKey(' ',KeyPressed,LOWER); // ascii space key
	USBSend(KEY_ENTER,LOWER);
     f0a:	0c 94 cc 29 	jmp	0x5398	; 0x5398 <USBSend>

00000f0e <QuickCalibrate>:
}

void QuickCalibrate(){
	uint8_t KeyPressed; //

	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
     f0e:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
     f12:	84 30       	cpi	r24, 0x04	; 4
     f14:	e1 f7       	brne	.-8      	; 0xf0e <QuickCalibrate>
     f16:	2f ef       	ldi	r18, 0xFF	; 255
     f18:	89 e6       	ldi	r24, 0x69	; 105
     f1a:	98 e1       	ldi	r25, 0x18	; 24
     f1c:	21 50       	subi	r18, 0x01	; 1
     f1e:	80 40       	sbci	r24, 0x00	; 0
     f20:	90 40       	sbci	r25, 0x00	; 0
     f22:	e1 f7       	brne	.-8      	; 0xf1c <QuickCalibrate+0xe>
     f24:	00 c0       	rjmp	.+0      	; 0xf26 <QuickCalibrate+0x18>
     f26:	00 00       	nop
	Delay_MS(1000);//wait 1 second.
	
	USBSendPROGString(Str_Quick_Calibrate);
     f28:	8d e5       	ldi	r24, 0x5D	; 93
     f2a:	94 e0       	ldi	r25, 0x04	; 4
     f2c:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
			
	if(!Bluetooth_Test()){ //if there is no bluetooth module, tell the user.
     f30:	89 dd       	rcall	.-1262   	; 0xa44 <Bluetooth_Test>
     f32:	81 11       	cpse	r24, r1
     f34:	0d c0       	rjmp	.+26     	; 0xf50 <QuickCalibrate+0x42>
		USBSendPROGString(Str_BT_Not_Found);
     f36:	8f e6       	ldi	r24, 0x6F	; 111
     f38:	91 e0       	ldi	r25, 0x01	; 1
     f3a:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
     f3e:	2f ef       	ldi	r18, 0xFF	; 255
     f40:	83 ed       	ldi	r24, 0xD3	; 211
     f42:	90 e3       	ldi	r25, 0x30	; 48
     f44:	21 50       	subi	r18, 0x01	; 1
     f46:	80 40       	sbci	r24, 0x00	; 0
     f48:	90 40       	sbci	r25, 0x00	; 0
     f4a:	e1 f7       	brne	.-8      	; 0xf44 <QuickCalibrate+0x36>
     f4c:	00 c0       	rjmp	.+0      	; 0xf4e <QuickCalibrate+0x40>
     f4e:	00 00       	nop
		Delay_MS(2000);
	}
	
	/*Measure the reed switch polarities*/
	Reed1Polarity = is_low(REED_1); //if reed_1 is low at start of calibration, then the polarity of reed 1 is active high
     f50:	99 b1       	in	r25, 0x09	; 9
     f52:	81 e0       	ldi	r24, 0x01	; 1
     f54:	92 95       	swap	r25
     f56:	91 70       	andi	r25, 0x01	; 1
     f58:	98 27       	eor	r25, r24
     f5a:	90 93 68 06 	sts	0x0668, r25	; 0x800668 <Reed1Polarity>
	Reed2Polarity= is_low(REED_2);
     f5e:	99 b1       	in	r25, 0x09	; 9
     f60:	96 fb       	bst	r25, 6
     f62:	99 27       	eor	r25, r25
     f64:	90 f9       	bld	r25, 0
     f66:	98 27       	eor	r25, r24
     f68:	90 93 16 06 	sts	0x0616, r25	; 0x800616 <Reed2Polarity>
	Reed3Polarity = is_low(REED_3);
     f6c:	99 b1       	in	r25, 0x09	; 9
     f6e:	90 95       	com	r25
     f70:	99 1f       	adc	r25, r25
     f72:	99 27       	eor	r25, r25
     f74:	99 1f       	adc	r25, r25
     f76:	90 93 ea 06 	sts	0x06EA, r25	; 0x8006ea <Reed3Polarity>
	Reed4Polarity = is_low(REED_4);
     f7a:	93 b1       	in	r25, 0x03	; 3
     f7c:	92 95       	swap	r25
     f7e:	91 70       	andi	r25, 0x01	; 1
     f80:	89 27       	eor	r24, r25
     f82:	80 93 28 07 	sts	0x0728, r24	; 0x800728 <Reed4Polarity>
	
	
	
	//Find out if user wants to use the hall effect sensor (probably not).
	DetectHallSensor();
     f86:	76 de       	rcall	.-788    	; 0xc74 <DetectHallSensor>

	USBSendPROGString(Str_Type_The_Following);
     f88:	80 e0       	ldi	r24, 0x00	; 0
     f8a:	95 e0       	ldi	r25, 0x05	; 5
     f8c:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>

	//--------TEACH SHIFT KEY-----------
	USBSendString("SHIFT");
     f90:	8a ed       	ldi	r24, 0xDA	; 218
     f92:	91 e0       	ldi	r25, 0x01	; 1
     f94:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
	Shift_Reed = 0; //reset the shift reed to 0 (undefined) so that WaitForKeypress() doesn't ignore any of the reeds
     f98:	10 92 5e 06 	sts	0x065E, r1	; 0x80065e <Shift_Reed>
	USBSend(KEY_TAB,LOWER);// used to be a colon
     f9c:	60 e0       	ldi	r22, 0x00	; 0
     f9e:	8b e2       	ldi	r24, 0x2B	; 43
     fa0:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	KeyPressed = WaitForKeypress();
     fa4:	c4 de       	rcall	.-632    	; 0xd2e <WaitForKeypress>
	if((KeyPressed)&&(KeyPressed <= 8)){ //if keypressed is 1, 2, 3, or 4, it represents a reed switch being held down.
     fa6:	9f ef       	ldi	r25, 0xFF	; 255
     fa8:	98 0f       	add	r25, r24
     faa:	98 30       	cpi	r25, 0x08	; 8
     fac:	58 f4       	brcc	.+22     	; 0xfc4 <QuickCalibrate+0xb6>
		Shift_Reed = KeyPressed;
     fae:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <Shift_Reed>
		USBSendPROGString(Str_Reed);
     fb2:	82 ea       	ldi	r24, 0xA2	; 162
     fb4:	91 e0       	ldi	r25, 0x01	; 1
     fb6:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
		USBSendNumber(Shift_Reed);
     fba:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <Shift_Reed>
     fbe:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
     fc2:	04 c0       	rjmp	.+8      	; 0xfcc <QuickCalibrate+0xbe>
	}
	else{
		USBSendPROGString(Str_Shift_Error);
     fc4:	8a ed       	ldi	r24, 0xDA	; 218
     fc6:	94 e0       	ldi	r25, 0x04	; 4
     fc8:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	}
	USBSend(KEY_ENTER,LOWER);
     fcc:	60 e0       	ldi	r22, 0x00	; 0
     fce:	88 e2       	ldi	r24, 0x28	; 40
	
	CalibrateReeds();
     fd0:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
	SaveCalibration();
     fd4:	f0 de       	rcall	.-544    	; 0xdb6 <CalibrateReeds>
     fd6:	04 de       	rcall	.-1016   	; 0xbe0 <SaveCalibration>
	
	USBSendPROGString(Str_Settings_Saved);
     fd8:	8e ea       	ldi	r24, 0xAE	; 174
     fda:	92 e0       	ldi	r25, 0x02	; 2
     fdc:	0c 94 8d 2a 	jmp	0x551a	; 0x551a <USBSendPROGString>

00000fe0 <TeachASCIIKey>:
	USBSendNumber(keypressed);
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
     fe0:	42 30       	cpi	r20, 0x02	; 2
     fe2:	21 f4       	brne	.+8      	; 0xfec <TeachASCIIKey+0xc>
		ASCIIShiftLookUpTable[keypressed] = teachkey;
     fe4:	fb 01       	movw	r30, r22
     fe6:	e6 55       	subi	r30, 0x56	; 86
     fe8:	f9 4f       	sbci	r31, 0xF9	; 249
     fea:	05 c0       	rjmp	.+10     	; 0xff6 <TeachASCIIKey+0x16>
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
     fec:	42 fd       	sbrc	r20, 2
     fee:	04 c0       	rjmp	.+8      	; 0xff8 <TeachASCIIKey+0x18>
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     ff0:	fb 01       	movw	r30, r22
     ff2:	e7 5d       	subi	r30, 0xD7	; 215
     ff4:	f8 4f       	sbci	r31, 0xF8	; 248
     ff6:	80 83       	st	Z, r24
     ff8:	08 95       	ret

00000ffa <Calibrate>:
	const char Str_Shift_Plus[] PROGMEM = "SHIFT+";
	const char Str_Reed[] PROGMEM ="REED";
	const char Str_Header[] PROGMEM = "\rCHAR:\tCONTACT#:\r";
	const char Str_BT_Not_Found[] PROGMEM = "NO BLUETOOTH MODULE DETECTED...\r";

void Calibrate(){
     ffa:	6f 92       	push	r6
     ffc:	7f 92       	push	r7
     ffe:	8f 92       	push	r8
    1000:	9f 92       	push	r9
    1002:	af 92       	push	r10
    1004:	bf 92       	push	r11
    1006:	cf 92       	push	r12
    1008:	df 92       	push	r13
    100a:	ef 92       	push	r14
    100c:	ff 92       	push	r15
    100e:	0f 93       	push	r16
    1010:	1f 93       	push	r17
    1012:	cf 93       	push	r28
    1014:	df 93       	push	r29
	uint8_t Modifier;
	uint8_t KeyPressed;
	
	uint8_t Default_Mode;

	ClearKeyCodeTables();//clear keycode tables (in memory)
    1016:	0e 94 27 2e 	call	0x5c4e	; 0x5c4e <ClearKeyCodeTables>

	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
    101a:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    101e:	84 30       	cpi	r24, 0x04	; 4
    1020:	e1 f7       	brne	.-8      	; 0x101a <Calibrate+0x20>
    1022:	2f ef       	ldi	r18, 0xFF	; 255
    1024:	89 e6       	ldi	r24, 0x69	; 105
    1026:	98 e1       	ldi	r25, 0x18	; 24
    1028:	21 50       	subi	r18, 0x01	; 1
    102a:	80 40       	sbci	r24, 0x00	; 0
    102c:	90 40       	sbci	r25, 0x00	; 0
    102e:	e1 f7       	brne	.-8      	; 0x1028 <Calibrate+0x2e>
    1030:	00 c0       	rjmp	.+0      	; 0x1032 <Calibrate+0x38>
    1032:	00 00       	nop
	Delay_MS(1000);//wait 1 second.
	
//--------SEND PROMPT TO USER -----------

    USBSendPROGString(Str_USB_Typewriter);
    1034:	8e ed       	ldi	r24, 0xDE	; 222
    1036:	95 e0       	ldi	r25, 0x05	; 5
    1038:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSendPROGString(Str_Firmware_Ver);
    103c:	88 ec       	ldi	r24, 0xC8	; 200
    103e:	95 e0       	ldi	r25, 0x05	; 5
    1040:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSend(KEY_ENTER,LOWER);
    1044:	60 e0       	ldi	r22, 0x00	; 0
    1046:	88 e2       	ldi	r24, 0x28	; 40
    1048:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
	
	Default_Mode = eeprom_read_byte((uint8_t*)DEFAULT_MODE_ADDR);
    104c:	8d e0       	ldi	r24, 0x0D	; 13
    104e:	92 e0       	ldi	r25, 0x02	; 2
    1050:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    1054:	c8 2f       	mov	r28, r24
	USBSendPROGString(Str_Typewriter_Mode);
    1056:	86 eb       	ldi	r24, 0xB6	; 182
    1058:	95 e0       	ldi	r25, 0x05	; 5
    105a:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	switch(Default_Mode){
    105e:	c2 30       	cpi	r28, 0x02	; 2
    1060:	91 f0       	breq	.+36     	; 0x1086 <Calibrate+0x8c>
    1062:	28 f4       	brcc	.+10     	; 0x106e <Calibrate+0x74>
    1064:	c1 30       	cpi	r28, 0x01	; 1
    1066:	91 f4       	brne	.+36     	; 0x108c <Calibrate+0x92>
		case USB_COMBO_MODE: 
			USBSendPROGString(Str_Combo_Mode); 
    1068:	88 e5       	ldi	r24, 0x58	; 88
    106a:	95 e0       	ldi	r25, 0x05	; 5
    106c:	09 c0       	rjmp	.+18     	; 0x1080 <Calibrate+0x86>
	USBSend(KEY_ENTER,LOWER);
	
	
	Default_Mode = eeprom_read_byte((uint8_t*)DEFAULT_MODE_ADDR);
	USBSendPROGString(Str_Typewriter_Mode);
	switch(Default_Mode){
    106e:	c9 30       	cpi	r28, 0x09	; 9
    1070:	29 f0       	breq	.+10     	; 0x107c <Calibrate+0x82>
    1072:	cd 30       	cpi	r28, 0x0D	; 13
    1074:	59 f4       	brne	.+22     	; 0x108c <Calibrate+0x92>
		break;
		case SD_MODE: 
			USBSendPROGString(Str_SD_Mode);
		break;
		case USB_LIGHT_MODE:
			USBSendPROGString(Str_Light_Mode);
    1076:	87 e7       	ldi	r24, 0x77	; 119
    1078:	95 e0       	ldi	r25, 0x05	; 5
    107a:	02 c0       	rjmp	.+4      	; 0x1080 <Calibrate+0x86>
	switch(Default_Mode){
		case USB_COMBO_MODE: 
			USBSendPROGString(Str_Combo_Mode); 
		break;
		case BLUETOOTH_MODE: 
			USBSendPROGString(Str_BT_Mode); 
    107c:	8d e9       	ldi	r24, 0x9D	; 157
    107e:	95 e0       	ldi	r25, 0x05	; 5
    1080:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
		break;
    1084:	07 c0       	rjmp	.+14     	; 0x1094 <Calibrate+0x9a>
		case SD_MODE: 
			USBSendPROGString(Str_SD_Mode);
    1086:	82 e4       	ldi	r24, 0x42	; 66
    1088:	95 e0       	ldi	r25, 0x05	; 5
    108a:	fa cf       	rjmp	.-12     	; 0x1080 <Calibrate+0x86>
		break;
		case USB_LIGHT_MODE:
			USBSendPROGString(Str_Light_Mode);
		break;
		default: USBSendString("NONE\r"); break;
    108c:	80 ee       	ldi	r24, 0xE0	; 224
    108e:	91 e0       	ldi	r25, 0x01	; 1
    1090:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
	}
	
	USBSendPROGString(Str_Calibrating);
    1094:	82 e3       	ldi	r24, 0x32	; 50
    1096:	95 e0       	ldi	r25, 0x05	; 5
    1098:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	
	/*Measure the reed switch polarities*/
		Reed1Polarity = is_low(REED_1); //if reed_1 is low at start of calibration, then the polarity of reed 1 is active high
    109c:	99 b1       	in	r25, 0x09	; 9
    109e:	81 e0       	ldi	r24, 0x01	; 1
    10a0:	92 95       	swap	r25
    10a2:	91 70       	andi	r25, 0x01	; 1
    10a4:	98 27       	eor	r25, r24
    10a6:	90 93 68 06 	sts	0x0668, r25	; 0x800668 <Reed1Polarity>
		Reed2Polarity= is_low(REED_2);
    10aa:	99 b1       	in	r25, 0x09	; 9
    10ac:	96 fb       	bst	r25, 6
    10ae:	99 27       	eor	r25, r25
    10b0:	90 f9       	bld	r25, 0
    10b2:	98 27       	eor	r25, r24
    10b4:	90 93 16 06 	sts	0x0616, r25	; 0x800616 <Reed2Polarity>
		Reed3Polarity = is_low(REED_3);
    10b8:	99 b1       	in	r25, 0x09	; 9
    10ba:	90 95       	com	r25
    10bc:	99 1f       	adc	r25, r25
    10be:	99 27       	eor	r25, r25
    10c0:	99 1f       	adc	r25, r25
    10c2:	90 93 ea 06 	sts	0x06EA, r25	; 0x8006ea <Reed3Polarity>
		Reed4Polarity = is_low(REED_4);
    10c6:	93 b1       	in	r25, 0x03	; 3
    10c8:	92 95       	swap	r25
    10ca:	91 70       	andi	r25, 0x01	; 1
    10cc:	89 27       	eor	r24, r25
    10ce:	80 93 28 07 	sts	0x0728, r24	; 0x800728 <Reed4Polarity>
		
		if(!Bluetooth_Test()){ //if there is no bluetooth module, tell the user.
    10d2:	b8 dc       	rcall	.-1680   	; 0xa44 <Bluetooth_Test>
    10d4:	81 11       	cpse	r24, r1
    10d6:	0d c0       	rjmp	.+26     	; 0x10f2 <Calibrate+0xf8>
			USBSendPROGString(Str_BT_Not_Found);
    10d8:	8f e6       	ldi	r24, 0x6F	; 111
    10da:	91 e0       	ldi	r25, 0x01	; 1
    10dc:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
    10e0:	ef ef       	ldi	r30, 0xFF	; 255
    10e2:	f3 ed       	ldi	r31, 0xD3	; 211
    10e4:	20 e3       	ldi	r18, 0x30	; 48
    10e6:	e1 50       	subi	r30, 0x01	; 1
    10e8:	f0 40       	sbci	r31, 0x00	; 0
    10ea:	20 40       	sbci	r18, 0x00	; 0
    10ec:	e1 f7       	brne	.-8      	; 0x10e6 <Calibrate+0xec>
    10ee:	00 c0       	rjmp	.+0      	; 0x10f0 <Calibrate+0xf6>
    10f0:	00 00       	nop
			Delay_MS(2000);
		}
		
		if (is_low(S2)){//hold down to activate the dummy load
				ToggleDummyLoad();
    10f2:	7d 9b       	sbis	0x0f, 5	; 15
		}

		DetectHallSensor();
    10f4:	5f dd       	rcall	.-1346   	; 0xbb4 <ToggleDummyLoad>
    10f6:	be dd       	rcall	.-1156   	; 0xc74 <DetectHallSensor>
	

	
	USBSendPROGString(Str_Type_The_Following);
    10f8:	80 e0       	ldi	r24, 0x00	; 0
    10fa:	95 e0       	ldi	r25, 0x05	; 5
    10fc:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSendPROGString(Str_Header);
    1100:	80 e9       	ldi	r24, 0x90	; 144
    1102:	91 e0       	ldi	r25, 0x01	; 1
    1104:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	
//--------TEACH LETTER KEYS----------
	for (HIDKey = KEY_A; HIDKey <= KEY_Z; HIDKey ++){
    1108:	c4 e0       	ldi	r28, 0x04	; 4
					
		TeachHIDKey(HIDKey, KeyPressed, Modifier); //all alphanumeric keys programmed as a/A pairs -- no special shift keys allowed.
		ASCIIKey = HIDKey-KEY_A+ASCII_A; //calculated corresponding sd card Ascii key
		
		if(HIDKey  == HID_KEYBOARD_SC_L){ //if the key is l, make sure fn+l=1
			FnKeyCodeLookUpTable[KeyPressed] = KEY_1;
    110a:	de e1       	ldi	r29, 0x1E	; 30
    110c:	fd 2e       	mov	r15, r29
	USBSendPROGString(Str_Type_The_Following);
	USBSendPROGString(Str_Header);
	
//--------TEACH LETTER KEYS----------
	for (HIDKey = KEY_A; HIDKey <= KEY_Z; HIDKey ++){
		USBSend(HIDKey, UPPER);
    110e:	62 e0       	ldi	r22, 0x02	; 2
    1110:	8c 2f       	mov	r24, r28
    1112:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
		USBSend(KEY_TAB,LOWER);// used to be a colon
    1116:	60 e0       	ldi	r22, 0x00	; 0
    1118:	8b e2       	ldi	r24, 0x2B	; 43
    111a:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
		KeyPressed = WaitForKeypress();
    111e:	07 de       	rcall	.-1010   	; 0xd2e <WaitForKeypress>
    1120:	8c 01       	movw	r16, r24
		Modifier = GetModifier();
    1122:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
    1126:	d8 2f       	mov	r29, r24
    1128:	11 27       	eor	r17, r17
		
		Modifier &= ~(HID_KEYBOARD_MODIFIER_LEFTSHIFT); //Lower-case version of the modifier indicator (overrid user's shift key)
					
		TeachHIDKey(HIDKey, KeyPressed, Modifier); //all alphanumeric keys programmed as a/A pairs -- no special shift keys allowed.
    112a:	48 2f       	mov	r20, r24
    112c:	4d 7f       	andi	r20, 0xFD	; 253
    112e:	b8 01       	movw	r22, r16
    1130:	8c 2f       	mov	r24, r28
    1132:	0c de       	rcall	.-1000   	; 0xd4c <TeachHIDKey>
		ASCIIKey = HIDKey-KEY_A+ASCII_A; //calculated corresponding sd card Ascii key
		
		if(HIDKey  == HID_KEYBOARD_SC_L){ //if the key is l, make sure fn+l=1
    1134:	cf 30       	cpi	r28, 0x0F	; 15
    1136:	21 f4       	brne	.+8      	; 0x1140 <Calibrate+0x146>
			FnKeyCodeLookUpTable[KeyPressed] = KEY_1;
    1138:	f8 01       	movw	r30, r16
    113a:	e6 59       	subi	r30, 0x96	; 150
    113c:	f6 4f       	sbci	r31, 0xF6	; 246
    113e:	f0 82       	st	Z, r15
		}
		
		if (!(Modifier & FN_MODIFIER)) { //only bother to program sd card letters if the fn key is not being pressed (sd card doesn't use fn key)
    1140:	d2 fd       	sbrc	r29, 2
    1142:	0c c0       	rjmp	.+24     	; 0x115c <Calibrate+0x162>
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1144:	f8 01       	movw	r30, r16
    1146:	e6 55       	subi	r30, 0x56	; 86
    1148:	f9 4f       	sbci	r31, 0xF9	; 249
    114a:	8d e3       	ldi	r24, 0x3D	; 61
    114c:	8c 0f       	add	r24, r28
    114e:	80 83       	st	Z, r24
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1150:	f8 01       	movw	r30, r16
    1152:	e7 5d       	subi	r30, 0xD7	; 215
    1154:	f8 4f       	sbci	r31, 0xF8	; 248
    1156:	8d e5       	ldi	r24, 0x5D	; 93
    1158:	8c 0f       	add	r24, r28
    115a:	80 83       	st	Z, r24
		if (!(Modifier & FN_MODIFIER)) { //only bother to program sd card letters if the fn key is not being pressed (sd card doesn't use fn key)
			TeachASCIIKey(ASCIIKey, KeyPressed, UPPER);  //program this key into memory as an upper case key
			TeachASCIIKey(ASCIIKey+0x20, KeyPressed, LOWER); // and as a lower case key
		}
		
		USBSend(KEY_ENTER,LOWER);
    115c:	60 e0       	ldi	r22, 0x00	; 0
    115e:	88 e2       	ldi	r24, 0x28	; 40
    1160:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
	USBSendPROGString(Str_Type_The_Following);
	USBSendPROGString(Str_Header);
	
//--------TEACH LETTER KEYS----------
	for (HIDKey = KEY_A; HIDKey <= KEY_Z; HIDKey ++){
    1164:	cf 5f       	subi	r28, 0xFF	; 255
    1166:	ce 31       	cpi	r28, 0x1E	; 30
    1168:	91 f6       	brne	.-92     	; 0x110e <Calibrate+0x114>
    116a:	ae e1       	ldi	r26, 0x1E	; 30
    116c:	ea 2e       	mov	r14, r26
    116e:	a6 e0       	ldi	r26, 0x06	; 6
    1170:	fa 2e       	mov	r15, r26
    1172:	b4 e1       	ldi	r27, 0x14	; 20
    1174:	ab 2e       	mov	r10, r27
    1176:	b6 e0       	ldi	r27, 0x06	; 6
    1178:	bb 2e       	mov	r11, r27
    117a:	ca e0       	ldi	r28, 0x0A	; 10
    117c:	cc 2e       	mov	r12, r28
    117e:	c6 e0       	ldi	r28, 0x06	; 6
    1180:	dc 2e       	mov	r13, r28
    1182:	1a e3       	ldi	r17, 0x3A	; 58
		USBSend(KEY_ENTER,LOWER);
	}

//--------TEACH NUMBER KEYS---------
	for (int i = 0; i <= 9; i ++){
			USBSend(pgm_read_byte(&HIDNumbers[i]), LOWER); //numbers are saved in program space.
    1184:	f7 01       	movw	r30, r14
    1186:	84 91       	lpm	r24, Z
    1188:	60 e0       	ldi	r22, 0x00	; 0
    118a:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
			USBSend(KEY_TAB,LOWER);// used to be a colon
    118e:	60 e0       	ldi	r22, 0x00	; 0
    1190:	8b e2       	ldi	r24, 0x2B	; 43
    1192:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
			KeyPressed = WaitForKeypress();
    1196:	cb dd       	rcall	.-1130   	; 0xd2e <WaitForKeypress>
    1198:	ec 01       	movw	r28, r24
			Modifier = GetModifier();
    119a:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
    119e:	08 2f       	mov	r16, r24
			
			Modifier &= ~(HID_KEYBOARD_MODIFIER_LEFTSHIFT); //numbers are always lower-case (override user's shift key)
			
			TeachHIDKey(pgm_read_byte(&HIDNumbers[i]), KeyPressed, Modifier); //teach the hid keycode array about this key -- must be lowercase.
    11a0:	dd 27       	eor	r29, r29
    11a2:	f7 01       	movw	r30, r14
    11a4:	84 91       	lpm	r24, Z
    11a6:	40 2f       	mov	r20, r16
    11a8:	4d 7f       	andi	r20, 0xFD	; 253
    11aa:	be 01       	movw	r22, r28
    11ac:	cf dd       	rcall	.-1122   	; 0xd4c <TeachHIDKey>
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
    11ae:	02 fd       	sbrc	r16, 2
    11b0:	0f c0       	rjmp	.+30     	; 0x11d0 <Calibrate+0x1d6>
				TeachASCIIKey(pgm_read_byte(&ASCIINumbers[i]), KeyPressed, LOWER); // and the ascii array about this key
    11b2:	f5 01       	movw	r30, r10
    11b4:	84 91       	lpm	r24, Z
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    11b6:	fe 01       	movw	r30, r28
    11b8:	e7 5d       	subi	r30, 0xD7	; 215
    11ba:	f8 4f       	sbci	r31, 0xF8	; 248
    11bc:	80 83       	st	Z, r24
			
			TeachHIDKey(pgm_read_byte(&HIDNumbers[i]), KeyPressed, Modifier); //teach the hid keycode array about this key -- must be lowercase.
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				TeachASCIIKey(pgm_read_byte(&ASCIINumbers[i]), KeyPressed, LOWER); // and the ascii array about this key
				TeachASCIIKey(pgm_read_byte(&ASCIINumSymbols[i]),KeyPressed, UPPER); // and the symbols above the numbers on most typewriters, for asii (sd card) use only.
    11be:	f6 01       	movw	r30, r12
    11c0:	84 91       	lpm	r24, Z
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    11c2:	fe 01       	movw	r30, r28
    11c4:	e6 55       	subi	r30, 0x56	; 86
    11c6:	f9 4f       	sbci	r31, 0xF9	; 249
    11c8:	80 83       	st	Z, r24
			TeachHIDKey(pgm_read_byte(&HIDNumbers[i]), KeyPressed, Modifier); //teach the hid keycode array about this key -- must be lowercase.
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				TeachASCIIKey(pgm_read_byte(&ASCIINumbers[i]), KeyPressed, LOWER); // and the ascii array about this key
				TeachASCIIKey(pgm_read_byte(&ASCIINumSymbols[i]),KeyPressed, UPPER); // and the symbols above the numbers on most typewriters, for asii (sd card) use only.
				FnKeyCodeLookUpTable[KeyPressed] = (KEY_F1+i);			}
    11ca:	c6 59       	subi	r28, 0x96	; 150
    11cc:	d6 4f       	sbci	r29, 0xF6	; 246
    11ce:	18 83       	st	Y, r17
			
			USBSend(KEY_ENTER,LOWER);
    11d0:	60 e0       	ldi	r22, 0x00	; 0
    11d2:	88 e2       	ldi	r24, 0x28	; 40
    11d4:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    11d8:	ff ef       	ldi	r31, 0xFF	; 255
    11da:	ef 1a       	sub	r14, r31
    11dc:	ff 0a       	sbc	r15, r31
    11de:	2f ef       	ldi	r18, 0xFF	; 255
    11e0:	a2 1a       	sub	r10, r18
    11e2:	b2 0a       	sbc	r11, r18
    11e4:	8f ef       	ldi	r24, 0xFF	; 255
    11e6:	c8 1a       	sub	r12, r24
    11e8:	d8 0a       	sbc	r13, r24
    11ea:	1f 5f       	subi	r17, 0xFF	; 255
		
		USBSend(KEY_ENTER,LOWER);
	}

//--------TEACH NUMBER KEYS---------
	for (int i = 0; i <= 9; i ++){
    11ec:	14 34       	cpi	r17, 0x44	; 68
    11ee:	09 f0       	breq	.+2      	; 0x11f2 <Calibrate+0x1f8>
    11f0:	c9 cf       	rjmp	.-110    	; 0x1184 <Calibrate+0x18a>
			
			USBSend(KEY_ENTER,LOWER);
	}
	
//----TEACH F1, F11, F12
	USBSendString("F1");
    11f2:	86 ee       	ldi	r24, 0xE6	; 230
    11f4:	91 e0       	ldi	r25, 0x01	; 1
    11f6:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
	USBSend(KEY_TAB,LOWER);
    11fa:	60 e0       	ldi	r22, 0x00	; 0
    11fc:	8b e2       	ldi	r24, 0x2B	; 43
    11fe:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	KeyPressed = WaitForKeypress();
    1202:	95 dd       	rcall	.-1238   	; 0xd2e <WaitForKeypress>
	Modifier = GetModifier();
    1204:	ec 01       	movw	r28, r24
    1206:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
	TeachHIDKey(KEY_F1, KeyPressed, Modifier); 
    120a:	be 01       	movw	r22, r28
    120c:	77 27       	eor	r23, r23
    120e:	48 2f       	mov	r20, r24
    1210:	8a e3       	ldi	r24, 0x3A	; 58
    1212:	9c dd       	rcall	.-1224   	; 0xd4c <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
    1214:	60 e0       	ldi	r22, 0x00	; 0
    1216:	88 e2       	ldi	r24, 0x28	; 40
    1218:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
	USBSendString("F11");
    121c:	89 ee       	ldi	r24, 0xE9	; 233
    121e:	91 e0       	ldi	r25, 0x01	; 1
    1220:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
	USBSend(KEY_TAB,LOWER);
    1224:	60 e0       	ldi	r22, 0x00	; 0
    1226:	8b e2       	ldi	r24, 0x2B	; 43
	KeyPressed = WaitForKeypress();
    1228:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    122c:	80 dd       	rcall	.-1280   	; 0xd2e <WaitForKeypress>
	Modifier = GetModifier();
    122e:	ec 01       	movw	r28, r24
    1230:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
	TeachHIDKey(KEY_F11, KeyPressed, Modifier);
    1234:	be 01       	movw	r22, r28
    1236:	77 27       	eor	r23, r23
    1238:	48 2f       	mov	r20, r24
    123a:	84 e4       	ldi	r24, 0x44	; 68
    123c:	87 dd       	rcall	.-1266   	; 0xd4c <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
    123e:	60 e0       	ldi	r22, 0x00	; 0
    1240:	88 e2       	ldi	r24, 0x28	; 40
    1242:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
	USBSendString("F12");
    1246:	8d ee       	ldi	r24, 0xED	; 237
    1248:	91 e0       	ldi	r25, 0x01	; 1
    124a:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
	USBSend(KEY_TAB,LOWER);
    124e:	60 e0       	ldi	r22, 0x00	; 0
    1250:	8b e2       	ldi	r24, 0x2B	; 43
	KeyPressed = WaitForKeypress();
    1252:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    1256:	6b dd       	rcall	.-1322   	; 0xd2e <WaitForKeypress>
	Modifier = GetModifier();
    1258:	ec 01       	movw	r28, r24
    125a:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
	TeachHIDKey(KEY_F12, KeyPressed, Modifier);
    125e:	be 01       	movw	r22, r28
    1260:	77 27       	eor	r23, r23
    1262:	48 2f       	mov	r20, r24
    1264:	85 e4       	ldi	r24, 0x45	; 69
	USBSend(KEY_ENTER,LOWER);	
    1266:	72 dd       	rcall	.-1308   	; 0xd4c <TeachHIDKey>
    1268:	60 e0       	ldi	r22, 0x00	; 0
    126a:	88 e2       	ldi	r24, 0x28	; 40
    126c:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
//--------TEACH SHIFT KEY-----------
	USBSendString("SHIFT");
    1270:	8a ed       	ldi	r24, 0xDA	; 218
    1272:	91 e0       	ldi	r25, 0x01	; 1
    1274:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
	USBSend(KEY_TAB,LOWER);// used to be a colon
    1278:	60 e0       	ldi	r22, 0x00	; 0
    127a:	8b e2       	ldi	r24, 0x2B	; 43
    127c:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	KeyPressed = WaitForKeypress();
    1280:	56 dd       	rcall	.-1364   	; 0xd2e <WaitForKeypress>
	if((KeyPressed)&&(KeyPressed <= 8)){ //if keypressed is 1, 2, 3, or 4, it represents a reed switch being held down.
    1282:	9f ef       	ldi	r25, 0xFF	; 255
    1284:	98 0f       	add	r25, r24
    1286:	98 30       	cpi	r25, 0x08	; 8
    1288:	58 f4       	brcc	.+22     	; 0x12a0 <Calibrate+0x2a6>
		Shift_Reed = KeyPressed;
    128a:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <Shift_Reed>
		USBSendPROGString(Str_Reed);
    128e:	82 ea       	ldi	r24, 0xA2	; 162
    1290:	91 e0       	ldi	r25, 0x01	; 1
    1292:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
		USBSendNumber(Shift_Reed);
    1296:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <Shift_Reed>
    129a:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
    129e:	04 c0       	rjmp	.+8      	; 0x12a8 <Calibrate+0x2ae>
	}
	else{
		USBSendPROGString(Str_Shift_Error);
    12a0:	8a ed       	ldi	r24, 0xDA	; 218
    12a2:	94 e0       	ldi	r25, 0x04	; 4
    12a4:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
    12a8:	9f ef       	ldi	r25, 0xFF	; 255
    12aa:	e4 e3       	ldi	r30, 0x34	; 52
    12ac:	fc e0       	ldi	r31, 0x0C	; 12
    12ae:	91 50       	subi	r25, 0x01	; 1
    12b0:	e0 40       	sbci	r30, 0x00	; 0
    12b2:	f0 40       	sbci	r31, 0x00	; 0
    12b4:	e1 f7       	brne	.-8      	; 0x12ae <Calibrate+0x2b4>
    12b6:	00 c0       	rjmp	.+0      	; 0x12b8 <Calibrate+0x2be>
    12b8:	00 00       	nop
	}
	Delay_MS(CALIBRATION_DELAY);
	USBSend(KEY_ENTER,LOWER);
    12ba:	60 e0       	ldi	r22, 0x00	; 0
    12bc:	88 e2       	ldi	r24, 0x28	; 40
    12be:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
//----------TEACH SYMBOL KEYS------------	
	for (HIDKey = KEY_DASH; HIDKey <= KEY_SLASH; HIDKey ++){
    12c2:	1d e2       	ldi	r17, 0x2D	; 45
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    12c4:	0e e2       	ldi	r16, 0x2E	; 46
    12c6:	9c e2       	ldi	r25, 0x2C	; 44
    12c8:	d9 2e       	mov	r13, r25
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    12ca:	2f e3       	ldi	r18, 0x3F	; 63
    12cc:	f2 2e       	mov	r15, r18
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    12ce:	3f e2       	ldi	r19, 0x2F	; 47
    12d0:	c3 2e       	mov	r12, r19
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    12d2:	4a e2       	ldi	r20, 0x2A	; 42
    12d4:	b4 2e       	mov	r11, r20
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    12d6:	50 e6       	ldi	r21, 0x60	; 96
    12d8:	a5 2e       	mov	r10, r21
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    12da:	6e e7       	ldi	r22, 0x7E	; 126
    12dc:	96 2e       	mov	r9, r22
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    12de:	7d e3       	ldi	r23, 0x3D	; 61
    12e0:	87 2e       	mov	r8, r23
    12e2:	eb e3       	ldi	r30, 0x3B	; 59
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    12e4:	7e 2e       	mov	r7, r30
    12e6:	fa e3       	ldi	r31, 0x3A	; 58
	Delay_MS(CALIBRATION_DELAY);
	USBSend(KEY_ENTER,LOWER);
	
//----------TEACH SYMBOL KEYS------------	
	for (HIDKey = KEY_DASH; HIDKey <= KEY_SLASH; HIDKey ++){
			if (HIDKey != HID_KEYBOARD_SC_NON_US_HASHMARK_AND_TILDE){ //don't bother to program the non-us hash key, which is a weird and confusing key.
    12e8:	6f 2e       	mov	r6, r31
    12ea:	12 33       	cpi	r17, 0x32	; 50
    12ec:	09 f4       	brne	.+2      	; 0x12f0 <Calibrate+0x2f6>
			USBSend(HIDKey, LOWER);
    12ee:	5b c0       	rjmp	.+182    	; 0x13a6 <Calibrate+0x3ac>
    12f0:	60 e0       	ldi	r22, 0x00	; 0
    12f2:	81 2f       	mov	r24, r17
			USBSend(KEY_TAB,LOWER);// used to be a colon
    12f4:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    12f8:	60 e0       	ldi	r22, 0x00	; 0
    12fa:	8b e2       	ldi	r24, 0x2B	; 43
			KeyPressed = WaitForKeypress();
    12fc:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    1300:	16 dd       	rcall	.-1492   	; 0xd2e <WaitForKeypress>
			Modifier = GetModifier();
    1302:	ec 01       	movw	r28, r24
    1304:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
    1308:	e8 2e       	mov	r14, r24
			
			TeachHIDKey(HIDKey, KeyPressed, Modifier); //program these characters, including the modifer used when programming them.
    130a:	dd 27       	eor	r29, r29
    130c:	48 2f       	mov	r20, r24
    130e:	be 01       	movw	r22, r28
    1310:	81 2f       	mov	r24, r17
    1312:	1c dd       	rcall	.-1480   	; 0xd4c <TeachHIDKey>
			
			//some of these keys (but not all) are also used for the SD card mode:			
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
    1314:	e2 fc       	sbrc	r14, 2
    1316:	43 c0       	rjmp	.+134    	; 0x139e <Calibrate+0x3a4>
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
    1318:	13 33       	cpi	r17, 0x33	; 51
    131a:	41 f4       	brne	.+16     	; 0x132c <Calibrate+0x332>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    131c:	fe 01       	movw	r30, r28
    131e:	e7 5d       	subi	r30, 0xD7	; 215
    1320:	f8 4f       	sbci	r31, 0xF8	; 248
    1322:	70 82       	st	Z, r7
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1324:	c6 55       	subi	r28, 0x56	; 86
    1326:	d9 4f       	sbci	r29, 0xF9	; 249
    1328:	68 82       	st	Y, r6
    132a:	39 c0       	rjmp	.+114    	; 0x139e <Calibrate+0x3a4>
			
			//some of these keys (but not all) are also used for the SD card mode:			
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
    132c:	1e 32       	cpi	r17, 0x2E	; 46
    132e:	49 f4       	brne	.+18     	; 0x1342 <Calibrate+0x348>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1330:	fe 01       	movw	r30, r28
    1332:	e7 5d       	subi	r30, 0xD7	; 215
    1334:	f8 4f       	sbci	r31, 0xF8	; 248
    1336:	80 82       	st	Z, r8
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1338:	c6 55       	subi	r28, 0x56	; 86
    133a:	d9 4f       	sbci	r29, 0xF9	; 249
    133c:	8b e2       	ldi	r24, 0x2B	; 43
    133e:	88 83       	st	Y, r24
    1340:	2e c0       	rjmp	.+92     	; 0x139e <Calibrate+0x3a4>
			//some of these keys (but not all) are also used for the SD card mode:			
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
    1342:	15 33       	cpi	r17, 0x35	; 53
    1344:	41 f4       	brne	.+16     	; 0x1356 <Calibrate+0x35c>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1346:	fe 01       	movw	r30, r28
    1348:	e7 5d       	subi	r30, 0xD7	; 215
    134a:	f8 4f       	sbci	r31, 0xF8	; 248
    134c:	a0 82       	st	Z, r10
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    134e:	c6 55       	subi	r28, 0x56	; 86
    1350:	d9 4f       	sbci	r29, 0xF9	; 249
    1352:	98 82       	st	Y, r9
    1354:	24 c0       	rjmp	.+72     	; 0x139e <Calibrate+0x3a4>
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
				if(HIDKey == KEY_DASH){TeachASCIIKey('-', KeyPressed, LOWER); TeachASCIIKey('*', KeyPressed, UPPER);}
    1356:	1d 32       	cpi	r17, 0x2D	; 45
    1358:	41 f4       	brne	.+16     	; 0x136a <Calibrate+0x370>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    135a:	fe 01       	movw	r30, r28
    135c:	e7 5d       	subi	r30, 0xD7	; 215
    135e:	f8 4f       	sbci	r31, 0xF8	; 248
    1360:	10 83       	st	Z, r17
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1362:	c6 55       	subi	r28, 0x56	; 86
    1364:	d9 4f       	sbci	r29, 0xF9	; 249
    1366:	b8 82       	st	Y, r11
    1368:	1a c0       	rjmp	.+52     	; 0x139e <Calibrate+0x3a4>
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
				if(HIDKey == KEY_DASH){TeachASCIIKey('-', KeyPressed, LOWER); TeachASCIIKey('*', KeyPressed, UPPER);}
				if(HIDKey == KEY_SLASH){TeachASCIIKey('/', KeyPressed, LOWER);TeachASCIIKey('?', KeyPressed, UPPER);}
    136a:	18 33       	cpi	r17, 0x38	; 56
    136c:	29 f4       	brne	.+10     	; 0x1378 <Calibrate+0x37e>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    136e:	fe 01       	movw	r30, r28
    1370:	e7 5d       	subi	r30, 0xD7	; 215
    1372:	f8 4f       	sbci	r31, 0xF8	; 248
    1374:	c0 82       	st	Z, r12
    1376:	06 c0       	rjmp	.+12     	; 0x1384 <Calibrate+0x38a>
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
				if(HIDKey == KEY_DASH){TeachASCIIKey('-', KeyPressed, LOWER); TeachASCIIKey('*', KeyPressed, UPPER);}
				if(HIDKey == KEY_SLASH){TeachASCIIKey('/', KeyPressed, LOWER);TeachASCIIKey('?', KeyPressed, UPPER);}
				if(HIDKey == KEY_COMMA){TeachASCIIKey(',', KeyPressed, LOWER); TeachASCIIKey('?', KeyPressed, UPPER);}
    1378:	16 33       	cpi	r17, 0x36	; 54
    137a:	41 f4       	brne	.+16     	; 0x138c <Calibrate+0x392>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    137c:	fe 01       	movw	r30, r28
    137e:	e7 5d       	subi	r30, 0xD7	; 215
    1380:	f8 4f       	sbci	r31, 0xF8	; 248
    1382:	d0 82       	st	Z, r13
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1384:	c6 55       	subi	r28, 0x56	; 86
    1386:	d9 4f       	sbci	r29, 0xF9	; 249
    1388:	f8 82       	st	Y, r15
    138a:	09 c0       	rjmp	.+18     	; 0x139e <Calibrate+0x3a4>
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
				if(HIDKey == KEY_DASH){TeachASCIIKey('-', KeyPressed, LOWER); TeachASCIIKey('*', KeyPressed, UPPER);}
				if(HIDKey == KEY_SLASH){TeachASCIIKey('/', KeyPressed, LOWER);TeachASCIIKey('?', KeyPressed, UPPER);}
				if(HIDKey == KEY_COMMA){TeachASCIIKey(',', KeyPressed, LOWER); TeachASCIIKey('?', KeyPressed, UPPER);}
				if(HIDKey == KEY_PERIOD){TeachASCIIKey('.', KeyPressed, LOWER); TeachASCIIKey('.', KeyPressed, UPPER);}
    138c:	17 33       	cpi	r17, 0x37	; 55
    138e:	39 f4       	brne	.+14     	; 0x139e <Calibrate+0x3a4>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1390:	fe 01       	movw	r30, r28
    1392:	e7 5d       	subi	r30, 0xD7	; 215
    1394:	f8 4f       	sbci	r31, 0xF8	; 248
    1396:	00 83       	st	Z, r16
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1398:	c6 55       	subi	r28, 0x56	; 86
    139a:	d9 4f       	sbci	r29, 0xF9	; 249
    139c:	08 83       	st	Y, r16
				if(HIDKey == KEY_PERIOD){TeachASCIIKey('.', KeyPressed, LOWER); TeachASCIIKey('.', KeyPressed, UPPER);}
			}
			
			
				
			USBSend(KEY_ENTER,LOWER);
    139e:	60 e0       	ldi	r22, 0x00	; 0
    13a0:	88 e2       	ldi	r24, 0x28	; 40
    13a2:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	}
	Delay_MS(CALIBRATION_DELAY);
	USBSend(KEY_ENTER,LOWER);
	
//----------TEACH SYMBOL KEYS------------	
	for (HIDKey = KEY_DASH; HIDKey <= KEY_SLASH; HIDKey ++){
    13a6:	1f 5f       	subi	r17, 0xFF	; 255
    13a8:	19 33       	cpi	r17, 0x39	; 57
    13aa:	09 f0       	breq	.+2      	; 0x13ae <Calibrate+0x3b4>
    13ac:	9e cf       	rjmp	.-196    	; 0x12ea <Calibrate+0x2f0>
    13ae:	ce ef       	ldi	r28, 0xFE	; 254
    13b0:	d1 e0       	ldi	r29, 0x01	; 1
    13b2:	06 e0       	ldi	r16, 0x06	; 6
    13b4:	16 e0       	ldi	r17, 0x06	; 6
    13b6:	86 e0       	ldi	r24, 0x06	; 6
    13b8:	c8 2e       	mov	r12, r24
    13ba:	82 e0       	ldi	r24, 0x02	; 2
	
//=======TEACH ARROW KEYS========

	
for(uint8_t i=0;i<4;i++){
	USBSendPROGString(arrow_table[i]);
    13bc:	d8 2e       	mov	r13, r24
    13be:	89 91       	ld	r24, Y+
    13c0:	99 91       	ld	r25, Y+
	USBSend(KEY_TAB,LOWER);// used to be a colon
    13c2:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
    13c6:	60 e0       	ldi	r22, 0x00	; 0
    13c8:	8b e2       	ldi	r24, 0x2B	; 43
	KeyPressed = WaitForKeypress();
    13ca:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    13ce:	af dc       	rcall	.-1698   	; 0xd2e <WaitForKeypress>
	Modifier = GetModifier();
    13d0:	7c 01       	movw	r14, r24
    13d2:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
	TeachHIDKey(pgm_read_byte(&hid_arrows[i]),KeyPressed,Modifier);
    13d6:	48 2f       	mov	r20, r24
    13d8:	f8 01       	movw	r30, r16
    13da:	84 91       	lpm	r24, Z
    13dc:	b7 01       	movw	r22, r14
    13de:	77 27       	eor	r23, r23
	USBSend(KEY_ENTER,LOWER);
    13e0:	b5 dc       	rcall	.-1686   	; 0xd4c <TeachHIDKey>
    13e2:	60 e0       	ldi	r22, 0x00	; 0
    13e4:	88 e2       	ldi	r24, 0x28	; 40
    13e6:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    13ea:	0f 5f       	subi	r16, 0xFF	; 255
	}
	
//=======TEACH ARROW KEYS========

	
for(uint8_t i=0;i<4;i++){
    13ec:	1f 4f       	sbci	r17, 0xFF	; 255
    13ee:	cc 16       	cp	r12, r28
}


//-------TEACH VARIOUS UPPER CASE SYMBOLS ---------
	//!
	USBSend(KEY_1|FORCE_UPPER,UPPER);
    13f0:	dd 06       	cpc	r13, r29
    13f2:	29 f7       	brne	.-54     	; 0x13be <Calibrate+0x3c4>
    13f4:	62 e0       	ldi	r22, 0x02	; 2
	USBSend(KEY_TAB,LOWER);
    13f6:	8e e9       	ldi	r24, 0x9E	; 158
    13f8:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    13fc:	60 e0       	ldi	r22, 0x00	; 0
	KeyPressed = WaitForKeypress();
    13fe:	8b e2       	ldi	r24, 0x2B	; 43
    1400:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	Modifier = GetModifier();
    1404:	94 dc       	rcall	.-1752   	; 0xd2e <WaitForKeypress>
    1406:	ec 01       	movw	r28, r24
    1408:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>

	if(!(Modifier&FN_MODIFIER&UPPER)){ //don't bother dealing with complicated combinations of FN and Shift to produce an !
		TeachHIDKey(KEY_1|FORCE_UPPER,KeyPressed,Modifier);
    140c:	18 2f       	mov	r17, r24
    140e:	dd 27       	eor	r29, r29
    1410:	48 2f       	mov	r20, r24
    1412:	be 01       	movw	r22, r28
		TeachASCIIKey('!',KeyPressed,Modifier);
    1414:	8e e9       	ldi	r24, 0x9E	; 158
    1416:	9a dc       	rcall	.-1740   	; 0xd4c <TeachHIDKey>
    1418:	41 2f       	mov	r20, r17
    141a:	be 01       	movw	r22, r28
    141c:	81 e2       	ldi	r24, 0x21	; 33
	}
	
	USBSend(KEY_ENTER,LOWER);
    141e:	e0 dd       	rcall	.-1088   	; 0xfe0 <TeachASCIIKey>
    1420:	60 e0       	ldi	r22, 0x00	; 0
    1422:	88 e2       	ldi	r24, 0x28	; 40
    1424:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>


	//@ for sd
	USBSend(KEY_2,UPPER);
    1428:	62 e0       	ldi	r22, 0x02	; 2
    142a:	8f e1       	ldi	r24, 0x1F	; 31
    142c:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	USBSendPROGString(Str_SD_Only);
    1430:	81 ec       	ldi	r24, 0xC1	; 193
    1432:	94 e0       	ldi	r25, 0x04	; 4
    1434:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	KeyPressed = WaitForKeypress();
    1438:	7a dc       	rcall	.-1804   	; 0xd2e <WaitForKeypress>
    143a:	c8 2f       	mov	r28, r24
	Modifier = GetModifier();
    143c:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
	
		if(Modifier==HID_KEYBOARD_MODIFIER_LEFTSHIFT){
    1440:	82 30       	cpi	r24, 0x02	; 2
    1442:	41 f4       	brne	.+16     	; 0x1454 <Calibrate+0x45a>
			USBSendString("SHIFT");
    1444:	8a ed       	ldi	r24, 0xDA	; 218
    1446:	91 e0       	ldi	r25, 0x01	; 1
    1448:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
			USBSend(KEY_EQ,UPPER); //send a + sign
    144c:	62 e0       	ldi	r22, 0x02	; 2
    144e:	8e e2       	ldi	r24, 0x2E	; 46
    1450:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
		}
	USBSendNumber(KeyPressed);
    1454:	8c 2f       	mov	r24, r28
    1456:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    145a:	60 e0       	ldi	r22, 0x00	; 0
    145c:	88 e2       	ldi	r24, 0x28	; 40
    145e:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    1462:	ff ef       	ldi	r31, 0xFF	; 255
    1464:	24 e3       	ldi	r18, 0x34	; 52
    1466:	8c e0       	ldi	r24, 0x0C	; 12
    1468:	f1 50       	subi	r31, 0x01	; 1
    146a:	20 40       	sbci	r18, 0x00	; 0
    146c:	80 40       	sbci	r24, 0x00	; 0
    146e:	e1 f7       	brne	.-8      	; 0x1468 <Calibrate+0x46e>
	
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
	
	//@ for usb
	USBSend(KEY_2,UPPER);
    1470:	00 c0       	rjmp	.+0      	; 0x1472 <Calibrate+0x478>
    1472:	00 00       	nop
    1474:	62 e0       	ldi	r22, 0x02	; 2
    1476:	8f e1       	ldi	r24, 0x1F	; 31
	USBSendPROGString(Str_USB_Only);
    1478:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    147c:	86 ea       	ldi	r24, 0xA6	; 166
	KeyPressed = WaitForKeypress();
    147e:	94 e0       	ldi	r25, 0x04	; 4
    1480:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	Modifier = GetModifier();
    1484:	54 dc       	rcall	.-1880   	; 0xd2e <WaitForKeypress>
    1486:	ec 01       	movw	r28, r24

	TeachHIDKey(KEY_2|FORCE_UPPER,KeyPressed,Modifier);
    1488:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
    148c:	be 01       	movw	r22, r28
    148e:	77 27       	eor	r23, r23
    1490:	48 2f       	mov	r20, r24
	USBSend(KEY_ENTER,LOWER);
    1492:	8f e9       	ldi	r24, 0x9F	; 159
    1494:	5b dc       	rcall	.-1866   	; 0xd4c <TeachHIDKey>
    1496:	60 e0       	ldi	r22, 0x00	; 0
    1498:	88 e2       	ldi	r24, 0x28	; 40
	
	//?
	USBSend(KEY_SLASH,UPPER);
    149a:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    149e:	62 e0       	ldi	r22, 0x02	; 2
    14a0:	88 e3       	ldi	r24, 0x38	; 56
	USBSendPROGString(Str_SD_Only);
    14a2:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    14a6:	81 ec       	ldi	r24, 0xC1	; 193
    14a8:	94 e0       	ldi	r25, 0x04	; 4
	KeyPressed = WaitForKeypress();
    14aa:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
    14ae:	3f dc       	rcall	.-1922   	; 0xd2e <WaitForKeypress>
	Modifier = GetModifier();
    14b0:	ec 01       	movw	r28, r24
    14b2:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
	TeachASCIIKey('?',KeyPressed,Modifier);
    14b6:	18 2f       	mov	r17, r24
    14b8:	be 01       	movw	r22, r28
    14ba:	77 27       	eor	r23, r23
    14bc:	48 2f       	mov	r20, r24
    14be:	8f e3       	ldi	r24, 0x3F	; 63
    14c0:	8f dd       	rcall	.-1250   	; 0xfe0 <TeachASCIIKey>
	if(Modifier==HID_KEYBOARD_MODIFIER_LEFTSHIFT){
    14c2:	12 30       	cpi	r17, 0x02	; 2
    14c4:	41 f4       	brne	.+16     	; 0x14d6 <Calibrate+0x4dc>
		USBSendString("SHIFT");
    14c6:	8a ed       	ldi	r24, 0xDA	; 218
    14c8:	91 e0       	ldi	r25, 0x01	; 1
    14ca:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
		USBSend(KEY_EQ,UPPER); //send a + sign
    14ce:	62 e0       	ldi	r22, 0x02	; 2
    14d0:	8e e2       	ldi	r24, 0x2E	; 46
    14d2:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	}
	USBSendNumber(KeyPressed);
    14d6:	8c 2f       	mov	r24, r28
    14d8:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    14dc:	60 e0       	ldi	r22, 0x00	; 0
    14de:	88 e2       	ldi	r24, 0x28	; 40
    14e0:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    14e4:	9f ef       	ldi	r25, 0xFF	; 255
    14e6:	e4 e3       	ldi	r30, 0x34	; 52
    14e8:	fc e0       	ldi	r31, 0x0C	; 12
    14ea:	91 50       	subi	r25, 0x01	; 1
    14ec:	e0 40       	sbci	r30, 0x00	; 0
	
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
	
//for USB

	USBSend(KEY_SLASH,UPPER);
    14ee:	f0 40       	sbci	r31, 0x00	; 0
    14f0:	e1 f7       	brne	.-8      	; 0x14ea <Calibrate+0x4f0>
    14f2:	00 c0       	rjmp	.+0      	; 0x14f4 <Calibrate+0x4fa>
    14f4:	00 00       	nop
	USBSendPROGString(Str_USB_Only);
    14f6:	62 e0       	ldi	r22, 0x02	; 2
    14f8:	88 e3       	ldi	r24, 0x38	; 56
    14fa:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	KeyPressed = WaitForKeypress();
    14fe:	86 ea       	ldi	r24, 0xA6	; 166
    1500:	94 e0       	ldi	r25, 0x04	; 4
    1502:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	Modifier = GetModifier();
    1506:	13 dc       	rcall	.-2010   	; 0xd2e <WaitForKeypress>

	TeachHIDKey(KEY_SLASH|FORCE_UPPER,KeyPressed,Modifier);
    1508:	ec 01       	movw	r28, r24
    150a:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
    150e:	be 01       	movw	r22, r28
    1510:	77 27       	eor	r23, r23
    1512:	48 2f       	mov	r20, r24
	USBSend(KEY_ENTER,LOWER);
    1514:	88 eb       	ldi	r24, 0xB8	; 184
    1516:	1a dc       	rcall	.-1996   	; 0xd4c <TeachHIDKey>
    1518:	60 e0       	ldi	r22, 0x00	; 0
    151a:	88 e2       	ldi	r24, 0x28	; 40
	

	
	
//------TEACH REED SWITCHES--------//
	CalibrateReeds();
    151c:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	
	SaveCalibration();
    1520:	4a dc       	rcall	.-1900   	; 0xdb6 <CalibrateReeds>
    1522:	5e db       	rcall	.-2372   	; 0xbe0 <SaveCalibration>
	
	USBSendPROGString(Str_Settings_Saved);
    1524:	8e ea       	ldi	r24, 0xAE	; 174
    1526:	92 e0       	ldi	r25, 0x02	; 2
	
}
    1528:	df 91       	pop	r29
    152a:	cf 91       	pop	r28
    152c:	1f 91       	pop	r17
    152e:	0f 91       	pop	r16
    1530:	ff 90       	pop	r15
    1532:	ef 90       	pop	r14
    1534:	df 90       	pop	r13
    1536:	cf 90       	pop	r12
    1538:	bf 90       	pop	r11
    153a:	af 90       	pop	r10
    153c:	9f 90       	pop	r9
    153e:	8f 90       	pop	r8
    1540:	7f 90       	pop	r7
    1542:	6f 90       	pop	r6
//------TEACH REED SWITCHES--------//
	CalibrateReeds();
	
	SaveCalibration();
	
	USBSendPROGString(Str_Settings_Saved);
    1544:	0c 94 8d 2a 	jmp	0x551a	; 0x551a <USBSendPROGString>

00001548 <Adjust_Sensitivity>:
	else{
		ASCIILookUpTable[keypressed] = teachkey;
	}
}

void Adjust_Sensitivity(){
    1548:	cf 93       	push	r28
	KeyHoldTime = eeprom_read_byte((uint8_t*)HOLD_TIME_ADDR);
    154a:	81 e0       	ldi	r24, 0x01	; 1
    154c:	92 e0       	ldi	r25, 0x02	; 2
    154e:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    1552:	80 93 a9 06 	sts	0x06A9, r24	; 0x8006a9 <KeyHoldTime>
	KeyReleaseTime = eeprom_read_byte((uint8_t*)RELEASE_TIME_ADDR);
    1556:	82 e0       	ldi	r24, 0x02	; 2
    1558:	92 e0       	ldi	r25, 0x02	; 2
    155a:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    155e:	80 93 1a 06 	sts	0x061A, r24	; 0x80061a <KeyReleaseTime>
	DoubleTapTime= eeprom_read_byte((uint8_t*)DOUBLE_TAP_ADDR);
    1562:	80 e0       	ldi	r24, 0x00	; 0
    1564:	92 e0       	ldi	r25, 0x02	; 2
    1566:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    156a:	80 93 5d 06 	sts	0x065D, r24	; 0x80065d <DoubleTapTime>
	
	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
    156e:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    1572:	84 30       	cpi	r24, 0x04	; 4
    1574:	e1 f7       	brne	.-8      	; 0x156e <Adjust_Sensitivity+0x26>
    1576:	2f ef       	ldi	r18, 0xFF	; 255
    1578:	89 e6       	ldi	r24, 0x69	; 105
    157a:	98 e1       	ldi	r25, 0x18	; 24
    157c:	21 50       	subi	r18, 0x01	; 1
    157e:	80 40       	sbci	r24, 0x00	; 0
    1580:	90 40       	sbci	r25, 0x00	; 0
    1582:	e1 f7       	brne	.-8      	; 0x157c <Adjust_Sensitivity+0x34>
    1584:	00 c0       	rjmp	.+0      	; 0x1586 <Adjust_Sensitivity+0x3e>
    1586:	00 00       	nop
	Delay_MS(1000);//wait 1 second.
	
	USBSendPROGString(Str_Adj_Sensitivity);
    1588:	83 ea       	ldi	r24, 0xA3	; 163
    158a:	93 e0       	ldi	r25, 0x03	; 3
    158c:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSendPROGString(Str_Press_CMD);
    1590:	85 e8       	ldi	r24, 0x85	; 133
    1592:	93 e0       	ldi	r25, 0x03	; 3
    1594:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	while(is_high(S3)){;}
    1598:	7e 99       	sbic	0x0f, 6	; 15
    159a:	fe cf       	rjmp	.-4      	; 0x1598 <Adjust_Sensitivity+0x50>
	
	USBSendPROGString(Str_Set_Reaction_Time);
    159c:	85 e5       	ldi	r24, 0x55	; 85
    159e:	93 e0       	ldi	r25, 0x03	; 3
    15a0:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSendNumber(KeyHoldTime);
    15a4:	80 91 a9 06 	lds	r24, 0x06A9	; 0x8006a9 <KeyHoldTime>
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
		if(is_low(S1)){KeyHoldTime++;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){KeyHoldTime--;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
    15a8:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
    15ac:	60 e0       	ldi	r22, 0x00	; 0
    15ae:	88 e2       	ldi	r24, 0x28	; 40
    15b0:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	while(is_high(S3)){;}
	
	USBSendPROGString(Str_Set_Reaction_Time);
	USBSendNumber(KeyHoldTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    15b4:	7e 9b       	sbis	0x0f, 6	; 15
    15b6:	15 c0       	rjmp	.+42     	; 0x15e2 <Adjust_Sensitivity+0x9a>
		if(is_low(S1)){KeyHoldTime++;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
    15b8:	7c 99       	sbic	0x0f, 4	; 15
    15ba:	0b c0       	rjmp	.+22     	; 0x15d2 <Adjust_Sensitivity+0x8a>
    15bc:	80 91 a9 06 	lds	r24, 0x06A9	; 0x8006a9 <KeyHoldTime>
    15c0:	8f 5f       	subi	r24, 0xFF	; 255
    15c2:	80 93 a9 06 	sts	0x06A9, r24	; 0x8006a9 <KeyHoldTime>
    15c6:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
    15ca:	60 e0       	ldi	r22, 0x00	; 0
    15cc:	88 e2       	ldi	r24, 0x28	; 40
    15ce:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
		if(is_low(S2)){KeyHoldTime--;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
    15d2:	7d 99       	sbic	0x0f, 5	; 15
    15d4:	ef cf       	rjmp	.-34     	; 0x15b4 <Adjust_Sensitivity+0x6c>
    15d6:	80 91 a9 06 	lds	r24, 0x06A9	; 0x8006a9 <KeyHoldTime>
    15da:	81 50       	subi	r24, 0x01	; 1
    15dc:	80 93 a9 06 	sts	0x06A9, r24	; 0x8006a9 <KeyHoldTime>
    15e0:	e3 cf       	rjmp	.-58     	; 0x15a8 <Adjust_Sensitivity+0x60>
	}
	
	USBSendPROGString(Str_Set_Release_Time);
    15e2:	87 e3       	ldi	r24, 0x37	; 55
    15e4:	93 e0       	ldi	r25, 0x03	; 3
    15e6:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSendNumber(KeyReleaseTime);
    15ea:	80 91 1a 06 	lds	r24, 0x061A	; 0x80061a <KeyReleaseTime>
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
		if(is_low(S1)){KeyReleaseTime++;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){KeyReleaseTime--;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
    15ee:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
    15f2:	60 e0       	ldi	r22, 0x00	; 0
    15f4:	88 e2       	ldi	r24, 0x28	; 40
    15f6:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	}
	
	USBSendPROGString(Str_Set_Release_Time);
	USBSendNumber(KeyReleaseTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    15fa:	7e 9b       	sbis	0x0f, 6	; 15
    15fc:	15 c0       	rjmp	.+42     	; 0x1628 <Adjust_Sensitivity+0xe0>
		if(is_low(S1)){KeyReleaseTime++;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
    15fe:	7c 99       	sbic	0x0f, 4	; 15
    1600:	0b c0       	rjmp	.+22     	; 0x1618 <Adjust_Sensitivity+0xd0>
    1602:	80 91 1a 06 	lds	r24, 0x061A	; 0x80061a <KeyReleaseTime>
    1606:	8f 5f       	subi	r24, 0xFF	; 255
    1608:	80 93 1a 06 	sts	0x061A, r24	; 0x80061a <KeyReleaseTime>
    160c:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
    1610:	60 e0       	ldi	r22, 0x00	; 0
    1612:	88 e2       	ldi	r24, 0x28	; 40
    1614:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
		if(is_low(S2)){KeyReleaseTime--;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
    1618:	7d 99       	sbic	0x0f, 5	; 15
    161a:	ef cf       	rjmp	.-34     	; 0x15fa <Adjust_Sensitivity+0xb2>
    161c:	80 91 1a 06 	lds	r24, 0x061A	; 0x80061a <KeyReleaseTime>
    1620:	81 50       	subi	r24, 0x01	; 1
    1622:	80 93 1a 06 	sts	0x061A, r24	; 0x80061a <KeyReleaseTime>
    1626:	e3 cf       	rjmp	.-58     	; 0x15ee <Adjust_Sensitivity+0xa6>
	}
	
	USBSendPROGString(Str_Set_Double_Time);
    1628:	89 e0       	ldi	r24, 0x09	; 9
    162a:	93 e0       	ldi	r25, 0x03	; 3
    162c:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSendNumber(DoubleTapTime);
    1630:	80 91 5d 06 	lds	r24, 0x065D	; 0x80065d <DoubleTapTime>
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
		if(is_low(S1)){DoubleTapTime++;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){DoubleTapTime--;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
    1634:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
    1638:	60 e0       	ldi	r22, 0x00	; 0
    163a:	88 e2       	ldi	r24, 0x28	; 40
    163c:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	}
	
	USBSendPROGString(Str_Set_Double_Time);
	USBSendNumber(DoubleTapTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    1640:	7e 9b       	sbis	0x0f, 6	; 15
    1642:	15 c0       	rjmp	.+42     	; 0x166e <Adjust_Sensitivity+0x126>
		if(is_low(S1)){DoubleTapTime++;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
    1644:	7c 99       	sbic	0x0f, 4	; 15
    1646:	0b c0       	rjmp	.+22     	; 0x165e <Adjust_Sensitivity+0x116>
    1648:	80 91 5d 06 	lds	r24, 0x065D	; 0x80065d <DoubleTapTime>
    164c:	8f 5f       	subi	r24, 0xFF	; 255
    164e:	80 93 5d 06 	sts	0x065D, r24	; 0x80065d <DoubleTapTime>
    1652:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
    1656:	60 e0       	ldi	r22, 0x00	; 0
    1658:	88 e2       	ldi	r24, 0x28	; 40
    165a:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
		if(is_low(S2)){DoubleTapTime--;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
    165e:	7d 99       	sbic	0x0f, 5	; 15
    1660:	ef cf       	rjmp	.-34     	; 0x1640 <Adjust_Sensitivity+0xf8>
    1662:	80 91 5d 06 	lds	r24, 0x065D	; 0x80065d <DoubleTapTime>
    1666:	81 50       	subi	r24, 0x01	; 1
    1668:	80 93 5d 06 	sts	0x065D, r24	; 0x80065d <DoubleTapTime>
    166c:	e3 cf       	rjmp	.-58     	; 0x1634 <Adjust_Sensitivity+0xec>
	}
	
	USBSendPROGString(Str_Set_Reed_Time);
    166e:	89 ee       	ldi	r24, 0xE9	; 233
    1670:	92 e0       	ldi	r25, 0x02	; 2
    1672:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSendNumber(ReedHoldTime);
    1676:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <ReedHoldTime>
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
		if(is_low(S1)){ReedHoldTime++;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
    167a:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
    167e:	60 e0       	ldi	r22, 0x00	; 0
    1680:	88 e2       	ldi	r24, 0x28	; 40
    1682:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	}
	
	USBSendPROGString(Str_Set_Reed_Time);
	USBSendNumber(ReedHoldTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    1686:	7e 9b       	sbis	0x0f, 6	; 15
    1688:	15 c0       	rjmp	.+42     	; 0x16b4 <Adjust_Sensitivity+0x16c>
		if(is_low(S1)){ReedHoldTime++;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
    168a:	7c 99       	sbic	0x0f, 4	; 15
    168c:	0b c0       	rjmp	.+22     	; 0x16a4 <Adjust_Sensitivity+0x15c>
    168e:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <ReedHoldTime>
    1692:	8f 5f       	subi	r24, 0xFF	; 255
    1694:	80 93 5c 06 	sts	0x065C, r24	; 0x80065c <ReedHoldTime>
    1698:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
    169c:	60 e0       	ldi	r22, 0x00	; 0
    169e:	88 e2       	ldi	r24, 0x28	; 40
    16a0:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
    16a4:	7d 99       	sbic	0x0f, 5	; 15
    16a6:	ef cf       	rjmp	.-34     	; 0x1686 <Adjust_Sensitivity+0x13e>
    16a8:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <ReedHoldTime>
    16ac:	81 50       	subi	r24, 0x01	; 1
    16ae:	80 93 5c 06 	sts	0x065C, r24	; 0x80065c <ReedHoldTime>
    16b2:	e3 cf       	rjmp	.-58     	; 0x167a <Adjust_Sensitivity+0x132>
	}	
	
	USBSendPROGString(Str_Spacebar_Blocks_Enter);
    16b4:	8f eb       	ldi	r24, 0xBF	; 191
    16b6:	92 e0       	ldi	r25, 0x02	; 2
    16b8:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	Reeds_Are_Independent ? USBSendString("NO\r") : USBSendString("YES\r");
    16bc:	80 91 18 06 	lds	r24, 0x0618	; 0x800618 <Reeds_Are_Independent>
    16c0:	88 23       	and	r24, r24
    16c2:	19 f0       	breq	.+6      	; 0x16ca <Adjust_Sensitivity+0x182>
    16c4:	81 ef       	ldi	r24, 0xF1	; 241
    16c6:	91 e0       	ldi	r25, 0x01	; 1
    16c8:	02 c0       	rjmp	.+4      	; 0x16ce <Adjust_Sensitivity+0x186>
    16ca:	85 ef       	ldi	r24, 0xF5	; 245
    16cc:	91 e0       	ldi	r25, 0x01	; 1
    16ce:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
	while(is_high(S3)){
		if(is_low(S1)){Reeds_Are_Independent = false; USBSendString("YES\r");}
		if(is_low(S2)){Reeds_Are_Independent = true; USBSendString("NO\r");}
    16d2:	c1 e0       	ldi	r28, 0x01	; 1
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
	}	
	
	USBSendPROGString(Str_Spacebar_Blocks_Enter);
	Reeds_Are_Independent ? USBSendString("NO\r") : USBSendString("YES\r");
	while(is_high(S3)){
    16d4:	7e 9b       	sbis	0x0f, 6	; 15
    16d6:	15 c0       	rjmp	.+42     	; 0x1702 <Adjust_Sensitivity+0x1ba>
		if(is_low(S1)){Reeds_Are_Independent = false; USBSendString("YES\r");}
    16d8:	7c 99       	sbic	0x0f, 4	; 15
    16da:	06 c0       	rjmp	.+12     	; 0x16e8 <Adjust_Sensitivity+0x1a0>
    16dc:	10 92 18 06 	sts	0x0618, r1	; 0x800618 <Reeds_Are_Independent>
    16e0:	85 ef       	ldi	r24, 0xF5	; 245
    16e2:	91 e0       	ldi	r25, 0x01	; 1
    16e4:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
		if(is_low(S2)){Reeds_Are_Independent = true; USBSendString("NO\r");}
    16e8:	7d 99       	sbic	0x0f, 5	; 15
    16ea:	06 c0       	rjmp	.+12     	; 0x16f8 <Adjust_Sensitivity+0x1b0>
    16ec:	c0 93 18 06 	sts	0x0618, r28	; 0x800618 <Reeds_Are_Independent>
    16f0:	81 ef       	ldi	r24, 0xF1	; 241
    16f2:	91 e0       	ldi	r25, 0x01	; 1
    16f4:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
		while(is_low(S1)||is_low(S2)){;}//wait until one of the switches is released before looping.
    16f8:	7c 9b       	sbis	0x0f, 4	; 15
    16fa:	fe cf       	rjmp	.-4      	; 0x16f8 <Adjust_Sensitivity+0x1b0>
    16fc:	7d 9b       	sbis	0x0f, 5	; 15
    16fe:	fc cf       	rjmp	.-8      	; 0x16f8 <Adjust_Sensitivity+0x1b0>
    1700:	e9 cf       	rjmp	.-46     	; 0x16d4 <Adjust_Sensitivity+0x18c>
	}
	
	eeprom_update_byte((uint8_t*)DOUBLE_TAP_ADDR,DoubleTapTime);
    1702:	60 91 5d 06 	lds	r22, 0x065D	; 0x80065d <DoubleTapTime>
    1706:	80 e0       	ldi	r24, 0x00	; 0
    1708:	92 e0       	ldi	r25, 0x02	; 2
    170a:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)RELEASE_TIME_ADDR,KeyReleaseTime);
    170e:	60 91 1a 06 	lds	r22, 0x061A	; 0x80061a <KeyReleaseTime>
    1712:	82 e0       	ldi	r24, 0x02	; 2
    1714:	92 e0       	ldi	r25, 0x02	; 2
    1716:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)HOLD_TIME_ADDR,KeyHoldTime);
    171a:	60 91 a9 06 	lds	r22, 0x06A9	; 0x8006a9 <KeyHoldTime>
    171e:	81 e0       	ldi	r24, 0x01	; 1
    1720:	92 e0       	ldi	r25, 0x02	; 2
    1722:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)REED_HOLD_TIME_ADDR,ReedHoldTime);
    1726:	60 91 5c 06 	lds	r22, 0x065C	; 0x80065c <ReedHoldTime>
    172a:	8c e0       	ldi	r24, 0x0C	; 12
    172c:	92 e0       	ldi	r25, 0x02	; 2
    172e:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)REEDS_INDEPENDENT_ADDR,Reeds_Are_Independent);
    1732:	60 91 18 06 	lds	r22, 0x0618	; 0x800618 <Reeds_Are_Independent>
    1736:	8e e0       	ldi	r24, 0x0E	; 14
    1738:	92 e0       	ldi	r25, 0x02	; 2
    173a:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
	
	USBSendPROGString(Str_Settings_Saved);
    173e:	8e ea       	ldi	r24, 0xAE	; 174
    1740:	92 e0       	ldi	r25, 0x02	; 2
}
    1742:	cf 91       	pop	r28
	eeprom_update_byte((uint8_t*)RELEASE_TIME_ADDR,KeyReleaseTime);
	eeprom_update_byte((uint8_t*)HOLD_TIME_ADDR,KeyHoldTime);
	eeprom_update_byte((uint8_t*)REED_HOLD_TIME_ADDR,ReedHoldTime);
	eeprom_update_byte((uint8_t*)REEDS_INDEPENDENT_ADDR,Reeds_Are_Independent);
	
	USBSendPROGString(Str_Settings_Saved);
    1744:	0c 94 8d 2a 	jmp	0x551a	; 0x551a <USBSendPROGString>

00001748 <Get_User_Response>:
}

char Get_User_Response(){
	uint8_t code;
	while(1){
		code = WaitForKeypress();
    1748:	f2 da       	rcall	.-2588   	; 0xd2e <WaitForKeypress>
		if ((ASCIILookUpTable[code]	== 'u')||(ASCIILookUpTable[code]	== 's')){
    174a:	fc 01       	movw	r30, r24
    174c:	ff 27       	eor	r31, r31
    174e:	e7 5d       	subi	r30, 0xD7	; 215
    1750:	f8 4f       	sbci	r31, 0xF8	; 248
    1752:	80 81       	ld	r24, Z
    1754:	85 37       	cpi	r24, 0x75	; 117
    1756:	11 f0       	breq	.+4      	; 0x175c <Get_User_Response+0x14>
    1758:	83 37       	cpi	r24, 0x73	; 115
    175a:	b1 f7       	brne	.-20     	; 0x1748 <Get_User_Response>
			break;
		}
	}
	return ASCIILookUpTable[code];
}
    175c:	08 95       	ret

0000175e <Calibrate_Manually>:
		USBSendASCII(code);\
	}\
}


void Calibrate_Manually(){
    175e:	9f 92       	push	r9
    1760:	af 92       	push	r10
    1762:	bf 92       	push	r11
    1764:	cf 92       	push	r12
    1766:	df 92       	push	r13
    1768:	ef 92       	push	r14
    176a:	ff 92       	push	r15
    176c:	0f 93       	push	r16
    176e:	1f 93       	push	r17
    1770:	cf 93       	push	r28
    1772:	df 93       	push	r29
	uint8_t codeend2;
	uint8_t keypressed;
	uint8_t modifier;
	char edit_mode = 's';
	
	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
    1774:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    1778:	84 30       	cpi	r24, 0x04	; 4
    177a:	e1 f7       	brne	.-8      	; 0x1774 <Calibrate_Manually+0x16>
    177c:	2f ef       	ldi	r18, 0xFF	; 255
    177e:	89 e6       	ldi	r24, 0x69	; 105
    1780:	98 e1       	ldi	r25, 0x18	; 24
    1782:	21 50       	subi	r18, 0x01	; 1
    1784:	80 40       	sbci	r24, 0x00	; 0
    1786:	90 40       	sbci	r25, 0x00	; 0
    1788:	e1 f7       	brne	.-8      	; 0x1782 <Calibrate_Manually+0x24>
    178a:	00 c0       	rjmp	.+0      	; 0x178c <Calibrate_Manually+0x2e>
    178c:	00 00       	nop
	Delay_MS(1000);
		
	//tell user what is up
	USBSendPROGString(Str_Manual_Calibration);
    178e:	82 e9       	ldi	r24, 0x92	; 146
    1790:	92 e0       	ldi	r25, 0x02	; 2
    1792:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSendPROGString(Str_U_For_USB);
    1796:	81 e6       	ldi	r24, 0x61	; 97
    1798:	92 e0       	ldi	r25, 0x02	; 2
    179a:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSendPROGString(Str_S_For_SD);
    179e:	84 e3       	ldi	r24, 0x34	; 52
    17a0:	92 e0       	ldi	r25, 0x02	; 2
    17a2:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	edit_mode = Get_User_Response();
    17a6:	d0 df       	rcall	.-96     	; 0x1748 <Get_User_Response>
    17a8:	08 2f       	mov	r16, r24
	USBSendString("OK\r");
    17aa:	8a ef       	ldi	r24, 0xFA	; 250
    17ac:	91 e0       	ldi	r25, 0x01	; 1
    17ae:	0e 94 10 2a 	call	0x5420	; 0x5420 <USBSendString>
	USBSendPROGString(Str_How_To_Scroll);
    17b2:	86 e0       	ldi	r24, 0x06	; 6
    17b4:	92 e0       	ldi	r25, 0x02	; 2
    17b6:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSendPROGString(Str_How_To_Scroll_Back);
    17ba:	8c ed       	ldi	r24, 0xDC	; 220
    17bc:	91 e0       	ldi	r25, 0x01	; 1
    17be:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	USBSendPROGString(Str_How_To_Exit);
    17c2:	8e ea       	ldi	r24, 0xAE	; 174
    17c4:	91 e0       	ldi	r25, 0x01	; 1
    17c6:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
	
	//set ranges of ascii/hid codes over which to calibrate.  there are two ranges.
	if(edit_mode == 'u'){
    17ca:	05 37       	cpi	r16, 0x75	; 117
    17cc:	09 f0       	breq	.+2      	; 0x17d0 <Calibrate_Manually+0x72>
    17ce:	2c c1       	rjmp	.+600    	; 0x1a28 <Calibrate_Manually+0x2ca>
		codestart2 = 153;
		codeend2 = 0xFF;
	}
	
	code = codestart1;
	if (edit_mode == 'u'){USBSend(code,LOWER);}
    17d0:	60 e0       	ldi	r22, 0x00	; 0
    17d2:	8d e2       	ldi	r24, 0x2D	; 45
    17d4:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
	//set ranges of ascii/hid codes over which to calibrate.  there are two ranges.
	if(edit_mode == 'u'){
		codestart1 = 0x2D;
		codeend1 = 0x38;
		codestart2 = 0x1E|FORCE_UPPER;
		codeend2 = 0x38|FORCE_UPPER;
    17d8:	98 eb       	ldi	r25, 0xB8	; 184
    17da:	99 2e       	mov	r9, r25
	
	//set ranges of ascii/hid codes over which to calibrate.  there are two ranges.
	if(edit_mode == 'u'){
		codestart1 = 0x2D;
		codeend1 = 0x38;
		codestart2 = 0x1E|FORCE_UPPER;
    17dc:	1e e9       	ldi	r17, 0x9E	; 158
	USBSendPROGString(Str_How_To_Exit);
	
	//set ranges of ascii/hid codes over which to calibrate.  there are two ranges.
	if(edit_mode == 'u'){
		codestart1 = 0x2D;
		codeend1 = 0x38;
    17de:	28 e3       	ldi	r18, 0x38	; 56
    17e0:	e2 2e       	mov	r14, r18
	USBSendPROGString(Str_How_To_Scroll_Back);
	USBSendPROGString(Str_How_To_Exit);
	
	//set ranges of ascii/hid codes over which to calibrate.  there are two ranges.
	if(edit_mode == 'u'){
		codestart1 = 0x2D;
    17e2:	dd e2       	ldi	r29, 0x2D	; 45
	code = codestart1;
	if (edit_mode == 'u'){USBSend(code,LOWER);}
	else {USBSendASCII(code);}
	
	while(1){			
			keypressed = WaitForKeypress();
    17e4:	cd 2f       	mov	r28, r29
    17e6:	a3 da       	rcall	.-2746   	; 0xd2e <WaitForKeypress>
    17e8:	5c 01       	movw	r10, r24
			modifier = GetModifier();
    17ea:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
    17ee:	f8 2e       	mov	r15, r24
    17f0:	65 01       	movw	r12, r10
    17f2:	dd 24       	eor	r13, r13
			if(KeyCodeLookUpTable[keypressed]!=KEY_SPACE){//if the key pressed is not spacebar, program the code -- otherwise skip to next line
    17f4:	f6 01       	movw	r30, r12
    17f6:	e4 5e       	subi	r30, 0xE4	; 228
    17f8:	f9 4f       	sbci	r31, 0xF9	; 249
    17fa:	80 81       	ld	r24, Z
    17fc:	8c 32       	cpi	r24, 0x2C	; 44
    17fe:	09 f4       	brne	.+2      	; 0x1802 <Calibrate_Manually+0xa4>
    1800:	72 c0       	rjmp	.+228    	; 0x18e6 <Calibrate_Manually+0x188>
				if (edit_mode == 'u'){
    1802:	05 37       	cpi	r16, 0x75	; 117
    1804:	29 f4       	brne	.+10     	; 0x1810 <Calibrate_Manually+0xb2>
					TeachHIDKey(code,keypressed,modifier);
    1806:	4f 2d       	mov	r20, r15
    1808:	b6 01       	movw	r22, r12
    180a:	8c 2f       	mov	r24, r28
    180c:	9f da       	rcall	.-2754   	; 0xd4c <TeachHIDKey>
    180e:	19 c0       	rjmp	.+50     	; 0x1842 <Calibrate_Manually+0xe4>
				}
				else if (edit_mode=='s'){
    1810:	03 37       	cpi	r16, 0x73	; 115
    1812:	b9 f4       	brne	.+46     	; 0x1842 <Calibrate_Manually+0xe4>
					TeachASCIIKey(code,keypressed,modifier);
    1814:	4f 2d       	mov	r20, r15
    1816:	b6 01       	movw	r22, r12
    1818:	8c 2f       	mov	r24, r28
    181a:	e2 db       	rcall	.-2108   	; 0xfe0 <TeachASCIIKey>
					if(modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT){USBSendPROGString(Str_Shift_Plus);}
    181c:	f1 fe       	sbrs	r15, 1
    181e:	04 c0       	rjmp	.+8      	; 0x1828 <Calibrate_Manually+0xca>
    1820:	87 ea       	ldi	r24, 0xA7	; 167
    1822:	91 e0       	ldi	r25, 0x01	; 1
    1824:	0e 94 8d 2a 	call	0x551a	; 0x551a <USBSendPROGString>
					USBSendNumber(keypressed);
    1828:	8a 2d       	mov	r24, r10
    182a:	0e 94 95 2a 	call	0x552a	; 0x552a <USBSendNumber>
					if((code >= 'a') && (code <='z')){
    182e:	8f e9       	ldi	r24, 0x9F	; 159
    1830:	8c 0f       	add	r24, r28
    1832:	8a 31       	cpi	r24, 0x1A	; 26
    1834:	30 f4       	brcc	.+12     	; 0x1842 <Calibrate_Manually+0xe4>
						TeachASCIIKey(code-'a'+'A',keypressed,modifier|HID_KEYBOARD_MODIFIER_LEFTSHIFT);//program upper case letters too
    1836:	4f 2d       	mov	r20, r15
    1838:	42 60       	ori	r20, 0x02	; 2
    183a:	b6 01       	movw	r22, r12
    183c:	80 ee       	ldi	r24, 0xE0	; 224
    183e:	8c 0f       	add	r24, r28
    1840:	cf db       	rcall	.-2146   	; 0xfe0 <TeachASCIIKey>
					}
				}
			INCREMENT_CODE();			
    1842:	cf 5f       	subi	r28, 0xFF	; 255
    1844:	41 f0       	breq	.+16     	; 0x1856 <Calibrate_Manually+0xf8>
    1846:	9c 16       	cp	r9, r28
    1848:	30 f0       	brcs	.+12     	; 0x1856 <Calibrate_Manually+0xf8>
    184a:	ec 16       	cp	r14, r28
    184c:	28 f4       	brcc	.+10     	; 0x1858 <Calibrate_Manually+0xfa>
    184e:	c1 17       	cp	r28, r17
    1850:	18 f4       	brcc	.+6      	; 0x1858 <Calibrate_Manually+0xfa>
    1852:	c1 2f       	mov	r28, r17
    1854:	01 c0       	rjmp	.+2      	; 0x1858 <Calibrate_Manually+0xfa>
    1856:	cd 2f       	mov	r28, r29
    1858:	60 e0       	ldi	r22, 0x00	; 0
    185a:	88 e2       	ldi	r24, 0x28	; 40
    185c:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    1860:	05 37       	cpi	r16, 0x75	; 117
    1862:	61 f4       	brne	.+24     	; 0x187c <Calibrate_Manually+0x11e>
    1864:	8c 2f       	mov	r24, r28
    1866:	80 68       	ori	r24, 0x80	; 128
    1868:	88 5a       	subi	r24, 0xA8	; 168
    186a:	85 30       	cpi	r24, 0x05	; 5
    186c:	10 f4       	brcc	.+4      	; 0x1872 <Calibrate_Manually+0x114>
    186e:	cf 5f       	subi	r28, 0xFF	; 255
    1870:	f9 cf       	rjmp	.-14     	; 0x1864 <Calibrate_Manually+0x106>
    1872:	60 e0       	ldi	r22, 0x00	; 0
    1874:	8c 2f       	mov	r24, r28
    1876:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    187a:	2b c0       	rjmp	.+86     	; 0x18d2 <Calibrate_Manually+0x174>
    187c:	c1 34       	cpi	r28, 0x41	; 65
    187e:	19 f0       	breq	.+6      	; 0x1886 <Calibrate_Manually+0x128>
    1880:	c0 33       	cpi	r28, 0x30	; 48
    1882:	31 f4       	brne	.+12     	; 0x1890 <Calibrate_Manually+0x132>
    1884:	22 c0       	rjmp	.+68     	; 0x18ca <Calibrate_Manually+0x16c>
    1886:	cb e5       	ldi	r28, 0x5B	; 91
    1888:	03 c0       	rjmp	.+6      	; 0x1890 <Calibrate_Manually+0x132>
    188a:	c4 38       	cpi	r28, 0x84	; 132
    188c:	31 f4       	brne	.+12     	; 0x189a <Calibrate_Manually+0x13c>
    188e:	cf 5f       	subi	r28, 0xFF	; 255
    1890:	8f e7       	ldi	r24, 0x7F	; 127
    1892:	8c 0f       	add	r24, r28
    1894:	82 30       	cpi	r24, 0x02	; 2
    1896:	c8 f7       	brcc	.-14     	; 0x188a <Calibrate_Manually+0x12c>
    1898:	fa cf       	rjmp	.-12     	; 0x188e <Calibrate_Manually+0x130>
    189a:	8c 2f       	mov	r24, r28
    189c:	8f 7e       	andi	r24, 0xEF	; 239
    189e:	8d 38       	cpi	r24, 0x8D	; 141
    18a0:	b1 f3       	breq	.-20     	; 0x188e <Calibrate_Manually+0x130>
    18a2:	cb 39       	cpi	r28, 0x9B	; 155
    18a4:	a1 f3       	breq	.-24     	; 0x188e <Calibrate_Manually+0x130>
    18a6:	8c 2f       	mov	r24, r28
    18a8:	87 7f       	andi	r24, 0xF7	; 247
    18aa:	80 3a       	cpi	r24, 0xA0	; 160
    18ac:	81 f3       	breq	.-32     	; 0x188e <Calibrate_Manually+0x130>
    18ae:	c4 3b       	cpi	r28, 0xB4	; 180
    18b0:	71 f3       	breq	.-36     	; 0x188e <Calibrate_Manually+0x130>
    18b2:	8c 2f       	mov	r24, r28
    18b4:	8d 7f       	andi	r24, 0xFD	; 253
    18b6:	8d 3a       	cpi	r24, 0xAD	; 173
    18b8:	51 f3       	breq	.-44     	; 0x188e <Calibrate_Manually+0x130>
    18ba:	89 e4       	ldi	r24, 0x49	; 73
    18bc:	8c 0f       	add	r24, r28
    18be:	82 30       	cpi	r24, 0x02	; 2
    18c0:	30 f3       	brcs	.-52     	; 0x188e <Calibrate_Manually+0x130>
    18c2:	c2 39       	cpi	r28, 0x92	; 146
    18c4:	19 f4       	brne	.+6      	; 0x18cc <Calibrate_Manually+0x16e>
    18c6:	cb e9       	ldi	r28, 0x9B	; 155
    18c8:	01 c0       	rjmp	.+2      	; 0x18cc <Calibrate_Manually+0x16e>
    18ca:	ca e3       	ldi	r28, 0x3A	; 58
    18cc:	8c 2f       	mov	r24, r28
    18ce:	0e 94 db 2a 	call	0x55b6	; 0x55b6 <USBSendASCII>
    18d2:	2f ef       	ldi	r18, 0xFF	; 255
    18d4:	84 e3       	ldi	r24, 0x34	; 52
    18d6:	9c e0       	ldi	r25, 0x0C	; 12
    18d8:	21 50       	subi	r18, 0x01	; 1
    18da:	80 40       	sbci	r24, 0x00	; 0
    18dc:	90 40       	sbci	r25, 0x00	; 0
    18de:	e1 f7       	brne	.-8      	; 0x18d8 <Calibrate_Manually+0x17a>
    18e0:	00 c0       	rjmp	.+0      	; 0x18e2 <Calibrate_Manually+0x184>
    18e2:	00 00       	nop
    18e4:	80 cf       	rjmp	.-256    	; 0x17e6 <Calibrate_Manually+0x88>
			Delay_MS(CALIBRATION_DELAY);
			}
			else{ //if key pressed is spacebar
				if (is_low(CTRL_KEY)){DECREMENT_CODE();}
    18e6:	7c 99       	sbic	0x0f, 4	; 15
    18e8:	44 c0       	rjmp	.+136    	; 0x1972 <Calibrate_Manually+0x214>
    18ea:	dc 17       	cp	r29, r28
    18ec:	30 f4       	brcc	.+12     	; 0x18fa <Calibrate_Manually+0x19c>
    18ee:	1c 17       	cp	r17, r28
    18f0:	10 f0       	brcs	.+4      	; 0x18f6 <Calibrate_Manually+0x198>
    18f2:	ec 16       	cp	r14, r28
    18f4:	20 f0       	brcs	.+8      	; 0x18fe <Calibrate_Manually+0x1a0>
    18f6:	c1 50       	subi	r28, 0x01	; 1
    18f8:	03 c0       	rjmp	.+6      	; 0x1900 <Calibrate_Manually+0x1a2>
    18fa:	c9 2d       	mov	r28, r9
    18fc:	01 c0       	rjmp	.+2      	; 0x1900 <Calibrate_Manually+0x1a2>
    18fe:	ce 2d       	mov	r28, r14
    1900:	60 e0       	ldi	r22, 0x00	; 0
    1902:	88 e2       	ldi	r24, 0x28	; 40
    1904:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    1908:	05 37       	cpi	r16, 0x75	; 117
    190a:	41 f4       	brne	.+16     	; 0x191c <Calibrate_Manually+0x1be>
    190c:	8c 2f       	mov	r24, r28
    190e:	80 68       	ori	r24, 0x80	; 128
    1910:	88 5a       	subi	r24, 0xA8	; 168
    1912:	85 30       	cpi	r24, 0x05	; 5
    1914:	08 f0       	brcs	.+2      	; 0x1918 <Calibrate_Manually+0x1ba>
    1916:	47 c0       	rjmp	.+142    	; 0x19a6 <Calibrate_Manually+0x248>
    1918:	c1 50       	subi	r28, 0x01	; 1
    191a:	f8 cf       	rjmp	.-16     	; 0x190c <Calibrate_Manually+0x1ae>
    191c:	ca 35       	cpi	r28, 0x5A	; 90
    191e:	29 f0       	breq	.+10     	; 0x192a <Calibrate_Manually+0x1cc>
    1920:	c9 33       	cpi	r28, 0x39	; 57
    1922:	29 f0       	breq	.+10     	; 0x192e <Calibrate_Manually+0x1d0>
    1924:	ca 39       	cpi	r28, 0x9A	; 154
    1926:	19 f1       	breq	.+70     	; 0x196e <Calibrate_Manually+0x210>
    1928:	07 c0       	rjmp	.+14     	; 0x1938 <Calibrate_Manually+0x1da>
    192a:	c0 e4       	ldi	r28, 0x40	; 64
    192c:	05 c0       	rjmp	.+10     	; 0x1938 <Calibrate_Manually+0x1da>
    192e:	cf e2       	ldi	r28, 0x2F	; 47
    1930:	03 c0       	rjmp	.+6      	; 0x1938 <Calibrate_Manually+0x1da>
    1932:	c4 38       	cpi	r28, 0x84	; 132
    1934:	31 f4       	brne	.+12     	; 0x1942 <Calibrate_Manually+0x1e4>
    1936:	c1 50       	subi	r28, 0x01	; 1
    1938:	8f e7       	ldi	r24, 0x7F	; 127
    193a:	8c 0f       	add	r24, r28
    193c:	82 30       	cpi	r24, 0x02	; 2
    193e:	c8 f7       	brcc	.-14     	; 0x1932 <Calibrate_Manually+0x1d4>
    1940:	fa cf       	rjmp	.-12     	; 0x1936 <Calibrate_Manually+0x1d8>
    1942:	8c 2f       	mov	r24, r28
    1944:	8f 7e       	andi	r24, 0xEF	; 239
    1946:	8d 38       	cpi	r24, 0x8D	; 141
    1948:	b1 f3       	breq	.-20     	; 0x1936 <Calibrate_Manually+0x1d8>
    194a:	cb 39       	cpi	r28, 0x9B	; 155
    194c:	a1 f3       	breq	.-24     	; 0x1936 <Calibrate_Manually+0x1d8>
    194e:	8c 2f       	mov	r24, r28
    1950:	87 7f       	andi	r24, 0xF7	; 247
    1952:	80 3a       	cpi	r24, 0xA0	; 160
    1954:	81 f3       	breq	.-32     	; 0x1936 <Calibrate_Manually+0x1d8>
    1956:	c4 3b       	cpi	r28, 0xB4	; 180
    1958:	71 f3       	breq	.-36     	; 0x1936 <Calibrate_Manually+0x1d8>
    195a:	8c 2f       	mov	r24, r28
    195c:	8d 7f       	andi	r24, 0xFD	; 253
    195e:	8d 3a       	cpi	r24, 0xAD	; 173
    1960:	51 f3       	breq	.-44     	; 0x1936 <Calibrate_Manually+0x1d8>
    1962:	89 e4       	ldi	r24, 0x49	; 73
    1964:	8c 0f       	add	r24, r28
    1966:	82 30       	cpi	r24, 0x02	; 2
    1968:	08 f0       	brcs	.+2      	; 0x196c <Calibrate_Manually+0x20e>
    196a:	4a c0       	rjmp	.+148    	; 0x1a00 <Calibrate_Manually+0x2a2>
    196c:	e4 cf       	rjmp	.-56     	; 0x1936 <Calibrate_Manually+0x1d8>
    196e:	c1 e9       	ldi	r28, 0x91	; 145
    1970:	47 c0       	rjmp	.+142    	; 0x1a00 <Calibrate_Manually+0x2a2>
				else if (is_low(CMD_KEY)){break;}
    1972:	7e 9b       	sbis	0x0f, 6	; 15
    1974:	49 c0       	rjmp	.+146    	; 0x1a08 <Calibrate_Manually+0x2aa>
				else {INCREMENT_CODE();}
    1976:	cf 5f       	subi	r28, 0xFF	; 255
    1978:	41 f0       	breq	.+16     	; 0x198a <Calibrate_Manually+0x22c>
    197a:	9c 16       	cp	r9, r28
    197c:	30 f0       	brcs	.+12     	; 0x198a <Calibrate_Manually+0x22c>
    197e:	ec 16       	cp	r14, r28
    1980:	28 f4       	brcc	.+10     	; 0x198c <Calibrate_Manually+0x22e>
    1982:	c1 17       	cp	r28, r17
    1984:	18 f4       	brcc	.+6      	; 0x198c <Calibrate_Manually+0x22e>
    1986:	c1 2f       	mov	r28, r17
    1988:	01 c0       	rjmp	.+2      	; 0x198c <Calibrate_Manually+0x22e>
    198a:	cd 2f       	mov	r28, r29
    198c:	60 e0       	ldi	r22, 0x00	; 0
    198e:	88 e2       	ldi	r24, 0x28	; 40
    1990:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    1994:	05 37       	cpi	r16, 0x75	; 117
    1996:	61 f4       	brne	.+24     	; 0x19b0 <Calibrate_Manually+0x252>
    1998:	8c 2f       	mov	r24, r28
    199a:	80 68       	ori	r24, 0x80	; 128
    199c:	88 5a       	subi	r24, 0xA8	; 168
    199e:	85 30       	cpi	r24, 0x05	; 5
    19a0:	10 f4       	brcc	.+4      	; 0x19a6 <Calibrate_Manually+0x248>
    19a2:	cf 5f       	subi	r28, 0xFF	; 255
    19a4:	f9 cf       	rjmp	.-14     	; 0x1998 <Calibrate_Manually+0x23a>
    19a6:	60 e0       	ldi	r22, 0x00	; 0
    19a8:	8c 2f       	mov	r24, r28
    19aa:	0e 94 cc 29 	call	0x5398	; 0x5398 <USBSend>
    19ae:	1b cf       	rjmp	.-458    	; 0x17e6 <Calibrate_Manually+0x88>
    19b0:	c1 34       	cpi	r28, 0x41	; 65
    19b2:	19 f0       	breq	.+6      	; 0x19ba <Calibrate_Manually+0x25c>
    19b4:	c0 33       	cpi	r28, 0x30	; 48
    19b6:	31 f4       	brne	.+12     	; 0x19c4 <Calibrate_Manually+0x266>
    19b8:	22 c0       	rjmp	.+68     	; 0x19fe <Calibrate_Manually+0x2a0>
    19ba:	cb e5       	ldi	r28, 0x5B	; 91
    19bc:	03 c0       	rjmp	.+6      	; 0x19c4 <Calibrate_Manually+0x266>
    19be:	c4 38       	cpi	r28, 0x84	; 132
    19c0:	31 f4       	brne	.+12     	; 0x19ce <Calibrate_Manually+0x270>
    19c2:	cf 5f       	subi	r28, 0xFF	; 255
    19c4:	8f e7       	ldi	r24, 0x7F	; 127
    19c6:	8c 0f       	add	r24, r28
    19c8:	82 30       	cpi	r24, 0x02	; 2
    19ca:	c8 f7       	brcc	.-14     	; 0x19be <Calibrate_Manually+0x260>
    19cc:	fa cf       	rjmp	.-12     	; 0x19c2 <Calibrate_Manually+0x264>
    19ce:	8c 2f       	mov	r24, r28
    19d0:	8f 7e       	andi	r24, 0xEF	; 239
    19d2:	8d 38       	cpi	r24, 0x8D	; 141
    19d4:	b1 f3       	breq	.-20     	; 0x19c2 <Calibrate_Manually+0x264>
    19d6:	cb 39       	cpi	r28, 0x9B	; 155
    19d8:	a1 f3       	breq	.-24     	; 0x19c2 <Calibrate_Manually+0x264>
    19da:	8c 2f       	mov	r24, r28
    19dc:	87 7f       	andi	r24, 0xF7	; 247
    19de:	80 3a       	cpi	r24, 0xA0	; 160
    19e0:	81 f3       	breq	.-32     	; 0x19c2 <Calibrate_Manually+0x264>
    19e2:	c4 3b       	cpi	r28, 0xB4	; 180
    19e4:	71 f3       	breq	.-36     	; 0x19c2 <Calibrate_Manually+0x264>
    19e6:	8c 2f       	mov	r24, r28
    19e8:	8d 7f       	andi	r24, 0xFD	; 253
    19ea:	8d 3a       	cpi	r24, 0xAD	; 173
    19ec:	51 f3       	breq	.-44     	; 0x19c2 <Calibrate_Manually+0x264>
    19ee:	89 e4       	ldi	r24, 0x49	; 73
    19f0:	8c 0f       	add	r24, r28
    19f2:	82 30       	cpi	r24, 0x02	; 2
    19f4:	30 f3       	brcs	.-52     	; 0x19c2 <Calibrate_Manually+0x264>
    19f6:	c2 39       	cpi	r28, 0x92	; 146
    19f8:	19 f4       	brne	.+6      	; 0x1a00 <Calibrate_Manually+0x2a2>
    19fa:	cb e9       	ldi	r28, 0x9B	; 155
    19fc:	01 c0       	rjmp	.+2      	; 0x1a00 <Calibrate_Manually+0x2a2>
    19fe:	ca e3       	ldi	r28, 0x3A	; 58
    1a00:	8c 2f       	mov	r24, r28
    1a02:	0e 94 db 2a 	call	0x55b6	; 0x55b6 <USBSendASCII>
			}
	}
	
	SaveCalibration(); //save your work.
    1a06:	ef ce       	rjmp	.-546    	; 0x17e6 <Calibrate_Manually+0x88>
    1a08:	eb d8       	rcall	.-3626   	; 0xbe0 <SaveCalibration>
	USBSendPROGString(Str_Settings_Saved);
    1a0a:	8e ea       	ldi	r24, 0xAE	; 174
    1a0c:	92 e0       	ldi	r25, 0x02	; 2
	
}
    1a0e:	df 91       	pop	r29
    1a10:	cf 91       	pop	r28
    1a12:	1f 91       	pop	r17
    1a14:	0f 91       	pop	r16
    1a16:	ff 90       	pop	r15
    1a18:	ef 90       	pop	r14
    1a1a:	df 90       	pop	r13
    1a1c:	cf 90       	pop	r12
    1a1e:	bf 90       	pop	r11
    1a20:	af 90       	pop	r10
    1a22:	9f 90       	pop	r9
				else {INCREMENT_CODE();}
			}
	}
	
	SaveCalibration(); //save your work.
	USBSendPROGString(Str_Settings_Saved);
    1a24:	0c 94 8d 2a 	jmp	0x551a	; 0x551a <USBSendPROGString>
		codeend2 = 0xFF;
	}
	
	code = codestart1;
	if (edit_mode == 'u'){USBSend(code,LOWER);}
	else {USBSendASCII(code);}
    1a28:	81 e2       	ldi	r24, 0x21	; 33
    1a2a:	0e 94 db 2a 	call	0x55b6	; 0x55b6 <USBSendASCII>
	}
	else{
		codestart1 = 0x21;
		codeend1 = 142;// see http://www.peterstagg.com/blog/wp-content/uploads/2012/05/letter-spagetti.png
		codestart2 = 153;
		codeend2 = 0xFF;
    1a2e:	99 24       	eor	r9, r9
    1a30:	9a 94       	dec	r9
		codeend2 = 0x38|FORCE_UPPER;
	}
	else{
		codestart1 = 0x21;
		codeend1 = 142;// see http://www.peterstagg.com/blog/wp-content/uploads/2012/05/letter-spagetti.png
		codestart2 = 153;
    1a32:	19 e9       	ldi	r17, 0x99	; 153
		codestart2 = 0x1E|FORCE_UPPER;
		codeend2 = 0x38|FORCE_UPPER;
	}
	else{
		codestart1 = 0x21;
		codeend1 = 142;// see http://www.peterstagg.com/blog/wp-content/uploads/2012/05/letter-spagetti.png
    1a34:	8e e8       	ldi	r24, 0x8E	; 142
    1a36:	e8 2e       	mov	r14, r24
		codeend1 = 0x38;
		codestart2 = 0x1E|FORCE_UPPER;
		codeend2 = 0x38|FORCE_UPPER;
	}
	else{
		codestart1 = 0x21;
    1a38:	d1 e2       	ldi	r29, 0x21	; 33
    1a3a:	d4 ce       	rjmp	.-600    	; 0x17e4 <Calibrate_Manually+0x86>

00001a3c <Config_Interrupts>:


void Config_Interrupts(){

	
	bit_clr(PRR0,PRTIM1); // clear power-reduction bit for timer1
    1a3c:	e4 e6       	ldi	r30, 0x64	; 100
    1a3e:	f0 e0       	ldi	r31, 0x00	; 0
    1a40:	80 81       	ld	r24, Z
    1a42:	87 7f       	andi	r24, 0xF7	; 247
    1a44:	80 83       	st	Z, r24
	TCCR1B = BIT(CTC1) | BIT(CS11); //set CTC (clear timer on compare equal mode) and set tmr prescaler to 8 -- page 125 of datasheet
    1a46:	8a e0       	ldi	r24, 0x0A	; 10
    1a48:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	
	OCR1AH = TIMER1_COMPARE_HIGH;//high register MUST be written before low register.  Datasheet says so!
    1a4c:	87 e2       	ldi	r24, 0x27	; 39
    1a4e:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
	OCR1AL = UINT8_C(TIMER1_COMPARE_LOW); //we only want the first 8 bits of the "low" variable.
    1a52:	80 e1       	ldi	r24, 0x10	; 16
    1a54:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
	
	bit_set(TIMSK1,OCIE1A); //enable output compare interrupt for timer1
    1a58:	ef e6       	ldi	r30, 0x6F	; 111
    1a5a:	f0 e0       	ldi	r31, 0x00	; 0
    1a5c:	80 81       	ld	r24, Z
    1a5e:	82 60       	ori	r24, 0x02	; 2
    1a60:	80 83       	st	Z, r24
    1a62:	08 95       	ret

00001a64 <Config_IO>:
    1a64:	20 98       	cbi	0x04, 0	; 4
    1a66:	28 9a       	sbi	0x05, 0	; 5
    1a68:	54 98       	cbi	0x0a, 4	; 10
    1a6a:	5c 9a       	sbi	0x0b, 4	; 11
    1a6c:	56 98       	cbi	0x0a, 6	; 10
    1a6e:	5e 9a       	sbi	0x0b, 6	; 11
    1a70:	57 98       	cbi	0x0a, 7	; 10
    1a72:	5f 9a       	sbi	0x0b, 7	; 11
    1a74:	24 98       	cbi	0x04, 4	; 4
    1a76:	2c 9a       	sbi	0x05, 4	; 5
    1a78:	2b 9a       	sbi	0x05, 3	; 5
    1a7a:	23 98       	cbi	0x04, 3	; 4
    1a7c:	2b 9a       	sbi	0x05, 3	; 5
    1a7e:	2a 9a       	sbi	0x05, 2	; 5
    1a80:	22 98       	cbi	0x04, 2	; 4
    1a82:	2a 9a       	sbi	0x05, 2	; 5
    1a84:	6a 9a       	sbi	0x0d, 2	; 13
    1a86:	25 98       	cbi	0x04, 5	; 4
    1a88:	2d 9a       	sbi	0x05, 5	; 5
    1a8a:	29 9a       	sbi	0x05, 1	; 5
    1a8c:	21 98       	cbi	0x04, 1	; 4
    1a8e:	29 9a       	sbi	0x05, 1	; 5
    1a90:	59 9a       	sbi	0x0b, 1	; 11
    1a92:	51 9a       	sbi	0x0a, 1	; 10
    1a94:	55 98       	cbi	0x0a, 5	; 10
    1a96:	5b 9a       	sbi	0x0b, 3	; 11
    1a98:	53 9a       	sbi	0x0a, 3	; 10
    1a9a:	52 98       	cbi	0x0a, 2	; 10
    1a9c:	5a 9a       	sbi	0x0b, 2	; 11
    1a9e:	84 98       	cbi	0x10, 4	; 16
    1aa0:	8c 9a       	sbi	0x11, 4	; 17
    1aa2:	85 98       	cbi	0x10, 5	; 16
    1aa4:	8d 9a       	sbi	0x11, 5	; 17
    1aa6:	86 98       	cbi	0x10, 6	; 16
    1aa8:	8e 9a       	sbi	0x11, 6	; 17
    1aaa:	8f 98       	cbi	0x11, 7	; 17
    1aac:	87 9a       	sbi	0x10, 7	; 16
    1aae:	47 9a       	sbi	0x08, 7	; 8
    1ab0:	3f 9a       	sbi	0x07, 7	; 7
    1ab2:	81 98       	cbi	0x10, 1	; 16
    1ab4:	89 9a       	sbi	0x11, 1	; 17
    1ab6:	76 9a       	sbi	0x0e, 6	; 14
    1ab8:	6e 9a       	sbi	0x0d, 6	; 13
    1aba:	46 9a       	sbi	0x08, 6	; 8
    1abc:	3e 9a       	sbi	0x07, 6	; 7
    1abe:	2e 9a       	sbi	0x05, 6	; 5
    1ac0:	26 9a       	sbi	0x04, 6	; 4
    1ac2:	08 95       	ret

00001ac4 <GlowGreenLED>:
    1ac4:	f8 94       	cli
    1ac6:	9f ef       	ldi	r25, 0xFF	; 255
    1ac8:	90 93 d1 00 	sts	0x00D1, r25	; 0x8000d1 <__DATA_REGION_ORIGIN__+0x71>
    1acc:	10 92 bf 00 	sts	0x00BF, r1	; 0x8000bf <__DATA_REGION_ORIGIN__+0x5f>
    1ad0:	90 e2       	ldi	r25, 0x20	; 32
    1ad2:	90 93 cf 00 	sts	0x00CF, r25	; 0x8000cf <__DATA_REGION_ORIGIN__+0x6f>
    1ad6:	90 91 c4 00 	lds	r25, 0x00C4	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
    1ada:	61 30       	cpi	r22, 0x01	; 1
    1adc:	51 f4       	brne	.+20     	; 0x1af2 <GlowGreenLED+0x2e>
    1ade:	9e 7f       	andi	r25, 0xFE	; 254
    1ae0:	90 93 c4 00 	sts	0x00C4, r25	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
    1ae4:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    1ae8:	9f 7b       	andi	r25, 0xBF	; 191
    1aea:	90 93 c0 00 	sts	0x00C0, r25	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    1aee:	46 98       	cbi	0x08, 6	; 8
    1af0:	08 c0       	rjmp	.+16     	; 0x1b02 <GlowGreenLED+0x3e>
    1af2:	91 60       	ori	r25, 0x01	; 1
    1af4:	90 93 c4 00 	sts	0x00C4, r25	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
    1af8:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    1afc:	90 64       	ori	r25, 0x40	; 64
    1afe:	90 93 c0 00 	sts	0x00C0, r25	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    1b02:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    1b06:	92 60       	ori	r25, 0x02	; 2
    1b08:	90 93 c0 00 	sts	0x00C0, r25	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    1b0c:	90 91 72 00 	lds	r25, 0x0072	; 0x800072 <__DATA_REGION_ORIGIN__+0x12>
    1b10:	94 60       	ori	r25, 0x04	; 4
    1b12:	90 93 72 00 	sts	0x0072, r25	; 0x800072 <__DATA_REGION_ORIGIN__+0x12>
    1b16:	81 30       	cpi	r24, 0x01	; 1
    1b18:	69 f0       	breq	.+26     	; 0x1b34 <GlowGreenLED+0x70>
    1b1a:	30 f0       	brcs	.+12     	; 0x1b28 <GlowGreenLED+0x64>
    1b1c:	82 30       	cpi	r24, 0x02	; 2
    1b1e:	41 f0       	breq	.+16     	; 0x1b30 <GlowGreenLED+0x6c>
    1b20:	83 30       	cpi	r24, 0x03	; 3
    1b22:	41 f4       	brne	.+16     	; 0x1b34 <GlowGreenLED+0x70>
    1b24:	86 e0       	ldi	r24, 0x06	; 6
    1b26:	09 c0       	rjmp	.+18     	; 0x1b3a <GlowGreenLED+0x76>
    1b28:	89 e0       	ldi	r24, 0x09	; 9
    1b2a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    1b2e:	02 c0       	rjmp	.+4      	; 0x1b34 <GlowGreenLED+0x70>
    1b30:	87 e0       	ldi	r24, 0x07	; 7
    1b32:	03 c0       	rjmp	.+6      	; 0x1b3a <GlowGreenLED+0x76>
    1b34:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    1b38:	88 60       	ori	r24, 0x08	; 8
    1b3a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    1b3e:	10 92 15 06 	sts	0x0615, r1	; 0x800615 <GlowDirection>
    1b42:	10 92 bf 00 	sts	0x00BF, r1	; 0x8000bf <__DATA_REGION_ORIGIN__+0x5f>
    1b46:	10 92 be 00 	sts	0x00BE, r1	; 0x8000be <__DATA_REGION_ORIGIN__+0x5e>
    1b4a:	78 94       	sei
    1b4c:	08 95       	ret

00001b4e <__vector_41>:
    1b4e:	1f 92       	push	r1
    1b50:	0f 92       	push	r0
    1b52:	0f b6       	in	r0, 0x3f	; 63
    1b54:	0f 92       	push	r0
    1b56:	11 24       	eor	r1, r1
    1b58:	8f 93       	push	r24
    1b5a:	9f 93       	push	r25
    1b5c:	80 91 cf 00 	lds	r24, 0x00CF	; 0x8000cf <__DATA_REGION_ORIGIN__+0x6f>
    1b60:	90 91 15 06 	lds	r25, 0x0615	; 0x800615 <GlowDirection>
    1b64:	99 23       	and	r25, r25
    1b66:	19 f0       	breq	.+6      	; 0x1b6e <__vector_41+0x20>
    1b68:	92 30       	cpi	r25, 0x02	; 2
    1b6a:	39 f0       	breq	.+14     	; 0x1b7a <__vector_41+0x2c>
    1b6c:	0a c0       	rjmp	.+20     	; 0x1b82 <__vector_41+0x34>
    1b6e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b70:	31 f4       	brne	.+12     	; 0x1b7e <__vector_41+0x30>
    1b72:	91 e0       	ldi	r25, 0x01	; 1
    1b74:	90 93 15 06 	sts	0x0615, r25	; 0x800615 <GlowDirection>
    1b78:	10 c0       	rjmp	.+32     	; 0x1b9a <__vector_41+0x4c>
    1b7a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b7c:	71 f0       	breq	.+28     	; 0x1b9a <__vector_41+0x4c>
    1b7e:	8f 5f       	subi	r24, 0xFF	; 255
    1b80:	0c c0       	rjmp	.+24     	; 0x1b9a <__vector_41+0x4c>
    1b82:	81 11       	cpse	r24, r1
    1b84:	09 c0       	rjmp	.+18     	; 0x1b98 <__vector_41+0x4a>
    1b86:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    1b8a:	9f 7b       	andi	r25, 0xBF	; 191
    1b8c:	90 93 c0 00 	sts	0x00C0, r25	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    1b90:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    1b94:	46 9a       	sbi	0x08, 6	; 8
    1b96:	01 c0       	rjmp	.+2      	; 0x1b9a <__vector_41+0x4c>
    1b98:	81 50       	subi	r24, 0x01	; 1
    1b9a:	80 93 cf 00 	sts	0x00CF, r24	; 0x8000cf <__DATA_REGION_ORIGIN__+0x6f>
    1b9e:	9f 91       	pop	r25
    1ba0:	8f 91       	pop	r24
    1ba2:	0f 90       	pop	r0
    1ba4:	0f be       	out	0x3f, r0	; 63
    1ba6:	0f 90       	pop	r0
    1ba8:	1f 90       	pop	r1
    1baa:	18 95       	reti

00001bac <CALLBACK_USB_GetDescriptor>:
    1bac:	29 2f       	mov	r18, r25
    1bae:	33 27       	eor	r19, r19
    1bb0:	23 30       	cpi	r18, 0x03	; 3
    1bb2:	31 05       	cpc	r19, r1
    1bb4:	e1 f0       	breq	.+56     	; 0x1bee <CALLBACK_USB_GetDescriptor+0x42>
    1bb6:	58 f4       	brcc	.+22     	; 0x1bce <CALLBACK_USB_GetDescriptor+0x22>
    1bb8:	21 30       	cpi	r18, 0x01	; 1
    1bba:	31 05       	cpc	r19, r1
    1bbc:	99 f0       	breq	.+38     	; 0x1be4 <CALLBACK_USB_GetDescriptor+0x38>
    1bbe:	22 30       	cpi	r18, 0x02	; 2
    1bc0:	31 05       	cpc	r19, r1
    1bc2:	69 f5       	brne	.+90     	; 0x1c1e <CALLBACK_USB_GetDescriptor+0x72>
    1bc4:	89 e3       	ldi	r24, 0x39	; 57
    1bc6:	90 e0       	ldi	r25, 0x00	; 0
    1bc8:	26 e8       	ldi	r18, 0x86	; 134
    1bca:	36 e0       	ldi	r19, 0x06	; 6
    1bcc:	2c c0       	rjmp	.+88     	; 0x1c26 <CALLBACK_USB_GetDescriptor+0x7a>
    1bce:	21 32       	cpi	r18, 0x21	; 33
    1bd0:	31 05       	cpc	r19, r1
    1bd2:	01 f1       	breq	.+64     	; 0x1c14 <CALLBACK_USB_GetDescriptor+0x68>
    1bd4:	22 32       	cpi	r18, 0x22	; 34
    1bd6:	31 05       	cpc	r19, r1
    1bd8:	11 f5       	brne	.+68     	; 0x1c1e <CALLBACK_USB_GetDescriptor+0x72>
    1bda:	8f e3       	ldi	r24, 0x3F	; 63
    1bdc:	90 e0       	ldi	r25, 0x00	; 0
    1bde:	21 ed       	ldi	r18, 0xD1	; 209
    1be0:	36 e0       	ldi	r19, 0x06	; 6
    1be2:	21 c0       	rjmp	.+66     	; 0x1c26 <CALLBACK_USB_GetDescriptor+0x7a>
    1be4:	82 e1       	ldi	r24, 0x12	; 18
    1be6:	90 e0       	ldi	r25, 0x00	; 0
    1be8:	2f eb       	ldi	r18, 0xBF	; 191
    1bea:	36 e0       	ldi	r19, 0x06	; 6
    1bec:	1c c0       	rjmp	.+56     	; 0x1c26 <CALLBACK_USB_GetDescriptor+0x7a>
    1bee:	99 27       	eor	r25, r25
    1bf0:	81 30       	cpi	r24, 0x01	; 1
    1bf2:	91 05       	cpc	r25, r1
    1bf4:	49 f0       	breq	.+18     	; 0x1c08 <CALLBACK_USB_GetDescriptor+0x5c>
    1bf6:	28 f0       	brcs	.+10     	; 0x1c02 <CALLBACK_USB_GetDescriptor+0x56>
    1bf8:	02 97       	sbiw	r24, 0x02	; 2
    1bfa:	89 f4       	brne	.+34     	; 0x1c1e <CALLBACK_USB_GetDescriptor+0x72>
    1bfc:	e8 e2       	ldi	r30, 0x28	; 40
    1bfe:	f6 e0       	ldi	r31, 0x06	; 6
    1c00:	05 c0       	rjmp	.+10     	; 0x1c0c <CALLBACK_USB_GetDescriptor+0x60>
    1c02:	e2 e8       	ldi	r30, 0x82	; 130
    1c04:	f6 e0       	ldi	r31, 0x06	; 6
    1c06:	02 c0       	rjmp	.+4      	; 0x1c0c <CALLBACK_USB_GetDescriptor+0x60>
    1c08:	ea e5       	ldi	r30, 0x5A	; 90
    1c0a:	f6 e0       	ldi	r31, 0x06	; 6
    1c0c:	84 91       	lpm	r24, Z
    1c0e:	90 e0       	ldi	r25, 0x00	; 0
    1c10:	9f 01       	movw	r18, r30
    1c12:	09 c0       	rjmp	.+18     	; 0x1c26 <CALLBACK_USB_GetDescriptor+0x7a>
    1c14:	89 e0       	ldi	r24, 0x09	; 9
    1c16:	90 e0       	ldi	r25, 0x00	; 0
    1c18:	2f ea       	ldi	r18, 0xAF	; 175
    1c1a:	36 e0       	ldi	r19, 0x06	; 6
    1c1c:	04 c0       	rjmp	.+8      	; 0x1c26 <CALLBACK_USB_GetDescriptor+0x7a>
    1c1e:	80 e0       	ldi	r24, 0x00	; 0
    1c20:	90 e0       	ldi	r25, 0x00	; 0
    1c22:	20 e0       	ldi	r18, 0x00	; 0
    1c24:	30 e0       	ldi	r19, 0x00	; 0
    1c26:	fa 01       	movw	r30, r20
    1c28:	31 83       	std	Z+1, r19	; 0x01
    1c2a:	20 83       	st	Z, r18
    1c2c:	08 95       	ret

00001c2e <OpenLogFile>:
			CloseLogFile(); // close log file so a new one can be opened later.
}

/** Opens the log file on the Dataflash's FAT formatted partition according to the current date */
FRESULT OpenLogFile(void)
{
    1c2e:	cf 93       	push	r28
	
//	if (USB_DeviceState == DEVICE_STATE_Configured){
//		return FR_LOCKED; //the disk is locked if the USB is engaged.  This prevents collision with filesystem read/writes
//	}
	
		diskstatus = f_open(&LogFile, FileName, FA_OPEN_ALWAYS | FA_WRITE);
    1c30:	42 e1       	ldi	r20, 0x12	; 18
    1c32:	60 e0       	ldi	r22, 0x00	; 0
    1c34:	71 e0       	ldi	r23, 0x01	; 1
    1c36:	87 ee       	ldi	r24, 0xE7	; 231
    1c38:	92 e0       	ldi	r25, 0x02	; 2
    1c3a:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <f_open>
		f_sync(&LogFile);
    1c3e:	87 ee       	ldi	r24, 0xE7	; 231
    1c40:	92 e0       	ldi	r25, 0x02	; 2
    1c42:	0e 94 34 21 	call	0x4268	; 0x4268 <f_sync>
		f_close(&LogFile);
    1c46:	87 ee       	ldi	r24, 0xE7	; 231
    1c48:	92 e0       	ldi	r25, 0x02	; 2
    1c4a:	0e 94 77 21 	call	0x42ee	; 0x42ee <f_close>
		diskstatus = f_open(&LogFile, FileName, FA_OPEN_ALWAYS | FA_WRITE);
    1c4e:	42 e1       	ldi	r20, 0x12	; 18
    1c50:	60 e0       	ldi	r22, 0x00	; 0
    1c52:	71 e0       	ldi	r23, 0x01	; 1
    1c54:	87 ee       	ldi	r24, 0xE7	; 231
    1c56:	92 e0       	ldi	r25, 0x02	; 2
    1c58:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <f_open>
    1c5c:	c8 2f       	mov	r28, r24
		
		f_lseek(&LogFile, LogFile.fsize);
    1c5e:	40 91 f1 02 	lds	r20, 0x02F1	; 0x8002f1 <LogFile+0xa>
    1c62:	50 91 f2 02 	lds	r21, 0x02F2	; 0x8002f2 <LogFile+0xb>
    1c66:	60 91 f3 02 	lds	r22, 0x02F3	; 0x8002f3 <LogFile+0xc>
    1c6a:	70 91 f4 02 	lds	r23, 0x02F4	; 0x8002f4 <LogFile+0xd>
    1c6e:	87 ee       	ldi	r24, 0xE7	; 231
    1c70:	92 e0       	ldi	r25, 0x02	; 2
    1c72:	0e 94 87 21 	call	0x430e	; 0x430e <f_lseek>
	
	return diskstatus;
}
    1c76:	8c 2f       	mov	r24, r28
    1c78:	cf 91       	pop	r28
    1c7a:	08 95       	ret

00001c7c <CloseLogFile>:

/** Closes the open data log file on the Dataflash's FAT formatted partition */
void CloseLogFile(void)
{
	/* Sync any data waiting to be written, unmount the storage device */
	f_sync(&LogFile);
    1c7c:	87 ee       	ldi	r24, 0xE7	; 231
    1c7e:	92 e0       	ldi	r25, 0x02	; 2
    1c80:	0e 94 34 21 	call	0x4268	; 0x4268 <f_sync>
	f_close(&LogFile);
    1c84:	87 ee       	ldi	r24, 0xE7	; 231
    1c86:	92 e0       	ldi	r25, 0x02	; 2
    1c88:	0c 94 77 21 	jmp	0x42ee	; 0x42ee <f_close>

00001c8c <MountFilesystem>:
}

bool MountFilesystem(){
	bool diskstatus;
	diskstatus = f_mount(&DiskFATState,"",1);
    1c8c:	41 e0       	ldi	r20, 0x01	; 1
    1c8e:	6a e1       	ldi	r22, 0x1A	; 26
    1c90:	72 e0       	ldi	r23, 0x02	; 2
    1c92:	87 e0       	ldi	r24, 0x07	; 7
    1c94:	93 e0       	ldi	r25, 0x03	; 3
    1c96:	0e 94 33 1e 	call	0x3c66	; 0x3c66 <f_mount>
	return diskstatus;
    1c9a:	91 e0       	ldi	r25, 0x01	; 1
    1c9c:	81 11       	cpse	r24, r1
    1c9e:	01 c0       	rjmp	.+2      	; 0x1ca2 <MountFilesystem+0x16>
    1ca0:	90 e0       	ldi	r25, 0x00	; 0
}
    1ca2:	89 2f       	mov	r24, r25
    1ca4:	08 95       	ret

00001ca6 <get_num_of_sectors>:

uint32_t get_num_of_sectors(){
	static uint32_t tot_sect;
	if(!tot_sect){ //if we have not yet read a valid value into totsect
    1ca6:	80 91 e3 02 	lds	r24, 0x02E3	; 0x8002e3 <tot_sect.4666>
    1caa:	90 91 e4 02 	lds	r25, 0x02E4	; 0x8002e4 <tot_sect.4666+0x1>
    1cae:	a0 91 e5 02 	lds	r26, 0x02E5	; 0x8002e5 <tot_sect.4666+0x2>
    1cb2:	b0 91 e6 02 	lds	r27, 0x02E6	; 0x8002e6 <tot_sect.4666+0x3>
    1cb6:	89 2b       	or	r24, r25
    1cb8:	8a 2b       	or	r24, r26
    1cba:	8b 2b       	or	r24, r27
    1cbc:	d9 f4       	brne	.+54     	; 0x1cf4 <get_num_of_sectors+0x4e>
		tot_sect = (DiskFATState.n_fatent - 2) * DiskFATState.csize;
    1cbe:	80 91 19 03 	lds	r24, 0x0319	; 0x800319 <DiskFATState+0x12>
    1cc2:	90 91 1a 03 	lds	r25, 0x031A	; 0x80031a <DiskFATState+0x13>
    1cc6:	a0 91 1b 03 	lds	r26, 0x031B	; 0x80031b <DiskFATState+0x14>
    1cca:	b0 91 1c 03 	lds	r27, 0x031C	; 0x80031c <DiskFATState+0x15>
    1cce:	9c 01       	movw	r18, r24
    1cd0:	ad 01       	movw	r20, r26
    1cd2:	22 50       	subi	r18, 0x02	; 2
    1cd4:	31 09       	sbc	r19, r1
    1cd6:	41 09       	sbc	r20, r1
    1cd8:	51 09       	sbc	r21, r1
    1cda:	a0 91 09 03 	lds	r26, 0x0309	; 0x800309 <DiskFATState+0x2>
    1cde:	b0 e0       	ldi	r27, 0x00	; 0
    1ce0:	0e 94 f5 37 	call	0x6fea	; 0x6fea <__muluhisi3>
    1ce4:	60 93 e3 02 	sts	0x02E3, r22	; 0x8002e3 <tot_sect.4666>
    1ce8:	70 93 e4 02 	sts	0x02E4, r23	; 0x8002e4 <tot_sect.4666+0x1>
    1cec:	80 93 e5 02 	sts	0x02E5, r24	; 0x8002e5 <tot_sect.4666+0x2>
    1cf0:	90 93 e6 02 	sts	0x02E6, r25	; 0x8002e6 <tot_sect.4666+0x3>
	}
	return 	tot_sect;
    1cf4:	60 91 e3 02 	lds	r22, 0x02E3	; 0x8002e3 <tot_sect.4666>
    1cf8:	70 91 e4 02 	lds	r23, 0x02E4	; 0x8002e4 <tot_sect.4666+0x1>
    1cfc:	80 91 e5 02 	lds	r24, 0x02E5	; 0x8002e5 <tot_sect.4666+0x2>
    1d00:	90 91 e6 02 	lds	r25, 0x02E6	; 0x8002e6 <tot_sect.4666+0x3>
}
    1d04:	08 95       	ret

00001d06 <WriteToLogFile>:

bool WriteToLogFile(){
    1d06:	1f 93       	push	r17
    1d08:	cf 93       	push	r28
    1d0a:	df 93       	push	r29
    1d0c:	00 d0       	rcall	.+0      	; 0x1d0e <WriteToLogFile+0x8>
    1d0e:	cd b7       	in	r28, 0x3d	; 61
    1d10:	de b7       	in	r29, 0x3e	; 62
	UINT BytesWritten;
	uint8_t result;
	
	
	BytesWritten = strlen((char*)SD_Buffer);
    1d12:	ea e6       	ldi	r30, 0x6A	; 106
    1d14:	f7 e0       	ldi	r31, 0x07	; 7
    1d16:	01 90       	ld	r0, Z+
    1d18:	00 20       	and	r0, r0
    1d1a:	e9 f7       	brne	.-6      	; 0x1d16 <WriteToLogFile+0x10>
    1d1c:	31 97       	sbiw	r30, 0x01	; 1
    1d1e:	ea 56       	subi	r30, 0x6A	; 106
    1d20:	f7 40       	sbci	r31, 0x07	; 7
    1d22:	fa 83       	std	Y+2, r31	; 0x02
    1d24:	e9 83       	std	Y+1, r30	; 0x01
//	BytesWritten = sprintf(SD_Buffer, "TESTINGTESTING/r/n");//debug 
	f_lseek(&LogFile, LogFile.fsize);
    1d26:	40 91 f1 02 	lds	r20, 0x02F1	; 0x8002f1 <LogFile+0xa>
    1d2a:	50 91 f2 02 	lds	r21, 0x02F2	; 0x8002f2 <LogFile+0xb>
    1d2e:	60 91 f3 02 	lds	r22, 0x02F3	; 0x8002f3 <LogFile+0xc>
    1d32:	70 91 f4 02 	lds	r23, 0x02F4	; 0x8002f4 <LogFile+0xd>
    1d36:	87 ee       	ldi	r24, 0xE7	; 231
    1d38:	92 e0       	ldi	r25, 0x02	; 2
    1d3a:	0e 94 87 21 	call	0x430e	; 0x430e <f_lseek>
	result = f_write(&LogFile, (void *) SD_Buffer, BytesWritten, &BytesWritten);
    1d3e:	49 81       	ldd	r20, Y+1	; 0x01
    1d40:	5a 81       	ldd	r21, Y+2	; 0x02
    1d42:	9e 01       	movw	r18, r28
    1d44:	2f 5f       	subi	r18, 0xFF	; 255
    1d46:	3f 4f       	sbci	r19, 0xFF	; 255
    1d48:	6a e6       	ldi	r22, 0x6A	; 106
    1d4a:	77 e0       	ldi	r23, 0x07	; 7
    1d4c:	87 ee       	ldi	r24, 0xE7	; 231
    1d4e:	92 e0       	ldi	r25, 0x02	; 2
    1d50:	0e 94 a4 1f 	call	0x3f48	; 0x3f48 <f_write>
    1d54:	18 2f       	mov	r17, r24
	SD_Buffer[0] = '\0'; //a simple way to clear the buffer (equivalent to saving an empty string into the buffer)
    1d56:	10 92 6a 07 	sts	0x076A, r1	; 0x80076a <SD_Buffer>
	f_sync(&LogFile);
    1d5a:	87 ee       	ldi	r24, 0xE7	; 231
    1d5c:	92 e0       	ldi	r25, 0x02	; 2
    1d5e:	0e 94 34 21 	call	0x4268	; 0x4268 <f_sync>
	
	return result;
    1d62:	81 e0       	ldi	r24, 0x01	; 1
    1d64:	11 11       	cpse	r17, r1
    1d66:	01 c0       	rjmp	.+2      	; 0x1d6a <WriteToLogFile+0x64>
    1d68:	80 e0       	ldi	r24, 0x00	; 0
	
}
    1d6a:	0f 90       	pop	r0
    1d6c:	0f 90       	pop	r0
    1d6e:	df 91       	pop	r29
    1d70:	cf 91       	pop	r28
    1d72:	1f 91       	pop	r17
    1d74:	08 95       	ret

00001d76 <TestSDHardware>:

void TestSDHardware(){
		FRESULT diskstatus;
		
		diskstatus = MountFilesystem();
    1d76:	8a df       	rcall	.-236    	; 0x1c8c <MountFilesystem>
		
		if (diskstatus != FR_OK){
    1d78:	88 23       	and	r24, r24
    1d7a:	21 f0       	breq	.+8      	; 0x1d84 <TestSDHardware+0xe>
			Typewriter_Mode = PANIC_MODE;
    1d7c:	8a e0       	ldi	r24, 0x0A	; 10
    1d7e:	80 93 69 07 	sts	0x0769, r24	; 0x800769 <Typewriter_Mode>
			return;
    1d82:	08 95       	ret
		}
		
		strcpy(FileName, "SDHW.TXT");
    1d84:	66 e0       	ldi	r22, 0x06	; 6
    1d86:	72 e0       	ldi	r23, 0x02	; 2
    1d88:	80 e0       	ldi	r24, 0x00	; 0
    1d8a:	91 e0       	ldi	r25, 0x01	; 1
    1d8c:	0e 94 b5 38 	call	0x716a	; 0x716a <strcpy>
		while(1){
		OpenLogFile();
    1d90:	4e df       	rcall	.-356    	; 0x1c2e <OpenLogFile>
		strcpy((CHAR*)SD_Buffer,"testphrase\n");
    1d92:	6f e0       	ldi	r22, 0x0F	; 15
    1d94:	72 e0       	ldi	r23, 0x02	; 2
    1d96:	8a e6       	ldi	r24, 0x6A	; 106
    1d98:	97 e0       	ldi	r25, 0x07	; 7
    1d9a:	0e 94 b5 38 	call	0x716a	; 0x716a <strcpy>
		WriteToLogFile();
    1d9e:	b3 df       	rcall	.-154    	; 0x1d06 <WriteToLogFile>
		CloseLogFile();
    1da0:	6d df       	rcall	.-294    	; 0x1c7c <CloseLogFile>
    1da2:	2f ef       	ldi	r18, 0xFF	; 255
    1da4:	80 e7       	ldi	r24, 0x70	; 112
    1da6:	92 e0       	ldi	r25, 0x02	; 2
    1da8:	21 50       	subi	r18, 0x01	; 1
    1daa:	80 40       	sbci	r24, 0x00	; 0
    1dac:	90 40       	sbci	r25, 0x00	; 0
    1dae:	e1 f7       	brne	.-8      	; 0x1da8 <TestSDHardware+0x32>
    1db0:	00 c0       	rjmp	.+0      	; 0x1db2 <TestSDHardware+0x3c>
    1db2:	00 00       	nop
    1db4:	ed cf       	rjmp	.-38     	; 0x1d90 <TestSDHardware+0x1a>

00001db6 <AddToSDBuffer>:
    1db6:	ea e6       	ldi	r30, 0x6A	; 106

void AddToSDBuffer(char character){
	UINT index;
	static char prevcharacter;
	
	index = strlen((char*)SD_Buffer); //index is moved to the end of the string saved in the SD_Buffer.
    1db8:	f7 e0       	ldi	r31, 0x07	; 7
    1dba:	01 90       	ld	r0, Z+
    1dbc:	00 20       	and	r0, r0
    1dbe:	e9 f7       	brne	.-6      	; 0x1dba <AddToSDBuffer+0x4>
    1dc0:	31 97       	sbiw	r30, 0x01	; 1
    1dc2:	9f 01       	movw	r18, r30
    1dc4:	2a 56       	subi	r18, 0x6A	; 106
    1dc6:	37 40       	sbci	r19, 0x07	; 7
	if (index >= SD_BUFFER_LENGTH-10){
    1dc8:	26 3f       	cpi	r18, 0xF6	; 246
    1dca:	91 e0       	ldi	r25, 0x01	; 1
    1dcc:	39 07       	cpc	r19, r25
    1dce:	08 f0       	brcs	.+2      	; 0x1dd2 <AddToSDBuffer+0x1c>
    1dd0:	41 c0       	rjmp	.+130    	; 0x1e54 <AddToSDBuffer+0x9e>
		return; //take no action if SD_Buffer is nearly full.  this could over-write other variables and cause a mess.
	}
	
	if (character == '\r'){ //special treatment for return character
    1dd2:	8d 30       	cpi	r24, 0x0D	; 13
    1dd4:	81 f5       	brne	.+96     	; 0x1e36 <AddToSDBuffer+0x80>
		if(prevcharacter != '\r'){ //if this is first time \r is pressed, insert a space instead, and save to file.
    1dd6:	90 91 e2 02 	lds	r25, 0x02E2	; 0x8002e2 <prevcharacter.4679>
    1dda:	f9 01       	movw	r30, r18
    1ddc:	e6 59       	subi	r30, 0x96	; 150
    1dde:	f8 4f       	sbci	r31, 0xF8	; 248
    1de0:	a9 01       	movw	r20, r18
    1de2:	4f 5f       	subi	r20, 0xFF	; 255
    1de4:	5f 4f       	sbci	r21, 0xFF	; 255
    1de6:	9d 30       	cpi	r25, 0x0D	; 13
    1de8:	21 f0       	breq	.+8      	; 0x1df2 <AddToSDBuffer+0x3c>
			SD_Buffer[index] = ' ';
    1dea:	90 e2       	ldi	r25, 0x20	; 32
    1dec:	90 83       	st	Z, r25
			SD_Buffer[index+1] = '\0';
    1dee:	fa 01       	movw	r30, r20
    1df0:	1f c0       	rjmp	.+62     	; 0x1e30 <AddToSDBuffer+0x7a>
		}
		else if (SD_Buffer[index-1] == ' '){//if a space was inserted last time in place of \r\n, user has pressed return twice.
    1df2:	d9 01       	movw	r26, r18
    1df4:	a7 59       	subi	r26, 0x97	; 151
    1df6:	b8 4f       	sbci	r27, 0xF8	; 248
    1df8:	9c 91       	ld	r25, X
    1dfa:	b9 01       	movw	r22, r18
    1dfc:	6e 5f       	subi	r22, 0xFE	; 254
    1dfe:	7f 4f       	sbci	r23, 0xFF	; 255
    1e00:	90 32       	cpi	r25, 0x20	; 32
    1e02:	79 f4       	brne	.+30     	; 0x1e22 <AddToSDBuffer+0x6c>
			SD_Buffer[index-1] = '\r'; //so put the missing \r\n in now
    1e04:	8c 93       	st	X, r24
			SD_Buffer[index] = '\n';
    1e06:	9a e0       	ldi	r25, 0x0A	; 10
    1e08:	90 83       	st	Z, r25
			SD_Buffer[index+1] = '\r';
    1e0a:	fa 01       	movw	r30, r20
    1e0c:	e6 59       	subi	r30, 0x96	; 150
    1e0e:	f8 4f       	sbci	r31, 0xF8	; 248
    1e10:	80 83       	st	Z, r24
			SD_Buffer[index+2] = '\n';
    1e12:	fb 01       	movw	r30, r22
    1e14:	e6 59       	subi	r30, 0x96	; 150
    1e16:	f8 4f       	sbci	r31, 0xF8	; 248
    1e18:	90 83       	st	Z, r25
			SD_Buffer[index+3] = '\0';
    1e1a:	f9 01       	movw	r30, r18
    1e1c:	e3 59       	subi	r30, 0x93	; 147
    1e1e:	f8 4f       	sbci	r31, 0xF8	; 248
    1e20:	16 c0       	rjmp	.+44     	; 0x1e4e <AddToSDBuffer+0x98>
		}
		else { //but if the last character entered was not recorded as a space (\r has already been pressed several times), then call a spade a spade.
			SD_Buffer[index] = '\r';
    1e22:	80 83       	st	Z, r24
			SD_Buffer[index+1] = '\n';
    1e24:	fa 01       	movw	r30, r20
    1e26:	e6 59       	subi	r30, 0x96	; 150
    1e28:	f8 4f       	sbci	r31, 0xF8	; 248
    1e2a:	9a e0       	ldi	r25, 0x0A	; 10
    1e2c:	90 83       	st	Z, r25
			SD_Buffer[index+2] = '\0';
    1e2e:	fb 01       	movw	r30, r22
    1e30:	e6 59       	subi	r30, 0x96	; 150
    1e32:	f8 4f       	sbci	r31, 0xF8	; 248
    1e34:	0c c0       	rjmp	.+24     	; 0x1e4e <AddToSDBuffer+0x98>
		}
	}
	else if (character == '\b'){ //for a backspace character,
		SD_Buffer[index-1] = '\0'; //turn the previous character into an "end of string" character 
    1e36:	f9 01       	movw	r30, r18
			SD_Buffer[index] = '\r';
			SD_Buffer[index+1] = '\n';
			SD_Buffer[index+2] = '\0';
		}
	}
	else if (character == '\b'){ //for a backspace character,
    1e38:	88 30       	cpi	r24, 0x08	; 8
    1e3a:	19 f4       	brne	.+6      	; 0x1e42 <AddToSDBuffer+0x8c>
		SD_Buffer[index-1] = '\0'; //turn the previous character into an "end of string" character 
    1e3c:	e7 59       	subi	r30, 0x97	; 151
    1e3e:	f8 4f       	sbci	r31, 0xF8	; 248
    1e40:	06 c0       	rjmp	.+12     	; 0x1e4e <AddToSDBuffer+0x98>
	}
	else{ //the most common scenario -- put a character at the end of the buffer, then follow with a \0;
		SD_Buffer[index] = character;
    1e42:	e6 59       	subi	r30, 0x96	; 150
    1e44:	f8 4f       	sbci	r31, 0xF8	; 248
    1e46:	80 83       	st	Z, r24
		SD_Buffer[index+1] = '\0';
    1e48:	f9 01       	movw	r30, r18
    1e4a:	e5 59       	subi	r30, 0x95	; 149
    1e4c:	f8 4f       	sbci	r31, 0xF8	; 248
    1e4e:	10 82       	st	Z, r1
	}
	
	prevcharacter = character; // save the character just pressed.
    1e50:	80 93 e2 02 	sts	0x02E2, r24	; 0x8002e2 <prevcharacter.4679>
    1e54:	08 95       	ret

00001e56 <LogKeystrokes>:
static FATFS DiskFATState;

/** FAT Fs structure to hold a FAT file handle for the log data write destination. */
static FIL LogFile;

void LogKeystrokes(){
    1e56:	cf 92       	push	r12
    1e58:	df 92       	push	r13
    1e5a:	ef 92       	push	r14
    1e5c:	ff 92       	push	r15
    1e5e:	0f 93       	push	r16
    1e60:	1f 93       	push	r17
    1e62:	cf 93       	push	r28
    1e64:	df 93       	push	r29
    1e66:	cd b7       	in	r28, 0x3d	; 61
    1e68:	de b7       	in	r29, 0x3e	; 62
    1e6a:	66 97       	sbiw	r28, 0x16	; 22
    1e6c:	0f b6       	in	r0, 0x3f	; 63
    1e6e:	f8 94       	cli
    1e70:	de bf       	out	0x3e, r29	; 62
    1e72:	0f be       	out	0x3f, r0	; 63
    1e74:	cd bf       	out	0x3d, r28	; 61
	uint16_t filenum;
	char code = 0;
	uint8_t modifier;
	uint8_t key;
	
	SD_Buffer[0] = '\0'; // A simple way to erase the SD_Buffer string -- first character is now the end of the string;
    1e76:	10 92 6a 07 	sts	0x076A, r1	; 0x80076a <SD_Buffer>

	diskstatus = MountFilesystem();
    1e7a:	08 df       	rcall	.-496    	; 0x1c8c <MountFilesystem>
	
	if (diskstatus != FR_OK){
    1e7c:	81 11       	cpse	r24, r1
    1e7e:	47 c0       	rjmp	.+142    	; 0x1f0e <LogKeystrokes+0xb8>
		Typewriter_Mode = PANIC_MODE;
		return;
	}
	else{
		GlowGreenLED(VERY_SLOW,SOLID);
    1e80:	61 e0       	ldi	r22, 0x01	; 1
    1e82:	80 e0       	ldi	r24, 0x00	; 0
    1e84:	1f de       	rcall	.-962    	; 0x1ac4 <GlowGreenLED>
	}
	
	filenum = eeprom_read_word((uint16_t *)FILENUM_ADDR); //filenum is the last used filenum, plus 1;
    1e86:	8a e0       	ldi	r24, 0x0A	; 10
    1e88:	92 e0       	ldi	r25, 0x02	; 2
    1e8a:	0e 94 9c 3b 	call	0x7738	; 0x7738 <eeprom_read_word>
    1e8e:	8c 01       	movw	r16, r24
	
	if (filenum>9999){
    1e90:	80 31       	cpi	r24, 0x10	; 16
    1e92:	97 42       	sbci	r25, 0x27	; 39
    1e94:	10 f0       	brcs	.+4      	; 0x1e9a <LogKeystrokes+0x44>
		filenum = 0;
    1e96:	00 e0       	ldi	r16, 0x00	; 0
    1e98:	10 e0       	ldi	r17, 0x00	; 0
	} //filenum can only be 4 digits long.

	do{ //increment filenum until a file name is found that does not already exist ("no file" error)
		filenum++; //increment file number
		sprintf(FileName,"PAGE%04d.TXT",filenum); //filename can only be 8 characters long (not including .TXT).
    1e9a:	8b e1       	ldi	r24, 0x1B	; 27
    1e9c:	c8 2e       	mov	r12, r24
    1e9e:	82 e0       	ldi	r24, 0x02	; 2
    1ea0:	d8 2e       	mov	r13, r24
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	e9 2e       	mov	r14, r25
    1ea6:	91 e0       	ldi	r25, 0x01	; 1
    1ea8:	f9 2e       	mov	r15, r25
	if (filenum>9999){
		filenum = 0;
	} //filenum can only be 4 digits long.

	do{ //increment filenum until a file name is found that does not already exist ("no file" error)
		filenum++; //increment file number
    1eaa:	0f 5f       	subi	r16, 0xFF	; 255
    1eac:	1f 4f       	sbci	r17, 0xFF	; 255
		sprintf(FileName,"PAGE%04d.TXT",filenum); //filename can only be 8 characters long (not including .TXT).
    1eae:	1f 93       	push	r17
    1eb0:	0f 93       	push	r16
    1eb2:	df 92       	push	r13
    1eb4:	cf 92       	push	r12
    1eb6:	ff 92       	push	r15
    1eb8:	ef 92       	push	r14
    1eba:	0e 94 e3 38 	call	0x71c6	; 0x71c6 <sprintf>
		filestatus = f_stat(FileName, &fileinfo);
    1ebe:	be 01       	movw	r22, r28
    1ec0:	6f 5f       	subi	r22, 0xFF	; 255
    1ec2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ec4:	80 e0       	ldi	r24, 0x00	; 0
    1ec6:	91 e0       	ldi	r25, 0x01	; 1
    1ec8:	0e 94 2d 23 	call	0x465a	; 0x465a <f_stat>
	}while(filestatus == FR_OK); //at the end of this loop, FileName is unique
    1ecc:	0f 90       	pop	r0
    1ece:	0f 90       	pop	r0
    1ed0:	0f 90       	pop	r0
    1ed2:	0f 90       	pop	r0
    1ed4:	0f 90       	pop	r0
    1ed6:	0f 90       	pop	r0
    1ed8:	88 23       	and	r24, r24
    1eda:	39 f3       	breq	.-50     	; 0x1eaa <LogKeystrokes+0x54>
	
	if (filestatus != FR_NO_FILE){ //if the error was not "no file" something went wrong
    1edc:	84 30       	cpi	r24, 0x04	; 4
    1ede:	b9 f4       	brne	.+46     	; 0x1f0e <LogKeystrokes+0xb8>
		Typewriter_Mode = PANIC_MODE; // go into panic mode
		return;
	}
	
	while(!code){ // wait for a key to be pressed before actually opening the file -- this stops lots of empty files from being created
		key = GetKey();
    1ee0:	0e 94 49 2c 	call	0x5892	; 0x5892 <GetKey>
    1ee4:	f8 2e       	mov	r15, r24
		modifier = GetModifier();
    1ee6:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
		code = GetASCIIKeyCode(key,modifier);
    1eea:	68 2f       	mov	r22, r24
    1eec:	8f 2d       	mov	r24, r15
    1eee:	0e 94 ac 2d 	call	0x5b58	; 0x5b58 <GetASCIIKeyCode>
	if (filestatus != FR_NO_FILE){ //if the error was not "no file" something went wrong
		Typewriter_Mode = PANIC_MODE; // go into panic mode
		return;
	}
	
	while(!code){ // wait for a key to be pressed before actually opening the file -- this stops lots of empty files from being created
    1ef2:	88 23       	and	r24, r24
    1ef4:	a9 f3       	breq	.-22     	; 0x1ee0 <LogKeystrokes+0x8a>
		key = GetKey();
		modifier = GetModifier();
		code = GetASCIIKeyCode(key,modifier);
	}
	if((code!='s')||(Ignore_Flag==0)){
    1ef6:	83 37       	cpi	r24, 0x73	; 115
    1ef8:	21 f4       	brne	.+8      	; 0x1f02 <LogKeystrokes+0xac>
    1efa:	90 91 63 06 	lds	r25, 0x0663	; 0x800663 <Ignore_Flag>
    1efe:	91 11       	cpse	r25, r1
		AddToSDBuffer(code); //save this first key pressed to the buffer.  there will be more, and those will be handled in the main loop
    1f00:	03 c0       	rjmp	.+6      	; 0x1f08 <LogKeystrokes+0xb2>
		Ignore_Flag = 0;
    1f02:	59 df       	rcall	.-334    	; 0x1db6 <AddToSDBuffer>
    1f04:	10 92 63 06 	sts	0x0663, r1	; 0x800663 <Ignore_Flag>
	}
	if (OpenLogFile()!=FR_OK){ //open the new log file.
    1f08:	92 de       	rcall	.-732    	; 0x1c2e <OpenLogFile>
    1f0a:	88 23       	and	r24, r24
    1f0c:	21 f0       	breq	.+8      	; 0x1f16 <LogKeystrokes+0xc0>
		Typewriter_Mode = PANIC_MODE; // go into panic mode
    1f0e:	8a e0       	ldi	r24, 0x0A	; 10
    1f10:	80 93 69 07 	sts	0x0769, r24	; 0x800769 <Typewriter_Mode>
		return;
    1f14:	57 c0       	rjmp	.+174    	; 0x1fc4 <LogKeystrokes+0x16e>
	}
	
	eeprom_write_word((uint16_t *)FILENUM_ADDR,filenum); // save the new filenumber for next time
    1f16:	b8 01       	movw	r22, r16
    1f18:	8a e0       	ldi	r24, 0x0A	; 10
    1f1a:	92 e0       	ldi	r25, 0x02	; 2
    1f1c:	0e 94 ca 3b 	call	0x7794	; 0x7794 <eeprom_write_word>
	
	myTimeoutCounter = 0; //reset timeout
    1f20:	10 92 62 06 	sts	0x0662, r1	; 0x800662 <myTimeoutCounter+0x1>
    1f24:	10 92 61 06 	sts	0x0661, r1	; 0x800661 <myTimeoutCounter>

	while(myTimeoutCounter < (SD_TIMEOUT)){ //keep listening for keys and adding them to buffer. Clear buffer occassionally.
    1f28:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <myTimeoutCounter>
    1f2c:	90 91 62 06 	lds	r25, 0x0662	; 0x800662 <myTimeoutCounter+0x1>
    1f30:	80 32       	cpi	r24, 0x20	; 32
    1f32:	9f 4b       	sbci	r25, 0xBF	; 191
    1f34:	08 f0       	brcs	.+2      	; 0x1f38 <LogKeystrokes+0xe2>
    1f36:	41 c0       	rjmp	.+130    	; 0x1fba <LogKeystrokes+0x164>
			key = GetKey();
    1f38:	0e 94 49 2c 	call	0x5892	; 0x5892 <GetKey>
    1f3c:	18 2f       	mov	r17, r24
			modifier = GetModifier();
    1f3e:	0e 94 3f 2b 	call	0x567e	; 0x567e <GetModifier>
			
			code = GetASCIIKeyCode(key, modifier);
    1f42:	68 2f       	mov	r22, r24
    1f44:	81 2f       	mov	r24, r17
    1f46:	0e 94 ac 2d 	call	0x5b58	; 0x5b58 <GetASCIIKeyCode>
			
			if(code){
    1f4a:	18 2f       	mov	r17, r24
    1f4c:	88 23       	and	r24, r24
				//if ((code == 's') && Ignore_Flag) code = 0; //if user is holding down S on startup, don't add this to file.
				//Ignore_Flag = 0;
				AddToSDBuffer(code); //this adds the character to the sd write buffer.
    1f4e:	b9 f0       	breq	.+46     	; 0x1f7e <LogKeystrokes+0x128>
    1f50:	32 df       	rcall	.-412    	; 0x1db6 <AddToSDBuffer>
				myTimeoutCounter = 0; //reset timeout every time a key is pressed.
    1f52:	10 92 62 06 	sts	0x0662, r1	; 0x800662 <myTimeoutCounter+0x1>
    1f56:	10 92 61 06 	sts	0x0661, r1	; 0x800661 <myTimeoutCounter>
			}
			if((code == '\r')||(code == '.')||(code == ',')||(code == '!')||(code == '?')||(code == ':')||(code == '\"')){
    1f5a:	1d 30       	cpi	r17, 0x0D	; 13
    1f5c:	61 f0       	breq	.+24     	; 0x1f76 <LogKeystrokes+0x120>
    1f5e:	81 2f       	mov	r24, r17
    1f60:	8d 7f       	andi	r24, 0xFD	; 253
    1f62:	8c 32       	cpi	r24, 0x2C	; 44
    1f64:	41 f0       	breq	.+16     	; 0x1f76 <LogKeystrokes+0x120>
    1f66:	8f ed       	ldi	r24, 0xDF	; 223
    1f68:	81 0f       	add	r24, r17
    1f6a:	82 30       	cpi	r24, 0x02	; 2
    1f6c:	20 f0       	brcs	.+8      	; 0x1f76 <LogKeystrokes+0x120>
    1f6e:	1f 33       	cpi	r17, 0x3F	; 63
    1f70:	11 f0       	breq	.+4      	; 0x1f76 <LogKeystrokes+0x120>
				GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
    1f72:	1a 33       	cpi	r17, 0x3A	; 58
    1f74:	21 f4       	brne	.+8      	; 0x1f7e <LogKeystrokes+0x128>
    1f76:	60 e0       	ldi	r22, 0x00	; 0
    1f78:	82 e0       	ldi	r24, 0x02	; 2
				WriteToLogFile(); //save your work every time enter key is pressed.
    1f7a:	a4 dd       	rcall	.-1208   	; 0x1ac4 <GlowGreenLED>
    1f7c:	c4 de       	rcall	.-632    	; 0x1d06 <WriteToLogFile>
    1f7e:	8f ec       	ldi	r24, 0xCF	; 207
    1f80:	97 e0       	ldi	r25, 0x07	; 7
    1f82:	01 97       	sbiw	r24, 0x01	; 1
    1f84:	f1 f7       	brne	.-4      	; 0x1f82 <LogKeystrokes+0x12c>
    1f86:	00 c0       	rjmp	.+0      	; 0x1f88 <LogKeystrokes+0x132>
    1f88:	00 00       	nop
			}
			Delay_MS(SENSE_DELAY);
			
			if ((myTimeoutCounter > SD_SAVE_TIME) && (SD_Buffer[0] != '\0')){
    1f8a:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <myTimeoutCounter>
    1f8e:	90 91 62 06 	lds	r25, 0x0662	; 0x800662 <myTimeoutCounter+0x1>
    1f92:	89 3b       	cpi	r24, 0xB9	; 185
    1f94:	9b 40       	sbci	r25, 0x0B	; 11
    1f96:	40 f2       	brcs	.-112    	; 0x1f28 <LogKeystrokes+0xd2>
    1f98:	80 91 6a 07 	lds	r24, 0x076A	; 0x80076a <SD_Buffer>
    1f9c:	88 23       	and	r24, r24
    1f9e:	21 f2       	breq	.-120    	; 0x1f28 <LogKeystrokes+0xd2>
				set_low(GREEN_LED);
    1fa0:	46 98       	cbi	0x08, 6	; 8
    1fa2:	8f ef       	ldi	r24, 0xFF	; 255
    1fa4:	9d e3       	ldi	r25, 0x3D	; 61
    1fa6:	29 e4       	ldi	r18, 0x49	; 73
    1fa8:	81 50       	subi	r24, 0x01	; 1
    1faa:	90 40       	sbci	r25, 0x00	; 0
    1fac:	20 40       	sbci	r18, 0x00	; 0
    1fae:	e1 f7       	brne	.-8      	; 0x1fa8 <LogKeystrokes+0x152>
				Delay_MS(3000);
				WriteToLogFile();
    1fb0:	00 c0       	rjmp	.+0      	; 0x1fb2 <LogKeystrokes+0x15c>
				set_high(GREEN_LED);
    1fb2:	00 00       	nop
    1fb4:	a8 de       	rcall	.-688    	; 0x1d06 <WriteToLogFile>
			}
	}
	
			GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
    1fb6:	46 9a       	sbi	0x08, 6	; 8
    1fb8:	b7 cf       	rjmp	.-146    	; 0x1f28 <LogKeystrokes+0xd2>
    1fba:	60 e0       	ldi	r22, 0x00	; 0
    1fbc:	82 e0       	ldi	r24, 0x02	; 2
			WriteToLogFile(); //save your work then "sleep" -- stop recording keystrokes
    1fbe:	82 dd       	rcall	.-1276   	; 0x1ac4 <GlowGreenLED>
    1fc0:	a2 de       	rcall	.-700    	; 0x1d06 <WriteToLogFile>
			CloseLogFile(); // close log file so a new one can be opened later.
    1fc2:	5c de       	rcall	.-840    	; 0x1c7c <CloseLogFile>
    1fc4:	66 96       	adiw	r28, 0x16	; 22
}
    1fc6:	0f b6       	in	r0, 0x3f	; 63
    1fc8:	f8 94       	cli
    1fca:	de bf       	out	0x3e, r29	; 62
    1fcc:	0f be       	out	0x3f, r0	; 63
    1fce:	cd bf       	out	0x3d, r28	; 61
    1fd0:	df 91       	pop	r29
    1fd2:	cf 91       	pop	r28
    1fd4:	1f 91       	pop	r17
    1fd6:	0f 91       	pop	r16
    1fd8:	ff 90       	pop	r15
    1fda:	ef 90       	pop	r14
    1fdc:	df 90       	pop	r13
    1fde:	cf 90       	pop	r12
    1fe0:	08 95       	ret

00001fe2 <dly_us>:
    1fe2:	23 b1       	in	r18, 0x03	; 3
    1fe4:	23 b1       	in	r18, 0x03	; 3
    1fe6:	01 97       	sbiw	r24, 0x01	; 1
    1fe8:	e1 f7       	brne	.-8      	; 0x1fe2 <dly_us>
    1fea:	08 95       	ret

00001fec <xmit_mmc>:
    1fec:	fc 01       	movw	r30, r24
    1fee:	68 0f       	add	r22, r24
    1ff0:	79 1f       	adc	r23, r25
    1ff2:	91 91       	ld	r25, Z+
    1ff4:	97 ff       	sbrs	r25, 7
    1ff6:	02 c0       	rjmp	.+4      	; 0x1ffc <xmit_mmc+0x10>
    1ff8:	2a 9a       	sbi	0x05, 2	; 5
    1ffa:	01 c0       	rjmp	.+2      	; 0x1ffe <xmit_mmc+0x12>
    1ffc:	2a 98       	cbi	0x05, 2	; 5
    1ffe:	29 9a       	sbi	0x05, 1	; 5
    2000:	29 98       	cbi	0x05, 1	; 5
    2002:	96 ff       	sbrs	r25, 6
    2004:	02 c0       	rjmp	.+4      	; 0x200a <xmit_mmc+0x1e>
    2006:	2a 9a       	sbi	0x05, 2	; 5
    2008:	01 c0       	rjmp	.+2      	; 0x200c <xmit_mmc+0x20>
    200a:	2a 98       	cbi	0x05, 2	; 5
    200c:	29 9a       	sbi	0x05, 1	; 5
    200e:	29 98       	cbi	0x05, 1	; 5
    2010:	95 ff       	sbrs	r25, 5
    2012:	02 c0       	rjmp	.+4      	; 0x2018 <xmit_mmc+0x2c>
    2014:	2a 9a       	sbi	0x05, 2	; 5
    2016:	01 c0       	rjmp	.+2      	; 0x201a <xmit_mmc+0x2e>
    2018:	2a 98       	cbi	0x05, 2	; 5
    201a:	29 9a       	sbi	0x05, 1	; 5
    201c:	29 98       	cbi	0x05, 1	; 5
    201e:	94 ff       	sbrs	r25, 4
    2020:	02 c0       	rjmp	.+4      	; 0x2026 <xmit_mmc+0x3a>
    2022:	2a 9a       	sbi	0x05, 2	; 5
    2024:	01 c0       	rjmp	.+2      	; 0x2028 <xmit_mmc+0x3c>
    2026:	2a 98       	cbi	0x05, 2	; 5
    2028:	29 9a       	sbi	0x05, 1	; 5
    202a:	29 98       	cbi	0x05, 1	; 5
    202c:	93 ff       	sbrs	r25, 3
    202e:	02 c0       	rjmp	.+4      	; 0x2034 <xmit_mmc+0x48>
    2030:	2a 9a       	sbi	0x05, 2	; 5
    2032:	01 c0       	rjmp	.+2      	; 0x2036 <xmit_mmc+0x4a>
    2034:	2a 98       	cbi	0x05, 2	; 5
    2036:	29 9a       	sbi	0x05, 1	; 5
    2038:	29 98       	cbi	0x05, 1	; 5
    203a:	92 ff       	sbrs	r25, 2
    203c:	02 c0       	rjmp	.+4      	; 0x2042 <xmit_mmc+0x56>
    203e:	2a 9a       	sbi	0x05, 2	; 5
    2040:	01 c0       	rjmp	.+2      	; 0x2044 <xmit_mmc+0x58>
    2042:	2a 98       	cbi	0x05, 2	; 5
    2044:	29 9a       	sbi	0x05, 1	; 5
    2046:	29 98       	cbi	0x05, 1	; 5
    2048:	91 ff       	sbrs	r25, 1
    204a:	02 c0       	rjmp	.+4      	; 0x2050 <xmit_mmc+0x64>
    204c:	2a 9a       	sbi	0x05, 2	; 5
    204e:	01 c0       	rjmp	.+2      	; 0x2052 <xmit_mmc+0x66>
    2050:	2a 98       	cbi	0x05, 2	; 5
    2052:	29 9a       	sbi	0x05, 1	; 5
    2054:	29 98       	cbi	0x05, 1	; 5
    2056:	90 ff       	sbrs	r25, 0
    2058:	02 c0       	rjmp	.+4      	; 0x205e <xmit_mmc+0x72>
    205a:	2a 9a       	sbi	0x05, 2	; 5
    205c:	01 c0       	rjmp	.+2      	; 0x2060 <xmit_mmc+0x74>
    205e:	2a 98       	cbi	0x05, 2	; 5
    2060:	29 9a       	sbi	0x05, 1	; 5
    2062:	29 98       	cbi	0x05, 1	; 5
    2064:	e6 17       	cp	r30, r22
    2066:	f7 07       	cpc	r31, r23
    2068:	21 f6       	brne	.-120    	; 0x1ff2 <xmit_mmc+0x6>
    206a:	08 95       	ret

0000206c <rcvr_mmc>:
    206c:	2a 9a       	sbi	0x05, 2	; 5
    206e:	fc 01       	movw	r30, r24
    2070:	68 0f       	add	r22, r24
    2072:	79 1f       	adc	r23, r25
    2074:	93 b1       	in	r25, 0x03	; 3
    2076:	29 9a       	sbi	0x05, 1	; 5
    2078:	29 98       	cbi	0x05, 1	; 5
    207a:	93 fb       	bst	r25, 3
    207c:	99 27       	eor	r25, r25
    207e:	90 f9       	bld	r25, 0
    2080:	99 0f       	add	r25, r25
    2082:	1b 99       	sbic	0x03, 3	; 3
    2084:	9f 5f       	subi	r25, 0xFF	; 255
    2086:	29 9a       	sbi	0x05, 1	; 5
    2088:	29 98       	cbi	0x05, 1	; 5
    208a:	99 0f       	add	r25, r25
    208c:	1b 99       	sbic	0x03, 3	; 3
    208e:	9f 5f       	subi	r25, 0xFF	; 255
    2090:	29 9a       	sbi	0x05, 1	; 5
    2092:	29 98       	cbi	0x05, 1	; 5
    2094:	99 0f       	add	r25, r25
    2096:	1b 99       	sbic	0x03, 3	; 3
    2098:	9f 5f       	subi	r25, 0xFF	; 255
    209a:	29 9a       	sbi	0x05, 1	; 5
    209c:	29 98       	cbi	0x05, 1	; 5
    209e:	99 0f       	add	r25, r25
    20a0:	1b 99       	sbic	0x03, 3	; 3
    20a2:	9f 5f       	subi	r25, 0xFF	; 255
    20a4:	29 9a       	sbi	0x05, 1	; 5
    20a6:	29 98       	cbi	0x05, 1	; 5
    20a8:	99 0f       	add	r25, r25
    20aa:	1b 99       	sbic	0x03, 3	; 3
    20ac:	9f 5f       	subi	r25, 0xFF	; 255
    20ae:	29 9a       	sbi	0x05, 1	; 5
    20b0:	29 98       	cbi	0x05, 1	; 5
    20b2:	99 0f       	add	r25, r25
    20b4:	1b 99       	sbic	0x03, 3	; 3
    20b6:	9f 5f       	subi	r25, 0xFF	; 255
    20b8:	29 9a       	sbi	0x05, 1	; 5
    20ba:	29 98       	cbi	0x05, 1	; 5
    20bc:	99 0f       	add	r25, r25
    20be:	1b 99       	sbic	0x03, 3	; 3
    20c0:	9f 5f       	subi	r25, 0xFF	; 255
    20c2:	29 9a       	sbi	0x05, 1	; 5
    20c4:	29 98       	cbi	0x05, 1	; 5
    20c6:	91 93       	st	Z+, r25
    20c8:	e6 17       	cp	r30, r22
    20ca:	f7 07       	cpc	r31, r23
    20cc:	99 f6       	brne	.-90     	; 0x2074 <rcvr_mmc+0x8>
    20ce:	08 95       	ret

000020d0 <wait_ready>:
    20d0:	0f 93       	push	r16
    20d2:	1f 93       	push	r17
    20d4:	cf 93       	push	r28
    20d6:	df 93       	push	r29
    20d8:	1f 92       	push	r1
    20da:	cd b7       	in	r28, 0x3d	; 61
    20dc:	de b7       	in	r29, 0x3e	; 62
    20de:	08 e8       	ldi	r16, 0x88	; 136
    20e0:	13 e1       	ldi	r17, 0x13	; 19
    20e2:	61 e0       	ldi	r22, 0x01	; 1
    20e4:	70 e0       	ldi	r23, 0x00	; 0
    20e6:	ce 01       	movw	r24, r28
    20e8:	01 96       	adiw	r24, 0x01	; 1
    20ea:	c0 df       	rcall	.-128    	; 0x206c <rcvr_mmc>
    20ec:	89 81       	ldd	r24, Y+1	; 0x01
    20ee:	8f 3f       	cpi	r24, 0xFF	; 255
    20f0:	31 f0       	breq	.+12     	; 0x20fe <wait_ready+0x2e>
    20f2:	84 e6       	ldi	r24, 0x64	; 100
    20f4:	90 e0       	ldi	r25, 0x00	; 0
    20f6:	75 df       	rcall	.-278    	; 0x1fe2 <dly_us>
    20f8:	01 50       	subi	r16, 0x01	; 1
    20fa:	11 09       	sbc	r17, r1
    20fc:	91 f7       	brne	.-28     	; 0x20e2 <wait_ready+0x12>
    20fe:	81 e0       	ldi	r24, 0x01	; 1
    2100:	90 e0       	ldi	r25, 0x00	; 0
    2102:	01 2b       	or	r16, r17
    2104:	11 f4       	brne	.+4      	; 0x210a <wait_ready+0x3a>
    2106:	80 e0       	ldi	r24, 0x00	; 0
    2108:	90 e0       	ldi	r25, 0x00	; 0
    210a:	0f 90       	pop	r0
    210c:	df 91       	pop	r29
    210e:	cf 91       	pop	r28
    2110:	1f 91       	pop	r17
    2112:	0f 91       	pop	r16
    2114:	08 95       	ret

00002116 <deselect>:
    2116:	cf 93       	push	r28
    2118:	df 93       	push	r29
    211a:	1f 92       	push	r1
    211c:	cd b7       	in	r28, 0x3d	; 61
    211e:	de b7       	in	r29, 0x3e	; 62
    2120:	59 9a       	sbi	0x0b, 1	; 11
    2122:	61 e0       	ldi	r22, 0x01	; 1
    2124:	70 e0       	ldi	r23, 0x00	; 0
    2126:	ce 01       	movw	r24, r28
    2128:	01 96       	adiw	r24, 0x01	; 1
    212a:	a0 df       	rcall	.-192    	; 0x206c <rcvr_mmc>
    212c:	0f 90       	pop	r0
    212e:	df 91       	pop	r29
    2130:	cf 91       	pop	r28
    2132:	08 95       	ret

00002134 <select>:
    2134:	0f 93       	push	r16
    2136:	1f 93       	push	r17
    2138:	cf 93       	push	r28
    213a:	df 93       	push	r29
    213c:	1f 92       	push	r1
    213e:	cd b7       	in	r28, 0x3d	; 61
    2140:	de b7       	in	r29, 0x3e	; 62
    2142:	59 98       	cbi	0x0b, 1	; 11
    2144:	61 e0       	ldi	r22, 0x01	; 1
    2146:	70 e0       	ldi	r23, 0x00	; 0
    2148:	ce 01       	movw	r24, r28
    214a:	01 96       	adiw	r24, 0x01	; 1
    214c:	8f df       	rcall	.-226    	; 0x206c <rcvr_mmc>
    214e:	c0 df       	rcall	.-128    	; 0x20d0 <wait_ready>
    2150:	8c 01       	movw	r16, r24
    2152:	89 2b       	or	r24, r25
    2154:	11 f4       	brne	.+4      	; 0x215a <select+0x26>
    2156:	df df       	rcall	.-66     	; 0x2116 <deselect>
    2158:	02 c0       	rjmp	.+4      	; 0x215e <select+0x2a>
    215a:	01 e0       	ldi	r16, 0x01	; 1
    215c:	10 e0       	ldi	r17, 0x00	; 0
    215e:	c8 01       	movw	r24, r16
    2160:	0f 90       	pop	r0
    2162:	df 91       	pop	r29
    2164:	cf 91       	pop	r28
    2166:	1f 91       	pop	r17
    2168:	0f 91       	pop	r16
    216a:	08 95       	ret

0000216c <rcvr_datablock>:
    216c:	cf 92       	push	r12
    216e:	df 92       	push	r13
    2170:	ef 92       	push	r14
    2172:	ff 92       	push	r15
    2174:	0f 93       	push	r16
    2176:	1f 93       	push	r17
    2178:	cf 93       	push	r28
    217a:	df 93       	push	r29
    217c:	00 d0       	rcall	.+0      	; 0x217e <rcvr_datablock+0x12>
    217e:	cd b7       	in	r28, 0x3d	; 61
    2180:	de b7       	in	r29, 0x3e	; 62
    2182:	7c 01       	movw	r14, r24
    2184:	6b 01       	movw	r12, r22
    2186:	08 ee       	ldi	r16, 0xE8	; 232
    2188:	13 e0       	ldi	r17, 0x03	; 3
    218a:	61 e0       	ldi	r22, 0x01	; 1
    218c:	70 e0       	ldi	r23, 0x00	; 0
    218e:	ce 01       	movw	r24, r28
    2190:	01 96       	adiw	r24, 0x01	; 1
    2192:	6c df       	rcall	.-296    	; 0x206c <rcvr_mmc>
    2194:	89 81       	ldd	r24, Y+1	; 0x01
    2196:	8f 3f       	cpi	r24, 0xFF	; 255
    2198:	71 f0       	breq	.+28     	; 0x21b6 <rcvr_datablock+0x4a>
    219a:	89 81       	ldd	r24, Y+1	; 0x01
    219c:	8e 3f       	cpi	r24, 0xFE	; 254
    219e:	91 f4       	brne	.+36     	; 0x21c4 <rcvr_datablock+0x58>
    21a0:	b6 01       	movw	r22, r12
    21a2:	c7 01       	movw	r24, r14
    21a4:	63 df       	rcall	.-314    	; 0x206c <rcvr_mmc>
    21a6:	62 e0       	ldi	r22, 0x02	; 2
    21a8:	70 e0       	ldi	r23, 0x00	; 0
    21aa:	ce 01       	movw	r24, r28
    21ac:	01 96       	adiw	r24, 0x01	; 1
    21ae:	5e df       	rcall	.-324    	; 0x206c <rcvr_mmc>
    21b0:	81 e0       	ldi	r24, 0x01	; 1
    21b2:	90 e0       	ldi	r25, 0x00	; 0
    21b4:	09 c0       	rjmp	.+18     	; 0x21c8 <rcvr_datablock+0x5c>
    21b6:	84 e6       	ldi	r24, 0x64	; 100
    21b8:	90 e0       	ldi	r25, 0x00	; 0
    21ba:	13 df       	rcall	.-474    	; 0x1fe2 <dly_us>
    21bc:	01 50       	subi	r16, 0x01	; 1
    21be:	11 09       	sbc	r17, r1
    21c0:	21 f7       	brne	.-56     	; 0x218a <rcvr_datablock+0x1e>
    21c2:	eb cf       	rjmp	.-42     	; 0x219a <rcvr_datablock+0x2e>
    21c4:	80 e0       	ldi	r24, 0x00	; 0
    21c6:	90 e0       	ldi	r25, 0x00	; 0
    21c8:	0f 90       	pop	r0
    21ca:	0f 90       	pop	r0
    21cc:	df 91       	pop	r29
    21ce:	cf 91       	pop	r28
    21d0:	1f 91       	pop	r17
    21d2:	0f 91       	pop	r16
    21d4:	ff 90       	pop	r15
    21d6:	ef 90       	pop	r14
    21d8:	df 90       	pop	r13
    21da:	cf 90       	pop	r12
    21dc:	08 95       	ret

000021de <send_cmd>:
    21de:	df 92       	push	r13
    21e0:	ef 92       	push	r14
    21e2:	ff 92       	push	r15
    21e4:	0f 93       	push	r16
    21e6:	1f 93       	push	r17
    21e8:	cf 93       	push	r28
    21ea:	df 93       	push	r29
    21ec:	cd b7       	in	r28, 0x3d	; 61
    21ee:	de b7       	in	r29, 0x3e	; 62
    21f0:	27 97       	sbiw	r28, 0x07	; 7
    21f2:	0f b6       	in	r0, 0x3f	; 63
    21f4:	f8 94       	cli
    21f6:	de bf       	out	0x3e, r29	; 62
    21f8:	0f be       	out	0x3f, r0	; 63
    21fa:	cd bf       	out	0x3d, r28	; 61
    21fc:	18 2f       	mov	r17, r24
    21fe:	04 2f       	mov	r16, r20
    2200:	f5 2e       	mov	r15, r21
    2202:	e6 2e       	mov	r14, r22
    2204:	d7 2e       	mov	r13, r23
    2206:	87 ff       	sbrs	r24, 7
    2208:	09 c0       	rjmp	.+18     	; 0x221c <send_cmd+0x3e>
    220a:	40 e0       	ldi	r20, 0x00	; 0
    220c:	50 e0       	ldi	r21, 0x00	; 0
    220e:	ba 01       	movw	r22, r20
    2210:	87 e3       	ldi	r24, 0x37	; 55
    2212:	e5 df       	rcall	.-54     	; 0x21de <send_cmd>
    2214:	82 30       	cpi	r24, 0x02	; 2
    2216:	08 f0       	brcs	.+2      	; 0x221a <send_cmd+0x3c>
    2218:	39 c0       	rjmp	.+114    	; 0x228c <send_cmd+0xae>
    221a:	1f 77       	andi	r17, 0x7F	; 127
    221c:	1c 30       	cpi	r17, 0x0C	; 12
    221e:	51 f4       	brne	.+20     	; 0x2234 <send_cmd+0x56>
    2220:	81 2f       	mov	r24, r17
    2222:	80 64       	ori	r24, 0x40	; 64
    2224:	89 83       	std	Y+1, r24	; 0x01
    2226:	da 82       	std	Y+2, r13	; 0x02
    2228:	eb 82       	std	Y+3, r14	; 0x03
    222a:	fc 82       	std	Y+4, r15	; 0x04
    222c:	0d 83       	std	Y+5, r16	; 0x05
    222e:	11 23       	and	r17, r17
    2230:	29 f1       	breq	.+74     	; 0x227c <send_cmd+0x9e>
    2232:	06 c0       	rjmp	.+12     	; 0x2240 <send_cmd+0x62>
    2234:	70 df       	rcall	.-288    	; 0x2116 <deselect>
    2236:	7e df       	rcall	.-260    	; 0x2134 <select>
    2238:	89 2b       	or	r24, r25
    223a:	91 f7       	brne	.-28     	; 0x2220 <send_cmd+0x42>
    223c:	8f ef       	ldi	r24, 0xFF	; 255
    223e:	26 c0       	rjmp	.+76     	; 0x228c <send_cmd+0xae>
    2240:	18 30       	cpi	r17, 0x08	; 8
    2242:	11 f4       	brne	.+4      	; 0x2248 <send_cmd+0x6a>
    2244:	87 e8       	ldi	r24, 0x87	; 135
    2246:	01 c0       	rjmp	.+2      	; 0x224a <send_cmd+0x6c>
    2248:	81 e0       	ldi	r24, 0x01	; 1
    224a:	8e 83       	std	Y+6, r24	; 0x06
    224c:	66 e0       	ldi	r22, 0x06	; 6
    224e:	70 e0       	ldi	r23, 0x00	; 0
    2250:	ce 01       	movw	r24, r28
    2252:	01 96       	adiw	r24, 0x01	; 1
    2254:	cb de       	rcall	.-618    	; 0x1fec <xmit_mmc>
    2256:	1c 30       	cpi	r17, 0x0C	; 12
    2258:	29 f4       	brne	.+10     	; 0x2264 <send_cmd+0x86>
    225a:	61 e0       	ldi	r22, 0x01	; 1
    225c:	70 e0       	ldi	r23, 0x00	; 0
    225e:	ce 01       	movw	r24, r28
    2260:	07 96       	adiw	r24, 0x07	; 7
    2262:	04 df       	rcall	.-504    	; 0x206c <rcvr_mmc>
    2264:	1a e0       	ldi	r17, 0x0A	; 10
    2266:	61 e0       	ldi	r22, 0x01	; 1
    2268:	70 e0       	ldi	r23, 0x00	; 0
    226a:	ce 01       	movw	r24, r28
    226c:	07 96       	adiw	r24, 0x07	; 7
    226e:	fe de       	rcall	.-516    	; 0x206c <rcvr_mmc>
    2270:	8f 81       	ldd	r24, Y+7	; 0x07
    2272:	87 ff       	sbrs	r24, 7
    2274:	0b c0       	rjmp	.+22     	; 0x228c <send_cmd+0xae>
    2276:	11 50       	subi	r17, 0x01	; 1
    2278:	b1 f7       	brne	.-20     	; 0x2266 <send_cmd+0x88>
    227a:	08 c0       	rjmp	.+16     	; 0x228c <send_cmd+0xae>
    227c:	85 e9       	ldi	r24, 0x95	; 149
    227e:	8e 83       	std	Y+6, r24	; 0x06
    2280:	66 e0       	ldi	r22, 0x06	; 6
    2282:	70 e0       	ldi	r23, 0x00	; 0
    2284:	ce 01       	movw	r24, r28
    2286:	01 96       	adiw	r24, 0x01	; 1
    2288:	b1 de       	rcall	.-670    	; 0x1fec <xmit_mmc>
    228a:	ec cf       	rjmp	.-40     	; 0x2264 <send_cmd+0x86>
    228c:	27 96       	adiw	r28, 0x07	; 7
    228e:	0f b6       	in	r0, 0x3f	; 63
    2290:	f8 94       	cli
    2292:	de bf       	out	0x3e, r29	; 62
    2294:	0f be       	out	0x3f, r0	; 63
    2296:	cd bf       	out	0x3d, r28	; 61
    2298:	df 91       	pop	r29
    229a:	cf 91       	pop	r28
    229c:	1f 91       	pop	r17
    229e:	0f 91       	pop	r16
    22a0:	ff 90       	pop	r15
    22a2:	ef 90       	pop	r14
    22a4:	df 90       	pop	r13
    22a6:	08 95       	ret

000022a8 <xmit_datablock>:
    22a8:	ef 92       	push	r14
    22aa:	ff 92       	push	r15
    22ac:	1f 93       	push	r17
    22ae:	cf 93       	push	r28
    22b0:	df 93       	push	r29
    22b2:	00 d0       	rcall	.+0      	; 0x22b4 <xmit_datablock+0xc>
    22b4:	cd b7       	in	r28, 0x3d	; 61
    22b6:	de b7       	in	r29, 0x3e	; 62
    22b8:	7c 01       	movw	r14, r24
    22ba:	16 2f       	mov	r17, r22
    22bc:	09 df       	rcall	.-494    	; 0x20d0 <wait_ready>
    22be:	00 97       	sbiw	r24, 0x00	; 0
    22c0:	11 f1       	breq	.+68     	; 0x2306 <xmit_datablock+0x5e>
    22c2:	19 83       	std	Y+1, r17	; 0x01
    22c4:	61 e0       	ldi	r22, 0x01	; 1
    22c6:	70 e0       	ldi	r23, 0x00	; 0
    22c8:	ce 01       	movw	r24, r28
    22ca:	01 96       	adiw	r24, 0x01	; 1
    22cc:	8f de       	rcall	.-738    	; 0x1fec <xmit_mmc>
    22ce:	1d 3f       	cpi	r17, 0xFD	; 253
    22d0:	c1 f0       	breq	.+48     	; 0x2302 <xmit_datablock+0x5a>
    22d2:	60 e0       	ldi	r22, 0x00	; 0
    22d4:	72 e0       	ldi	r23, 0x02	; 2
    22d6:	c7 01       	movw	r24, r14
    22d8:	89 de       	rcall	.-750    	; 0x1fec <xmit_mmc>
    22da:	62 e0       	ldi	r22, 0x02	; 2
    22dc:	70 e0       	ldi	r23, 0x00	; 0
    22de:	ce 01       	movw	r24, r28
    22e0:	01 96       	adiw	r24, 0x01	; 1
    22e2:	c4 de       	rcall	.-632    	; 0x206c <rcvr_mmc>
    22e4:	61 e0       	ldi	r22, 0x01	; 1
    22e6:	70 e0       	ldi	r23, 0x00	; 0
    22e8:	ce 01       	movw	r24, r28
    22ea:	01 96       	adiw	r24, 0x01	; 1
    22ec:	bf de       	rcall	.-642    	; 0x206c <rcvr_mmc>
    22ee:	89 81       	ldd	r24, Y+1	; 0x01
    22f0:	8f 71       	andi	r24, 0x1F	; 31
    22f2:	31 e0       	ldi	r19, 0x01	; 1
    22f4:	20 e0       	ldi	r18, 0x00	; 0
    22f6:	85 30       	cpi	r24, 0x05	; 5
    22f8:	09 f0       	breq	.+2      	; 0x22fc <xmit_datablock+0x54>
    22fa:	30 e0       	ldi	r19, 0x00	; 0
    22fc:	83 2f       	mov	r24, r19
    22fe:	92 2f       	mov	r25, r18
    2300:	02 c0       	rjmp	.+4      	; 0x2306 <xmit_datablock+0x5e>
    2302:	81 e0       	ldi	r24, 0x01	; 1
    2304:	90 e0       	ldi	r25, 0x00	; 0
    2306:	0f 90       	pop	r0
    2308:	0f 90       	pop	r0
    230a:	df 91       	pop	r29
    230c:	cf 91       	pop	r28
    230e:	1f 91       	pop	r17
    2310:	ff 90       	pop	r15
    2312:	ef 90       	pop	r14
    2314:	08 95       	ret

00002316 <disk_status>:
    2316:	81 11       	cpse	r24, r1
    2318:	03 c0       	rjmp	.+6      	; 0x2320 <disk_status+0xa>
    231a:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <Stat>
    231e:	08 95       	ret
    2320:	81 e0       	ldi	r24, 0x01	; 1
    2322:	08 95       	ret

00002324 <disk_initialize>:
    2324:	ef 92       	push	r14
    2326:	ff 92       	push	r15
    2328:	0f 93       	push	r16
    232a:	1f 93       	push	r17
    232c:	cf 93       	push	r28
    232e:	df 93       	push	r29
    2330:	00 d0       	rcall	.+0      	; 0x2332 <disk_initialize+0xe>
    2332:	00 d0       	rcall	.+0      	; 0x2334 <disk_initialize+0x10>
    2334:	cd b7       	in	r28, 0x3d	; 61
    2336:	de b7       	in	r29, 0x3e	; 62
    2338:	81 11       	cpse	r24, r1
    233a:	78 c0       	rjmp	.+240    	; 0x242c <disk_initialize+0x108>
    233c:	80 e1       	ldi	r24, 0x10	; 16
    233e:	97 e2       	ldi	r25, 0x27	; 39
    2340:	50 de       	rcall	.-864    	; 0x1fe2 <dly_us>
    2342:	51 9a       	sbi	0x0a, 1	; 10
    2344:	59 9a       	sbi	0x0b, 1	; 11
    2346:	29 98       	cbi	0x05, 1	; 5
    2348:	21 9a       	sbi	0x04, 1	; 4
    234a:	29 98       	cbi	0x05, 1	; 5
    234c:	22 9a       	sbi	0x04, 2	; 4
    234e:	2b 9a       	sbi	0x05, 3	; 5
    2350:	1a e0       	ldi	r17, 0x0A	; 10
    2352:	61 e0       	ldi	r22, 0x01	; 1
    2354:	70 e0       	ldi	r23, 0x00	; 0
    2356:	ce 01       	movw	r24, r28
    2358:	01 96       	adiw	r24, 0x01	; 1
    235a:	88 de       	rcall	.-752    	; 0x206c <rcvr_mmc>
    235c:	11 50       	subi	r17, 0x01	; 1
    235e:	c9 f7       	brne	.-14     	; 0x2352 <disk_initialize+0x2e>
    2360:	40 e0       	ldi	r20, 0x00	; 0
    2362:	50 e0       	ldi	r21, 0x00	; 0
    2364:	ba 01       	movw	r22, r20
    2366:	80 e0       	ldi	r24, 0x00	; 0
    2368:	3a df       	rcall	.-396    	; 0x21de <send_cmd>
    236a:	81 30       	cpi	r24, 0x01	; 1
    236c:	09 f0       	breq	.+2      	; 0x2370 <disk_initialize+0x4c>
    236e:	42 c0       	rjmp	.+132    	; 0x23f4 <disk_initialize+0xd0>
    2370:	4a ea       	ldi	r20, 0xAA	; 170
    2372:	51 e0       	ldi	r21, 0x01	; 1
    2374:	60 e0       	ldi	r22, 0x00	; 0
    2376:	70 e0       	ldi	r23, 0x00	; 0
    2378:	88 e0       	ldi	r24, 0x08	; 8
    237a:	31 df       	rcall	.-414    	; 0x21de <send_cmd>
    237c:	81 30       	cpi	r24, 0x01	; 1
    237e:	e1 f4       	brne	.+56     	; 0x23b8 <disk_initialize+0x94>
    2380:	64 e0       	ldi	r22, 0x04	; 4
    2382:	70 e0       	ldi	r23, 0x00	; 0
    2384:	ce 01       	movw	r24, r28
    2386:	01 96       	adiw	r24, 0x01	; 1
    2388:	71 de       	rcall	.-798    	; 0x206c <rcvr_mmc>
    238a:	8b 81       	ldd	r24, Y+3	; 0x03
    238c:	81 30       	cpi	r24, 0x01	; 1
    238e:	91 f5       	brne	.+100    	; 0x23f4 <disk_initialize+0xd0>
    2390:	8c 81       	ldd	r24, Y+4	; 0x04
    2392:	8a 3a       	cpi	r24, 0xAA	; 170
    2394:	79 f5       	brne	.+94     	; 0x23f4 <disk_initialize+0xd0>
    2396:	08 ee       	ldi	r16, 0xE8	; 232
    2398:	13 e0       	ldi	r17, 0x03	; 3
    239a:	40 e0       	ldi	r20, 0x00	; 0
    239c:	50 e0       	ldi	r21, 0x00	; 0
    239e:	60 e0       	ldi	r22, 0x00	; 0
    23a0:	70 e4       	ldi	r23, 0x40	; 64
    23a2:	89 ea       	ldi	r24, 0xA9	; 169
    23a4:	1c df       	rcall	.-456    	; 0x21de <send_cmd>
    23a6:	88 23       	and	r24, r24
    23a8:	39 f1       	breq	.+78     	; 0x23f8 <disk_initialize+0xd4>
    23aa:	88 ee       	ldi	r24, 0xE8	; 232
    23ac:	93 e0       	ldi	r25, 0x03	; 3
    23ae:	19 de       	rcall	.-974    	; 0x1fe2 <dly_us>
    23b0:	01 50       	subi	r16, 0x01	; 1
    23b2:	11 09       	sbc	r17, r1
    23b4:	91 f7       	brne	.-28     	; 0x239a <disk_initialize+0x76>
    23b6:	1e c0       	rjmp	.+60     	; 0x23f4 <disk_initialize+0xd0>
    23b8:	40 e0       	ldi	r20, 0x00	; 0
    23ba:	50 e0       	ldi	r21, 0x00	; 0
    23bc:	ba 01       	movw	r22, r20
    23be:	89 ea       	ldi	r24, 0xA9	; 169
    23c0:	0e df       	rcall	.-484    	; 0x21de <send_cmd>
    23c2:	82 30       	cpi	r24, 0x02	; 2
    23c4:	18 f0       	brcs	.+6      	; 0x23cc <disk_initialize+0xa8>
    23c6:	11 e0       	ldi	r17, 0x01	; 1
    23c8:	01 e0       	ldi	r16, 0x01	; 1
    23ca:	02 c0       	rjmp	.+4      	; 0x23d0 <disk_initialize+0xac>
    23cc:	19 ea       	ldi	r17, 0xA9	; 169
    23ce:	02 e0       	ldi	r16, 0x02	; 2
    23d0:	88 ee       	ldi	r24, 0xE8	; 232
    23d2:	e8 2e       	mov	r14, r24
    23d4:	83 e0       	ldi	r24, 0x03	; 3
    23d6:	f8 2e       	mov	r15, r24
    23d8:	40 e0       	ldi	r20, 0x00	; 0
    23da:	50 e0       	ldi	r21, 0x00	; 0
    23dc:	ba 01       	movw	r22, r20
    23de:	81 2f       	mov	r24, r17
    23e0:	fe de       	rcall	.-516    	; 0x21de <send_cmd>
    23e2:	88 23       	and	r24, r24
    23e4:	39 f1       	breq	.+78     	; 0x2434 <disk_initialize+0x110>
    23e6:	88 ee       	ldi	r24, 0xE8	; 232
    23e8:	93 e0       	ldi	r25, 0x03	; 3
    23ea:	fb dd       	rcall	.-1034   	; 0x1fe2 <dly_us>
    23ec:	81 e0       	ldi	r24, 0x01	; 1
    23ee:	e8 1a       	sub	r14, r24
    23f0:	f1 08       	sbc	r15, r1
    23f2:	91 f7       	brne	.-28     	; 0x23d8 <disk_initialize+0xb4>
    23f4:	00 e0       	ldi	r16, 0x00	; 0
    23f6:	10 c0       	rjmp	.+32     	; 0x2418 <disk_initialize+0xf4>
    23f8:	40 e0       	ldi	r20, 0x00	; 0
    23fa:	50 e0       	ldi	r21, 0x00	; 0
    23fc:	ba 01       	movw	r22, r20
    23fe:	8a e3       	ldi	r24, 0x3A	; 58
    2400:	ee de       	rcall	.-548    	; 0x21de <send_cmd>
    2402:	81 11       	cpse	r24, r1
    2404:	f7 cf       	rjmp	.-18     	; 0x23f4 <disk_initialize+0xd0>
    2406:	64 e0       	ldi	r22, 0x04	; 4
    2408:	70 e0       	ldi	r23, 0x00	; 0
    240a:	ce 01       	movw	r24, r28
    240c:	01 96       	adiw	r24, 0x01	; 1
    240e:	2e de       	rcall	.-932    	; 0x206c <rcvr_mmc>
    2410:	89 81       	ldd	r24, Y+1	; 0x01
    2412:	86 fd       	sbrc	r24, 6
    2414:	0d c0       	rjmp	.+26     	; 0x2430 <disk_initialize+0x10c>
    2416:	04 e0       	ldi	r16, 0x04	; 4
    2418:	00 93 35 05 	sts	0x0535, r16	; 0x800535 <CardType>
    241c:	11 e0       	ldi	r17, 0x01	; 1
    241e:	01 11       	cpse	r16, r1
    2420:	10 e0       	ldi	r17, 0x00	; 0
    2422:	10 93 0d 01 	sts	0x010D, r17	; 0x80010d <Stat>
    2426:	77 de       	rcall	.-786    	; 0x2116 <deselect>
    2428:	81 2f       	mov	r24, r17
    242a:	0d c0       	rjmp	.+26     	; 0x2446 <disk_initialize+0x122>
    242c:	83 e0       	ldi	r24, 0x03	; 3
    242e:	0b c0       	rjmp	.+22     	; 0x2446 <disk_initialize+0x122>
    2430:	0c e0       	ldi	r16, 0x0C	; 12
    2432:	f2 cf       	rjmp	.-28     	; 0x2418 <disk_initialize+0xf4>
    2434:	40 e0       	ldi	r20, 0x00	; 0
    2436:	52 e0       	ldi	r21, 0x02	; 2
    2438:	60 e0       	ldi	r22, 0x00	; 0
    243a:	70 e0       	ldi	r23, 0x00	; 0
    243c:	80 e1       	ldi	r24, 0x10	; 16
    243e:	cf de       	rcall	.-610    	; 0x21de <send_cmd>
    2440:	81 11       	cpse	r24, r1
    2442:	d8 cf       	rjmp	.-80     	; 0x23f4 <disk_initialize+0xd0>
    2444:	e9 cf       	rjmp	.-46     	; 0x2418 <disk_initialize+0xf4>
    2446:	0f 90       	pop	r0
    2448:	0f 90       	pop	r0
    244a:	0f 90       	pop	r0
    244c:	0f 90       	pop	r0
    244e:	df 91       	pop	r29
    2450:	cf 91       	pop	r28
    2452:	1f 91       	pop	r17
    2454:	0f 91       	pop	r16
    2456:	ff 90       	pop	r15
    2458:	ef 90       	pop	r14
    245a:	08 95       	ret

0000245c <disk_read>:
    245c:	ef 92       	push	r14
    245e:	ff 92       	push	r15
    2460:	0f 93       	push	r16
    2462:	1f 93       	push	r17
    2464:	cf 93       	push	r28
    2466:	7b 01       	movw	r14, r22
    2468:	ba 01       	movw	r22, r20
    246a:	a9 01       	movw	r20, r18
    246c:	81 11       	cpse	r24, r1
    246e:	03 c0       	rjmp	.+6      	; 0x2476 <disk_read+0x1a>
    2470:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <Stat>
    2474:	01 c0       	rjmp	.+2      	; 0x2478 <disk_read+0x1c>
    2476:	81 e0       	ldi	r24, 0x01	; 1
    2478:	80 fd       	sbrc	r24, 0
    247a:	2d c0       	rjmp	.+90     	; 0x24d6 <disk_read+0x7a>
    247c:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <CardType>
    2480:	83 fd       	sbrc	r24, 3
    2482:	07 c0       	rjmp	.+14     	; 0x2492 <disk_read+0x36>
    2484:	89 e0       	ldi	r24, 0x09	; 9
    2486:	44 0f       	add	r20, r20
    2488:	55 1f       	adc	r21, r21
    248a:	66 1f       	adc	r22, r22
    248c:	77 1f       	adc	r23, r23
    248e:	8a 95       	dec	r24
    2490:	d1 f7       	brne	.-12     	; 0x2486 <disk_read+0x2a>
    2492:	02 30       	cpi	r16, 0x02	; 2
    2494:	11 05       	cpc	r17, r1
    2496:	10 f4       	brcc	.+4      	; 0x249c <disk_read+0x40>
    2498:	c1 e1       	ldi	r28, 0x11	; 17
    249a:	01 c0       	rjmp	.+2      	; 0x249e <disk_read+0x42>
    249c:	c2 e1       	ldi	r28, 0x12	; 18
    249e:	8c 2f       	mov	r24, r28
    24a0:	9e de       	rcall	.-708    	; 0x21de <send_cmd>
    24a2:	81 11       	cpse	r24, r1
    24a4:	12 c0       	rjmp	.+36     	; 0x24ca <disk_read+0x6e>
    24a6:	60 e0       	ldi	r22, 0x00	; 0
    24a8:	72 e0       	ldi	r23, 0x02	; 2
    24aa:	c7 01       	movw	r24, r14
    24ac:	5f de       	rcall	.-834    	; 0x216c <rcvr_datablock>
    24ae:	89 2b       	or	r24, r25
    24b0:	29 f0       	breq	.+10     	; 0x24bc <disk_read+0x60>
    24b2:	8e ef       	ldi	r24, 0xFE	; 254
    24b4:	f8 1a       	sub	r15, r24
    24b6:	01 50       	subi	r16, 0x01	; 1
    24b8:	11 09       	sbc	r17, r1
    24ba:	a9 f7       	brne	.-22     	; 0x24a6 <disk_read+0x4a>
    24bc:	c2 31       	cpi	r28, 0x12	; 18
    24be:	29 f4       	brne	.+10     	; 0x24ca <disk_read+0x6e>
    24c0:	40 e0       	ldi	r20, 0x00	; 0
    24c2:	50 e0       	ldi	r21, 0x00	; 0
    24c4:	ba 01       	movw	r22, r20
    24c6:	8c e0       	ldi	r24, 0x0C	; 12
    24c8:	8a de       	rcall	.-748    	; 0x21de <send_cmd>
    24ca:	25 de       	rcall	.-950    	; 0x2116 <deselect>
    24cc:	81 e0       	ldi	r24, 0x01	; 1
    24ce:	01 2b       	or	r16, r17
    24d0:	19 f4       	brne	.+6      	; 0x24d8 <disk_read+0x7c>
    24d2:	80 e0       	ldi	r24, 0x00	; 0
    24d4:	01 c0       	rjmp	.+2      	; 0x24d8 <disk_read+0x7c>
    24d6:	83 e0       	ldi	r24, 0x03	; 3
    24d8:	cf 91       	pop	r28
    24da:	1f 91       	pop	r17
    24dc:	0f 91       	pop	r16
    24de:	ff 90       	pop	r15
    24e0:	ef 90       	pop	r14
    24e2:	08 95       	ret

000024e4 <disk_write>:
    24e4:	cf 92       	push	r12
    24e6:	df 92       	push	r13
    24e8:	ef 92       	push	r14
    24ea:	ff 92       	push	r15
    24ec:	0f 93       	push	r16
    24ee:	1f 93       	push	r17
    24f0:	cf 93       	push	r28
    24f2:	df 93       	push	r29
    24f4:	eb 01       	movw	r28, r22
    24f6:	69 01       	movw	r12, r18
    24f8:	7a 01       	movw	r14, r20
    24fa:	81 11       	cpse	r24, r1
    24fc:	03 c0       	rjmp	.+6      	; 0x2504 <disk_write+0x20>
    24fe:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <Stat>
    2502:	01 c0       	rjmp	.+2      	; 0x2506 <disk_write+0x22>
    2504:	81 e0       	ldi	r24, 0x01	; 1
    2506:	80 fd       	sbrc	r24, 0
    2508:	43 c0       	rjmp	.+134    	; 0x2590 <disk_write+0xac>
    250a:	80 91 35 05 	lds	r24, 0x0535	; 0x800535 <CardType>
    250e:	83 fd       	sbrc	r24, 3
    2510:	07 c0       	rjmp	.+14     	; 0x2520 <disk_write+0x3c>
    2512:	99 e0       	ldi	r25, 0x09	; 9
    2514:	cc 0c       	add	r12, r12
    2516:	dd 1c       	adc	r13, r13
    2518:	ee 1c       	adc	r14, r14
    251a:	ff 1c       	adc	r15, r15
    251c:	9a 95       	dec	r25
    251e:	d1 f7       	brne	.-12     	; 0x2514 <disk_write+0x30>
    2520:	01 30       	cpi	r16, 0x01	; 1
    2522:	11 05       	cpc	r17, r1
    2524:	89 f4       	brne	.+34     	; 0x2548 <disk_write+0x64>
    2526:	b7 01       	movw	r22, r14
    2528:	a6 01       	movw	r20, r12
    252a:	88 e1       	ldi	r24, 0x18	; 24
    252c:	58 de       	rcall	.-848    	; 0x21de <send_cmd>
    252e:	81 11       	cpse	r24, r1
    2530:	27 c0       	rjmp	.+78     	; 0x2580 <disk_write+0x9c>
    2532:	6e ef       	ldi	r22, 0xFE	; 254
    2534:	ce 01       	movw	r24, r28
    2536:	b8 de       	rcall	.-656    	; 0x22a8 <xmit_datablock>
    2538:	31 e0       	ldi	r19, 0x01	; 1
    253a:	20 e0       	ldi	r18, 0x00	; 0
    253c:	89 2b       	or	r24, r25
    253e:	09 f0       	breq	.+2      	; 0x2542 <disk_write+0x5e>
    2540:	30 e0       	ldi	r19, 0x00	; 0
    2542:	03 2f       	mov	r16, r19
    2544:	12 2f       	mov	r17, r18
    2546:	1e c0       	rjmp	.+60     	; 0x2584 <disk_write+0xa0>
    2548:	86 70       	andi	r24, 0x06	; 6
    254a:	29 f0       	breq	.+10     	; 0x2556 <disk_write+0x72>
    254c:	a8 01       	movw	r20, r16
    254e:	60 e0       	ldi	r22, 0x00	; 0
    2550:	70 e0       	ldi	r23, 0x00	; 0
    2552:	87 e9       	ldi	r24, 0x97	; 151
    2554:	44 de       	rcall	.-888    	; 0x21de <send_cmd>
    2556:	b7 01       	movw	r22, r14
    2558:	a6 01       	movw	r20, r12
    255a:	89 e1       	ldi	r24, 0x19	; 25
    255c:	40 de       	rcall	.-896    	; 0x21de <send_cmd>
    255e:	81 11       	cpse	r24, r1
    2560:	11 c0       	rjmp	.+34     	; 0x2584 <disk_write+0xa0>
    2562:	6c ef       	ldi	r22, 0xFC	; 252
    2564:	ce 01       	movw	r24, r28
    2566:	a0 de       	rcall	.-704    	; 0x22a8 <xmit_datablock>
    2568:	89 2b       	or	r24, r25
    256a:	21 f0       	breq	.+8      	; 0x2574 <disk_write+0x90>
    256c:	de 5f       	subi	r29, 0xFE	; 254
    256e:	01 50       	subi	r16, 0x01	; 1
    2570:	11 09       	sbc	r17, r1
    2572:	b9 f7       	brne	.-18     	; 0x2562 <disk_write+0x7e>
    2574:	6d ef       	ldi	r22, 0xFD	; 253
    2576:	80 e0       	ldi	r24, 0x00	; 0
    2578:	90 e0       	ldi	r25, 0x00	; 0
    257a:	96 de       	rcall	.-724    	; 0x22a8 <xmit_datablock>
    257c:	89 2b       	or	r24, r25
    257e:	11 f4       	brne	.+4      	; 0x2584 <disk_write+0xa0>
    2580:	01 e0       	ldi	r16, 0x01	; 1
    2582:	10 e0       	ldi	r17, 0x00	; 0
    2584:	c8 dd       	rcall	.-1136   	; 0x2116 <deselect>
    2586:	81 e0       	ldi	r24, 0x01	; 1
    2588:	01 2b       	or	r16, r17
    258a:	19 f4       	brne	.+6      	; 0x2592 <disk_write+0xae>
    258c:	80 e0       	ldi	r24, 0x00	; 0
    258e:	01 c0       	rjmp	.+2      	; 0x2592 <disk_write+0xae>
    2590:	83 e0       	ldi	r24, 0x03	; 3
    2592:	df 91       	pop	r29
    2594:	cf 91       	pop	r28
    2596:	1f 91       	pop	r17
    2598:	0f 91       	pop	r16
    259a:	ff 90       	pop	r15
    259c:	ef 90       	pop	r14
    259e:	df 90       	pop	r13
    25a0:	cf 90       	pop	r12
    25a2:	08 95       	ret

000025a4 <disk_ioctl>:
    25a4:	0f 93       	push	r16
    25a6:	1f 93       	push	r17
    25a8:	cf 93       	push	r28
    25aa:	df 93       	push	r29
    25ac:	cd b7       	in	r28, 0x3d	; 61
    25ae:	de b7       	in	r29, 0x3e	; 62
    25b0:	60 97       	sbiw	r28, 0x10	; 16
    25b2:	0f b6       	in	r0, 0x3f	; 63
    25b4:	f8 94       	cli
    25b6:	de bf       	out	0x3e, r29	; 62
    25b8:	0f be       	out	0x3f, r0	; 63
    25ba:	cd bf       	out	0x3d, r28	; 61
    25bc:	81 11       	cpse	r24, r1
    25be:	03 c0       	rjmp	.+6      	; 0x25c6 <disk_ioctl+0x22>
    25c0:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <Stat>
    25c4:	01 c0       	rjmp	.+2      	; 0x25c8 <disk_ioctl+0x24>
    25c6:	81 e0       	ldi	r24, 0x01	; 1
    25c8:	80 fd       	sbrc	r24, 0
    25ca:	7b c0       	rjmp	.+246    	; 0x26c2 <disk_ioctl+0x11e>
    25cc:	8a 01       	movw	r16, r20
    25ce:	61 30       	cpi	r22, 0x01	; 1
    25d0:	79 f0       	breq	.+30     	; 0x25f0 <disk_ioctl+0x4c>
    25d2:	40 f0       	brcs	.+16     	; 0x25e4 <disk_ioctl+0x40>
    25d4:	63 30       	cpi	r22, 0x03	; 3
    25d6:	09 f0       	breq	.+2      	; 0x25da <disk_ioctl+0x36>
    25d8:	70 c0       	rjmp	.+224    	; 0x26ba <disk_ioctl+0x116>
    25da:	80 e8       	ldi	r24, 0x80	; 128
    25dc:	90 e0       	ldi	r25, 0x00	; 0
    25de:	a0 e0       	ldi	r26, 0x00	; 0
    25e0:	b0 e0       	ldi	r27, 0x00	; 0
    25e2:	64 c0       	rjmp	.+200    	; 0x26ac <disk_ioctl+0x108>
    25e4:	a7 dd       	rcall	.-1202   	; 0x2134 <select>
    25e6:	11 e0       	ldi	r17, 0x01	; 1
    25e8:	89 2b       	or	r24, r25
    25ea:	09 f4       	brne	.+2      	; 0x25ee <disk_ioctl+0x4a>
    25ec:	67 c0       	rjmp	.+206    	; 0x26bc <disk_ioctl+0x118>
    25ee:	63 c0       	rjmp	.+198    	; 0x26b6 <disk_ioctl+0x112>
    25f0:	40 e0       	ldi	r20, 0x00	; 0
    25f2:	50 e0       	ldi	r21, 0x00	; 0
    25f4:	ba 01       	movw	r22, r20
    25f6:	89 e0       	ldi	r24, 0x09	; 9
    25f8:	f2 dd       	rcall	.-1052   	; 0x21de <send_cmd>
    25fa:	88 23       	and	r24, r24
    25fc:	11 f0       	breq	.+4      	; 0x2602 <disk_ioctl+0x5e>
    25fe:	11 e0       	ldi	r17, 0x01	; 1
    2600:	5d c0       	rjmp	.+186    	; 0x26bc <disk_ioctl+0x118>
    2602:	60 e1       	ldi	r22, 0x10	; 16
    2604:	70 e0       	ldi	r23, 0x00	; 0
    2606:	ce 01       	movw	r24, r28
    2608:	01 96       	adiw	r24, 0x01	; 1
    260a:	b0 dd       	rcall	.-1184   	; 0x216c <rcvr_datablock>
    260c:	89 2b       	or	r24, r25
    260e:	b9 f3       	breq	.-18     	; 0x25fe <disk_ioctl+0x5a>
    2610:	99 81       	ldd	r25, Y+1	; 0x01
    2612:	92 95       	swap	r25
    2614:	96 95       	lsr	r25
    2616:	96 95       	lsr	r25
    2618:	93 70       	andi	r25, 0x03	; 3
    261a:	29 85       	ldd	r18, Y+9	; 0x09
    261c:	4a 85       	ldd	r20, Y+10	; 0x0a
    261e:	88 85       	ldd	r24, Y+8	; 0x08
    2620:	91 30       	cpi	r25, 0x01	; 1
    2622:	d9 f4       	brne	.+54     	; 0x265a <disk_ioctl+0xb6>
    2624:	30 e0       	ldi	r19, 0x00	; 0
    2626:	32 2f       	mov	r19, r18
    2628:	22 27       	eor	r18, r18
    262a:	24 0f       	add	r18, r20
    262c:	31 1d       	adc	r19, r1
    262e:	8f 73       	andi	r24, 0x3F	; 63
    2630:	90 e0       	ldi	r25, 0x00	; 0
    2632:	a0 e0       	ldi	r26, 0x00	; 0
    2634:	b0 e0       	ldi	r27, 0x00	; 0
    2636:	dc 01       	movw	r26, r24
    2638:	99 27       	eor	r25, r25
    263a:	88 27       	eor	r24, r24
    263c:	01 96       	adiw	r24, 0x01	; 1
    263e:	a1 1d       	adc	r26, r1
    2640:	b1 1d       	adc	r27, r1
    2642:	82 0f       	add	r24, r18
    2644:	93 1f       	adc	r25, r19
    2646:	a1 1d       	adc	r26, r1
    2648:	b1 1d       	adc	r27, r1
    264a:	ea e0       	ldi	r30, 0x0A	; 10
    264c:	88 0f       	add	r24, r24
    264e:	99 1f       	adc	r25, r25
    2650:	aa 1f       	adc	r26, r26
    2652:	bb 1f       	adc	r27, r27
    2654:	ea 95       	dec	r30
    2656:	d1 f7       	brne	.-12     	; 0x264c <disk_ioctl+0xa8>
    2658:	29 c0       	rjmp	.+82     	; 0x26ac <disk_ioctl+0x108>
    265a:	22 95       	swap	r18
    265c:	26 95       	lsr	r18
    265e:	26 95       	lsr	r18
    2660:	23 70       	andi	r18, 0x03	; 3
    2662:	f4 e0       	ldi	r31, 0x04	; 4
    2664:	8f 9f       	mul	r24, r31
    2666:	c0 01       	movw	r24, r0
    2668:	11 24       	eor	r1, r1
    266a:	82 0f       	add	r24, r18
    266c:	91 1d       	adc	r25, r1
    266e:	01 96       	adiw	r24, 0x01	; 1
    2670:	2f 81       	ldd	r18, Y+7	; 0x07
    2672:	23 70       	andi	r18, 0x03	; 3
    2674:	30 e0       	ldi	r19, 0x00	; 0
    2676:	32 2f       	mov	r19, r18
    2678:	22 27       	eor	r18, r18
    267a:	33 0f       	add	r19, r19
    267c:	33 0f       	add	r19, r19
    267e:	82 0f       	add	r24, r18
    2680:	93 1f       	adc	r25, r19
    2682:	a0 e0       	ldi	r26, 0x00	; 0
    2684:	b0 e0       	ldi	r27, 0x00	; 0
    2686:	2e 81       	ldd	r18, Y+6	; 0x06
    2688:	32 2f       	mov	r19, r18
    268a:	3f 70       	andi	r19, 0x0F	; 15
    268c:	2b 85       	ldd	r18, Y+11	; 0x0b
    268e:	22 1f       	adc	r18, r18
    2690:	22 27       	eor	r18, r18
    2692:	22 1f       	adc	r18, r18
    2694:	23 0f       	add	r18, r19
    2696:	43 70       	andi	r20, 0x03	; 3
    2698:	44 0f       	add	r20, r20
    269a:	42 0f       	add	r20, r18
    269c:	47 50       	subi	r20, 0x07	; 7
    269e:	04 c0       	rjmp	.+8      	; 0x26a8 <disk_ioctl+0x104>
    26a0:	88 0f       	add	r24, r24
    26a2:	99 1f       	adc	r25, r25
    26a4:	aa 1f       	adc	r26, r26
    26a6:	bb 1f       	adc	r27, r27
    26a8:	4a 95       	dec	r20
    26aa:	d2 f7       	brpl	.-12     	; 0x26a0 <disk_ioctl+0xfc>
    26ac:	f8 01       	movw	r30, r16
    26ae:	80 83       	st	Z, r24
    26b0:	91 83       	std	Z+1, r25	; 0x01
    26b2:	a2 83       	std	Z+2, r26	; 0x02
    26b4:	b3 83       	std	Z+3, r27	; 0x03
    26b6:	10 e0       	ldi	r17, 0x00	; 0
    26b8:	01 c0       	rjmp	.+2      	; 0x26bc <disk_ioctl+0x118>
    26ba:	14 e0       	ldi	r17, 0x04	; 4
    26bc:	2c dd       	rcall	.-1448   	; 0x2116 <deselect>
    26be:	81 2f       	mov	r24, r17
    26c0:	01 c0       	rjmp	.+2      	; 0x26c4 <disk_ioctl+0x120>
    26c2:	83 e0       	ldi	r24, 0x03	; 3
    26c4:	60 96       	adiw	r28, 0x10	; 16
    26c6:	0f b6       	in	r0, 0x3f	; 63
    26c8:	f8 94       	cli
    26ca:	de bf       	out	0x3e, r29	; 62
    26cc:	0f be       	out	0x3f, r0	; 63
    26ce:	cd bf       	out	0x3d, r28	; 61
    26d0:	df 91       	pop	r29
    26d2:	cf 91       	pop	r28
    26d4:	1f 91       	pop	r17
    26d6:	0f 91       	pop	r16
    26d8:	08 95       	ret

000026da <mem_cpy>:
    26da:	cf 93       	push	r28
    26dc:	df 93       	push	r29
    26de:	db 01       	movw	r26, r22
    26e0:	fc 01       	movw	r30, r24
    26e2:	9a 01       	movw	r18, r20
    26e4:	22 30       	cpi	r18, 0x02	; 2
    26e6:	31 05       	cpc	r19, r1
    26e8:	38 f0       	brcs	.+14     	; 0x26f8 <mem_cpy+0x1e>
    26ea:	cd 91       	ld	r28, X+
    26ec:	dd 91       	ld	r29, X+
    26ee:	c1 93       	st	Z+, r28
    26f0:	d1 93       	st	Z+, r29
    26f2:	22 50       	subi	r18, 0x02	; 2
    26f4:	31 09       	sbc	r19, r1
    26f6:	f6 cf       	rjmp	.-20     	; 0x26e4 <mem_cpy+0xa>
    26f8:	9a 01       	movw	r18, r20
    26fa:	2e 7f       	andi	r18, 0xFE	; 254
    26fc:	fc 01       	movw	r30, r24
    26fe:	e2 0f       	add	r30, r18
    2700:	f3 1f       	adc	r31, r19
    2702:	db 01       	movw	r26, r22
    2704:	a2 0f       	add	r26, r18
    2706:	b3 1f       	adc	r27, r19
    2708:	42 17       	cp	r20, r18
    270a:	53 07       	cpc	r21, r19
    270c:	11 f0       	breq	.+4      	; 0x2712 <mem_cpy+0x38>
    270e:	2c 91       	ld	r18, X
    2710:	20 83       	st	Z, r18
    2712:	df 91       	pop	r29
    2714:	cf 91       	pop	r28
    2716:	08 95       	ret

00002718 <get_fileinfo>:
    2718:	0f 93       	push	r16
    271a:	1f 93       	push	r17
    271c:	cf 93       	push	r28
    271e:	df 93       	push	r29
    2720:	8b 01       	movw	r16, r22
    2722:	fb 01       	movw	r30, r22
    2724:	39 96       	adiw	r30, 0x09	; 9
    2726:	dc 01       	movw	r26, r24
    2728:	1e 96       	adiw	r26, 0x0e	; 14
    272a:	4d 91       	ld	r20, X+
    272c:	5d 91       	ld	r21, X+
    272e:	6d 91       	ld	r22, X+
    2730:	7c 91       	ld	r23, X
    2732:	51 97       	sbiw	r26, 0x11	; 17
    2734:	45 2b       	or	r20, r21
    2736:	46 2b       	or	r20, r22
    2738:	47 2b       	or	r20, r23
    273a:	a9 f1       	breq	.+106    	; 0x27a6 <get_fileinfo+0x8e>
    273c:	52 96       	adiw	r26, 0x12	; 18
    273e:	cd 91       	ld	r28, X+
    2740:	dc 91       	ld	r29, X
    2742:	53 97       	sbiw	r26, 0x13	; 19
    2744:	ae 01       	movw	r20, r28
    2746:	80 e0       	ldi	r24, 0x00	; 0
    2748:	90 e0       	ldi	r25, 0x00	; 0
    274a:	3e e2       	ldi	r19, 0x2E	; 46
    274c:	01 96       	adiw	r24, 0x01	; 1
    274e:	da 01       	movw	r26, r20
    2750:	2d 91       	ld	r18, X+
    2752:	ad 01       	movw	r20, r26
    2754:	20 32       	cpi	r18, 0x20	; 32
    2756:	51 f0       	breq	.+20     	; 0x276c <get_fileinfo+0x54>
    2758:	25 30       	cpi	r18, 0x05	; 5
    275a:	09 f4       	brne	.+2      	; 0x275e <get_fileinfo+0x46>
    275c:	25 ee       	ldi	r18, 0xE5	; 229
    275e:	89 30       	cpi	r24, 0x09	; 9
    2760:	91 05       	cpc	r25, r1
    2762:	11 f4       	brne	.+4      	; 0x2768 <get_fileinfo+0x50>
    2764:	30 83       	st	Z, r19
    2766:	31 96       	adiw	r30, 0x01	; 1
    2768:	20 83       	st	Z, r18
    276a:	31 96       	adiw	r30, 0x01	; 1
    276c:	8b 30       	cpi	r24, 0x0B	; 11
    276e:	91 05       	cpc	r25, r1
    2770:	69 f7       	brne	.-38     	; 0x274c <get_fileinfo+0x34>
    2772:	8b 85       	ldd	r24, Y+11	; 0x0b
    2774:	d8 01       	movw	r26, r16
    2776:	18 96       	adiw	r26, 0x08	; 8
    2778:	8c 93       	st	X, r24
    277a:	18 97       	sbiw	r26, 0x08	; 8
    277c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    277e:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2780:	6e 8d       	ldd	r22, Y+30	; 0x1e
    2782:	7f 8d       	ldd	r23, Y+31	; 0x1f
    2784:	4d 93       	st	X+, r20
    2786:	5d 93       	st	X+, r21
    2788:	6d 93       	st	X+, r22
    278a:	7c 93       	st	X, r23
    278c:	13 97       	sbiw	r26, 0x03	; 3
    278e:	88 8d       	ldd	r24, Y+24	; 0x18
    2790:	99 8d       	ldd	r25, Y+25	; 0x19
    2792:	15 96       	adiw	r26, 0x05	; 5
    2794:	9c 93       	st	X, r25
    2796:	8e 93       	st	-X, r24
    2798:	14 97       	sbiw	r26, 0x04	; 4
    279a:	8e 89       	ldd	r24, Y+22	; 0x16
    279c:	9f 89       	ldd	r25, Y+23	; 0x17
    279e:	17 96       	adiw	r26, 0x07	; 7
    27a0:	9c 93       	st	X, r25
    27a2:	8e 93       	st	-X, r24
    27a4:	16 97       	sbiw	r26, 0x06	; 6
    27a6:	10 82       	st	Z, r1
    27a8:	df 91       	pop	r29
    27aa:	cf 91       	pop	r28
    27ac:	1f 91       	pop	r17
    27ae:	0f 91       	pop	r16
    27b0:	08 95       	ret

000027b2 <get_ldnumber>:
    27b2:	dc 01       	movw	r26, r24
    27b4:	ed 91       	ld	r30, X+
    27b6:	fc 91       	ld	r31, X
    27b8:	30 97       	sbiw	r30, 0x00	; 0
    27ba:	c1 f0       	breq	.+48     	; 0x27ec <get_ldnumber+0x3a>
    27bc:	df 01       	movw	r26, r30
    27be:	9d 01       	movw	r18, r26
    27c0:	4d 91       	ld	r20, X+
    27c2:	41 32       	cpi	r20, 0x21	; 33
    27c4:	80 f0       	brcs	.+32     	; 0x27e6 <get_ldnumber+0x34>
    27c6:	4a 33       	cpi	r20, 0x3A	; 58
    27c8:	d1 f7       	brne	.-12     	; 0x27be <get_ldnumber+0xc>
    27ca:	af 01       	movw	r20, r30
    27cc:	4f 5f       	subi	r20, 0xFF	; 255
    27ce:	5f 4f       	sbci	r21, 0xFF	; 255
    27d0:	24 17       	cp	r18, r20
    27d2:	35 07       	cpc	r19, r21
    27d4:	59 f4       	brne	.+22     	; 0x27ec <get_ldnumber+0x3a>
    27d6:	40 81       	ld	r20, Z
    27d8:	40 33       	cpi	r20, 0x30	; 48
    27da:	41 f4       	brne	.+16     	; 0x27ec <get_ldnumber+0x3a>
    27dc:	2f 5f       	subi	r18, 0xFF	; 255
    27de:	3f 4f       	sbci	r19, 0xFF	; 255
    27e0:	fc 01       	movw	r30, r24
    27e2:	31 83       	std	Z+1, r19	; 0x01
    27e4:	20 83       	st	Z, r18
    27e6:	80 e0       	ldi	r24, 0x00	; 0
    27e8:	90 e0       	ldi	r25, 0x00	; 0
    27ea:	08 95       	ret
    27ec:	8f ef       	ldi	r24, 0xFF	; 255
    27ee:	9f ef       	ldi	r25, 0xFF	; 255
    27f0:	08 95       	ret

000027f2 <validate>:
    27f2:	00 97       	sbiw	r24, 0x00	; 0
    27f4:	c1 f0       	breq	.+48     	; 0x2826 <validate+0x34>
    27f6:	dc 01       	movw	r26, r24
    27f8:	ed 91       	ld	r30, X+
    27fa:	fc 91       	ld	r31, X
    27fc:	11 97       	sbiw	r26, 0x01	; 1
    27fe:	30 97       	sbiw	r30, 0x00	; 0
    2800:	91 f0       	breq	.+36     	; 0x2826 <validate+0x34>
    2802:	20 81       	ld	r18, Z
    2804:	22 23       	and	r18, r18
    2806:	79 f0       	breq	.+30     	; 0x2826 <validate+0x34>
    2808:	26 81       	ldd	r18, Z+6	; 0x06
    280a:	37 81       	ldd	r19, Z+7	; 0x07
    280c:	12 96       	adiw	r26, 0x02	; 2
    280e:	8d 91       	ld	r24, X+
    2810:	9c 91       	ld	r25, X
    2812:	13 97       	sbiw	r26, 0x03	; 3
    2814:	28 17       	cp	r18, r24
    2816:	39 07       	cpc	r19, r25
    2818:	31 f4       	brne	.+12     	; 0x2826 <validate+0x34>
    281a:	81 81       	ldd	r24, Z+1	; 0x01
    281c:	7c dd       	rcall	.-1288   	; 0x2316 <disk_status>
    281e:	80 fd       	sbrc	r24, 0
    2820:	04 c0       	rjmp	.+8      	; 0x282a <validate+0x38>
    2822:	80 e0       	ldi	r24, 0x00	; 0
    2824:	08 95       	ret
    2826:	89 e0       	ldi	r24, 0x09	; 9
    2828:	08 95       	ret
    282a:	83 e0       	ldi	r24, 0x03	; 3
    282c:	08 95       	ret

0000282e <sync_window.part.2>:
    282e:	8f 92       	push	r8
    2830:	9f 92       	push	r9
    2832:	af 92       	push	r10
    2834:	bf 92       	push	r11
    2836:	cf 92       	push	r12
    2838:	df 92       	push	r13
    283a:	ef 92       	push	r14
    283c:	ff 92       	push	r15
    283e:	0f 93       	push	r16
    2840:	1f 93       	push	r17
    2842:	cf 93       	push	r28
    2844:	df 93       	push	r29
    2846:	ec 01       	movw	r28, r24
    2848:	8a a4       	ldd	r8, Y+42	; 0x2a
    284a:	9b a4       	ldd	r9, Y+43	; 0x2b
    284c:	ac a4       	ldd	r10, Y+44	; 0x2c
    284e:	bd a4       	ldd	r11, Y+45	; 0x2d
    2850:	6c 01       	movw	r12, r24
    2852:	8e e2       	ldi	r24, 0x2E	; 46
    2854:	c8 0e       	add	r12, r24
    2856:	d1 1c       	adc	r13, r1
    2858:	01 e0       	ldi	r16, 0x01	; 1
    285a:	10 e0       	ldi	r17, 0x00	; 0
    285c:	a5 01       	movw	r20, r10
    285e:	94 01       	movw	r18, r8
    2860:	b6 01       	movw	r22, r12
    2862:	89 81       	ldd	r24, Y+1	; 0x01
    2864:	3f de       	rcall	.-898    	; 0x24e4 <disk_write>
    2866:	81 11       	cpse	r24, r1
    2868:	2f c0       	rjmp	.+94     	; 0x28c8 <sync_window.part.2+0x9a>
    286a:	1c 82       	std	Y+4, r1	; 0x04
    286c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    286e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2870:	a8 a1       	ldd	r26, Y+32	; 0x20
    2872:	b9 a1       	ldd	r27, Y+33	; 0x21
    2874:	b5 01       	movw	r22, r10
    2876:	a4 01       	movw	r20, r8
    2878:	48 1b       	sub	r20, r24
    287a:	59 0b       	sbc	r21, r25
    287c:	6a 0b       	sbc	r22, r26
    287e:	7b 0b       	sbc	r23, r27
    2880:	8e 89       	ldd	r24, Y+22	; 0x16
    2882:	9f 89       	ldd	r25, Y+23	; 0x17
    2884:	a8 8d       	ldd	r26, Y+24	; 0x18
    2886:	b9 8d       	ldd	r27, Y+25	; 0x19
    2888:	48 17       	cp	r20, r24
    288a:	59 07       	cpc	r21, r25
    288c:	6a 07       	cpc	r22, r26
    288e:	7b 07       	cpc	r23, r27
    2890:	10 f0       	brcs	.+4      	; 0x2896 <sync_window.part.2+0x68>
    2892:	80 e0       	ldi	r24, 0x00	; 0
    2894:	1a c0       	rjmp	.+52     	; 0x28ca <sync_window.part.2+0x9c>
    2896:	eb 80       	ldd	r14, Y+3	; 0x03
    2898:	f1 2c       	mov	r15, r1
    289a:	82 e0       	ldi	r24, 0x02	; 2
    289c:	e8 16       	cp	r14, r24
    289e:	f1 04       	cpc	r15, r1
    28a0:	c0 f3       	brcs	.-16     	; 0x2892 <sync_window.part.2+0x64>
    28a2:	8e 89       	ldd	r24, Y+22	; 0x16
    28a4:	9f 89       	ldd	r25, Y+23	; 0x17
    28a6:	a8 8d       	ldd	r26, Y+24	; 0x18
    28a8:	b9 8d       	ldd	r27, Y+25	; 0x19
    28aa:	88 0e       	add	r8, r24
    28ac:	99 1e       	adc	r9, r25
    28ae:	aa 1e       	adc	r10, r26
    28b0:	bb 1e       	adc	r11, r27
    28b2:	01 e0       	ldi	r16, 0x01	; 1
    28b4:	10 e0       	ldi	r17, 0x00	; 0
    28b6:	a5 01       	movw	r20, r10
    28b8:	94 01       	movw	r18, r8
    28ba:	b6 01       	movw	r22, r12
    28bc:	89 81       	ldd	r24, Y+1	; 0x01
    28be:	12 de       	rcall	.-988    	; 0x24e4 <disk_write>
    28c0:	81 e0       	ldi	r24, 0x01	; 1
    28c2:	e8 1a       	sub	r14, r24
    28c4:	f1 08       	sbc	r15, r1
    28c6:	e9 cf       	rjmp	.-46     	; 0x289a <sync_window.part.2+0x6c>
    28c8:	81 e0       	ldi	r24, 0x01	; 1
    28ca:	df 91       	pop	r29
    28cc:	cf 91       	pop	r28
    28ce:	1f 91       	pop	r17
    28d0:	0f 91       	pop	r16
    28d2:	ff 90       	pop	r15
    28d4:	ef 90       	pop	r14
    28d6:	df 90       	pop	r13
    28d8:	cf 90       	pop	r12
    28da:	bf 90       	pop	r11
    28dc:	af 90       	pop	r10
    28de:	9f 90       	pop	r9
    28e0:	8f 90       	pop	r8
    28e2:	08 95       	ret

000028e4 <sync_window>:
    28e4:	fc 01       	movw	r30, r24
    28e6:	24 81       	ldd	r18, Z+4	; 0x04
    28e8:	21 11       	cpse	r18, r1
    28ea:	a1 cf       	rjmp	.-190    	; 0x282e <sync_window.part.2>
    28ec:	80 e0       	ldi	r24, 0x00	; 0
    28ee:	08 95       	ret

000028f0 <move_window>:
    28f0:	8f 92       	push	r8
    28f2:	9f 92       	push	r9
    28f4:	af 92       	push	r10
    28f6:	bf 92       	push	r11
    28f8:	ff 92       	push	r15
    28fa:	0f 93       	push	r16
    28fc:	1f 93       	push	r17
    28fe:	cf 93       	push	r28
    2900:	df 93       	push	r29
    2902:	ec 01       	movw	r28, r24
    2904:	4a 01       	movw	r8, r20
    2906:	5b 01       	movw	r10, r22
    2908:	8a a5       	ldd	r24, Y+42	; 0x2a
    290a:	9b a5       	ldd	r25, Y+43	; 0x2b
    290c:	ac a5       	ldd	r26, Y+44	; 0x2c
    290e:	bd a5       	ldd	r27, Y+45	; 0x2d
    2910:	84 17       	cp	r24, r20
    2912:	95 07       	cpc	r25, r21
    2914:	a6 07       	cpc	r26, r22
    2916:	b7 07       	cpc	r27, r23
    2918:	d9 f0       	breq	.+54     	; 0x2950 <move_window+0x60>
    291a:	ce 01       	movw	r24, r28
    291c:	e3 df       	rcall	.-58     	; 0x28e4 <sync_window>
    291e:	f8 2e       	mov	r15, r24
    2920:	81 11       	cpse	r24, r1
    2922:	17 c0       	rjmp	.+46     	; 0x2952 <move_window+0x62>
    2924:	01 e0       	ldi	r16, 0x01	; 1
    2926:	10 e0       	ldi	r17, 0x00	; 0
    2928:	a5 01       	movw	r20, r10
    292a:	94 01       	movw	r18, r8
    292c:	be 01       	movw	r22, r28
    292e:	62 5d       	subi	r22, 0xD2	; 210
    2930:	7f 4f       	sbci	r23, 0xFF	; 255
    2932:	89 81       	ldd	r24, Y+1	; 0x01
    2934:	93 dd       	rcall	.-1242   	; 0x245c <disk_read>
    2936:	88 23       	and	r24, r24
    2938:	31 f0       	breq	.+12     	; 0x2946 <move_window+0x56>
    293a:	ff 24       	eor	r15, r15
    293c:	f3 94       	inc	r15
    293e:	88 24       	eor	r8, r8
    2940:	8a 94       	dec	r8
    2942:	98 2c       	mov	r9, r8
    2944:	54 01       	movw	r10, r8
    2946:	8a a6       	std	Y+42, r8	; 0x2a
    2948:	9b a6       	std	Y+43, r9	; 0x2b
    294a:	ac a6       	std	Y+44, r10	; 0x2c
    294c:	bd a6       	std	Y+45, r11	; 0x2d
    294e:	01 c0       	rjmp	.+2      	; 0x2952 <move_window+0x62>
    2950:	f1 2c       	mov	r15, r1
    2952:	8f 2d       	mov	r24, r15
    2954:	df 91       	pop	r29
    2956:	cf 91       	pop	r28
    2958:	1f 91       	pop	r17
    295a:	0f 91       	pop	r16
    295c:	ff 90       	pop	r15
    295e:	bf 90       	pop	r11
    2960:	af 90       	pop	r10
    2962:	9f 90       	pop	r9
    2964:	8f 90       	pop	r8
    2966:	08 95       	ret

00002968 <check_fs>:
    2968:	cf 93       	push	r28
    296a:	df 93       	push	r29
    296c:	ec 01       	movw	r28, r24
    296e:	1c 82       	std	Y+4, r1	; 0x04
    2970:	8f ef       	ldi	r24, 0xFF	; 255
    2972:	9f ef       	ldi	r25, 0xFF	; 255
    2974:	dc 01       	movw	r26, r24
    2976:	8a a7       	std	Y+42, r24	; 0x2a
    2978:	9b a7       	std	Y+43, r25	; 0x2b
    297a:	ac a7       	std	Y+44, r26	; 0x2c
    297c:	bd a7       	std	Y+45, r27	; 0x2d
    297e:	ce 01       	movw	r24, r28
    2980:	b7 df       	rcall	.-146    	; 0x28f0 <move_window>
    2982:	81 11       	cpse	r24, r1
    2984:	22 c0       	rjmp	.+68     	; 0x29ca <check_fs+0x62>
    2986:	fe 01       	movw	r30, r28
    2988:	e4 5d       	subi	r30, 0xD4	; 212
    298a:	fd 4f       	sbci	r31, 0xFD	; 253
    298c:	80 81       	ld	r24, Z
    298e:	91 81       	ldd	r25, Z+1	; 0x01
    2990:	85 35       	cpi	r24, 0x55	; 85
    2992:	9a 4a       	sbci	r25, 0xAA	; 170
    2994:	e1 f4       	brne	.+56     	; 0x29ce <check_fs+0x66>
    2996:	e8 5c       	subi	r30, 0xC8	; 200
    2998:	f1 40       	sbci	r31, 0x01	; 1
    299a:	80 81       	ld	r24, Z
    299c:	91 81       	ldd	r25, Z+1	; 0x01
    299e:	a2 81       	ldd	r26, Z+2	; 0x02
    29a0:	b3 81       	ldd	r27, Z+3	; 0x03
    29a2:	bb 27       	eor	r27, r27
    29a4:	86 34       	cpi	r24, 0x46	; 70
    29a6:	91 44       	sbci	r25, 0x41	; 65
    29a8:	a4 45       	sbci	r26, 0x54	; 84
    29aa:	b1 05       	cpc	r27, r1
    29ac:	91 f0       	breq	.+36     	; 0x29d2 <check_fs+0x6a>
    29ae:	c0 58       	subi	r28, 0x80	; 128
    29b0:	df 4f       	sbci	r29, 0xFF	; 255
    29b2:	48 81       	ld	r20, Y
    29b4:	59 81       	ldd	r21, Y+1	; 0x01
    29b6:	6a 81       	ldd	r22, Y+2	; 0x02
    29b8:	7b 81       	ldd	r23, Y+3	; 0x03
    29ba:	77 27       	eor	r23, r23
    29bc:	81 e0       	ldi	r24, 0x01	; 1
    29be:	46 34       	cpi	r20, 0x46	; 70
    29c0:	51 44       	sbci	r21, 0x41	; 65
    29c2:	64 45       	sbci	r22, 0x54	; 84
    29c4:	71 05       	cpc	r23, r1
    29c6:	31 f4       	brne	.+12     	; 0x29d4 <check_fs+0x6c>
    29c8:	04 c0       	rjmp	.+8      	; 0x29d2 <check_fs+0x6a>
    29ca:	83 e0       	ldi	r24, 0x03	; 3
    29cc:	03 c0       	rjmp	.+6      	; 0x29d4 <check_fs+0x6c>
    29ce:	82 e0       	ldi	r24, 0x02	; 2
    29d0:	01 c0       	rjmp	.+2      	; 0x29d4 <check_fs+0x6c>
    29d2:	80 e0       	ldi	r24, 0x00	; 0
    29d4:	df 91       	pop	r29
    29d6:	cf 91       	pop	r28
    29d8:	08 95       	ret

000029da <find_volume>:
    29da:	2f 92       	push	r2
    29dc:	3f 92       	push	r3
    29de:	4f 92       	push	r4
    29e0:	5f 92       	push	r5
    29e2:	6f 92       	push	r6
    29e4:	7f 92       	push	r7
    29e6:	8f 92       	push	r8
    29e8:	9f 92       	push	r9
    29ea:	af 92       	push	r10
    29ec:	bf 92       	push	r11
    29ee:	cf 92       	push	r12
    29f0:	df 92       	push	r13
    29f2:	ef 92       	push	r14
    29f4:	ff 92       	push	r15
    29f6:	0f 93       	push	r16
    29f8:	1f 93       	push	r17
    29fa:	cf 93       	push	r28
    29fc:	df 93       	push	r29
    29fe:	cd b7       	in	r28, 0x3d	; 61
    2a00:	de b7       	in	r29, 0x3e	; 62
    2a02:	6d 97       	sbiw	r28, 0x1d	; 29
    2a04:	0f b6       	in	r0, 0x3f	; 63
    2a06:	f8 94       	cli
    2a08:	de bf       	out	0x3e, r29	; 62
    2a0a:	0f be       	out	0x3f, r0	; 63
    2a0c:	cd bf       	out	0x3d, r28	; 61
    2a0e:	6c 01       	movw	r12, r24
    2a10:	cb 01       	movw	r24, r22
    2a12:	b4 2e       	mov	r11, r20
    2a14:	d6 01       	movw	r26, r12
    2a16:	1d 92       	st	X+, r1
    2a18:	1c 92       	st	X, r1
    2a1a:	cb de       	rcall	.-618    	; 0x27b2 <get_ldnumber>
    2a1c:	7c 01       	movw	r14, r24
    2a1e:	97 fd       	sbrc	r25, 7
    2a20:	2c c2       	rjmp	.+1112   	; 0x2e7a <find_volume+0x4a0>
    2a22:	fc 01       	movw	r30, r24
    2a24:	ee 0f       	add	r30, r30
    2a26:	ff 1f       	adc	r31, r31
    2a28:	e8 5c       	subi	r30, 0xC8	; 200
    2a2a:	fa 4f       	sbci	r31, 0xFA	; 250
    2a2c:	00 81       	ld	r16, Z
    2a2e:	11 81       	ldd	r17, Z+1	; 0x01
    2a30:	01 15       	cp	r16, r1
    2a32:	11 05       	cpc	r17, r1
    2a34:	09 f4       	brne	.+2      	; 0x2a38 <find_volume+0x5e>
    2a36:	23 c2       	rjmp	.+1094   	; 0x2e7e <find_volume+0x4a4>
    2a38:	f6 01       	movw	r30, r12
    2a3a:	11 83       	std	Z+1, r17	; 0x01
    2a3c:	00 83       	st	Z, r16
    2a3e:	d8 01       	movw	r26, r16
    2a40:	8c 91       	ld	r24, X
    2a42:	88 23       	and	r24, r24
    2a44:	61 f0       	breq	.+24     	; 0x2a5e <find_volume+0x84>
    2a46:	11 96       	adiw	r26, 0x01	; 1
    2a48:	8c 91       	ld	r24, X
    2a4a:	65 dc       	rcall	.-1846   	; 0x2316 <disk_status>
    2a4c:	80 fd       	sbrc	r24, 0
    2a4e:	07 c0       	rjmp	.+14     	; 0x2a5e <find_volume+0x84>
    2a50:	bb 20       	and	r11, r11
    2a52:	09 f4       	brne	.+2      	; 0x2a56 <find_volume+0x7c>
    2a54:	16 c2       	rjmp	.+1068   	; 0x2e82 <find_volume+0x4a8>
    2a56:	82 ff       	sbrs	r24, 2
    2a58:	14 c2       	rjmp	.+1064   	; 0x2e82 <find_volume+0x4a8>
    2a5a:	8a e0       	ldi	r24, 0x0A	; 10
    2a5c:	33 c2       	rjmp	.+1126   	; 0x2ec4 <find_volume+0x4ea>
    2a5e:	f8 01       	movw	r30, r16
    2a60:	10 82       	st	Z, r1
    2a62:	e1 82       	std	Z+1, r14	; 0x01
    2a64:	8e 2d       	mov	r24, r14
    2a66:	5e dc       	rcall	.-1860   	; 0x2324 <disk_initialize>
    2a68:	80 fd       	sbrc	r24, 0
    2a6a:	0d c2       	rjmp	.+1050   	; 0x2e86 <find_volume+0x4ac>
    2a6c:	bb 20       	and	r11, r11
    2a6e:	11 f0       	breq	.+4      	; 0x2a74 <find_volume+0x9a>
    2a70:	82 fd       	sbrc	r24, 2
    2a72:	f3 cf       	rjmp	.-26     	; 0x2a5a <find_volume+0x80>
    2a74:	40 e0       	ldi	r20, 0x00	; 0
    2a76:	50 e0       	ldi	r21, 0x00	; 0
    2a78:	ba 01       	movw	r22, r20
    2a7a:	c8 01       	movw	r24, r16
    2a7c:	75 df       	rcall	.-278    	; 0x2968 <check_fs>
    2a7e:	81 30       	cpi	r24, 0x01	; 1
    2a80:	c9 f5       	brne	.+114    	; 0x2af4 <find_volume+0x11a>
    2a82:	f8 01       	movw	r30, r16
    2a84:	e0 51       	subi	r30, 0x10	; 16
    2a86:	fe 4f       	sbci	r31, 0xFE	; 254
    2a88:	9e 01       	movw	r18, r28
    2a8a:	2f 5f       	subi	r18, 0xFF	; 255
    2a8c:	3f 4f       	sbci	r19, 0xFF	; 255
    2a8e:	69 01       	movw	r12, r18
    2a90:	c8 01       	movw	r24, r16
    2a92:	80 5d       	subi	r24, 0xD0	; 208
    2a94:	9d 4f       	sbci	r25, 0xFD	; 253
    2a96:	d9 01       	movw	r26, r18
    2a98:	20 81       	ld	r18, Z
    2a9a:	22 23       	and	r18, r18
    2a9c:	29 f0       	breq	.+10     	; 0x2aa8 <find_volume+0xce>
    2a9e:	44 81       	ldd	r20, Z+4	; 0x04
    2aa0:	55 81       	ldd	r21, Z+5	; 0x05
    2aa2:	66 81       	ldd	r22, Z+6	; 0x06
    2aa4:	77 81       	ldd	r23, Z+7	; 0x07
    2aa6:	03 c0       	rjmp	.+6      	; 0x2aae <find_volume+0xd4>
    2aa8:	40 e0       	ldi	r20, 0x00	; 0
    2aaa:	50 e0       	ldi	r21, 0x00	; 0
    2aac:	ba 01       	movw	r22, r20
    2aae:	4d 93       	st	X+, r20
    2ab0:	5d 93       	st	X+, r21
    2ab2:	6d 93       	st	X+, r22
    2ab4:	7d 93       	st	X+, r23
    2ab6:	70 96       	adiw	r30, 0x10	; 16
    2ab8:	e8 17       	cp	r30, r24
    2aba:	f9 07       	cpc	r31, r25
    2abc:	69 f7       	brne	.-38     	; 0x2a98 <find_volume+0xbe>
    2abe:	7e 01       	movw	r14, r28
    2ac0:	31 e1       	ldi	r19, 0x11	; 17
    2ac2:	e3 0e       	add	r14, r19
    2ac4:	f1 1c       	adc	r15, r1
    2ac6:	d6 01       	movw	r26, r12
    2ac8:	4d 90       	ld	r4, X+
    2aca:	5d 90       	ld	r5, X+
    2acc:	6d 90       	ld	r6, X+
    2ace:	7d 90       	ld	r7, X+
    2ad0:	6d 01       	movw	r12, r26
    2ad2:	41 14       	cp	r4, r1
    2ad4:	51 04       	cpc	r5, r1
    2ad6:	61 04       	cpc	r6, r1
    2ad8:	71 04       	cpc	r7, r1
    2ada:	39 f0       	breq	.+14     	; 0x2aea <find_volume+0x110>
    2adc:	b3 01       	movw	r22, r6
    2ade:	a2 01       	movw	r20, r4
    2ae0:	c8 01       	movw	r24, r16
    2ae2:	42 df       	rcall	.-380    	; 0x2968 <check_fs>
    2ae4:	81 11       	cpse	r24, r1
    2ae6:	02 c0       	rjmp	.+4      	; 0x2aec <find_volume+0x112>
    2ae8:	0f c0       	rjmp	.+30     	; 0x2b08 <find_volume+0x12e>
    2aea:	82 e0       	ldi	r24, 0x02	; 2
    2aec:	ec 14       	cp	r14, r12
    2aee:	fd 04       	cpc	r15, r13
    2af0:	51 f7       	brne	.-44     	; 0x2ac6 <find_volume+0xec>
    2af2:	03 c0       	rjmp	.+6      	; 0x2afa <find_volume+0x120>
    2af4:	41 2c       	mov	r4, r1
    2af6:	51 2c       	mov	r5, r1
    2af8:	32 01       	movw	r6, r4
    2afa:	83 30       	cpi	r24, 0x03	; 3
    2afc:	09 f4       	brne	.+2      	; 0x2b00 <find_volume+0x126>
    2afe:	c5 c1       	rjmp	.+906    	; 0x2e8a <find_volume+0x4b0>
    2b00:	88 23       	and	r24, r24
    2b02:	11 f0       	breq	.+4      	; 0x2b08 <find_volume+0x12e>
    2b04:	8d e0       	ldi	r24, 0x0D	; 13
    2b06:	de c1       	rjmp	.+956    	; 0x2ec4 <find_volume+0x4ea>
    2b08:	f8 01       	movw	r30, r16
    2b0a:	81 ad       	ldd	r24, Z+57	; 0x39
    2b0c:	92 ad       	ldd	r25, Z+58	; 0x3a
    2b0e:	81 15       	cp	r24, r1
    2b10:	92 40       	sbci	r25, 0x02	; 2
    2b12:	c1 f7       	brne	.-16     	; 0x2b04 <find_volume+0x12a>
    2b14:	f8 01       	movw	r30, r16
    2b16:	ec 5b       	subi	r30, 0xBC	; 188
    2b18:	ff 4f       	sbci	r31, 0xFF	; 255
    2b1a:	80 80       	ld	r8, Z
    2b1c:	91 80       	ldd	r9, Z+1	; 0x01
    2b1e:	a1 2c       	mov	r10, r1
    2b20:	b1 2c       	mov	r11, r1
    2b22:	81 14       	cp	r8, r1
    2b24:	91 04       	cpc	r9, r1
    2b26:	a1 04       	cpc	r10, r1
    2b28:	b1 04       	cpc	r11, r1
    2b2a:	29 f4       	brne	.+10     	; 0x2b36 <find_volume+0x15c>
    2b2c:	3e 96       	adiw	r30, 0x0e	; 14
    2b2e:	80 80       	ld	r8, Z
    2b30:	91 80       	ldd	r9, Z+1	; 0x01
    2b32:	a2 80       	ldd	r10, Z+2	; 0x02
    2b34:	b3 80       	ldd	r11, Z+3	; 0x03
    2b36:	d8 01       	movw	r26, r16
    2b38:	56 96       	adiw	r26, 0x16	; 22
    2b3a:	8d 92       	st	X+, r8
    2b3c:	9d 92       	st	X+, r9
    2b3e:	ad 92       	st	X+, r10
    2b40:	bc 92       	st	X, r11
    2b42:	59 97       	sbiw	r26, 0x19	; 25
    2b44:	de 96       	adiw	r26, 0x3e	; 62
    2b46:	4c 91       	ld	r20, X
    2b48:	de 97       	sbiw	r26, 0x3e	; 62
    2b4a:	13 96       	adiw	r26, 0x03	; 3
    2b4c:	4c 93       	st	X, r20
    2b4e:	13 97       	sbiw	r26, 0x03	; 3
    2b50:	8f ef       	ldi	r24, 0xFF	; 255
    2b52:	84 0f       	add	r24, r20
    2b54:	82 30       	cpi	r24, 0x02	; 2
    2b56:	b0 f6       	brcc	.-84     	; 0x2b04 <find_volume+0x12a>
    2b58:	db 96       	adiw	r26, 0x3b	; 59
    2b5a:	ec 91       	ld	r30, X
    2b5c:	db 97       	sbiw	r26, 0x3b	; 59
    2b5e:	e9 8b       	std	Y+17, r30	; 0x11
    2b60:	12 96       	adiw	r26, 0x02	; 2
    2b62:	ec 93       	st	X, r30
    2b64:	12 97       	sbiw	r26, 0x02	; 2
    2b66:	ee 23       	and	r30, r30
    2b68:	69 f2       	breq	.-102    	; 0x2b04 <find_volume+0x12a>
    2b6a:	8e 2f       	mov	r24, r30
    2b6c:	90 e0       	ldi	r25, 0x00	; 0
    2b6e:	9c 01       	movw	r18, r24
    2b70:	21 50       	subi	r18, 0x01	; 1
    2b72:	31 09       	sbc	r19, r1
    2b74:	82 23       	and	r24, r18
    2b76:	93 23       	and	r25, r19
    2b78:	89 2b       	or	r24, r25
    2b7a:	21 f6       	brne	.-120    	; 0x2b04 <find_volume+0x12a>
    2b7c:	f8 01       	movw	r30, r16
    2b7e:	ff 96       	adiw	r30, 0x3f	; 63
    2b80:	20 80       	ld	r2, Z
    2b82:	31 80       	ldd	r3, Z+1	; 0x01
    2b84:	19 96       	adiw	r26, 0x09	; 9
    2b86:	3c 92       	st	X, r3
    2b88:	2e 92       	st	-X, r2
    2b8a:	18 97       	sbiw	r26, 0x08	; 8
    2b8c:	c1 01       	movw	r24, r2
    2b8e:	8f 70       	andi	r24, 0x0F	; 15
    2b90:	99 27       	eor	r25, r25
    2b92:	89 2b       	or	r24, r25
    2b94:	09 f0       	breq	.+2      	; 0x2b98 <find_volume+0x1be>
    2b96:	b6 cf       	rjmp	.-148    	; 0x2b04 <find_volume+0x12a>
    2b98:	32 96       	adiw	r30, 0x02	; 2
    2b9a:	c0 80       	ld	r12, Z
    2b9c:	d1 80       	ldd	r13, Z+1	; 0x01
    2b9e:	e1 2c       	mov	r14, r1
    2ba0:	f1 2c       	mov	r15, r1
    2ba2:	c1 14       	cp	r12, r1
    2ba4:	d1 04       	cpc	r13, r1
    2ba6:	e1 04       	cpc	r14, r1
    2ba8:	f1 04       	cpc	r15, r1
    2baa:	29 f4       	brne	.+10     	; 0x2bb6 <find_volume+0x1dc>
    2bac:	3d 96       	adiw	r30, 0x0d	; 13
    2bae:	c0 80       	ld	r12, Z
    2bb0:	d1 80       	ldd	r13, Z+1	; 0x01
    2bb2:	e2 80       	ldd	r14, Z+2	; 0x02
    2bb4:	f3 80       	ldd	r15, Z+3	; 0x03
    2bb6:	d8 01       	movw	r26, r16
    2bb8:	dc 96       	adiw	r26, 0x3c	; 60
    2bba:	ed 91       	ld	r30, X+
    2bbc:	fc 91       	ld	r31, X
    2bbe:	dd 97       	sbiw	r26, 0x3d	; 61
    2bc0:	30 97       	sbiw	r30, 0x00	; 0
    2bc2:	09 f4       	brne	.+2      	; 0x2bc6 <find_volume+0x1ec>
    2bc4:	9f cf       	rjmp	.-194    	; 0x2b04 <find_volume+0x12a>
    2bc6:	a4 2f       	mov	r26, r20
    2bc8:	b0 e0       	ldi	r27, 0x00	; 0
    2bca:	a5 01       	movw	r20, r10
    2bcc:	94 01       	movw	r18, r8
    2bce:	0e 94 f5 37 	call	0x6fea	; 0x6fea <__muluhisi3>
    2bd2:	6e 8b       	std	Y+22, r22	; 0x16
    2bd4:	7f 8b       	std	Y+23, r23	; 0x17
    2bd6:	88 8f       	std	Y+24, r24	; 0x18
    2bd8:	99 8f       	std	Y+25, r25	; 0x19
    2bda:	9f 01       	movw	r18, r30
    2bdc:	40 e0       	ldi	r20, 0x00	; 0
    2bde:	50 e0       	ldi	r21, 0x00	; 0
    2be0:	2a 8f       	std	Y+26, r18	; 0x1a
    2be2:	3b 8f       	std	Y+27, r19	; 0x1b
    2be4:	4c 8f       	std	Y+28, r20	; 0x1c
    2be6:	5d 8f       	std	Y+29, r21	; 0x1d
    2be8:	c1 01       	movw	r24, r2
    2bea:	64 e0       	ldi	r22, 0x04	; 4
    2bec:	96 95       	lsr	r25
    2bee:	87 95       	ror	r24
    2bf0:	6a 95       	dec	r22
    2bf2:	e1 f7       	brne	.-8      	; 0x2bec <find_volume+0x212>
    2bf4:	28 0f       	add	r18, r24
    2bf6:	39 1f       	adc	r19, r25
    2bf8:	41 1d       	adc	r20, r1
    2bfa:	51 1d       	adc	r21, r1
    2bfc:	da 01       	movw	r26, r20
    2bfe:	c9 01       	movw	r24, r18
    2c00:	2e 89       	ldd	r18, Y+22	; 0x16
    2c02:	3f 89       	ldd	r19, Y+23	; 0x17
    2c04:	48 8d       	ldd	r20, Y+24	; 0x18
    2c06:	59 8d       	ldd	r21, Y+25	; 0x19
    2c08:	28 0f       	add	r18, r24
    2c0a:	39 1f       	adc	r19, r25
    2c0c:	4a 1f       	adc	r20, r26
    2c0e:	5b 1f       	adc	r21, r27
    2c10:	2a 8b       	std	Y+18, r18	; 0x12
    2c12:	3b 8b       	std	Y+19, r19	; 0x13
    2c14:	4c 8b       	std	Y+20, r20	; 0x14
    2c16:	5d 8b       	std	Y+21, r21	; 0x15
    2c18:	c2 16       	cp	r12, r18
    2c1a:	d3 06       	cpc	r13, r19
    2c1c:	e4 06       	cpc	r14, r20
    2c1e:	f5 06       	cpc	r15, r21
    2c20:	08 f4       	brcc	.+2      	; 0x2c24 <find_volume+0x24a>
    2c22:	70 cf       	rjmp	.-288    	; 0x2b04 <find_volume+0x12a>
    2c24:	c7 01       	movw	r24, r14
    2c26:	b6 01       	movw	r22, r12
    2c28:	62 1b       	sub	r22, r18
    2c2a:	73 0b       	sbc	r23, r19
    2c2c:	84 0b       	sbc	r24, r20
    2c2e:	95 0b       	sbc	r25, r21
    2c30:	e9 89       	ldd	r30, Y+17	; 0x11
    2c32:	2e 2f       	mov	r18, r30
    2c34:	30 e0       	ldi	r19, 0x00	; 0
    2c36:	40 e0       	ldi	r20, 0x00	; 0
    2c38:	50 e0       	ldi	r21, 0x00	; 0
    2c3a:	0e 94 d3 37 	call	0x6fa6	; 0x6fa6 <__udivmodsi4>
    2c3e:	21 15       	cp	r18, r1
    2c40:	31 05       	cpc	r19, r1
    2c42:	41 05       	cpc	r20, r1
    2c44:	51 05       	cpc	r21, r1
    2c46:	09 f4       	brne	.+2      	; 0x2c4a <find_volume+0x270>
    2c48:	5d cf       	rjmp	.-326    	; 0x2b04 <find_volume+0x12a>
    2c4a:	69 01       	movw	r12, r18
    2c4c:	7a 01       	movw	r14, r20
    2c4e:	f2 e0       	ldi	r31, 0x02	; 2
    2c50:	cf 0e       	add	r12, r31
    2c52:	d1 1c       	adc	r13, r1
    2c54:	e1 1c       	adc	r14, r1
    2c56:	f1 1c       	adc	r15, r1
    2c58:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2c5a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2c5c:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2c5e:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2c60:	84 0d       	add	r24, r4
    2c62:	95 1d       	adc	r25, r5
    2c64:	a6 1d       	adc	r26, r6
    2c66:	b7 1d       	adc	r27, r7
    2c68:	8a 8f       	std	Y+26, r24	; 0x1a
    2c6a:	9b 8f       	std	Y+27, r25	; 0x1b
    2c6c:	ac 8f       	std	Y+28, r26	; 0x1c
    2c6e:	bd 8f       	std	Y+29, r27	; 0x1d
    2c70:	8a 89       	ldd	r24, Y+18	; 0x12
    2c72:	9b 89       	ldd	r25, Y+19	; 0x13
    2c74:	ac 89       	ldd	r26, Y+20	; 0x14
    2c76:	bd 89       	ldd	r27, Y+21	; 0x15
    2c78:	84 0d       	add	r24, r4
    2c7a:	95 1d       	adc	r25, r5
    2c7c:	a6 1d       	adc	r26, r6
    2c7e:	b7 1d       	adc	r27, r7
    2c80:	8a 8b       	std	Y+18, r24	; 0x12
    2c82:	9b 8b       	std	Y+19, r25	; 0x13
    2c84:	ac 8b       	std	Y+20, r26	; 0x14
    2c86:	bd 8b       	std	Y+21, r27	; 0x15
    2c88:	26 3f       	cpi	r18, 0xF6	; 246
    2c8a:	9f e0       	ldi	r25, 0x0F	; 15
    2c8c:	39 07       	cpc	r19, r25
    2c8e:	41 05       	cpc	r20, r1
    2c90:	51 05       	cpc	r21, r1
    2c92:	b8 f1       	brcs	.+110    	; 0x2d02 <find_volume+0x328>
    2c94:	26 3f       	cpi	r18, 0xF6	; 246
    2c96:	3f 4f       	sbci	r19, 0xFF	; 255
    2c98:	41 05       	cpc	r20, r1
    2c9a:	51 05       	cpc	r21, r1
    2c9c:	08 f4       	brcc	.+2      	; 0x2ca0 <find_volume+0x2c6>
    2c9e:	f7 c0       	rjmp	.+494    	; 0x2e8e <find_volume+0x4b4>
    2ca0:	f8 01       	movw	r30, r16
    2ca2:	c2 8a       	std	Z+18, r12	; 0x12
    2ca4:	d3 8a       	std	Z+19, r13	; 0x13
    2ca6:	e4 8a       	std	Z+20, r14	; 0x14
    2ca8:	f5 8a       	std	Z+21, r15	; 0x15
    2caa:	42 8e       	std	Z+26, r4	; 0x1a
    2cac:	53 8e       	std	Z+27, r5	; 0x1b
    2cae:	64 8e       	std	Z+28, r6	; 0x1c
    2cb0:	75 8e       	std	Z+29, r7	; 0x1d
    2cb2:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2cb4:	3b 8d       	ldd	r19, Y+27	; 0x1b
    2cb6:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2cb8:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2cba:	26 8f       	std	Z+30, r18	; 0x1e
    2cbc:	37 8f       	std	Z+31, r19	; 0x1f
    2cbe:	40 a3       	std	Z+32, r20	; 0x20
    2cc0:	51 a3       	std	Z+33, r21	; 0x21
    2cc2:	2a 89       	ldd	r18, Y+18	; 0x12
    2cc4:	3b 89       	ldd	r19, Y+19	; 0x13
    2cc6:	4c 89       	ldd	r20, Y+20	; 0x14
    2cc8:	5d 89       	ldd	r21, Y+21	; 0x15
    2cca:	26 a3       	std	Z+38, r18	; 0x26
    2ccc:	37 a3       	std	Z+39, r19	; 0x27
    2cce:	40 a7       	std	Z+40, r20	; 0x28
    2cd0:	51 a7       	std	Z+41, r21	; 0x29
    2cd2:	23 28       	or	r2, r3
    2cd4:	09 f0       	breq	.+2      	; 0x2cd8 <find_volume+0x2fe>
    2cd6:	16 cf       	rjmp	.-468    	; 0x2b04 <find_volume+0x12a>
    2cd8:	e6 5a       	subi	r30, 0xA6	; 166
    2cda:	ff 4f       	sbci	r31, 0xFF	; 255
    2cdc:	80 81       	ld	r24, Z
    2cde:	91 81       	ldd	r25, Z+1	; 0x01
    2ce0:	a2 81       	ldd	r26, Z+2	; 0x02
    2ce2:	b3 81       	ldd	r27, Z+3	; 0x03
    2ce4:	f8 01       	movw	r30, r16
    2ce6:	82 a3       	std	Z+34, r24	; 0x22
    2ce8:	93 a3       	std	Z+35, r25	; 0x23
    2cea:	a4 a3       	std	Z+36, r26	; 0x24
    2cec:	b5 a3       	std	Z+37, r27	; 0x25
    2cee:	42 e0       	ldi	r20, 0x02	; 2
    2cf0:	cc 0c       	add	r12, r12
    2cf2:	dd 1c       	adc	r13, r13
    2cf4:	ee 1c       	adc	r14, r14
    2cf6:	ff 1c       	adc	r15, r15
    2cf8:	4a 95       	dec	r20
    2cfa:	d1 f7       	brne	.-12     	; 0x2cf0 <find_volume+0x316>
    2cfc:	f3 e0       	ldi	r31, 0x03	; 3
    2cfe:	f9 8b       	std	Y+17, r31	; 0x11
    2d00:	3e c0       	rjmp	.+124    	; 0x2d7e <find_volume+0x3a4>
    2d02:	f1 e0       	ldi	r31, 0x01	; 1
    2d04:	f9 8b       	std	Y+17, r31	; 0x11
    2d06:	d8 01       	movw	r26, r16
    2d08:	52 96       	adiw	r26, 0x12	; 18
    2d0a:	cd 92       	st	X+, r12
    2d0c:	dd 92       	st	X+, r13
    2d0e:	ed 92       	st	X+, r14
    2d10:	fc 92       	st	X, r15
    2d12:	55 97       	sbiw	r26, 0x15	; 21
    2d14:	f8 01       	movw	r30, r16
    2d16:	42 8e       	std	Z+26, r4	; 0x1a
    2d18:	53 8e       	std	Z+27, r5	; 0x1b
    2d1a:	64 8e       	std	Z+28, r6	; 0x1c
    2d1c:	75 8e       	std	Z+29, r7	; 0x1d
    2d1e:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2d20:	3b 8d       	ldd	r19, Y+27	; 0x1b
    2d22:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2d24:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2d26:	5e 96       	adiw	r26, 0x1e	; 30
    2d28:	2d 93       	st	X+, r18
    2d2a:	3d 93       	st	X+, r19
    2d2c:	4d 93       	st	X+, r20
    2d2e:	5c 93       	st	X, r21
    2d30:	91 97       	sbiw	r26, 0x21	; 33
    2d32:	2a 89       	ldd	r18, Y+18	; 0x12
    2d34:	3b 89       	ldd	r19, Y+19	; 0x13
    2d36:	4c 89       	ldd	r20, Y+20	; 0x14
    2d38:	5d 89       	ldd	r21, Y+21	; 0x15
    2d3a:	96 96       	adiw	r26, 0x26	; 38
    2d3c:	2d 93       	st	X+, r18
    2d3e:	3d 93       	st	X+, r19
    2d40:	4d 93       	st	X+, r20
    2d42:	5c 93       	st	X, r21
    2d44:	99 97       	sbiw	r26, 0x29	; 41
    2d46:	23 28       	or	r2, r3
    2d48:	09 f4       	brne	.+2      	; 0x2d4c <find_volume+0x372>
    2d4a:	dc ce       	rjmp	.-584    	; 0x2b04 <find_volume+0x12a>
    2d4c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2d4e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2d50:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2d52:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2d54:	2e 89       	ldd	r18, Y+22	; 0x16
    2d56:	3f 89       	ldd	r19, Y+23	; 0x17
    2d58:	48 8d       	ldd	r20, Y+24	; 0x18
    2d5a:	59 8d       	ldd	r21, Y+25	; 0x19
    2d5c:	82 0f       	add	r24, r18
    2d5e:	93 1f       	adc	r25, r19
    2d60:	a4 1f       	adc	r26, r20
    2d62:	b5 1f       	adc	r27, r21
    2d64:	f8 01       	movw	r30, r16
    2d66:	82 a3       	std	Z+34, r24	; 0x22
    2d68:	93 a3       	std	Z+35, r25	; 0x23
    2d6a:	a4 a3       	std	Z+36, r26	; 0x24
    2d6c:	b5 a3       	std	Z+37, r27	; 0x25
    2d6e:	f9 89       	ldd	r31, Y+17	; 0x11
    2d70:	f2 30       	cpi	r31, 0x02	; 2
    2d72:	09 f0       	breq	.+2      	; 0x2d76 <find_volume+0x39c>
    2d74:	8f c0       	rjmp	.+286    	; 0x2e94 <find_volume+0x4ba>
    2d76:	cc 0c       	add	r12, r12
    2d78:	dd 1c       	adc	r13, r13
    2d7a:	ee 1c       	adc	r14, r14
    2d7c:	ff 1c       	adc	r15, r15
    2d7e:	4f ef       	ldi	r20, 0xFF	; 255
    2d80:	c4 0e       	add	r12, r20
    2d82:	41 e0       	ldi	r20, 0x01	; 1
    2d84:	d4 1e       	adc	r13, r20
    2d86:	e1 1c       	adc	r14, r1
    2d88:	f1 1c       	adc	r15, r1
    2d8a:	89 e0       	ldi	r24, 0x09	; 9
    2d8c:	f6 94       	lsr	r15
    2d8e:	e7 94       	ror	r14
    2d90:	d7 94       	ror	r13
    2d92:	c7 94       	ror	r12
    2d94:	8a 95       	dec	r24
    2d96:	d1 f7       	brne	.-12     	; 0x2d8c <find_volume+0x3b2>
    2d98:	8c 14       	cp	r8, r12
    2d9a:	9d 04       	cpc	r9, r13
    2d9c:	ae 04       	cpc	r10, r14
    2d9e:	bf 04       	cpc	r11, r15
    2da0:	08 f4       	brcc	.+2      	; 0x2da4 <find_volume+0x3ca>
    2da2:	b0 ce       	rjmp	.-672    	; 0x2b04 <find_volume+0x12a>
    2da4:	8f ef       	ldi	r24, 0xFF	; 255
    2da6:	9f ef       	ldi	r25, 0xFF	; 255
    2da8:	dc 01       	movw	r26, r24
    2daa:	f8 01       	movw	r30, r16
    2dac:	86 87       	std	Z+14, r24	; 0x0e
    2dae:	97 87       	std	Z+15, r25	; 0x0f
    2db0:	a0 8b       	std	Z+16, r26	; 0x10
    2db2:	b1 8b       	std	Z+17, r27	; 0x11
    2db4:	82 87       	std	Z+10, r24	; 0x0a
    2db6:	93 87       	std	Z+11, r25	; 0x0b
    2db8:	a4 87       	std	Z+12, r26	; 0x0c
    2dba:	b5 87       	std	Z+13, r27	; 0x0d
    2dbc:	80 e8       	ldi	r24, 0x80	; 128
    2dbe:	85 83       	std	Z+5, r24	; 0x05
    2dc0:	f9 89       	ldd	r31, Y+17	; 0x11
    2dc2:	f3 30       	cpi	r31, 0x03	; 3
    2dc4:	09 f0       	breq	.+2      	; 0x2dc8 <find_volume+0x3ee>
    2dc6:	48 c0       	rjmp	.+144    	; 0x2e58 <find_volume+0x47e>
    2dc8:	f8 01       	movw	r30, r16
    2dca:	e2 5a       	subi	r30, 0xA2	; 162
    2dcc:	ff 4f       	sbci	r31, 0xFF	; 255
    2dce:	80 81       	ld	r24, Z
    2dd0:	91 81       	ldd	r25, Z+1	; 0x01
    2dd2:	01 97       	sbiw	r24, 0x01	; 1
    2dd4:	09 f0       	breq	.+2      	; 0x2dd8 <find_volume+0x3fe>
    2dd6:	40 c0       	rjmp	.+128    	; 0x2e58 <find_volume+0x47e>
    2dd8:	b3 01       	movw	r22, r6
    2dda:	a2 01       	movw	r20, r4
    2ddc:	4f 5f       	subi	r20, 0xFF	; 255
    2dde:	5f 4f       	sbci	r21, 0xFF	; 255
    2de0:	6f 4f       	sbci	r22, 0xFF	; 255
    2de2:	7f 4f       	sbci	r23, 0xFF	; 255
    2de4:	c8 01       	movw	r24, r16
    2de6:	84 dd       	rcall	.-1272   	; 0x28f0 <move_window>
    2de8:	81 11       	cpse	r24, r1
    2dea:	36 c0       	rjmp	.+108    	; 0x2e58 <find_volume+0x47e>
    2dec:	d8 01       	movw	r26, r16
    2dee:	15 96       	adiw	r26, 0x05	; 5
    2df0:	1c 92       	st	X, r1
    2df2:	f8 01       	movw	r30, r16
    2df4:	e4 5d       	subi	r30, 0xD4	; 212
    2df6:	fd 4f       	sbci	r31, 0xFD	; 253
    2df8:	80 81       	ld	r24, Z
    2dfa:	91 81       	ldd	r25, Z+1	; 0x01
    2dfc:	85 35       	cpi	r24, 0x55	; 85
    2dfe:	9a 4a       	sbci	r25, 0xAA	; 170
    2e00:	59 f5       	brne	.+86     	; 0x2e58 <find_volume+0x47e>
    2e02:	f8 01       	movw	r30, r16
    2e04:	86 a5       	ldd	r24, Z+46	; 0x2e
    2e06:	97 a5       	ldd	r25, Z+47	; 0x2f
    2e08:	a0 a9       	ldd	r26, Z+48	; 0x30
    2e0a:	b1 a9       	ldd	r27, Z+49	; 0x31
    2e0c:	82 35       	cpi	r24, 0x52	; 82
    2e0e:	92 45       	sbci	r25, 0x52	; 82
    2e10:	a1 46       	sbci	r26, 0x61	; 97
    2e12:	b1 44       	sbci	r27, 0x41	; 65
    2e14:	09 f5       	brne	.+66     	; 0x2e58 <find_volume+0x47e>
    2e16:	f8 01       	movw	r30, r16
    2e18:	ee 5e       	subi	r30, 0xEE	; 238
    2e1a:	fd 4f       	sbci	r31, 0xFD	; 253
    2e1c:	80 81       	ld	r24, Z
    2e1e:	91 81       	ldd	r25, Z+1	; 0x01
    2e20:	a2 81       	ldd	r26, Z+2	; 0x02
    2e22:	b3 81       	ldd	r27, Z+3	; 0x03
    2e24:	82 37       	cpi	r24, 0x72	; 114
    2e26:	92 47       	sbci	r25, 0x72	; 114
    2e28:	a1 44       	sbci	r26, 0x41	; 65
    2e2a:	b1 46       	sbci	r27, 0x61	; 97
    2e2c:	a9 f4       	brne	.+42     	; 0x2e58 <find_volume+0x47e>
    2e2e:	34 96       	adiw	r30, 0x04	; 4
    2e30:	80 81       	ld	r24, Z
    2e32:	91 81       	ldd	r25, Z+1	; 0x01
    2e34:	a2 81       	ldd	r26, Z+2	; 0x02
    2e36:	b3 81       	ldd	r27, Z+3	; 0x03
    2e38:	f8 01       	movw	r30, r16
    2e3a:	86 87       	std	Z+14, r24	; 0x0e
    2e3c:	97 87       	std	Z+15, r25	; 0x0f
    2e3e:	a0 8b       	std	Z+16, r26	; 0x10
    2e40:	b1 8b       	std	Z+17, r27	; 0x11
    2e42:	e6 5e       	subi	r30, 0xE6	; 230
    2e44:	fd 4f       	sbci	r31, 0xFD	; 253
    2e46:	80 81       	ld	r24, Z
    2e48:	91 81       	ldd	r25, Z+1	; 0x01
    2e4a:	a2 81       	ldd	r26, Z+2	; 0x02
    2e4c:	b3 81       	ldd	r27, Z+3	; 0x03
    2e4e:	f8 01       	movw	r30, r16
    2e50:	82 87       	std	Z+10, r24	; 0x0a
    2e52:	93 87       	std	Z+11, r25	; 0x0b
    2e54:	a4 87       	std	Z+12, r26	; 0x0c
    2e56:	b5 87       	std	Z+13, r27	; 0x0d
    2e58:	e9 89       	ldd	r30, Y+17	; 0x11
    2e5a:	d8 01       	movw	r26, r16
    2e5c:	ec 93       	st	X, r30
    2e5e:	80 91 36 05 	lds	r24, 0x0536	; 0x800536 <Fsid>
    2e62:	90 91 37 05 	lds	r25, 0x0537	; 0x800537 <Fsid+0x1>
    2e66:	01 96       	adiw	r24, 0x01	; 1
    2e68:	90 93 37 05 	sts	0x0537, r25	; 0x800537 <Fsid+0x1>
    2e6c:	80 93 36 05 	sts	0x0536, r24	; 0x800536 <Fsid>
    2e70:	17 96       	adiw	r26, 0x07	; 7
    2e72:	9c 93       	st	X, r25
    2e74:	8e 93       	st	-X, r24
    2e76:	16 97       	sbiw	r26, 0x06	; 6
    2e78:	04 c0       	rjmp	.+8      	; 0x2e82 <find_volume+0x4a8>
    2e7a:	8b e0       	ldi	r24, 0x0B	; 11
    2e7c:	23 c0       	rjmp	.+70     	; 0x2ec4 <find_volume+0x4ea>
    2e7e:	8c e0       	ldi	r24, 0x0C	; 12
    2e80:	21 c0       	rjmp	.+66     	; 0x2ec4 <find_volume+0x4ea>
    2e82:	80 e0       	ldi	r24, 0x00	; 0
    2e84:	1f c0       	rjmp	.+62     	; 0x2ec4 <find_volume+0x4ea>
    2e86:	83 e0       	ldi	r24, 0x03	; 3
    2e88:	1d c0       	rjmp	.+58     	; 0x2ec4 <find_volume+0x4ea>
    2e8a:	81 e0       	ldi	r24, 0x01	; 1
    2e8c:	1b c0       	rjmp	.+54     	; 0x2ec4 <find_volume+0x4ea>
    2e8e:	22 e0       	ldi	r18, 0x02	; 2
    2e90:	29 8b       	std	Y+17, r18	; 0x11
    2e92:	39 cf       	rjmp	.-398    	; 0x2d06 <find_volume+0x32c>
    2e94:	a3 e0       	ldi	r26, 0x03	; 3
    2e96:	b0 e0       	ldi	r27, 0x00	; 0
    2e98:	a7 01       	movw	r20, r14
    2e9a:	96 01       	movw	r18, r12
    2e9c:	0e 94 f5 37 	call	0x6fea	; 0x6fea <__muluhisi3>
    2ea0:	dc 01       	movw	r26, r24
    2ea2:	cb 01       	movw	r24, r22
    2ea4:	b6 95       	lsr	r27
    2ea6:	a7 95       	ror	r26
    2ea8:	97 95       	ror	r25
    2eaa:	87 95       	ror	r24
    2eac:	21 e0       	ldi	r18, 0x01	; 1
    2eae:	c2 22       	and	r12, r18
    2eb0:	dd 24       	eor	r13, r13
    2eb2:	ee 24       	eor	r14, r14
    2eb4:	ff 24       	eor	r15, r15
    2eb6:	c8 0e       	add	r12, r24
    2eb8:	d9 1e       	adc	r13, r25
    2eba:	ea 1e       	adc	r14, r26
    2ebc:	fb 1e       	adc	r15, r27
    2ebe:	31 e0       	ldi	r19, 0x01	; 1
    2ec0:	39 8b       	std	Y+17, r19	; 0x11
    2ec2:	5d cf       	rjmp	.-326    	; 0x2d7e <find_volume+0x3a4>
    2ec4:	6d 96       	adiw	r28, 0x1d	; 29
    2ec6:	0f b6       	in	r0, 0x3f	; 63
    2ec8:	f8 94       	cli
    2eca:	de bf       	out	0x3e, r29	; 62
    2ecc:	0f be       	out	0x3f, r0	; 63
    2ece:	cd bf       	out	0x3d, r28	; 61
    2ed0:	df 91       	pop	r29
    2ed2:	cf 91       	pop	r28
    2ed4:	1f 91       	pop	r17
    2ed6:	0f 91       	pop	r16
    2ed8:	ff 90       	pop	r15
    2eda:	ef 90       	pop	r14
    2edc:	df 90       	pop	r13
    2ede:	cf 90       	pop	r12
    2ee0:	bf 90       	pop	r11
    2ee2:	af 90       	pop	r10
    2ee4:	9f 90       	pop	r9
    2ee6:	8f 90       	pop	r8
    2ee8:	7f 90       	pop	r7
    2eea:	6f 90       	pop	r6
    2eec:	5f 90       	pop	r5
    2eee:	4f 90       	pop	r4
    2ef0:	3f 90       	pop	r3
    2ef2:	2f 90       	pop	r2
    2ef4:	08 95       	ret

00002ef6 <sync_fs>:
    2ef6:	0f 93       	push	r16
    2ef8:	1f 93       	push	r17
    2efa:	cf 93       	push	r28
    2efc:	df 93       	push	r29
    2efe:	ec 01       	movw	r28, r24
    2f00:	f1 dc       	rcall	.-1566   	; 0x28e4 <sync_window>
    2f02:	98 2f       	mov	r25, r24
    2f04:	81 11       	cpse	r24, r1
    2f06:	5a c0       	rjmp	.+180    	; 0x2fbc <sync_fs+0xc6>
    2f08:	88 81       	ld	r24, Y
    2f0a:	83 30       	cpi	r24, 0x03	; 3
    2f0c:	09 f0       	breq	.+2      	; 0x2f10 <sync_fs+0x1a>
    2f0e:	4d c0       	rjmp	.+154    	; 0x2faa <sync_fs+0xb4>
    2f10:	8d 81       	ldd	r24, Y+5	; 0x05
    2f12:	81 30       	cpi	r24, 0x01	; 1
    2f14:	09 f0       	breq	.+2      	; 0x2f18 <sync_fs+0x22>
    2f16:	49 c0       	rjmp	.+146    	; 0x2faa <sync_fs+0xb4>
    2f18:	be 01       	movw	r22, r28
    2f1a:	62 5d       	subi	r22, 0xD2	; 210
    2f1c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f1e:	fb 01       	movw	r30, r22
    2f20:	ce 01       	movw	r24, r28
    2f22:	82 5d       	subi	r24, 0xD2	; 210
    2f24:	9d 4f       	sbci	r25, 0xFD	; 253
    2f26:	e8 17       	cp	r30, r24
    2f28:	f9 07       	cpc	r31, r25
    2f2a:	11 f0       	breq	.+4      	; 0x2f30 <sync_fs+0x3a>
    2f2c:	11 92       	st	Z+, r1
    2f2e:	fb cf       	rjmp	.-10     	; 0x2f26 <sync_fs+0x30>
    2f30:	85 e5       	ldi	r24, 0x55	; 85
    2f32:	9a ea       	ldi	r25, 0xAA	; 170
    2f34:	fe 01       	movw	r30, r28
    2f36:	e4 5d       	subi	r30, 0xD4	; 212
    2f38:	fd 4f       	sbci	r31, 0xFD	; 253
    2f3a:	91 83       	std	Z+1, r25	; 0x01
    2f3c:	80 83       	st	Z, r24
    2f3e:	82 e5       	ldi	r24, 0x52	; 82
    2f40:	92 e5       	ldi	r25, 0x52	; 82
    2f42:	a1 e6       	ldi	r26, 0x61	; 97
    2f44:	b1 e4       	ldi	r27, 0x41	; 65
    2f46:	8e a7       	std	Y+46, r24	; 0x2e
    2f48:	9f a7       	std	Y+47, r25	; 0x2f
    2f4a:	a8 ab       	std	Y+48, r26	; 0x30
    2f4c:	b9 ab       	std	Y+49, r27	; 0x31
    2f4e:	82 e7       	ldi	r24, 0x72	; 114
    2f50:	92 e7       	ldi	r25, 0x72	; 114
    2f52:	a1 e4       	ldi	r26, 0x41	; 65
    2f54:	b1 e6       	ldi	r27, 0x61	; 97
    2f56:	7a 97       	sbiw	r30, 0x1a	; 26
    2f58:	80 83       	st	Z, r24
    2f5a:	91 83       	std	Z+1, r25	; 0x01
    2f5c:	a2 83       	std	Z+2, r26	; 0x02
    2f5e:	b3 83       	std	Z+3, r27	; 0x03
    2f60:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f62:	9f 85       	ldd	r25, Y+15	; 0x0f
    2f64:	a8 89       	ldd	r26, Y+16	; 0x10
    2f66:	b9 89       	ldd	r27, Y+17	; 0x11
    2f68:	34 96       	adiw	r30, 0x04	; 4
    2f6a:	80 83       	st	Z, r24
    2f6c:	91 83       	std	Z+1, r25	; 0x01
    2f6e:	a2 83       	std	Z+2, r26	; 0x02
    2f70:	b3 83       	std	Z+3, r27	; 0x03
    2f72:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f74:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f76:	ac 85       	ldd	r26, Y+12	; 0x0c
    2f78:	bd 85       	ldd	r27, Y+13	; 0x0d
    2f7a:	34 96       	adiw	r30, 0x04	; 4
    2f7c:	80 83       	st	Z, r24
    2f7e:	91 83       	std	Z+1, r25	; 0x01
    2f80:	a2 83       	std	Z+2, r26	; 0x02
    2f82:	b3 83       	std	Z+3, r27	; 0x03
    2f84:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2f86:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2f88:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2f8a:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2f8c:	9c 01       	movw	r18, r24
    2f8e:	ad 01       	movw	r20, r26
    2f90:	2f 5f       	subi	r18, 0xFF	; 255
    2f92:	3f 4f       	sbci	r19, 0xFF	; 255
    2f94:	4f 4f       	sbci	r20, 0xFF	; 255
    2f96:	5f 4f       	sbci	r21, 0xFF	; 255
    2f98:	2a a7       	std	Y+42, r18	; 0x2a
    2f9a:	3b a7       	std	Y+43, r19	; 0x2b
    2f9c:	4c a7       	std	Y+44, r20	; 0x2c
    2f9e:	5d a7       	std	Y+45, r21	; 0x2d
    2fa0:	01 e0       	ldi	r16, 0x01	; 1
    2fa2:	10 e0       	ldi	r17, 0x00	; 0
    2fa4:	89 81       	ldd	r24, Y+1	; 0x01
    2fa6:	9e da       	rcall	.-2756   	; 0x24e4 <disk_write>
    2fa8:	1d 82       	std	Y+5, r1	; 0x05
    2faa:	40 e0       	ldi	r20, 0x00	; 0
    2fac:	50 e0       	ldi	r21, 0x00	; 0
    2fae:	60 e0       	ldi	r22, 0x00	; 0
    2fb0:	89 81       	ldd	r24, Y+1	; 0x01
    2fb2:	f8 da       	rcall	.-2576   	; 0x25a4 <disk_ioctl>
    2fb4:	91 e0       	ldi	r25, 0x01	; 1
    2fb6:	81 11       	cpse	r24, r1
    2fb8:	01 c0       	rjmp	.+2      	; 0x2fbc <sync_fs+0xc6>
    2fba:	90 e0       	ldi	r25, 0x00	; 0
    2fbc:	89 2f       	mov	r24, r25
    2fbe:	df 91       	pop	r29
    2fc0:	cf 91       	pop	r28
    2fc2:	1f 91       	pop	r17
    2fc4:	0f 91       	pop	r16
    2fc6:	08 95       	ret

00002fc8 <clust2sect>:
    2fc8:	0f 93       	push	r16
    2fca:	1f 93       	push	r17
    2fcc:	fc 01       	movw	r30, r24
    2fce:	9a 01       	movw	r18, r20
    2fd0:	ab 01       	movw	r20, r22
    2fd2:	22 50       	subi	r18, 0x02	; 2
    2fd4:	31 09       	sbc	r19, r1
    2fd6:	41 09       	sbc	r20, r1
    2fd8:	51 09       	sbc	r21, r1
    2fda:	82 89       	ldd	r24, Z+18	; 0x12
    2fdc:	93 89       	ldd	r25, Z+19	; 0x13
    2fde:	a4 89       	ldd	r26, Z+20	; 0x14
    2fe0:	b5 89       	ldd	r27, Z+21	; 0x15
    2fe2:	02 97       	sbiw	r24, 0x02	; 2
    2fe4:	a1 09       	sbc	r26, r1
    2fe6:	b1 09       	sbc	r27, r1
    2fe8:	28 17       	cp	r18, r24
    2fea:	39 07       	cpc	r19, r25
    2fec:	4a 07       	cpc	r20, r26
    2fee:	5b 07       	cpc	r21, r27
    2ff0:	68 f4       	brcc	.+26     	; 0x300c <clust2sect+0x44>
    2ff2:	a2 81       	ldd	r26, Z+2	; 0x02
    2ff4:	b0 e0       	ldi	r27, 0x00	; 0
    2ff6:	0e 94 f5 37 	call	0x6fea	; 0x6fea <__muluhisi3>
    2ffa:	06 a1       	ldd	r16, Z+38	; 0x26
    2ffc:	17 a1       	ldd	r17, Z+39	; 0x27
    2ffe:	20 a5       	ldd	r18, Z+40	; 0x28
    3000:	31 a5       	ldd	r19, Z+41	; 0x29
    3002:	60 0f       	add	r22, r16
    3004:	71 1f       	adc	r23, r17
    3006:	82 1f       	adc	r24, r18
    3008:	93 1f       	adc	r25, r19
    300a:	03 c0       	rjmp	.+6      	; 0x3012 <clust2sect+0x4a>
    300c:	60 e0       	ldi	r22, 0x00	; 0
    300e:	70 e0       	ldi	r23, 0x00	; 0
    3010:	cb 01       	movw	r24, r22
    3012:	1f 91       	pop	r17
    3014:	0f 91       	pop	r16
    3016:	08 95       	ret

00003018 <get_fat>:
    3018:	af 92       	push	r10
    301a:	bf 92       	push	r11
    301c:	cf 92       	push	r12
    301e:	df 92       	push	r13
    3020:	ef 92       	push	r14
    3022:	ff 92       	push	r15
    3024:	0f 93       	push	r16
    3026:	1f 93       	push	r17
    3028:	cf 93       	push	r28
    302a:	df 93       	push	r29
    302c:	42 30       	cpi	r20, 0x02	; 2
    302e:	51 05       	cpc	r21, r1
    3030:	61 05       	cpc	r22, r1
    3032:	71 05       	cpc	r23, r1
    3034:	08 f4       	brcc	.+2      	; 0x3038 <get_fat+0x20>
    3036:	aa c0       	rjmp	.+340    	; 0x318c <get_fat+0x174>
    3038:	fc 01       	movw	r30, r24
    303a:	02 89       	ldd	r16, Z+18	; 0x12
    303c:	13 89       	ldd	r17, Z+19	; 0x13
    303e:	24 89       	ldd	r18, Z+20	; 0x14
    3040:	35 89       	ldd	r19, Z+21	; 0x15
    3042:	40 17       	cp	r20, r16
    3044:	51 07       	cpc	r21, r17
    3046:	62 07       	cpc	r22, r18
    3048:	73 07       	cpc	r23, r19
    304a:	08 f0       	brcs	.+2      	; 0x304e <get_fat+0x36>
    304c:	9f c0       	rjmp	.+318    	; 0x318c <get_fat+0x174>
    304e:	6a 01       	movw	r12, r20
    3050:	7b 01       	movw	r14, r22
    3052:	8c 01       	movw	r16, r24
    3054:	80 81       	ld	r24, Z
    3056:	82 30       	cpi	r24, 0x02	; 2
    3058:	09 f4       	brne	.+2      	; 0x305c <get_fat+0x44>
    305a:	4b c0       	rjmp	.+150    	; 0x30f2 <get_fat+0xda>
    305c:	83 30       	cpi	r24, 0x03	; 3
    305e:	09 f4       	brne	.+2      	; 0x3062 <get_fat+0x4a>
    3060:	6a c0       	rjmp	.+212    	; 0x3136 <get_fat+0x11e>
    3062:	81 30       	cpi	r24, 0x01	; 1
    3064:	09 f0       	breq	.+2      	; 0x3068 <get_fat+0x50>
    3066:	92 c0       	rjmp	.+292    	; 0x318c <get_fat+0x174>
    3068:	ea 01       	movw	r28, r20
    306a:	d6 95       	lsr	r29
    306c:	c7 95       	ror	r28
    306e:	cc 0d       	add	r28, r12
    3070:	dd 1d       	adc	r29, r13
    3072:	ce 01       	movw	r24, r28
    3074:	89 2f       	mov	r24, r25
    3076:	99 27       	eor	r25, r25
    3078:	86 95       	lsr	r24
    307a:	46 8d       	ldd	r20, Z+30	; 0x1e
    307c:	57 8d       	ldd	r21, Z+31	; 0x1f
    307e:	60 a1       	ldd	r22, Z+32	; 0x20
    3080:	71 a1       	ldd	r23, Z+33	; 0x21
    3082:	48 0f       	add	r20, r24
    3084:	59 1f       	adc	r21, r25
    3086:	61 1d       	adc	r22, r1
    3088:	71 1d       	adc	r23, r1
    308a:	cf 01       	movw	r24, r30
    308c:	31 dc       	rcall	.-1950   	; 0x28f0 <move_window>
    308e:	88 23       	and	r24, r24
    3090:	21 f0       	breq	.+8      	; 0x309a <get_fat+0x82>
    3092:	6f ef       	ldi	r22, 0xFF	; 255
    3094:	7f ef       	ldi	r23, 0xFF	; 255
    3096:	cb 01       	movw	r24, r22
    3098:	7d c0       	rjmp	.+250    	; 0x3194 <get_fat+0x17c>
    309a:	5e 01       	movw	r10, r28
    309c:	ff ef       	ldi	r31, 0xFF	; 255
    309e:	af 1a       	sub	r10, r31
    30a0:	bf 0a       	sbc	r11, r31
    30a2:	d1 70       	andi	r29, 0x01	; 1
    30a4:	c0 0f       	add	r28, r16
    30a6:	d1 1f       	adc	r29, r17
    30a8:	ce a5       	ldd	r28, Y+46	; 0x2e
    30aa:	c5 01       	movw	r24, r10
    30ac:	89 2f       	mov	r24, r25
    30ae:	99 27       	eor	r25, r25
    30b0:	86 95       	lsr	r24
    30b2:	f8 01       	movw	r30, r16
    30b4:	46 8d       	ldd	r20, Z+30	; 0x1e
    30b6:	57 8d       	ldd	r21, Z+31	; 0x1f
    30b8:	60 a1       	ldd	r22, Z+32	; 0x20
    30ba:	71 a1       	ldd	r23, Z+33	; 0x21
    30bc:	48 0f       	add	r20, r24
    30be:	59 1f       	adc	r21, r25
    30c0:	61 1d       	adc	r22, r1
    30c2:	71 1d       	adc	r23, r1
    30c4:	c8 01       	movw	r24, r16
    30c6:	14 dc       	rcall	.-2008   	; 0x28f0 <move_window>
    30c8:	81 11       	cpse	r24, r1
    30ca:	e3 cf       	rjmp	.-58     	; 0x3092 <get_fat+0x7a>
    30cc:	f1 e0       	ldi	r31, 0x01	; 1
    30ce:	bf 22       	and	r11, r31
    30d0:	f8 01       	movw	r30, r16
    30d2:	ea 0d       	add	r30, r10
    30d4:	fb 1d       	adc	r31, r11
    30d6:	86 a5       	ldd	r24, Z+46	; 0x2e
    30d8:	6c 2f       	mov	r22, r28
    30da:	70 e0       	ldi	r23, 0x00	; 0
    30dc:	78 2b       	or	r23, r24
    30de:	c0 fe       	sbrs	r12, 0
    30e0:	06 c0       	rjmp	.+12     	; 0x30ee <get_fat+0xd6>
    30e2:	54 e0       	ldi	r21, 0x04	; 4
    30e4:	76 95       	lsr	r23
    30e6:	67 95       	ror	r22
    30e8:	5a 95       	dec	r21
    30ea:	e1 f7       	brne	.-8      	; 0x30e4 <get_fat+0xcc>
    30ec:	21 c0       	rjmp	.+66     	; 0x3130 <get_fat+0x118>
    30ee:	7f 70       	andi	r23, 0x0F	; 15
    30f0:	1f c0       	rjmp	.+62     	; 0x3130 <get_fat+0x118>
    30f2:	77 27       	eor	r23, r23
    30f4:	6f 2d       	mov	r22, r15
    30f6:	5e 2d       	mov	r21, r14
    30f8:	4d 2d       	mov	r20, r13
    30fa:	86 8d       	ldd	r24, Z+30	; 0x1e
    30fc:	97 8d       	ldd	r25, Z+31	; 0x1f
    30fe:	a0 a1       	ldd	r26, Z+32	; 0x20
    3100:	b1 a1       	ldd	r27, Z+33	; 0x21
    3102:	48 0f       	add	r20, r24
    3104:	59 1f       	adc	r21, r25
    3106:	6a 1f       	adc	r22, r26
    3108:	7b 1f       	adc	r23, r27
    310a:	cf 01       	movw	r24, r30
    310c:	f1 db       	rcall	.-2078   	; 0x28f0 <move_window>
    310e:	81 11       	cpse	r24, r1
    3110:	c0 cf       	rjmp	.-128    	; 0x3092 <get_fat+0x7a>
    3112:	cc 0c       	add	r12, r12
    3114:	dd 1c       	adc	r13, r13
    3116:	ee 1c       	adc	r14, r14
    3118:	ff 1c       	adc	r15, r15
    311a:	e8 94       	clt
    311c:	c0 f8       	bld	r12, 0
    311e:	f1 e0       	ldi	r31, 0x01	; 1
    3120:	df 22       	and	r13, r31
    3122:	ee 24       	eor	r14, r14
    3124:	ff 24       	eor	r15, r15
    3126:	f8 01       	movw	r30, r16
    3128:	ec 0d       	add	r30, r12
    312a:	fd 1d       	adc	r31, r13
    312c:	66 a5       	ldd	r22, Z+46	; 0x2e
    312e:	77 a5       	ldd	r23, Z+47	; 0x2f
    3130:	80 e0       	ldi	r24, 0x00	; 0
    3132:	90 e0       	ldi	r25, 0x00	; 0
    3134:	2f c0       	rjmp	.+94     	; 0x3194 <get_fat+0x17c>
    3136:	86 8d       	ldd	r24, Z+30	; 0x1e
    3138:	97 8d       	ldd	r25, Z+31	; 0x1f
    313a:	a0 a1       	ldd	r26, Z+32	; 0x20
    313c:	b1 a1       	ldd	r27, Z+33	; 0x21
    313e:	27 e0       	ldi	r18, 0x07	; 7
    3140:	76 95       	lsr	r23
    3142:	67 95       	ror	r22
    3144:	57 95       	ror	r21
    3146:	47 95       	ror	r20
    3148:	2a 95       	dec	r18
    314a:	d1 f7       	brne	.-12     	; 0x3140 <get_fat+0x128>
    314c:	48 0f       	add	r20, r24
    314e:	59 1f       	adc	r21, r25
    3150:	6a 1f       	adc	r22, r26
    3152:	7b 1f       	adc	r23, r27
    3154:	cf 01       	movw	r24, r30
    3156:	cc db       	rcall	.-2152   	; 0x28f0 <move_window>
    3158:	81 11       	cpse	r24, r1
    315a:	9b cf       	rjmp	.-202    	; 0x3092 <get_fat+0x7a>
    315c:	82 e0       	ldi	r24, 0x02	; 2
    315e:	cc 0c       	add	r12, r12
    3160:	dd 1c       	adc	r13, r13
    3162:	ee 1c       	adc	r14, r14
    3164:	ff 1c       	adc	r15, r15
    3166:	8a 95       	dec	r24
    3168:	d1 f7       	brne	.-12     	; 0x315e <get_fat+0x146>
    316a:	fc ef       	ldi	r31, 0xFC	; 252
    316c:	cf 22       	and	r12, r31
    316e:	f1 e0       	ldi	r31, 0x01	; 1
    3170:	df 22       	and	r13, r31
    3172:	ee 24       	eor	r14, r14
    3174:	ff 24       	eor	r15, r15
    3176:	f8 01       	movw	r30, r16
    3178:	ec 0d       	add	r30, r12
    317a:	fd 1d       	adc	r31, r13
    317c:	86 a5       	ldd	r24, Z+46	; 0x2e
    317e:	97 a5       	ldd	r25, Z+47	; 0x2f
    3180:	a0 a9       	ldd	r26, Z+48	; 0x30
    3182:	b1 a9       	ldd	r27, Z+49	; 0x31
    3184:	bc 01       	movw	r22, r24
    3186:	cd 01       	movw	r24, r26
    3188:	9f 70       	andi	r25, 0x0F	; 15
    318a:	04 c0       	rjmp	.+8      	; 0x3194 <get_fat+0x17c>
    318c:	61 e0       	ldi	r22, 0x01	; 1
    318e:	70 e0       	ldi	r23, 0x00	; 0
    3190:	80 e0       	ldi	r24, 0x00	; 0
    3192:	90 e0       	ldi	r25, 0x00	; 0
    3194:	df 91       	pop	r29
    3196:	cf 91       	pop	r28
    3198:	1f 91       	pop	r17
    319a:	0f 91       	pop	r16
    319c:	ff 90       	pop	r15
    319e:	ef 90       	pop	r14
    31a0:	df 90       	pop	r13
    31a2:	cf 90       	pop	r12
    31a4:	bf 90       	pop	r11
    31a6:	af 90       	pop	r10
    31a8:	08 95       	ret

000031aa <dir_sdi>:
    31aa:	af 92       	push	r10
    31ac:	bf 92       	push	r11
    31ae:	cf 92       	push	r12
    31b0:	df 92       	push	r13
    31b2:	ef 92       	push	r14
    31b4:	ff 92       	push	r15
    31b6:	0f 93       	push	r16
    31b8:	1f 93       	push	r17
    31ba:	cf 93       	push	r28
    31bc:	df 93       	push	r29
    31be:	8c 01       	movw	r16, r24
    31c0:	eb 01       	movw	r28, r22
    31c2:	dc 01       	movw	r26, r24
    31c4:	15 96       	adiw	r26, 0x05	; 5
    31c6:	7c 93       	st	X, r23
    31c8:	6e 93       	st	-X, r22
    31ca:	14 97       	sbiw	r26, 0x04	; 4
    31cc:	16 96       	adiw	r26, 0x06	; 6
    31ce:	cd 90       	ld	r12, X+
    31d0:	dd 90       	ld	r13, X+
    31d2:	ed 90       	ld	r14, X+
    31d4:	fc 90       	ld	r15, X
    31d6:	19 97       	sbiw	r26, 0x09	; 9
    31d8:	b1 e0       	ldi	r27, 0x01	; 1
    31da:	cb 16       	cp	r12, r27
    31dc:	d1 04       	cpc	r13, r1
    31de:	e1 04       	cpc	r14, r1
    31e0:	f1 04       	cpc	r15, r1
    31e2:	11 f4       	brne	.+4      	; 0x31e8 <dir_sdi+0x3e>
    31e4:	82 e0       	ldi	r24, 0x02	; 2
    31e6:	85 c0       	rjmp	.+266    	; 0x32f2 <dir_sdi+0x148>
    31e8:	dc 01       	movw	r26, r24
    31ea:	ed 91       	ld	r30, X+
    31ec:	fc 91       	ld	r31, X
    31ee:	82 89       	ldd	r24, Z+18	; 0x12
    31f0:	93 89       	ldd	r25, Z+19	; 0x13
    31f2:	a4 89       	ldd	r26, Z+20	; 0x14
    31f4:	b5 89       	ldd	r27, Z+21	; 0x15
    31f6:	c8 16       	cp	r12, r24
    31f8:	d9 06       	cpc	r13, r25
    31fa:	ea 06       	cpc	r14, r26
    31fc:	fb 06       	cpc	r15, r27
    31fe:	90 f7       	brcc	.-28     	; 0x31e4 <dir_sdi+0x3a>
    3200:	c1 14       	cp	r12, r1
    3202:	d1 04       	cpc	r13, r1
    3204:	e1 04       	cpc	r14, r1
    3206:	f1 04       	cpc	r15, r1
    3208:	b9 f4       	brne	.+46     	; 0x3238 <dir_sdi+0x8e>
    320a:	80 81       	ld	r24, Z
    320c:	83 30       	cpi	r24, 0x03	; 3
    320e:	41 f4       	brne	.+16     	; 0x3220 <dir_sdi+0x76>
    3210:	82 a1       	ldd	r24, Z+34	; 0x22
    3212:	93 a1       	ldd	r25, Z+35	; 0x23
    3214:	a4 a1       	ldd	r26, Z+36	; 0x24
    3216:	b5 a1       	ldd	r27, Z+37	; 0x25
    3218:	00 97       	sbiw	r24, 0x00	; 0
    321a:	a1 05       	cpc	r26, r1
    321c:	b1 05       	cpc	r27, r1
    321e:	51 f4       	brne	.+20     	; 0x3234 <dir_sdi+0x8a>
    3220:	80 85       	ldd	r24, Z+8	; 0x08
    3222:	91 85       	ldd	r25, Z+9	; 0x09
    3224:	c8 17       	cp	r28, r24
    3226:	d9 07       	cpc	r29, r25
    3228:	e8 f6       	brcc	.-70     	; 0x31e4 <dir_sdi+0x3a>
    322a:	62 a1       	ldd	r22, Z+34	; 0x22
    322c:	73 a1       	ldd	r23, Z+35	; 0x23
    322e:	84 a1       	ldd	r24, Z+36	; 0x24
    3230:	95 a1       	ldd	r25, Z+37	; 0x25
    3232:	30 c0       	rjmp	.+96     	; 0x3294 <dir_sdi+0xea>
    3234:	6c 01       	movw	r12, r24
    3236:	7d 01       	movw	r14, r26
    3238:	a2 80       	ldd	r10, Z+2	; 0x02
    323a:	b0 e1       	ldi	r27, 0x10	; 16
    323c:	ab 9e       	mul	r10, r27
    323e:	50 01       	movw	r10, r0
    3240:	11 24       	eor	r1, r1
    3242:	f8 01       	movw	r30, r16
    3244:	80 81       	ld	r24, Z
    3246:	91 81       	ldd	r25, Z+1	; 0x01
    3248:	b7 01       	movw	r22, r14
    324a:	a6 01       	movw	r20, r12
    324c:	ca 15       	cp	r28, r10
    324e:	db 05       	cpc	r29, r11
    3250:	00 f1       	brcs	.+64     	; 0x3292 <dir_sdi+0xe8>
    3252:	e2 de       	rcall	.-572    	; 0x3018 <get_fat>
    3254:	6b 01       	movw	r12, r22
    3256:	7c 01       	movw	r14, r24
    3258:	6f 3f       	cpi	r22, 0xFF	; 255
    325a:	ef ef       	ldi	r30, 0xFF	; 255
    325c:	7e 07       	cpc	r23, r30
    325e:	8e 07       	cpc	r24, r30
    3260:	9e 07       	cpc	r25, r30
    3262:	09 f4       	brne	.+2      	; 0x3266 <dir_sdi+0xbc>
    3264:	45 c0       	rjmp	.+138    	; 0x32f0 <dir_sdi+0x146>
    3266:	62 30       	cpi	r22, 0x02	; 2
    3268:	71 05       	cpc	r23, r1
    326a:	81 05       	cpc	r24, r1
    326c:	91 05       	cpc	r25, r1
    326e:	08 f4       	brcc	.+2      	; 0x3272 <dir_sdi+0xc8>
    3270:	b9 cf       	rjmp	.-142    	; 0x31e4 <dir_sdi+0x3a>
    3272:	d8 01       	movw	r26, r16
    3274:	ed 91       	ld	r30, X+
    3276:	fc 91       	ld	r31, X
    3278:	82 89       	ldd	r24, Z+18	; 0x12
    327a:	93 89       	ldd	r25, Z+19	; 0x13
    327c:	a4 89       	ldd	r26, Z+20	; 0x14
    327e:	b5 89       	ldd	r27, Z+21	; 0x15
    3280:	c8 16       	cp	r12, r24
    3282:	d9 06       	cpc	r13, r25
    3284:	ea 06       	cpc	r14, r26
    3286:	fb 06       	cpc	r15, r27
    3288:	08 f0       	brcs	.+2      	; 0x328c <dir_sdi+0xe2>
    328a:	ac cf       	rjmp	.-168    	; 0x31e4 <dir_sdi+0x3a>
    328c:	ca 19       	sub	r28, r10
    328e:	db 09       	sbc	r29, r11
    3290:	d8 cf       	rjmp	.-80     	; 0x3242 <dir_sdi+0x98>
    3292:	9a de       	rcall	.-716    	; 0x2fc8 <clust2sect>
    3294:	d8 01       	movw	r26, r16
    3296:	1a 96       	adiw	r26, 0x0a	; 10
    3298:	cd 92       	st	X+, r12
    329a:	dd 92       	st	X+, r13
    329c:	ed 92       	st	X+, r14
    329e:	fc 92       	st	X, r15
    32a0:	1d 97       	sbiw	r26, 0x0d	; 13
    32a2:	61 15       	cp	r22, r1
    32a4:	71 05       	cpc	r23, r1
    32a6:	81 05       	cpc	r24, r1
    32a8:	91 05       	cpc	r25, r1
    32aa:	09 f4       	brne	.+2      	; 0x32ae <dir_sdi+0x104>
    32ac:	9b cf       	rjmp	.-202    	; 0x31e4 <dir_sdi+0x3a>
    32ae:	9e 01       	movw	r18, r28
    32b0:	44 e0       	ldi	r20, 0x04	; 4
    32b2:	36 95       	lsr	r19
    32b4:	27 95       	ror	r18
    32b6:	4a 95       	dec	r20
    32b8:	e1 f7       	brne	.-8      	; 0x32b2 <dir_sdi+0x108>
    32ba:	dc 01       	movw	r26, r24
    32bc:	cb 01       	movw	r24, r22
    32be:	82 0f       	add	r24, r18
    32c0:	93 1f       	adc	r25, r19
    32c2:	a1 1d       	adc	r26, r1
    32c4:	b1 1d       	adc	r27, r1
    32c6:	f8 01       	movw	r30, r16
    32c8:	86 87       	std	Z+14, r24	; 0x0e
    32ca:	97 87       	std	Z+15, r25	; 0x0f
    32cc:	a0 8b       	std	Z+16, r26	; 0x10
    32ce:	b1 8b       	std	Z+17, r27	; 0x11
    32d0:	80 81       	ld	r24, Z
    32d2:	91 81       	ldd	r25, Z+1	; 0x01
    32d4:	8e 96       	adiw	r24, 0x2e	; 46
    32d6:	cf 70       	andi	r28, 0x0F	; 15
    32d8:	dd 27       	eor	r29, r29
    32da:	55 e0       	ldi	r21, 0x05	; 5
    32dc:	cc 0f       	add	r28, r28
    32de:	dd 1f       	adc	r29, r29
    32e0:	5a 95       	dec	r21
    32e2:	e1 f7       	brne	.-8      	; 0x32dc <dir_sdi+0x132>
    32e4:	c8 0f       	add	r28, r24
    32e6:	d9 1f       	adc	r29, r25
    32e8:	d3 8b       	std	Z+19, r29	; 0x13
    32ea:	c2 8b       	std	Z+18, r28	; 0x12
    32ec:	80 e0       	ldi	r24, 0x00	; 0
    32ee:	01 c0       	rjmp	.+2      	; 0x32f2 <dir_sdi+0x148>
    32f0:	81 e0       	ldi	r24, 0x01	; 1
    32f2:	df 91       	pop	r29
    32f4:	cf 91       	pop	r28
    32f6:	1f 91       	pop	r17
    32f8:	0f 91       	pop	r16
    32fa:	ff 90       	pop	r15
    32fc:	ef 90       	pop	r14
    32fe:	df 90       	pop	r13
    3300:	cf 90       	pop	r12
    3302:	bf 90       	pop	r11
    3304:	af 90       	pop	r10
    3306:	08 95       	ret

00003308 <put_fat>:
    3308:	4f 92       	push	r4
    330a:	5f 92       	push	r5
    330c:	6f 92       	push	r6
    330e:	7f 92       	push	r7
    3310:	8f 92       	push	r8
    3312:	9f 92       	push	r9
    3314:	af 92       	push	r10
    3316:	bf 92       	push	r11
    3318:	cf 92       	push	r12
    331a:	df 92       	push	r13
    331c:	ef 92       	push	r14
    331e:	ff 92       	push	r15
    3320:	0f 93       	push	r16
    3322:	1f 93       	push	r17
    3324:	cf 93       	push	r28
    3326:	df 93       	push	r29
    3328:	42 30       	cpi	r20, 0x02	; 2
    332a:	51 05       	cpc	r21, r1
    332c:	61 05       	cpc	r22, r1
    332e:	71 05       	cpc	r23, r1
    3330:	08 f4       	brcc	.+2      	; 0x3334 <put_fat+0x2c>
    3332:	d1 c0       	rjmp	.+418    	; 0x34d6 <put_fat+0x1ce>
    3334:	fc 01       	movw	r30, r24
    3336:	c2 88       	ldd	r12, Z+18	; 0x12
    3338:	d3 88       	ldd	r13, Z+19	; 0x13
    333a:	e4 88       	ldd	r14, Z+20	; 0x14
    333c:	f5 88       	ldd	r15, Z+21	; 0x15
    333e:	4c 15       	cp	r20, r12
    3340:	5d 05       	cpc	r21, r13
    3342:	6e 05       	cpc	r22, r14
    3344:	7f 05       	cpc	r23, r15
    3346:	08 f0       	brcs	.+2      	; 0x334a <put_fat+0x42>
    3348:	c6 c0       	rjmp	.+396    	; 0x34d6 <put_fat+0x1ce>
    334a:	28 01       	movw	r4, r16
    334c:	39 01       	movw	r6, r18
    334e:	6a 01       	movw	r12, r20
    3350:	7b 01       	movw	r14, r22
    3352:	ec 01       	movw	r28, r24
    3354:	80 81       	ld	r24, Z
    3356:	82 30       	cpi	r24, 0x02	; 2
    3358:	09 f4       	brne	.+2      	; 0x335c <put_fat+0x54>
    335a:	61 c0       	rjmp	.+194    	; 0x341e <put_fat+0x116>
    335c:	83 30       	cpi	r24, 0x03	; 3
    335e:	09 f4       	brne	.+2      	; 0x3362 <put_fat+0x5a>
    3360:	81 c0       	rjmp	.+258    	; 0x3464 <put_fat+0x15c>
    3362:	81 30       	cpi	r24, 0x01	; 1
    3364:	09 f0       	breq	.+2      	; 0x3368 <put_fat+0x60>
    3366:	b7 c0       	rjmp	.+366    	; 0x34d6 <put_fat+0x1ce>
    3368:	5a 01       	movw	r10, r20
    336a:	b6 94       	lsr	r11
    336c:	a7 94       	ror	r10
    336e:	a4 0e       	add	r10, r20
    3370:	b5 1e       	adc	r11, r21
    3372:	c5 01       	movw	r24, r10
    3374:	89 2f       	mov	r24, r25
    3376:	99 27       	eor	r25, r25
    3378:	86 95       	lsr	r24
    337a:	4e 8d       	ldd	r20, Y+30	; 0x1e
    337c:	5f 8d       	ldd	r21, Y+31	; 0x1f
    337e:	68 a1       	ldd	r22, Y+32	; 0x20
    3380:	79 a1       	ldd	r23, Y+33	; 0x21
    3382:	48 0f       	add	r20, r24
    3384:	59 1f       	adc	r21, r25
    3386:	61 1d       	adc	r22, r1
    3388:	71 1d       	adc	r23, r1
    338a:	ce 01       	movw	r24, r28
    338c:	b1 da       	rcall	.-2718   	; 0x28f0 <move_window>
    338e:	81 11       	cpse	r24, r1
    3390:	a3 c0       	rjmp	.+326    	; 0x34d8 <put_fat+0x1d0>
    3392:	85 01       	movw	r16, r10
    3394:	0f 5f       	subi	r16, 0xFF	; 255
    3396:	1f 4f       	sbci	r17, 0xFF	; 255
    3398:	f1 e0       	ldi	r31, 0x01	; 1
    339a:	bf 22       	and	r11, r31
    339c:	fe 01       	movw	r30, r28
    339e:	ea 0d       	add	r30, r10
    33a0:	fb 1d       	adc	r31, r11
    33a2:	46 01       	movw	r8, r12
    33a4:	57 01       	movw	r10, r14
    33a6:	31 e0       	ldi	r19, 0x01	; 1
    33a8:	83 22       	and	r8, r19
    33aa:	99 24       	eor	r9, r9
    33ac:	aa 24       	eor	r10, r10
    33ae:	bb 24       	eor	r11, r11
    33b0:	c0 fe       	sbrs	r12, 0
    33b2:	09 c0       	rjmp	.+18     	; 0x33c6 <put_fat+0xbe>
    33b4:	86 a5       	ldd	r24, Z+46	; 0x2e
    33b6:	28 2f       	mov	r18, r24
    33b8:	2f 70       	andi	r18, 0x0F	; 15
    33ba:	30 e1       	ldi	r19, 0x10	; 16
    33bc:	43 9e       	mul	r4, r19
    33be:	c0 01       	movw	r24, r0
    33c0:	11 24       	eor	r1, r1
    33c2:	82 2b       	or	r24, r18
    33c4:	01 c0       	rjmp	.+2      	; 0x33c8 <put_fat+0xc0>
    33c6:	84 2d       	mov	r24, r4
    33c8:	86 a7       	std	Z+46, r24	; 0x2e
    33ca:	81 e0       	ldi	r24, 0x01	; 1
    33cc:	8c 83       	std	Y+4, r24	; 0x04
    33ce:	4e 8d       	ldd	r20, Y+30	; 0x1e
    33d0:	5f 8d       	ldd	r21, Y+31	; 0x1f
    33d2:	68 a1       	ldd	r22, Y+32	; 0x20
    33d4:	79 a1       	ldd	r23, Y+33	; 0x21
    33d6:	c8 01       	movw	r24, r16
    33d8:	89 2f       	mov	r24, r25
    33da:	99 27       	eor	r25, r25
    33dc:	86 95       	lsr	r24
    33de:	48 0f       	add	r20, r24
    33e0:	59 1f       	adc	r21, r25
    33e2:	61 1d       	adc	r22, r1
    33e4:	71 1d       	adc	r23, r1
    33e6:	ce 01       	movw	r24, r28
    33e8:	83 da       	rcall	.-2810   	; 0x28f0 <move_window>
    33ea:	81 11       	cpse	r24, r1
    33ec:	75 c0       	rjmp	.+234    	; 0x34d8 <put_fat+0x1d0>
    33ee:	11 70       	andi	r17, 0x01	; 1
    33f0:	fe 01       	movw	r30, r28
    33f2:	e0 0f       	add	r30, r16
    33f4:	f1 1f       	adc	r31, r17
    33f6:	89 28       	or	r8, r9
    33f8:	8a 28       	or	r8, r10
    33fa:	8b 28       	or	r8, r11
    33fc:	41 f0       	breq	.+16     	; 0x340e <put_fat+0x106>
    33fe:	54 e0       	ldi	r21, 0x04	; 4
    3400:	76 94       	lsr	r7
    3402:	67 94       	ror	r6
    3404:	57 94       	ror	r5
    3406:	47 94       	ror	r4
    3408:	5a 95       	dec	r21
    340a:	d1 f7       	brne	.-12     	; 0x3400 <put_fat+0xf8>
    340c:	06 c0       	rjmp	.+12     	; 0x341a <put_fat+0x112>
    340e:	06 a5       	ldd	r16, Z+46	; 0x2e
    3410:	00 7f       	andi	r16, 0xF0	; 240
    3412:	95 2d       	mov	r25, r5
    3414:	9f 70       	andi	r25, 0x0F	; 15
    3416:	40 2e       	mov	r4, r16
    3418:	49 2a       	or	r4, r25
    341a:	46 a6       	std	Z+46, r4	; 0x2e
    341c:	59 c0       	rjmp	.+178    	; 0x34d0 <put_fat+0x1c8>
    341e:	77 27       	eor	r23, r23
    3420:	6f 2d       	mov	r22, r15
    3422:	5e 2d       	mov	r21, r14
    3424:	4d 2d       	mov	r20, r13
    3426:	86 8d       	ldd	r24, Z+30	; 0x1e
    3428:	97 8d       	ldd	r25, Z+31	; 0x1f
    342a:	a0 a1       	ldd	r26, Z+32	; 0x20
    342c:	b1 a1       	ldd	r27, Z+33	; 0x21
    342e:	48 0f       	add	r20, r24
    3430:	59 1f       	adc	r21, r25
    3432:	6a 1f       	adc	r22, r26
    3434:	7b 1f       	adc	r23, r27
    3436:	cf 01       	movw	r24, r30
    3438:	5b da       	rcall	.-2890   	; 0x28f0 <move_window>
    343a:	81 11       	cpse	r24, r1
    343c:	4d c0       	rjmp	.+154    	; 0x34d8 <put_fat+0x1d0>
    343e:	cc 0c       	add	r12, r12
    3440:	dd 1c       	adc	r13, r13
    3442:	ee 1c       	adc	r14, r14
    3444:	ff 1c       	adc	r15, r15
    3446:	e8 94       	clt
    3448:	c0 f8       	bld	r12, 0
    344a:	91 e0       	ldi	r25, 0x01	; 1
    344c:	d9 22       	and	r13, r25
    344e:	ee 24       	eor	r14, r14
    3450:	ff 24       	eor	r15, r15
    3452:	ee e2       	ldi	r30, 0x2E	; 46
    3454:	ce 0e       	add	r12, r30
    3456:	d1 1c       	adc	r13, r1
    3458:	fe 01       	movw	r30, r28
    345a:	ec 0d       	add	r30, r12
    345c:	fd 1d       	adc	r31, r13
    345e:	51 82       	std	Z+1, r5	; 0x01
    3460:	40 82       	st	Z, r4
    3462:	36 c0       	rjmp	.+108    	; 0x34d0 <put_fat+0x1c8>
    3464:	86 8d       	ldd	r24, Z+30	; 0x1e
    3466:	97 8d       	ldd	r25, Z+31	; 0x1f
    3468:	a0 a1       	ldd	r26, Z+32	; 0x20
    346a:	b1 a1       	ldd	r27, Z+33	; 0x21
    346c:	27 e0       	ldi	r18, 0x07	; 7
    346e:	76 95       	lsr	r23
    3470:	67 95       	ror	r22
    3472:	57 95       	ror	r21
    3474:	47 95       	ror	r20
    3476:	2a 95       	dec	r18
    3478:	d1 f7       	brne	.-12     	; 0x346e <put_fat+0x166>
    347a:	48 0f       	add	r20, r24
    347c:	59 1f       	adc	r21, r25
    347e:	6a 1f       	adc	r22, r26
    3480:	7b 1f       	adc	r23, r27
    3482:	cf 01       	movw	r24, r30
    3484:	35 da       	rcall	.-2966   	; 0x28f0 <move_window>
    3486:	81 11       	cpse	r24, r1
    3488:	27 c0       	rjmp	.+78     	; 0x34d8 <put_fat+0x1d0>
    348a:	92 e0       	ldi	r25, 0x02	; 2
    348c:	cc 0c       	add	r12, r12
    348e:	dd 1c       	adc	r13, r13
    3490:	ee 1c       	adc	r14, r14
    3492:	ff 1c       	adc	r15, r15
    3494:	9a 95       	dec	r25
    3496:	d1 f7       	brne	.-12     	; 0x348c <put_fat+0x184>
    3498:	fc ef       	ldi	r31, 0xFC	; 252
    349a:	cf 22       	and	r12, r31
    349c:	f1 e0       	ldi	r31, 0x01	; 1
    349e:	df 22       	and	r13, r31
    34a0:	ee 24       	eor	r14, r14
    34a2:	ff 24       	eor	r15, r15
    34a4:	3e e2       	ldi	r19, 0x2E	; 46
    34a6:	c3 0e       	add	r12, r19
    34a8:	d1 1c       	adc	r13, r1
    34aa:	fe 01       	movw	r30, r28
    34ac:	ec 0d       	add	r30, r12
    34ae:	fd 1d       	adc	r31, r13
    34b0:	00 81       	ld	r16, Z
    34b2:	11 81       	ldd	r17, Z+1	; 0x01
    34b4:	22 81       	ldd	r18, Z+2	; 0x02
    34b6:	33 81       	ldd	r19, Z+3	; 0x03
    34b8:	00 27       	eor	r16, r16
    34ba:	11 27       	eor	r17, r17
    34bc:	22 27       	eor	r18, r18
    34be:	30 7f       	andi	r19, 0xF0	; 240
    34c0:	40 2a       	or	r4, r16
    34c2:	51 2a       	or	r5, r17
    34c4:	62 2a       	or	r6, r18
    34c6:	73 2a       	or	r7, r19
    34c8:	40 82       	st	Z, r4
    34ca:	51 82       	std	Z+1, r5	; 0x01
    34cc:	62 82       	std	Z+2, r6	; 0x02
    34ce:	73 82       	std	Z+3, r7	; 0x03
    34d0:	91 e0       	ldi	r25, 0x01	; 1
    34d2:	9c 83       	std	Y+4, r25	; 0x04
    34d4:	01 c0       	rjmp	.+2      	; 0x34d8 <put_fat+0x1d0>
    34d6:	82 e0       	ldi	r24, 0x02	; 2
    34d8:	df 91       	pop	r29
    34da:	cf 91       	pop	r28
    34dc:	1f 91       	pop	r17
    34de:	0f 91       	pop	r16
    34e0:	ff 90       	pop	r15
    34e2:	ef 90       	pop	r14
    34e4:	df 90       	pop	r13
    34e6:	cf 90       	pop	r12
    34e8:	bf 90       	pop	r11
    34ea:	af 90       	pop	r10
    34ec:	9f 90       	pop	r9
    34ee:	8f 90       	pop	r8
    34f0:	7f 90       	pop	r7
    34f2:	6f 90       	pop	r6
    34f4:	5f 90       	pop	r5
    34f6:	4f 90       	pop	r4
    34f8:	08 95       	ret

000034fa <create_chain>:
    34fa:	4f 92       	push	r4
    34fc:	5f 92       	push	r5
    34fe:	6f 92       	push	r6
    3500:	7f 92       	push	r7
    3502:	8f 92       	push	r8
    3504:	9f 92       	push	r9
    3506:	af 92       	push	r10
    3508:	bf 92       	push	r11
    350a:	cf 92       	push	r12
    350c:	df 92       	push	r13
    350e:	ef 92       	push	r14
    3510:	ff 92       	push	r15
    3512:	0f 93       	push	r16
    3514:	1f 93       	push	r17
    3516:	cf 93       	push	r28
    3518:	df 93       	push	r29
    351a:	ec 01       	movw	r28, r24
    351c:	2a 01       	movw	r4, r20
    351e:	3b 01       	movw	r6, r22
    3520:	41 15       	cp	r20, r1
    3522:	51 05       	cpc	r21, r1
    3524:	61 05       	cpc	r22, r1
    3526:	71 05       	cpc	r23, r1
    3528:	99 f4       	brne	.+38     	; 0x3550 <create_chain+0x56>
    352a:	8a 84       	ldd	r8, Y+10	; 0x0a
    352c:	9b 84       	ldd	r9, Y+11	; 0x0b
    352e:	ac 84       	ldd	r10, Y+12	; 0x0c
    3530:	bd 84       	ldd	r11, Y+13	; 0x0d
    3532:	81 14       	cp	r8, r1
    3534:	91 04       	cpc	r9, r1
    3536:	a1 04       	cpc	r10, r1
    3538:	b1 04       	cpc	r11, r1
    353a:	49 f1       	breq	.+82     	; 0x358e <create_chain+0x94>
    353c:	8a 89       	ldd	r24, Y+18	; 0x12
    353e:	9b 89       	ldd	r25, Y+19	; 0x13
    3540:	ac 89       	ldd	r26, Y+20	; 0x14
    3542:	bd 89       	ldd	r27, Y+21	; 0x15
    3544:	88 16       	cp	r8, r24
    3546:	99 06       	cpc	r9, r25
    3548:	aa 06       	cpc	r10, r26
    354a:	bb 06       	cpc	r11, r27
    354c:	20 f1       	brcs	.+72     	; 0x3596 <create_chain+0x9c>
    354e:	1f c0       	rjmp	.+62     	; 0x358e <create_chain+0x94>
    3550:	63 dd       	rcall	.-1338   	; 0x3018 <get_fat>
    3552:	62 30       	cpi	r22, 0x02	; 2
    3554:	71 05       	cpc	r23, r1
    3556:	81 05       	cpc	r24, r1
    3558:	91 05       	cpc	r25, r1
    355a:	08 f4       	brcc	.+2      	; 0x355e <create_chain+0x64>
    355c:	8e c0       	rjmp	.+284    	; 0x367a <create_chain+0x180>
    355e:	6f 3f       	cpi	r22, 0xFF	; 255
    3560:	2f ef       	ldi	r18, 0xFF	; 255
    3562:	72 07       	cpc	r23, r18
    3564:	82 07       	cpc	r24, r18
    3566:	92 07       	cpc	r25, r18
    3568:	29 f4       	brne	.+10     	; 0x3574 <create_chain+0x7a>
    356a:	4f ef       	ldi	r20, 0xFF	; 255
    356c:	3f ef       	ldi	r19, 0xFF	; 255
    356e:	2f ef       	ldi	r18, 0xFF	; 255
    3570:	9f ef       	ldi	r25, 0xFF	; 255
    3572:	8b c0       	rjmp	.+278    	; 0x368a <create_chain+0x190>
    3574:	ca 88       	ldd	r12, Y+18	; 0x12
    3576:	db 88       	ldd	r13, Y+19	; 0x13
    3578:	ec 88       	ldd	r14, Y+20	; 0x14
    357a:	fd 88       	ldd	r15, Y+21	; 0x15
    357c:	6c 15       	cp	r22, r12
    357e:	7d 05       	cpc	r23, r13
    3580:	8e 05       	cpc	r24, r14
    3582:	9f 05       	cpc	r25, r15
    3584:	08 f4       	brcc	.+2      	; 0x3588 <create_chain+0x8e>
    3586:	7e c0       	rjmp	.+252    	; 0x3684 <create_chain+0x18a>
    3588:	53 01       	movw	r10, r6
    358a:	42 01       	movw	r8, r4
    358c:	04 c0       	rjmp	.+8      	; 0x3596 <create_chain+0x9c>
    358e:	81 2c       	mov	r8, r1
    3590:	91 2c       	mov	r9, r1
    3592:	54 01       	movw	r10, r8
    3594:	83 94       	inc	r8
    3596:	75 01       	movw	r14, r10
    3598:	64 01       	movw	r12, r8
    359a:	8f ef       	ldi	r24, 0xFF	; 255
    359c:	c8 1a       	sub	r12, r24
    359e:	d8 0a       	sbc	r13, r24
    35a0:	e8 0a       	sbc	r14, r24
    35a2:	f8 0a       	sbc	r15, r24
    35a4:	8a 89       	ldd	r24, Y+18	; 0x12
    35a6:	9b 89       	ldd	r25, Y+19	; 0x13
    35a8:	ac 89       	ldd	r26, Y+20	; 0x14
    35aa:	bd 89       	ldd	r27, Y+21	; 0x15
    35ac:	c8 16       	cp	r12, r24
    35ae:	d9 06       	cpc	r13, r25
    35b0:	ea 06       	cpc	r14, r26
    35b2:	fb 06       	cpc	r15, r27
    35b4:	68 f0       	brcs	.+26     	; 0x35d0 <create_chain+0xd6>
    35b6:	22 e0       	ldi	r18, 0x02	; 2
    35b8:	82 16       	cp	r8, r18
    35ba:	91 04       	cpc	r9, r1
    35bc:	a1 04       	cpc	r10, r1
    35be:	b1 04       	cpc	r11, r1
    35c0:	10 f4       	brcc	.+4      	; 0x35c6 <create_chain+0xcc>
    35c2:	40 e0       	ldi	r20, 0x00	; 0
    35c4:	5b c0       	rjmp	.+182    	; 0x367c <create_chain+0x182>
    35c6:	82 e0       	ldi	r24, 0x02	; 2
    35c8:	c8 2e       	mov	r12, r24
    35ca:	d1 2c       	mov	r13, r1
    35cc:	e1 2c       	mov	r14, r1
    35ce:	f1 2c       	mov	r15, r1
    35d0:	b7 01       	movw	r22, r14
    35d2:	a6 01       	movw	r20, r12
    35d4:	ce 01       	movw	r24, r28
    35d6:	20 dd       	rcall	.-1472   	; 0x3018 <get_fat>
    35d8:	61 15       	cp	r22, r1
    35da:	71 05       	cpc	r23, r1
    35dc:	81 05       	cpc	r24, r1
    35de:	91 05       	cpc	r25, r1
    35e0:	99 f0       	breq	.+38     	; 0x3608 <create_chain+0x10e>
    35e2:	6f 3f       	cpi	r22, 0xFF	; 255
    35e4:	2f ef       	ldi	r18, 0xFF	; 255
    35e6:	72 07       	cpc	r23, r18
    35e8:	82 07       	cpc	r24, r18
    35ea:	92 07       	cpc	r25, r18
    35ec:	09 f4       	brne	.+2      	; 0x35f0 <create_chain+0xf6>
    35ee:	bd cf       	rjmp	.-134    	; 0x356a <create_chain+0x70>
    35f0:	61 30       	cpi	r22, 0x01	; 1
    35f2:	71 05       	cpc	r23, r1
    35f4:	81 05       	cpc	r24, r1
    35f6:	91 05       	cpc	r25, r1
    35f8:	09 f4       	brne	.+2      	; 0x35fc <create_chain+0x102>
    35fa:	3f c0       	rjmp	.+126    	; 0x367a <create_chain+0x180>
    35fc:	c8 14       	cp	r12, r8
    35fe:	d9 04       	cpc	r13, r9
    3600:	ea 04       	cpc	r14, r10
    3602:	fb 04       	cpc	r15, r11
    3604:	51 f6       	brne	.-108    	; 0x359a <create_chain+0xa0>
    3606:	dd cf       	rjmp	.-70     	; 0x35c2 <create_chain+0xc8>
    3608:	0f ef       	ldi	r16, 0xFF	; 255
    360a:	1f ef       	ldi	r17, 0xFF	; 255
    360c:	2f ef       	ldi	r18, 0xFF	; 255
    360e:	3f e0       	ldi	r19, 0x0F	; 15
    3610:	b7 01       	movw	r22, r14
    3612:	a6 01       	movw	r20, r12
    3614:	ce 01       	movw	r24, r28
    3616:	78 de       	rcall	.-784    	; 0x3308 <put_fat>
    3618:	81 11       	cpse	r24, r1
    361a:	2c c0       	rjmp	.+88     	; 0x3674 <create_chain+0x17a>
    361c:	41 14       	cp	r4, r1
    361e:	51 04       	cpc	r5, r1
    3620:	61 04       	cpc	r6, r1
    3622:	71 04       	cpc	r7, r1
    3624:	c9 f4       	brne	.+50     	; 0x3658 <create_chain+0x15e>
    3626:	ca 86       	std	Y+10, r12	; 0x0a
    3628:	db 86       	std	Y+11, r13	; 0x0b
    362a:	ec 86       	std	Y+12, r14	; 0x0c
    362c:	fd 86       	std	Y+13, r15	; 0x0d
    362e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3630:	9f 85       	ldd	r25, Y+15	; 0x0f
    3632:	a8 89       	ldd	r26, Y+16	; 0x10
    3634:	b9 89       	ldd	r27, Y+17	; 0x11
    3636:	8f 3f       	cpi	r24, 0xFF	; 255
    3638:	2f ef       	ldi	r18, 0xFF	; 255
    363a:	92 07       	cpc	r25, r18
    363c:	a2 07       	cpc	r26, r18
    363e:	b2 07       	cpc	r27, r18
    3640:	a1 f0       	breq	.+40     	; 0x366a <create_chain+0x170>
    3642:	01 97       	sbiw	r24, 0x01	; 1
    3644:	a1 09       	sbc	r26, r1
    3646:	b1 09       	sbc	r27, r1
    3648:	8e 87       	std	Y+14, r24	; 0x0e
    364a:	9f 87       	std	Y+15, r25	; 0x0f
    364c:	a8 8b       	std	Y+16, r26	; 0x10
    364e:	b9 8b       	std	Y+17, r27	; 0x11
    3650:	8d 81       	ldd	r24, Y+5	; 0x05
    3652:	81 60       	ori	r24, 0x01	; 1
    3654:	8d 83       	std	Y+5, r24	; 0x05
    3656:	09 c0       	rjmp	.+18     	; 0x366a <create_chain+0x170>
    3658:	97 01       	movw	r18, r14
    365a:	86 01       	movw	r16, r12
    365c:	b3 01       	movw	r22, r6
    365e:	a2 01       	movw	r20, r4
    3660:	ce 01       	movw	r24, r28
    3662:	52 de       	rcall	.-860    	; 0x3308 <put_fat>
    3664:	88 23       	and	r24, r24
    3666:	f9 f2       	breq	.-66     	; 0x3626 <create_chain+0x12c>
    3668:	05 c0       	rjmp	.+10     	; 0x3674 <create_chain+0x17a>
    366a:	4c 2d       	mov	r20, r12
    366c:	3d 2d       	mov	r19, r13
    366e:	2e 2d       	mov	r18, r14
    3670:	9f 2d       	mov	r25, r15
    3672:	0b c0       	rjmp	.+22     	; 0x368a <create_chain+0x190>
    3674:	81 30       	cpi	r24, 0x01	; 1
    3676:	09 f4       	brne	.+2      	; 0x367a <create_chain+0x180>
    3678:	78 cf       	rjmp	.-272    	; 0x356a <create_chain+0x70>
    367a:	41 e0       	ldi	r20, 0x01	; 1
    367c:	30 e0       	ldi	r19, 0x00	; 0
    367e:	20 e0       	ldi	r18, 0x00	; 0
    3680:	90 e0       	ldi	r25, 0x00	; 0
    3682:	03 c0       	rjmp	.+6      	; 0x368a <create_chain+0x190>
    3684:	46 2f       	mov	r20, r22
    3686:	37 2f       	mov	r19, r23
    3688:	28 2f       	mov	r18, r24
    368a:	64 2f       	mov	r22, r20
    368c:	73 2f       	mov	r23, r19
    368e:	82 2f       	mov	r24, r18
    3690:	df 91       	pop	r29
    3692:	cf 91       	pop	r28
    3694:	1f 91       	pop	r17
    3696:	0f 91       	pop	r16
    3698:	ff 90       	pop	r15
    369a:	ef 90       	pop	r14
    369c:	df 90       	pop	r13
    369e:	cf 90       	pop	r12
    36a0:	bf 90       	pop	r11
    36a2:	af 90       	pop	r10
    36a4:	9f 90       	pop	r9
    36a6:	8f 90       	pop	r8
    36a8:	7f 90       	pop	r7
    36aa:	6f 90       	pop	r6
    36ac:	5f 90       	pop	r5
    36ae:	4f 90       	pop	r4
    36b0:	08 95       	ret

000036b2 <dir_next>:
    36b2:	7f 92       	push	r7
    36b4:	8f 92       	push	r8
    36b6:	9f 92       	push	r9
    36b8:	af 92       	push	r10
    36ba:	bf 92       	push	r11
    36bc:	cf 92       	push	r12
    36be:	df 92       	push	r13
    36c0:	ef 92       	push	r14
    36c2:	ff 92       	push	r15
    36c4:	0f 93       	push	r16
    36c6:	1f 93       	push	r17
    36c8:	cf 93       	push	r28
    36ca:	df 93       	push	r29
    36cc:	ec 01       	movw	r28, r24
    36ce:	6b 01       	movw	r12, r22
    36d0:	0c 81       	ldd	r16, Y+4	; 0x04
    36d2:	1d 81       	ldd	r17, Y+5	; 0x05
    36d4:	0f 5f       	subi	r16, 0xFF	; 255
    36d6:	1f 4f       	sbci	r17, 0xFF	; 255
    36d8:	11 f4       	brne	.+4      	; 0x36de <dir_next+0x2c>
    36da:	84 e0       	ldi	r24, 0x04	; 4
    36dc:	db c0       	rjmp	.+438    	; 0x3894 <dir_next+0x1e2>
    36de:	4e 85       	ldd	r20, Y+14	; 0x0e
    36e0:	5f 85       	ldd	r21, Y+15	; 0x0f
    36e2:	68 89       	ldd	r22, Y+16	; 0x10
    36e4:	79 89       	ldd	r23, Y+17	; 0x11
    36e6:	41 15       	cp	r20, r1
    36e8:	51 05       	cpc	r21, r1
    36ea:	61 05       	cpc	r22, r1
    36ec:	71 05       	cpc	r23, r1
    36ee:	a9 f3       	breq	.-22     	; 0x36da <dir_next+0x28>
    36f0:	78 01       	movw	r14, r16
    36f2:	8f e0       	ldi	r24, 0x0F	; 15
    36f4:	e8 22       	and	r14, r24
    36f6:	ff 24       	eor	r15, r15
    36f8:	e1 14       	cp	r14, r1
    36fa:	f1 04       	cpc	r15, r1
    36fc:	09 f0       	breq	.+2      	; 0x3700 <dir_next+0x4e>
    36fe:	b9 c0       	rjmp	.+370    	; 0x3872 <dir_next+0x1c0>
    3700:	4f 5f       	subi	r20, 0xFF	; 255
    3702:	5f 4f       	sbci	r21, 0xFF	; 255
    3704:	6f 4f       	sbci	r22, 0xFF	; 255
    3706:	7f 4f       	sbci	r23, 0xFF	; 255
    3708:	4e 87       	std	Y+14, r20	; 0x0e
    370a:	5f 87       	std	Y+15, r21	; 0x0f
    370c:	68 8b       	std	Y+16, r22	; 0x10
    370e:	79 8b       	std	Y+17, r23	; 0x11
    3710:	4a 85       	ldd	r20, Y+10	; 0x0a
    3712:	5b 85       	ldd	r21, Y+11	; 0x0b
    3714:	6c 85       	ldd	r22, Y+12	; 0x0c
    3716:	7d 85       	ldd	r23, Y+13	; 0x0d
    3718:	88 81       	ld	r24, Y
    371a:	99 81       	ldd	r25, Y+1	; 0x01
    371c:	fc 01       	movw	r30, r24
    371e:	41 15       	cp	r20, r1
    3720:	51 05       	cpc	r21, r1
    3722:	61 05       	cpc	r22, r1
    3724:	71 05       	cpc	r23, r1
    3726:	31 f4       	brne	.+12     	; 0x3734 <dir_next+0x82>
    3728:	80 85       	ldd	r24, Z+8	; 0x08
    372a:	91 85       	ldd	r25, Z+9	; 0x09
    372c:	08 17       	cp	r16, r24
    372e:	19 07       	cpc	r17, r25
    3730:	a0 f6       	brcc	.-88     	; 0x36da <dir_next+0x28>
    3732:	9f c0       	rjmp	.+318    	; 0x3872 <dir_next+0x1c0>
    3734:	22 81       	ldd	r18, Z+2	; 0x02
    3736:	30 e0       	ldi	r19, 0x00	; 0
    3738:	21 50       	subi	r18, 0x01	; 1
    373a:	31 09       	sbc	r19, r1
    373c:	f8 01       	movw	r30, r16
    373e:	a4 e0       	ldi	r26, 0x04	; 4
    3740:	f6 95       	lsr	r31
    3742:	e7 95       	ror	r30
    3744:	aa 95       	dec	r26
    3746:	e1 f7       	brne	.-8      	; 0x3740 <dir_next+0x8e>
    3748:	2e 23       	and	r18, r30
    374a:	3f 23       	and	r19, r31
    374c:	23 2b       	or	r18, r19
    374e:	09 f0       	breq	.+2      	; 0x3752 <dir_next+0xa0>
    3750:	90 c0       	rjmp	.+288    	; 0x3872 <dir_next+0x1c0>
    3752:	62 dc       	rcall	.-1852   	; 0x3018 <get_fat>
    3754:	4b 01       	movw	r8, r22
    3756:	5c 01       	movw	r10, r24
    3758:	62 30       	cpi	r22, 0x02	; 2
    375a:	71 05       	cpc	r23, r1
    375c:	81 05       	cpc	r24, r1
    375e:	91 05       	cpc	r25, r1
    3760:	10 f4       	brcc	.+4      	; 0x3766 <dir_next+0xb4>
    3762:	82 e0       	ldi	r24, 0x02	; 2
    3764:	97 c0       	rjmp	.+302    	; 0x3894 <dir_next+0x1e2>
    3766:	8f ef       	ldi	r24, 0xFF	; 255
    3768:	88 16       	cp	r8, r24
    376a:	98 06       	cpc	r9, r24
    376c:	a8 06       	cpc	r10, r24
    376e:	b8 06       	cpc	r11, r24
    3770:	11 f4       	brne	.+4      	; 0x3776 <dir_next+0xc4>
    3772:	81 e0       	ldi	r24, 0x01	; 1
    3774:	8f c0       	rjmp	.+286    	; 0x3894 <dir_next+0x1e2>
    3776:	88 81       	ld	r24, Y
    3778:	99 81       	ldd	r25, Y+1	; 0x01
    377a:	fc 01       	movw	r30, r24
    377c:	42 89       	ldd	r20, Z+18	; 0x12
    377e:	53 89       	ldd	r21, Z+19	; 0x13
    3780:	64 89       	ldd	r22, Z+20	; 0x14
    3782:	75 89       	ldd	r23, Z+21	; 0x15
    3784:	84 16       	cp	r8, r20
    3786:	95 06       	cpc	r9, r21
    3788:	a6 06       	cpc	r10, r22
    378a:	b7 06       	cpc	r11, r23
    378c:	08 f4       	brcc	.+2      	; 0x3790 <dir_next+0xde>
    378e:	64 c0       	rjmp	.+200    	; 0x3858 <dir_next+0x1a6>
    3790:	cd 28       	or	r12, r13
    3792:	09 f4       	brne	.+2      	; 0x3796 <dir_next+0xe4>
    3794:	a2 cf       	rjmp	.-188    	; 0x36da <dir_next+0x28>
    3796:	4a 85       	ldd	r20, Y+10	; 0x0a
    3798:	5b 85       	ldd	r21, Y+11	; 0x0b
    379a:	6c 85       	ldd	r22, Y+12	; 0x0c
    379c:	7d 85       	ldd	r23, Y+13	; 0x0d
    379e:	ad de       	rcall	.-678    	; 0x34fa <create_chain>
    37a0:	4b 01       	movw	r8, r22
    37a2:	5c 01       	movw	r10, r24
    37a4:	61 15       	cp	r22, r1
    37a6:	71 05       	cpc	r23, r1
    37a8:	81 05       	cpc	r24, r1
    37aa:	91 05       	cpc	r25, r1
    37ac:	09 f4       	brne	.+2      	; 0x37b0 <dir_next+0xfe>
    37ae:	71 c0       	rjmp	.+226    	; 0x3892 <dir_next+0x1e0>
    37b0:	61 30       	cpi	r22, 0x01	; 1
    37b2:	71 05       	cpc	r23, r1
    37b4:	81 05       	cpc	r24, r1
    37b6:	91 05       	cpc	r25, r1
    37b8:	a1 f2       	breq	.-88     	; 0x3762 <dir_next+0xb0>
    37ba:	8f ef       	ldi	r24, 0xFF	; 255
    37bc:	88 16       	cp	r8, r24
    37be:	98 06       	cpc	r9, r24
    37c0:	a8 06       	cpc	r10, r24
    37c2:	b8 06       	cpc	r11, r24
    37c4:	b1 f2       	breq	.-84     	; 0x3772 <dir_next+0xc0>
    37c6:	88 81       	ld	r24, Y
    37c8:	99 81       	ldd	r25, Y+1	; 0x01
    37ca:	8c d8       	rcall	.-3816   	; 0x28e4 <sync_window>
    37cc:	81 11       	cpse	r24, r1
    37ce:	d1 cf       	rjmp	.-94     	; 0x3772 <dir_next+0xc0>
    37d0:	88 81       	ld	r24, Y
    37d2:	99 81       	ldd	r25, Y+1	; 0x01
    37d4:	fc 01       	movw	r30, r24
    37d6:	be 96       	adiw	r30, 0x2e	; 46
    37d8:	82 5d       	subi	r24, 0xD2	; 210
    37da:	9d 4f       	sbci	r25, 0xFD	; 253
    37dc:	e8 17       	cp	r30, r24
    37de:	f9 07       	cpc	r31, r25
    37e0:	11 f0       	breq	.+4      	; 0x37e6 <dir_next+0x134>
    37e2:	11 92       	st	Z+, r1
    37e4:	fb cf       	rjmp	.-10     	; 0x37dc <dir_next+0x12a>
    37e6:	c8 80       	ld	r12, Y
    37e8:	d9 80       	ldd	r13, Y+1	; 0x01
    37ea:	b5 01       	movw	r22, r10
    37ec:	a4 01       	movw	r20, r8
    37ee:	c6 01       	movw	r24, r12
    37f0:	eb db       	rcall	.-2090   	; 0x2fc8 <clust2sect>
    37f2:	f6 01       	movw	r30, r12
    37f4:	62 a7       	std	Z+42, r22	; 0x2a
    37f6:	73 a7       	std	Z+43, r23	; 0x2b
    37f8:	84 a7       	std	Z+44, r24	; 0x2c
    37fa:	95 a7       	std	Z+45, r25	; 0x2d
    37fc:	c1 2c       	mov	r12, r1
    37fe:	d1 2c       	mov	r13, r1
    3800:	77 24       	eor	r7, r7
    3802:	73 94       	inc	r7
    3804:	e8 81       	ld	r30, Y
    3806:	f9 81       	ldd	r31, Y+1	; 0x01
    3808:	82 81       	ldd	r24, Z+2	; 0x02
    380a:	90 e0       	ldi	r25, 0x00	; 0
    380c:	c8 16       	cp	r12, r24
    380e:	d9 06       	cpc	r13, r25
    3810:	b8 f4       	brcc	.+46     	; 0x3840 <dir_next+0x18e>
    3812:	74 82       	std	Z+4, r7	; 0x04
    3814:	88 81       	ld	r24, Y
    3816:	99 81       	ldd	r25, Y+1	; 0x01
    3818:	65 d8       	rcall	.-3894   	; 0x28e4 <sync_window>
    381a:	81 11       	cpse	r24, r1
    381c:	aa cf       	rjmp	.-172    	; 0x3772 <dir_next+0xc0>
    381e:	e8 81       	ld	r30, Y
    3820:	f9 81       	ldd	r31, Y+1	; 0x01
    3822:	82 a5       	ldd	r24, Z+42	; 0x2a
    3824:	93 a5       	ldd	r25, Z+43	; 0x2b
    3826:	a4 a5       	ldd	r26, Z+44	; 0x2c
    3828:	b5 a5       	ldd	r27, Z+45	; 0x2d
    382a:	01 96       	adiw	r24, 0x01	; 1
    382c:	a1 1d       	adc	r26, r1
    382e:	b1 1d       	adc	r27, r1
    3830:	82 a7       	std	Z+42, r24	; 0x2a
    3832:	93 a7       	std	Z+43, r25	; 0x2b
    3834:	a4 a7       	std	Z+44, r26	; 0x2c
    3836:	b5 a7       	std	Z+45, r27	; 0x2d
    3838:	ff ef       	ldi	r31, 0xFF	; 255
    383a:	cf 1a       	sub	r12, r31
    383c:	df 0a       	sbc	r13, r31
    383e:	e2 cf       	rjmp	.-60     	; 0x3804 <dir_next+0x152>
    3840:	82 a5       	ldd	r24, Z+42	; 0x2a
    3842:	93 a5       	ldd	r25, Z+43	; 0x2b
    3844:	a4 a5       	ldd	r26, Z+44	; 0x2c
    3846:	b5 a5       	ldd	r27, Z+45	; 0x2d
    3848:	8c 19       	sub	r24, r12
    384a:	9d 09       	sbc	r25, r13
    384c:	a1 09       	sbc	r26, r1
    384e:	b1 09       	sbc	r27, r1
    3850:	82 a7       	std	Z+42, r24	; 0x2a
    3852:	93 a7       	std	Z+43, r25	; 0x2b
    3854:	a4 a7       	std	Z+44, r26	; 0x2c
    3856:	b5 a7       	std	Z+45, r27	; 0x2d
    3858:	8a 86       	std	Y+10, r8	; 0x0a
    385a:	9b 86       	std	Y+11, r9	; 0x0b
    385c:	ac 86       	std	Y+12, r10	; 0x0c
    385e:	bd 86       	std	Y+13, r11	; 0x0d
    3860:	b5 01       	movw	r22, r10
    3862:	a4 01       	movw	r20, r8
    3864:	88 81       	ld	r24, Y
    3866:	99 81       	ldd	r25, Y+1	; 0x01
    3868:	af db       	rcall	.-2210   	; 0x2fc8 <clust2sect>
    386a:	6e 87       	std	Y+14, r22	; 0x0e
    386c:	7f 87       	std	Y+15, r23	; 0x0f
    386e:	88 8b       	std	Y+16, r24	; 0x10
    3870:	99 8b       	std	Y+17, r25	; 0x11
    3872:	1d 83       	std	Y+5, r17	; 0x05
    3874:	0c 83       	std	Y+4, r16	; 0x04
    3876:	88 81       	ld	r24, Y
    3878:	99 81       	ldd	r25, Y+1	; 0x01
    387a:	8e 96       	adiw	r24, 0x2e	; 46
    387c:	25 e0       	ldi	r18, 0x05	; 5
    387e:	ee 0c       	add	r14, r14
    3880:	ff 1c       	adc	r15, r15
    3882:	2a 95       	dec	r18
    3884:	e1 f7       	brne	.-8      	; 0x387e <dir_next+0x1cc>
    3886:	e8 0e       	add	r14, r24
    3888:	f9 1e       	adc	r15, r25
    388a:	fb 8a       	std	Y+19, r15	; 0x13
    388c:	ea 8a       	std	Y+18, r14	; 0x12
    388e:	80 e0       	ldi	r24, 0x00	; 0
    3890:	01 c0       	rjmp	.+2      	; 0x3894 <dir_next+0x1e2>
    3892:	87 e0       	ldi	r24, 0x07	; 7
    3894:	df 91       	pop	r29
    3896:	cf 91       	pop	r28
    3898:	1f 91       	pop	r17
    389a:	0f 91       	pop	r16
    389c:	ff 90       	pop	r15
    389e:	ef 90       	pop	r14
    38a0:	df 90       	pop	r13
    38a2:	cf 90       	pop	r12
    38a4:	bf 90       	pop	r11
    38a6:	af 90       	pop	r10
    38a8:	9f 90       	pop	r9
    38aa:	8f 90       	pop	r8
    38ac:	7f 90       	pop	r7
    38ae:	08 95       	ret

000038b0 <follow_path>:
    38b0:	6f 92       	push	r6
    38b2:	7f 92       	push	r7
    38b4:	8f 92       	push	r8
    38b6:	9f 92       	push	r9
    38b8:	af 92       	push	r10
    38ba:	bf 92       	push	r11
    38bc:	cf 92       	push	r12
    38be:	df 92       	push	r13
    38c0:	ef 92       	push	r14
    38c2:	ff 92       	push	r15
    38c4:	0f 93       	push	r16
    38c6:	1f 93       	push	r17
    38c8:	cf 93       	push	r28
    38ca:	df 93       	push	r29
    38cc:	ec 01       	movw	r28, r24
    38ce:	7b 01       	movw	r14, r22
    38d0:	fb 01       	movw	r30, r22
    38d2:	80 81       	ld	r24, Z
    38d4:	8f 32       	cpi	r24, 0x2F	; 47
    38d6:	11 f0       	breq	.+4      	; 0x38dc <follow_path+0x2c>
    38d8:	8c 35       	cpi	r24, 0x5C	; 92
    38da:	19 f4       	brne	.+6      	; 0x38e2 <follow_path+0x32>
    38dc:	ff ef       	ldi	r31, 0xFF	; 255
    38de:	ef 1a       	sub	r14, r31
    38e0:	ff 0a       	sbc	r15, r31
    38e2:	1e 82       	std	Y+6, r1	; 0x06
    38e4:	1f 82       	std	Y+7, r1	; 0x07
    38e6:	18 86       	std	Y+8, r1	; 0x08
    38e8:	19 86       	std	Y+9, r1	; 0x09
    38ea:	f7 01       	movw	r30, r14
    38ec:	80 81       	ld	r24, Z
    38ee:	80 32       	cpi	r24, 0x20	; 32
    38f0:	28 f0       	brcs	.+10     	; 0x38fc <follow_path+0x4c>
    38f2:	50 e2       	ldi	r21, 0x20	; 32
    38f4:	a5 2e       	mov	r10, r21
    38f6:	65 e0       	ldi	r22, 0x05	; 5
    38f8:	b6 2e       	mov	r11, r22
    38fa:	62 c0       	rjmp	.+196    	; 0x39c0 <follow_path+0x110>
    38fc:	60 e0       	ldi	r22, 0x00	; 0
    38fe:	70 e0       	ldi	r23, 0x00	; 0
    3900:	ce 01       	movw	r24, r28
    3902:	53 dc       	rcall	.-1882   	; 0x31aa <dir_sdi>
    3904:	1b 8a       	std	Y+19, r1	; 0x13
    3906:	1a 8a       	std	Y+18, r1	; 0x12
    3908:	e6 c0       	rjmp	.+460    	; 0x3ad6 <follow_path+0x226>
    390a:	80 e0       	ldi	r24, 0x00	; 0
    390c:	90 e0       	ldi	r25, 0x00	; 0
    390e:	60 e0       	ldi	r22, 0x00	; 0
    3910:	70 e0       	ldi	r23, 0x00	; 0
    3912:	28 e0       	ldi	r18, 0x08	; 8
    3914:	30 e0       	ldi	r19, 0x00	; 0
    3916:	10 e0       	ldi	r17, 0x00	; 0
    3918:	6f 5f       	subi	r22, 0xFF	; 255
    391a:	7f 4f       	sbci	r23, 0xFF	; 255
    391c:	f3 01       	movw	r30, r6
    391e:	01 91       	ld	r16, Z+
    3920:	3f 01       	movw	r6, r30
    3922:	01 32       	cpi	r16, 0x21	; 33
    3924:	08 f0       	brcs	.+2      	; 0x3928 <follow_path+0x78>
    3926:	64 c0       	rjmp	.+200    	; 0x39f0 <follow_path+0x140>
    3928:	e6 0e       	add	r14, r22
    392a:	f7 1e       	adc	r15, r23
    392c:	01 32       	cpi	r16, 0x21	; 33
    392e:	08 f4       	brcc	.+2      	; 0x3932 <follow_path+0x82>
    3930:	85 c0       	rjmp	.+266    	; 0x3a3c <follow_path+0x18c>
    3932:	40 e0       	ldi	r20, 0x00	; 0
    3934:	89 2b       	or	r24, r25
    3936:	09 f4       	brne	.+2      	; 0x393a <follow_path+0x8a>
    3938:	af c0       	rjmp	.+350    	; 0x3a98 <follow_path+0x1e8>
    393a:	8c 91       	ld	r24, X
    393c:	85 3e       	cpi	r24, 0xE5	; 229
    393e:	09 f4       	brne	.+2      	; 0x3942 <follow_path+0x92>
    3940:	bc 92       	st	X, r11
    3942:	28 30       	cpi	r18, 0x08	; 8
    3944:	31 05       	cpc	r19, r1
    3946:	11 f4       	brne	.+4      	; 0x394c <follow_path+0x9c>
    3948:	11 0f       	add	r17, r17
    394a:	11 0f       	add	r17, r17
    394c:	81 2f       	mov	r24, r17
    394e:	83 70       	andi	r24, 0x03	; 3
    3950:	81 30       	cpi	r24, 0x01	; 1
    3952:	09 f4       	brne	.+2      	; 0x3956 <follow_path+0xa6>
    3954:	40 61       	ori	r20, 0x10	; 16
    3956:	81 2f       	mov	r24, r17
    3958:	8c 70       	andi	r24, 0x0C	; 12
    395a:	84 30       	cpi	r24, 0x04	; 4
    395c:	09 f4       	brne	.+2      	; 0x3960 <follow_path+0xb0>
    395e:	48 60       	ori	r20, 0x08	; 8
    3960:	1b 96       	adiw	r26, 0x0b	; 11
    3962:	4c 93       	st	X, r20
    3964:	60 e0       	ldi	r22, 0x00	; 0
    3966:	70 e0       	ldi	r23, 0x00	; 0
    3968:	ce 01       	movw	r24, r28
    396a:	1f dc       	rcall	.-1986   	; 0x31aa <dir_sdi>
    396c:	88 23       	and	r24, r24
    396e:	09 f4       	brne	.+2      	; 0x3972 <follow_path+0xc2>
    3970:	67 c0       	rjmp	.+206    	; 0x3a40 <follow_path+0x190>
    3972:	ec 89       	ldd	r30, Y+20	; 0x14
    3974:	fd 89       	ldd	r31, Y+21	; 0x15
    3976:	93 85       	ldd	r25, Z+11	; 0x0b
    3978:	81 11       	cpse	r24, r1
    397a:	88 c0       	rjmp	.+272    	; 0x3a8c <follow_path+0x1dc>
    397c:	92 fd       	sbrc	r25, 2
    397e:	ab c0       	rjmp	.+342    	; 0x3ad6 <follow_path+0x226>
    3980:	4a 89       	ldd	r20, Y+18	; 0x12
    3982:	5b 89       	ldd	r21, Y+19	; 0x13
    3984:	fa 01       	movw	r30, r20
    3986:	83 85       	ldd	r24, Z+11	; 0x0b
    3988:	84 ff       	sbrs	r24, 4
    398a:	84 c0       	rjmp	.+264    	; 0x3a94 <follow_path+0x1e4>
    398c:	82 8d       	ldd	r24, Z+26	; 0x1a
    398e:	93 8d       	ldd	r25, Z+27	; 0x1b
    3990:	a0 e0       	ldi	r26, 0x00	; 0
    3992:	b0 e0       	ldi	r27, 0x00	; 0
    3994:	28 81       	ld	r18, Y
    3996:	39 81       	ldd	r19, Y+1	; 0x01
    3998:	f9 01       	movw	r30, r18
    399a:	20 81       	ld	r18, Z
    399c:	23 30       	cpi	r18, 0x03	; 3
    399e:	61 f4       	brne	.+24     	; 0x39b8 <follow_path+0x108>
    39a0:	fa 01       	movw	r30, r20
    39a2:	44 89       	ldd	r20, Z+20	; 0x14
    39a4:	55 89       	ldd	r21, Z+21	; 0x15
    39a6:	60 e0       	ldi	r22, 0x00	; 0
    39a8:	70 e0       	ldi	r23, 0x00	; 0
    39aa:	ba 01       	movw	r22, r20
    39ac:	55 27       	eor	r21, r21
    39ae:	44 27       	eor	r20, r20
    39b0:	84 2b       	or	r24, r20
    39b2:	95 2b       	or	r25, r21
    39b4:	a6 2b       	or	r26, r22
    39b6:	b7 2b       	or	r27, r23
    39b8:	8e 83       	std	Y+6, r24	; 0x06
    39ba:	9f 83       	std	Y+7, r25	; 0x07
    39bc:	a8 87       	std	Y+8, r26	; 0x08
    39be:	b9 87       	std	Y+9, r27	; 0x09
    39c0:	37 01       	movw	r6, r14
    39c2:	73 01       	movw	r14, r6
    39c4:	d3 01       	movw	r26, r6
    39c6:	8d 91       	ld	r24, X+
    39c8:	8f 32       	cpi	r24, 0x2F	; 47
    39ca:	11 f4       	brne	.+4      	; 0x39d0 <follow_path+0x120>
    39cc:	3d 01       	movw	r6, r26
    39ce:	f9 cf       	rjmp	.-14     	; 0x39c2 <follow_path+0x112>
    39d0:	8c 35       	cpi	r24, 0x5C	; 92
    39d2:	e1 f3       	breq	.-8      	; 0x39cc <follow_path+0x11c>
    39d4:	ac 89       	ldd	r26, Y+20	; 0x14
    39d6:	bd 89       	ldd	r27, Y+21	; 0x15
    39d8:	cd 01       	movw	r24, r26
    39da:	9d 01       	movw	r18, r26
    39dc:	25 5f       	subi	r18, 0xF5	; 245
    39de:	3f 4f       	sbci	r19, 0xFF	; 255
    39e0:	82 17       	cp	r24, r18
    39e2:	93 07       	cpc	r25, r19
    39e4:	09 f4       	brne	.+2      	; 0x39e8 <follow_path+0x138>
    39e6:	91 cf       	rjmp	.-222    	; 0x390a <follow_path+0x5a>
    39e8:	fc 01       	movw	r30, r24
    39ea:	a1 92       	st	Z+, r10
    39ec:	cf 01       	movw	r24, r30
    39ee:	f8 cf       	rjmp	.-16     	; 0x39e0 <follow_path+0x130>
    39f0:	0f 32       	cpi	r16, 0x2F	; 47
    39f2:	09 f4       	brne	.+2      	; 0x39f6 <follow_path+0x146>
    39f4:	99 cf       	rjmp	.-206    	; 0x3928 <follow_path+0x78>
    39f6:	0c 35       	cpi	r16, 0x5C	; 92
    39f8:	09 f4       	brne	.+2      	; 0x39fc <follow_path+0x14c>
    39fa:	96 cf       	rjmp	.-212    	; 0x3928 <follow_path+0x78>
    39fc:	0e 32       	cpi	r16, 0x2E	; 46
    39fe:	09 f4       	brne	.+2      	; 0x3a02 <follow_path+0x152>
    3a00:	60 c0       	rjmp	.+192    	; 0x3ac2 <follow_path+0x212>
    3a02:	82 17       	cp	r24, r18
    3a04:	93 07       	cpc	r25, r19
    3a06:	08 f0       	brcs	.+2      	; 0x3a0a <follow_path+0x15a>
    3a08:	47 c0       	rjmp	.+142    	; 0x3a98 <follow_path+0x1e8>
    3a0a:	07 ff       	sbrs	r16, 7
    3a0c:	07 c0       	rjmp	.+14     	; 0x3a1c <follow_path+0x16c>
    3a0e:	13 60       	ori	r17, 0x03	; 3
    3a10:	40 2f       	mov	r20, r16
    3a12:	50 e0       	ldi	r21, 0x00	; 0
    3a14:	49 54       	subi	r20, 0x49	; 73
    3a16:	5e 4f       	sbci	r21, 0xFE	; 254
    3a18:	fa 01       	movw	r30, r20
    3a1a:	00 81       	ld	r16, Z
    3a1c:	c0 2e       	mov	r12, r16
    3a1e:	d1 2c       	mov	r13, r1
    3a20:	48 e2       	ldi	r20, 0x28	; 40
    3a22:	84 2e       	mov	r8, r20
    3a24:	42 e0       	ldi	r20, 0x02	; 2
    3a26:	94 2e       	mov	r9, r20
    3a28:	f4 01       	movw	r30, r8
    3a2a:	41 91       	ld	r20, Z+
    3a2c:	4f 01       	movw	r8, r30
    3a2e:	44 23       	and	r20, r20
    3a30:	a9 f1       	breq	.+106    	; 0x3a9c <follow_path+0x1ec>
    3a32:	50 e0       	ldi	r21, 0x00	; 0
    3a34:	c4 16       	cp	r12, r20
    3a36:	d5 06       	cpc	r13, r21
    3a38:	b9 f7       	brne	.-18     	; 0x3a28 <follow_path+0x178>
    3a3a:	2e c0       	rjmp	.+92     	; 0x3a98 <follow_path+0x1e8>
    3a3c:	44 e0       	ldi	r20, 0x04	; 4
    3a3e:	7a cf       	rjmp	.-268    	; 0x3934 <follow_path+0x84>
    3a40:	4e 85       	ldd	r20, Y+14	; 0x0e
    3a42:	5f 85       	ldd	r21, Y+15	; 0x0f
    3a44:	68 89       	ldd	r22, Y+16	; 0x10
    3a46:	79 89       	ldd	r23, Y+17	; 0x11
    3a48:	88 81       	ld	r24, Y
    3a4a:	99 81       	ldd	r25, Y+1	; 0x01
    3a4c:	0e 94 78 14 	call	0x28f0	; 0x28f0 <move_window>
    3a50:	81 11       	cpse	r24, r1
    3a52:	8f cf       	rjmp	.-226    	; 0x3972 <follow_path+0xc2>
    3a54:	ea 89       	ldd	r30, Y+18	; 0x12
    3a56:	fb 89       	ldd	r31, Y+19	; 0x13
    3a58:	90 81       	ld	r25, Z
    3a5a:	99 23       	and	r25, r25
    3a5c:	a9 f0       	breq	.+42     	; 0x3a88 <follow_path+0x1d8>
    3a5e:	93 85       	ldd	r25, Z+11	; 0x0b
    3a60:	93 fd       	sbrc	r25, 3
    3a62:	0d c0       	rjmp	.+26     	; 0x3a7e <follow_path+0x1ce>
    3a64:	ac 89       	ldd	r26, Y+20	; 0x14
    3a66:	bd 89       	ldd	r27, Y+21	; 0x15
    3a68:	af 01       	movw	r20, r30
    3a6a:	45 5f       	subi	r20, 0xF5	; 245
    3a6c:	5f 4f       	sbci	r21, 0xFF	; 255
    3a6e:	4e 17       	cp	r20, r30
    3a70:	5f 07       	cpc	r21, r31
    3a72:	09 f4       	brne	.+2      	; 0x3a76 <follow_path+0x1c6>
    3a74:	7e cf       	rjmp	.-260    	; 0x3972 <follow_path+0xc2>
    3a76:	21 91       	ld	r18, Z+
    3a78:	9d 91       	ld	r25, X+
    3a7a:	29 17       	cp	r18, r25
    3a7c:	c1 f3       	breq	.-16     	; 0x3a6e <follow_path+0x1be>
    3a7e:	60 e0       	ldi	r22, 0x00	; 0
    3a80:	70 e0       	ldi	r23, 0x00	; 0
    3a82:	ce 01       	movw	r24, r28
    3a84:	16 de       	rcall	.-980    	; 0x36b2 <dir_next>
    3a86:	72 cf       	rjmp	.-284    	; 0x396c <follow_path+0xbc>
    3a88:	84 e0       	ldi	r24, 0x04	; 4
    3a8a:	73 cf       	rjmp	.-282    	; 0x3972 <follow_path+0xc2>
    3a8c:	84 30       	cpi	r24, 0x04	; 4
    3a8e:	19 f5       	brne	.+70     	; 0x3ad6 <follow_path+0x226>
    3a90:	92 fd       	sbrc	r25, 2
    3a92:	21 c0       	rjmp	.+66     	; 0x3ad6 <follow_path+0x226>
    3a94:	85 e0       	ldi	r24, 0x05	; 5
    3a96:	1f c0       	rjmp	.+62     	; 0x3ad6 <follow_path+0x226>
    3a98:	86 e0       	ldi	r24, 0x06	; 6
    3a9a:	1d c0       	rjmp	.+58     	; 0x3ad6 <follow_path+0x226>
    3a9c:	4f eb       	ldi	r20, 0xBF	; 191
    3a9e:	40 0f       	add	r20, r16
    3aa0:	4a 31       	cpi	r20, 0x1A	; 26
    3aa2:	10 f4       	brcc	.+4      	; 0x3aa8 <follow_path+0x1f8>
    3aa4:	12 60       	ori	r17, 0x02	; 2
    3aa6:	06 c0       	rjmp	.+12     	; 0x3ab4 <follow_path+0x204>
    3aa8:	4f e9       	ldi	r20, 0x9F	; 159
    3aaa:	40 0f       	add	r20, r16
    3aac:	4a 31       	cpi	r20, 0x1A	; 26
    3aae:	10 f4       	brcc	.+4      	; 0x3ab4 <follow_path+0x204>
    3ab0:	11 60       	ori	r17, 0x01	; 1
    3ab2:	00 52       	subi	r16, 0x20	; 32
    3ab4:	ad 01       	movw	r20, r26
    3ab6:	48 0f       	add	r20, r24
    3ab8:	59 1f       	adc	r21, r25
    3aba:	fa 01       	movw	r30, r20
    3abc:	00 83       	st	Z, r16
    3abe:	01 96       	adiw	r24, 0x01	; 1
    3ac0:	2b cf       	rjmp	.-426    	; 0x3918 <follow_path+0x68>
    3ac2:	28 30       	cpi	r18, 0x08	; 8
    3ac4:	31 05       	cpc	r19, r1
    3ac6:	41 f7       	brne	.-48     	; 0x3a98 <follow_path+0x1e8>
    3ac8:	11 0f       	add	r17, r17
    3aca:	11 0f       	add	r17, r17
    3acc:	88 e0       	ldi	r24, 0x08	; 8
    3ace:	90 e0       	ldi	r25, 0x00	; 0
    3ad0:	2b e0       	ldi	r18, 0x0B	; 11
    3ad2:	30 e0       	ldi	r19, 0x00	; 0
    3ad4:	21 cf       	rjmp	.-446    	; 0x3918 <follow_path+0x68>
    3ad6:	df 91       	pop	r29
    3ad8:	cf 91       	pop	r28
    3ada:	1f 91       	pop	r17
    3adc:	0f 91       	pop	r16
    3ade:	ff 90       	pop	r15
    3ae0:	ef 90       	pop	r14
    3ae2:	df 90       	pop	r13
    3ae4:	cf 90       	pop	r12
    3ae6:	bf 90       	pop	r11
    3ae8:	af 90       	pop	r10
    3aea:	9f 90       	pop	r9
    3aec:	8f 90       	pop	r8
    3aee:	7f 90       	pop	r7
    3af0:	6f 90       	pop	r6
    3af2:	08 95       	ret

00003af4 <dir_register>:
    3af4:	1f 93       	push	r17
    3af6:	cf 93       	push	r28
    3af8:	df 93       	push	r29
    3afa:	ec 01       	movw	r28, r24
    3afc:	60 e0       	ldi	r22, 0x00	; 0
    3afe:	70 e0       	ldi	r23, 0x00	; 0
    3b00:	54 db       	rcall	.-2392   	; 0x31aa <dir_sdi>
    3b02:	18 2f       	mov	r17, r24
    3b04:	81 11       	cpse	r24, r1
    3b06:	39 c0       	rjmp	.+114    	; 0x3b7a <dir_register+0x86>
    3b08:	4e 85       	ldd	r20, Y+14	; 0x0e
    3b0a:	5f 85       	ldd	r21, Y+15	; 0x0f
    3b0c:	68 89       	ldd	r22, Y+16	; 0x10
    3b0e:	79 89       	ldd	r23, Y+17	; 0x11
    3b10:	88 81       	ld	r24, Y
    3b12:	99 81       	ldd	r25, Y+1	; 0x01
    3b14:	0e 94 78 14 	call	0x28f0	; 0x28f0 <move_window>
    3b18:	18 2f       	mov	r17, r24
    3b1a:	81 11       	cpse	r24, r1
    3b1c:	2e c0       	rjmp	.+92     	; 0x3b7a <dir_register+0x86>
    3b1e:	ea 89       	ldd	r30, Y+18	; 0x12
    3b20:	fb 89       	ldd	r31, Y+19	; 0x13
    3b22:	80 81       	ld	r24, Z
    3b24:	85 3e       	cpi	r24, 0xE5	; 229
    3b26:	81 f4       	brne	.+32     	; 0x3b48 <dir_register+0x54>
    3b28:	4e 85       	ldd	r20, Y+14	; 0x0e
    3b2a:	5f 85       	ldd	r21, Y+15	; 0x0f
    3b2c:	68 89       	ldd	r22, Y+16	; 0x10
    3b2e:	79 89       	ldd	r23, Y+17	; 0x11
    3b30:	88 81       	ld	r24, Y
    3b32:	99 81       	ldd	r25, Y+1	; 0x01
    3b34:	0e 94 78 14 	call	0x28f0	; 0x28f0 <move_window>
    3b38:	18 2f       	mov	r17, r24
    3b3a:	81 11       	cpse	r24, r1
    3b3c:	21 c0       	rjmp	.+66     	; 0x3b80 <dir_register+0x8c>
    3b3e:	ea 89       	ldd	r30, Y+18	; 0x12
    3b40:	fb 89       	ldd	r31, Y+19	; 0x13
    3b42:	cf 01       	movw	r24, r30
    3b44:	80 96       	adiw	r24, 0x20	; 32
    3b46:	07 c0       	rjmp	.+14     	; 0x3b56 <dir_register+0x62>
    3b48:	88 23       	and	r24, r24
    3b4a:	71 f3       	breq	.-36     	; 0x3b28 <dir_register+0x34>
    3b4c:	61 e0       	ldi	r22, 0x01	; 1
    3b4e:	70 e0       	ldi	r23, 0x00	; 0
    3b50:	ce 01       	movw	r24, r28
    3b52:	af dd       	rcall	.-1186   	; 0x36b2 <dir_next>
    3b54:	d6 cf       	rjmp	.-84     	; 0x3b02 <dir_register+0xe>
    3b56:	8e 17       	cp	r24, r30
    3b58:	9f 07       	cpc	r25, r31
    3b5a:	11 f0       	breq	.+4      	; 0x3b60 <dir_register+0x6c>
    3b5c:	11 92       	st	Z+, r1
    3b5e:	fb cf       	rjmp	.-10     	; 0x3b56 <dir_register+0x62>
    3b60:	6c 89       	ldd	r22, Y+20	; 0x14
    3b62:	7d 89       	ldd	r23, Y+21	; 0x15
    3b64:	4b e0       	ldi	r20, 0x0B	; 11
    3b66:	50 e0       	ldi	r21, 0x00	; 0
    3b68:	8a 89       	ldd	r24, Y+18	; 0x12
    3b6a:	9b 89       	ldd	r25, Y+19	; 0x13
    3b6c:	0e 94 6d 13 	call	0x26da	; 0x26da <mem_cpy>
    3b70:	e8 81       	ld	r30, Y
    3b72:	f9 81       	ldd	r31, Y+1	; 0x01
    3b74:	81 e0       	ldi	r24, 0x01	; 1
    3b76:	84 83       	std	Z+4, r24	; 0x04
    3b78:	03 c0       	rjmp	.+6      	; 0x3b80 <dir_register+0x8c>
    3b7a:	14 30       	cpi	r17, 0x04	; 4
    3b7c:	09 f4       	brne	.+2      	; 0x3b80 <dir_register+0x8c>
    3b7e:	17 e0       	ldi	r17, 0x07	; 7
    3b80:	81 2f       	mov	r24, r17
    3b82:	df 91       	pop	r29
    3b84:	cf 91       	pop	r28
    3b86:	1f 91       	pop	r17
    3b88:	08 95       	ret

00003b8a <remove_chain>:
    3b8a:	8f 92       	push	r8
    3b8c:	9f 92       	push	r9
    3b8e:	af 92       	push	r10
    3b90:	bf 92       	push	r11
    3b92:	cf 92       	push	r12
    3b94:	df 92       	push	r13
    3b96:	ef 92       	push	r14
    3b98:	ff 92       	push	r15
    3b9a:	0f 93       	push	r16
    3b9c:	1f 93       	push	r17
    3b9e:	cf 93       	push	r28
    3ba0:	df 93       	push	r29
    3ba2:	ec 01       	movw	r28, r24
    3ba4:	6a 01       	movw	r12, r20
    3ba6:	7b 01       	movw	r14, r22
    3ba8:	42 30       	cpi	r20, 0x02	; 2
    3baa:	51 05       	cpc	r21, r1
    3bac:	61 05       	cpc	r22, r1
    3bae:	71 05       	cpc	r23, r1
    3bb0:	10 f4       	brcc	.+4      	; 0x3bb6 <remove_chain+0x2c>
    3bb2:	82 e0       	ldi	r24, 0x02	; 2
    3bb4:	4b c0       	rjmp	.+150    	; 0x3c4c <remove_chain+0xc2>
    3bb6:	8a 89       	ldd	r24, Y+18	; 0x12
    3bb8:	9b 89       	ldd	r25, Y+19	; 0x13
    3bba:	ac 89       	ldd	r26, Y+20	; 0x14
    3bbc:	bd 89       	ldd	r27, Y+21	; 0x15
    3bbe:	48 17       	cp	r20, r24
    3bc0:	59 07       	cpc	r21, r25
    3bc2:	6a 07       	cpc	r22, r26
    3bc4:	7b 07       	cpc	r23, r27
    3bc6:	a8 f7       	brcc	.-22     	; 0x3bb2 <remove_chain+0x28>
    3bc8:	8a 89       	ldd	r24, Y+18	; 0x12
    3bca:	9b 89       	ldd	r25, Y+19	; 0x13
    3bcc:	ac 89       	ldd	r26, Y+20	; 0x14
    3bce:	bd 89       	ldd	r27, Y+21	; 0x15
    3bd0:	c8 16       	cp	r12, r24
    3bd2:	d9 06       	cpc	r13, r25
    3bd4:	ea 06       	cpc	r14, r26
    3bd6:	fb 06       	cpc	r15, r27
    3bd8:	50 f4       	brcc	.+20     	; 0x3bee <remove_chain+0x64>
    3bda:	b7 01       	movw	r22, r14
    3bdc:	a6 01       	movw	r20, r12
    3bde:	ce 01       	movw	r24, r28
    3be0:	1b da       	rcall	.-3018   	; 0x3018 <get_fat>
    3be2:	4b 01       	movw	r8, r22
    3be4:	5c 01       	movw	r10, r24
    3be6:	67 2b       	or	r22, r23
    3be8:	68 2b       	or	r22, r24
    3bea:	69 2b       	or	r22, r25
    3bec:	11 f4       	brne	.+4      	; 0x3bf2 <remove_chain+0x68>
    3bee:	80 e0       	ldi	r24, 0x00	; 0
    3bf0:	2d c0       	rjmp	.+90     	; 0x3c4c <remove_chain+0xc2>
    3bf2:	81 e0       	ldi	r24, 0x01	; 1
    3bf4:	88 16       	cp	r8, r24
    3bf6:	91 04       	cpc	r9, r1
    3bf8:	a1 04       	cpc	r10, r1
    3bfa:	b1 04       	cpc	r11, r1
    3bfc:	d1 f2       	breq	.-76     	; 0x3bb2 <remove_chain+0x28>
    3bfe:	2f ef       	ldi	r18, 0xFF	; 255
    3c00:	82 16       	cp	r8, r18
    3c02:	92 06       	cpc	r9, r18
    3c04:	a2 06       	cpc	r10, r18
    3c06:	b2 06       	cpc	r11, r18
    3c08:	01 f1       	breq	.+64     	; 0x3c4a <remove_chain+0xc0>
    3c0a:	00 e0       	ldi	r16, 0x00	; 0
    3c0c:	10 e0       	ldi	r17, 0x00	; 0
    3c0e:	98 01       	movw	r18, r16
    3c10:	b7 01       	movw	r22, r14
    3c12:	a6 01       	movw	r20, r12
    3c14:	ce 01       	movw	r24, r28
    3c16:	78 db       	rcall	.-2320   	; 0x3308 <put_fat>
    3c18:	81 11       	cpse	r24, r1
    3c1a:	18 c0       	rjmp	.+48     	; 0x3c4c <remove_chain+0xc2>
    3c1c:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c1e:	9f 85       	ldd	r25, Y+15	; 0x0f
    3c20:	a8 89       	ldd	r26, Y+16	; 0x10
    3c22:	b9 89       	ldd	r27, Y+17	; 0x11
    3c24:	8f 3f       	cpi	r24, 0xFF	; 255
    3c26:	2f ef       	ldi	r18, 0xFF	; 255
    3c28:	92 07       	cpc	r25, r18
    3c2a:	a2 07       	cpc	r26, r18
    3c2c:	b2 07       	cpc	r27, r18
    3c2e:	51 f0       	breq	.+20     	; 0x3c44 <remove_chain+0xba>
    3c30:	01 96       	adiw	r24, 0x01	; 1
    3c32:	a1 1d       	adc	r26, r1
    3c34:	b1 1d       	adc	r27, r1
    3c36:	8e 87       	std	Y+14, r24	; 0x0e
    3c38:	9f 87       	std	Y+15, r25	; 0x0f
    3c3a:	a8 8b       	std	Y+16, r26	; 0x10
    3c3c:	b9 8b       	std	Y+17, r27	; 0x11
    3c3e:	8d 81       	ldd	r24, Y+5	; 0x05
    3c40:	81 60       	ori	r24, 0x01	; 1
    3c42:	8d 83       	std	Y+5, r24	; 0x05
    3c44:	75 01       	movw	r14, r10
    3c46:	64 01       	movw	r12, r8
    3c48:	bf cf       	rjmp	.-130    	; 0x3bc8 <remove_chain+0x3e>
    3c4a:	81 e0       	ldi	r24, 0x01	; 1
    3c4c:	df 91       	pop	r29
    3c4e:	cf 91       	pop	r28
    3c50:	1f 91       	pop	r17
    3c52:	0f 91       	pop	r16
    3c54:	ff 90       	pop	r15
    3c56:	ef 90       	pop	r14
    3c58:	df 90       	pop	r13
    3c5a:	cf 90       	pop	r12
    3c5c:	bf 90       	pop	r11
    3c5e:	af 90       	pop	r10
    3c60:	9f 90       	pop	r9
    3c62:	8f 90       	pop	r8
    3c64:	08 95       	ret

00003c66 <f_mount>:
    3c66:	1f 93       	push	r17
    3c68:	cf 93       	push	r28
    3c6a:	df 93       	push	r29
    3c6c:	00 d0       	rcall	.+0      	; 0x3c6e <f_mount+0x8>
    3c6e:	00 d0       	rcall	.+0      	; 0x3c70 <f_mount+0xa>
    3c70:	00 d0       	rcall	.+0      	; 0x3c72 <f_mount+0xc>
    3c72:	cd b7       	in	r28, 0x3d	; 61
    3c74:	de b7       	in	r29, 0x3e	; 62
    3c76:	9c 83       	std	Y+4, r25	; 0x04
    3c78:	8b 83       	std	Y+3, r24	; 0x03
    3c7a:	7e 83       	std	Y+6, r23	; 0x06
    3c7c:	6d 83       	std	Y+5, r22	; 0x05
    3c7e:	14 2f       	mov	r17, r20
    3c80:	7a 83       	std	Y+2, r23	; 0x02
    3c82:	69 83       	std	Y+1, r22	; 0x01
    3c84:	ce 01       	movw	r24, r28
    3c86:	01 96       	adiw	r24, 0x01	; 1
    3c88:	0e 94 d9 13 	call	0x27b2	; 0x27b2 <get_ldnumber>
    3c8c:	97 fd       	sbrc	r25, 7
    3c8e:	24 c0       	rjmp	.+72     	; 0x3cd8 <f_mount+0x72>
    3c90:	88 0f       	add	r24, r24
    3c92:	99 1f       	adc	r25, r25
    3c94:	fc 01       	movw	r30, r24
    3c96:	e8 5c       	subi	r30, 0xC8	; 200
    3c98:	fa 4f       	sbci	r31, 0xFA	; 250
    3c9a:	01 90       	ld	r0, Z+
    3c9c:	f0 81       	ld	r31, Z
    3c9e:	e0 2d       	mov	r30, r0
    3ca0:	30 97       	sbiw	r30, 0x00	; 0
    3ca2:	09 f0       	breq	.+2      	; 0x3ca6 <f_mount+0x40>
    3ca4:	10 82       	st	Z, r1
    3ca6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ca8:	fc 81       	ldd	r31, Y+4	; 0x04
    3caa:	30 97       	sbiw	r30, 0x00	; 0
    3cac:	09 f0       	breq	.+2      	; 0x3cb0 <f_mount+0x4a>
    3cae:	10 82       	st	Z, r1
    3cb0:	2b 81       	ldd	r18, Y+3	; 0x03
    3cb2:	3c 81       	ldd	r19, Y+4	; 0x04
    3cb4:	fc 01       	movw	r30, r24
    3cb6:	e8 5c       	subi	r30, 0xC8	; 200
    3cb8:	fa 4f       	sbci	r31, 0xFA	; 250
    3cba:	31 83       	std	Z+1, r19	; 0x01
    3cbc:	20 83       	st	Z, r18
    3cbe:	23 2b       	or	r18, r19
    3cc0:	69 f0       	breq	.+26     	; 0x3cdc <f_mount+0x76>
    3cc2:	11 30       	cpi	r17, 0x01	; 1
    3cc4:	59 f4       	brne	.+22     	; 0x3cdc <f_mount+0x76>
    3cc6:	40 e0       	ldi	r20, 0x00	; 0
    3cc8:	be 01       	movw	r22, r28
    3cca:	6b 5f       	subi	r22, 0xFB	; 251
    3ccc:	7f 4f       	sbci	r23, 0xFF	; 255
    3cce:	ce 01       	movw	r24, r28
    3cd0:	03 96       	adiw	r24, 0x03	; 3
    3cd2:	0e 94 ed 14 	call	0x29da	; 0x29da <find_volume>
    3cd6:	03 c0       	rjmp	.+6      	; 0x3cde <f_mount+0x78>
    3cd8:	8b e0       	ldi	r24, 0x0B	; 11
    3cda:	01 c0       	rjmp	.+2      	; 0x3cde <f_mount+0x78>
    3cdc:	80 e0       	ldi	r24, 0x00	; 0
    3cde:	26 96       	adiw	r28, 0x06	; 6
    3ce0:	0f b6       	in	r0, 0x3f	; 63
    3ce2:	f8 94       	cli
    3ce4:	de bf       	out	0x3e, r29	; 62
    3ce6:	0f be       	out	0x3f, r0	; 63
    3ce8:	cd bf       	out	0x3d, r28	; 61
    3cea:	df 91       	pop	r29
    3cec:	cf 91       	pop	r28
    3cee:	1f 91       	pop	r17
    3cf0:	08 95       	ret

00003cf2 <f_open>:
    3cf2:	4f 92       	push	r4
    3cf4:	5f 92       	push	r5
    3cf6:	6f 92       	push	r6
    3cf8:	7f 92       	push	r7
    3cfa:	8f 92       	push	r8
    3cfc:	9f 92       	push	r9
    3cfe:	af 92       	push	r10
    3d00:	bf 92       	push	r11
    3d02:	df 92       	push	r13
    3d04:	ef 92       	push	r14
    3d06:	ff 92       	push	r15
    3d08:	0f 93       	push	r16
    3d0a:	1f 93       	push	r17
    3d0c:	cf 93       	push	r28
    3d0e:	df 93       	push	r29
    3d10:	cd b7       	in	r28, 0x3d	; 61
    3d12:	de b7       	in	r29, 0x3e	; 62
    3d14:	a4 97       	sbiw	r28, 0x24	; 36
    3d16:	0f b6       	in	r0, 0x3f	; 63
    3d18:	f8 94       	cli
    3d1a:	de bf       	out	0x3e, r29	; 62
    3d1c:	0f be       	out	0x3f, r0	; 63
    3d1e:	cd bf       	out	0x3d, r28	; 61
    3d20:	7c a3       	std	Y+36, r23	; 0x24
    3d22:	6b a3       	std	Y+35, r22	; 0x23
    3d24:	00 97       	sbiw	r24, 0x00	; 0
    3d26:	09 f4       	brne	.+2      	; 0x3d2a <f_open+0x38>
    3d28:	f2 c0       	rjmp	.+484    	; 0x3f0e <f_open+0x21c>
    3d2a:	b4 2e       	mov	r11, r20
    3d2c:	7c 01       	movw	r14, r24
    3d2e:	dc 01       	movw	r26, r24
    3d30:	1d 92       	st	X+, r1
    3d32:	1c 92       	st	X, r1
    3d34:	4e 71       	andi	r20, 0x1E	; 30
    3d36:	be 01       	movw	r22, r28
    3d38:	6d 5d       	subi	r22, 0xDD	; 221
    3d3a:	7f 4f       	sbci	r23, 0xFF	; 255
    3d3c:	ce 01       	movw	r24, r28
    3d3e:	01 96       	adiw	r24, 0x01	; 1
    3d40:	0e 94 ed 14 	call	0x29da	; 0x29da <find_volume>
    3d44:	81 11       	cpse	r24, r1
    3d46:	ea c0       	rjmp	.+468    	; 0x3f1c <f_open+0x22a>
    3d48:	ce 01       	movw	r24, r28
    3d4a:	47 96       	adiw	r24, 0x17	; 23
    3d4c:	9e 8b       	std	Y+22, r25	; 0x16
    3d4e:	8d 8b       	std	Y+21, r24	; 0x15
    3d50:	6b a1       	ldd	r22, Y+35	; 0x23
    3d52:	7c a1       	ldd	r23, Y+36	; 0x24
    3d54:	46 97       	sbiw	r24, 0x16	; 22
    3d56:	ac dd       	rcall	.-1192   	; 0x38b0 <follow_path>
    3d58:	0b 89       	ldd	r16, Y+19	; 0x13
    3d5a:	1c 89       	ldd	r17, Y+20	; 0x14
    3d5c:	81 11       	cpse	r24, r1
    3d5e:	04 c0       	rjmp	.+8      	; 0x3d68 <f_open+0x76>
    3d60:	01 15       	cp	r16, r1
    3d62:	11 05       	cpc	r17, r1
    3d64:	09 f4       	brne	.+2      	; 0x3d68 <f_open+0x76>
    3d66:	86 e0       	ldi	r24, 0x06	; 6
    3d68:	bb 2d       	mov	r27, r11
    3d6a:	bf 71       	andi	r27, 0x1F	; 31
    3d6c:	db 2e       	mov	r13, r27
    3d6e:	9b 2d       	mov	r25, r11
    3d70:	9c 71       	andi	r25, 0x1C	; 28
    3d72:	09 f4       	brne	.+2      	; 0x3d76 <f_open+0x84>
    3d74:	6e c0       	rjmp	.+220    	; 0x3e52 <f_open+0x160>
    3d76:	88 23       	and	r24, r24
    3d78:	71 f0       	breq	.+28     	; 0x3d96 <f_open+0xa4>
    3d7a:	84 30       	cpi	r24, 0x04	; 4
    3d7c:	09 f0       	breq	.+2      	; 0x3d80 <f_open+0x8e>
    3d7e:	ce c0       	rjmp	.+412    	; 0x3f1c <f_open+0x22a>
    3d80:	ce 01       	movw	r24, r28
    3d82:	01 96       	adiw	r24, 0x01	; 1
    3d84:	b7 de       	rcall	.-658    	; 0x3af4 <dir_register>
    3d86:	81 11       	cpse	r24, r1
    3d88:	c9 c0       	rjmp	.+402    	; 0x3f1c <f_open+0x22a>
    3d8a:	ed 2d       	mov	r30, r13
    3d8c:	e8 60       	ori	r30, 0x08	; 8
    3d8e:	de 2e       	mov	r13, r30
    3d90:	0b 89       	ldd	r16, Y+19	; 0x13
    3d92:	1c 89       	ldd	r17, Y+20	; 0x14
    3d94:	08 c0       	rjmp	.+16     	; 0x3da6 <f_open+0xb4>
    3d96:	d8 01       	movw	r26, r16
    3d98:	1b 96       	adiw	r26, 0x0b	; 11
    3d9a:	8c 91       	ld	r24, X
    3d9c:	81 71       	andi	r24, 0x11	; 17
    3d9e:	09 f0       	breq	.+2      	; 0x3da2 <f_open+0xb0>
    3da0:	bc c0       	rjmp	.+376    	; 0x3f1a <f_open+0x228>
    3da2:	b2 fc       	sbrc	r11, 2
    3da4:	b6 c0       	rjmp	.+364    	; 0x3f12 <f_open+0x220>
    3da6:	d3 fe       	sbrs	r13, 3
    3da8:	64 c0       	rjmp	.+200    	; 0x3e72 <f_open+0x180>
    3daa:	80 e0       	ldi	r24, 0x00	; 0
    3dac:	90 e0       	ldi	r25, 0x00	; 0
    3dae:	a9 e6       	ldi	r26, 0x69	; 105
    3db0:	b5 e4       	ldi	r27, 0x45	; 69
    3db2:	f8 01       	movw	r30, r16
    3db4:	86 87       	std	Z+14, r24	; 0x0e
    3db6:	97 87       	std	Z+15, r25	; 0x0f
    3db8:	a0 8b       	std	Z+16, r26	; 0x10
    3dba:	b1 8b       	std	Z+17, r27	; 0x11
    3dbc:	13 86       	std	Z+11, r1	; 0x0b
    3dbe:	d8 01       	movw	r26, r16
    3dc0:	14 8e       	std	Z+28, r1	; 0x1c
    3dc2:	15 8e       	std	Z+29, r1	; 0x1d
    3dc4:	16 8e       	std	Z+30, r1	; 0x1e
    3dc6:	17 8e       	std	Z+31, r1	; 0x1f
    3dc8:	e9 81       	ldd	r30, Y+1	; 0x01
    3dca:	fa 81       	ldd	r31, Y+2	; 0x02
    3dcc:	5a 96       	adiw	r26, 0x1a	; 26
    3dce:	8d 90       	ld	r8, X+
    3dd0:	9c 90       	ld	r9, X
    3dd2:	5b 97       	sbiw	r26, 0x1b	; 27
    3dd4:	a1 2c       	mov	r10, r1
    3dd6:	b1 2c       	mov	r11, r1
    3dd8:	80 81       	ld	r24, Z
    3dda:	83 30       	cpi	r24, 0x03	; 3
    3ddc:	69 f4       	brne	.+26     	; 0x3df8 <f_open+0x106>
    3dde:	54 96       	adiw	r26, 0x14	; 20
    3de0:	4d 91       	ld	r20, X+
    3de2:	5c 91       	ld	r21, X
    3de4:	55 97       	sbiw	r26, 0x15	; 21
    3de6:	60 e0       	ldi	r22, 0x00	; 0
    3de8:	70 e0       	ldi	r23, 0x00	; 0
    3dea:	ba 01       	movw	r22, r20
    3dec:	55 27       	eor	r21, r21
    3dee:	44 27       	eor	r20, r20
    3df0:	84 2a       	or	r8, r20
    3df2:	95 2a       	or	r9, r21
    3df4:	a6 2a       	or	r10, r22
    3df6:	b7 2a       	or	r11, r23
    3df8:	d8 01       	movw	r26, r16
    3dfa:	5b 96       	adiw	r26, 0x1b	; 27
    3dfc:	1c 92       	st	X, r1
    3dfe:	1e 92       	st	-X, r1
    3e00:	5a 97       	sbiw	r26, 0x1a	; 26
    3e02:	55 96       	adiw	r26, 0x15	; 21
    3e04:	1c 92       	st	X, r1
    3e06:	1e 92       	st	-X, r1
    3e08:	54 97       	sbiw	r26, 0x14	; 20
    3e0a:	81 e0       	ldi	r24, 0x01	; 1
    3e0c:	84 83       	std	Z+4, r24	; 0x04
    3e0e:	81 14       	cp	r8, r1
    3e10:	91 04       	cpc	r9, r1
    3e12:	a1 04       	cpc	r10, r1
    3e14:	b1 04       	cpc	r11, r1
    3e16:	51 f1       	breq	.+84     	; 0x3e6c <f_open+0x17a>
    3e18:	42 a4       	ldd	r4, Z+42	; 0x2a
    3e1a:	53 a4       	ldd	r5, Z+43	; 0x2b
    3e1c:	64 a4       	ldd	r6, Z+44	; 0x2c
    3e1e:	75 a4       	ldd	r7, Z+45	; 0x2d
    3e20:	b5 01       	movw	r22, r10
    3e22:	a4 01       	movw	r20, r8
    3e24:	cf 01       	movw	r24, r30
    3e26:	b1 de       	rcall	.-670    	; 0x3b8a <remove_chain>
    3e28:	81 11       	cpse	r24, r1
    3e2a:	78 c0       	rjmp	.+240    	; 0x3f1c <f_open+0x22a>
    3e2c:	89 81       	ldd	r24, Y+1	; 0x01
    3e2e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e30:	b1 e0       	ldi	r27, 0x01	; 1
    3e32:	8b 1a       	sub	r8, r27
    3e34:	91 08       	sbc	r9, r1
    3e36:	a1 08       	sbc	r10, r1
    3e38:	b1 08       	sbc	r11, r1
    3e3a:	fc 01       	movw	r30, r24
    3e3c:	82 86       	std	Z+10, r8	; 0x0a
    3e3e:	93 86       	std	Z+11, r9	; 0x0b
    3e40:	a4 86       	std	Z+12, r10	; 0x0c
    3e42:	b5 86       	std	Z+13, r11	; 0x0d
    3e44:	b3 01       	movw	r22, r6
    3e46:	a2 01       	movw	r20, r4
    3e48:	0e 94 78 14 	call	0x28f0	; 0x28f0 <move_window>
    3e4c:	88 23       	and	r24, r24
    3e4e:	61 f0       	breq	.+24     	; 0x3e68 <f_open+0x176>
    3e50:	65 c0       	rjmp	.+202    	; 0x3f1c <f_open+0x22a>
    3e52:	81 11       	cpse	r24, r1
    3e54:	63 c0       	rjmp	.+198    	; 0x3f1c <f_open+0x22a>
    3e56:	d8 01       	movw	r26, r16
    3e58:	1b 96       	adiw	r26, 0x0b	; 11
    3e5a:	8c 91       	ld	r24, X
    3e5c:	84 fd       	sbrc	r24, 4
    3e5e:	5b c0       	rjmp	.+182    	; 0x3f16 <f_open+0x224>
    3e60:	b1 fe       	sbrs	r11, 1
    3e62:	02 c0       	rjmp	.+4      	; 0x3e68 <f_open+0x176>
    3e64:	80 fd       	sbrc	r24, 0
    3e66:	59 c0       	rjmp	.+178    	; 0x3f1a <f_open+0x228>
    3e68:	d3 fe       	sbrs	r13, 3
    3e6a:	03 c0       	rjmp	.+6      	; 0x3e72 <f_open+0x180>
    3e6c:	bd 2d       	mov	r27, r13
    3e6e:	b0 62       	ori	r27, 0x20	; 32
    3e70:	db 2e       	mov	r13, r27
    3e72:	a9 80       	ldd	r10, Y+1	; 0x01
    3e74:	ba 80       	ldd	r11, Y+2	; 0x02
    3e76:	f5 01       	movw	r30, r10
    3e78:	42 a5       	ldd	r20, Z+42	; 0x2a
    3e7a:	53 a5       	ldd	r21, Z+43	; 0x2b
    3e7c:	64 a5       	ldd	r22, Z+44	; 0x2c
    3e7e:	75 a5       	ldd	r23, Z+45	; 0x2d
    3e80:	d7 01       	movw	r26, r14
    3e82:	5a 96       	adiw	r26, 0x1a	; 26
    3e84:	4d 93       	st	X+, r20
    3e86:	5d 93       	st	X+, r21
    3e88:	6d 93       	st	X+, r22
    3e8a:	7c 93       	st	X, r23
    3e8c:	5d 97       	sbiw	r26, 0x1d	; 29
    3e8e:	5f 96       	adiw	r26, 0x1f	; 31
    3e90:	1c 93       	st	X, r17
    3e92:	0e 93       	st	-X, r16
    3e94:	5e 97       	sbiw	r26, 0x1e	; 30
    3e96:	14 96       	adiw	r26, 0x04	; 4
    3e98:	dc 92       	st	X, r13
    3e9a:	14 97       	sbiw	r26, 0x04	; 4
    3e9c:	15 96       	adiw	r26, 0x05	; 5
    3e9e:	1c 92       	st	X, r1
    3ea0:	f8 01       	movw	r30, r16
    3ea2:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ea4:	93 8d       	ldd	r25, Z+27	; 0x1b
    3ea6:	a0 e0       	ldi	r26, 0x00	; 0
    3ea8:	b0 e0       	ldi	r27, 0x00	; 0
    3eaa:	f5 01       	movw	r30, r10
    3eac:	20 81       	ld	r18, Z
    3eae:	23 30       	cpi	r18, 0x03	; 3
    3eb0:	61 f4       	brne	.+24     	; 0x3eca <f_open+0x1d8>
    3eb2:	f8 01       	movw	r30, r16
    3eb4:	44 89       	ldd	r20, Z+20	; 0x14
    3eb6:	55 89       	ldd	r21, Z+21	; 0x15
    3eb8:	60 e0       	ldi	r22, 0x00	; 0
    3eba:	70 e0       	ldi	r23, 0x00	; 0
    3ebc:	ba 01       	movw	r22, r20
    3ebe:	55 27       	eor	r21, r21
    3ec0:	44 27       	eor	r20, r20
    3ec2:	84 2b       	or	r24, r20
    3ec4:	95 2b       	or	r25, r21
    3ec6:	a6 2b       	or	r26, r22
    3ec8:	b7 2b       	or	r27, r23
    3eca:	f7 01       	movw	r30, r14
    3ecc:	86 87       	std	Z+14, r24	; 0x0e
    3ece:	97 87       	std	Z+15, r25	; 0x0f
    3ed0:	a0 8b       	std	Z+16, r26	; 0x10
    3ed2:	b1 8b       	std	Z+17, r27	; 0x11
    3ed4:	f8 01       	movw	r30, r16
    3ed6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ed8:	95 8d       	ldd	r25, Z+29	; 0x1d
    3eda:	a6 8d       	ldd	r26, Z+30	; 0x1e
    3edc:	b7 8d       	ldd	r27, Z+31	; 0x1f
    3ede:	f7 01       	movw	r30, r14
    3ee0:	82 87       	std	Z+10, r24	; 0x0a
    3ee2:	93 87       	std	Z+11, r25	; 0x0b
    3ee4:	a4 87       	std	Z+12, r26	; 0x0c
    3ee6:	b5 87       	std	Z+13, r27	; 0x0d
    3ee8:	16 82       	std	Z+6, r1	; 0x06
    3eea:	17 82       	std	Z+7, r1	; 0x07
    3eec:	10 86       	std	Z+8, r1	; 0x08
    3eee:	11 86       	std	Z+9, r1	; 0x09
    3ef0:	16 8a       	std	Z+22, r1	; 0x16
    3ef2:	17 8a       	std	Z+23, r1	; 0x17
    3ef4:	10 8e       	std	Z+24, r1	; 0x18
    3ef6:	11 8e       	std	Z+25, r1	; 0x19
    3ef8:	b1 82       	std	Z+1, r11	; 0x01
    3efa:	a0 82       	st	Z, r10
    3efc:	d5 01       	movw	r26, r10
    3efe:	16 96       	adiw	r26, 0x06	; 6
    3f00:	8d 91       	ld	r24, X+
    3f02:	9c 91       	ld	r25, X
    3f04:	17 97       	sbiw	r26, 0x07	; 7
    3f06:	93 83       	std	Z+3, r25	; 0x03
    3f08:	82 83       	std	Z+2, r24	; 0x02
    3f0a:	80 e0       	ldi	r24, 0x00	; 0
    3f0c:	07 c0       	rjmp	.+14     	; 0x3f1c <f_open+0x22a>
    3f0e:	89 e0       	ldi	r24, 0x09	; 9
    3f10:	05 c0       	rjmp	.+10     	; 0x3f1c <f_open+0x22a>
    3f12:	88 e0       	ldi	r24, 0x08	; 8
    3f14:	03 c0       	rjmp	.+6      	; 0x3f1c <f_open+0x22a>
    3f16:	84 e0       	ldi	r24, 0x04	; 4
    3f18:	01 c0       	rjmp	.+2      	; 0x3f1c <f_open+0x22a>
    3f1a:	87 e0       	ldi	r24, 0x07	; 7
    3f1c:	a4 96       	adiw	r28, 0x24	; 36
    3f1e:	0f b6       	in	r0, 0x3f	; 63
    3f20:	f8 94       	cli
    3f22:	de bf       	out	0x3e, r29	; 62
    3f24:	0f be       	out	0x3f, r0	; 63
    3f26:	cd bf       	out	0x3d, r28	; 61
    3f28:	df 91       	pop	r29
    3f2a:	cf 91       	pop	r28
    3f2c:	1f 91       	pop	r17
    3f2e:	0f 91       	pop	r16
    3f30:	ff 90       	pop	r15
    3f32:	ef 90       	pop	r14
    3f34:	df 90       	pop	r13
    3f36:	bf 90       	pop	r11
    3f38:	af 90       	pop	r10
    3f3a:	9f 90       	pop	r9
    3f3c:	8f 90       	pop	r8
    3f3e:	7f 90       	pop	r7
    3f40:	6f 90       	pop	r6
    3f42:	5f 90       	pop	r5
    3f44:	4f 90       	pop	r4
    3f46:	08 95       	ret

00003f48 <f_write>:
    3f48:	2f 92       	push	r2
    3f4a:	3f 92       	push	r3
    3f4c:	4f 92       	push	r4
    3f4e:	5f 92       	push	r5
    3f50:	6f 92       	push	r6
    3f52:	7f 92       	push	r7
    3f54:	8f 92       	push	r8
    3f56:	9f 92       	push	r9
    3f58:	af 92       	push	r10
    3f5a:	bf 92       	push	r11
    3f5c:	cf 92       	push	r12
    3f5e:	df 92       	push	r13
    3f60:	ef 92       	push	r14
    3f62:	ff 92       	push	r15
    3f64:	0f 93       	push	r16
    3f66:	1f 93       	push	r17
    3f68:	cf 93       	push	r28
    3f6a:	df 93       	push	r29
    3f6c:	ec 01       	movw	r28, r24
    3f6e:	5b 01       	movw	r10, r22
    3f70:	6a 01       	movw	r12, r20
    3f72:	19 01       	movw	r2, r18
    3f74:	f9 01       	movw	r30, r18
    3f76:	11 82       	std	Z+1, r1	; 0x01
    3f78:	10 82       	st	Z, r1
    3f7a:	0e 94 f9 13 	call	0x27f2	; 0x27f2 <validate>
    3f7e:	81 11       	cpse	r24, r1
    3f80:	60 c1       	rjmp	.+704    	; 0x4242 <f_write+0x2fa>
    3f82:	8d 81       	ldd	r24, Y+5	; 0x05
    3f84:	81 11       	cpse	r24, r1
    3f86:	5d c1       	rjmp	.+698    	; 0x4242 <f_write+0x2fa>
    3f88:	8c 81       	ldd	r24, Y+4	; 0x04
    3f8a:	81 ff       	sbrs	r24, 1
    3f8c:	59 c1       	rjmp	.+690    	; 0x4240 <f_write+0x2f8>
    3f8e:	8e 81       	ldd	r24, Y+6	; 0x06
    3f90:	9f 81       	ldd	r25, Y+7	; 0x07
    3f92:	a8 85       	ldd	r26, Y+8	; 0x08
    3f94:	b9 85       	ldd	r27, Y+9	; 0x09
    3f96:	ac 01       	movw	r20, r24
    3f98:	bd 01       	movw	r22, r26
    3f9a:	4c 0d       	add	r20, r12
    3f9c:	5d 1d       	adc	r21, r13
    3f9e:	61 1d       	adc	r22, r1
    3fa0:	71 1d       	adc	r23, r1
    3fa2:	48 17       	cp	r20, r24
    3fa4:	59 07       	cpc	r21, r25
    3fa6:	6a 07       	cpc	r22, r26
    3fa8:	7b 07       	cpc	r23, r27
    3faa:	08 f0       	brcs	.+2      	; 0x3fae <f_write+0x66>
    3fac:	b3 c0       	rjmp	.+358    	; 0x4114 <f_write+0x1cc>
    3fae:	8e 81       	ldd	r24, Y+6	; 0x06
    3fb0:	9f 81       	ldd	r25, Y+7	; 0x07
    3fb2:	a8 85       	ldd	r26, Y+8	; 0x08
    3fb4:	b9 85       	ldd	r27, Y+9	; 0x09
    3fb6:	4a 85       	ldd	r20, Y+10	; 0x0a
    3fb8:	5b 85       	ldd	r21, Y+11	; 0x0b
    3fba:	6c 85       	ldd	r22, Y+12	; 0x0c
    3fbc:	7d 85       	ldd	r23, Y+13	; 0x0d
    3fbe:	48 17       	cp	r20, r24
    3fc0:	59 07       	cpc	r21, r25
    3fc2:	6a 07       	cpc	r22, r26
    3fc4:	7b 07       	cpc	r23, r27
    3fc6:	08 f0       	brcs	.+2      	; 0x3fca <f_write+0x82>
    3fc8:	36 c1       	rjmp	.+620    	; 0x4236 <f_write+0x2ee>
    3fca:	8a 87       	std	Y+10, r24	; 0x0a
    3fcc:	9b 87       	std	Y+11, r25	; 0x0b
    3fce:	ac 87       	std	Y+12, r26	; 0x0c
    3fd0:	bd 87       	std	Y+13, r27	; 0x0d
    3fd2:	31 c1       	rjmp	.+610    	; 0x4236 <f_write+0x2ee>
    3fd4:	4e 81       	ldd	r20, Y+6	; 0x06
    3fd6:	5f 81       	ldd	r21, Y+7	; 0x07
    3fd8:	68 85       	ldd	r22, Y+8	; 0x08
    3fda:	79 85       	ldd	r23, Y+9	; 0x09
    3fdc:	db 01       	movw	r26, r22
    3fde:	ca 01       	movw	r24, r20
    3fe0:	91 70       	andi	r25, 0x01	; 1
    3fe2:	aa 27       	eor	r26, r26
    3fe4:	bb 27       	eor	r27, r27
    3fe6:	89 2b       	or	r24, r25
    3fe8:	8a 2b       	or	r24, r26
    3fea:	8b 2b       	or	r24, r27
    3fec:	09 f0       	breq	.+2      	; 0x3ff0 <f_write+0xa8>
    3fee:	f8 c0       	rjmp	.+496    	; 0x41e0 <f_write+0x298>
    3ff0:	e8 81       	ld	r30, Y
    3ff2:	f9 81       	ldd	r31, Y+1	; 0x01
    3ff4:	22 81       	ldd	r18, Z+2	; 0x02
    3ff6:	21 50       	subi	r18, 0x01	; 1
    3ff8:	2a 01       	movw	r4, r20
    3ffa:	3b 01       	movw	r6, r22
    3ffc:	a9 e0       	ldi	r26, 0x09	; 9
    3ffe:	76 94       	lsr	r7
    4000:	67 94       	ror	r6
    4002:	57 94       	ror	r5
    4004:	47 94       	ror	r4
    4006:	aa 95       	dec	r26
    4008:	d1 f7       	brne	.-12     	; 0x3ffe <f_write+0xb6>
    400a:	12 2f       	mov	r17, r18
    400c:	14 21       	and	r17, r4
    400e:	09 f4       	brne	.+2      	; 0x4012 <f_write+0xca>
    4010:	86 c0       	rjmp	.+268    	; 0x411e <f_write+0x1d6>
    4012:	88 81       	ld	r24, Y
    4014:	99 81       	ldd	r25, Y+1	; 0x01
    4016:	fc 01       	movw	r30, r24
    4018:	42 a4       	ldd	r4, Z+42	; 0x2a
    401a:	53 a4       	ldd	r5, Z+43	; 0x2b
    401c:	64 a4       	ldd	r6, Z+44	; 0x2c
    401e:	75 a4       	ldd	r7, Z+45	; 0x2d
    4020:	4e 89       	ldd	r20, Y+22	; 0x16
    4022:	5f 89       	ldd	r21, Y+23	; 0x17
    4024:	68 8d       	ldd	r22, Y+24	; 0x18
    4026:	79 8d       	ldd	r23, Y+25	; 0x19
    4028:	44 16       	cp	r4, r20
    402a:	55 06       	cpc	r5, r21
    402c:	66 06       	cpc	r6, r22
    402e:	77 06       	cpc	r7, r23
    4030:	09 f4       	brne	.+2      	; 0x4034 <f_write+0xec>
    4032:	b4 c0       	rjmp	.+360    	; 0x419c <f_write+0x254>
    4034:	88 80       	ld	r8, Y
    4036:	99 80       	ldd	r9, Y+1	; 0x01
    4038:	4a 89       	ldd	r20, Y+18	; 0x12
    403a:	5b 89       	ldd	r21, Y+19	; 0x13
    403c:	6c 89       	ldd	r22, Y+20	; 0x14
    403e:	7d 89       	ldd	r23, Y+21	; 0x15
    4040:	c4 01       	movw	r24, r8
    4042:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <clust2sect>
    4046:	61 15       	cp	r22, r1
    4048:	71 05       	cpc	r23, r1
    404a:	81 05       	cpc	r24, r1
    404c:	91 05       	cpc	r25, r1
    404e:	09 f4       	brne	.+2      	; 0x4052 <f_write+0x10a>
    4050:	88 c0       	rjmp	.+272    	; 0x4162 <f_write+0x21a>
    4052:	2b 01       	movw	r4, r22
    4054:	3c 01       	movw	r6, r24
    4056:	41 0e       	add	r4, r17
    4058:	51 1c       	adc	r5, r1
    405a:	61 1c       	adc	r6, r1
    405c:	71 1c       	adc	r7, r1
    405e:	76 01       	movw	r14, r12
    4060:	ef 2c       	mov	r14, r15
    4062:	ff 24       	eor	r15, r15
    4064:	e6 94       	lsr	r14
    4066:	e1 14       	cp	r14, r1
    4068:	f1 04       	cpc	r15, r1
    406a:	09 f4       	brne	.+2      	; 0x406e <f_write+0x126>
    406c:	9d c0       	rjmp	.+314    	; 0x41a8 <f_write+0x260>
    406e:	f4 01       	movw	r30, r8
    4070:	82 81       	ldd	r24, Z+2	; 0x02
    4072:	21 2f       	mov	r18, r17
    4074:	30 e0       	ldi	r19, 0x00	; 0
    4076:	a9 01       	movw	r20, r18
    4078:	4e 0d       	add	r20, r14
    407a:	5f 1d       	adc	r21, r15
    407c:	90 e0       	ldi	r25, 0x00	; 0
    407e:	84 17       	cp	r24, r20
    4080:	95 07       	cpc	r25, r21
    4082:	18 f4       	brcc	.+6      	; 0x408a <f_write+0x142>
    4084:	7c 01       	movw	r14, r24
    4086:	e2 1a       	sub	r14, r18
    4088:	f3 0a       	sbc	r15, r19
    408a:	87 01       	movw	r16, r14
    408c:	a3 01       	movw	r20, r6
    408e:	92 01       	movw	r18, r4
    4090:	b5 01       	movw	r22, r10
    4092:	f4 01       	movw	r30, r8
    4094:	81 81       	ldd	r24, Z+1	; 0x01
    4096:	0e 94 72 12 	call	0x24e4	; 0x24e4 <disk_write>
    409a:	81 11       	cpse	r24, r1
    409c:	6a c0       	rjmp	.+212    	; 0x4172 <f_write+0x22a>
    409e:	88 81       	ld	r24, Y
    40a0:	99 81       	ldd	r25, Y+1	; 0x01
    40a2:	fc 01       	movw	r30, r24
    40a4:	42 a5       	ldd	r20, Z+42	; 0x2a
    40a6:	53 a5       	ldd	r21, Z+43	; 0x2b
    40a8:	64 a5       	ldd	r22, Z+44	; 0x2c
    40aa:	75 a5       	ldd	r23, Z+45	; 0x2d
    40ac:	44 19       	sub	r20, r4
    40ae:	55 09       	sbc	r21, r5
    40b0:	66 09       	sbc	r22, r6
    40b2:	77 09       	sbc	r23, r7
    40b4:	27 01       	movw	r4, r14
    40b6:	61 2c       	mov	r6, r1
    40b8:	71 2c       	mov	r7, r1
    40ba:	44 15       	cp	r20, r4
    40bc:	55 05       	cpc	r21, r5
    40be:	66 05       	cpc	r22, r6
    40c0:	77 05       	cpc	r23, r7
    40c2:	70 f4       	brcc	.+28     	; 0x40e0 <f_write+0x198>
    40c4:	54 2f       	mov	r21, r20
    40c6:	44 27       	eor	r20, r20
    40c8:	55 0f       	add	r21, r21
    40ca:	b5 01       	movw	r22, r10
    40cc:	64 0f       	add	r22, r20
    40ce:	75 1f       	adc	r23, r21
    40d0:	40 e0       	ldi	r20, 0x00	; 0
    40d2:	52 e0       	ldi	r21, 0x02	; 2
    40d4:	8e 96       	adiw	r24, 0x2e	; 46
    40d6:	0e 94 6d 13 	call	0x26da	; 0x26da <mem_cpy>
    40da:	e8 81       	ld	r30, Y
    40dc:	f9 81       	ldd	r31, Y+1	; 0x01
    40de:	14 82       	std	Z+4, r1	; 0x04
    40e0:	fe 2c       	mov	r15, r14
    40e2:	ee 24       	eor	r14, r14
    40e4:	ff 0c       	add	r15, r15
    40e6:	ae 0c       	add	r10, r14
    40e8:	bf 1c       	adc	r11, r15
    40ea:	8e 81       	ldd	r24, Y+6	; 0x06
    40ec:	9f 81       	ldd	r25, Y+7	; 0x07
    40ee:	a8 85       	ldd	r26, Y+8	; 0x08
    40f0:	b9 85       	ldd	r27, Y+9	; 0x09
    40f2:	8e 0d       	add	r24, r14
    40f4:	9f 1d       	adc	r25, r15
    40f6:	a1 1d       	adc	r26, r1
    40f8:	b1 1d       	adc	r27, r1
    40fa:	8e 83       	std	Y+6, r24	; 0x06
    40fc:	9f 83       	std	Y+7, r25	; 0x07
    40fe:	a8 87       	std	Y+8, r26	; 0x08
    4100:	b9 87       	std	Y+9, r27	; 0x09
    4102:	f1 01       	movw	r30, r2
    4104:	80 81       	ld	r24, Z
    4106:	91 81       	ldd	r25, Z+1	; 0x01
    4108:	8e 0d       	add	r24, r14
    410a:	9f 1d       	adc	r25, r15
    410c:	91 83       	std	Z+1, r25	; 0x01
    410e:	80 83       	st	Z, r24
    4110:	ce 18       	sub	r12, r14
    4112:	df 08       	sbc	r13, r15
    4114:	c1 14       	cp	r12, r1
    4116:	d1 04       	cpc	r13, r1
    4118:	09 f0       	breq	.+2      	; 0x411c <f_write+0x1d4>
    411a:	5c cf       	rjmp	.-328    	; 0x3fd4 <f_write+0x8c>
    411c:	48 cf       	rjmp	.-368    	; 0x3fae <f_write+0x66>
    411e:	45 2b       	or	r20, r21
    4120:	46 2b       	or	r20, r22
    4122:	47 2b       	or	r20, r23
    4124:	69 f4       	brne	.+26     	; 0x4140 <f_write+0x1f8>
    4126:	6e 85       	ldd	r22, Y+14	; 0x0e
    4128:	7f 85       	ldd	r23, Y+15	; 0x0f
    412a:	88 89       	ldd	r24, Y+16	; 0x10
    412c:	99 89       	ldd	r25, Y+17	; 0x11
    412e:	61 15       	cp	r22, r1
    4130:	71 05       	cpc	r23, r1
    4132:	81 05       	cpc	r24, r1
    4134:	91 05       	cpc	r25, r1
    4136:	81 f4       	brne	.+32     	; 0x4158 <f_write+0x210>
    4138:	40 e0       	ldi	r20, 0x00	; 0
    413a:	50 e0       	ldi	r21, 0x00	; 0
    413c:	ba 01       	movw	r22, r20
    413e:	04 c0       	rjmp	.+8      	; 0x4148 <f_write+0x200>
    4140:	4a 89       	ldd	r20, Y+18	; 0x12
    4142:	5b 89       	ldd	r21, Y+19	; 0x13
    4144:	6c 89       	ldd	r22, Y+20	; 0x14
    4146:	7d 89       	ldd	r23, Y+21	; 0x15
    4148:	cf 01       	movw	r24, r30
    414a:	d7 d9       	rcall	.-3154   	; 0x34fa <create_chain>
    414c:	61 15       	cp	r22, r1
    414e:	71 05       	cpc	r23, r1
    4150:	81 05       	cpc	r24, r1
    4152:	91 05       	cpc	r25, r1
    4154:	09 f4       	brne	.+2      	; 0x4158 <f_write+0x210>
    4156:	2b cf       	rjmp	.-426    	; 0x3fae <f_write+0x66>
    4158:	61 30       	cpi	r22, 0x01	; 1
    415a:	71 05       	cpc	r23, r1
    415c:	81 05       	cpc	r24, r1
    415e:	91 05       	cpc	r25, r1
    4160:	11 f4       	brne	.+4      	; 0x4166 <f_write+0x21e>
    4162:	82 e0       	ldi	r24, 0x02	; 2
    4164:	07 c0       	rjmp	.+14     	; 0x4174 <f_write+0x22c>
    4166:	6f 3f       	cpi	r22, 0xFF	; 255
    4168:	ff ef       	ldi	r31, 0xFF	; 255
    416a:	7f 07       	cpc	r23, r31
    416c:	8f 07       	cpc	r24, r31
    416e:	9f 07       	cpc	r25, r31
    4170:	19 f4       	brne	.+6      	; 0x4178 <f_write+0x230>
    4172:	81 e0       	ldi	r24, 0x01	; 1
    4174:	8d 83       	std	Y+5, r24	; 0x05
    4176:	65 c0       	rjmp	.+202    	; 0x4242 <f_write+0x2fa>
    4178:	6a 8b       	std	Y+18, r22	; 0x12
    417a:	7b 8b       	std	Y+19, r23	; 0x13
    417c:	8c 8b       	std	Y+20, r24	; 0x14
    417e:	9d 8b       	std	Y+21, r25	; 0x15
    4180:	4e 84       	ldd	r4, Y+14	; 0x0e
    4182:	5f 84       	ldd	r5, Y+15	; 0x0f
    4184:	68 88       	ldd	r6, Y+16	; 0x10
    4186:	79 88       	ldd	r7, Y+17	; 0x11
    4188:	45 28       	or	r4, r5
    418a:	46 28       	or	r4, r6
    418c:	47 28       	or	r4, r7
    418e:	09 f0       	breq	.+2      	; 0x4192 <f_write+0x24a>
    4190:	40 cf       	rjmp	.-384    	; 0x4012 <f_write+0xca>
    4192:	6e 87       	std	Y+14, r22	; 0x0e
    4194:	7f 87       	std	Y+15, r23	; 0x0f
    4196:	88 8b       	std	Y+16, r24	; 0x10
    4198:	99 8b       	std	Y+17, r25	; 0x11
    419a:	3b cf       	rjmp	.-394    	; 0x4012 <f_write+0xca>
    419c:	0e 94 72 14 	call	0x28e4	; 0x28e4 <sync_window>
    41a0:	88 23       	and	r24, r24
    41a2:	09 f4       	brne	.+2      	; 0x41a6 <f_write+0x25e>
    41a4:	47 cf       	rjmp	.-370    	; 0x4034 <f_write+0xec>
    41a6:	e5 cf       	rjmp	.-54     	; 0x4172 <f_write+0x22a>
    41a8:	4e 81       	ldd	r20, Y+6	; 0x06
    41aa:	5f 81       	ldd	r21, Y+7	; 0x07
    41ac:	68 85       	ldd	r22, Y+8	; 0x08
    41ae:	79 85       	ldd	r23, Y+9	; 0x09
    41b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    41b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    41b4:	ac 85       	ldd	r26, Y+12	; 0x0c
    41b6:	bd 85       	ldd	r27, Y+13	; 0x0d
    41b8:	48 17       	cp	r20, r24
    41ba:	59 07       	cpc	r21, r25
    41bc:	6a 07       	cpc	r22, r26
    41be:	7b 07       	cpc	r23, r27
    41c0:	58 f0       	brcs	.+22     	; 0x41d8 <f_write+0x290>
    41c2:	c4 01       	movw	r24, r8
    41c4:	0e 94 72 14 	call	0x28e4	; 0x28e4 <sync_window>
    41c8:	81 11       	cpse	r24, r1
    41ca:	d3 cf       	rjmp	.-90     	; 0x4172 <f_write+0x22a>
    41cc:	e8 81       	ld	r30, Y
    41ce:	f9 81       	ldd	r31, Y+1	; 0x01
    41d0:	42 a6       	std	Z+42, r4	; 0x2a
    41d2:	53 a6       	std	Z+43, r5	; 0x2b
    41d4:	64 a6       	std	Z+44, r6	; 0x2c
    41d6:	75 a6       	std	Z+45, r7	; 0x2d
    41d8:	4e 8a       	std	Y+22, r4	; 0x16
    41da:	5f 8a       	std	Y+23, r5	; 0x17
    41dc:	68 8e       	std	Y+24, r6	; 0x18
    41de:	79 8e       	std	Y+25, r7	; 0x19
    41e0:	8e 81       	ldd	r24, Y+6	; 0x06
    41e2:	9f 81       	ldd	r25, Y+7	; 0x07
    41e4:	91 70       	andi	r25, 0x01	; 1
    41e6:	20 e0       	ldi	r18, 0x00	; 0
    41e8:	32 e0       	ldi	r19, 0x02	; 2
    41ea:	28 1b       	sub	r18, r24
    41ec:	39 0b       	sbc	r19, r25
    41ee:	76 01       	movw	r14, r12
    41f0:	2c 15       	cp	r18, r12
    41f2:	3d 05       	cpc	r19, r13
    41f4:	08 f4       	brcc	.+2      	; 0x41f8 <f_write+0x2b0>
    41f6:	79 01       	movw	r14, r18
    41f8:	4e 89       	ldd	r20, Y+22	; 0x16
    41fa:	5f 89       	ldd	r21, Y+23	; 0x17
    41fc:	68 8d       	ldd	r22, Y+24	; 0x18
    41fe:	79 8d       	ldd	r23, Y+25	; 0x19
    4200:	88 81       	ld	r24, Y
    4202:	99 81       	ldd	r25, Y+1	; 0x01
    4204:	0e 94 78 14 	call	0x28f0	; 0x28f0 <move_window>
    4208:	81 11       	cpse	r24, r1
    420a:	b3 cf       	rjmp	.-154    	; 0x4172 <f_write+0x22a>
    420c:	8e 81       	ldd	r24, Y+6	; 0x06
    420e:	9f 81       	ldd	r25, Y+7	; 0x07
    4210:	a8 85       	ldd	r26, Y+8	; 0x08
    4212:	b9 85       	ldd	r27, Y+9	; 0x09
    4214:	91 70       	andi	r25, 0x01	; 1
    4216:	aa 27       	eor	r26, r26
    4218:	bb 27       	eor	r27, r27
    421a:	8e 96       	adiw	r24, 0x2e	; 46
    421c:	28 81       	ld	r18, Y
    421e:	39 81       	ldd	r19, Y+1	; 0x01
    4220:	a7 01       	movw	r20, r14
    4222:	b5 01       	movw	r22, r10
    4224:	82 0f       	add	r24, r18
    4226:	93 1f       	adc	r25, r19
    4228:	0e 94 6d 13 	call	0x26da	; 0x26da <mem_cpy>
    422c:	e8 81       	ld	r30, Y
    422e:	f9 81       	ldd	r31, Y+1	; 0x01
    4230:	31 e0       	ldi	r19, 0x01	; 1
    4232:	34 83       	std	Z+4, r19	; 0x04
    4234:	58 cf       	rjmp	.-336    	; 0x40e6 <f_write+0x19e>
    4236:	8c 81       	ldd	r24, Y+4	; 0x04
    4238:	80 62       	ori	r24, 0x20	; 32
    423a:	8c 83       	std	Y+4, r24	; 0x04
    423c:	80 e0       	ldi	r24, 0x00	; 0
    423e:	01 c0       	rjmp	.+2      	; 0x4242 <f_write+0x2fa>
    4240:	87 e0       	ldi	r24, 0x07	; 7
    4242:	df 91       	pop	r29
    4244:	cf 91       	pop	r28
    4246:	1f 91       	pop	r17
    4248:	0f 91       	pop	r16
    424a:	ff 90       	pop	r15
    424c:	ef 90       	pop	r14
    424e:	df 90       	pop	r13
    4250:	cf 90       	pop	r12
    4252:	bf 90       	pop	r11
    4254:	af 90       	pop	r10
    4256:	9f 90       	pop	r9
    4258:	8f 90       	pop	r8
    425a:	7f 90       	pop	r7
    425c:	6f 90       	pop	r6
    425e:	5f 90       	pop	r5
    4260:	4f 90       	pop	r4
    4262:	3f 90       	pop	r3
    4264:	2f 90       	pop	r2
    4266:	08 95       	ret

00004268 <f_sync>:
    4268:	cf 93       	push	r28
    426a:	df 93       	push	r29
    426c:	ec 01       	movw	r28, r24
    426e:	0e 94 f9 13 	call	0x27f2	; 0x27f2 <validate>
    4272:	81 11       	cpse	r24, r1
    4274:	39 c0       	rjmp	.+114    	; 0x42e8 <f_sync+0x80>
    4276:	9c 81       	ldd	r25, Y+4	; 0x04
    4278:	95 ff       	sbrs	r25, 5
    427a:	36 c0       	rjmp	.+108    	; 0x42e8 <f_sync+0x80>
    427c:	4a 8d       	ldd	r20, Y+26	; 0x1a
    427e:	5b 8d       	ldd	r21, Y+27	; 0x1b
    4280:	6c 8d       	ldd	r22, Y+28	; 0x1c
    4282:	7d 8d       	ldd	r23, Y+29	; 0x1d
    4284:	88 81       	ld	r24, Y
    4286:	99 81       	ldd	r25, Y+1	; 0x01
    4288:	0e 94 78 14 	call	0x28f0	; 0x28f0 <move_window>
    428c:	81 11       	cpse	r24, r1
    428e:	2c c0       	rjmp	.+88     	; 0x42e8 <f_sync+0x80>
    4290:	ee 8d       	ldd	r30, Y+30	; 0x1e
    4292:	ff 8d       	ldd	r31, Y+31	; 0x1f
    4294:	83 85       	ldd	r24, Z+11	; 0x0b
    4296:	80 62       	ori	r24, 0x20	; 32
    4298:	83 87       	std	Z+11, r24	; 0x0b
    429a:	8a 85       	ldd	r24, Y+10	; 0x0a
    429c:	9b 85       	ldd	r25, Y+11	; 0x0b
    429e:	ac 85       	ldd	r26, Y+12	; 0x0c
    42a0:	bd 85       	ldd	r27, Y+13	; 0x0d
    42a2:	84 8f       	std	Z+28, r24	; 0x1c
    42a4:	95 8f       	std	Z+29, r25	; 0x1d
    42a6:	a6 8f       	std	Z+30, r26	; 0x1e
    42a8:	b7 8f       	std	Z+31, r27	; 0x1f
    42aa:	8e 85       	ldd	r24, Y+14	; 0x0e
    42ac:	9f 85       	ldd	r25, Y+15	; 0x0f
    42ae:	a8 89       	ldd	r26, Y+16	; 0x10
    42b0:	b9 89       	ldd	r27, Y+17	; 0x11
    42b2:	93 8f       	std	Z+27, r25	; 0x1b
    42b4:	82 8f       	std	Z+26, r24	; 0x1a
    42b6:	b5 8b       	std	Z+21, r27	; 0x15
    42b8:	a4 8b       	std	Z+20, r26	; 0x14
    42ba:	80 e0       	ldi	r24, 0x00	; 0
    42bc:	90 e0       	ldi	r25, 0x00	; 0
    42be:	a9 e6       	ldi	r26, 0x69	; 105
    42c0:	b5 e4       	ldi	r27, 0x45	; 69
    42c2:	86 8b       	std	Z+22, r24	; 0x16
    42c4:	97 8b       	std	Z+23, r25	; 0x17
    42c6:	a0 8f       	std	Z+24, r26	; 0x18
    42c8:	b1 8f       	std	Z+25, r27	; 0x19
    42ca:	13 8a       	std	Z+19, r1	; 0x13
    42cc:	12 8a       	std	Z+18, r1	; 0x12
    42ce:	8c 81       	ldd	r24, Y+4	; 0x04
    42d0:	8f 7d       	andi	r24, 0xDF	; 223
    42d2:	8c 83       	std	Y+4, r24	; 0x04
    42d4:	e8 81       	ld	r30, Y
    42d6:	f9 81       	ldd	r31, Y+1	; 0x01
    42d8:	81 e0       	ldi	r24, 0x01	; 1
    42da:	84 83       	std	Z+4, r24	; 0x04
    42dc:	88 81       	ld	r24, Y
    42de:	99 81       	ldd	r25, Y+1	; 0x01
    42e0:	df 91       	pop	r29
    42e2:	cf 91       	pop	r28
    42e4:	0c 94 7b 17 	jmp	0x2ef6	; 0x2ef6 <sync_fs>
    42e8:	df 91       	pop	r29
    42ea:	cf 91       	pop	r28
    42ec:	08 95       	ret

000042ee <f_close>:
    42ee:	cf 93       	push	r28
    42f0:	df 93       	push	r29
    42f2:	ec 01       	movw	r28, r24
    42f4:	b9 df       	rcall	.-142    	; 0x4268 <f_sync>
    42f6:	81 11       	cpse	r24, r1
    42f8:	07 c0       	rjmp	.+14     	; 0x4308 <f_close+0x1a>
    42fa:	ce 01       	movw	r24, r28
    42fc:	0e 94 f9 13 	call	0x27f2	; 0x27f2 <validate>
    4300:	81 11       	cpse	r24, r1
    4302:	02 c0       	rjmp	.+4      	; 0x4308 <f_close+0x1a>
    4304:	19 82       	std	Y+1, r1	; 0x01
    4306:	18 82       	st	Y, r1
    4308:	df 91       	pop	r29
    430a:	cf 91       	pop	r28
    430c:	08 95       	ret

0000430e <f_lseek>:
    430e:	4f 92       	push	r4
    4310:	5f 92       	push	r5
    4312:	6f 92       	push	r6
    4314:	7f 92       	push	r7
    4316:	8f 92       	push	r8
    4318:	9f 92       	push	r9
    431a:	af 92       	push	r10
    431c:	bf 92       	push	r11
    431e:	cf 92       	push	r12
    4320:	df 92       	push	r13
    4322:	ef 92       	push	r14
    4324:	ff 92       	push	r15
    4326:	0f 93       	push	r16
    4328:	1f 93       	push	r17
    432a:	cf 93       	push	r28
    432c:	df 93       	push	r29
    432e:	00 d0       	rcall	.+0      	; 0x4330 <f_lseek+0x22>
    4330:	00 d0       	rcall	.+0      	; 0x4332 <f_lseek+0x24>
    4332:	00 d0       	rcall	.+0      	; 0x4334 <f_lseek+0x26>
    4334:	cd b7       	in	r28, 0x3d	; 61
    4336:	de b7       	in	r29, 0x3e	; 62
    4338:	9e 83       	std	Y+6, r25	; 0x06
    433a:	8d 83       	std	Y+5, r24	; 0x05
    433c:	6a 01       	movw	r12, r20
    433e:	7b 01       	movw	r14, r22
    4340:	0e 94 f9 13 	call	0x27f2	; 0x27f2 <validate>
    4344:	81 11       	cpse	r24, r1
    4346:	72 c1       	rjmp	.+740    	; 0x462c <f_lseek+0x31e>
    4348:	ad 81       	ldd	r26, Y+5	; 0x05
    434a:	be 81       	ldd	r27, Y+6	; 0x06
    434c:	15 96       	adiw	r26, 0x05	; 5
    434e:	8c 91       	ld	r24, X
    4350:	15 97       	sbiw	r26, 0x05	; 5
    4352:	81 11       	cpse	r24, r1
    4354:	6b c1       	rjmp	.+726    	; 0x462c <f_lseek+0x31e>
    4356:	1a 96       	adiw	r26, 0x0a	; 10
    4358:	8d 91       	ld	r24, X+
    435a:	9d 91       	ld	r25, X+
    435c:	0d 90       	ld	r0, X+
    435e:	bc 91       	ld	r27, X
    4360:	a0 2d       	mov	r26, r0
    4362:	8c 15       	cp	r24, r12
    4364:	9d 05       	cpc	r25, r13
    4366:	ae 05       	cpc	r26, r14
    4368:	bf 05       	cpc	r27, r15
    436a:	38 f4       	brcc	.+14     	; 0x437a <f_lseek+0x6c>
    436c:	ed 81       	ldd	r30, Y+5	; 0x05
    436e:	fe 81       	ldd	r31, Y+6	; 0x06
    4370:	24 81       	ldd	r18, Z+4	; 0x04
    4372:	21 fd       	sbrc	r18, 1
    4374:	02 c0       	rjmp	.+4      	; 0x437a <f_lseek+0x6c>
    4376:	6c 01       	movw	r12, r24
    4378:	7d 01       	movw	r14, r26
    437a:	ad 81       	ldd	r26, Y+5	; 0x05
    437c:	be 81       	ldd	r27, Y+6	; 0x06
    437e:	16 96       	adiw	r26, 0x06	; 6
    4380:	4d 90       	ld	r4, X+
    4382:	5d 90       	ld	r5, X+
    4384:	6d 90       	ld	r6, X+
    4386:	7c 90       	ld	r7, X
    4388:	19 97       	sbiw	r26, 0x09	; 9
    438a:	fd 01       	movw	r30, r26
    438c:	16 82       	std	Z+6, r1	; 0x06
    438e:	17 82       	std	Z+7, r1	; 0x07
    4390:	10 86       	std	Z+8, r1	; 0x08
    4392:	11 86       	std	Z+9, r1	; 0x09
    4394:	c1 14       	cp	r12, r1
    4396:	d1 04       	cpc	r13, r1
    4398:	e1 04       	cpc	r14, r1
    439a:	f1 04       	cpc	r15, r1
    439c:	09 f4       	brne	.+2      	; 0x43a0 <f_lseek+0x92>
    439e:	42 c1       	rjmp	.+644    	; 0x4624 <f_lseek+0x316>
    43a0:	ad 81       	ldd	r26, Y+5	; 0x05
    43a2:	be 81       	ldd	r27, Y+6	; 0x06
    43a4:	0d 91       	ld	r16, X+
    43a6:	1c 91       	ld	r17, X
    43a8:	f8 01       	movw	r30, r16
    43aa:	82 80       	ldd	r8, Z+2	; 0x02
    43ac:	91 2c       	mov	r9, r1
    43ae:	a1 2c       	mov	r10, r1
    43b0:	b1 2c       	mov	r11, r1
    43b2:	39 e0       	ldi	r19, 0x09	; 9
    43b4:	88 0c       	add	r8, r8
    43b6:	99 1c       	adc	r9, r9
    43b8:	aa 1c       	adc	r10, r10
    43ba:	bb 1c       	adc	r11, r11
    43bc:	3a 95       	dec	r19
    43be:	d1 f7       	brne	.-12     	; 0x43b4 <f_lseek+0xa6>
    43c0:	41 14       	cp	r4, r1
    43c2:	51 04       	cpc	r5, r1
    43c4:	61 04       	cpc	r6, r1
    43c6:	71 04       	cpc	r7, r1
    43c8:	09 f4       	brne	.+2      	; 0x43cc <f_lseek+0xbe>
    43ca:	40 c0       	rjmp	.+128    	; 0x444c <f_lseek+0x13e>
    43cc:	f1 e0       	ldi	r31, 0x01	; 1
    43ce:	4f 1a       	sub	r4, r31
    43d0:	51 08       	sbc	r5, r1
    43d2:	61 08       	sbc	r6, r1
    43d4:	71 08       	sbc	r7, r1
    43d6:	c7 01       	movw	r24, r14
    43d8:	b6 01       	movw	r22, r12
    43da:	61 50       	subi	r22, 0x01	; 1
    43dc:	71 09       	sbc	r23, r1
    43de:	81 09       	sbc	r24, r1
    43e0:	91 09       	sbc	r25, r1
    43e2:	a5 01       	movw	r20, r10
    43e4:	94 01       	movw	r18, r8
    43e6:	0e 94 d3 37 	call	0x6fa6	; 0x6fa6 <__udivmodsi4>
    43ea:	29 83       	std	Y+1, r18	; 0x01
    43ec:	3a 83       	std	Y+2, r19	; 0x02
    43ee:	4b 83       	std	Y+3, r20	; 0x03
    43f0:	5c 83       	std	Y+4, r21	; 0x04
    43f2:	c3 01       	movw	r24, r6
    43f4:	b2 01       	movw	r22, r4
    43f6:	a5 01       	movw	r20, r10
    43f8:	94 01       	movw	r18, r8
    43fa:	0e 94 d3 37 	call	0x6fa6	; 0x6fa6 <__udivmodsi4>
    43fe:	89 81       	ldd	r24, Y+1	; 0x01
    4400:	9a 81       	ldd	r25, Y+2	; 0x02
    4402:	ab 81       	ldd	r26, Y+3	; 0x03
    4404:	bc 81       	ldd	r27, Y+4	; 0x04
    4406:	82 17       	cp	r24, r18
    4408:	93 07       	cpc	r25, r19
    440a:	a4 07       	cpc	r26, r20
    440c:	b5 07       	cpc	r27, r21
    440e:	f0 f0       	brcs	.+60     	; 0x444c <f_lseek+0x13e>
    4410:	88 27       	eor	r24, r24
    4412:	99 27       	eor	r25, r25
    4414:	dc 01       	movw	r26, r24
    4416:	88 19       	sub	r24, r8
    4418:	99 09       	sbc	r25, r9
    441a:	aa 09       	sbc	r26, r10
    441c:	bb 09       	sbc	r27, r11
    441e:	48 22       	and	r4, r24
    4420:	59 22       	and	r5, r25
    4422:	6a 22       	and	r6, r26
    4424:	7b 22       	and	r7, r27
    4426:	ad 81       	ldd	r26, Y+5	; 0x05
    4428:	be 81       	ldd	r27, Y+6	; 0x06
    442a:	16 96       	adiw	r26, 0x06	; 6
    442c:	4d 92       	st	X+, r4
    442e:	5d 92       	st	X+, r5
    4430:	6d 92       	st	X+, r6
    4432:	7c 92       	st	X, r7
    4434:	19 97       	sbiw	r26, 0x09	; 9
    4436:	c4 18       	sub	r12, r4
    4438:	d5 08       	sbc	r13, r5
    443a:	e6 08       	sbc	r14, r6
    443c:	f7 08       	sbc	r15, r7
    443e:	52 96       	adiw	r26, 0x12	; 18
    4440:	4d 91       	ld	r20, X+
    4442:	5d 91       	ld	r21, X+
    4444:	6d 91       	ld	r22, X+
    4446:	7c 91       	ld	r23, X
    4448:	55 97       	sbiw	r26, 0x15	; 21
    444a:	36 c0       	rjmp	.+108    	; 0x44b8 <f_lseek+0x1aa>
    444c:	ed 81       	ldd	r30, Y+5	; 0x05
    444e:	fe 81       	ldd	r31, Y+6	; 0x06
    4450:	46 85       	ldd	r20, Z+14	; 0x0e
    4452:	57 85       	ldd	r21, Z+15	; 0x0f
    4454:	60 89       	ldd	r22, Z+16	; 0x10
    4456:	71 89       	ldd	r23, Z+17	; 0x11
    4458:	41 15       	cp	r20, r1
    445a:	51 05       	cpc	r21, r1
    445c:	61 05       	cpc	r22, r1
    445e:	71 05       	cpc	r23, r1
    4460:	29 f5       	brne	.+74     	; 0x44ac <f_lseek+0x19e>
    4462:	40 e0       	ldi	r20, 0x00	; 0
    4464:	50 e0       	ldi	r21, 0x00	; 0
    4466:	ba 01       	movw	r22, r20
    4468:	c8 01       	movw	r24, r16
    446a:	47 d8       	rcall	.-3954   	; 0x34fa <create_chain>
    446c:	ab 01       	movw	r20, r22
    446e:	bc 01       	movw	r22, r24
    4470:	41 30       	cpi	r20, 0x01	; 1
    4472:	51 05       	cpc	r21, r1
    4474:	61 05       	cpc	r22, r1
    4476:	71 05       	cpc	r23, r1
    4478:	31 f4       	brne	.+12     	; 0x4486 <f_lseek+0x178>
    447a:	82 e0       	ldi	r24, 0x02	; 2
    447c:	ad 81       	ldd	r26, Y+5	; 0x05
    447e:	be 81       	ldd	r27, Y+6	; 0x06
    4480:	15 96       	adiw	r26, 0x05	; 5
    4482:	8c 93       	st	X, r24
    4484:	d3 c0       	rjmp	.+422    	; 0x462c <f_lseek+0x31e>
    4486:	4f 3f       	cpi	r20, 0xFF	; 255
    4488:	bf ef       	ldi	r27, 0xFF	; 255
    448a:	5b 07       	cpc	r21, r27
    448c:	6b 07       	cpc	r22, r27
    448e:	7b 07       	cpc	r23, r27
    4490:	29 f4       	brne	.+10     	; 0x449c <f_lseek+0x18e>
    4492:	81 e0       	ldi	r24, 0x01	; 1
    4494:	ed 81       	ldd	r30, Y+5	; 0x05
    4496:	fe 81       	ldd	r31, Y+6	; 0x06
    4498:	85 83       	std	Z+5, r24	; 0x05
    449a:	c8 c0       	rjmp	.+400    	; 0x462c <f_lseek+0x31e>
    449c:	ad 81       	ldd	r26, Y+5	; 0x05
    449e:	be 81       	ldd	r27, Y+6	; 0x06
    44a0:	1e 96       	adiw	r26, 0x0e	; 14
    44a2:	4d 93       	st	X+, r20
    44a4:	5d 93       	st	X+, r21
    44a6:	6d 93       	st	X+, r22
    44a8:	7c 93       	st	X, r23
    44aa:	51 97       	sbiw	r26, 0x11	; 17
    44ac:	ed 81       	ldd	r30, Y+5	; 0x05
    44ae:	fe 81       	ldd	r31, Y+6	; 0x06
    44b0:	42 8b       	std	Z+18, r20	; 0x12
    44b2:	53 8b       	std	Z+19, r21	; 0x13
    44b4:	64 8b       	std	Z+20, r22	; 0x14
    44b6:	75 8b       	std	Z+21, r23	; 0x15
    44b8:	41 15       	cp	r20, r1
    44ba:	51 05       	cpc	r21, r1
    44bc:	61 05       	cpc	r22, r1
    44be:	71 05       	cpc	r23, r1
    44c0:	09 f0       	breq	.+2      	; 0x44c4 <f_lseek+0x1b6>
    44c2:	45 c0       	rjmp	.+138    	; 0x454e <f_lseek+0x240>
    44c4:	c1 2c       	mov	r12, r1
    44c6:	d1 2c       	mov	r13, r1
    44c8:	76 01       	movw	r14, r12
    44ca:	7c c0       	rjmp	.+248    	; 0x45c4 <f_lseek+0x2b6>
    44cc:	ad 81       	ldd	r26, Y+5	; 0x05
    44ce:	be 81       	ldd	r27, Y+6	; 0x06
    44d0:	14 96       	adiw	r26, 0x04	; 4
    44d2:	2c 91       	ld	r18, X
    44d4:	14 97       	sbiw	r26, 0x04	; 4
    44d6:	8d 91       	ld	r24, X+
    44d8:	9c 91       	ld	r25, X
    44da:	21 ff       	sbrs	r18, 1
    44dc:	3f c0       	rjmp	.+126    	; 0x455c <f_lseek+0x24e>
    44de:	0d d8       	rcall	.-4070   	; 0x34fa <create_chain>
    44e0:	ab 01       	movw	r20, r22
    44e2:	bc 01       	movw	r22, r24
    44e4:	41 15       	cp	r20, r1
    44e6:	51 05       	cpc	r21, r1
    44e8:	61 05       	cpc	r22, r1
    44ea:	71 05       	cpc	r23, r1
    44ec:	e1 f1       	breq	.+120    	; 0x4566 <f_lseek+0x258>
    44ee:	4f 3f       	cpi	r20, 0xFF	; 255
    44f0:	bf ef       	ldi	r27, 0xFF	; 255
    44f2:	5b 07       	cpc	r21, r27
    44f4:	6b 07       	cpc	r22, r27
    44f6:	7b 07       	cpc	r23, r27
    44f8:	61 f2       	breq	.-104    	; 0x4492 <f_lseek+0x184>
    44fa:	42 30       	cpi	r20, 0x02	; 2
    44fc:	51 05       	cpc	r21, r1
    44fe:	61 05       	cpc	r22, r1
    4500:	71 05       	cpc	r23, r1
    4502:	08 f4       	brcc	.+2      	; 0x4506 <f_lseek+0x1f8>
    4504:	ba cf       	rjmp	.-140    	; 0x447a <f_lseek+0x16c>
    4506:	ad 81       	ldd	r26, Y+5	; 0x05
    4508:	be 81       	ldd	r27, Y+6	; 0x06
    450a:	ed 91       	ld	r30, X+
    450c:	fc 91       	ld	r31, X
    450e:	82 89       	ldd	r24, Z+18	; 0x12
    4510:	93 89       	ldd	r25, Z+19	; 0x13
    4512:	a4 89       	ldd	r26, Z+20	; 0x14
    4514:	b5 89       	ldd	r27, Z+21	; 0x15
    4516:	48 17       	cp	r20, r24
    4518:	59 07       	cpc	r21, r25
    451a:	6a 07       	cpc	r22, r26
    451c:	7b 07       	cpc	r23, r27
    451e:	08 f0       	brcs	.+2      	; 0x4522 <f_lseek+0x214>
    4520:	ac cf       	rjmp	.-168    	; 0x447a <f_lseek+0x16c>
    4522:	ed 81       	ldd	r30, Y+5	; 0x05
    4524:	fe 81       	ldd	r31, Y+6	; 0x06
    4526:	42 8b       	std	Z+18, r20	; 0x12
    4528:	53 8b       	std	Z+19, r21	; 0x13
    452a:	64 8b       	std	Z+20, r22	; 0x14
    452c:	75 8b       	std	Z+21, r23	; 0x15
    452e:	86 81       	ldd	r24, Z+6	; 0x06
    4530:	97 81       	ldd	r25, Z+7	; 0x07
    4532:	a0 85       	ldd	r26, Z+8	; 0x08
    4534:	b1 85       	ldd	r27, Z+9	; 0x09
    4536:	88 0d       	add	r24, r8
    4538:	99 1d       	adc	r25, r9
    453a:	aa 1d       	adc	r26, r10
    453c:	bb 1d       	adc	r27, r11
    453e:	86 83       	std	Z+6, r24	; 0x06
    4540:	97 83       	std	Z+7, r25	; 0x07
    4542:	a0 87       	std	Z+8, r26	; 0x08
    4544:	b1 87       	std	Z+9, r27	; 0x09
    4546:	c8 18       	sub	r12, r8
    4548:	d9 08       	sbc	r13, r9
    454a:	ea 08       	sbc	r14, r10
    454c:	fb 08       	sbc	r15, r11
    454e:	8c 14       	cp	r8, r12
    4550:	9d 04       	cpc	r9, r13
    4552:	ae 04       	cpc	r10, r14
    4554:	bf 04       	cpc	r11, r15
    4556:	08 f4       	brcc	.+2      	; 0x455a <f_lseek+0x24c>
    4558:	b9 cf       	rjmp	.-142    	; 0x44cc <f_lseek+0x1be>
    455a:	07 c0       	rjmp	.+14     	; 0x456a <f_lseek+0x25c>
    455c:	0e 94 0c 18 	call	0x3018	; 0x3018 <get_fat>
    4560:	ab 01       	movw	r20, r22
    4562:	bc 01       	movw	r22, r24
    4564:	c4 cf       	rjmp	.-120    	; 0x44ee <f_lseek+0x1e0>
    4566:	75 01       	movw	r14, r10
    4568:	64 01       	movw	r12, r8
    456a:	ed 81       	ldd	r30, Y+5	; 0x05
    456c:	fe 81       	ldd	r31, Y+6	; 0x06
    456e:	86 81       	ldd	r24, Z+6	; 0x06
    4570:	97 81       	ldd	r25, Z+7	; 0x07
    4572:	a0 85       	ldd	r26, Z+8	; 0x08
    4574:	b1 85       	ldd	r27, Z+9	; 0x09
    4576:	8c 0d       	add	r24, r12
    4578:	9d 1d       	adc	r25, r13
    457a:	ae 1d       	adc	r26, r14
    457c:	bf 1d       	adc	r27, r15
    457e:	86 83       	std	Z+6, r24	; 0x06
    4580:	97 83       	std	Z+7, r25	; 0x07
    4582:	a0 87       	std	Z+8, r26	; 0x08
    4584:	b1 87       	std	Z+9, r27	; 0x09
    4586:	d7 01       	movw	r26, r14
    4588:	c6 01       	movw	r24, r12
    458a:	91 70       	andi	r25, 0x01	; 1
    458c:	aa 27       	eor	r26, r26
    458e:	bb 27       	eor	r27, r27
    4590:	89 2b       	or	r24, r25
    4592:	8a 2b       	or	r24, r26
    4594:	8b 2b       	or	r24, r27
    4596:	09 f4       	brne	.+2      	; 0x459a <f_lseek+0x28c>
    4598:	95 cf       	rjmp	.-214    	; 0x44c4 <f_lseek+0x1b6>
    459a:	80 81       	ld	r24, Z
    459c:	91 81       	ldd	r25, Z+1	; 0x01
    459e:	0e 94 e4 17 	call	0x2fc8	; 0x2fc8 <clust2sect>
    45a2:	61 15       	cp	r22, r1
    45a4:	71 05       	cpc	r23, r1
    45a6:	81 05       	cpc	r24, r1
    45a8:	91 05       	cpc	r25, r1
    45aa:	09 f4       	brne	.+2      	; 0x45ae <f_lseek+0x2a0>
    45ac:	66 cf       	rjmp	.-308    	; 0x447a <f_lseek+0x16c>
    45ae:	29 e0       	ldi	r18, 0x09	; 9
    45b0:	f6 94       	lsr	r15
    45b2:	e7 94       	ror	r14
    45b4:	d7 94       	ror	r13
    45b6:	c7 94       	ror	r12
    45b8:	2a 95       	dec	r18
    45ba:	d1 f7       	brne	.-12     	; 0x45b0 <f_lseek+0x2a2>
    45bc:	c6 0e       	add	r12, r22
    45be:	d7 1e       	adc	r13, r23
    45c0:	e8 1e       	adc	r14, r24
    45c2:	f9 1e       	adc	r15, r25
    45c4:	ed 81       	ldd	r30, Y+5	; 0x05
    45c6:	fe 81       	ldd	r31, Y+6	; 0x06
    45c8:	86 81       	ldd	r24, Z+6	; 0x06
    45ca:	97 81       	ldd	r25, Z+7	; 0x07
    45cc:	a0 85       	ldd	r26, Z+8	; 0x08
    45ce:	b1 85       	ldd	r27, Z+9	; 0x09
    45d0:	ac 01       	movw	r20, r24
    45d2:	bd 01       	movw	r22, r26
    45d4:	51 70       	andi	r21, 0x01	; 1
    45d6:	66 27       	eor	r22, r22
    45d8:	77 27       	eor	r23, r23
    45da:	45 2b       	or	r20, r21
    45dc:	46 2b       	or	r20, r22
    45de:	47 2b       	or	r20, r23
    45e0:	69 f0       	breq	.+26     	; 0x45fc <f_lseek+0x2ee>
    45e2:	46 89       	ldd	r20, Z+22	; 0x16
    45e4:	57 89       	ldd	r21, Z+23	; 0x17
    45e6:	60 8d       	ldd	r22, Z+24	; 0x18
    45e8:	71 8d       	ldd	r23, Z+25	; 0x19
    45ea:	c4 16       	cp	r12, r20
    45ec:	d5 06       	cpc	r13, r21
    45ee:	e6 06       	cpc	r14, r22
    45f0:	f7 06       	cpc	r15, r23
    45f2:	21 f0       	breq	.+8      	; 0x45fc <f_lseek+0x2ee>
    45f4:	c6 8a       	std	Z+22, r12	; 0x16
    45f6:	d7 8a       	std	Z+23, r13	; 0x17
    45f8:	e0 8e       	std	Z+24, r14	; 0x18
    45fa:	f1 8e       	std	Z+25, r15	; 0x19
    45fc:	ed 81       	ldd	r30, Y+5	; 0x05
    45fe:	fe 81       	ldd	r31, Y+6	; 0x06
    4600:	42 85       	ldd	r20, Z+10	; 0x0a
    4602:	53 85       	ldd	r21, Z+11	; 0x0b
    4604:	64 85       	ldd	r22, Z+12	; 0x0c
    4606:	75 85       	ldd	r23, Z+13	; 0x0d
    4608:	48 17       	cp	r20, r24
    460a:	59 07       	cpc	r21, r25
    460c:	6a 07       	cpc	r22, r26
    460e:	7b 07       	cpc	r23, r27
    4610:	38 f4       	brcc	.+14     	; 0x4620 <f_lseek+0x312>
    4612:	82 87       	std	Z+10, r24	; 0x0a
    4614:	93 87       	std	Z+11, r25	; 0x0b
    4616:	a4 87       	std	Z+12, r26	; 0x0c
    4618:	b5 87       	std	Z+13, r27	; 0x0d
    461a:	84 81       	ldd	r24, Z+4	; 0x04
    461c:	80 62       	ori	r24, 0x20	; 32
    461e:	84 83       	std	Z+4, r24	; 0x04
    4620:	80 e0       	ldi	r24, 0x00	; 0
    4622:	04 c0       	rjmp	.+8      	; 0x462c <f_lseek+0x31e>
    4624:	80 e0       	ldi	r24, 0x00	; 0
    4626:	90 e0       	ldi	r25, 0x00	; 0
    4628:	dc 01       	movw	r26, r24
    462a:	e8 cf       	rjmp	.-48     	; 0x45fc <f_lseek+0x2ee>
    462c:	26 96       	adiw	r28, 0x06	; 6
    462e:	0f b6       	in	r0, 0x3f	; 63
    4630:	f8 94       	cli
    4632:	de bf       	out	0x3e, r29	; 62
    4634:	0f be       	out	0x3f, r0	; 63
    4636:	cd bf       	out	0x3d, r28	; 61
    4638:	df 91       	pop	r29
    463a:	cf 91       	pop	r28
    463c:	1f 91       	pop	r17
    463e:	0f 91       	pop	r16
    4640:	ff 90       	pop	r15
    4642:	ef 90       	pop	r14
    4644:	df 90       	pop	r13
    4646:	cf 90       	pop	r12
    4648:	bf 90       	pop	r11
    464a:	af 90       	pop	r10
    464c:	9f 90       	pop	r9
    464e:	8f 90       	pop	r8
    4650:	7f 90       	pop	r7
    4652:	6f 90       	pop	r6
    4654:	5f 90       	pop	r5
    4656:	4f 90       	pop	r4
    4658:	08 95       	ret

0000465a <f_stat>:
    465a:	ef 92       	push	r14
    465c:	ff 92       	push	r15
    465e:	1f 93       	push	r17
    4660:	cf 93       	push	r28
    4662:	df 93       	push	r29
    4664:	cd b7       	in	r28, 0x3d	; 61
    4666:	de b7       	in	r29, 0x3e	; 62
    4668:	a4 97       	sbiw	r28, 0x24	; 36
    466a:	0f b6       	in	r0, 0x3f	; 63
    466c:	f8 94       	cli
    466e:	de bf       	out	0x3e, r29	; 62
    4670:	0f be       	out	0x3f, r0	; 63
    4672:	cd bf       	out	0x3d, r28	; 61
    4674:	9c a3       	std	Y+36, r25	; 0x24
    4676:	8b a3       	std	Y+35, r24	; 0x23
    4678:	7b 01       	movw	r14, r22
    467a:	40 e0       	ldi	r20, 0x00	; 0
    467c:	be 01       	movw	r22, r28
    467e:	6d 5d       	subi	r22, 0xDD	; 221
    4680:	7f 4f       	sbci	r23, 0xFF	; 255
    4682:	ce 01       	movw	r24, r28
    4684:	01 96       	adiw	r24, 0x01	; 1
    4686:	0e 94 ed 14 	call	0x29da	; 0x29da <find_volume>
    468a:	18 2f       	mov	r17, r24
    468c:	81 11       	cpse	r24, r1
    468e:	19 c0       	rjmp	.+50     	; 0x46c2 <f_stat+0x68>
    4690:	ce 01       	movw	r24, r28
    4692:	47 96       	adiw	r24, 0x17	; 23
    4694:	9e 8b       	std	Y+22, r25	; 0x16
    4696:	8d 8b       	std	Y+21, r24	; 0x15
    4698:	6b a1       	ldd	r22, Y+35	; 0x23
    469a:	7c a1       	ldd	r23, Y+36	; 0x24
    469c:	46 97       	sbiw	r24, 0x16	; 22
    469e:	08 d9       	rcall	.-3568   	; 0x38b0 <follow_path>
    46a0:	18 2f       	mov	r17, r24
    46a2:	81 11       	cpse	r24, r1
    46a4:	0e c0       	rjmp	.+28     	; 0x46c2 <f_stat+0x68>
    46a6:	8b 89       	ldd	r24, Y+19	; 0x13
    46a8:	9c 89       	ldd	r25, Y+20	; 0x14
    46aa:	89 2b       	or	r24, r25
    46ac:	49 f0       	breq	.+18     	; 0x46c0 <f_stat+0x66>
    46ae:	e1 14       	cp	r14, r1
    46b0:	f1 04       	cpc	r15, r1
    46b2:	39 f0       	breq	.+14     	; 0x46c2 <f_stat+0x68>
    46b4:	b7 01       	movw	r22, r14
    46b6:	ce 01       	movw	r24, r28
    46b8:	01 96       	adiw	r24, 0x01	; 1
    46ba:	0e 94 8c 13 	call	0x2718	; 0x2718 <get_fileinfo>
    46be:	01 c0       	rjmp	.+2      	; 0x46c2 <f_stat+0x68>
    46c0:	16 e0       	ldi	r17, 0x06	; 6
    46c2:	81 2f       	mov	r24, r17
    46c4:	a4 96       	adiw	r28, 0x24	; 36
    46c6:	0f b6       	in	r0, 0x3f	; 63
    46c8:	f8 94       	cli
    46ca:	de bf       	out	0x3e, r29	; 62
    46cc:	0f be       	out	0x3f, r0	; 63
    46ce:	cd bf       	out	0x3d, r28	; 61
    46d0:	df 91       	pop	r29
    46d2:	cf 91       	pop	r28
    46d4:	1f 91       	pop	r17
    46d6:	ff 90       	pop	r15
    46d8:	ef 90       	pop	r14
    46da:	08 95       	ret

000046dc <SCSI_Command_ReadWrite_10>:
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_ReadWrite_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                      const bool IsDataRead)
{
    46dc:	bf 92       	push	r11
    46de:	cf 92       	push	r12
    46e0:	df 92       	push	r13
    46e2:	ef 92       	push	r14
    46e4:	ff 92       	push	r15
    46e6:	0f 93       	push	r16
    46e8:	1f 93       	push	r17
    46ea:	cf 93       	push	r28
    46ec:	df 93       	push	r29
    46ee:	ec 01       	movw	r28, r24
    46f0:	b6 2e       	mov	r11, r22

				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
    46f2:	c8 a0       	ldd	r12, Y+32	; 0x20
    46f4:	df 8c       	ldd	r13, Y+31	; 0x1f
    46f6:	ee 8c       	ldd	r14, Y+30	; 0x1e
    46f8:	fd 8c       	ldd	r15, Y+29	; 0x1d

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
    46fa:	0b a1       	ldd	r16, Y+35	; 0x23
    46fc:	1a a1       	ldd	r17, Y+34	; 0x22

	/* Load in the 16-bit total blocks (SCSI uses big-endian, so have to reverse the byte order) */
	TotalBlocks  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[7]);

	/* Check if the block address is outside the maximum allowable value for the LUN */
	if (BlockAddress >= get_num_of_sectors())
    46fe:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <get_num_of_sectors>
    4702:	c6 16       	cp	r12, r22
    4704:	d7 06       	cpc	r13, r23
    4706:	e8 06       	cpc	r14, r24
    4708:	f9 06       	cpc	r15, r25
    470a:	68 f0       	brcs	.+26     	; 0x4726 <SCSI_Command_ReadWrite_10+0x4a>
	{
		/* Block address is invalid, update SENSE key and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    470c:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <SenseData+0x2>
    4710:	80 7f       	andi	r24, 0xF0	; 240
    4712:	85 60       	ori	r24, 0x05	; 5
    4714:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <SenseData+0x2>
    4718:	81 e2       	ldi	r24, 0x21	; 33
    471a:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <SenseData+0xc>
    471e:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <SenseData+0xd>
    4722:	80 e0       	ldi	r24, 0x00	; 0
    4724:	22 c0       	rjmp	.+68     	; 0x476a <SCSI_Command_ReadWrite_10+0x8e>
	}

	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
	  //SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
	  SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
    4726:	98 01       	movw	r18, r16
    4728:	b7 01       	movw	r22, r14
    472a:	a6 01       	movw	r20, r12
    472c:	ce 01       	movw	r24, r28

		return false;
	}

	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
    472e:	bb 20       	and	r11, r11
    4730:	11 f0       	breq	.+4      	; 0x4736 <SCSI_Command_ReadWrite_10+0x5a>
	  //SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
	  SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
    4732:	79 d2       	rcall	.+1266   	; 0x4c26 <SDCardManager_ReadBlocks>
    4734:	01 c0       	rjmp	.+2      	; 0x4738 <SCSI_Command_ReadWrite_10+0x5c>
	else
	  SDCardManager_WriteBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
    4736:	d1 d1       	rcall	.+930    	; 0x4ada <SDCardManager_WriteBlocks>
    4738:	c8 01       	movw	r24, r16

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= ((uint32_t)TotalBlocks * VIRTUAL_MEMORY_BLOCK_SIZE);
    473a:	a0 e0       	ldi	r26, 0x00	; 0
    473c:	b0 e0       	ldi	r27, 0x00	; 0
    473e:	29 e0       	ldi	r18, 0x09	; 9
    4740:	88 0f       	add	r24, r24
    4742:	99 1f       	adc	r25, r25
    4744:	aa 1f       	adc	r26, r26
    4746:	bb 1f       	adc	r27, r27
    4748:	2a 95       	dec	r18
    474a:	d1 f7       	brne	.-12     	; 0x4740 <SCSI_Command_ReadWrite_10+0x64>
    474c:	4c 89       	ldd	r20, Y+20	; 0x14
    474e:	5d 89       	ldd	r21, Y+21	; 0x15
    4750:	6e 89       	ldd	r22, Y+22	; 0x16
    4752:	7f 89       	ldd	r23, Y+23	; 0x17
    4754:	8a 01       	movw	r16, r20
    4756:	9b 01       	movw	r18, r22
    4758:	08 1b       	sub	r16, r24
    475a:	19 0b       	sbc	r17, r25
    475c:	2a 0b       	sbc	r18, r26
    475e:	3b 0b       	sbc	r19, r27
    4760:	0c 8b       	std	Y+20, r16	; 0x14
    4762:	1d 8b       	std	Y+21, r17	; 0x15
    4764:	2e 8b       	std	Y+22, r18	; 0x16
    4766:	3f 8b       	std	Y+23, r19	; 0x17
    4768:	81 e0       	ldi	r24, 0x01	; 1

	return true;
    476a:	df 91       	pop	r29
}
    476c:	cf 91       	pop	r28
    476e:	1f 91       	pop	r17
    4770:	0f 91       	pop	r16
    4772:	ff 90       	pop	r15
    4774:	ef 90       	pop	r14
    4776:	df 90       	pop	r13
    4778:	cf 90       	pop	r12
    477a:	bf 90       	pop	r11
    477c:	08 95       	ret

0000477e <SCSI_DecodeSCSICommand>:
    477e:	cf 92       	push	r12
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise
 */
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    4780:	df 92       	push	r13
    4782:	ef 92       	push	r14
    4784:	ff 92       	push	r15
    4786:	0f 93       	push	r16
    4788:	1f 93       	push	r17
    478a:	cf 93       	push	r28
    478c:	df 93       	push	r29
    478e:	cd b7       	in	r28, 0x3d	; 61
    4790:	de b7       	in	r29, 0x3e	; 62
    4792:	28 97       	sbiw	r28, 0x08	; 8
    4794:	0f b6       	in	r0, 0x3f	; 63
    4796:	f8 94       	cli
    4798:	de bf       	out	0x3e, r29	; 62
    479a:	0f be       	out	0x3f, r0	; 63
    479c:	cd bf       	out	0x3d, r28	; 61
    479e:	8c 01       	movw	r16, r24
	bool CommandSuccess = false;



	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
    47a0:	fc 01       	movw	r30, r24
    47a2:	83 8d       	ldd	r24, Z+27	; 0x1b
    47a4:	8d 31       	cpi	r24, 0x1D	; 29
    47a6:	09 f4       	brne	.+2      	; 0x47aa <SCSI_DecodeSCSICommand+0x2c>
    47a8:	c2 c0       	rjmp	.+388    	; 0x492e <SCSI_DecodeSCSICommand+0x1b0>
    47aa:	88 f4       	brcc	.+34     	; 0x47ce <SCSI_DecodeSCSICommand+0x50>
    47ac:	82 31       	cpi	r24, 0x12	; 18
    47ae:	09 f1       	breq	.+66     	; 0x47f2 <SCSI_DecodeSCSICommand+0x74>
    47b0:	38 f4       	brcc	.+14     	; 0x47c0 <SCSI_DecodeSCSICommand+0x42>
    47b2:	88 23       	and	r24, r24
    47b4:	09 f4       	brne	.+2      	; 0x47b8 <SCSI_DecodeSCSICommand+0x3a>
    47b6:	01 c1       	rjmp	.+514    	; 0x49ba <SCSI_DecodeSCSICommand+0x23c>
    47b8:	83 30       	cpi	r24, 0x03	; 3
    47ba:	09 f4       	brne	.+2      	; 0x47be <SCSI_DecodeSCSICommand+0x40>
    47bc:	50 c0       	rjmp	.+160    	; 0x485e <SCSI_DecodeSCSICommand+0xe0>
    47be:	0c c1       	rjmp	.+536    	; 0x49d8 <SCSI_DecodeSCSICommand+0x25a>
    47c0:	8a 31       	cpi	r24, 0x1A	; 26
    47c2:	09 f4       	brne	.+2      	; 0x47c6 <SCSI_DecodeSCSICommand+0x48>
    47c4:	e0 c0       	rjmp	.+448    	; 0x4986 <SCSI_DecodeSCSICommand+0x208>
    47c6:	8b 31       	cpi	r24, 0x1B	; 27
    47c8:	09 f4       	brne	.+2      	; 0x47cc <SCSI_DecodeSCSICommand+0x4e>
    47ca:	00 c1       	rjmp	.+512    	; 0x49cc <SCSI_DecodeSCSICommand+0x24e>
    47cc:	05 c1       	rjmp	.+522    	; 0x49d8 <SCSI_DecodeSCSICommand+0x25a>
    47ce:	88 32       	cpi	r24, 0x28	; 40
    47d0:	09 f4       	brne	.+2      	; 0x47d4 <SCSI_DecodeSCSICommand+0x56>
    47d2:	ca c0       	rjmp	.+404    	; 0x4968 <SCSI_DecodeSCSICommand+0x1ea>
    47d4:	38 f4       	brcc	.+14     	; 0x47e4 <SCSI_DecodeSCSICommand+0x66>
    47d6:	8e 31       	cpi	r24, 0x1E	; 30
    47d8:	09 f4       	brne	.+2      	; 0x47dc <SCSI_DecodeSCSICommand+0x5e>
    47da:	f8 c0       	rjmp	.+496    	; 0x49cc <SCSI_DecodeSCSICommand+0x24e>
    47dc:	85 32       	cpi	r24, 0x25	; 37
    47de:	09 f4       	brne	.+2      	; 0x47e2 <SCSI_DecodeSCSICommand+0x64>
    47e0:	66 c0       	rjmp	.+204    	; 0x48ae <SCSI_DecodeSCSICommand+0x130>
    47e2:	fa c0       	rjmp	.+500    	; 0x49d8 <SCSI_DecodeSCSICommand+0x25a>
    47e4:	8a 32       	cpi	r24, 0x2A	; 42
    47e6:	09 f4       	brne	.+2      	; 0x47ea <SCSI_DecodeSCSICommand+0x6c>
    47e8:	b4 c0       	rjmp	.+360    	; 0x4952 <SCSI_DecodeSCSICommand+0x1d4>
    47ea:	8f 32       	cpi	r24, 0x2F	; 47
    47ec:	09 f4       	brne	.+2      	; 0x47f0 <SCSI_DecodeSCSICommand+0x72>
    47ee:	ee c0       	rjmp	.+476    	; 0x49cc <SCSI_DecodeSCSICommand+0x24e>
    47f0:	f3 c0       	rjmp	.+486    	; 0x49d8 <SCSI_DecodeSCSICommand+0x25a>
    47f2:	f8 01       	movw	r30, r16
    47f4:	e7 8c       	ldd	r14, Z+31	; 0x1f
    47f6:	f6 8c       	ldd	r15, Z+30	; 0x1e
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));

	/* Only the standard INQUIRY data is supported, check if any optional INQUIRY bits set */
	if ((MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & ((1 << 0) | (1 << 1))) ||
    47f8:	84 8d       	ldd	r24, Z+28	; 0x1c
    47fa:	83 70       	andi	r24, 0x03	; 3
    47fc:	19 f4       	brne	.+6      	; 0x4804 <SCSI_DecodeSCSICommand+0x86>
    47fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    4800:	88 23       	and	r24, r24
    4802:	41 f0       	breq	.+16     	; 0x4814 <SCSI_DecodeSCSICommand+0x96>
	     MSInterfaceInfo->State.CommandBlock.SCSICommandData[2])
	{
		/* Optional but unsupported bits set - update the SENSE key and fail the request */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    4804:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <SenseData+0x2>
    4808:	80 7f       	andi	r24, 0xF0	; 240
    480a:	85 60       	ori	r24, 0x05	; 5
    480c:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <SenseData+0x2>
    4810:	84 e2       	ldi	r24, 0x24	; 36
    4812:	e9 c0       	rjmp	.+466    	; 0x49e6 <SCSI_DecodeSCSICommand+0x268>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));
    4814:	67 01       	movw	r12, r14
    4816:	f5 e2       	ldi	r31, 0x25	; 37
    4818:	ef 16       	cp	r14, r31
    481a:	f1 04       	cpc	r15, r1
    481c:	18 f0       	brcs	.+6      	; 0x4824 <SCSI_DecodeSCSICommand+0xa6>
    481e:	94 e2       	ldi	r25, 0x24	; 36
    4820:	c9 2e       	mov	r12, r25
    4822:	d1 2c       	mov	r13, r1
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
	}

	Endpoint_Write_Stream_LE(&InquiryData, BytesTransferred, NULL);
    4824:	40 e0       	ldi	r20, 0x00	; 0
    4826:	50 e0       	ldi	r21, 0x00	; 0
    4828:	b6 01       	movw	r22, r12
    482a:	87 eb       	ldi	r24, 0xB7	; 183
    482c:	92 e0       	ldi	r25, 0x02	; 2
    482e:	0e 94 5c 32 	call	0x64b8	; 0x64b8 <Endpoint_Write_Stream_LE>

	/* Pad out remaining bytes with 0x00 */
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
    4832:	60 e0       	ldi	r22, 0x00	; 0
    4834:	70 e0       	ldi	r23, 0x00	; 0
    4836:	c7 01       	movw	r24, r14
    4838:	8c 19       	sub	r24, r12
    483a:	9d 09       	sbc	r25, r13
    483c:	0e 94 1d 32 	call	0x643a	; 0x643a <Endpoint_Null_Stream>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4840:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    4844:	8e 77       	andi	r24, 0x7E	; 126
    4846:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

	/* Finalize the stream transfer to send the last packet */
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
    484a:	f8 01       	movw	r30, r16
    484c:	84 89       	ldd	r24, Z+20	; 0x14
    484e:	95 89       	ldd	r25, Z+21	; 0x15
    4850:	a6 89       	ldd	r26, Z+22	; 0x16
    4852:	b7 89       	ldd	r27, Z+23	; 0x17
    4854:	8c 19       	sub	r24, r12
    4856:	9d 09       	sbc	r25, r13
    4858:	a1 09       	sbc	r26, r1
    485a:	b1 09       	sbc	r27, r1
    485c:	a9 c0       	rjmp	.+338    	; 0x49b0 <SCSI_DecodeSCSICommand+0x232>
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint8_t  AllocationLength = MSInterfaceInfo->State.CommandBlock.SCSICommandData[4];
    485e:	f8 01       	movw	r30, r16
    4860:	f7 8c       	ldd	r15, Z+31	; 0x1f
	uint8_t  BytesTransferred = MIN(AllocationLength, sizeof(SenseData));
    4862:	ef 2c       	mov	r14, r15
    4864:	f2 e1       	ldi	r31, 0x12	; 18
    4866:	ff 15       	cp	r31, r15
    4868:	10 f4       	brcc	.+4      	; 0x486e <SCSI_DecodeSCSICommand+0xf0>
    486a:	82 e1       	ldi	r24, 0x12	; 18
    486c:	e8 2e       	mov	r14, r24

	Endpoint_Write_Stream_LE(&SenseData, BytesTransferred, NULL);
    486e:	ce 2c       	mov	r12, r14
    4870:	d1 2c       	mov	r13, r1
    4872:	40 e0       	ldi	r20, 0x00	; 0
    4874:	50 e0       	ldi	r21, 0x00	; 0
    4876:	b6 01       	movw	r22, r12
    4878:	8e e0       	ldi	r24, 0x0E	; 14
    487a:	91 e0       	ldi	r25, 0x01	; 1
    487c:	0e 94 5c 32 	call	0x64b8	; 0x64b8 <Endpoint_Write_Stream_LE>
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
    4880:	8f 2d       	mov	r24, r15
    4882:	90 e0       	ldi	r25, 0x00	; 0
    4884:	60 e0       	ldi	r22, 0x00	; 0
    4886:	70 e0       	ldi	r23, 0x00	; 0
    4888:	8c 19       	sub	r24, r12
    488a:	9d 09       	sbc	r25, r13
    488c:	0e 94 1d 32 	call	0x643a	; 0x643a <Endpoint_Null_Stream>
    4890:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    4894:	8e 77       	andi	r24, 0x7E	; 126
    4896:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
    489a:	f8 01       	movw	r30, r16
    489c:	84 89       	ldd	r24, Z+20	; 0x14
    489e:	95 89       	ldd	r25, Z+21	; 0x15
    48a0:	a6 89       	ldd	r26, Z+22	; 0x16
    48a2:	b7 89       	ldd	r27, Z+23	; 0x17
    48a4:	8e 19       	sub	r24, r14
    48a6:	91 09       	sbc	r25, r1
    48a8:	a1 09       	sbc	r26, r1
    48aa:	b1 09       	sbc	r27, r1
    48ac:	81 c0       	rjmp	.+258    	; 0x49b0 <SCSI_DecodeSCSICommand+0x232>
			break;
		case SCSI_CMD_REQUEST_SENSE:
			CommandSuccess = SCSI_Command_Request_Sense(MSInterfaceInfo);
			break;
		case SCSI_CMD_READ_CAPACITY_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    48ae:	14 d2       	rcall	.+1064   	; 0x4cd8 <SDCardManager_CheckSDCardOperation>
    48b0:	81 11       	cpse	r24, r1
    48b2:	08 c0       	rjmp	.+16     	; 0x48c4 <SCSI_DecodeSCSICommand+0x146>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
    48b4:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <SenseData+0x2>
    48b8:	80 7f       	andi	r24, 0xF0	; 240
    48ba:	82 60       	ori	r24, 0x02	; 2
    48bc:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <SenseData+0x2>
    48c0:	8a e3       	ldi	r24, 0x3A	; 58
    48c2:	91 c0       	rjmp	.+290    	; 0x49e6 <SCSI_DecodeSCSICommand+0x268>
			break;
		case SCSI_CMD_REQUEST_SENSE:
			CommandSuccess = SCSI_Command_Request_Sense(MSInterfaceInfo);
			break;
		case SCSI_CMD_READ_CAPACITY_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    48c4:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <Typewriter_Mode>
    48c8:	81 30       	cpi	r24, 0x01	; 1
    48ca:	a1 f7       	brne	.-24     	; 0x48b4 <SCSI_DecodeSCSICommand+0x136>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Read_Capacity_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint32_t LastBlockAddressInLUN;
	uint32_t MediaBlockSize        = VIRTUAL_MEMORY_BLOCK_SIZE;
    48cc:	80 e0       	ldi	r24, 0x00	; 0
    48ce:	92 e0       	ldi	r25, 0x02	; 2
    48d0:	a0 e0       	ldi	r26, 0x00	; 0
    48d2:	b0 e0       	ldi	r27, 0x00	; 0
    48d4:	89 83       	std	Y+1, r24	; 0x01
    48d6:	9a 83       	std	Y+2, r25	; 0x02
    48d8:	ab 83       	std	Y+3, r26	; 0x03
    48da:	bc 83       	std	Y+4, r27	; 0x04

	LastBlockAddressInLUN = get_num_of_sectors()-1;
    48dc:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <get_num_of_sectors>
    48e0:	dc 01       	movw	r26, r24
    48e2:	cb 01       	movw	r24, r22
    48e4:	01 97       	sbiw	r24, 0x01	; 1
    48e6:	a1 09       	sbc	r26, r1
    48e8:	b1 09       	sbc	r27, r1
    48ea:	8d 83       	std	Y+5, r24	; 0x05
    48ec:	9e 83       	std	Y+6, r25	; 0x06
    48ee:	af 83       	std	Y+7, r26	; 0x07
    48f0:	b8 87       	std	Y+8, r27	; 0x08

	Endpoint_Write_Stream_BE(&LastBlockAddressInLUN, sizeof(LastBlockAddressInLUN), NULL);
    48f2:	40 e0       	ldi	r20, 0x00	; 0
    48f4:	50 e0       	ldi	r21, 0x00	; 0
    48f6:	64 e0       	ldi	r22, 0x04	; 4
    48f8:	70 e0       	ldi	r23, 0x00	; 0
    48fa:	ce 01       	movw	r24, r28
    48fc:	05 96       	adiw	r24, 0x05	; 5
    48fe:	0e 94 a6 32 	call	0x654c	; 0x654c <Endpoint_Write_Stream_BE>
	Endpoint_Write_Stream_BE(&MediaBlockSize, sizeof(MediaBlockSize), NULL);
    4902:	40 e0       	ldi	r20, 0x00	; 0
    4904:	50 e0       	ldi	r21, 0x00	; 0
    4906:	64 e0       	ldi	r22, 0x04	; 4
    4908:	70 e0       	ldi	r23, 0x00	; 0
    490a:	ce 01       	movw	r24, r28
    490c:	01 96       	adiw	r24, 0x01	; 1
    490e:	0e 94 a6 32 	call	0x654c	; 0x654c <Endpoint_Write_Stream_BE>
    4912:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    4916:	8e 77       	andi	r24, 0x7E	; 126
    4918:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 8;
    491c:	f8 01       	movw	r30, r16
    491e:	84 89       	ldd	r24, Z+20	; 0x14
    4920:	95 89       	ldd	r25, Z+21	; 0x15
    4922:	a6 89       	ldd	r26, Z+22	; 0x16
    4924:	b7 89       	ldd	r27, Z+23	; 0x17
    4926:	08 97       	sbiw	r24, 0x08	; 8
    4928:	a1 09       	sbc	r26, r1
    492a:	b1 09       	sbc	r27, r1
    492c:	41 c0       	rjmp	.+130    	; 0x49b0 <SCSI_DecodeSCSICommand+0x232>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Send_Diagnostic(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	/* Check to see if the SELF TEST bit is not set */
	if (!(MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & (1 << 2)))
    492e:	f8 01       	movw	r30, r16
    4930:	84 8d       	ldd	r24, Z+28	; 0x1c
    4932:	82 ff       	sbrs	r24, 2

		return false;
	}

	/* Check to see if all attached Dataflash ICs are functional */
	if (!(SDCardManager_CheckSDCardOperation()))
    4934:	67 cf       	rjmp	.-306    	; 0x4804 <SCSI_DecodeSCSICommand+0x86>
    4936:	d0 d1       	rcall	.+928    	; 0x4cd8 <SDCardManager_CheckSDCardOperation>
    4938:	81 11       	cpse	r24, r1
    493a:	48 c0       	rjmp	.+144    	; 0x49cc <SCSI_DecodeSCSICommand+0x24e>
	{
		/* Update SENSE key with a hardware error condition and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_HARDWARE_ERROR,
    493c:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <SenseData+0x2>
    4940:	80 7f       	andi	r24, 0xF0	; 240
    4942:	84 60       	ori	r24, 0x04	; 4
    4944:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <SenseData+0x2>
    4948:	10 92 1a 01 	sts	0x011A, r1	; 0x80011a <SenseData+0xc>
    494c:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <SenseData+0xd>
			break;
		case SCSI_CMD_SEND_DIAGNOSTIC:
			CommandSuccess = SCSI_Command_Send_Diagnostic(MSInterfaceInfo);
			break;
		case SCSI_CMD_WRITE_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    4950:	58 c0       	rjmp	.+176    	; 0x4a02 <SCSI_DecodeSCSICommand+0x284>
    4952:	c2 d1       	rcall	.+900    	; 0x4cd8 <SDCardManager_CheckSDCardOperation>
    4954:	88 23       	and	r24, r24
    4956:	09 f4       	brne	.+2      	; 0x495a <SCSI_DecodeSCSICommand+0x1dc>
    4958:	ad cf       	rjmp	.-166    	; 0x48b4 <SCSI_DecodeSCSICommand+0x136>
    495a:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <Typewriter_Mode>
    495e:	81 30       	cpi	r24, 0x01	; 1
    4960:	09 f0       	breq	.+2      	; 0x4964 <SCSI_DecodeSCSICommand+0x1e6>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
				return false; //return with an error flag -- send a failure response to host.
			}
			
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_WRITE);
    4962:	a8 cf       	rjmp	.-176    	; 0x48b4 <SCSI_DecodeSCSICommand+0x136>
    4964:	60 e0       	ldi	r22, 0x00	; 0
			break;
		case SCSI_CMD_READ_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    4966:	0a c0       	rjmp	.+20     	; 0x497c <SCSI_DecodeSCSICommand+0x1fe>
    4968:	b7 d1       	rcall	.+878    	; 0x4cd8 <SDCardManager_CheckSDCardOperation>
    496a:	88 23       	and	r24, r24
    496c:	09 f4       	brne	.+2      	; 0x4970 <SCSI_DecodeSCSICommand+0x1f2>
    496e:	a2 cf       	rjmp	.-188    	; 0x48b4 <SCSI_DecodeSCSICommand+0x136>
    4970:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <Typewriter_Mode>
    4974:	81 30       	cpi	r24, 0x01	; 1
    4976:	09 f0       	breq	.+2      	; 0x497a <SCSI_DecodeSCSICommand+0x1fc>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
				return false; //return with an error flag -- send a failure response to host.
			}
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
    4978:	9d cf       	rjmp	.-198    	; 0x48b4 <SCSI_DecodeSCSICommand+0x136>
    497a:	61 e0       	ldi	r22, 0x01	; 1
    497c:	c8 01       	movw	r24, r16
    497e:	ae de       	rcall	.-676    	; 0x46dc <SCSI_Command_ReadWrite_10>
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
    4980:	81 11       	cpse	r24, r1
    4982:	34 c0       	rjmp	.+104    	; 0x49ec <SCSI_DecodeSCSICommand+0x26e>
    4984:	3e c0       	rjmp	.+124    	; 0x4a02 <SCSI_DecodeSCSICommand+0x284>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4986:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    498a:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    498e:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    4992:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4996:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    499a:	8e 77       	andi	r24, 0x7E	; 126
    499c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
	Endpoint_Write_8(DISK_READ_ONLY ? 0x80 : 0x00);
	Endpoint_Write_8(0x00);
	Endpoint_ClearIN();

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 4;
    49a0:	f8 01       	movw	r30, r16
    49a2:	84 89       	ldd	r24, Z+20	; 0x14
    49a4:	95 89       	ldd	r25, Z+21	; 0x15
    49a6:	a6 89       	ldd	r26, Z+22	; 0x16
    49a8:	b7 89       	ldd	r27, Z+23	; 0x17
    49aa:	04 97       	sbiw	r24, 0x04	; 4
    49ac:	a1 09       	sbc	r26, r1
    49ae:	b1 09       	sbc	r27, r1
    49b0:	84 8b       	std	Z+20, r24	; 0x14
    49b2:	95 8b       	std	Z+21, r25	; 0x15
    49b4:	a6 8b       	std	Z+22, r26	; 0x16
			}
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
			break;
		case SCSI_CMD_MODE_SENSE_6:
			CommandSuccess = SCSI_Command_ModeSense_6(MSInterfaceInfo);
			break;
    49b6:	b7 8b       	std	Z+23, r27	; 0x17
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
			break;
		case SCSI_CMD_TEST_UNIT_READY:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    49b8:	19 c0       	rjmp	.+50     	; 0x49ec <SCSI_DecodeSCSICommand+0x26e>
    49ba:	8e d1       	rcall	.+796    	; 0x4cd8 <SDCardManager_CheckSDCardOperation>
    49bc:	88 23       	and	r24, r24
    49be:	09 f4       	brne	.+2      	; 0x49c2 <SCSI_DecodeSCSICommand+0x244>
    49c0:	79 cf       	rjmp	.-270    	; 0x48b4 <SCSI_DecodeSCSICommand+0x136>
    49c2:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <Typewriter_Mode>
    49c6:	81 30       	cpi	r24, 0x01	; 1
    49c8:	09 f0       	breq	.+2      	; 0x49cc <SCSI_DecodeSCSICommand+0x24e>
    49ca:	74 cf       	rjmp	.-280    	; 0x48b4 <SCSI_DecodeSCSICommand+0x136>
		case SCSI_CMD_START_STOP_UNIT:
		case SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
		case SCSI_CMD_VERIFY_10:
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
    49cc:	f8 01       	movw	r30, r16
    49ce:	14 8a       	std	Z+20, r1	; 0x14
    49d0:	15 8a       	std	Z+21, r1	; 0x15
    49d2:	16 8a       	std	Z+22, r1	; 0x16
    49d4:	17 8a       	std	Z+23, r1	; 0x17
			break;
    49d6:	0a c0       	rjmp	.+20     	; 0x49ec <SCSI_DecodeSCSICommand+0x26e>
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
			break;
		default:
			/* Update the SENSE key to reflect the invalid command */
			SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    49d8:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <SenseData+0x2>
    49dc:	80 7f       	andi	r24, 0xF0	; 240
    49de:	85 60       	ori	r24, 0x05	; 5
    49e0:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <SenseData+0x2>
    49e4:	80 e2       	ldi	r24, 0x20	; 32
    49e6:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <SenseData+0xc>
    49ea:	b0 cf       	rjmp	.-160    	; 0x494c <SCSI_DecodeSCSICommand+0x1ce>
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
	{
		SCSI_SET_SENSE(SCSI_SENSE_KEY_GOOD,
    49ec:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <SenseData+0x2>
    49f0:	80 7f       	andi	r24, 0xF0	; 240
    49f2:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <SenseData+0x2>
    49f6:	10 92 1a 01 	sts	0x011A, r1	; 0x80011a <SenseData+0xc>
    49fa:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <SenseData+0xd>
		               SCSI_ASENSE_NO_ADDITIONAL_INFORMATION,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return true;
    49fe:	81 e0       	ldi	r24, 0x01	; 1
    4a00:	01 c0       	rjmp	.+2      	; 0x4a04 <SCSI_DecodeSCSICommand+0x286>
	}

	return false;
    4a02:	80 e0       	ldi	r24, 0x00	; 0
}
    4a04:	28 96       	adiw	r28, 0x08	; 8
    4a06:	0f b6       	in	r0, 0x3f	; 63
    4a08:	f8 94       	cli
    4a0a:	de bf       	out	0x3e, r29	; 62
    4a0c:	0f be       	out	0x3f, r0	; 63
    4a0e:	cd bf       	out	0x3d, r28	; 61
    4a10:	df 91       	pop	r29
    4a12:	cf 91       	pop	r28
    4a14:	1f 91       	pop	r17
    4a16:	0f 91       	pop	r16
    4a18:	ff 90       	pop	r15
    4a1a:	ef 90       	pop	r14
    4a1c:	df 90       	pop	r13
    4a1e:	cf 90       	pop	r12
    4a20:	08 95       	ret

00004a22 <SDCardManager_Init>:
static bool SDCard_Present= false;

void SDCardManager_Init(void)
{

	if(disk_initialize(0)==FR_OK){ //if the disk initializes correctly
    4a22:	80 e0       	ldi	r24, 0x00	; 0
    4a24:	0e 94 92 11 	call	0x2324	; 0x2324 <disk_initialize>
    4a28:	81 11       	cpse	r24, r1
    4a2a:	04 c0       	rjmp	.+8      	; 0x4a34 <SDCardManager_Init+0x12>
		SDCard_Present = true;
    4a2c:	81 e0       	ldi	r24, 0x01	; 1
    4a2e:	80 93 3a 05 	sts	0x053A, r24	; 0x80053a <SDCard_Present>
    4a32:	08 95       	ret
	}
	else{
		SDCard_Present = false; //tell other functions that the SD Card is missing/malfunctioned
    4a34:	10 92 3a 05 	sts	0x053A, r1	; 0x80053a <SDCard_Present>
    4a38:	08 95       	ret

00004a3a <SDCardManager_WriteBlockHandler>:
	}
}


uintptr_t SDCardManager_WriteBlockHandler(uint8_t* buffer, uint16_t offset)
{
    4a3a:	0f 93       	push	r16
    4a3c:	1f 93       	push	r17
    4a3e:	cf 93       	push	r28
    4a40:	df 93       	push	r29
    4a42:	8c 01       	movw	r16, r24
    4a44:	eb 01       	movw	r28, r22
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4a46:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

	/* Check if the endpoint is currently empty */
	if (!(Endpoint_IsReadWriteAllowed()))
    4a4a:	85 ff       	sbrs	r24, 5
    4a4c:	36 c0       	rjmp	.+108    	; 0x4aba <SDCardManager_WriteBlockHandler+0x80>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    4a4e:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
		if (Endpoint_WaitUntilReady())
		  return 0;
	}
	
	/* Write one 16-byte chunk of data to the dataflash */
	buffer[0+offset] = Endpoint_Read_8();
    4a52:	f8 01       	movw	r30, r16
    4a54:	ec 0f       	add	r30, r28
    4a56:	fd 1f       	adc	r31, r29
    4a58:	80 83       	st	Z, r24
    4a5a:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[1+offset] = Endpoint_Read_8();
    4a5e:	81 83       	std	Z+1, r24	; 0x01
    4a60:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[2+offset] = Endpoint_Read_8();
    4a64:	82 83       	std	Z+2, r24	; 0x02
    4a66:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[3+offset] = Endpoint_Read_8();
    4a6a:	83 83       	std	Z+3, r24	; 0x03
    4a6c:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[4+offset] = Endpoint_Read_8();
    4a70:	84 83       	std	Z+4, r24	; 0x04
    4a72:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[5+offset] = Endpoint_Read_8();
    4a76:	85 83       	std	Z+5, r24	; 0x05
    4a78:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[6+offset] = Endpoint_Read_8();
    4a7c:	86 83       	std	Z+6, r24	; 0x06
    4a7e:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[7+offset] = Endpoint_Read_8();
    4a82:	87 83       	std	Z+7, r24	; 0x07
    4a84:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[8+offset] = Endpoint_Read_8();
    4a88:	80 87       	std	Z+8, r24	; 0x08
    4a8a:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[9+offset] = Endpoint_Read_8();
    4a8e:	81 87       	std	Z+9, r24	; 0x09
    4a90:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[10+offset] = Endpoint_Read_8();
    4a94:	82 87       	std	Z+10, r24	; 0x0a
    4a96:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[11+offset] = Endpoint_Read_8();
    4a9a:	83 87       	std	Z+11, r24	; 0x0b
    4a9c:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[12+offset] = Endpoint_Read_8();
    4aa0:	84 87       	std	Z+12, r24	; 0x0c
    4aa2:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[13+offset] = Endpoint_Read_8();
    4aa6:	85 87       	std	Z+13, r24	; 0x0d
    4aa8:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[14+offset] = Endpoint_Read_8();
    4aac:	86 87       	std	Z+14, r24	; 0x0e
    4aae:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	buffer[15+offset] = Endpoint_Read_8();
    4ab2:	87 87       	std	Z+15, r24	; 0x0f
	
	return 16;
    4ab4:	80 e1       	ldi	r24, 0x10	; 16
    4ab6:	90 e0       	ldi	r25, 0x00	; 0
    4ab8:	0b c0       	rjmp	.+22     	; 0x4ad0 <SDCardManager_WriteBlockHandler+0x96>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4aba:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    4abe:	8b 77       	andi	r24, 0x7B	; 123
    4ac0:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
	{
		/* Clear the current endpoint bank */
		Endpoint_ClearOUT();
		
		/* Wait until the host has sent another packet */
		if (Endpoint_WaitUntilReady())
    4ac4:	0e 94 cf 34 	call	0x699e	; 0x699e <Endpoint_WaitUntilReady>
    4ac8:	88 23       	and	r24, r24
    4aca:	09 f2       	breq	.-126    	; 0x4a4e <SDCardManager_WriteBlockHandler+0x14>
		  return 0;
    4acc:	80 e0       	ldi	r24, 0x00	; 0
    4ace:	90 e0       	ldi	r25, 0x00	; 0
	buffer[13+offset] = Endpoint_Read_8();
	buffer[14+offset] = Endpoint_Read_8();
	buffer[15+offset] = Endpoint_Read_8();
	
	return 16;
}
    4ad0:	df 91       	pop	r29
    4ad2:	cf 91       	pop	r28
    4ad4:	1f 91       	pop	r17
    4ad6:	0f 91       	pop	r16
    4ad8:	08 95       	ret

00004ada <SDCardManager_WriteBlocks>:
 *
 *  \param[in] BlockAddress  Data block starting address for the write sequence
 *  \param[in] TotalBlocks   Number of blocks of data to write
 */
void SDCardManager_WriteBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo, uint32_t BlockAddress, uint16_t TotalBlocks)
{
    4ada:	8f 92       	push	r8
    4adc:	9f 92       	push	r9
    4ade:	af 92       	push	r10
    4ae0:	bf 92       	push	r11
    4ae2:	cf 92       	push	r12
    4ae4:	df 92       	push	r13
    4ae6:	ef 92       	push	r14
    4ae8:	ff 92       	push	r15
    4aea:	0f 93       	push	r16
    4aec:	1f 93       	push	r17
    4aee:	cf 93       	push	r28
    4af0:	df 93       	push	r29
    4af2:	6c 01       	movw	r12, r24
    4af4:	4a 01       	movw	r8, r20
    4af6:	5b 01       	movw	r10, r22
    4af8:	79 01       	movw	r14, r18
	uint16_t  BytesWritten;

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
    4afa:	0e 94 cf 34 	call	0x699e	; 0x699e <Endpoint_WaitUntilReady>
    4afe:	81 11       	cpse	r24, r1
    4b00:	33 c0       	rjmp	.+102    	; 0x4b68 <SDCardManager_WriteBlocks+0x8e>
	  return;
	
	while (TotalBlocks)
    4b02:	e1 14       	cp	r14, r1
    4b04:	f1 04       	cpc	r15, r1
    4b06:	31 f1       	breq	.+76     	; 0x4b54 <SDCardManager_WriteBlocks+0x7a>
	{
		set_low(RED_LED); //red LED indicates busy status
    4b08:	2e 98       	cbi	0x05, 6	; 5
		
		//Reset BytesWritten every time you finish writing a block, Dummy!
		BytesWritten = 0;
    4b0a:	c0 e0       	ldi	r28, 0x00	; 0
    4b0c:	d0 e0       	ldi	r29, 0x00	; 0
		
		while((BytesWritten<512)){
			BytesWritten += SDCardManager_WriteBlockHandler((uint8_t*)SD_Buffer, BytesWritten);
    4b0e:	be 01       	movw	r22, r28
    4b10:	8a e6       	ldi	r24, 0x6A	; 106
    4b12:	97 e0       	ldi	r25, 0x07	; 7
    4b14:	92 df       	rcall	.-220    	; 0x4a3a <SDCardManager_WriteBlockHandler>
    4b16:	c8 0f       	add	r28, r24
    4b18:	d9 1f       	adc	r29, r25
			if (USB_DeviceState != DEVICE_STATE_Configured){return;}//if the device is not configured, exit out of this
    4b1a:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    4b1e:	84 30       	cpi	r24, 0x04	; 4
    4b20:	19 f5       	brne	.+70     	; 0x4b68 <SDCardManager_WriteBlocks+0x8e>
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
    4b22:	f6 01       	movw	r30, r12
    4b24:	80 ad       	ldd	r24, Z+56	; 0x38
    4b26:	81 11       	cpse	r24, r1
    4b28:	1f c0       	rjmp	.+62     	; 0x4b68 <SDCardManager_WriteBlocks+0x8e>
		set_low(RED_LED); //red LED indicates busy status
		
		//Reset BytesWritten every time you finish writing a block, Dummy!
		BytesWritten = 0;
		
		while((BytesWritten<512)){
    4b2a:	c1 15       	cp	r28, r1
    4b2c:	f2 e0       	ldi	r31, 0x02	; 2
    4b2e:	df 07       	cpc	r29, r31
    4b30:	70 f3       	brcs	.-36     	; 0x4b0e <SDCardManager_WriteBlocks+0x34>
			BytesWritten += SDCardManager_WriteBlockHandler((uint8_t*)SD_Buffer, BytesWritten);
			if (USB_DeviceState != DEVICE_STATE_Configured){return;}//if the device is not configured, exit out of this
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
		}
		
		disk_write (0, (uint8_t*)SD_Buffer, BlockAddress, 1);//write to disk 0, from Buffer array, into BlockAddress, Write only 1 sector (block);
    4b32:	01 e0       	ldi	r16, 0x01	; 1
    4b34:	10 e0       	ldi	r17, 0x00	; 0
    4b36:	a5 01       	movw	r20, r10
    4b38:	94 01       	movw	r18, r8
    4b3a:	6a e6       	ldi	r22, 0x6A	; 106
    4b3c:	77 e0       	ldi	r23, 0x07	; 7
    4b3e:	0e 94 72 12 	call	0x24e4	; 0x24e4 <disk_write>
	
		/* Decrement the blocks remaining counter and reset the sub block counter */
		BlockAddress++;
    4b42:	8f ef       	ldi	r24, 0xFF	; 255
    4b44:	88 1a       	sub	r8, r24
    4b46:	98 0a       	sbc	r9, r24
    4b48:	a8 0a       	sbc	r10, r24
    4b4a:	b8 0a       	sbc	r11, r24
		TotalBlocks--;			
    4b4c:	e1 e0       	ldi	r30, 0x01	; 1
    4b4e:	ee 1a       	sub	r14, r30
    4b50:	f1 08       	sbc	r15, r1
    4b52:	d7 cf       	rjmp	.-82     	; 0x4b02 <SDCardManager_WriteBlocks+0x28>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4b54:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
		
	}

	/* If the endpoint is empty, clear it ready for the next packet from the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    4b58:	85 fd       	sbrc	r24, 5
    4b5a:	05 c0       	rjmp	.+10     	; 0x4b66 <SDCardManager_WriteBlocks+0x8c>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4b5c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    4b60:	8b 77       	andi	r24, 0x7B	; 123
    4b62:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
	  Endpoint_ClearOUT();
	  
	  set_high(RED_LED);
    4b66:	2e 9a       	sbi	0x05, 6	; 5
}
    4b68:	df 91       	pop	r29
    4b6a:	cf 91       	pop	r28
    4b6c:	1f 91       	pop	r17
    4b6e:	0f 91       	pop	r16
    4b70:	ff 90       	pop	r15
    4b72:	ef 90       	pop	r14
    4b74:	df 90       	pop	r13
    4b76:	cf 90       	pop	r12
    4b78:	bf 90       	pop	r11
    4b7a:	af 90       	pop	r10
    4b7c:	9f 90       	pop	r9
    4b7e:	8f 90       	pop	r8
    4b80:	08 95       	ret

00004b82 <SDCardManager_ReadBlockHandler>:
 *  \param[in] BlockAddress  Data block starting address for the read sequence
 *  \param[in] TotalBlocks   Number of blocks of data to read
 *  \output -- number of bytes forwarded successfully.  Return 16 if they are forwarded successfully, 0 if host rejects them.
 */
uint8_t SDCardManager_ReadBlockHandler(uint8_t* buffer, uint16_t offset)
{
    4b82:	ef 92       	push	r14
    4b84:	ff 92       	push	r15
    4b86:	1f 93       	push	r17
    4b88:	cf 93       	push	r28
    4b8a:	df 93       	push	r29
    4b8c:	7c 01       	movw	r14, r24
    4b8e:	eb 01       	movw	r28, r22
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4b90:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

	/* Check if the endpoint is currently full */
	if (!(Endpoint_IsReadWriteAllowed()))
    4b94:	18 2f       	mov	r17, r24
    4b96:	10 72       	andi	r17, 0x20	; 32
    4b98:	85 ff       	sbrs	r24, 5
    4b9a:	35 c0       	rjmp	.+106    	; 0x4c06 <SDCardManager_ReadBlockHandler+0x84>
		/* Wait until the endpoint is ready for more data */
		if (Endpoint_WaitUntilReady())
		return 0;
	}
	
	Endpoint_Write_8(buffer[0+offset]);
    4b9c:	f7 01       	movw	r30, r14
    4b9e:	ec 0f       	add	r30, r28
    4ba0:	fd 1f       	adc	r31, r29
    4ba2:	80 81       	ld	r24, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4ba4:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[1+offset]);
    4ba8:	81 81       	ldd	r24, Z+1	; 0x01
    4baa:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[2+offset]);
    4bae:	82 81       	ldd	r24, Z+2	; 0x02
    4bb0:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[3+offset]);
    4bb4:	83 81       	ldd	r24, Z+3	; 0x03
    4bb6:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[4+offset]);
    4bba:	84 81       	ldd	r24, Z+4	; 0x04
    4bbc:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[5+offset]);
    4bc0:	85 81       	ldd	r24, Z+5	; 0x05
    4bc2:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[6+offset]);
    4bc6:	86 81       	ldd	r24, Z+6	; 0x06
    4bc8:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[7+offset]);
    4bcc:	87 81       	ldd	r24, Z+7	; 0x07
    4bce:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[8+offset]);
    4bd2:	80 85       	ldd	r24, Z+8	; 0x08
    4bd4:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[9+offset]);
    4bd8:	81 85       	ldd	r24, Z+9	; 0x09
    4bda:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[10+offset]);
    4bde:	82 85       	ldd	r24, Z+10	; 0x0a
    4be0:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[11+offset]);
    4be4:	83 85       	ldd	r24, Z+11	; 0x0b
    4be6:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[12+offset]);
    4bea:	84 85       	ldd	r24, Z+12	; 0x0c
    4bec:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[13+offset]);
    4bf0:	85 85       	ldd	r24, Z+13	; 0x0d
    4bf2:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[14+offset]);
    4bf6:	86 85       	ldd	r24, Z+14	; 0x0e
    4bf8:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	Endpoint_Write_8(buffer[15+offset]);
    4bfc:	87 85       	ldd	r24, Z+15	; 0x0f
    4bfe:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
	
	return 16;
    4c02:	10 e1       	ldi	r17, 0x10	; 16
    4c04:	09 c0       	rjmp	.+18     	; 0x4c18 <SDCardManager_ReadBlockHandler+0x96>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4c06:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    4c0a:	8e 77       	andi	r24, 0x7E	; 126
    4c0c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
	{
		/* Clear the endpoint bank to send its contents to the host */
		Endpoint_ClearIN();
		
		/* Wait until the endpoint is ready for more data */
		if (Endpoint_WaitUntilReady())
    4c10:	0e 94 cf 34 	call	0x699e	; 0x699e <Endpoint_WaitUntilReady>
    4c14:	88 23       	and	r24, r24
    4c16:	11 f2       	breq	.-124    	; 0x4b9c <SDCardManager_ReadBlockHandler+0x1a>
	Endpoint_Write_8(buffer[13+offset]);
	Endpoint_Write_8(buffer[14+offset]);
	Endpoint_Write_8(buffer[15+offset]);
	
	return 16;
}
    4c18:	81 2f       	mov	r24, r17
    4c1a:	df 91       	pop	r29
    4c1c:	cf 91       	pop	r28
    4c1e:	1f 91       	pop	r17
    4c20:	ff 90       	pop	r15
    4c22:	ef 90       	pop	r14
    4c24:	08 95       	ret

00004c26 <SDCardManager_ReadBlocks>:
 *
 *  \param[in] BlockAddress  Data block starting address for the read sequence
 *  \param[in] TotalBlocks   Number of blocks of data to read
 */
void SDCardManager_ReadBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo, uint32_t BlockAddress, uint16_t TotalBlocks)
{
    4c26:	8f 92       	push	r8
    4c28:	9f 92       	push	r9
    4c2a:	af 92       	push	r10
    4c2c:	bf 92       	push	r11
    4c2e:	cf 92       	push	r12
    4c30:	df 92       	push	r13
    4c32:	ef 92       	push	r14
    4c34:	ff 92       	push	r15
    4c36:	0f 93       	push	r16
    4c38:	1f 93       	push	r17
    4c3a:	cf 93       	push	r28
    4c3c:	df 93       	push	r29
    4c3e:	6c 01       	movw	r12, r24
    4c40:	4a 01       	movw	r8, r20
    4c42:	5b 01       	movw	r10, r22
    4c44:	79 01       	movw	r14, r18
	uint16_t BytesRead;
	
	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
    4c46:	0e 94 cf 34 	call	0x699e	; 0x699e <Endpoint_WaitUntilReady>
    4c4a:	81 11       	cpse	r24, r1
    4c4c:	38 c0       	rjmp	.+112    	; 0x4cbe <SDCardManager_ReadBlocks+0x98>
	  return;
	
	while (TotalBlocks)
    4c4e:	e1 14       	cp	r14, r1
    4c50:	f1 04       	cpc	r15, r1
    4c52:	59 f1       	breq	.+86     	; 0x4caa <SDCardManager_ReadBlocks+0x84>
	{		
		set_low(RED_LED); //red LED indicates busy status
    4c54:	2e 98       	cbi	0x05, 6	; 5
		//Reset tally of BytesRead every time a new block is accessed.  
		BytesRead = 0;
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)
    4c56:	01 e0       	ldi	r16, 0x01	; 1
    4c58:	10 e0       	ldi	r17, 0x00	; 0
    4c5a:	a5 01       	movw	r20, r10
    4c5c:	94 01       	movw	r18, r8
    4c5e:	6a e6       	ldi	r22, 0x6A	; 106
    4c60:	77 e0       	ldi	r23, 0x07	; 7
    4c62:	80 e0       	ldi	r24, 0x00	; 0
    4c64:	0e 94 2e 12 	call	0x245c	; 0x245c <disk_read>
	
	while (TotalBlocks)
	{		
		set_low(RED_LED); //red LED indicates busy status
		//Reset tally of BytesRead every time a new block is accessed.  
		BytesRead = 0;
    4c68:	c0 e0       	ldi	r28, 0x00	; 0
    4c6a:	d0 e0       	ldi	r29, 0x00	; 0
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)

		while(BytesRead<512){  //send the results to the usb endpoint buffer, 16 bytes at a time.
			BytesRead += SDCardManager_ReadBlockHandler((uint8_t*)SD_Buffer, BytesRead); // BytesRead increases 16 every time handler is called, if all goes well.
    4c6c:	be 01       	movw	r22, r28
    4c6e:	8a e6       	ldi	r24, 0x6A	; 106
    4c70:	97 e0       	ldi	r25, 0x07	; 7
    4c72:	87 df       	rcall	.-242    	; 0x4b82 <SDCardManager_ReadBlockHandler>
    4c74:	c8 0f       	add	r28, r24
    4c76:	d1 1d       	adc	r29, r1
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
    4c78:	f6 01       	movw	r30, r12
    4c7a:	80 ad       	ldd	r24, Z+56	; 0x38
    4c7c:	81 11       	cpse	r24, r1
    4c7e:	1f c0       	rjmp	.+62     	; 0x4cbe <SDCardManager_ReadBlocks+0x98>
			if (USB_DeviceState != DEVICE_STATE_Configured){Typewriter_Mode = PANIC_MODE; return;}
    4c80:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    4c84:	84 30       	cpi	r24, 0x04	; 4
    4c86:	21 f0       	breq	.+8      	; 0x4c90 <SDCardManager_ReadBlocks+0x6a>
    4c88:	8a e0       	ldi	r24, 0x0A	; 10
    4c8a:	80 93 69 07 	sts	0x0769, r24	; 0x800769 <Typewriter_Mode>
    4c8e:	17 c0       	rjmp	.+46     	; 0x4cbe <SDCardManager_ReadBlocks+0x98>
		BytesRead = 0;
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)

		while(BytesRead<512){  //send the results to the usb endpoint buffer, 16 bytes at a time.
    4c90:	c1 15       	cp	r28, r1
    4c92:	f2 e0       	ldi	r31, 0x02	; 2
    4c94:	df 07       	cpc	r29, r31
    4c96:	50 f3       	brcs	.-44     	; 0x4c6c <SDCardManager_ReadBlocks+0x46>
			BytesRead += SDCardManager_ReadBlockHandler((uint8_t*)SD_Buffer, BytesRead); // BytesRead increases 16 every time handler is called, if all goes well.
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
			if (USB_DeviceState != DEVICE_STATE_Configured){Typewriter_Mode = PANIC_MODE; return;}
		}
		/* Decrement the blocks remaining counter */
		BlockAddress++;
    4c98:	8f ef       	ldi	r24, 0xFF	; 255
    4c9a:	88 1a       	sub	r8, r24
    4c9c:	98 0a       	sbc	r9, r24
    4c9e:	a8 0a       	sbc	r10, r24
    4ca0:	b8 0a       	sbc	r11, r24
		TotalBlocks--;
    4ca2:	e1 e0       	ldi	r30, 0x01	; 1
    4ca4:	ee 1a       	sub	r14, r30
    4ca6:	f1 08       	sbc	r15, r1
    4ca8:	d2 cf       	rjmp	.-92     	; 0x4c4e <SDCardManager_ReadBlocks+0x28>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4caa:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
	}
	
	/* If the endpoint is full, send its contents to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    4cae:	85 fd       	sbrc	r24, 5
    4cb0:	05 c0       	rjmp	.+10     	; 0x4cbc <SDCardManager_ReadBlocks+0x96>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4cb2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    4cb6:	8e 77       	andi	r24, 0x7E	; 126
    4cb8:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
	  Endpoint_ClearIN();
	 
	 set_high(RED_LED);
    4cbc:	2e 9a       	sbi	0x05, 6	; 5
}
    4cbe:	df 91       	pop	r29
    4cc0:	cf 91       	pop	r28
    4cc2:	1f 91       	pop	r17
    4cc4:	0f 91       	pop	r16
    4cc6:	ff 90       	pop	r15
    4cc8:	ef 90       	pop	r14
    4cca:	df 90       	pop	r13
    4ccc:	cf 90       	pop	r12
    4cce:	bf 90       	pop	r11
    4cd0:	af 90       	pop	r10
    4cd2:	9f 90       	pop	r9
    4cd4:	8f 90       	pop	r8
    4cd6:	08 95       	ret

00004cd8 <SDCardManager_CheckSDCardOperation>:
 *  \return Boolean true if all media chips are working, false otherwise
 */
bool SDCardManager_CheckSDCardOperation(void)
{	
	return SDCard_Present; //return whether or not sd card is present and working.
}
    4cd8:	80 91 3a 05 	lds	r24, 0x053A	; 0x80053a <SDCard_Present>
    4cdc:	08 95       	ret

00004cde <__vector_25>:
    4cde:	1f 92       	push	r1
    4ce0:	0f 92       	push	r0
    4ce2:	0f b6       	in	r0, 0x3f	; 63
    4ce4:	0f 92       	push	r0
    4ce6:	11 24       	eor	r1, r1
    4ce8:	2f 93       	push	r18
    4cea:	8f 93       	push	r24
    4cec:	9f 93       	push	r25
    4cee:	ef 93       	push	r30
    4cf0:	ff 93       	push	r31
    4cf2:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__DATA_REGION_ORIGIN__+0x68>
    4cf6:	90 91 ce 00 	lds	r25, 0x00CE	; 0x8000ce <__DATA_REGION_ORIGIN__+0x6e>
    4cfa:	88 71       	andi	r24, 0x18	; 24
    4cfc:	e0 91 3d 05 	lds	r30, 0x053D	; 0x80053d <UART_RxHead>
    4d00:	ef 5f       	subi	r30, 0xFF	; 255
    4d02:	ef 73       	andi	r30, 0x3F	; 63
    4d04:	20 91 3c 05 	lds	r18, 0x053C	; 0x80053c <UART_RxTail>
    4d08:	e2 17       	cp	r30, r18
    4d0a:	39 f0       	breq	.+14     	; 0x4d1a <__vector_25+0x3c>
    4d0c:	e0 93 3d 05 	sts	0x053D, r30	; 0x80053d <UART_RxHead>
    4d10:	f0 e0       	ldi	r31, 0x00	; 0
    4d12:	e0 5c       	subi	r30, 0xC0	; 192
    4d14:	fa 4f       	sbci	r31, 0xFA	; 250
    4d16:	90 83       	st	Z, r25
    4d18:	01 c0       	rjmp	.+2      	; 0x4d1c <__vector_25+0x3e>
    4d1a:	82 e0       	ldi	r24, 0x02	; 2
    4d1c:	90 91 3b 05 	lds	r25, 0x053B	; 0x80053b <UART_LastRxError>
    4d20:	89 2b       	or	r24, r25
    4d22:	80 93 3b 05 	sts	0x053B, r24	; 0x80053b <UART_LastRxError>
    4d26:	ff 91       	pop	r31
    4d28:	ef 91       	pop	r30
    4d2a:	9f 91       	pop	r25
    4d2c:	8f 91       	pop	r24
    4d2e:	2f 91       	pop	r18
    4d30:	0f 90       	pop	r0
    4d32:	0f be       	out	0x3f, r0	; 63
    4d34:	0f 90       	pop	r0
    4d36:	1f 90       	pop	r1
    4d38:	18 95       	reti

00004d3a <__vector_26>:
    4d3a:	1f 92       	push	r1
    4d3c:	0f 92       	push	r0
    4d3e:	0f b6       	in	r0, 0x3f	; 63
    4d40:	0f 92       	push	r0
    4d42:	11 24       	eor	r1, r1
    4d44:	8f 93       	push	r24
    4d46:	9f 93       	push	r25
    4d48:	ef 93       	push	r30
    4d4a:	ff 93       	push	r31
    4d4c:	90 91 3f 05 	lds	r25, 0x053F	; 0x80053f <UART_TxHead>
    4d50:	80 91 3e 05 	lds	r24, 0x053E	; 0x80053e <UART_TxTail>
    4d54:	98 17       	cp	r25, r24
    4d56:	69 f0       	breq	.+26     	; 0x4d72 <__vector_26+0x38>
    4d58:	e0 91 3e 05 	lds	r30, 0x053E	; 0x80053e <UART_TxTail>
    4d5c:	ef 5f       	subi	r30, 0xFF	; 255
    4d5e:	ef 73       	andi	r30, 0x3F	; 63
    4d60:	e0 93 3e 05 	sts	0x053E, r30	; 0x80053e <UART_TxTail>
    4d64:	f0 e0       	ldi	r31, 0x00	; 0
    4d66:	e0 58       	subi	r30, 0x80	; 128
    4d68:	fa 4f       	sbci	r31, 0xFA	; 250
    4d6a:	80 81       	ld	r24, Z
    4d6c:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__DATA_REGION_ORIGIN__+0x6e>
    4d70:	05 c0       	rjmp	.+10     	; 0x4d7c <__vector_26+0x42>
    4d72:	80 91 c9 00 	lds	r24, 0x00C9	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
    4d76:	8f 7d       	andi	r24, 0xDF	; 223
    4d78:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
    4d7c:	ff 91       	pop	r31
    4d7e:	ef 91       	pop	r30
    4d80:	9f 91       	pop	r25
    4d82:	8f 91       	pop	r24
    4d84:	0f 90       	pop	r0
    4d86:	0f be       	out	0x3f, r0	; 63
    4d88:	0f 90       	pop	r0
    4d8a:	1f 90       	pop	r1
    4d8c:	18 95       	reti

00004d8e <uart_init>:
    4d8e:	10 92 3f 05 	sts	0x053F, r1	; 0x80053f <UART_TxHead>
    4d92:	10 92 3e 05 	sts	0x053E, r1	; 0x80053e <UART_TxTail>
    4d96:	10 92 3d 05 	sts	0x053D, r1	; 0x80053d <UART_RxHead>
    4d9a:	10 92 3c 05 	sts	0x053C, r1	; 0x80053c <UART_RxTail>
    4d9e:	97 ff       	sbrs	r25, 7
    4da0:	04 c0       	rjmp	.+8      	; 0x4daa <uart_init+0x1c>
    4da2:	22 e0       	ldi	r18, 0x02	; 2
    4da4:	20 93 c8 00 	sts	0x00C8, r18	; 0x8000c8 <__DATA_REGION_ORIGIN__+0x68>
    4da8:	9f 77       	andi	r25, 0x7F	; 127
    4daa:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__DATA_REGION_ORIGIN__+0x6d>
    4dae:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__DATA_REGION_ORIGIN__+0x6c>
    4db2:	88 e9       	ldi	r24, 0x98	; 152
    4db4:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
    4db8:	86 e0       	ldi	r24, 0x06	; 6
    4dba:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
    4dbe:	08 95       	ret

00004dc0 <uart_getc>:
    4dc0:	90 91 3d 05 	lds	r25, 0x053D	; 0x80053d <UART_RxHead>
    4dc4:	80 91 3c 05 	lds	r24, 0x053C	; 0x80053c <UART_RxTail>
    4dc8:	98 17       	cp	r25, r24
    4dca:	81 f0       	breq	.+32     	; 0x4dec <uart_getc+0x2c>
    4dcc:	e0 91 3c 05 	lds	r30, 0x053C	; 0x80053c <UART_RxTail>
    4dd0:	ef 5f       	subi	r30, 0xFF	; 255
    4dd2:	ef 73       	andi	r30, 0x3F	; 63
    4dd4:	e0 93 3c 05 	sts	0x053C, r30	; 0x80053c <UART_RxTail>
    4dd8:	f0 e0       	ldi	r31, 0x00	; 0
    4dda:	e0 5c       	subi	r30, 0xC0	; 192
    4ddc:	fa 4f       	sbci	r31, 0xFA	; 250
    4dde:	80 81       	ld	r24, Z
    4de0:	90 91 3b 05 	lds	r25, 0x053B	; 0x80053b <UART_LastRxError>
    4de4:	10 92 3b 05 	sts	0x053B, r1	; 0x80053b <UART_LastRxError>
    4de8:	90 e0       	ldi	r25, 0x00	; 0
    4dea:	08 95       	ret
    4dec:	80 e0       	ldi	r24, 0x00	; 0
    4dee:	91 e0       	ldi	r25, 0x01	; 1
    4df0:	08 95       	ret

00004df2 <uart_clear_rx_buffer>:
    4df2:	10 92 3d 05 	sts	0x053D, r1	; 0x80053d <UART_RxHead>
    4df6:	10 92 3c 05 	sts	0x053C, r1	; 0x80053c <UART_RxTail>
    4dfa:	08 95       	ret

00004dfc <uart_putc>:
    4dfc:	90 91 3f 05 	lds	r25, 0x053F	; 0x80053f <UART_TxHead>
    4e00:	9f 5f       	subi	r25, 0xFF	; 255
    4e02:	9f 73       	andi	r25, 0x3F	; 63
    4e04:	20 91 3e 05 	lds	r18, 0x053E	; 0x80053e <UART_TxTail>
    4e08:	92 17       	cp	r25, r18
    4e0a:	e1 f3       	breq	.-8      	; 0x4e04 <uart_putc+0x8>
    4e0c:	e9 2f       	mov	r30, r25
    4e0e:	f0 e0       	ldi	r31, 0x00	; 0
    4e10:	e0 58       	subi	r30, 0x80	; 128
    4e12:	fa 4f       	sbci	r31, 0xFA	; 250
    4e14:	80 83       	st	Z, r24
    4e16:	90 93 3f 05 	sts	0x053F, r25	; 0x80053f <UART_TxHead>
    4e1a:	80 91 c9 00 	lds	r24, 0x00C9	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
    4e1e:	80 62       	ori	r24, 0x20	; 32
    4e20:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
    4e24:	08 95       	ret

00004e26 <__vector_17>:
		return false;
	}
	else{
		return true;
	}
}
    4e26:	1f 92       	push	r1
    4e28:	0f 92       	push	r0
    4e2a:	0f b6       	in	r0, 0x3f	; 63
    4e2c:	0f 92       	push	r0
    4e2e:	11 24       	eor	r1, r1
    4e30:	2f 93       	push	r18
    4e32:	3f 93       	push	r19
    4e34:	4f 93       	push	r20
    4e36:	5f 93       	push	r21
    4e38:	6f 93       	push	r22
    4e3a:	7f 93       	push	r23
    4e3c:	8f 93       	push	r24
    4e3e:	9f 93       	push	r25
    4e40:	af 93       	push	r26
    4e42:	bf 93       	push	r27
    4e44:	ef 93       	push	r30
    4e46:	ff 93       	push	r31
    4e48:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <TMR1_Count>
    4e4c:	90 91 60 06 	lds	r25, 0x0660	; 0x800660 <TMR1_Count+0x1>
    4e50:	01 96       	adiw	r24, 0x01	; 1
    4e52:	90 93 60 06 	sts	0x0660, r25	; 0x800660 <TMR1_Count+0x1>
    4e56:	80 93 5f 06 	sts	0x065F, r24	; 0x80065f <TMR1_Count>
    4e5a:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <myTimeoutCounter>
    4e5e:	90 91 62 06 	lds	r25, 0x0662	; 0x800662 <myTimeoutCounter+0x1>
    4e62:	01 96       	adiw	r24, 0x01	; 1
    4e64:	90 93 62 06 	sts	0x0662, r25	; 0x800662 <myTimeoutCounter+0x1>
    4e68:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <myTimeoutCounter>
    4e6c:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <Typewriter_Mode>
    4e70:	81 30       	cpi	r24, 0x01	; 1
    4e72:	79 f0       	breq	.+30     	; 0x4e92 <__vector_17+0x6c>
    4e74:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <Typewriter_Mode>
    4e78:	8d 30       	cpi	r24, 0x0D	; 13
    4e7a:	59 f0       	breq	.+22     	; 0x4e92 <__vector_17+0x6c>
    4e7c:	80 e3       	ldi	r24, 0x30	; 48
    4e7e:	91 e0       	ldi	r25, 0x01	; 1
    4e80:	0e 94 03 31 	call	0x6206	; 0x6206 <MS_Device_USBTask>
    4e84:	80 e2       	ldi	r24, 0x20	; 32
    4e86:	91 e0       	ldi	r25, 0x01	; 1
    4e88:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <HID_Device_USBTask>
    4e8c:	0e 94 9a 37 	call	0x6f34	; 0x6f34 <USB_USBTask>
    4e90:	03 c0       	rjmp	.+6      	; 0x4e98 <__vector_17+0x72>
    4e92:	81 e0       	ldi	r24, 0x01	; 1
    4e94:	80 93 19 06 	sts	0x0619, r24	; 0x800619 <Scheduled_Task>
    4e98:	ff 91       	pop	r31
    4e9a:	ef 91       	pop	r30
    4e9c:	bf 91       	pop	r27
    4e9e:	af 91       	pop	r26
    4ea0:	9f 91       	pop	r25
    4ea2:	8f 91       	pop	r24
    4ea4:	7f 91       	pop	r23
    4ea6:	6f 91       	pop	r22
    4ea8:	5f 91       	pop	r21
    4eaa:	4f 91       	pop	r20
    4eac:	3f 91       	pop	r19
    4eae:	2f 91       	pop	r18
    4eb0:	0f 90       	pop	r0
    4eb2:	0f be       	out	0x3f, r0	; 63
    4eb4:	0f 90       	pop	r0
    4eb6:	1f 90       	pop	r1
    4eb8:	18 95       	reti

00004eba <Task_Manager>:
    4eba:	80 91 19 06 	lds	r24, 0x0619	; 0x800619 <Scheduled_Task>
    4ebe:	81 30       	cpi	r24, 0x01	; 1
    4ec0:	29 f4       	brne	.+10     	; 0x4ecc <Task_Manager+0x12>
    4ec2:	80 e3       	ldi	r24, 0x30	; 48
    4ec4:	91 e0       	ldi	r25, 0x01	; 1
    4ec6:	0e 94 03 31 	call	0x6206	; 0x6206 <MS_Device_USBTask>
    4eca:	04 c0       	rjmp	.+8      	; 0x4ed4 <Task_Manager+0x1a>
    4ecc:	80 91 19 06 	lds	r24, 0x0619	; 0x800619 <Scheduled_Task>
    4ed0:	83 30       	cpi	r24, 0x03	; 3
    4ed2:	29 f4       	brne	.+10     	; 0x4ede <Task_Manager+0x24>
    4ed4:	80 e2       	ldi	r24, 0x20	; 32
    4ed6:	91 e0       	ldi	r25, 0x01	; 1
    4ed8:	0e 94 e8 2f 	call	0x5fd0	; 0x5fd0 <HID_Device_USBTask>
    4edc:	08 c0       	rjmp	.+16     	; 0x4eee <Task_Manager+0x34>
    4ede:	80 91 19 06 	lds	r24, 0x0619	; 0x800619 <Scheduled_Task>
    4ee2:	82 30       	cpi	r24, 0x02	; 2
    4ee4:	31 f4       	brne	.+12     	; 0x4ef2 <Task_Manager+0x38>
    4ee6:	80 e3       	ldi	r24, 0x30	; 48
    4ee8:	91 e0       	ldi	r25, 0x01	; 1
    4eea:	0e 94 03 31 	call	0x6206	; 0x6206 <MS_Device_USBTask>
    4eee:	0e 94 9a 37 	call	0x6f34	; 0x6f34 <USB_USBTask>
    4ef2:	10 92 19 06 	sts	0x0619, r1	; 0x800619 <Scheduled_Task>
    4ef6:	08 95       	ret

00004ef8 <SetupHardware>:


/** Configures the board hardware and chip peripherals for functionality. */
void SetupHardware()
{
	UHWCON |=  (1 << UVREGE);
    4ef8:	80 91 d7 00 	lds	r24, 0x00D7	; 0x8000d7 <__DATA_REGION_ORIGIN__+0x77>
    4efc:	81 60       	ori	r24, 0x01	; 1
    4efe:	80 93 d7 00 	sts	0x00D7, r24	; 0x8000d7 <__DATA_REGION_ORIGIN__+0x77>

	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
    4f02:	84 b7       	in	r24, 0x34	; 52
    4f04:	87 7f       	andi	r24, 0xF7	; 247
    4f06:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    4f08:	0f b6       	in	r0, 0x3f	; 63
    4f0a:	f8 94       	cli
    4f0c:	a8 95       	wdr
    4f0e:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    4f12:	88 61       	ori	r24, 0x18	; 24
    4f14:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    4f18:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
    4f1c:	0f be       	out	0x3f, r0	; 63
	wdt_disable();
	
	/* Disable JTAG on PortF -- enables Port F pins to function normally.  Datasheet requires this pin to be written repeatedly in order for it to work. 
	("The application software must write this bit to the desired value twice within four cycles to change its value."*/
	MCUCR |= (1 << JTD); 
    4f1e:	85 b7       	in	r24, 0x35	; 53
    4f20:	80 68       	ori	r24, 0x80	; 128
    4f22:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4f24:	85 b7       	in	r24, 0x35	; 53
    4f26:	80 68       	ori	r24, 0x80	; 128
    4f28:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4f2a:	85 b7       	in	r24, 0x35	; 53
    4f2c:	80 68       	ori	r24, 0x80	; 128
    4f2e:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4f30:	85 b7       	in	r24, 0x35	; 53
    4f32:	80 68       	ori	r24, 0x80	; 128
    4f34:	85 bf       	out	0x35, r24	; 53
from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
    4f36:	90 e0       	ldi	r25, 0x00	; 0
    4f38:	80 e8       	ldi	r24, 0x80	; 128
    4f3a:	0f b6       	in	r0, 0x3f	; 63
    4f3c:	f8 94       	cli
    4f3e:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    4f42:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    4f46:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
	Config_Interrupts();
    4f48:	0e 94 1e 0d 	call	0x1a3c	; 0x1a3c <Config_Interrupts>
	
	/* Hardware Initialization */
	Config_IO();
    4f4c:	0e 94 32 0d 	call	0x1a64	; 0x1a64 <Config_IO>
    4f50:	2f e7       	ldi	r18, 0x7F	; 127
    4f52:	88 e3       	ldi	r24, 0x38	; 56
    4f54:	91 e0       	ldi	r25, 0x01	; 1
    4f56:	21 50       	subi	r18, 0x01	; 1
    4f58:	80 40       	sbci	r24, 0x00	; 0
    4f5a:	90 40       	sbci	r25, 0x00	; 0
    4f5c:	e1 f7       	brne	.-8      	; 0x4f56 <SetupHardware+0x5e>
    4f5e:	00 c0       	rjmp	.+0      	; 0x4f60 <SetupHardware+0x68>
    4f60:	00 00       	nop
	Delay_MS(50); //DELAY 50ms after setting IO.
	
	Reed1Polarity = eeprom_read_byte((uint8_t *)REED_1_POLARITY_ADDR);
    4f62:	86 e0       	ldi	r24, 0x06	; 6
    4f64:	92 e0       	ldi	r25, 0x02	; 2
    4f66:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    4f6a:	91 e0       	ldi	r25, 0x01	; 1
    4f6c:	81 11       	cpse	r24, r1
    4f6e:	01 c0       	rjmp	.+2      	; 0x4f72 <SetupHardware+0x7a>
    4f70:	90 e0       	ldi	r25, 0x00	; 0
    4f72:	90 93 68 06 	sts	0x0668, r25	; 0x800668 <Reed1Polarity>
	Reed2Polarity= eeprom_read_byte((uint8_t *)REED_2_POLARITY_ADDR);
    4f76:	87 e0       	ldi	r24, 0x07	; 7
    4f78:	92 e0       	ldi	r25, 0x02	; 2
    4f7a:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    4f7e:	91 e0       	ldi	r25, 0x01	; 1
    4f80:	81 11       	cpse	r24, r1
    4f82:	01 c0       	rjmp	.+2      	; 0x4f86 <SetupHardware+0x8e>
    4f84:	90 e0       	ldi	r25, 0x00	; 0
    4f86:	90 93 16 06 	sts	0x0616, r25	; 0x800616 <Reed2Polarity>
	Reed3Polarity = eeprom_read_byte((uint8_t *)REED_3_POLARITY_ADDR);
    4f8a:	88 e0       	ldi	r24, 0x08	; 8
    4f8c:	92 e0       	ldi	r25, 0x02	; 2
    4f8e:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    4f92:	91 e0       	ldi	r25, 0x01	; 1
    4f94:	81 11       	cpse	r24, r1
    4f96:	01 c0       	rjmp	.+2      	; 0x4f9a <SetupHardware+0xa2>
    4f98:	90 e0       	ldi	r25, 0x00	; 0
    4f9a:	90 93 ea 06 	sts	0x06EA, r25	; 0x8006ea <Reed3Polarity>
	Reed4Polarity = eeprom_read_byte((uint8_t *)REED_4_POLARITY_ADDR);
    4f9e:	89 e0       	ldi	r24, 0x09	; 9
    4fa0:	92 e0       	ldi	r25, 0x02	; 2
    4fa2:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    4fa6:	91 e0       	ldi	r25, 0x01	; 1
    4fa8:	81 11       	cpse	r24, r1
    4faa:	01 c0       	rjmp	.+2      	; 0x4fae <SetupHardware+0xb6>
    4fac:	90 e0       	ldi	r25, 0x00	; 0
    4fae:	90 93 28 07 	sts	0x0728, r25	; 0x800728 <Reed4Polarity>
    4fb2:	08 95       	ret

00004fb4 <EVENT_USB_Device_Connect>:
    4fb4:	08 95       	ret

00004fb6 <EVENT_USB_Device_Disconnect>:
}

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	if(SDCardManager_CheckSDCardOperation()){ //if there is an SD Card present, flip into sd mode if the computer is shut off.
    4fb6:	90 de       	rcall	.-736    	; 0x4cd8 <SDCardManager_CheckSDCardOperation>
    4fb8:	88 23       	and	r24, r24
    4fba:	19 f0       	breq	.+6      	; 0x4fc2 <EVENT_USB_Device_Disconnect+0xc>
		Typewriter_Mode = SD_MODE;
    4fbc:	82 e0       	ldi	r24, 0x02	; 2
    4fbe:	80 93 69 07 	sts	0x0769, r24	; 0x800769 <Typewriter_Mode>
    4fc2:	08 95       	ret

00004fc4 <EVENT_USB_Device_Suspend>:
    4fc4:	08 95       	ret

00004fc6 <EVENT_USB_Device_WakeUp>:

void EVENT_USB_Device_Suspend(void){
	
}

void EVENT_USB_Device_WakeUp(void){
    4fc6:	08 95       	ret

00004fc8 <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= HID_Device_ConfigureEndpoints(&Keyboard_HID_Interface);
    4fc8:	80 e2       	ldi	r24, 0x20	; 32
    4fca:	91 e0       	ldi	r25, 0x01	; 1
    4fcc:	ee d7       	rcall	.+4060   	; 0x5faa <HID_Device_ConfigureEndpoints>
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
    4fce:	80 e3       	ldi	r24, 0x30	; 48
    4fd0:	91 e0       	ldi	r25, 0x01	; 1
    4fd2:	0e 94 e6 30 	call	0x61cc	; 0x61cc <MS_Device_ConfigureEndpoints>
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
    4fd6:	e2 ee       	ldi	r30, 0xE2	; 226
    4fd8:	f0 e0       	ldi	r31, 0x00	; 0
    4fda:	80 81       	ld	r24, Z
    4fdc:	84 60       	ori	r24, 0x04	; 4
    4fde:	80 83       	st	Z, r24
    4fe0:	08 95       	ret

00004fe2 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	MS_Device_ProcessControlRequest(&Disk_MS_Interface);
    4fe2:	80 e3       	ldi	r24, 0x30	; 48
    4fe4:	91 e0       	ldi	r25, 0x01	; 1
    4fe6:	0e 94 a5 30 	call	0x614a	; 0x614a <MS_Device_ProcessControlRequest>
	HID_Device_ProcessControlRequest(&Keyboard_HID_Interface);
    4fea:	80 e2       	ldi	r24, 0x20	; 32
    4fec:	91 e0       	ldi	r25, 0x01	; 1
    4fee:	a8 c6       	rjmp	.+3408   	; 0x5d40 <HID_Device_ProcessControlRequest>

00004ff0 <EVENT_USB_Device_StartOfFrame>:
			 *  \param[in,out] HIDInterfaceInfo  Pointer to a structure containing a HID Class configuration and state.
			 */
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo) ATTR_ALWAYS_INLINE ATTR_NON_NULL_PTR_ARG(1);
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
			{
				if (HIDInterfaceInfo->State.IdleMSRemaining)
    4ff0:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <Keyboard_HID_Interface+0xe>
    4ff4:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <Keyboard_HID_Interface+0xf>
    4ff8:	00 97       	sbiw	r24, 0x00	; 0
    4ffa:	29 f0       	breq	.+10     	; 0x5006 <EVENT_USB_Device_StartOfFrame+0x16>
				  HIDInterfaceInfo->State.IdleMSRemaining--;
    4ffc:	01 97       	sbiw	r24, 0x01	; 1
    4ffe:	90 93 2f 01 	sts	0x012F, r25	; 0x80012f <Keyboard_HID_Interface+0xf>
    5002:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <Keyboard_HID_Interface+0xe>
    5006:	08 95       	ret

00005008 <CALLBACK_MS_Device_SCSICommandReceived>:
 */
bool CALLBACK_MS_Device_SCSICommandReceived(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	bool CommandSuccess;

	CommandSuccess = SCSI_DecodeSCSICommand(MSInterfaceInfo);
    5008:	ba cb       	rjmp	.-2188   	; 0x477e <SCSI_DecodeSCSICommand>

0000500a <CALLBACK_HID_Device_CreateHIDReport>:
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
                                         uint8_t* const ReportID,
                                         const uint8_t ReportType,
                                         void* ReportData,
                                         uint16_t* const ReportSize)
{
    500a:	0f 93       	push	r16
    500c:	1f 93       	push	r17
    500e:	f9 01       	movw	r30, r18
	USB_KeyboardReport_Data_t* KeyboardReport = (USB_KeyboardReport_Data_t*)ReportData;

//	memcpy((void*)KeyboardReport->KeyCode, (void*)KeyBuffer->KeyCode, 6); //copy the keybuffer into the keyboard report being sent to host.
	KeyboardReport->KeyCode[0] = KeyBuffer->KeyCode[0];
    5010:	a0 91 64 06 	lds	r26, 0x0664	; 0x800664 <KeyBuffer>
    5014:	b0 91 65 06 	lds	r27, 0x0665	; 0x800665 <KeyBuffer+0x1>
    5018:	12 96       	adiw	r26, 0x02	; 2
    501a:	8c 91       	ld	r24, X
    501c:	82 83       	std	Z+2, r24	; 0x02

	if (Hold_Alt_Down) { //this flag instructs us to hold alt down continuously, so that numpad ascii can be sent.
    501e:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <Hold_Alt_Down>
    5022:	99 23       	and	r25, r25
    5024:	11 f0       	breq	.+4      	; 0x502a <CALLBACK_HID_Device_CreateHIDReport+0x20>
		KeyboardReport->Modifier = HID_KEYBOARD_MODIFIER_LEFTALT;
    5026:	84 e0       	ldi	r24, 0x04	; 4
    5028:	04 c0       	rjmp	.+8      	; 0x5032 <CALLBACK_HID_Device_CreateHIDReport+0x28>
	}
	else if (KeyboardReport->KeyCode[0]){ //if there is a key waiting to be sent, then use the modifier that goes with that key.
    502a:	88 23       	and	r24, r24
    502c:	21 f0       	breq	.+8      	; 0x5036 <CALLBACK_HID_Device_CreateHIDReport+0x2c>
		KeyboardReport->Modifier = KeyBufferMod;
    502e:	80 91 1b 06 	lds	r24, 0x061B	; 0x80061b <KeyBufferMod>
    5032:	80 83       	st	Z, r24
    5034:	01 c0       	rjmp	.+2      	; 0x5038 <CALLBACK_HID_Device_CreateHIDReport+0x2e>
	}
	else{
		KeyboardReport->Modifier = 0; //otherwise, clear the modifiers so the host doesn't think we are holding down shift or alt or whatever for no reason.
    5036:	10 82       	st	Z, r1
	}
	
//	memset((void*)KeyBuffer->KeyCode,0,6);  //clear keybuffer to clear room for the next key.  This indicates to other routines that the USB buffer is available for sending.
	KeyBuffer->KeyCode[0] = 0;
    5038:	e0 91 64 06 	lds	r30, 0x0664	; 0x800664 <KeyBuffer>
    503c:	f0 91 65 06 	lds	r31, 0x0665	; 0x800665 <KeyBuffer+0x1>
    5040:	12 82       	std	Z+2, r1	; 0x02
	KeyBufferMod= 0;
    5042:	10 92 1b 06 	sts	0x061B, r1	; 0x80061b <KeyBufferMod>

	*ReportSize = sizeof(USB_KeyboardReport_Data_t);
    5046:	88 e0       	ldi	r24, 0x08	; 8
    5048:	90 e0       	ldi	r25, 0x00	; 0
    504a:	f8 01       	movw	r30, r16
    504c:	91 83       	std	Z+1, r25	; 0x01
    504e:	80 83       	st	Z, r24
	return false;
}
    5050:	80 e0       	ldi	r24, 0x00	; 0
    5052:	1f 91       	pop	r17
    5054:	0f 91       	pop	r16
    5056:	08 95       	ret

00005058 <CALLBACK_HID_Device_ProcessHIDReport>:
{
	uint8_t* LEDReport = (uint8_t*)ReportData;
	static bool NumLockActivated;
	static bool CapsLockDeactivated;

		if (!(*LEDReport & HID_KEYBOARD_LED_NUMLOCK) && !(NumLockActivated)){ //if numlock is somehow inactive, and numlock not already deactivated by code,
    5058:	f9 01       	movw	r30, r18
    505a:	80 81       	ld	r24, Z
    505c:	80 fd       	sbrc	r24, 0
    505e:	0e c0       	rjmp	.+28     	; 0x507c <CALLBACK_HID_Device_ProcessHIDReport+0x24>
    5060:	90 91 c1 05 	lds	r25, 0x05C1	; 0x8005c1 <NumLockActivated.4747>
    5064:	91 11       	cpse	r25, r1
    5066:	0a c0       	rjmp	.+20     	; 0x507c <CALLBACK_HID_Device_ProcessHIDReport+0x24>
		  KeyBuffer->KeyCode[0] = HID_KEYBOARD_SC_NUM_LOCK; //press numlock key to activate it.  -- NumLockDeactivated flag makes sure this only happens once per session.
    5068:	e0 91 64 06 	lds	r30, 0x0664	; 0x800664 <KeyBuffer>
    506c:	f0 91 65 06 	lds	r31, 0x0665	; 0x800665 <KeyBuffer+0x1>
    5070:	83 e5       	ldi	r24, 0x53	; 83
    5072:	82 83       	std	Z+2, r24	; 0x02
		  NumLockActivated = true;//only activate numlock once per session -- that way user can override
    5074:	81 e0       	ldi	r24, 0x01	; 1
    5076:	80 93 c1 05 	sts	0x05C1, r24	; 0x8005c1 <NumLockActivated.4747>
    507a:	08 95       	ret
		}

		else if ((*LEDReport & HID_KEYBOARD_LED_CAPSLOCK) && !(CapsLockDeactivated)){ //if capslock is somehow active,
    507c:	81 ff       	sbrs	r24, 1
    507e:	0d c0       	rjmp	.+26     	; 0x509a <CALLBACK_HID_Device_ProcessHIDReport+0x42>
    5080:	80 91 c0 05 	lds	r24, 0x05C0	; 0x8005c0 <CapsLockDeactivated.4748>
    5084:	81 11       	cpse	r24, r1
    5086:	09 c0       	rjmp	.+18     	; 0x509a <CALLBACK_HID_Device_ProcessHIDReport+0x42>
		 KeyBuffer ->KeyCode[0] = HID_KEYBOARD_SC_CAPS_LOCK; //press capslock key to deactivate it.
    5088:	e0 91 64 06 	lds	r30, 0x0664	; 0x800664 <KeyBuffer>
    508c:	f0 91 65 06 	lds	r31, 0x0665	; 0x800665 <KeyBuffer+0x1>
    5090:	89 e3       	ldi	r24, 0x39	; 57
    5092:	82 83       	std	Z+2, r24	; 0x02
		 CapsLockDeactivated = true; //only deactivate caps lock once per session -- that way user can override
    5094:	81 e0       	ldi	r24, 0x01	; 1
    5096:	80 93 c0 05 	sts	0x05C0, r24	; 0x8005c0 <CapsLockDeactivated.4748>
    509a:	08 95       	ret

0000509c <Init_Mode>:
	//	  KeyBuffer ->KeyCode[0] = HID_KEYBOARD_SC_SCROLL_LOCK; //press scrolllock key to deactivate it.
	
}


void Init_Mode(){
    509c:	cf 93       	push	r28
	uint8_t key;
	uint8_t code;
	uint8_t Default_Mode;
	
	Default_Mode = eeprom_read_byte((uint8_t*)DEFAULT_MODE_ADDR);
    509e:	8d e0       	ldi	r24, 0x0D	; 13
    50a0:	92 e0       	ldi	r25, 0x02	; 2
    50a2:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    50a6:	c8 2f       	mov	r28, r24

	key = GetKeySimple(); //read the key that is being held during startup (if any)
    50a8:	cc d3       	rcall	.+1944   	; 0x5842 <GetKeySimple>
	code = GetASCIIKeyCode(key,UPPER);
    50aa:	62 e0       	ldi	r22, 0x02	; 2
    50ac:	55 d5       	rcall	.+2730   	; 0x5b58 <GetASCIIKeyCode>
	
	if (is_low(S1)&&is_low(S2)&&is_low(S3)){ //reset device to known state
    50ae:	7c 99       	sbic	0x0f, 4	; 15
    50b0:	0c c0       	rjmp	.+24     	; 0x50ca <Init_Mode+0x2e>
    50b2:	7d 99       	sbic	0x0f, 5	; 15
    50b4:	0a c0       	rjmp	.+20     	; 0x50ca <Init_Mode+0x2e>
    50b6:	7e 99       	sbic	0x0f, 6	; 15
    50b8:	08 c0       	rjmp	.+16     	; 0x50ca <Init_Mode+0x2e>
			Typewriter_Mode = USB_COMBO_MODE;
    50ba:	81 e0       	ldi	r24, 0x01	; 1
    50bc:	80 93 69 07 	sts	0x0769, r24	; 0x800769 <Typewriter_Mode>
			Default_Mode = USB_COMBO_MODE;
			GlowGreenLED(SLOW,GLOWING);
    50c0:	60 e0       	ldi	r22, 0x00	; 0
    50c2:	0e 94 62 0d 	call	0x1ac4	; 0x1ac4 <GlowGreenLED>
			RestoreFactoryDefaults();			
    50c6:	e9 d5       	rcall	.+3026   	; 0x5c9a <RestoreFactoryDefaults>
    50c8:	1f c0       	rjmp	.+62     	; 0x5108 <Init_Mode+0x6c>
	}
	else if(is_low(S2)&&is_low(S3)){ //configure bluetooth and test bluetooth -- reset bluetooth module  -- force initialization next time bluetooth is used.
    50ca:	7d 99       	sbic	0x0f, 5	; 15
    50cc:	10 c0       	rjmp	.+32     	; 0x50ee <Init_Mode+0x52>
    50ce:	7e 99       	sbic	0x0f, 6	; 15
    50d0:	0e c0       	rjmp	.+28     	; 0x50ee <Init_Mode+0x52>
			if(Bluetooth_Configure()){
    50d2:	0e 94 2e 05 	call	0xa5c	; 0xa5c <Bluetooth_Configure>
    50d6:	88 23       	and	r24, r24
    50d8:	31 f0       	breq	.+12     	; 0x50e6 <Init_Mode+0x4a>
					#ifndef BT_DEBUG
						USB_Disable(); //leave usb active if this is debug mode.
    50da:	0e 94 02 35 	call	0x6a04	; 0x6a04 <USB_Disable>
					#endif
					
					#if MODULE_NAME==EHONG //ehong module requires you to manually clear the pairing list to enter inquiry mode
					BluetoothInquire();//clear paired device list and try to pair.
    50de:	0e 94 8c 05 	call	0xb18	; 0xb18 <BluetoothInquire>
					#endif
					
					Typewriter_Mode = BLUETOOTH_MODE;
    50e2:	89 e0       	ldi	r24, 0x09	; 9
    50e4:	01 c0       	rjmp	.+2      	; 0x50e8 <Init_Mode+0x4c>
					//Default_Mode = BLUETOOTH_MODE;  //Do not set bluetooth mode as the default, since this mode only TESTS the bluetooth
			}
			else{ //if something goes wrong during configuration...
					Typewriter_Mode = PANIC_MODE; //don't change default mode
    50e6:	8a e0       	ldi	r24, 0x0A	; 10
    50e8:	80 93 69 07 	sts	0x0769, r24	; 0x800769 <Typewriter_Mode>
    50ec:	4d c0       	rjmp	.+154    	; 0x5188 <Init_Mode+0xec>
			}
	}
	else if(is_low(S1)&&is_low(S2)){
    50ee:	7c 99       	sbic	0x0f, 4	; 15
    50f0:	04 c0       	rjmp	.+8      	; 0x50fa <Init_Mode+0x5e>
    50f2:	7d 99       	sbic	0x0f, 5	; 15
    50f4:	02 c0       	rjmp	.+4      	; 0x50fa <Init_Mode+0x5e>
			Typewriter_Mode = MANUAL_CAL_MODE;
    50f6:	8e e0       	ldi	r24, 0x0E	; 14
    50f8:	05 c0       	rjmp	.+10     	; 0x5104 <Init_Mode+0x68>
			Default_Mode = USB_COMBO_MODE;
	}
	else if(is_low(S1)&&is_low(S3)){//quick calibration mode
    50fa:	7c 99       	sbic	0x0f, 4	; 15
    50fc:	07 c0       	rjmp	.+14     	; 0x510c <Init_Mode+0x70>
    50fe:	7e 99       	sbic	0x0f, 6	; 15
    5100:	05 c0       	rjmp	.+10     	; 0x510c <Init_Mode+0x70>
			Typewriter_Mode = QUICK_CAL_MODE;
    5102:	86 e0       	ldi	r24, 0x06	; 6
    5104:	80 93 69 07 	sts	0x0769, r24	; 0x800769 <Typewriter_Mode>
			Default_Mode = USB_COMBO_MODE;
    5108:	c1 e0       	ldi	r28, 0x01	; 1
    510a:	3e c0       	rjmp	.+124    	; 0x5188 <Init_Mode+0xec>
	}
	else if (is_low(S1)){ //hold down S1 during initialization to calibrate
    510c:	7c 99       	sbic	0x0f, 4	; 15
    510e:	02 c0       	rjmp	.+4      	; 0x5114 <Init_Mode+0x78>
			Typewriter_Mode = CAL_MODE;
    5110:	85 e0       	ldi	r24, 0x05	; 5
    5112:	f8 cf       	rjmp	.-16     	; 0x5104 <Init_Mode+0x68>
			Default_Mode = USB_COMBO_MODE;
	}
	else if(is_low(S2)){
    5114:	7d 99       	sbic	0x0f, 5	; 15
    5116:	02 c0       	rjmp	.+4      	; 0x511c <Init_Mode+0x80>
		Typewriter_Mode = SENSITIVITY_MODE;
    5118:	83 e0       	ldi	r24, 0x03	; 3
    511a:	e6 cf       	rjmp	.-52     	; 0x50e8 <Init_Mode+0x4c>
	}
	else if (is_low(S3)){ //hold down S3 to enter LED indication mode to test reed switches.
    511c:	7e 99       	sbic	0x0f, 6	; 15
    511e:	02 c0       	rjmp	.+4      	; 0x5124 <Init_Mode+0x88>
		Typewriter_Mode = TEST_MODE;
    5120:	84 e0       	ldi	r24, 0x04	; 4
    5122:	e2 cf       	rjmp	.-60     	; 0x50e8 <Init_Mode+0x4c>
	}
	else if(code == 'U'){ //if the letter U is being held by user
    5124:	85 35       	cpi	r24, 0x55	; 85
    5126:	31 f4       	brne	.+12     	; 0x5134 <Init_Mode+0x98>
		Typewriter_Mode = USB_COMBO_MODE;
    5128:	81 e0       	ldi	r24, 0x01	; 1
    512a:	80 93 69 07 	sts	0x0769, r24	; 0x800769 <Typewriter_Mode>
		Default_Mode = USB_COMBO_MODE;	
		Ignore_Flag = 1; //tell sensor routine to ignore this U.
    512e:	80 93 63 06 	sts	0x0663, r24	; 0x800663 <Ignore_Flag>
	}
	else if(code == 'S'){//if the letter S is being held by the user
    5132:	ea cf       	rjmp	.-44     	; 0x5108 <Init_Mode+0x6c>
    5134:	83 35       	cpi	r24, 0x53	; 83
		if(SDCardManager_CheckSDCardOperation()){ //if an sd card is present and working, put typewriter into sd mode
    5136:	79 f4       	brne	.+30     	; 0x5156 <Init_Mode+0xba>
    5138:	cf dd       	rcall	.-1122   	; 0x4cd8 <SDCardManager_CheckSDCardOperation>
    513a:	88 23       	and	r24, r24
    513c:	39 f0       	breq	.+14     	; 0x514c <Init_Mode+0xb0>
			Typewriter_Mode = SD_MODE;
    513e:	82 e0       	ldi	r24, 0x02	; 2
    5140:	80 93 69 07 	sts	0x0769, r24	; 0x800769 <Typewriter_Mode>
			Default_Mode = SD_MODE;
			Ignore_Flag = 1; //tell sensor routine to ignore this S.
    5144:	81 e0       	ldi	r24, 0x01	; 1
    5146:	80 93 63 06 	sts	0x0663, r24	; 0x800663 <Ignore_Flag>
    514a:	03 c0       	rjmp	.+6      	; 0x5152 <Init_Mode+0xb6>
		}
		else{
			Typewriter_Mode = PANIC_MODE; //otherwise, panic to indicate malfunction ... don't change default mode.
    514c:	8a e0       	ldi	r24, 0x0A	; 10
    514e:	80 93 69 07 	sts	0x0769, r24	; 0x800769 <Typewriter_Mode>
			Default_Mode = SD_MODE; //even so, sd mode next time you plug in.
    5152:	c2 e0       	ldi	r28, 0x02	; 2
    5154:	19 c0       	rjmp	.+50     	; 0x5188 <Init_Mode+0xec>
		}
	}
	else if(code == 'B'){ //if the letter B is being held by the user
    5156:	82 34       	cpi	r24, 0x42	; 66
    5158:	71 f4       	brne	.+28     	; 0x5176 <Init_Mode+0xda>
		#ifndef BT_DEBUG
			USB_Disable(); //if this is not debug mode, disable the usb port.
    515a:	0e 94 02 35 	call	0x6a04	; 0x6a04 <USB_Disable>
		#endif
		if(Bluetooth_Configure()){ // attempt to configure. this erases rn42 paired device list, but not ehong's
    515e:	0e 94 2e 05 	call	0xa5c	; 0xa5c <Bluetooth_Configure>
    5162:	88 23       	and	r24, r24
    5164:	09 f4       	brne	.+2      	; 0x5168 <Init_Mode+0xcc>
    5166:	bf cf       	rjmp	.-130    	; 0x50e6 <Init_Mode+0x4a>
			#if MODULE_NAME==EHONG 
				BluetoothInquire(); //if configuration is successful, delete the paired device list so device can become discoverable.
    5168:	0e 94 8c 05 	call	0xb18	; 0xb18 <BluetoothInquire>
			#endif
			
			Typewriter_Mode = BLUETOOTH_MODE;
    516c:	89 e0       	ldi	r24, 0x09	; 9
    516e:	80 93 69 07 	sts	0x0769, r24	; 0x800769 <Typewriter_Mode>
			Default_Mode = BLUETOOTH_MODE;
    5172:	c9 e0       	ldi	r28, 0x09	; 9
    5174:	09 c0       	rjmp	.+18     	; 0x5188 <Init_Mode+0xec>
		}
		else{ //if something goes wrong during configuration...
			Typewriter_Mode = PANIC_MODE; //indicate error
		}
	}
	else if(code == 'L'){
    5176:	8c 34       	cpi	r24, 0x4C	; 76
    5178:	29 f4       	brne	.+10     	; 0x5184 <Init_Mode+0xe8>
			Typewriter_Mode = USB_LIGHT_MODE;
    517a:	8d e0       	ldi	r24, 0x0D	; 13
    517c:	80 93 69 07 	sts	0x0769, r24	; 0x800769 <Typewriter_Mode>
			Default_Mode = USB_LIGHT_MODE;
    5180:	cd e0       	ldi	r28, 0x0D	; 13
    5182:	02 c0       	rjmp	.+4      	; 0x5188 <Init_Mode+0xec>
	}

	else{
		Typewriter_Mode = Default_Mode; //otherwise just go into the last mode selected by user.
    5184:	c0 93 69 07 	sts	0x0769, r28	; 0x800769 <Typewriter_Mode>
	}
	
	eeprom_update_byte((uint8_t*)DEFAULT_MODE_ADDR,Default_Mode);  //Save the new default mode (if changed)
    5188:	6c 2f       	mov	r22, r28
    518a:	8d e0       	ldi	r24, 0x0D	; 13
    518c:	92 e0       	ldi	r25, 0x02	; 2
}
    518e:	cf 91       	pop	r28

	else{
		Typewriter_Mode = Default_Mode; //otherwise just go into the last mode selected by user.
	}
	
	eeprom_update_byte((uint8_t*)DEFAULT_MODE_ADDR,Default_Mode);  //Save the new default mode (if changed)
    5190:	0c 94 a1 3b 	jmp	0x7742	; 0x7742 <eeprom_update_byte>

00005194 <main>:

/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{	
    5194:	cf 93       	push	r28
    5196:	df 93       	push	r29
    5198:	1f 92       	push	r1
    519a:	cd b7       	in	r28, 0x3d	; 61
    519c:	de b7       	in	r29, 0x3e	; 62
	uint8_t key;
	uint8_t code;
	uint8_t modifier;
	uint8_t parity;
	
	Typewriter_Mode = INITIALIZING;
    519e:	8c e0       	ldi	r24, 0x0C	; 12
    51a0:	80 93 69 07 	sts	0x0769, r24	; 0x800769 <Typewriter_Mode>

	SetupHardware();
    51a4:	a9 de       	rcall	.-686    	; 0x4ef8 <SetupHardware>
	InitializeEeprom();//sets all EEPROM entries to zero if the checksum is incorrect
    51a6:	a3 d5       	rcall	.+2886   	; 0x5cee <InitializeEeprom>
	LoadEepromParameters();
    51a8:	1b d5       	rcall	.+2614   	; 0x5be0 <LoadEepromParameters>
	LoadKeyCodeTables();
    51aa:	f2 d4       	rcall	.+2532   	; 0x5b90 <LoadKeyCodeTables>
    51ac:	3a dc       	rcall	.-1932   	; 0x4a22 <SDCardManager_Init>
	SDCardManager_Init(); 
    51ae:	0e 94 5a 35 	call	0x6ab4	; 0x6ab4 <USB_Init>
	USB_Init();//DEBUG ONLY
	uart_init(UART_BAUD_SELECT(9600,F_CPU));//initialize the uart with a baud rate of x bps
    51b2:	83 e3       	ldi	r24, 0x33	; 51
    51b4:	90 e0       	ldi	r25, 0x00	; 0
    51b6:	eb dd       	rcall	.-1066   	; 0x4d8e <uart_init>
    51b8:	78 94       	sei
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    51ba:	70 df       	rcall	.-288    	; 0x509c <Init_Mode>

	//USB_Init(); COMMENTED FOR DEBUGGING
	GlobalInterruptEnable();
	
	Init_Mode();
    51bc:	1d e0       	ldi	r17, 0x0D	; 13
    51be:	0a e0       	ldi	r16, 0x0A	; 10
				Calibrate();
				Typewriter_Mode = USB_LIGHT_MODE; //after calibrating, go to usb light mode.
			break;
			case QUICK_CAL_MODE:
				QuickCalibrate();
				Typewriter_Mode = USB_LIGHT_MODE;//after calibrating, go to usb light mode.
    51c0:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <Typewriter_Mode>
	
	Init_Mode();
//	Delay_MS(INIT_DELAY);
	
	while(1){
		switch (Typewriter_Mode){
    51c4:	86 30       	cpi	r24, 0x06	; 6
    51c6:	09 f4       	brne	.+2      	; 0x51ca <main+0x36>
    51c8:	84 c0       	rjmp	.+264    	; 0x52d2 <main+0x13e>
    51ca:	9c f4       	brge	.+38     	; 0x51f2 <main+0x5e>
    51cc:	83 30       	cpi	r24, 0x03	; 3
    51ce:	09 f4       	brne	.+2      	; 0x51d2 <main+0x3e>
    51d0:	db c0       	rjmp	.+438    	; 0x5388 <main+0x1f4>
    51d2:	34 f4       	brge	.+12     	; 0x51e0 <main+0x4c>
    51d4:	81 30       	cpi	r24, 0x01	; 1
    51d6:	11 f1       	breq	.+68     	; 0x521c <main+0x88>
    51d8:	82 30       	cpi	r24, 0x02	; 2
    51da:	09 f4       	brne	.+2      	; 0x51de <main+0x4a>
    51dc:	6f c0       	rjmp	.+222    	; 0x52bc <main+0x128>
    51de:	d9 c0       	rjmp	.+434    	; 0x5392 <main+0x1fe>
    51e0:	84 30       	cpi	r24, 0x04	; 4
    51e2:	09 f4       	brne	.+2      	; 0x51e6 <main+0x52>
    51e4:	3d c0       	rjmp	.+122    	; 0x5260 <main+0xcc>
    51e6:	85 30       	cpi	r24, 0x05	; 5
    51e8:	09 f0       	breq	.+2      	; 0x51ec <main+0x58>
    51ea:	d3 c0       	rjmp	.+422    	; 0x5392 <main+0x1fe>
    51ec:	0e 94 fd 07 	call	0xffa	; 0xffa <Calibrate>
				if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
				USB_Disable(); //make sure no host is connected before accessing SD card.
				LogKeystrokes();
			break;
			case CAL_MODE:
				Calibrate();
    51f0:	cd c0       	rjmp	.+410    	; 0x538c <main+0x1f8>
    51f2:	8b 30       	cpi	r24, 0x0B	; 11
    51f4:	09 f4       	brne	.+2      	; 0x51f8 <main+0x64>
	
	Init_Mode();
//	Delay_MS(INIT_DELAY);
	
	while(1){
		switch (Typewriter_Mode){
    51f6:	5e c0       	rjmp	.+188    	; 0x52b4 <main+0x120>
    51f8:	4c f4       	brge	.+18     	; 0x520c <main+0x78>
    51fa:	89 30       	cpi	r24, 0x09	; 9
    51fc:	09 f4       	brne	.+2      	; 0x5200 <main+0x6c>
    51fe:	6c c0       	rjmp	.+216    	; 0x52d8 <main+0x144>
    5200:	8a 30       	cpi	r24, 0x0A	; 10
    5202:	09 f0       	breq	.+2      	; 0x5206 <main+0x72>
    5204:	c6 c0       	rjmp	.+396    	; 0x5392 <main+0x1fe>
    5206:	0e 94 02 35 	call	0x6a04	; 0x6a04 <USB_Disable>
					Delay_MS(SENSE_DELAY);//perform this loop every X ms.
				}
			
			break;
			case PANIC_MODE:
				USB_Disable();
    520a:	a7 c0       	rjmp	.+334    	; 0x535a <main+0x1c6>
    520c:	8d 30       	cpi	r24, 0x0D	; 13
    520e:	31 f0       	breq	.+12     	; 0x521c <main+0x88>
	
	Init_Mode();
//	Delay_MS(INIT_DELAY);
	
	while(1){
		switch (Typewriter_Mode){
    5210:	8e 30       	cpi	r24, 0x0E	; 14
    5212:	09 f0       	breq	.+2      	; 0x5216 <main+0x82>
    5214:	be c0       	rjmp	.+380    	; 0x5392 <main+0x1fe>
    5216:	0e 94 af 0b 	call	0x175e	; 0x175e <Calibrate_Manually>
			case QUICK_CAL_MODE:
				QuickCalibrate();
				Typewriter_Mode = USB_LIGHT_MODE;//after calibrating, go to usb light mode.
			break;
			case MANUAL_CAL_MODE:
				Calibrate_Manually();
    521a:	b8 c0       	rjmp	.+368    	; 0x538c <main+0x1f8>
	
	while(1){
		switch (Typewriter_Mode){
			case USB_LIGHT_MODE:
			case USB_COMBO_MODE:				
			MountFilesystem();//mount the filesystem so that we have info on it
    521c:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <MountFilesystem>
			while(1){
				key = GetKey();
    5220:	38 d3       	rcall	.+1648   	; 0x5892 <GetKey>
    5222:	18 2f       	mov	r17, r24
				modifier = GetModifier(); 
    5224:	2c d2       	rcall	.+1112   	; 0x567e <GetModifier>
    5226:	89 83       	std	Y+1, r24	; 0x01
    5228:	be 01       	movw	r22, r28
				code = GetHIDKeyCode(key, &modifier);
    522a:	6f 5f       	subi	r22, 0xFF	; 255
    522c:	7f 4f       	sbci	r23, 0xFF	; 255
    522e:	81 2f       	mov	r24, r17
    5230:	75 d4       	rcall	.+2282   	; 0x5b1c <GetHIDKeyCode>
    5232:	88 23       	and	r24, r24
    5234:	51 f0       	breq	.+20     	; 0x524a <main+0xb6>
					
				if(code){//if the code is valid, send it
    5236:	88 31       	cpi	r24, 0x18	; 24
						if ((code == KEY_U) && Ignore_Flag) code = 0; //if user is holding down U on startup, don't add this U to file.
    5238:	21 f4       	brne	.+8      	; 0x5242 <main+0xae>
    523a:	90 91 63 06 	lds	r25, 0x0663	; 0x800663 <Ignore_Flag>
    523e:	91 11       	cpse	r25, r1
    5240:	80 e0       	ldi	r24, 0x00	; 0
    5242:	10 92 63 06 	sts	0x0663, r1	; 0x800663 <Ignore_Flag>
						Ignore_Flag = 0;
    5246:	69 81       	ldd	r22, Y+1	; 0x01
						USBSend(code,modifier);
    5248:	a7 d0       	rcall	.+334    	; 0x5398 <USBSend>
    524a:	8f ec       	ldi	r24, 0xCF	; 207
    524c:	97 e0       	ldi	r25, 0x07	; 7
    524e:	01 97       	sbiw	r24, 0x01	; 1
    5250:	f1 f7       	brne	.-4      	; 0x524e <main+0xba>
    5252:	00 c0       	rjmp	.+0      	; 0x5254 <main+0xc0>
    5254:	00 00       	nop
				}
				Delay_MS(SENSE_DELAY);//perform this loop every X ms.
				HID_Device_USBTask(&Keyboard_HID_Interface);
    5256:	80 e2       	ldi	r24, 0x20	; 32
    5258:	91 e0       	ldi	r25, 0x01	; 1
    525a:	ba d6       	rcall	.+3444   	; 0x5fd0 <HID_Device_USBTask>
    525c:	2e de       	rcall	.-932    	; 0x4eba <Task_Manager>
				Task_Manager(); //do the required usb upkeep tasks, then update the list of scheduled tasks.
    525e:	e0 cf       	rjmp	.-64     	; 0x5220 <main+0x8c>
    5260:	0e 94 02 35 	call	0x6a04	; 0x6a04 <USB_Disable>
				
			}
			break;
			case TEST_MODE:
				USB_Disable(); //USB not needed for testing
    5264:	01 e0       	ldi	r16, 0x01	; 1
    5266:	10 92 eb 06 	sts	0x06EB, r1	; 0x8006eb <UseHallSensor>
				while(1){
					UseHallSensor = HALL_NOT_PRESENT;//make sure hall sensor bit is not zeroed out by ReadSensor() as soon as it is read;
    526a:	19 b1       	in	r17, 0x09	; 9
    526c:	89 b1       	in	r24, 0x09	; 9
					parity = (uint8_t)is_low(REED_1) + (uint8_t)is_low(REED_2)+ (uint8_t)is_low(REED_3) + (uint8_t)is_low(REED_4) + (uint8_t)getHallState();
    526e:	29 b1       	in	r18, 0x09	; 9
    5270:	93 b1       	in	r25, 0x03	; 3
    5272:	12 95       	swap	r17
    5274:	11 70       	andi	r17, 0x01	; 1
    5276:	10 27       	eor	r17, r16
    5278:	86 fb       	bst	r24, 6
    527a:	88 27       	eor	r24, r24
    527c:	80 f9       	bld	r24, 0
    527e:	80 27       	eor	r24, r16
    5280:	18 0f       	add	r17, r24
    5282:	20 95       	com	r18
    5284:	22 1f       	adc	r18, r18
    5286:	22 27       	eor	r18, r18
    5288:	22 1f       	adc	r18, r18
    528a:	12 0f       	add	r17, r18
    528c:	92 95       	swap	r25
    528e:	91 70       	andi	r25, 0x01	; 1
    5290:	90 27       	eor	r25, r16
    5292:	19 0f       	add	r17, r25
    5294:	74 d4       	rcall	.+2280   	; 0x5b7e <getHallState>
    5296:	81 0f       	add	r24, r17
    5298:	80 ff       	sbrs	r24, 0
				
					if (parity & 1){  //if first bit of parity is 1, then an odd number of sensors are active.
    529a:	03 c0       	rjmp	.+6      	; 0x52a2 <main+0x10e>
    529c:	46 9a       	sbi	0x08, 6	; 8
    529e:	2e 98       	cbi	0x05, 6	; 5
						set_high(LED1);
    52a0:	02 c0       	rjmp	.+4      	; 0x52a6 <main+0x112>
						set_low(LED2);
    52a2:	46 98       	cbi	0x08, 6	; 8
    52a4:	2e 9a       	sbi	0x05, 6	; 5
					}
					else{ //otherwise, an even number (or zero) are active.
						set_low(LED1);
    52a6:	ef ec       	ldi	r30, 0xCF	; 207
						set_high(LED2);
    52a8:	f7 e0       	ldi	r31, 0x07	; 7
    52aa:	31 97       	sbiw	r30, 0x01	; 1
    52ac:	f1 f7       	brne	.-4      	; 0x52aa <main+0x116>
    52ae:	00 c0       	rjmp	.+0      	; 0x52b0 <main+0x11c>
    52b0:	00 00       	nop
    52b2:	d9 cf       	rjmp	.-78     	; 0x5266 <main+0xd2>
    52b4:	0e 94 02 35 	call	0x6a04	; 0x6a04 <USB_Disable>
					}
					Delay_MS(SENSE_DELAY);
				}
			break;
			case HARDWARE_TEST:				
				USB_Disable(); //make sure no host is connected before accessing SD card.
    52b8:	0e 94 bb 0e 	call	0x1d76	; 0x1d76 <TestSDHardware>
				TestSDHardware();
    52bc:	80 91 17 06 	lds	r24, 0x0617	; 0x800617 <UseDummyLoad>
			case SD_MODE:
				if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
    52c0:	88 23       	and	r24, r24
    52c2:	11 f0       	breq	.+4      	; 0x52c8 <main+0x134>
    52c4:	5d 98       	cbi	0x0b, 5	; 11
    52c6:	55 9a       	sbi	0x0a, 5	; 10
    52c8:	0e 94 02 35 	call	0x6a04	; 0x6a04 <USB_Disable>
				USB_Disable(); //make sure no host is connected before accessing SD card.
    52cc:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <LogKeystrokes>
				LogKeystrokes();
    52d0:	77 cf       	rjmp	.-274    	; 0x51c0 <main+0x2c>
    52d2:	0e 94 87 07 	call	0xf0e	; 0xf0e <QuickCalibrate>
			case CAL_MODE:
				Calibrate();
				Typewriter_Mode = USB_LIGHT_MODE; //after calibrating, go to usb light mode.
			break;
			case QUICK_CAL_MODE:
				QuickCalibrate();
    52d6:	5a c0       	rjmp	.+180    	; 0x538c <main+0x1f8>
    52d8:	0e 94 02 35 	call	0x6a04	; 0x6a04 <USB_Disable>
				Calibrate_Manually();
				Typewriter_Mode = USB_LIGHT_MODE;
			break;
			case BLUETOOTH_MODE:
				#ifndef BT_DEBUG
					USB_Disable();//don't disable usb if it is debug mode.
    52dc:	0e 94 d7 05 	call	0xbae	; 0xbae <Get_Bluetooth_State>
				#endif
					
					if(Get_Bluetooth_State() != INITIALIZED){Bluetooth_Init();};//initialize bluetooth if it hasn't been already. this sets up proxy mode, too.
    52e0:	81 30       	cpi	r24, 0x01	; 1
    52e2:	11 f0       	breq	.+4      	; 0x52e8 <main+0x154>
    52e4:	0e 94 bd 04 	call	0x97a	; 0x97a <Bluetooth_Init>
    52e8:	80 91 17 06 	lds	r24, 0x0617	; 0x800617 <UseDummyLoad>
					if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
    52ec:	88 23       	and	r24, r24
    52ee:	69 f0       	breq	.+26     	; 0x530a <main+0x176>
    52f0:	5d 98       	cbi	0x0b, 5	; 11
    52f2:	55 9a       	sbi	0x0a, 5	; 10
    52f4:	0a c0       	rjmp	.+20     	; 0x530a <main+0x176>
    52f6:	01 97       	sbiw	r24, 0x01	; 1
    52f8:	41 f0       	breq	.+16     	; 0x530a <main+0x176>
    52fa:	ef e1       	ldi	r30, 0x1F	; 31
				while(is_low(BT_CONNECTED)){	
					set_low(RED_LED);
					set_high(GREEN_LED);
					#if MODULE_NAME==EHONG
					Bluetooth_Connect();
					for (int i=0; i<=1000; i++){//10 seconds between connection attempts
    52fc:	fe e4       	ldi	r31, 0x4E	; 78
    52fe:	31 97       	sbiw	r30, 0x01	; 1
    5300:	f1 f7       	brne	.-4      	; 0x52fe <main+0x16a>
    5302:	00 c0       	rjmp	.+0      	; 0x5304 <main+0x170>
    5304:	00 00       	nop
    5306:	79 9b       	sbis	0x0f, 1	; 15
    5308:	f6 cf       	rjmp	.-20     	; 0x52f6 <main+0x162>
						Delay_MS(10); //poll connection status every 10ms.
						if (is_high(BT_CONNECTED)){break;} //break FOR loop
    530a:	79 99       	sbic	0x0f, 1	; 15
    530c:	07 c0       	rjmp	.+14     	; 0x531c <main+0x188>
				#endif
					
					if(Get_Bluetooth_State() != INITIALIZED){Bluetooth_Init();};//initialize bluetooth if it hasn't been already. this sets up proxy mode, too.
					if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}

				while(is_low(BT_CONNECTED)){	
    530e:	2e 98       	cbi	0x05, 6	; 5
    5310:	46 9a       	sbi	0x08, 6	; 8
					set_low(RED_LED);
    5312:	0e 94 90 05 	call	0xb20	; 0xb20 <Bluetooth_Connect>
					set_high(GREEN_LED);
					#if MODULE_NAME==EHONG
					Bluetooth_Connect();
    5316:	89 ee       	ldi	r24, 0xE9	; 233
    5318:	93 e0       	ldi	r25, 0x03	; 3
    531a:	ef cf       	rjmp	.-34     	; 0x52fa <main+0x166>
						Delay_MS(10); //poll connection status every 10ms.
						if (is_high(BT_CONNECTED)){break;} //break FOR loop
					}
					#endif
				}
				set_high(RED_LED);
    531c:	2e 9a       	sbi	0x05, 6	; 5
				set_low(GREEN_LED);
    531e:	46 98       	cbi	0x08, 6	; 8

				#if MODULE_NAME==EHONG
				Bluetooth_Send(0,0); //clear off keyboard report.
    5320:	60 e0       	ldi	r22, 0x00	; 0
    5322:	80 e0       	ldi	r24, 0x00	; 0
    5324:	0e 94 e7 03 	call	0x7ce	; 0x7ce <Bluetooth_Send>
				Bluetooth_Toggle_iOS_Keyboard();
    5328:	0e 94 37 04 	call	0x86e	; 0x86e <Bluetooth_Toggle_iOS_Keyboard>
				#endif

				//wait for connection to happen, glow red until then.
				while(is_high(BT_CONNECTED)){
    532c:	79 9b       	sbis	0x0f, 1	; 15


					key = GetKey();
    532e:	48 cf       	rjmp	.-368    	; 0x51c0 <main+0x2c>
    5330:	b0 d2       	rcall	.+1376   	; 0x5892 <GetKey>
    5332:	f8 2e       	mov	r15, r24
					modifier = GetModifier();
    5334:	a4 d1       	rcall	.+840    	; 0x567e <GetModifier>
    5336:	89 83       	std	Y+1, r24	; 0x01
    5338:	be 01       	movw	r22, r28
									
					code = GetHIDKeyCode(key, &modifier);
    533a:	6f 5f       	subi	r22, 0xFF	; 255
    533c:	7f 4f       	sbci	r23, 0xFF	; 255
    533e:	8f 2d       	mov	r24, r15
    5340:	ed d3       	rcall	.+2010   	; 0x5b1c <GetHIDKeyCode>
    5342:	88 23       	and	r24, r24
    5344:	19 f0       	breq	.+6      	; 0x534c <main+0x1b8>
					
	//				if(code == KEY_ESC){
	//					Bluetooth_Toggle_iOS_Keyboard();
	//				}
					if(code){
    5346:	69 81       	ldd	r22, Y+1	; 0x01
    5348:	0e 94 e7 03 	call	0x7ce	; 0x7ce <Bluetooth_Send>
						Bluetooth_Send(code,modifier);
    534c:	8f ec       	ldi	r24, 0xCF	; 207
    534e:	97 e0       	ldi	r25, 0x07	; 7
    5350:	01 97       	sbiw	r24, 0x01	; 1
    5352:	f1 f7       	brne	.-4      	; 0x5350 <main+0x1bc>
    5354:	00 c0       	rjmp	.+0      	; 0x5356 <main+0x1c2>
    5356:	00 00       	nop
    5358:	e9 cf       	rjmp	.-46     	; 0x532c <main+0x198>
    535a:	2e 9a       	sbi	0x05, 6	; 5
    535c:	46 98       	cbi	0x08, 6	; 8
			
			break;
			case PANIC_MODE:
				USB_Disable();
				while(1){
					set_high(LED2);
    535e:	9f ef       	ldi	r25, 0xFF	; 255
					set_low(LED1);
    5360:	e1 ee       	ldi	r30, 0xE1	; 225
    5362:	f4 e0       	ldi	r31, 0x04	; 4
    5364:	91 50       	subi	r25, 0x01	; 1
    5366:	e0 40       	sbci	r30, 0x00	; 0
    5368:	f0 40       	sbci	r31, 0x00	; 0
    536a:	e1 f7       	brne	.-8      	; 0x5364 <main+0x1d0>
    536c:	00 c0       	rjmp	.+0      	; 0x536e <main+0x1da>
    536e:	00 00       	nop
    5370:	46 9a       	sbi	0x08, 6	; 8
    5372:	2e 98       	cbi	0x05, 6	; 5
					Delay_MS(200);
					set_high(LED1);
    5374:	2f ef       	ldi	r18, 0xFF	; 255
					set_low(LED2);
    5376:	81 ee       	ldi	r24, 0xE1	; 225
    5378:	94 e0       	ldi	r25, 0x04	; 4
    537a:	21 50       	subi	r18, 0x01	; 1
    537c:	80 40       	sbci	r24, 0x00	; 0
    537e:	90 40       	sbci	r25, 0x00	; 0
    5380:	e1 f7       	brne	.-8      	; 0x537a <main+0x1e6>
    5382:	00 c0       	rjmp	.+0      	; 0x5384 <main+0x1f0>
    5384:	00 00       	nop
    5386:	e9 cf       	rjmp	.-46     	; 0x535a <main+0x1c6>
    5388:	0e 94 a4 0a 	call	0x1548	; 0x1548 <Adjust_Sensitivity>
					Delay_MS(200);
				}		
			break;
			case SENSITIVITY_MODE:
				Adjust_Sensitivity();
    538c:	10 93 69 07 	sts	0x0769, r17	; 0x800769 <Typewriter_Mode>
				Typewriter_Mode = USB_LIGHT_MODE;
    5390:	17 cf       	rjmp	.-466    	; 0x51c0 <main+0x2c>
    5392:	00 93 69 07 	sts	0x0769, r16	; 0x800769 <Typewriter_Mode>
			break;
			default:
				Typewriter_Mode = PANIC_MODE;
    5396:	14 cf       	rjmp	.-472    	; 0x51c0 <main+0x2c>

00005398 <USBSend>:
#include <ctype.h> // allows toupper()

extern USB_ClassInfo_HID_Device_t Keyboard_HID_Interface; //import the keyboard interface object from main routine so we can call usbtask on it.

/*Send a character over usb with a given modifier (shift, ctrl, etc)*/
void USBSend(uint8_t code,uint8_t mod){	
    5398:	cf 93       	push	r28
    539a:	df 93       	push	r29
    539c:	c8 2f       	mov	r28, r24
    539e:	d6 2f       	mov	r29, r22
	
	TMR1_Count = 0;
    53a0:	10 92 60 06 	sts	0x0660, r1	; 0x800660 <TMR1_Count+0x1>
    53a4:	10 92 5f 06 	sts	0x065F, r1	; 0x80065f <TMR1_Count>
	while (KeyBuffer->KeyCode[0] && TMR1_Count < USB_SEND_TIMEOUT) {
    53a8:	e0 91 64 06 	lds	r30, 0x0664	; 0x800664 <KeyBuffer>
    53ac:	f0 91 65 06 	lds	r31, 0x0665	; 0x800665 <KeyBuffer+0x1>
    53b0:	82 81       	ldd	r24, Z+2	; 0x02
    53b2:	88 23       	and	r24, r24
    53b4:	99 f0       	breq	.+38     	; 0x53dc <USBSend+0x44>
    53b6:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <TMR1_Count>
    53ba:	90 91 60 06 	lds	r25, 0x0660	; 0x800660 <TMR1_Count+0x1>
    53be:	84 36       	cpi	r24, 0x64	; 100
    53c0:	91 05       	cpc	r25, r1
    53c2:	60 f4       	brcc	.+24     	; 0x53dc <USBSend+0x44>
		if((Typewriter_Mode == USB_COMBO_MODE) || (Typewriter_Mode == USB_LIGHT_MODE)){ //interrupts do not handle keyboard stuff during this mode.
    53c4:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <Typewriter_Mode>
    53c8:	81 30       	cpi	r24, 0x01	; 1
    53ca:	21 f0       	breq	.+8      	; 0x53d4 <USBSend+0x3c>
    53cc:	80 91 69 07 	lds	r24, 0x0769	; 0x800769 <Typewriter_Mode>
    53d0:	8d 30       	cpi	r24, 0x0D	; 13
    53d2:	51 f7       	brne	.-44     	; 0x53a8 <USBSend+0x10>
			HID_Device_USBTask(&Keyboard_HID_Interface);
    53d4:	80 e2       	ldi	r24, 0x20	; 32
    53d6:	91 e0       	ldi	r25, 0x01	; 1
    53d8:	fb d5       	rcall	.+3062   	; 0x5fd0 <HID_Device_USBTask>
    53da:	e6 cf       	rjmp	.-52     	; 0x53a8 <USBSend+0x10>
		} //if buffer is full, wait.  If timeout expires, stop waiting.
	}
	
	if (code&FORCE_UPPER){ //in this program, we use the MSB of code to indicate that this key MUST be sent as upper case.
    53dc:	c7 ff       	sbrs	r28, 7
    53de:	02 c0       	rjmp	.+4      	; 0x53e4 <USBSend+0x4c>
		reg_clr(code,FORCE_UPPER); //clear the MSB,  
    53e0:	cf 77       	andi	r28, 0x7F	; 127
		mod = UPPER; //and set the modifier to upper case.
    53e2:	d2 e0       	ldi	r29, 0x02	; 2
	}
	
	if(code == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
    53e4:	c4 37       	cpi	r28, 0x74	; 116
    53e6:	11 f4       	brne	.+4      	; 0x53ec <USBSend+0x54>
		code = KEY_ENTER;
		mod = HID_KEYBOARD_MODIFIER_LEFTCTRL;
    53e8:	d1 e0       	ldi	r29, 0x01	; 1
		reg_clr(code,FORCE_UPPER); //clear the MSB,  
		mod = UPPER; //and set the modifier to upper case.
	}
	
	if(code == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
		code = KEY_ENTER;
    53ea:	c8 e2       	ldi	r28, 0x28	; 40
		mod = HID_KEYBOARD_MODIFIER_LEFTCTRL;
	}
	
	cli();//make sure there are no interrupts between setting code and setting the modifier that goes with it.
    53ec:	f8 94       	cli
	KeyBuffer->KeyCode[0] = code; //cue up keycode to be sent during next LUFA HID callback function.
    53ee:	e0 91 64 06 	lds	r30, 0x0664	; 0x800664 <KeyBuffer>
    53f2:	f0 91 65 06 	lds	r31, 0x0665	; 0x800665 <KeyBuffer+0x1>
    53f6:	c2 83       	std	Z+2, r28	; 0x02
	KeyBufferMod = mod;
    53f8:	d0 93 1b 06 	sts	0x061B, r29	; 0x80061b <KeyBufferMod>
	HID_Device_USBTask(&Keyboard_HID_Interface); //Dean Camera says to call this function regularly -- right after sending a character seems like an appropriate time.
    53fc:	80 e2       	ldi	r24, 0x20	; 32
    53fe:	91 e0       	ldi	r25, 0x01	; 1
    5400:	e7 d5       	rcall	.+3022   	; 0x5fd0 <HID_Device_USBTask>
	sei();//re-enable the interrupts.
    5402:	78 94       	sei
    5404:	8f e3       	ldi	r24, 0x3F	; 63
    5406:	9c e9       	ldi	r25, 0x9C	; 156
    5408:	01 97       	sbiw	r24, 0x01	; 1
    540a:	f1 f7       	brne	.-4      	; 0x5408 <USBSend+0x70>
    540c:	00 c0       	rjmp	.+0      	; 0x540e <USBSend+0x76>
    540e:	00 00       	nop
	
	Delay_MS(USB_SEND_DELAY);// wait X ms after sending each character.
	
	cli();//make sure no interrupts occur during the usb task.
    5410:	f8 94       	cli
	HID_Device_USBTask(&Keyboard_HID_Interface); //do LUFA hid usb tasks
    5412:	80 e2       	ldi	r24, 0x20	; 32
    5414:	91 e0       	ldi	r25, 0x01	; 1
    5416:	dc d5       	rcall	.+3000   	; 0x5fd0 <HID_Device_USBTask>
	sei();
    5418:	78 94       	sei
}
    541a:	df 91       	pop	r29
    541c:	cf 91       	pop	r28
    541e:	08 95       	ret

00005420 <USBSendString>:

/*Send a string over USB. Only supports some characters.*/
void USBSendString(char *str){
    5420:	ef 92       	push	r14
    5422:	ff 92       	push	r15
    5424:	0f 93       	push	r16
    5426:	1f 93       	push	r17
    5428:	cf 93       	push	r28
    542a:	df 93       	push	r29
    542c:	8c 01       	movw	r16, r24
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
    542e:	fc 01       	movw	r30, r24
    5430:	01 90       	ld	r0, Z+
    5432:	00 20       	and	r0, r0
    5434:	e9 f7       	brne	.-6      	; 0x5430 <USBSendString+0x10>
    5436:	31 97       	sbiw	r30, 0x01	; 1
    5438:	ef 01       	movw	r28, r30
    543a:	c8 1b       	sub	r28, r24
    543c:	d9 0b       	sbc	r29, r25
	for (int i=0; i<length; i++){
    543e:	7c 01       	movw	r14, r24
    5440:	c7 01       	movw	r24, r14
    5442:	80 1b       	sub	r24, r16
    5444:	91 0b       	sbc	r25, r17
    5446:	8c 17       	cp	r24, r28
    5448:	9d 07       	cpc	r25, r29
    544a:	0c f0       	brlt	.+2      	; 0x544e <USBSendString+0x2e>
    544c:	5f c0       	rjmp	.+190    	; 0x550c <USBSendString+0xec>
		modifier = LOWER;
		if(str[i] == ' '){
    544e:	f7 01       	movw	r30, r14
    5450:	81 91       	ld	r24, Z+
    5452:	7f 01       	movw	r14, r30
    5454:	80 32       	cpi	r24, 0x20	; 32
    5456:	49 f1       	breq	.+82     	; 0x54aa <USBSendString+0x8a>
			code = KEY_SPACE;
		}
		else if(str[i] == '('){
    5458:	88 32       	cpi	r24, 0x28	; 40
    545a:	51 f1       	breq	.+84     	; 0x54b0 <USBSendString+0x90>
			code = KEY_9;
			modifier = UPPER;
		}
		else if(str[i] == ')'){
    545c:	89 32       	cpi	r24, 0x29	; 41
    545e:	59 f1       	breq	.+86     	; 0x54b6 <USBSendString+0x96>
			code = KEY_0;
			modifier = UPPER;
		}
		else if(str[i] == '/'){
    5460:	8f 32       	cpi	r24, 0x2F	; 47
    5462:	59 f1       	breq	.+86     	; 0x54ba <USBSendString+0x9a>
			code = KEY_SLASH;
		}
		else if(str[i] == '?'){
    5464:	8f 33       	cpi	r24, 0x3F	; 63
    5466:	59 f1       	breq	.+86     	; 0x54be <USBSendString+0x9e>
			code = KEY_SLASH;
			modifier = UPPER;
		}
		else if(str[i] == ':'){
    5468:	8a 33       	cpi	r24, 0x3A	; 58
    546a:	61 f1       	breq	.+88     	; 0x54c4 <USBSendString+0xa4>
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
    546c:	8d 30       	cpi	r24, 0x0D	; 13
    546e:	69 f1       	breq	.+90     	; 0x54ca <USBSendString+0xaa>
    5470:	8a 30       	cpi	r24, 0x0A	; 10
    5472:	59 f1       	breq	.+86     	; 0x54ca <USBSendString+0xaa>
			code = KEY_ENTER;
		}
		else if(str[i] == '.'){
    5474:	8e 32       	cpi	r24, 0x2E	; 46
    5476:	61 f1       	breq	.+88     	; 0x54d0 <USBSendString+0xb0>
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if(str[i] == '='){
    5478:	8d 33       	cpi	r24, 0x3D	; 61
    547a:	69 f1       	breq	.+90     	; 0x54d6 <USBSendString+0xb6>
			code = KEY_EQ;
			modifier = LOWER;
		}
		else if(str[i] == '+'){
    547c:	8b 32       	cpi	r24, 0x2B	; 43
    547e:	69 f1       	breq	.+90     	; 0x54da <USBSendString+0xba>
			code = KEY_EQ;
			modifier = UPPER;
		}
		else if(str[i] == '\t'){
    5480:	89 30       	cpi	r24, 0x09	; 9
    5482:	71 f1       	breq	.+92     	; 0x54e0 <USBSendString+0xc0>
			code = KEY_TAB;
			modifier = LOWER;
		}
		else if(str[i] == '#'){
    5484:	83 32       	cpi	r24, 0x23	; 35
    5486:	79 f1       	breq	.+94     	; 0x54e6 <USBSendString+0xc6>
			code = KEY_1 +2;
			modifier = UPPER;
		}
		else if(str[i] == '!'){
    5488:	81 32       	cpi	r24, 0x21	; 33
    548a:	81 f1       	breq	.+96     	; 0x54ec <USBSendString+0xcc>
			code = KEY_1;
			modifier = UPPER;
		}
		else if(str[i] == '0'){
    548c:	80 33       	cpi	r24, 0x30	; 48
    548e:	89 f1       	breq	.+98     	; 0x54f2 <USBSendString+0xd2>
			code = KEY_0;
		}
		else if((str[i] >= ASCII_1 )&&(str[i] <= ASCII_9)){
    5490:	9f ec       	ldi	r25, 0xCF	; 207
    5492:	98 0f       	add	r25, r24
    5494:	99 30       	cpi	r25, 0x09	; 9
    5496:	18 f4       	brcc	.+6      	; 0x549e <USBSendString+0x7e>
			code = str[i] - ASCII_1 + KEY_1; //translate ascii to hid number code 
    5498:	83 51       	subi	r24, 0x13	; 19
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    549a:	60 e0       	ldi	r22, 0x00	; 0
    549c:	2c c0       	rjmp	.+88     	; 0x54f6 <USBSendString+0xd6>
		}
		else if((str[i] >= ASCII_1 )&&(str[i] <= ASCII_9)){
			code = str[i] - ASCII_1 + KEY_1; //translate ascii to hid number code 
		}
		else{
			code = toupper(str[i]);//make sure code is uppercase.
    549e:	90 e0       	ldi	r25, 0x00	; 0
    54a0:	0e 94 86 38 	call	0x710c	; 0x710c <toupper>
			code = code-ASCII_A+KEY_A;  //Convert the character (which is uppercase Ascii)  to an USB HID Keycode.
    54a4:	8d 53       	subi	r24, 0x3D	; 61
			modifier = UPPER;
    54a6:	62 e0       	ldi	r22, 0x02	; 2
    54a8:	26 c0       	rjmp	.+76     	; 0x54f6 <USBSendString+0xd6>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    54aa:	60 e0       	ldi	r22, 0x00	; 0
		if(str[i] == ' '){
			code = KEY_SPACE;
    54ac:	8c e2       	ldi	r24, 0x2C	; 44
    54ae:	23 c0       	rjmp	.+70     	; 0x54f6 <USBSendString+0xd6>
		}
		else if(str[i] == '('){
			code = KEY_9;
			modifier = UPPER;
    54b0:	62 e0       	ldi	r22, 0x02	; 2
		modifier = LOWER;
		if(str[i] == ' '){
			code = KEY_SPACE;
		}
		else if(str[i] == '('){
			code = KEY_9;
    54b2:	86 e2       	ldi	r24, 0x26	; 38
    54b4:	20 c0       	rjmp	.+64     	; 0x54f6 <USBSendString+0xd6>
			modifier = UPPER;
		}
		else if(str[i] == ')'){
			code = KEY_0;
			modifier = UPPER;
    54b6:	62 e0       	ldi	r22, 0x02	; 2
    54b8:	1d c0       	rjmp	.+58     	; 0x54f4 <USBSendString+0xd4>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    54ba:	60 e0       	ldi	r22, 0x00	; 0
    54bc:	01 c0       	rjmp	.+2      	; 0x54c0 <USBSendString+0xa0>
		else if(str[i] == '/'){
			code = KEY_SLASH;
		}
		else if(str[i] == '?'){
			code = KEY_SLASH;
			modifier = UPPER;
    54be:	62 e0       	ldi	r22, 0x02	; 2
		}
		else if(str[i] == '/'){
			code = KEY_SLASH;
		}
		else if(str[i] == '?'){
			code = KEY_SLASH;
    54c0:	88 e3       	ldi	r24, 0x38	; 56
    54c2:	19 c0       	rjmp	.+50     	; 0x54f6 <USBSendString+0xd6>
			modifier = UPPER;
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
    54c4:	62 e0       	ldi	r22, 0x02	; 2
		else if(str[i] == '?'){
			code = KEY_SLASH;
			modifier = UPPER;
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
    54c6:	83 e3       	ldi	r24, 0x33	; 51
    54c8:	16 c0       	rjmp	.+44     	; 0x54f6 <USBSendString+0xd6>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    54ca:	60 e0       	ldi	r22, 0x00	; 0
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
			code = KEY_ENTER;
    54cc:	88 e2       	ldi	r24, 0x28	; 40
    54ce:	13 c0       	rjmp	.+38     	; 0x54f6 <USBSendString+0xd6>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    54d0:	60 e0       	ldi	r22, 0x00	; 0
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
			code = KEY_ENTER;
		}
		else if(str[i] == '.'){
			code = KEY_PERIOD;
    54d2:	87 e3       	ldi	r24, 0x37	; 55
    54d4:	10 c0       	rjmp	.+32     	; 0x54f6 <USBSendString+0xd6>
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if(str[i] == '='){
			code = KEY_EQ;
			modifier = LOWER;
    54d6:	60 e0       	ldi	r22, 0x00	; 0
    54d8:	01 c0       	rjmp	.+2      	; 0x54dc <USBSendString+0xbc>
		}
		else if(str[i] == '+'){
			code = KEY_EQ;
			modifier = UPPER;
    54da:	62 e0       	ldi	r22, 0x02	; 2
		else if(str[i] == '='){
			code = KEY_EQ;
			modifier = LOWER;
		}
		else if(str[i] == '+'){
			code = KEY_EQ;
    54dc:	8e e2       	ldi	r24, 0x2E	; 46
    54de:	0b c0       	rjmp	.+22     	; 0x54f6 <USBSendString+0xd6>
			modifier = UPPER;
		}
		else if(str[i] == '\t'){
			code = KEY_TAB;
			modifier = LOWER;
    54e0:	60 e0       	ldi	r22, 0x00	; 0
		else if(str[i] == '+'){
			code = KEY_EQ;
			modifier = UPPER;
		}
		else if(str[i] == '\t'){
			code = KEY_TAB;
    54e2:	8b e2       	ldi	r24, 0x2B	; 43
    54e4:	08 c0       	rjmp	.+16     	; 0x54f6 <USBSendString+0xd6>
			modifier = LOWER;
		}
		else if(str[i] == '#'){
			code = KEY_1 +2;
			modifier = UPPER;
    54e6:	62 e0       	ldi	r22, 0x02	; 2
		else if(str[i] == '\t'){
			code = KEY_TAB;
			modifier = LOWER;
		}
		else if(str[i] == '#'){
			code = KEY_1 +2;
    54e8:	80 e2       	ldi	r24, 0x20	; 32
    54ea:	05 c0       	rjmp	.+10     	; 0x54f6 <USBSendString+0xd6>
			modifier = UPPER;
		}
		else if(str[i] == '!'){
			code = KEY_1;
			modifier = UPPER;
    54ec:	62 e0       	ldi	r22, 0x02	; 2
		else if(str[i] == '#'){
			code = KEY_1 +2;
			modifier = UPPER;
		}
		else if(str[i] == '!'){
			code = KEY_1;
    54ee:	8e e1       	ldi	r24, 0x1E	; 30
    54f0:	02 c0       	rjmp	.+4      	; 0x54f6 <USBSendString+0xd6>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    54f2:	60 e0       	ldi	r22, 0x00	; 0
		else if(str[i] == '!'){
			code = KEY_1;
			modifier = UPPER;
		}
		else if(str[i] == '0'){
			code = KEY_0;
    54f4:	87 e2       	ldi	r24, 0x27	; 39
		else{
			code = toupper(str[i]);//make sure code is uppercase.
			code = code-ASCII_A+KEY_A;  //Convert the character (which is uppercase Ascii)  to an USB HID Keycode.
			modifier = UPPER;
		}
		USBSend(code,modifier);
    54f6:	50 df       	rcall	.-352    	; 0x5398 <USBSend>
    54f8:	ff e7       	ldi	r31, 0x7F	; 127
    54fa:	28 e3       	ldi	r18, 0x38	; 56
    54fc:	81 e0       	ldi	r24, 0x01	; 1
    54fe:	f1 50       	subi	r31, 0x01	; 1
    5500:	20 40       	sbci	r18, 0x00	; 0
    5502:	80 40       	sbci	r24, 0x00	; 0
    5504:	e1 f7       	brne	.-8      	; 0x54fe <USBSendString+0xde>
    5506:	00 c0       	rjmp	.+0      	; 0x5508 <USBSendString+0xe8>
    5508:	00 00       	nop
    550a:	9a cf       	rjmp	.-204    	; 0x5440 <USBSendString+0x20>
		Delay_MS(STRING_SEND_DELAY);
	}
} 
    550c:	df 91       	pop	r29
    550e:	cf 91       	pop	r28
    5510:	1f 91       	pop	r17
    5512:	0f 91       	pop	r16
    5514:	ff 90       	pop	r15
    5516:	ef 90       	pop	r14
    5518:	08 95       	ret

0000551a <USBSendPROGString>:

/*Send a string literal to Bluetooth Module, using a string stored in program memory instead of data memory (this saves RAM)*/
void USBSendPROGString(const char*  ProgStr){
	strcpy_P(StringBuffer, (char*) ProgStr);
    551a:	bc 01       	movw	r22, r24
    551c:	8c ee       	ldi	r24, 0xEC	; 236
    551e:	96 e0       	ldi	r25, 0x06	; 6
    5520:	0e 94 8e 38 	call	0x711c	; 0x711c <strcpy_P>
	USBSendString(StringBuffer);
    5524:	8c ee       	ldi	r24, 0xEC	; 236
    5526:	96 e0       	ldi	r25, 0x06	; 6
    5528:	7b cf       	rjmp	.-266    	; 0x5420 <USBSendString>

0000552a <USBSendNumber>:
}

/*Send a number between 0 and 255 over usb)*/
void USBSendNumber(uint8_t number){
    552a:	1f 93       	push	r17
    552c:	cf 93       	push	r28
    552e:	df 93       	push	r29
    5530:	28 2f       	mov	r18, r24
	uint8_t ones ;
	uint8_t tens;
	
	ones = number%10;
    5532:	6a e0       	ldi	r22, 0x0A	; 10
    5534:	0e 94 b4 37 	call	0x6f68	; 0x6f68 <__udivmodqi4>
    5538:	c9 2f       	mov	r28, r25
	tens = ((number - ones)%100)/10;
    553a:	82 2f       	mov	r24, r18
    553c:	90 e0       	ldi	r25, 0x00	; 0
    553e:	8c 1b       	sub	r24, r28
    5540:	91 09       	sbc	r25, r1
    5542:	64 e6       	ldi	r22, 0x64	; 100
    5544:	70 e0       	ldi	r23, 0x00	; 0
    5546:	0e 94 c0 37 	call	0x6f80	; 0x6f80 <__divmodhi4>
    554a:	6a e0       	ldi	r22, 0x0A	; 10
    554c:	70 e0       	ldi	r23, 0x00	; 0
    554e:	0e 94 c0 37 	call	0x6f80	; 0x6f80 <__divmodhi4>
    5552:	d6 2f       	mov	r29, r22
    5554:	16 2f       	mov	r17, r22
	
	if (number >= 200){
    5556:	28 3c       	cpi	r18, 0xC8	; 200
    5558:	18 f0       	brcs	.+6      	; 0x5560 <USBSendNumber+0x36>
		USBSend(KEY_2,LOWER);
    555a:	60 e0       	ldi	r22, 0x00	; 0
    555c:	8f e1       	ldi	r24, 0x1F	; 31
    555e:	04 c0       	rjmp	.+8      	; 0x5568 <USBSendNumber+0x3e>
	}
	else if (number >= 100){
    5560:	24 36       	cpi	r18, 0x64	; 100
    5562:	18 f0       	brcs	.+6      	; 0x556a <USBSendNumber+0x40>
		USBSend(KEY_1,LOWER);
    5564:	60 e0       	ldi	r22, 0x00	; 0
    5566:	8e e1       	ldi	r24, 0x1E	; 30
    5568:	17 df       	rcall	.-466    	; 0x5398 <USBSend>
	}
	
	if (tens != 0){
		USBSend(29+tens,LOWER);
    556a:	60 e0       	ldi	r22, 0x00	; 0
	}
	else if (number >= 100){
		USBSend(KEY_1,LOWER);
	}
	
	if (tens != 0){
    556c:	11 23       	and	r17, r17
    556e:	19 f0       	breq	.+6      	; 0x5576 <USBSendNumber+0x4c>
		USBSend(29+tens,LOWER);
    5570:	8d e1       	ldi	r24, 0x1D	; 29
    5572:	8d 0f       	add	r24, r29
    5574:	01 c0       	rjmp	.+2      	; 0x5578 <USBSendNumber+0x4e>
	}
	else{
		USBSend(39,LOWER);
    5576:	87 e2       	ldi	r24, 0x27	; 39
    5578:	0f df       	rcall	.-482    	; 0x5398 <USBSend>
    557a:	2f ef       	ldi	r18, 0xFF	; 255
    557c:	80 e7       	ldi	r24, 0x70	; 112
    557e:	92 e0       	ldi	r25, 0x02	; 2
    5580:	21 50       	subi	r18, 0x01	; 1
    5582:	80 40       	sbci	r24, 0x00	; 0
    5584:	90 40       	sbci	r25, 0x00	; 0
    5586:	e1 f7       	brne	.-8      	; 0x5580 <USBSendNumber+0x56>
    5588:	00 c0       	rjmp	.+0      	; 0x558a <USBSendNumber+0x60>
    558a:	00 00       	nop
	}

	Delay_MS(100);
	
	if (ones!=0){
		USBSend(29+ones,LOWER);
    558c:	60 e0       	ldi	r22, 0x00	; 0
		USBSend(39,LOWER);
	}

	Delay_MS(100);
	
	if (ones!=0){
    558e:	cc 23       	and	r28, r28
    5590:	19 f0       	breq	.+6      	; 0x5598 <USBSendNumber+0x6e>
		USBSend(29+ones,LOWER);
    5592:	8d e1       	ldi	r24, 0x1D	; 29
    5594:	8c 0f       	add	r24, r28
	}
	else{
		USBSend(39,LOWER);
    5596:	01 c0       	rjmp	.+2      	; 0x559a <USBSendNumber+0x70>
    5598:	87 e2       	ldi	r24, 0x27	; 39
    559a:	fe de       	rcall	.-516    	; 0x5398 <USBSend>
    559c:	2f ef       	ldi	r18, 0xFF	; 255
    559e:	80 e7       	ldi	r24, 0x70	; 112
    55a0:	92 e0       	ldi	r25, 0x02	; 2
    55a2:	21 50       	subi	r18, 0x01	; 1
    55a4:	80 40       	sbci	r24, 0x00	; 0
    55a6:	90 40       	sbci	r25, 0x00	; 0
    55a8:	e1 f7       	brne	.-8      	; 0x55a2 <USBSendNumber+0x78>
    55aa:	00 c0       	rjmp	.+0      	; 0x55ac <USBSendNumber+0x82>
    55ac:	00 00       	nop
	}
	
	Delay_MS(100);

}
    55ae:	df 91       	pop	r29
    55b0:	cf 91       	pop	r28
    55b2:	1f 91       	pop	r17
    55b4:	08 95       	ret

000055b6 <USBSendASCII>:

/*Send an ascii character between 0 and 255 over usb)*/
void USBSendASCII(uint8_t number){
    55b6:	0f 93       	push	r16
    55b8:	1f 93       	push	r17
    55ba:	cf 93       	push	r28
    55bc:	df 93       	push	r29
    55be:	c8 2f       	mov	r28, r24
	uint8_t ones ;
	uint8_t tens;
	
	ones = number%10;
    55c0:	6a e0       	ldi	r22, 0x0A	; 10
    55c2:	0e 94 b4 37 	call	0x6f68	; 0x6f68 <__udivmodqi4>
    55c6:	d9 2f       	mov	r29, r25
	tens = ((number - ones)%100)/10;
    55c8:	8c 2f       	mov	r24, r28
    55ca:	90 e0       	ldi	r25, 0x00	; 0
    55cc:	8d 1b       	sub	r24, r29
    55ce:	91 09       	sbc	r25, r1
    55d0:	64 e6       	ldi	r22, 0x64	; 100
    55d2:	70 e0       	ldi	r23, 0x00	; 0
    55d4:	0e 94 c0 37 	call	0x6f80	; 0x6f80 <__divmodhi4>
    55d8:	6a e0       	ldi	r22, 0x0A	; 10
    55da:	70 e0       	ldi	r23, 0x00	; 0
    55dc:	0e 94 c0 37 	call	0x6f80	; 0x6f80 <__divmodhi4>
    55e0:	16 2f       	mov	r17, r22
    55e2:	06 2f       	mov	r16, r22
	
	Hold_Alt_Down = true; //hold down the alt key
    55e4:	81 e0       	ldi	r24, 0x01	; 1
    55e6:	80 93 67 06 	sts	0x0667, r24	; 0x800667 <Hold_Alt_Down>
    55ea:	2f ef       	ldi	r18, 0xFF	; 255
    55ec:	80 e7       	ldi	r24, 0x70	; 112
    55ee:	92 e0       	ldi	r25, 0x02	; 2
    55f0:	21 50       	subi	r18, 0x01	; 1
    55f2:	80 40       	sbci	r24, 0x00	; 0
    55f4:	90 40       	sbci	r25, 0x00	; 0
    55f6:	e1 f7       	brne	.-8      	; 0x55f0 <USBSendASCII+0x3a>
    55f8:	00 c0       	rjmp	.+0      	; 0x55fa <USBSendASCII+0x44>
    55fa:	00 00       	nop
	
	Delay_MS(100);
	
	if(number>=0x80){//leading zero indicates utf-8 instead of extended ascii format
    55fc:	c7 ff       	sbrs	r28, 7
    55fe:	08 c0       	rjmp	.+16     	; 0x5610 <USBSendASCII+0x5a>
		USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT, LOWER); //send a leading 0
    5600:	60 e0       	ldi	r22, 0x00	; 0
    5602:	82 e6       	ldi	r24, 0x62	; 98
    5604:	c9 de       	rcall	.-622    	; 0x5398 <USBSend>
	}
	
	//send hundreds digit
	if (number >= 200){  
    5606:	c8 3c       	cpi	r28, 0xC8	; 200
    5608:	28 f0       	brcs	.+10     	; 0x5614 <USBSendASCII+0x5e>
		USBSend(HID_KEYBOARD_SC_KEYPAD_2_AND_DOWN_ARROW,LOWER);
    560a:	60 e0       	ldi	r22, 0x00	; 0
    560c:	8a e5       	ldi	r24, 0x5A	; 90
    560e:	04 c0       	rjmp	.+8      	; 0x5618 <USBSendASCII+0x62>
	}
	else if (number >= 100){
    5610:	c4 36       	cpi	r28, 0x64	; 100
    5612:	18 f0       	brcs	.+6      	; 0x561a <USBSendASCII+0x64>
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END, LOWER);
    5614:	60 e0       	ldi	r22, 0x00	; 0
    5616:	89 e5       	ldi	r24, 0x59	; 89
    5618:	bf de       	rcall	.-642    	; 0x5398 <USBSend>
    561a:	2f e7       	ldi	r18, 0x7F	; 127
    561c:	88 e3       	ldi	r24, 0x38	; 56
    561e:	91 e0       	ldi	r25, 0x01	; 1
    5620:	21 50       	subi	r18, 0x01	; 1
    5622:	80 40       	sbci	r24, 0x00	; 0
    5624:	90 40       	sbci	r25, 0x00	; 0
    5626:	e1 f7       	brne	.-8      	; 0x5620 <USBSendASCII+0x6a>
    5628:	00 c0       	rjmp	.+0      	; 0x562a <USBSendASCII+0x74>
    562a:	00 00       	nop
	}
	Delay_MS(50);
	
	//send tens digit
	if (tens != 0){
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END + tens -1,LOWER); //send 1-9
    562c:	60 e0       	ldi	r22, 0x00	; 0
//		USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT, LOWER);
	}
	Delay_MS(50);
	
	//send tens digit
	if (tens != 0){
    562e:	00 23       	and	r16, r16
    5630:	19 f0       	breq	.+6      	; 0x5638 <USBSendASCII+0x82>
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END + tens -1,LOWER); //send 1-9
    5632:	88 e5       	ldi	r24, 0x58	; 88
    5634:	81 0f       	add	r24, r17
	}
	else{
		USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT,LOWER); //send 0
    5636:	01 c0       	rjmp	.+2      	; 0x563a <USBSendASCII+0x84>
    5638:	82 e6       	ldi	r24, 0x62	; 98
    563a:	ae de       	rcall	.-676    	; 0x5398 <USBSend>
    563c:	2f e7       	ldi	r18, 0x7F	; 127
    563e:	88 e3       	ldi	r24, 0x38	; 56
    5640:	91 e0       	ldi	r25, 0x01	; 1
    5642:	21 50       	subi	r18, 0x01	; 1
    5644:	80 40       	sbci	r24, 0x00	; 0
    5646:	90 40       	sbci	r25, 0x00	; 0
    5648:	e1 f7       	brne	.-8      	; 0x5642 <USBSendASCII+0x8c>
    564a:	00 c0       	rjmp	.+0      	; 0x564c <USBSendASCII+0x96>
    564c:	00 00       	nop

	Delay_MS(50);
	
	//send ones digit
	if (ones!=0){
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END + ones -1,LOWER);
    564e:	60 e0       	ldi	r22, 0x00	; 0
	}

	Delay_MS(50);
	
	//send ones digit
	if (ones!=0){
    5650:	dd 23       	and	r29, r29
    5652:	19 f0       	breq	.+6      	; 0x565a <USBSendASCII+0xa4>
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END + ones -1,LOWER);
    5654:	88 e5       	ldi	r24, 0x58	; 88
    5656:	8d 0f       	add	r24, r29
	}
	else{
		USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT,LOWER);
    5658:	01 c0       	rjmp	.+2      	; 0x565c <USBSendASCII+0xa6>
    565a:	82 e6       	ldi	r24, 0x62	; 98
    565c:	9d de       	rcall	.-710    	; 0x5398 <USBSend>
    565e:	2f ef       	ldi	r18, 0xFF	; 255
    5660:	80 e7       	ldi	r24, 0x70	; 112
    5662:	92 e0       	ldi	r25, 0x02	; 2
    5664:	21 50       	subi	r18, 0x01	; 1
    5666:	80 40       	sbci	r24, 0x00	; 0
    5668:	90 40       	sbci	r25, 0x00	; 0
    566a:	e1 f7       	brne	.-8      	; 0x5664 <USBSendASCII+0xae>
    566c:	00 c0       	rjmp	.+0      	; 0x566e <USBSendASCII+0xb8>
    566e:	00 00       	nop
	}
	
	Delay_MS(100);
	
	//release alt key
	Hold_Alt_Down = false;
    5670:	10 92 67 06 	sts	0x0667, r1	; 0x800667 <Hold_Alt_Down>

}
    5674:	df 91       	pop	r29
    5676:	cf 91       	pop	r28
    5678:	1f 91       	pop	r17
    567a:	0f 91       	pop	r16
    567c:	08 95       	ret

0000567e <GetModifier>:

uint8_t GetModifier(){
	uint8_t Modifier = 0;
	bool ShiftIsPressed = false;
	
	switch (Shift_Reed){
    567e:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <Shift_Reed>
    5682:	82 30       	cpi	r24, 0x02	; 2
    5684:	99 f0       	breq	.+38     	; 0x56ac <GetModifier+0x2e>
    5686:	40 f4       	brcc	.+16     	; 0x5698 <GetModifier+0x1a>
    5688:	81 30       	cpi	r24, 0x01	; 1
    568a:	09 f5       	brne	.+66     	; 0x56ce <GetModifier+0x50>
	case 0: ShiftIsPressed = false; break;// if shift reed is 0, no shift key has been programed;
	case 1: ShiftIsPressed = (is_high(REED_1) == Reed1Polarity); break; //test if reed_1 is at the active level (high/low) indicated by reed1polarity
    568c:	89 b1       	in	r24, 0x09	; 9
    568e:	82 95       	swap	r24
    5690:	81 70       	andi	r24, 0x01	; 1
    5692:	90 91 68 06 	lds	r25, 0x0668	; 0x800668 <Reed1Polarity>
    5696:	17 c0       	rjmp	.+46     	; 0x56c6 <GetModifier+0x48>

uint8_t GetModifier(){
	uint8_t Modifier = 0;
	bool ShiftIsPressed = false;
	
	switch (Shift_Reed){
    5698:	83 30       	cpi	r24, 0x03	; 3
    569a:	79 f0       	breq	.+30     	; 0x56ba <GetModifier+0x3c>
    569c:	84 30       	cpi	r24, 0x04	; 4
    569e:	b9 f4       	brne	.+46     	; 0x56ce <GetModifier+0x50>
	case 0: ShiftIsPressed = false; break;// if shift reed is 0, no shift key has been programed;
	case 1: ShiftIsPressed = (is_high(REED_1) == Reed1Polarity); break; //test if reed_1 is at the active level (high/low) indicated by reed1polarity
	case 2: ShiftIsPressed = (is_high(REED_2) == Reed2Polarity); break;
	case 3: ShiftIsPressed = (is_high(REED_3) == Reed3Polarity); break;
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
    56a0:	83 b1       	in	r24, 0x03	; 3
    56a2:	82 95       	swap	r24
    56a4:	81 70       	andi	r24, 0x01	; 1
    56a6:	90 91 28 07 	lds	r25, 0x0728	; 0x800728 <Reed4Polarity>
    56aa:	0d c0       	rjmp	.+26     	; 0x56c6 <GetModifier+0x48>
	bool ShiftIsPressed = false;
	
	switch (Shift_Reed){
	case 0: ShiftIsPressed = false; break;// if shift reed is 0, no shift key has been programed;
	case 1: ShiftIsPressed = (is_high(REED_1) == Reed1Polarity); break; //test if reed_1 is at the active level (high/low) indicated by reed1polarity
	case 2: ShiftIsPressed = (is_high(REED_2) == Reed2Polarity); break;
    56ac:	89 b1       	in	r24, 0x09	; 9
    56ae:	86 fb       	bst	r24, 6
    56b0:	88 27       	eor	r24, r24
    56b2:	80 f9       	bld	r24, 0
    56b4:	90 91 16 06 	lds	r25, 0x0616	; 0x800616 <Reed2Polarity>
    56b8:	06 c0       	rjmp	.+12     	; 0x56c6 <GetModifier+0x48>
	case 3: ShiftIsPressed = (is_high(REED_3) == Reed3Polarity); break;
    56ba:	89 b1       	in	r24, 0x09	; 9
    56bc:	88 1f       	adc	r24, r24
    56be:	88 27       	eor	r24, r24
    56c0:	88 1f       	adc	r24, r24
    56c2:	90 91 ea 06 	lds	r25, 0x06EA	; 0x8006ea <Reed3Polarity>
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
    56c6:	89 13       	cpse	r24, r25
    56c8:	02 c0       	rjmp	.+4      	; 0x56ce <GetModifier+0x50>
	default: ShiftIsPressed = false;
	}
	
	if(ShiftIsPressed) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTSHIFT;}
    56ca:	82 e0       	ldi	r24, 0x02	; 2
    56cc:	01 c0       	rjmp	.+2      	; 0x56d0 <GetModifier+0x52>

const uint8_t REED_BITS[] = {62,61,60,59}; //these are the bits of the sensor array that represent the reed switches


uint8_t GetModifier(){
	uint8_t Modifier = 0;
    56ce:	80 e0       	ldi	r24, 0x00	; 0
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
	default: ShiftIsPressed = false;
	}
	
	if(ShiftIsPressed) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTSHIFT;}
	if(is_low(CTRL_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTCTRL;}
    56d0:	7c 9b       	sbis	0x0f, 4	; 15
    56d2:	81 60       	ori	r24, 0x01	; 1
	if(is_low(ALT_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTALT;}
    56d4:	7d 9b       	sbis	0x0f, 5	; 15
    56d6:	84 60       	ori	r24, 0x04	; 4
	if(is_low(CMD_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTGUI;}
    56d8:	7e 9b       	sbis	0x0f, 6	; 15
    56da:	88 60       	ori	r24, 0x08	; 8
	
	return Modifier;
}
    56dc:	08 95       	ret

000056de <ReadSensor>:
			return 0; //if no keys or reeds need sending, return 0
		}

}

unsigned long long ReadSensor(){
    56de:	7f 92       	push	r7
    56e0:	8f 92       	push	r8
    56e2:	9f 92       	push	r9
    56e4:	af 92       	push	r10
    56e6:	bf 92       	push	r11
    56e8:	cf 92       	push	r12
    56ea:	df 92       	push	r13
    56ec:	ef 92       	push	r14
    56ee:	ff 92       	push	r15
    56f0:	0f 93       	push	r16
    56f2:	1f 93       	push	r17
    56f4:	cf 93       	push	r28
    56f6:	df 93       	push	r29
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    56f8:	f8 94       	cli
		unsigned long long Readout = 0;	
		bool HallReading;
		
		GlobalInterruptDisable();
		set_high(SENSE_CLK);
    56fa:	72 9a       	sbi	0x0e, 2	; 14
    56fc:	8f ec       	ldi	r24, 0xCF	; 207
    56fe:	97 e0       	ldi	r25, 0x07	; 7
    5700:	01 97       	sbiw	r24, 0x01	; 1
    5702:	f1 f7       	brne	.-4      	; 0x5700 <ReadSensor+0x22>
    5704:	00 c0       	rjmp	.+0      	; 0x5706 <ReadSensor+0x28>
    5706:	00 00       	nop
		Delay_MS(1); //Sensor board has an LP filter and an inverter on the _LOAD signal.  Wait X ms for the low-pass filter on the _LOAD signal to fire low. 
		set_low(SENSE_CLK);
    5708:	72 98       	cbi	0x0e, 2	; 14
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    570a:	78 94       	sei
    570c:	8f ec       	ldi	r24, 0xCF	; 207
    570e:	97 e0       	ldi	r25, 0x07	; 7
    5710:	01 97       	sbiw	r24, 0x01	; 1
    5712:	f1 f7       	brne	.-4      	; 0x5710 <ReadSensor+0x32>
    5714:	00 c0       	rjmp	.+0      	; 0x5716 <ReadSensor+0x38>
    5716:	00 00       	nop
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
    5718:	e1 2c       	mov	r14, r1
    571a:	f1 2c       	mov	r15, r1
		}

}

unsigned long long ReadSensor(){
		unsigned long long Readout = 0;	
    571c:	71 2c       	mov	r7, r1
    571e:	10 e0       	ldi	r17, 0x00	; 0
    5720:	d0 e0       	ldi	r29, 0x00	; 0
    5722:	c0 e0       	ldi	r28, 0x00	; 0
    5724:	b0 e0       	ldi	r27, 0x00	; 0
    5726:	a0 e0       	ldi	r26, 0x00	; 0
    5728:	f0 e0       	ldi	r31, 0x00	; 0
    572a:	e0 e0       	ldi	r30, 0x00	; 0
		set_low(SENSE_CLK);
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
			if (is_low(SENSE_SER)) { 
    572c:	1d 99       	sbic	0x03, 5	; 3
    572e:	13 c0       	rjmp	.+38     	; 0x5756 <ReadSensor+0x78>
				longlongbit_set(Readout,i);// if the readout for one of the sensor pins comes back low, that key has been pressed -- store it as a 1 in the readout.
    5730:	21 e0       	ldi	r18, 0x01	; 1
    5732:	30 e0       	ldi	r19, 0x00	; 0
    5734:	40 e0       	ldi	r20, 0x00	; 0
    5736:	50 e0       	ldi	r21, 0x00	; 0
    5738:	60 e0       	ldi	r22, 0x00	; 0
    573a:	70 e0       	ldi	r23, 0x00	; 0
    573c:	80 e0       	ldi	r24, 0x00	; 0
    573e:	90 e0       	ldi	r25, 0x00	; 0
    5740:	0e 2d       	mov	r16, r14
    5742:	0e 94 07 38 	call	0x700e	; 0x700e <__ashldi3>
    5746:	72 2a       	or	r7, r18
    5748:	13 2b       	or	r17, r19
    574a:	d4 2b       	or	r29, r20
    574c:	c5 2b       	or	r28, r21
    574e:	b6 2b       	or	r27, r22
    5750:	a7 2b       	or	r26, r23
    5752:	f8 2b       	or	r31, r24
    5754:	e9 2b       	or	r30, r25
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    5756:	f8 94       	cli
			}	
			
			GlobalInterruptDisable();//if sense clk stays high too long, it could falsely trigger _Load signal.
			set_high(SENSE_CLK);
    5758:	72 9a       	sbi	0x0e, 2	; 14
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    575a:	9a e1       	ldi	r25, 0x1A	; 26
    575c:	9a 95       	dec	r25
    575e:	f1 f7       	brne	.-4      	; 0x575c <ReadSensor+0x7e>
    5760:	00 c0       	rjmp	.+0      	; 0x5762 <ReadSensor+0x84>
			_delay_us(CLK_POS_PULSE); //delay for the required pulsewidth
			set_low(SENSE_CLK);
    5762:	72 98       	cbi	0x0e, 2	; 14
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    5764:	78 94       	sei
    5766:	8a e6       	ldi	r24, 0x6A	; 106
    5768:	8a 95       	dec	r24
    576a:	f1 f7       	brne	.-4      	; 0x5768 <ReadSensor+0x8a>
    576c:	00 c0       	rjmp	.+0      	; 0x576e <ReadSensor+0x90>
		Delay_MS(1); //Sensor board has an LP filter and an inverter on the _LOAD signal.  Wait X ms for the low-pass filter on the _LOAD signal to fire low. 
		set_low(SENSE_CLK);
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
    576e:	9f ef       	ldi	r25, 0xFF	; 255
    5770:	e9 1a       	sub	r14, r25
    5772:	f9 0a       	sbc	r15, r25
    5774:	80 e3       	ldi	r24, 0x30	; 48
    5776:	e8 16       	cp	r14, r24
    5778:	f1 04       	cpc	r15, r1
    577a:	c1 f6       	brne	.-80     	; 0x572c <ReadSensor+0x4e>

		}
		
		/*The hall effect sensor on the end of the sensor board is only installed in certain cases -
		- its job is to tell if the entire crossbar has moved(active), or if it is at rest (therefore no keys should be detected)*/
		if(UseHallSensor == HALL_ACTIVE){ //when the hall effect sensor is installed and activated
    577c:	80 91 eb 06 	lds	r24, 0x06EB	; 0x8006eb <UseHallSensor>
    5780:	82 30       	cpi	r24, 0x02	; 2
    5782:	e9 f4       	brne	.+58     	; 0x57be <ReadSensor+0xe0>
			HallReading = Readout & LONGLONGBIT(HALL_SENSOR_BIT); //one of the bits of the sensor readout gives the state of the hall sensor
			if(HallReading != HallSensorPolarity){
    5784:	27 2d       	mov	r18, r7
    5786:	31 2f       	mov	r19, r17
    5788:	4d 2f       	mov	r20, r29
    578a:	5c 2f       	mov	r21, r28
    578c:	6b 2f       	mov	r22, r27
    578e:	7a 2f       	mov	r23, r26
    5790:	8f 2f       	mov	r24, r31
    5792:	9e 2f       	mov	r25, r30
    5794:	0c e2       	ldi	r16, 0x2C	; 44
    5796:	0e 94 22 38 	call	0x7044	; 0x7044 <__lshrdi3>
    579a:	49 01       	movw	r8, r18
    579c:	91 e0       	ldi	r25, 0x01	; 1
    579e:	89 22       	and	r8, r25
    57a0:	99 24       	eor	r9, r9
    57a2:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <HallSensorPolarity>
    57a6:	90 e0       	ldi	r25, 0x00	; 0
    57a8:	88 16       	cp	r8, r24
    57aa:	99 06       	cpc	r9, r25
    57ac:	41 f0       	breq	.+16     	; 0x57be <ReadSensor+0xe0>
				Readout = 0; //then if the hall effect sensor is not triggered, readout of keys is invalid -- clear it (including the hall sensor bit). 
    57ae:	71 2c       	mov	r7, r1
    57b0:	10 e0       	ldi	r17, 0x00	; 0
    57b2:	d0 e0       	ldi	r29, 0x00	; 0
    57b4:	c0 e0       	ldi	r28, 0x00	; 0
    57b6:	b0 e0       	ldi	r27, 0x00	; 0
    57b8:	a0 e0       	ldi	r26, 0x00	; 0
    57ba:	f0 e0       	ldi	r31, 0x00	; 0
    57bc:	e0 e0       	ldi	r30, 0x00	; 0
			}
		}

		//add the reed switches to the last 4 bits of the readout array -- if the reed switch is for the shift key, ignore it!
		if (Shift_Reed != 1 && is_high(REED_1)==(bool)Reed1Polarity){ Readout |= LONGLONGBIT(REED_BITS[0]);} //63rd bit of readout (or something like that) represents Reed1
    57be:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <Shift_Reed>
    57c2:	81 30       	cpi	r24, 0x01	; 1
    57c4:	51 f0       	breq	.+20     	; 0x57da <ReadSensor+0xfc>
    57c6:	99 b1       	in	r25, 0x09	; 9
    57c8:	92 95       	swap	r25
    57ca:	91 70       	andi	r25, 0x01	; 1
    57cc:	20 91 68 06 	lds	r18, 0x0668	; 0x800668 <Reed1Polarity>
    57d0:	92 13       	cpse	r25, r18
    57d2:	01 c0       	rjmp	.+2      	; 0x57d6 <ReadSensor+0xf8>
    57d4:	e0 64       	ori	r30, 0x40	; 64
		if (Shift_Reed != 2 && is_high(REED_2)==(bool)Reed2Polarity){ Readout |= LONGLONGBIT(REED_BITS[1]);} //62nd bit of readout (or something like that) represents Reed2
    57d6:	82 30       	cpi	r24, 0x02	; 2
    57d8:	59 f0       	breq	.+22     	; 0x57f0 <ReadSensor+0x112>
    57da:	99 b1       	in	r25, 0x09	; 9
    57dc:	96 fb       	bst	r25, 6
    57de:	99 27       	eor	r25, r25
    57e0:	90 f9       	bld	r25, 0
    57e2:	20 91 16 06 	lds	r18, 0x0616	; 0x800616 <Reed2Polarity>
    57e6:	92 13       	cpse	r25, r18
    57e8:	01 c0       	rjmp	.+2      	; 0x57ec <ReadSensor+0x10e>
    57ea:	e0 62       	ori	r30, 0x20	; 32
		if (Shift_Reed != 3 && is_high(REED_3)==(bool)Reed3Polarity){ Readout |= LONGLONGBIT(REED_BITS[2]);} //61st bit of readout (or something like that) represents Reed3
    57ec:	83 30       	cpi	r24, 0x03	; 3
    57ee:	59 f0       	breq	.+22     	; 0x5806 <ReadSensor+0x128>
    57f0:	99 b1       	in	r25, 0x09	; 9
    57f2:	99 1f       	adc	r25, r25
    57f4:	99 27       	eor	r25, r25
    57f6:	99 1f       	adc	r25, r25
    57f8:	20 91 ea 06 	lds	r18, 0x06EA	; 0x8006ea <Reed3Polarity>
    57fc:	92 13       	cpse	r25, r18
    57fe:	01 c0       	rjmp	.+2      	; 0x5802 <ReadSensor+0x124>
    5800:	e0 61       	ori	r30, 0x10	; 16
		if (Shift_Reed != 4 && is_high(REED_4)==(bool)Reed4Polarity){ Readout |= LONGLONGBIT(REED_BITS[3]);} //60th bit of readout (or something like that) represents Reed4
    5802:	84 30       	cpi	r24, 0x04	; 4
    5804:	41 f0       	breq	.+16     	; 0x5816 <ReadSensor+0x138>
    5806:	83 b1       	in	r24, 0x03	; 3
    5808:	82 95       	swap	r24
    580a:	81 70       	andi	r24, 0x01	; 1
    580c:	90 91 28 07 	lds	r25, 0x0728	; 0x800728 <Reed4Polarity>
    5810:	89 13       	cpse	r24, r25
    5812:	01 c0       	rjmp	.+2      	; 0x5816 <ReadSensor+0x138>
    5814:	e8 60       	ori	r30, 0x08	; 8
		
		return Readout;
}
    5816:	27 2d       	mov	r18, r7
    5818:	31 2f       	mov	r19, r17
    581a:	4d 2f       	mov	r20, r29
    581c:	5c 2f       	mov	r21, r28
    581e:	6b 2f       	mov	r22, r27
    5820:	7a 2f       	mov	r23, r26
    5822:	8f 2f       	mov	r24, r31
    5824:	9e 2f       	mov	r25, r30
    5826:	df 91       	pop	r29
    5828:	cf 91       	pop	r28
    582a:	1f 91       	pop	r17
    582c:	0f 91       	pop	r16
    582e:	ff 90       	pop	r15
    5830:	ef 90       	pop	r14
    5832:	df 90       	pop	r13
    5834:	cf 90       	pop	r12
    5836:	bf 90       	pop	r11
    5838:	af 90       	pop	r10
    583a:	9f 90       	pop	r9
    583c:	8f 90       	pop	r8
    583e:	7f 90       	pop	r7
    5840:	08 95       	ret

00005842 <GetKeySimple>:
	if(is_low(CMD_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTGUI;}
	
	return Modifier;
}

uint8_t GetKeySimple(){
    5842:	ff 92       	push	r15
    5844:	0f 93       	push	r16
    5846:	1f 93       	push	r17
    5848:	cf 93       	push	r28
    584a:	df 93       	push	r29
	unsigned long long SensorReadout; //create 64-bit "long long" binary variable and set it all to 0s.
	uint8_t Key;
	
	Key=0;//by default, there is no key to send, unless one is detected later.
	
	SensorReadout = ReadSensor();
    584c:	48 df       	rcall	.-368    	; 0x56de <ReadSensor>
    584e:	f2 2e       	mov	r15, r18
    5850:	03 2f       	mov	r16, r19
    5852:	14 2f       	mov	r17, r20
    5854:	d5 2f       	mov	r29, r21
    5856:	c6 2f       	mov	r28, r22
    5858:	e7 2f       	mov	r30, r23
    585a:	b8 2f       	mov	r27, r24
    585c:	f9 2f       	mov	r31, r25
	if(UseHallSensor != HALL_NOT_PRESENT){
    585e:	80 91 eb 06 	lds	r24, 0x06EB	; 0x8006eb <UseHallSensor>
    5862:	81 11       	cpse	r24, r1
		SensorReadout &= ~LONGLONGBIT(HALL_SENSOR_BIT); //discard the hall effect bit of the array -- it is not an actual key, so don't report it as one.
    5864:	ef 7e       	andi	r30, 0xEF	; 239
	}

	if(SensorReadout){
    5866:	2f 2d       	mov	r18, r15
    5868:	30 2f       	mov	r19, r16
    586a:	41 2f       	mov	r20, r17
    586c:	5d 2f       	mov	r21, r29
    586e:	6c 2f       	mov	r22, r28
    5870:	7e 2f       	mov	r23, r30
    5872:	8b 2f       	mov	r24, r27
    5874:	9f 2f       	mov	r25, r31
    5876:	a0 e0       	ldi	r26, 0x00	; 0
    5878:	0e 94 3e 38 	call	0x707c	; 0x707c <__cmpdi2_s8>
    587c:	19 f0       	breq	.+6      	; 0x5884 <GetKeySimple+0x42>
		Key = (uint8_t) __builtin_clzll(SensorReadout); //this function finds the first nonzero bit in the bitfield SensorReadout (by counting leading zeros)
    587e:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__clzdi2>
    5882:	01 c0       	rjmp	.+2      	; 0x5886 <GetKeySimple+0x44>
	}
	else{
		Key = 0;
    5884:	80 e0       	ldi	r24, 0x00	; 0
	}
	return  Key;
	
}
    5886:	df 91       	pop	r29
    5888:	cf 91       	pop	r28
    588a:	1f 91       	pop	r17
    588c:	0f 91       	pop	r16
    588e:	ff 90       	pop	r15
    5890:	08 95       	ret

00005892 <GetKey>:
	
uint8_t GetKey(){
    5892:	2f 92       	push	r2
    5894:	3f 92       	push	r3
    5896:	4f 92       	push	r4
    5898:	5f 92       	push	r5
    589a:	6f 92       	push	r6
    589c:	7f 92       	push	r7
    589e:	8f 92       	push	r8
    58a0:	9f 92       	push	r9
    58a2:	af 92       	push	r10
    58a4:	bf 92       	push	r11
    58a6:	cf 92       	push	r12
    58a8:	df 92       	push	r13
    58aa:	ef 92       	push	r14
    58ac:	ff 92       	push	r15
    58ae:	0f 93       	push	r16
    58b0:	1f 93       	push	r17
    58b2:	cf 93       	push	r28
    58b4:	df 93       	push	r29
    58b6:	00 d0       	rcall	.+0      	; 0x58b8 <GetKey+0x26>
    58b8:	1f 92       	push	r1
    58ba:	cd b7       	in	r28, 0x3d	; 61
    58bc:	de b7       	in	r29, 0x3e	; 62
		bool OKtoSendReed = false; //go ahead to send a reed switch
		
		uint8_t ReedToSend = 0;
	
/*READ INPUT FROM SENSOR STRIP*/	
		SensorReadout = ReadSensor();
    58be:	0f df       	rcall	.-482    	; 0x56de <ReadSensor>
    58c0:	49 01       	movw	r8, r18
    58c2:	14 2f       	mov	r17, r20
    58c4:	59 83       	std	Y+1, r21	; 0x01
    58c6:	f6 2f       	mov	r31, r22
    58c8:	e7 2f       	mov	r30, r23
    58ca:	48 2e       	mov	r4, r24
    58cc:	39 2e       	mov	r3, r25
		
		if (UseHallSensor != HALL_NOT_PRESENT){ //if the user has not installed the hall sensor, don't do this part.
    58ce:	80 91 eb 06 	lds	r24, 0x06EB	; 0x8006eb <UseHallSensor>
    58d2:	81 11       	cpse	r24, r1
			SensorReadout &= ~LONGLONGBIT(HALL_SENSOR_BIT); //after detecting it, discard the hall effect bit of the array -- it is not an actual key, so don't report it as one.
    58d4:	ef 7e       	andi	r30, 0xEF	; 239
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
			int reednumber = i+1;
			int j;
			
			if (Reeds_Are_Independent) j = i; //
    58d6:	50 90 18 06 	lds	r5, 0x0618	; 0x800618 <Reeds_Are_Independent>
			else j = 0; //setting j = 0 means "If any reed is active, all reeds are considered active also (and are therefore won't be sent when pressed)
			
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
				if (ReedDebounce[i] < ReedHoldTime){//increment the debounce entry if not already maxed out.
    58da:	20 90 5c 06 	lds	r2, 0x065C	; 0x80065c <ReedHoldTime>
    58de:	83 ed       	ldi	r24, 0xD3	; 211
    58e0:	e8 2e       	mov	r14, r24
    58e2:	85 e0       	ldi	r24, 0x05	; 5
    58e4:	f8 2e       	mov	r15, r24
    58e6:	9b ed       	ldi	r25, 0xDB	; 219
    58e8:	a9 2e       	mov	r10, r25
    58ea:	92 e0       	ldi	r25, 0x02	; 2
    58ec:	b9 2e       	mov	r11, r25
    58ee:	c1 2c       	mov	r12, r1
    58f0:	d1 2c       	mov	r13, r1
		static uint8_t ReedDebounce[4]; //array tracking the debounce times of all four reed switches.  
		
		bool OKtoSendKey = false; //non static bool that gives the go-ahead to send a key over the usb/bluetooth bus.  Indicates that the key has been pressed first time.
		bool OKtoSendReed = false; //go ahead to send a reed switch
		
		uint8_t ReedToSend = 0;
    58f2:	71 2c       	mov	r7, r1
		static uint8_t KeyReleaseCounter;
		static bool ActiveReeds[4];//array showing all currently active reeds.
		static uint8_t ReedDebounce[4]; //array tracking the debounce times of all four reed switches.  
		
		bool OKtoSendKey = false; //non static bool that gives the go-ahead to send a key over the usb/bluetooth bus.  Indicates that the key has been pressed first time.
		bool OKtoSendReed = false; //go ahead to send a reed switch
    58f4:	61 2c       	mov	r6, r1
/*READ AND DEBOUNCE REED SWITCH INPUTS*/

		/*Detect which reeds have been pressed, and if they have been sent to the host already or if they still need to be*/
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
			int reednumber = i+1;
    58f6:	db 82       	std	Y+3, r13	; 0x03
    58f8:	ca 82       	std	Y+2, r12	; 0x02
			int j;
			
			if (Reeds_Are_Independent) j = i; //
    58fa:	51 10       	cpse	r5, r1
    58fc:	02 c0       	rjmp	.+4      	; 0x5902 <GetKey+0x70>
			else j = 0; //setting j = 0 means "If any reed is active, all reeds are considered active also (and are therefore won't be sent when pressed)
    58fe:	1b 82       	std	Y+3, r1	; 0x03
    5900:	1a 82       	std	Y+2, r1	; 0x02
			
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
    5902:	d5 01       	movw	r26, r10
    5904:	0d 91       	ld	r16, X+
    5906:	5d 01       	movw	r10, r26
    5908:	bf ef       	ldi	r27, 0xFF	; 255
    590a:	cb 1a       	sub	r12, r27
    590c:	db 0a       	sbc	r13, r27
    590e:	94 01       	movw	r18, r8
    5910:	41 2f       	mov	r20, r17
    5912:	59 81       	ldd	r21, Y+1	; 0x01
    5914:	6f 2f       	mov	r22, r31
    5916:	7e 2f       	mov	r23, r30
    5918:	84 2d       	mov	r24, r4
    591a:	93 2d       	mov	r25, r3
    591c:	0e 94 22 38 	call	0x7044	; 0x7044 <__lshrdi3>
    5920:	21 70       	andi	r18, 0x01	; 1
    5922:	30 e0       	ldi	r19, 0x00	; 0
    5924:	40 e0       	ldi	r20, 0x00	; 0
    5926:	50 e0       	ldi	r21, 0x00	; 0
    5928:	60 e0       	ldi	r22, 0x00	; 0
    592a:	70 e0       	ldi	r23, 0x00	; 0
    592c:	80 e0       	ldi	r24, 0x00	; 0
    592e:	90 e0       	ldi	r25, 0x00	; 0
    5930:	a0 e0       	ldi	r26, 0x00	; 0
    5932:	0e 94 3e 38 	call	0x707c	; 0x707c <__cmpdi2_s8>
    5936:	b1 f0       	breq	.+44     	; 0x5964 <GetKey+0xd2>
				if (ReedDebounce[i] < ReedHoldTime){//increment the debounce entry if not already maxed out.
    5938:	d7 01       	movw	r26, r14
    593a:	8c 91       	ld	r24, X
    593c:	82 15       	cp	r24, r2
    593e:	10 f4       	brcc	.+4      	; 0x5944 <GetKey+0xb2>
					ReedDebounce[i] ++;
    5940:	8f 5f       	subi	r24, 0xFF	; 255
    5942:	35 c0       	rjmp	.+106    	; 0x59ae <GetKey+0x11c>
				} 
				else if (!ActiveReeds[j]){ //if the debounce has reached KeyHoldTime, but the reed isn't already listed as active
    5944:	2a 81       	ldd	r18, Y+2	; 0x02
    5946:	3b 81       	ldd	r19, Y+3	; 0x03
    5948:	21 53       	subi	r18, 0x31	; 49
    594a:	3a 4f       	sbci	r19, 0xFA	; 250
    594c:	3b 83       	std	Y+3, r19	; 0x03
    594e:	2a 83       	std	Y+2, r18	; 0x02
    5950:	d9 01       	movw	r26, r18
    5952:	8c 91       	ld	r24, X
    5954:	81 11       	cpse	r24, r1
    5956:	2c c0       	rjmp	.+88     	; 0x59b0 <GetKey+0x11e>
						ActiveReeds[j] = true; //then list it as active.
    5958:	21 e0       	ldi	r18, 0x01	; 1
    595a:	2c 93       	st	X, r18
						ReedToSend = reednumber; //code 1,2,3, or 4 indicates which reed has been pressed
    595c:	7c 2c       	mov	r7, r12
						OKtoSendReed = true;//and tell the routine to send it
    595e:	66 24       	eor	r6, r6
    5960:	63 94       	inc	r6
    5962:	26 c0       	rjmp	.+76     	; 0x59b0 <GetKey+0x11e>
				}
			} 
			else if (Reeds_Are_Independent){//if the reed is not detected, and we are tracking them separately.
    5964:	55 20       	and	r5, r5
    5966:	39 f0       	breq	.+14     	; 0x5976 <GetKey+0xe4>
				if(ReedDebounce[i] == 0) ActiveReeds[j] = false; //then if the debounce counter has run down, consider the reed to be released.
    5968:	d7 01       	movw	r26, r14
    596a:	8c 91       	ld	r24, X
    596c:	88 23       	and	r24, r24
    596e:	99 f0       	breq	.+38     	; 0x5996 <GetKey+0x104>
				else ReedDebounce[i]--; //if not already zero, decrement the counter
    5970:	81 50       	subi	r24, 0x01	; 1
    5972:	d7 01       	movw	r26, r14
    5974:	1c c0       	rjmp	.+56     	; 0x59ae <GetKey+0x11c>
			}
			else if (!Reeds_Are_Independent){ //if reeds are not considered independent, all reeds must be released before another can fire.
				if((ReedDebounce[0] == 0)&&(ReedDebounce[1] == 0)&&(ReedDebounce[2]== 0)&&(ReedDebounce[3]==0)){ //so wait for all reeds to be released
    5976:	80 91 d3 05 	lds	r24, 0x05D3	; 0x8005d3 <ReedDebounce.4660>
    597a:	81 11       	cpse	r24, r1
    597c:	13 c0       	rjmp	.+38     	; 0x59a4 <GetKey+0x112>
    597e:	80 91 d4 05 	lds	r24, 0x05D4	; 0x8005d4 <ReedDebounce.4660+0x1>
    5982:	81 11       	cpse	r24, r1
    5984:	0f c0       	rjmp	.+30     	; 0x59a4 <GetKey+0x112>
    5986:	80 91 d5 05 	lds	r24, 0x05D5	; 0x8005d5 <ReedDebounce.4660+0x2>
    598a:	81 11       	cpse	r24, r1
    598c:	0b c0       	rjmp	.+22     	; 0x59a4 <GetKey+0x112>
    598e:	80 91 d6 05 	lds	r24, 0x05D6	; 0x8005d6 <ReedDebounce.4660+0x3>
    5992:	81 11       	cpse	r24, r1
    5994:	07 c0       	rjmp	.+14     	; 0x59a4 <GetKey+0x112>
					ActiveReeds[j] = false; // only if all reeds are released do we allow a new reed to be pressed.
    5996:	2a 81       	ldd	r18, Y+2	; 0x02
    5998:	3b 81       	ldd	r19, Y+3	; 0x03
    599a:	21 53       	subi	r18, 0x31	; 49
    599c:	3a 4f       	sbci	r19, 0xFA	; 250
    599e:	d9 01       	movw	r26, r18
    59a0:	1c 92       	st	X, r1
    59a2:	06 c0       	rjmp	.+12     	; 0x59b0 <GetKey+0x11e>
				}
				else if (ReedDebounce[i]) {ReedDebounce[i]--;} //decrement debounce counter for this reed.
    59a4:	d7 01       	movw	r26, r14
    59a6:	8c 91       	ld	r24, X
    59a8:	88 23       	and	r24, r24
    59aa:	11 f0       	breq	.+4      	; 0x59b0 <GetKey+0x11e>
    59ac:	81 50       	subi	r24, 0x01	; 1
    59ae:	8c 93       	st	X, r24
    59b0:	bf ef       	ldi	r27, 0xFF	; 255
    59b2:	eb 1a       	sub	r14, r27
    59b4:	fb 0a       	sbc	r15, r27
		
/*READ AND DEBOUNCE REED SWITCH INPUTS*/

		/*Detect which reeds have been pressed, and if they have been sent to the host already or if they still need to be*/
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
    59b6:	24 e0       	ldi	r18, 0x04	; 4
    59b8:	c2 16       	cp	r12, r18
    59ba:	d1 04       	cpc	r13, r1
    59bc:	09 f0       	breq	.+2      	; 0x59c0 <GetKey+0x12e>
    59be:	9b cf       	rjmp	.-202    	; 0x58f6 <GetKey+0x64>
		

		

/*APPLY VARIOUS MASKS TO SIMPLIFY SENSOR READOUT*/	
		SensorReadout = SensorReadout & KEY_SENSOR_MASK;//discard the reed switch bits and the sensor bit -- look only at the key sensor contacts.
    59c0:	b9 81       	ldd	r27, Y+1	; 0x01
		if (SensorReadout == KEY_SENSOR_MASK){
    59c2:	94 01       	movw	r18, r8
    59c4:	41 2f       	mov	r20, r17
    59c6:	5b 2f       	mov	r21, r27
    59c8:	6f 2f       	mov	r22, r31
    59ca:	7e 2f       	mov	r23, r30
    59cc:	80 e0       	ldi	r24, 0x00	; 0
    59ce:	90 e0       	ldi	r25, 0x00	; 0
    59d0:	2f 3f       	cpi	r18, 0xFF	; 255
    59d2:	af ef       	ldi	r26, 0xFF	; 255
    59d4:	3a 07       	cpc	r19, r26
    59d6:	4a 07       	cpc	r20, r26
    59d8:	5a 07       	cpc	r21, r26
    59da:	6a 07       	cpc	r22, r26
    59dc:	7a 07       	cpc	r23, r26
    59de:	81 05       	cpc	r24, r1
    59e0:	91 05       	cpc	r25, r1
    59e2:	09 f4       	brne	.+2      	; 0x59e6 <GetKey+0x154>
    59e4:	59 c0       	rjmp	.+178    	; 0x5a98 <GetKey+0x206>
			SensorReadout = 0;// if masked sensor readout is all ones, sensor is probably not plugged in -- discard.
		}
		else if(ActiveKey){
    59e6:	80 91 ce 05 	lds	r24, 0x05CE	; 0x8005ce <ActiveKey.4655>
    59ea:	88 23       	and	r24, r24
    59ec:	89 f0       	breq	.+34     	; 0x5a10 <GetKey+0x17e>
			SensorReadout = (SensorReadout & KEYMASK(ActiveKey)); //if a key was detected last time, mask all others -- only look at that key this time -- prevents confusion from multiple keys.
    59ee:	2f e3       	ldi	r18, 0x3F	; 63
    59f0:	30 e0       	ldi	r19, 0x00	; 0
    59f2:	28 1b       	sub	r18, r24
    59f4:	31 09       	sbc	r19, r1
    59f6:	3b 83       	std	Y+3, r19	; 0x03
    59f8:	2a 83       	std	Y+2, r18	; 0x02
    59fa:	21 e0       	ldi	r18, 0x01	; 1
    59fc:	30 e0       	ldi	r19, 0x00	; 0
    59fe:	40 e0       	ldi	r20, 0x00	; 0
    5a00:	50 e0       	ldi	r21, 0x00	; 0
    5a02:	60 e0       	ldi	r22, 0x00	; 0
    5a04:	70 e0       	ldi	r23, 0x00	; 0
    5a06:	80 e0       	ldi	r24, 0x00	; 0
    5a08:	0a 81       	ldd	r16, Y+2	; 0x02
    5a0a:	0e 94 07 38 	call	0x700e	; 0x700e <__ashldi3>
    5a0e:	29 c0       	rjmp	.+82     	; 0x5a62 <GetKey+0x1d0>
		}
		else if(PreviousKey){ //if no key was detected, but a key was recently detected (maybe it was just released, or maybe it bounced off)
    5a10:	90 91 cd 05 	lds	r25, 0x05CD	; 0x8005cd <PreviousKey.4654>
    5a14:	99 23       	and	r25, r25
    5a16:	59 f1       	breq	.+86     	; 0x5a6e <GetKey+0x1dc>
			DoubleTapCounter++;
    5a18:	80 91 cc 05 	lds	r24, 0x05CC	; 0x8005cc <DoubleTapCounter.4656>
    5a1c:	8f 5f       	subi	r24, 0xFF	; 255
    5a1e:	80 93 cc 05 	sts	0x05CC, r24	; 0x8005cc <DoubleTapCounter.4656>
			if (DoubleTapCounter >= DoubleTapTime){ //once the double tap timer has expired, reset everything and stop ignoring previous key.
    5a22:	20 91 5d 06 	lds	r18, 0x065D	; 0x80065d <DoubleTapTime>
    5a26:	82 17       	cp	r24, r18
    5a28:	28 f0       	brcs	.+10     	; 0x5a34 <GetKey+0x1a2>
				DoubleTapCounter = 0;
    5a2a:	10 92 cc 05 	sts	0x05CC, r1	; 0x8005cc <DoubleTapCounter.4656>
				PreviousKey = 0; 
    5a2e:	10 92 cd 05 	sts	0x05CD, r1	; 0x8005cd <PreviousKey.4654>
    5a32:	1d c0       	rjmp	.+58     	; 0x5a6e <GetKey+0x1dc>
			}		
			else{ //if timer has not expired yet, ignore the previous key pressed.
				SensorReadout = (SensorReadout & ~KEYMASK(PreviousKey)); //whatever the previous active key pressed was, ignore it.
    5a34:	2f e3       	ldi	r18, 0x3F	; 63
    5a36:	30 e0       	ldi	r19, 0x00	; 0
    5a38:	29 1b       	sub	r18, r25
    5a3a:	31 09       	sbc	r19, r1
    5a3c:	3b 83       	std	Y+3, r19	; 0x03
    5a3e:	2a 83       	std	Y+2, r18	; 0x02
    5a40:	21 e0       	ldi	r18, 0x01	; 1
    5a42:	30 e0       	ldi	r19, 0x00	; 0
    5a44:	40 e0       	ldi	r20, 0x00	; 0
    5a46:	50 e0       	ldi	r21, 0x00	; 0
    5a48:	60 e0       	ldi	r22, 0x00	; 0
    5a4a:	70 e0       	ldi	r23, 0x00	; 0
    5a4c:	80 e0       	ldi	r24, 0x00	; 0
    5a4e:	90 e0       	ldi	r25, 0x00	; 0
    5a50:	0a 81       	ldd	r16, Y+2	; 0x02
    5a52:	0e 94 07 38 	call	0x700e	; 0x700e <__ashldi3>
    5a56:	20 95       	com	r18
    5a58:	30 95       	com	r19
    5a5a:	40 95       	com	r20
    5a5c:	50 95       	com	r21
    5a5e:	60 95       	com	r22
    5a60:	70 95       	com	r23
    5a62:	82 22       	and	r8, r18
    5a64:	93 22       	and	r9, r19
    5a66:	14 23       	and	r17, r20
    5a68:	b5 23       	and	r27, r21
    5a6a:	f6 23       	and	r31, r22
    5a6c:	e7 23       	and	r30, r23
			}
		}
		
/*DETERMINE WHICH CONTACT, IF ANY, HAS DETECTED A KEY THIS ROUND*/	
		if(SensorReadout){ //if sensor readout is not all zeros
    5a6e:	94 01       	movw	r18, r8
    5a70:	41 2f       	mov	r20, r17
    5a72:	5b 2f       	mov	r21, r27
    5a74:	6f 2f       	mov	r22, r31
    5a76:	7e 2f       	mov	r23, r30
    5a78:	80 e0       	ldi	r24, 0x00	; 0
    5a7a:	90 e0       	ldi	r25, 0x00	; 0
    5a7c:	a0 e0       	ldi	r26, 0x00	; 0
    5a7e:	0e 94 3e 38 	call	0x707c	; 0x707c <__cmpdi2_s8>
    5a82:	51 f0       	breq	.+20     	; 0x5a98 <GetKey+0x206>
			DetectedKey = (uint8_t) __builtin_clzll(SensorReadout); //get the position of the first "one" in the sparse key detection array 
    5a84:	0e 94 ff 37 	call	0x6ffe	; 0x6ffe <__clzdi2>
			DetectedKey = 0;
		}
		
/*DEBOUNCE KEY READING*/
		if(DetectedKey){//if there is a detected key this time,
			 KeyHoldCounter++;  
    5a88:	90 91 cb 05 	lds	r25, 0x05CB	; 0x8005cb <KeyHoldCounter.4657>
    5a8c:	9f 5f       	subi	r25, 0xFF	; 255
    5a8e:	90 93 cb 05 	sts	0x05CB, r25	; 0x8005cb <KeyHoldCounter.4657>
			 KeyReleaseCounter=0;		 
    5a92:	10 92 ca 05 	sts	0x05CA, r1	; 0x8005ca <KeyReleaseCounter.4658>
    5a96:	08 c0       	rjmp	.+16     	; 0x5aa8 <GetKey+0x216>
		}
		else {
			KeyReleaseCounter++; 
    5a98:	80 91 ca 05 	lds	r24, 0x05CA	; 0x8005ca <KeyReleaseCounter.4658>
    5a9c:	8f 5f       	subi	r24, 0xFF	; 255
    5a9e:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <KeyReleaseCounter.4658>
			KeyHoldCounter = 0;  
    5aa2:	10 92 cb 05 	sts	0x05CB, r1	; 0x8005cb <KeyHoldCounter.4657>
    5aa6:	80 e0       	ldi	r24, 0x00	; 0
		}
		
		if (KeyHoldCounter >= KeyHoldTime){
    5aa8:	90 91 a9 06 	lds	r25, 0x06A9	; 0x8006a9 <KeyHoldTime>
    5aac:	20 91 cb 05 	lds	r18, 0x05CB	; 0x8005cb <KeyHoldCounter.4657>
    5ab0:	29 17       	cp	r18, r25
    5ab2:	58 f0       	brcs	.+22     	; 0x5aca <GetKey+0x238>
			KeyHoldCounter = KeyHoldTime; // can't get higher than keyholdtime
    5ab4:	90 93 cb 05 	sts	0x05CB, r25	; 0x8005cb <KeyHoldCounter.4657>
			if (DetectedKey != ActiveKey){ // if this is a new active key (just pressed) then set the active key to the new value, and give go-ahead to send it.
    5ab8:	90 91 ce 05 	lds	r25, 0x05CE	; 0x8005ce <ActiveKey.4655>
    5abc:	98 17       	cp	r25, r24
    5abe:	99 f0       	breq	.+38     	; 0x5ae6 <GetKey+0x254>
				ActiveKey = DetectedKey; //the current key is the new active key
    5ac0:	80 93 ce 05 	sts	0x05CE, r24	; 0x8005ce <ActiveKey.4655>
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
    5ac4:	66 20       	and	r6, r6
    5ac6:	a1 f0       	breq	.+40     	; 0x5af0 <GetKey+0x25e>
    5ac8:	12 c0       	rjmp	.+36     	; 0x5aee <GetKey+0x25c>
			if (DetectedKey != ActiveKey){ // if this is a new active key (just pressed) then set the active key to the new value, and give go-ahead to send it.
				ActiveKey = DetectedKey; //the current key is the new active key
				OKtoSendKey = true;
			}
		}
		else if (KeyReleaseCounter >= KeyReleaseTime){
    5aca:	80 91 1a 06 	lds	r24, 0x061A	; 0x80061a <KeyReleaseTime>
    5ace:	90 91 ca 05 	lds	r25, 0x05CA	; 0x8005ca <KeyReleaseCounter.4658>
    5ad2:	98 17       	cp	r25, r24
    5ad4:	40 f0       	brcs	.+16     	; 0x5ae6 <GetKey+0x254>
			KeyReleaseCounter = KeyReleaseTime; //
    5ad6:	80 93 ca 05 	sts	0x05CA, r24	; 0x8005ca <KeyReleaseCounter.4658>
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
    5ada:	80 91 ce 05 	lds	r24, 0x05CE	; 0x8005ce <ActiveKey.4655>
    5ade:	80 93 cd 05 	sts	0x05CD, r24	; 0x8005cd <PreviousKey.4654>
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
    5ae2:	10 92 ce 05 	sts	0x05CE, r1	; 0x8005ce <ActiveKey.4655>
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
    5ae6:	61 10       	cpse	r6, r1
    5ae8:	02 c0       	rjmp	.+4      	; 0x5aee <GetKey+0x25c>
		}
		else if(OKtoSendKey){ //otherwise, if there is a key to send, report it
			return ActiveKey; 
		}
		else{
			return 0; //if no keys or reeds need sending, return 0
    5aea:	80 e0       	ldi	r24, 0x00	; 0
    5aec:	01 c0       	rjmp	.+2      	; 0x5af0 <GetKey+0x25e>
    5aee:	87 2d       	mov	r24, r7
		}

}
    5af0:	0f 90       	pop	r0
    5af2:	0f 90       	pop	r0
    5af4:	0f 90       	pop	r0
    5af6:	df 91       	pop	r29
    5af8:	cf 91       	pop	r28
    5afa:	1f 91       	pop	r17
    5afc:	0f 91       	pop	r16
    5afe:	ff 90       	pop	r15
    5b00:	ef 90       	pop	r14
    5b02:	df 90       	pop	r13
    5b04:	cf 90       	pop	r12
    5b06:	bf 90       	pop	r11
    5b08:	af 90       	pop	r10
    5b0a:	9f 90       	pop	r9
    5b0c:	8f 90       	pop	r8
    5b0e:	7f 90       	pop	r7
    5b10:	6f 90       	pop	r6
    5b12:	5f 90       	pop	r5
    5b14:	4f 90       	pop	r4
    5b16:	3f 90       	pop	r3
    5b18:	2f 90       	pop	r2
    5b1a:	08 95       	ret

00005b1c <GetHIDKeyCode>:
		if (Shift_Reed != 4 && is_high(REED_4)==(bool)Reed4Polarity){ Readout |= LONGLONGBIT(REED_BITS[3]);} //60th bit of readout (or something like that) represents Reed4
		
		return Readout;
}

uint8_t GetHIDKeyCode(uint8_t key, uint8_t* modifier){ 
    5b1c:	fb 01       	movw	r30, r22
	uint8_t code;

	if ((*modifier & HID_KEYBOARD_MODIFIER_LEFTALT) && FnKeyCodeLookUpTable[key]){ //if the FN key is held down, look up key in FN array.
    5b1e:	90 81       	ld	r25, Z
    5b20:	28 2f       	mov	r18, r24
    5b22:	30 e0       	ldi	r19, 0x00	; 0
    5b24:	92 ff       	sbrs	r25, 2
    5b26:	08 c0       	rjmp	.+16     	; 0x5b38 <GetHIDKeyCode+0x1c>
    5b28:	d9 01       	movw	r26, r18
    5b2a:	a6 59       	subi	r26, 0x96	; 150
    5b2c:	b6 4f       	sbci	r27, 0xF6	; 246
    5b2e:	8c 91       	ld	r24, X
    5b30:	88 23       	and	r24, r24
    5b32:	11 f0       	breq	.+4      	; 0x5b38 <GetHIDKeyCode+0x1c>
		code = FnKeyCodeLookUpTable[key];
		*modifier &= ~HID_KEYBOARD_MODIFIER_LEFTALT;// if the key is in the function table, it is a special key.  The alt modifier should not be sent..
    5b34:	9b 7f       	andi	r25, 0xFB	; 251
    5b36:	09 c0       	rjmp	.+18     	; 0x5b4a <GetHIDKeyCode+0x2e>

	}
	else if ((*modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT) && ShiftKeyCodeLookUpTable[key]){
    5b38:	91 ff       	sbrs	r25, 1
    5b3a:	09 c0       	rjmp	.+18     	; 0x5b4e <GetHIDKeyCode+0x32>
    5b3c:	d9 01       	movw	r26, r18
    5b3e:	a7 59       	subi	r26, 0x97	; 151
    5b40:	b9 4f       	sbci	r27, 0xF9	; 249
    5b42:	8c 91       	ld	r24, X
    5b44:	88 23       	and	r24, r24
    5b46:	19 f0       	breq	.+6      	; 0x5b4e <GetHIDKeyCode+0x32>
		code = ShiftKeyCodeLookUpTable[key];
		*modifier &= ~HID_KEYBOARD_MODIFIER_LEFTSHIFT;// if the key is in the shift table, it is a special key.  The shift modifier should not be sent..
    5b48:	9d 7f       	andi	r25, 0xFD	; 253
    5b4a:	90 83       	st	Z, r25
    5b4c:	08 95       	ret
	}
	else {
		code = KeyCodeLookUpTable[key]; //otherwise, look up the key in the regular array.
    5b4e:	f9 01       	movw	r30, r18
    5b50:	e4 5e       	subi	r30, 0xE4	; 228
    5b52:	f9 4f       	sbci	r31, 0xF9	; 249
    5b54:	80 81       	ld	r24, Z
	}
	return code;
}
    5b56:	08 95       	ret

00005b58 <GetASCIIKeyCode>:

uint8_t GetASCIIKeyCode(uint8_t key, uint8_t modifier){
	uint8_t code;
	
	if(key == 0){
    5b58:	88 23       	and	r24, r24
    5b5a:	79 f0       	breq	.+30     	; 0x5b7a <GetASCIIKeyCode+0x22>
    5b5c:	28 2f       	mov	r18, r24
    5b5e:	30 e0       	ldi	r19, 0x00	; 0
		return 0;
	}
	
	if ((modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT) && ASCIIShiftLookUpTable[key]){
    5b60:	61 ff       	sbrs	r22, 1
    5b62:	06 c0       	rjmp	.+12     	; 0x5b70 <GetASCIIKeyCode+0x18>
    5b64:	f9 01       	movw	r30, r18
    5b66:	e6 55       	subi	r30, 0x56	; 86
    5b68:	f9 4f       	sbci	r31, 0xF9	; 249
    5b6a:	80 81       	ld	r24, Z
    5b6c:	81 11       	cpse	r24, r1
    5b6e:	06 c0       	rjmp	.+12     	; 0x5b7c <GetASCIIKeyCode+0x24>
		code = ASCIIShiftLookUpTable[key];
		}
	else {
		code = ASCIILookUpTable[key];
    5b70:	f9 01       	movw	r30, r18
    5b72:	e7 5d       	subi	r30, 0xD7	; 215
    5b74:	f8 4f       	sbci	r31, 0xF8	; 248
    5b76:	80 81       	ld	r24, Z
    5b78:	08 95       	ret

uint8_t GetASCIIKeyCode(uint8_t key, uint8_t modifier){
	uint8_t code;
	
	if(key == 0){
		return 0;
    5b7a:	80 e0       	ldi	r24, 0x00	; 0
		}
	else {
		code = ASCIILookUpTable[key];
	}
	return code;
}
    5b7c:	08 95       	ret

00005b7e <getHallState>:

bool getHallState(){ //don't call this function from inside ReadSensor !  It will cause an infinite loop...
    5b7e:	0f 93       	push	r16
	bool hallstate;
	hallstate = (ReadSensor() & LONGLONGBIT(HALL_SENSOR_BIT));
    5b80:	ae dd       	rcall	.-1188   	; 0x56de <ReadSensor>
	return hallstate;
    5b82:	0c e2       	ldi	r16, 0x2C	; 44
    5b84:	0e 94 22 38 	call	0x7044	; 0x7044 <__lshrdi3>
}
    5b88:	82 2f       	mov	r24, r18
    5b8a:	81 70       	andi	r24, 0x01	; 1
    5b8c:	0f 91       	pop	r16
    5b8e:	08 95       	ret

00005b90 <LoadKeyCodeTables>:

	

void LoadKeyCodeTables(){
	 eeprom_read_block (( void *) KeyCodeLookUpTable, (void *) KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    5b90:	40 e4       	ldi	r20, 0x40	; 64
    5b92:	50 e0       	ldi	r21, 0x00	; 0
    5b94:	60 e0       	ldi	r22, 0x00	; 0
    5b96:	70 e0       	ldi	r23, 0x00	; 0
    5b98:	8c e1       	ldi	r24, 0x1C	; 28
    5b9a:	96 e0       	ldi	r25, 0x06	; 6
    5b9c:	0e 94 84 3b 	call	0x7708	; 0x7708 <eeprom_read_block>
	 eeprom_read_block (( void *) FnKeyCodeLookUpTable, (void *) FN_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    5ba0:	40 e4       	ldi	r20, 0x40	; 64
    5ba2:	50 e0       	ldi	r21, 0x00	; 0
    5ba4:	60 e4       	ldi	r22, 0x40	; 64
    5ba6:	70 e0       	ldi	r23, 0x00	; 0
    5ba8:	8a e6       	ldi	r24, 0x6A	; 106
    5baa:	99 e0       	ldi	r25, 0x09	; 9
    5bac:	0e 94 84 3b 	call	0x7708	; 0x7708 <eeprom_read_block>
	 eeprom_read_block (( void *) ShiftKeyCodeLookUpTable, (void *) SHIFT_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    5bb0:	40 e4       	ldi	r20, 0x40	; 64
    5bb2:	50 e0       	ldi	r21, 0x00	; 0
    5bb4:	60 e8       	ldi	r22, 0x80	; 128
    5bb6:	70 e0       	ldi	r23, 0x00	; 0
    5bb8:	89 e6       	ldi	r24, 0x69	; 105
    5bba:	96 e0       	ldi	r25, 0x06	; 6
    5bbc:	0e 94 84 3b 	call	0x7708	; 0x7708 <eeprom_read_block>
	 eeprom_read_block (( void *) ASCIILookUpTable, (void *) ASCII_ADDR, KEYCODE_ARRAY_LENGTH);
    5bc0:	40 e4       	ldi	r20, 0x40	; 64
    5bc2:	50 e0       	ldi	r21, 0x00	; 0
    5bc4:	60 ec       	ldi	r22, 0xC0	; 192
    5bc6:	70 e0       	ldi	r23, 0x00	; 0
    5bc8:	89 e2       	ldi	r24, 0x29	; 41
    5bca:	97 e0       	ldi	r25, 0x07	; 7
    5bcc:	0e 94 84 3b 	call	0x7708	; 0x7708 <eeprom_read_block>
	 eeprom_read_block (( void *) ASCIIShiftLookUpTable, (void *) ASCII_SHIFT_ADDR, KEYCODE_ARRAY_LENGTH);
    5bd0:	40 e4       	ldi	r20, 0x40	; 64
    5bd2:	50 e0       	ldi	r21, 0x00	; 0
    5bd4:	60 e0       	ldi	r22, 0x00	; 0
    5bd6:	71 e0       	ldi	r23, 0x01	; 1
    5bd8:	8a ea       	ldi	r24, 0xAA	; 170
    5bda:	96 e0       	ldi	r25, 0x06	; 6
    5bdc:	0c 94 84 3b 	jmp	0x7708	; 0x7708 <eeprom_read_block>

00005be0 <LoadEepromParameters>:

}

void LoadEepromParameters(){	
	 KeyReleaseTime = eeprom_read_byte((uint8_t *)RELEASE_TIME_ADDR);
    5be0:	82 e0       	ldi	r24, 0x02	; 2
    5be2:	92 e0       	ldi	r25, 0x02	; 2
    5be4:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    5be8:	80 93 1a 06 	sts	0x061A, r24	; 0x80061a <KeyReleaseTime>
	 KeyHoldTime = eeprom_read_byte((uint8_t *)HOLD_TIME_ADDR);
    5bec:	81 e0       	ldi	r24, 0x01	; 1
    5bee:	92 e0       	ldi	r25, 0x02	; 2
    5bf0:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    5bf4:	80 93 a9 06 	sts	0x06A9, r24	; 0x8006a9 <KeyHoldTime>
	 DoubleTapTime = eeprom_read_byte((uint8_t *)DOUBLE_TAP_ADDR);
    5bf8:	80 e0       	ldi	r24, 0x00	; 0
    5bfa:	92 e0       	ldi	r25, 0x02	; 2
    5bfc:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    5c00:	80 93 5d 06 	sts	0x065D, r24	; 0x80065d <DoubleTapTime>
	 ReedHoldTime = eeprom_read_byte((uint8_t *)REED_HOLD_TIME_ADDR);
    5c04:	8c e0       	ldi	r24, 0x0C	; 12
    5c06:	92 e0       	ldi	r25, 0x02	; 2
    5c08:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    5c0c:	80 93 5c 06 	sts	0x065C, r24	; 0x80065c <ReedHoldTime>
	 UseHallSensor = eeprom_read_byte((uint8_t *)USE_HALL_SENSOR_ADDR);
    5c10:	83 e0       	ldi	r24, 0x03	; 3
    5c12:	92 e0       	ldi	r25, 0x02	; 2
    5c14:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    5c18:	80 93 eb 06 	sts	0x06EB, r24	; 0x8006eb <UseHallSensor>
	 HallSensorPolarity = eeprom_read_byte((uint8_t *)HALL_SENSOR_POLARITY_ADDR);
    5c1c:	84 e0       	ldi	r24, 0x04	; 4
    5c1e:	92 e0       	ldi	r25, 0x02	; 2
    5c20:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    5c24:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <HallSensorPolarity>
	 Shift_Reed = eeprom_read_byte((uint8_t *)SHIFT_REED_ADDR);
    5c28:	85 e0       	ldi	r24, 0x05	; 5
    5c2a:	92 e0       	ldi	r25, 0x02	; 2
    5c2c:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    5c30:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <Shift_Reed>
	 Reeds_Are_Independent = eeprom_read_byte((uint8_t *)REEDS_INDEPENDENT_ADDR);
    5c34:	8e e0       	ldi	r24, 0x0E	; 14
    5c36:	92 e0       	ldi	r25, 0x02	; 2
    5c38:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    5c3c:	80 93 18 06 	sts	0x0618, r24	; 0x800618 <Reeds_Are_Independent>
	 UseDummyLoad = eeprom_read_byte((uint8_t*)DUMMY_LOAD_ADDR);
    5c40:	8f e0       	ldi	r24, 0x0F	; 15
    5c42:	92 e0       	ldi	r25, 0x02	; 2
    5c44:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    5c48:	80 93 17 06 	sts	0x0617, r24	; 0x800617 <UseDummyLoad>
    5c4c:	08 95       	ret

00005c4e <ClearKeyCodeTables>:
}

void ClearKeyCodeTables(){
	memset (&KeyCodeLookUpTable[0] , 0, KEYCODE_ARRAY_LENGTH);
    5c4e:	80 e4       	ldi	r24, 0x40	; 64
    5c50:	ec e1       	ldi	r30, 0x1C	; 28
    5c52:	f6 e0       	ldi	r31, 0x06	; 6
    5c54:	df 01       	movw	r26, r30
    5c56:	98 2f       	mov	r25, r24
    5c58:	1d 92       	st	X+, r1
    5c5a:	9a 95       	dec	r25
    5c5c:	e9 f7       	brne	.-6      	; 0x5c58 <ClearKeyCodeTables+0xa>
	memset (&FnKeyCodeLookUpTable[0] , 0, KEYCODE_ARRAY_LENGTH);
    5c5e:	ea e6       	ldi	r30, 0x6A	; 106
    5c60:	f9 e0       	ldi	r31, 0x09	; 9
    5c62:	df 01       	movw	r26, r30
    5c64:	98 2f       	mov	r25, r24
    5c66:	1d 92       	st	X+, r1
    5c68:	9a 95       	dec	r25
    5c6a:	e9 f7       	brne	.-6      	; 0x5c66 <ClearKeyCodeTables+0x18>
	memset (&ShiftKeyCodeLookUpTable[0], 0, KEYCODE_ARRAY_LENGTH);
    5c6c:	e9 e6       	ldi	r30, 0x69	; 105
    5c6e:	f6 e0       	ldi	r31, 0x06	; 6
    5c70:	df 01       	movw	r26, r30
    5c72:	98 2f       	mov	r25, r24
    5c74:	1d 92       	st	X+, r1
    5c76:	9a 95       	dec	r25
    5c78:	e9 f7       	brne	.-6      	; 0x5c74 <ClearKeyCodeTables+0x26>
	memset (&ASCIILookUpTable[0],0,KEYCODE_ARRAY_LENGTH);
    5c7a:	e9 e2       	ldi	r30, 0x29	; 41
    5c7c:	f7 e0       	ldi	r31, 0x07	; 7
    5c7e:	df 01       	movw	r26, r30
    5c80:	98 2f       	mov	r25, r24
    5c82:	1d 92       	st	X+, r1
    5c84:	9a 95       	dec	r25
    5c86:	e9 f7       	brne	.-6      	; 0x5c82 <ClearKeyCodeTables+0x34>
	memset (&ASCIIShiftLookUpTable[0],0,KEYCODE_ARRAY_LENGTH);
    5c88:	ea ea       	ldi	r30, 0xAA	; 170
    5c8a:	f6 e0       	ldi	r31, 0x06	; 6
    5c8c:	df 01       	movw	r26, r30
    5c8e:	1d 92       	st	X+, r1
    5c90:	8a 95       	dec	r24
    5c92:	e9 f7       	brne	.-6      	; 0x5c8e <ClearKeyCodeTables+0x40>

	Shift_Reed = 0;
    5c94:	10 92 5e 06 	sts	0x065E, r1	; 0x80065e <Shift_Reed>
    5c98:	08 95       	ret

00005c9a <RestoreFactoryDefaults>:
		eeprom_write_byte((uint8_t*)EEP_CHECKSUM_ADDR, EEP_CHECKSUM);//write the checksum to the eeprom to indicate that eeprom has been properly initialized.
	}
}

void RestoreFactoryDefaults(){
			eeprom_update_byte((uint8_t*)DOUBLE_TAP_ADDR, DEFAULT_DOUBLE_TAP_TIME);
    5c9a:	65 e0       	ldi	r22, 0x05	; 5
    5c9c:	80 e0       	ldi	r24, 0x00	; 0
    5c9e:	92 e0       	ldi	r25, 0x02	; 2
    5ca0:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)HOLD_TIME_ADDR, DEFAULT_HOLD_TIME);
    5ca4:	66 e0       	ldi	r22, 0x06	; 6
    5ca6:	81 e0       	ldi	r24, 0x01	; 1
    5ca8:	92 e0       	ldi	r25, 0x02	; 2
    5caa:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)RELEASE_TIME_ADDR, DEFAULT_RELEASE_TIME);
    5cae:	63 e0       	ldi	r22, 0x03	; 3
    5cb0:	82 e0       	ldi	r24, 0x02	; 2
    5cb2:	92 e0       	ldi	r25, 0x02	; 2
    5cb4:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)REED_HOLD_TIME_ADDR, DEFAULT_REED_HOLD_TIME);
    5cb8:	63 e0       	ldi	r22, 0x03	; 3
    5cba:	8c e0       	ldi	r24, 0x0C	; 12
    5cbc:	92 e0       	ldi	r25, 0x02	; 2
    5cbe:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)REEDS_INDEPENDENT_ADDR,REEDS_ARE_INDEPENDENT_BY_DEFAULT);
    5cc2:	60 e0       	ldi	r22, 0x00	; 0
    5cc4:	8e e0       	ldi	r24, 0x0E	; 14
    5cc6:	92 e0       	ldi	r25, 0x02	; 2
    5cc8:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)DEFAULT_MODE_ADDR,USB_COMBO_MODE);
    5ccc:	61 e0       	ldi	r22, 0x01	; 1
    5cce:	8d e0       	ldi	r24, 0x0D	; 13
    5cd0:	92 e0       	ldi	r25, 0x02	; 2
    5cd2:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)DUMMY_LOAD_ADDR,0); //do not use dummy load unless told to.
    5cd6:	60 e0       	ldi	r22, 0x00	; 0
    5cd8:	8f e0       	ldi	r24, 0x0F	; 15
    5cda:	92 e0       	ldi	r25, 0x02	; 2
    5cdc:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
			eeprom_write_word((uint16_t *)FILENUM_ADDR,0);//reset sd card file number to zero.
    5ce0:	60 e0       	ldi	r22, 0x00	; 0
    5ce2:	70 e0       	ldi	r23, 0x00	; 0
    5ce4:	8a e0       	ldi	r24, 0x0A	; 10
    5ce6:	92 e0       	ldi	r25, 0x02	; 2
    5ce8:	0e 94 ca 3b 	call	0x7794	; 0x7794 <eeprom_write_word>
//			eeprom_write_byte((uint8_t*)USE_HALL_SENSOR_ADDR,HALL_NOT_PRESENT); //dont change hall sensor when resetting defaults.
			
			LoadEepromParameters(); //load new defaults into RAM
    5cec:	79 cf       	rjmp	.-270    	; 0x5be0 <LoadEepromParameters>

00005cee <InitializeEeprom>:

	Shift_Reed = 0;
//	UseHallSensor = HALL_NOT_PRESENT;	
}

void InitializeEeprom(){
    5cee:	cf 93       	push	r28
    5cf0:	df 93       	push	r29
	int i;
	if (eeprom_read_byte((uint8_t*)EEP_CHECKSUM_ADDR) != EEP_CHECKSUM){
    5cf2:	8f ef       	ldi	r24, 0xFF	; 255
    5cf4:	93 e0       	ldi	r25, 0x03	; 3
    5cf6:	0e 94 94 3b 	call	0x7728	; 0x7728 <eeprom_read_byte>
    5cfa:	87 34       	cpi	r24, 0x47	; 71
    5cfc:	f1 f0       	breq	.+60     	; 0x5d3a <InitializeEeprom+0x4c>
    5cfe:	c0 e0       	ldi	r28, 0x00	; 0
    5d00:	d0 e0       	ldi	r29, 0x00	; 0
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
    5d02:	60 e0       	ldi	r22, 0x00	; 0
    5d04:	ce 01       	movw	r24, r28
    5d06:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>

void InitializeEeprom(){
	int i;
	if (eeprom_read_byte((uint8_t*)EEP_CHECKSUM_ADDR) != EEP_CHECKSUM){
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
    5d0a:	21 96       	adiw	r28, 0x01	; 1
    5d0c:	c1 35       	cpi	r28, 0x51	; 81
    5d0e:	81 e0       	ldi	r24, 0x01	; 1
    5d10:	d8 07       	cpc	r29, r24
    5d12:	b9 f7       	brne	.-18     	; 0x5d02 <InitializeEeprom+0x14>
    5d14:	c0 e0       	ldi	r28, 0x00	; 0
    5d16:	d2 e0       	ldi	r29, 0x02	; 2
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		for(i=EEP_BANK2; i<=EEP_BANK2_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
    5d18:	60 e0       	ldi	r22, 0x00	; 0
    5d1a:	ce 01       	movw	r24, r28
    5d1c:	0e 94 a1 3b 	call	0x7742	; 0x7742 <eeprom_update_byte>
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		for(i=EEP_BANK2; i<=EEP_BANK2_END; i++){
    5d20:	21 96       	adiw	r28, 0x01	; 1
    5d22:	c2 31       	cpi	r28, 0x12	; 18
    5d24:	82 e0       	ldi	r24, 0x02	; 2
    5d26:	d8 07       	cpc	r29, r24
    5d28:	b9 f7       	brne	.-18     	; 0x5d18 <InitializeEeprom+0x2a>
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		RestoreFactoryDefaults();
    5d2a:	b7 df       	rcall	.-146    	; 0x5c9a <RestoreFactoryDefaults>

		eeprom_write_byte((uint8_t*)EEP_CHECKSUM_ADDR, EEP_CHECKSUM);//write the checksum to the eeprom to indicate that eeprom has been properly initialized.
    5d2c:	67 e4       	ldi	r22, 0x47	; 71
    5d2e:	8f ef       	ldi	r24, 0xFF	; 255
    5d30:	93 e0       	ldi	r25, 0x03	; 3
	}
}
    5d32:	df 91       	pop	r29
    5d34:	cf 91       	pop	r28
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		RestoreFactoryDefaults();

		eeprom_write_byte((uint8_t*)EEP_CHECKSUM_ADDR, EEP_CHECKSUM);//write the checksum to the eeprom to indicate that eeprom has been properly initialized.
    5d36:	0c 94 bc 3b 	jmp	0x7778	; 0x7778 <eeprom_write_byte>
	}
}
    5d3a:	df 91       	pop	r29
    5d3c:	cf 91       	pop	r28
    5d3e:	08 95       	ret

00005d40 <HID_Device_ProcessControlRequest>:
    5d40:	6f 92       	push	r6
    5d42:	7f 92       	push	r7
    5d44:	8f 92       	push	r8
    5d46:	9f 92       	push	r9
    5d48:	af 92       	push	r10
    5d4a:	bf 92       	push	r11
    5d4c:	cf 92       	push	r12
    5d4e:	df 92       	push	r13
    5d50:	ef 92       	push	r14
    5d52:	ff 92       	push	r15
    5d54:	0f 93       	push	r16
    5d56:	1f 93       	push	r17
    5d58:	cf 93       	push	r28
    5d5a:	df 93       	push	r29
    5d5c:	00 d0       	rcall	.+0      	; 0x5d5e <HID_Device_ProcessControlRequest+0x1e>
    5d5e:	1f 92       	push	r1
    5d60:	cd b7       	in	r28, 0x3d	; 61
    5d62:	de b7       	in	r29, 0x3e	; 62
    5d64:	7c 01       	movw	r14, r24
    5d66:	ad b6       	in	r10, 0x3d	; 61
    5d68:	be b6       	in	r11, 0x3e	; 62
    5d6a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5d6e:	83 ff       	sbrs	r24, 3
    5d70:	05 c1       	rjmp	.+522    	; 0x5f7c <HID_Device_ProcessControlRequest+0x23c>
    5d72:	f7 01       	movw	r30, r14
    5d74:	80 81       	ld	r24, Z
    5d76:	90 e0       	ldi	r25, 0x00	; 0
    5d78:	20 91 b3 09 	lds	r18, 0x09B3	; 0x8009b3 <USB_ControlRequest+0x4>
    5d7c:	30 91 b4 09 	lds	r19, 0x09B4	; 0x8009b4 <USB_ControlRequest+0x5>
    5d80:	28 17       	cp	r18, r24
    5d82:	39 07       	cpc	r19, r25
    5d84:	09 f0       	breq	.+2      	; 0x5d88 <HID_Device_ProcessControlRequest+0x48>
    5d86:	fa c0       	rjmp	.+500    	; 0x5f7c <HID_Device_ProcessControlRequest+0x23c>
    5d88:	80 91 b0 09 	lds	r24, 0x09B0	; 0x8009b0 <USB_ControlRequest+0x1>
    5d8c:	83 30       	cpi	r24, 0x03	; 3
    5d8e:	09 f4       	brne	.+2      	; 0x5d92 <HID_Device_ProcessControlRequest+0x52>
    5d90:	9c c0       	rjmp	.+312    	; 0x5eca <HID_Device_ProcessControlRequest+0x18a>
    5d92:	30 f4       	brcc	.+12     	; 0x5da0 <HID_Device_ProcessControlRequest+0x60>
    5d94:	81 30       	cpi	r24, 0x01	; 1
    5d96:	71 f0       	breq	.+28     	; 0x5db4 <HID_Device_ProcessControlRequest+0x74>
    5d98:	82 30       	cpi	r24, 0x02	; 2
    5d9a:	09 f4       	brne	.+2      	; 0x5d9e <HID_Device_ProcessControlRequest+0x5e>
    5d9c:	d3 c0       	rjmp	.+422    	; 0x5f44 <HID_Device_ProcessControlRequest+0x204>
    5d9e:	ee c0       	rjmp	.+476    	; 0x5f7c <HID_Device_ProcessControlRequest+0x23c>
    5da0:	8a 30       	cpi	r24, 0x0A	; 10
    5da2:	09 f4       	brne	.+2      	; 0x5da6 <HID_Device_ProcessControlRequest+0x66>
    5da4:	b7 c0       	rjmp	.+366    	; 0x5f14 <HID_Device_ProcessControlRequest+0x1d4>
    5da6:	8b 30       	cpi	r24, 0x0B	; 11
    5da8:	09 f4       	brne	.+2      	; 0x5dac <HID_Device_ProcessControlRequest+0x6c>
    5daa:	a0 c0       	rjmp	.+320    	; 0x5eec <HID_Device_ProcessControlRequest+0x1ac>
    5dac:	89 30       	cpi	r24, 0x09	; 9
    5dae:	09 f0       	breq	.+2      	; 0x5db2 <HID_Device_ProcessControlRequest+0x72>
    5db0:	e5 c0       	rjmp	.+458    	; 0x5f7c <HID_Device_ProcessControlRequest+0x23c>
    5db2:	4e c0       	rjmp	.+156    	; 0x5e50 <HID_Device_ProcessControlRequest+0x110>
    5db4:	80 91 af 09 	lds	r24, 0x09AF	; 0x8009af <USB_ControlRequest>
    5db8:	81 3a       	cpi	r24, 0xA1	; 161
    5dba:	09 f0       	breq	.+2      	; 0x5dbe <HID_Device_ProcessControlRequest+0x7e>
    5dbc:	df c0       	rjmp	.+446    	; 0x5f7c <HID_Device_ProcessControlRequest+0x23c>
    5dbe:	8d b6       	in	r8, 0x3d	; 61
    5dc0:	9e b6       	in	r9, 0x3e	; 62
    5dc2:	1a 82       	std	Y+2, r1	; 0x02
    5dc4:	19 82       	std	Y+1, r1	; 0x01
    5dc6:	80 91 b1 09 	lds	r24, 0x09B1	; 0x8009b1 <USB_ControlRequest+0x2>
    5dca:	10 91 b2 09 	lds	r17, 0x09B2	; 0x8009b2 <USB_ControlRequest+0x3>
    5dce:	8b 83       	std	Y+3, r24	; 0x03
    5dd0:	f7 01       	movw	r30, r14
    5dd2:	80 85       	ldd	r24, Z+8	; 0x08
    5dd4:	48 2f       	mov	r20, r24
    5dd6:	50 e0       	ldi	r21, 0x00	; 0
    5dd8:	8d b7       	in	r24, 0x3d	; 61
    5dda:	9e b7       	in	r25, 0x3e	; 62
    5ddc:	84 1b       	sub	r24, r20
    5dde:	95 0b       	sbc	r25, r21
    5de0:	0f b6       	in	r0, 0x3f	; 63
    5de2:	f8 94       	cli
    5de4:	9e bf       	out	0x3e, r25	; 62
    5de6:	0f be       	out	0x3f, r0	; 63
    5de8:	8d bf       	out	0x3d, r24	; 61
    5dea:	ed b7       	in	r30, 0x3d	; 61
    5dec:	fe b7       	in	r31, 0x3e	; 62
    5dee:	31 96       	adiw	r30, 0x01	; 1
    5df0:	6f 01       	movw	r12, r30
    5df2:	60 e0       	ldi	r22, 0x00	; 0
    5df4:	70 e0       	ldi	r23, 0x00	; 0
    5df6:	cf 01       	movw	r24, r30
    5df8:	0e 94 ae 38 	call	0x715c	; 0x715c <memset>
    5dfc:	4f ef       	ldi	r20, 0xFF	; 255
    5dfe:	41 0f       	add	r20, r17
    5e00:	8e 01       	movw	r16, r28
    5e02:	0f 5f       	subi	r16, 0xFF	; 255
    5e04:	1f 4f       	sbci	r17, 0xFF	; 255
    5e06:	96 01       	movw	r18, r12
    5e08:	be 01       	movw	r22, r28
    5e0a:	6d 5f       	subi	r22, 0xFD	; 253
    5e0c:	7f 4f       	sbci	r23, 0xFF	; 255
    5e0e:	c7 01       	movw	r24, r14
    5e10:	fc d8       	rcall	.-3592   	; 0x500a <CALLBACK_HID_Device_CreateHIDReport>
    5e12:	f7 01       	movw	r30, r14
    5e14:	86 81       	ldd	r24, Z+6	; 0x06
    5e16:	97 81       	ldd	r25, Z+7	; 0x07
    5e18:	00 97       	sbiw	r24, 0x00	; 0
    5e1a:	29 f0       	breq	.+10     	; 0x5e26 <HID_Device_ProcessControlRequest+0xe6>
    5e1c:	40 85       	ldd	r20, Z+8	; 0x08
    5e1e:	50 e0       	ldi	r21, 0x00	; 0
    5e20:	b6 01       	movw	r22, r12
    5e22:	0e 94 a5 38 	call	0x714a	; 0x714a <memcpy>
    5e26:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    5e2a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5e2e:	87 7f       	andi	r24, 0xF7	; 247
    5e30:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5e34:	8b 81       	ldd	r24, Y+3	; 0x03
    5e36:	81 11       	cpse	r24, r1
    5e38:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    5e3c:	69 81       	ldd	r22, Y+1	; 0x01
    5e3e:	7a 81       	ldd	r23, Y+2	; 0x02
    5e40:	c6 01       	movw	r24, r12
    5e42:	1d d4       	rcall	.+2106   	; 0x667e <Endpoint_Write_Control_Stream_LE>
    5e44:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5e48:	8b 77       	andi	r24, 0x7B	; 123
    5e4a:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5e4e:	37 c0       	rjmp	.+110    	; 0x5ebe <HID_Device_ProcessControlRequest+0x17e>
    5e50:	80 91 af 09 	lds	r24, 0x09AF	; 0x8009af <USB_ControlRequest>
    5e54:	81 32       	cpi	r24, 0x21	; 33
    5e56:	09 f0       	breq	.+2      	; 0x5e5a <HID_Device_ProcessControlRequest+0x11a>
    5e58:	91 c0       	rjmp	.+290    	; 0x5f7c <HID_Device_ProcessControlRequest+0x23c>
    5e5a:	8d b6       	in	r8, 0x3d	; 61
    5e5c:	9e b6       	in	r9, 0x3e	; 62
    5e5e:	00 91 b5 09 	lds	r16, 0x09B5	; 0x8009b5 <USB_ControlRequest+0x6>
    5e62:	10 91 b6 09 	lds	r17, 0x09B6	; 0x8009b6 <USB_ControlRequest+0x7>
    5e66:	70 90 b1 09 	lds	r7, 0x09B1	; 0x8009b1 <USB_ControlRequest+0x2>
    5e6a:	60 90 b2 09 	lds	r6, 0x09B2	; 0x8009b2 <USB_ControlRequest+0x3>
    5e6e:	8d b7       	in	r24, 0x3d	; 61
    5e70:	9e b7       	in	r25, 0x3e	; 62
    5e72:	80 1b       	sub	r24, r16
    5e74:	91 0b       	sbc	r25, r17
    5e76:	0f b6       	in	r0, 0x3f	; 63
    5e78:	f8 94       	cli
    5e7a:	9e bf       	out	0x3e, r25	; 62
    5e7c:	0f be       	out	0x3f, r0	; 63
    5e7e:	8d bf       	out	0x3d, r24	; 61
    5e80:	ed b7       	in	r30, 0x3d	; 61
    5e82:	fe b7       	in	r31, 0x3e	; 62
    5e84:	31 96       	adiw	r30, 0x01	; 1
    5e86:	6f 01       	movw	r12, r30
    5e88:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5e8c:	87 7f       	andi	r24, 0xF7	; 247
    5e8e:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5e92:	b8 01       	movw	r22, r16
    5e94:	cf 01       	movw	r24, r30
    5e96:	51 d4       	rcall	.+2210   	; 0x673a <Endpoint_Read_Control_Stream_LE>
    5e98:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5e9c:	8e 77       	andi	r24, 0x7E	; 126
    5e9e:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5ea2:	21 e0       	ldi	r18, 0x01	; 1
    5ea4:	71 10       	cpse	r7, r1
    5ea6:	01 c0       	rjmp	.+2      	; 0x5eaa <HID_Device_ProcessControlRequest+0x16a>
    5ea8:	20 e0       	ldi	r18, 0x00	; 0
    5eaa:	30 e0       	ldi	r19, 0x00	; 0
    5eac:	02 1b       	sub	r16, r18
    5eae:	13 0b       	sbc	r17, r19
    5eb0:	2c 0d       	add	r18, r12
    5eb2:	3d 1d       	adc	r19, r13
    5eb4:	4f ef       	ldi	r20, 0xFF	; 255
    5eb6:	46 0d       	add	r20, r6
    5eb8:	67 2d       	mov	r22, r7
    5eba:	c7 01       	movw	r24, r14
    5ebc:	cd d8       	rcall	.-3686   	; 0x5058 <CALLBACK_HID_Device_ProcessHIDReport>
    5ebe:	0f b6       	in	r0, 0x3f	; 63
    5ec0:	f8 94       	cli
    5ec2:	9e be       	out	0x3e, r9	; 62
    5ec4:	0f be       	out	0x3f, r0	; 63
    5ec6:	8d be       	out	0x3d, r8	; 61
    5ec8:	59 c0       	rjmp	.+178    	; 0x5f7c <HID_Device_ProcessControlRequest+0x23c>
    5eca:	80 91 af 09 	lds	r24, 0x09AF	; 0x8009af <USB_ControlRequest>
    5ece:	81 3a       	cpi	r24, 0xA1	; 161
    5ed0:	09 f0       	breq	.+2      	; 0x5ed4 <HID_Device_ProcessControlRequest+0x194>
    5ed2:	54 c0       	rjmp	.+168    	; 0x5f7c <HID_Device_ProcessControlRequest+0x23c>
    5ed4:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5ed8:	87 7f       	andi	r24, 0xF7	; 247
    5eda:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5ede:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5ee2:	80 ff       	sbrs	r24, 0
    5ee4:	fc cf       	rjmp	.-8      	; 0x5ede <HID_Device_ProcessControlRequest+0x19e>
    5ee6:	f7 01       	movw	r30, r14
    5ee8:	81 85       	ldd	r24, Z+9	; 0x09
    5eea:	40 c0       	rjmp	.+128    	; 0x5f6c <HID_Device_ProcessControlRequest+0x22c>
    5eec:	80 91 af 09 	lds	r24, 0x09AF	; 0x8009af <USB_ControlRequest>
    5ef0:	81 32       	cpi	r24, 0x21	; 33
    5ef2:	09 f0       	breq	.+2      	; 0x5ef6 <HID_Device_ProcessControlRequest+0x1b6>
    5ef4:	43 c0       	rjmp	.+134    	; 0x5f7c <HID_Device_ProcessControlRequest+0x23c>
    5ef6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5efa:	87 7f       	andi	r24, 0xF7	; 247
    5efc:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5f00:	2f d5       	rcall	.+2654   	; 0x6960 <Endpoint_ClearStatusStage>
    5f02:	90 91 b1 09 	lds	r25, 0x09B1	; 0x8009b1 <USB_ControlRequest+0x2>
    5f06:	81 e0       	ldi	r24, 0x01	; 1
    5f08:	91 11       	cpse	r25, r1
    5f0a:	01 c0       	rjmp	.+2      	; 0x5f0e <HID_Device_ProcessControlRequest+0x1ce>
    5f0c:	80 e0       	ldi	r24, 0x00	; 0
    5f0e:	f7 01       	movw	r30, r14
    5f10:	81 87       	std	Z+9, r24	; 0x09
    5f12:	34 c0       	rjmp	.+104    	; 0x5f7c <HID_Device_ProcessControlRequest+0x23c>
    5f14:	80 91 af 09 	lds	r24, 0x09AF	; 0x8009af <USB_ControlRequest>
    5f18:	81 32       	cpi	r24, 0x21	; 33
    5f1a:	81 f5       	brne	.+96     	; 0x5f7c <HID_Device_ProcessControlRequest+0x23c>
    5f1c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5f20:	87 7f       	andi	r24, 0xF7	; 247
    5f22:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5f26:	1c d5       	rcall	.+2616   	; 0x6960 <Endpoint_ClearStatusStage>
    5f28:	80 91 b1 09 	lds	r24, 0x09B1	; 0x8009b1 <USB_ControlRequest+0x2>
    5f2c:	90 91 b2 09 	lds	r25, 0x09B2	; 0x8009b2 <USB_ControlRequest+0x3>
    5f30:	88 27       	eor	r24, r24
    5f32:	36 e0       	ldi	r19, 0x06	; 6
    5f34:	96 95       	lsr	r25
    5f36:	87 95       	ror	r24
    5f38:	3a 95       	dec	r19
    5f3a:	e1 f7       	brne	.-8      	; 0x5f34 <HID_Device_ProcessControlRequest+0x1f4>
    5f3c:	f7 01       	movw	r30, r14
    5f3e:	95 87       	std	Z+13, r25	; 0x0d
    5f40:	84 87       	std	Z+12, r24	; 0x0c
    5f42:	1c c0       	rjmp	.+56     	; 0x5f7c <HID_Device_ProcessControlRequest+0x23c>
    5f44:	80 91 af 09 	lds	r24, 0x09AF	; 0x8009af <USB_ControlRequest>
    5f48:	81 3a       	cpi	r24, 0xA1	; 161
    5f4a:	c1 f4       	brne	.+48     	; 0x5f7c <HID_Device_ProcessControlRequest+0x23c>
    5f4c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5f50:	87 7f       	andi	r24, 0xF7	; 247
    5f52:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5f56:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5f5a:	80 ff       	sbrs	r24, 0
    5f5c:	fc cf       	rjmp	.-8      	; 0x5f56 <HID_Device_ProcessControlRequest+0x216>
    5f5e:	f7 01       	movw	r30, r14
    5f60:	84 85       	ldd	r24, Z+12	; 0x0c
    5f62:	95 85       	ldd	r25, Z+13	; 0x0d
    5f64:	96 95       	lsr	r25
    5f66:	87 95       	ror	r24
    5f68:	96 95       	lsr	r25
    5f6a:	87 95       	ror	r24
    5f6c:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    5f70:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5f74:	8e 77       	andi	r24, 0x7E	; 126
    5f76:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    5f7a:	f2 d4       	rcall	.+2532   	; 0x6960 <Endpoint_ClearStatusStage>
    5f7c:	0f b6       	in	r0, 0x3f	; 63
    5f7e:	f8 94       	cli
    5f80:	be be       	out	0x3e, r11	; 62
    5f82:	0f be       	out	0x3f, r0	; 63
    5f84:	ad be       	out	0x3d, r10	; 61
    5f86:	0f 90       	pop	r0
    5f88:	0f 90       	pop	r0
    5f8a:	0f 90       	pop	r0
    5f8c:	df 91       	pop	r29
    5f8e:	cf 91       	pop	r28
    5f90:	1f 91       	pop	r17
    5f92:	0f 91       	pop	r16
    5f94:	ff 90       	pop	r15
    5f96:	ef 90       	pop	r14
    5f98:	df 90       	pop	r13
    5f9a:	cf 90       	pop	r12
    5f9c:	bf 90       	pop	r11
    5f9e:	af 90       	pop	r10
    5fa0:	9f 90       	pop	r9
    5fa2:	8f 90       	pop	r8
    5fa4:	7f 90       	pop	r7
    5fa6:	6f 90       	pop	r6
    5fa8:	08 95       	ret

00005faa <HID_Device_ConfigureEndpoints>:
    5faa:	fc 01       	movw	r30, r24
    5fac:	39 96       	adiw	r30, 0x09	; 9
    5fae:	27 e0       	ldi	r18, 0x07	; 7
    5fb0:	df 01       	movw	r26, r30
    5fb2:	1d 92       	st	X+, r1
    5fb4:	2a 95       	dec	r18
    5fb6:	e9 f7       	brne	.-6      	; 0x5fb2 <HID_Device_ConfigureEndpoints+0x8>
    5fb8:	21 e0       	ldi	r18, 0x01	; 1
    5fba:	fc 01       	movw	r30, r24
    5fbc:	21 87       	std	Z+9, r18	; 0x09
    5fbe:	24 ef       	ldi	r18, 0xF4	; 244
    5fc0:	31 e0       	ldi	r19, 0x01	; 1
    5fc2:	35 87       	std	Z+13, r19	; 0x0d
    5fc4:	24 87       	std	Z+12, r18	; 0x0c
    5fc6:	23 e0       	ldi	r18, 0x03	; 3
    5fc8:	24 83       	std	Z+4, r18	; 0x04
    5fca:	61 e0       	ldi	r22, 0x01	; 1
    5fcc:	01 96       	adiw	r24, 0x01	; 1
    5fce:	8b c4       	rjmp	.+2326   	; 0x68e6 <Endpoint_ConfigureEndpointTable>

00005fd0 <HID_Device_USBTask>:
    5fd0:	5f 92       	push	r5
    5fd2:	6f 92       	push	r6
    5fd4:	7f 92       	push	r7
    5fd6:	8f 92       	push	r8
    5fd8:	9f 92       	push	r9
    5fda:	af 92       	push	r10
    5fdc:	bf 92       	push	r11
    5fde:	cf 92       	push	r12
    5fe0:	df 92       	push	r13
    5fe2:	ef 92       	push	r14
    5fe4:	ff 92       	push	r15
    5fe6:	0f 93       	push	r16
    5fe8:	1f 93       	push	r17
    5fea:	cf 93       	push	r28
    5fec:	df 93       	push	r29
    5fee:	00 d0       	rcall	.+0      	; 0x5ff0 <HID_Device_USBTask+0x20>
    5ff0:	1f 92       	push	r1
    5ff2:	cd b7       	in	r28, 0x3d	; 61
    5ff4:	de b7       	in	r29, 0x3e	; 62
    5ff6:	7c 01       	movw	r14, r24
    5ff8:	ad b6       	in	r10, 0x3d	; 61
    5ffa:	be b6       	in	r11, 0x3e	; 62
    5ffc:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    6000:	84 30       	cpi	r24, 0x04	; 4
    6002:	09 f0       	breq	.+2      	; 0x6006 <HID_Device_USBTask+0x36>
    6004:	8a c0       	rjmp	.+276    	; 0x611a <HID_Device_USBTask+0x14a>
    6006:	80 91 e4 00 	lds	r24, 0x00E4	; 0x8000e4 <__DATA_REGION_ORIGIN__+0x84>
    600a:	90 91 e5 00 	lds	r25, 0x00E5	; 0x8000e5 <__DATA_REGION_ORIGIN__+0x85>
    600e:	f7 01       	movw	r30, r14
    6010:	22 85       	ldd	r18, Z+10	; 0x0a
    6012:	33 85       	ldd	r19, Z+11	; 0x0b
    6014:	28 17       	cp	r18, r24
    6016:	39 07       	cpc	r19, r25
    6018:	09 f4       	brne	.+2      	; 0x601c <HID_Device_USBTask+0x4c>
    601a:	7f c0       	rjmp	.+254    	; 0x611a <HID_Device_USBTask+0x14a>
    601c:	81 81       	ldd	r24, Z+1	; 0x01
    601e:	8f 70       	andi	r24, 0x0F	; 15
    6020:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    6024:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6028:	85 ff       	sbrs	r24, 5
    602a:	77 c0       	rjmp	.+238    	; 0x611a <HID_Device_USBTask+0x14a>
    602c:	8d b6       	in	r8, 0x3d	; 61
    602e:	9e b6       	in	r9, 0x3e	; 62
    6030:	40 85       	ldd	r20, Z+8	; 0x08
    6032:	50 e0       	ldi	r21, 0x00	; 0
    6034:	8d b7       	in	r24, 0x3d	; 61
    6036:	9e b7       	in	r25, 0x3e	; 62
    6038:	84 1b       	sub	r24, r20
    603a:	95 0b       	sbc	r25, r21
    603c:	0f b6       	in	r0, 0x3f	; 63
    603e:	f8 94       	cli
    6040:	9e bf       	out	0x3e, r25	; 62
    6042:	0f be       	out	0x3f, r0	; 63
    6044:	8d bf       	out	0x3d, r24	; 61
    6046:	ed b7       	in	r30, 0x3d	; 61
    6048:	fe b7       	in	r31, 0x3e	; 62
    604a:	31 96       	adiw	r30, 0x01	; 1
    604c:	6f 01       	movw	r12, r30
    604e:	1b 82       	std	Y+3, r1	; 0x03
    6050:	1a 82       	std	Y+2, r1	; 0x02
    6052:	19 82       	std	Y+1, r1	; 0x01
    6054:	60 e0       	ldi	r22, 0x00	; 0
    6056:	70 e0       	ldi	r23, 0x00	; 0
    6058:	cf 01       	movw	r24, r30
    605a:	0e 94 ae 38 	call	0x715c	; 0x715c <memset>
    605e:	8e 01       	movw	r16, r28
    6060:	0f 5f       	subi	r16, 0xFF	; 255
    6062:	1f 4f       	sbci	r17, 0xFF	; 255
    6064:	96 01       	movw	r18, r12
    6066:	40 e0       	ldi	r20, 0x00	; 0
    6068:	be 01       	movw	r22, r28
    606a:	6d 5f       	subi	r22, 0xFD	; 253
    606c:	7f 4f       	sbci	r23, 0xFF	; 255
    606e:	c7 01       	movw	r24, r14
    6070:	0e 94 05 28 	call	0x500a	; 0x500a <CALLBACK_HID_Device_CreateHIDReport>
    6074:	58 2e       	mov	r5, r24
    6076:	f7 01       	movw	r30, r14
    6078:	84 85       	ldd	r24, Z+12	; 0x0c
    607a:	95 85       	ldd	r25, Z+13	; 0x0d
    607c:	89 2b       	or	r24, r25
    607e:	29 f0       	breq	.+10     	; 0x608a <HID_Device_USBTask+0xba>
    6080:	11 e0       	ldi	r17, 0x01	; 1
    6082:	86 85       	ldd	r24, Z+14	; 0x0e
    6084:	97 85       	ldd	r25, Z+15	; 0x0f
    6086:	89 2b       	or	r24, r25
    6088:	09 f0       	breq	.+2      	; 0x608c <HID_Device_USBTask+0xbc>
    608a:	10 e0       	ldi	r17, 0x00	; 0
    608c:	f7 01       	movw	r30, r14
    608e:	66 80       	ldd	r6, Z+6	; 0x06
    6090:	77 80       	ldd	r7, Z+7	; 0x07
    6092:	61 14       	cp	r6, r1
    6094:	71 04       	cpc	r7, r1
    6096:	91 f0       	breq	.+36     	; 0x60bc <HID_Device_USBTask+0xec>
    6098:	49 81       	ldd	r20, Y+1	; 0x01
    609a:	5a 81       	ldd	r21, Y+2	; 0x02
    609c:	b3 01       	movw	r22, r6
    609e:	c6 01       	movw	r24, r12
    60a0:	0e 94 98 38 	call	0x7130	; 0x7130 <memcmp>
    60a4:	01 e0       	ldi	r16, 0x01	; 1
    60a6:	89 2b       	or	r24, r25
    60a8:	09 f4       	brne	.+2      	; 0x60ac <HID_Device_USBTask+0xdc>
    60aa:	00 e0       	ldi	r16, 0x00	; 0
    60ac:	f7 01       	movw	r30, r14
    60ae:	40 85       	ldd	r20, Z+8	; 0x08
    60b0:	50 e0       	ldi	r21, 0x00	; 0
    60b2:	b6 01       	movw	r22, r12
    60b4:	c3 01       	movw	r24, r6
    60b6:	0e 94 a5 38 	call	0x714a	; 0x714a <memcpy>
    60ba:	01 c0       	rjmp	.+2      	; 0x60be <HID_Device_USBTask+0xee>
    60bc:	00 e0       	ldi	r16, 0x00	; 0
    60be:	89 81       	ldd	r24, Y+1	; 0x01
    60c0:	9a 81       	ldd	r25, Y+2	; 0x02
    60c2:	89 2b       	or	r24, r25
    60c4:	f1 f0       	breq	.+60     	; 0x6102 <HID_Device_USBTask+0x132>
    60c6:	51 10       	cpse	r5, r1
    60c8:	04 c0       	rjmp	.+8      	; 0x60d2 <HID_Device_USBTask+0x102>
    60ca:	01 11       	cpse	r16, r1
    60cc:	02 c0       	rjmp	.+4      	; 0x60d2 <HID_Device_USBTask+0x102>
    60ce:	10 ff       	sbrs	r17, 0
    60d0:	18 c0       	rjmp	.+48     	; 0x6102 <HID_Device_USBTask+0x132>
    60d2:	f7 01       	movw	r30, r14
    60d4:	84 85       	ldd	r24, Z+12	; 0x0c
    60d6:	95 85       	ldd	r25, Z+13	; 0x0d
    60d8:	97 87       	std	Z+15, r25	; 0x0f
    60da:	86 87       	std	Z+14, r24	; 0x0e
    60dc:	81 81       	ldd	r24, Z+1	; 0x01
    60de:	8f 70       	andi	r24, 0x0F	; 15
    60e0:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    60e4:	8b 81       	ldd	r24, Y+3	; 0x03
    60e6:	81 11       	cpse	r24, r1
    60e8:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    60ec:	69 81       	ldd	r22, Y+1	; 0x01
    60ee:	7a 81       	ldd	r23, Y+2	; 0x02
    60f0:	40 e0       	ldi	r20, 0x00	; 0
    60f2:	50 e0       	ldi	r21, 0x00	; 0
    60f4:	c6 01       	movw	r24, r12
    60f6:	e0 d1       	rcall	.+960    	; 0x64b8 <Endpoint_Write_Stream_LE>
    60f8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    60fc:	8e 77       	andi	r24, 0x7E	; 126
    60fe:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6102:	80 91 e4 00 	lds	r24, 0x00E4	; 0x8000e4 <__DATA_REGION_ORIGIN__+0x84>
    6106:	90 91 e5 00 	lds	r25, 0x00E5	; 0x8000e5 <__DATA_REGION_ORIGIN__+0x85>
    610a:	f7 01       	movw	r30, r14
    610c:	93 87       	std	Z+11, r25	; 0x0b
    610e:	82 87       	std	Z+10, r24	; 0x0a
    6110:	0f b6       	in	r0, 0x3f	; 63
    6112:	f8 94       	cli
    6114:	9e be       	out	0x3e, r9	; 62
    6116:	0f be       	out	0x3f, r0	; 63
    6118:	8d be       	out	0x3d, r8	; 61
    611a:	0f b6       	in	r0, 0x3f	; 63
    611c:	f8 94       	cli
    611e:	be be       	out	0x3e, r11	; 62
    6120:	0f be       	out	0x3f, r0	; 63
    6122:	ad be       	out	0x3d, r10	; 61
    6124:	0f 90       	pop	r0
    6126:	0f 90       	pop	r0
    6128:	0f 90       	pop	r0
    612a:	df 91       	pop	r29
    612c:	cf 91       	pop	r28
    612e:	1f 91       	pop	r17
    6130:	0f 91       	pop	r16
    6132:	ff 90       	pop	r15
    6134:	ef 90       	pop	r14
    6136:	df 90       	pop	r13
    6138:	cf 90       	pop	r12
    613a:	bf 90       	pop	r11
    613c:	af 90       	pop	r10
    613e:	9f 90       	pop	r9
    6140:	8f 90       	pop	r8
    6142:	7f 90       	pop	r7
    6144:	6f 90       	pop	r6
    6146:	5f 90       	pop	r5
    6148:	08 95       	ret

0000614a <MS_Device_ProcessControlRequest>:
    614a:	cf 93       	push	r28
    614c:	df 93       	push	r29
    614e:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6152:	23 ff       	sbrs	r18, 3
    6154:	38 c0       	rjmp	.+112    	; 0x61c6 <MS_Device_ProcessControlRequest+0x7c>
    6156:	fc 01       	movw	r30, r24
    6158:	20 81       	ld	r18, Z
    615a:	30 e0       	ldi	r19, 0x00	; 0
    615c:	40 91 b3 09 	lds	r20, 0x09B3	; 0x8009b3 <USB_ControlRequest+0x4>
    6160:	50 91 b4 09 	lds	r21, 0x09B4	; 0x8009b4 <USB_ControlRequest+0x5>
    6164:	42 17       	cp	r20, r18
    6166:	53 07       	cpc	r21, r19
    6168:	71 f5       	brne	.+92     	; 0x61c6 <MS_Device_ProcessControlRequest+0x7c>
    616a:	20 91 b0 09 	lds	r18, 0x09B0	; 0x8009b0 <USB_ControlRequest+0x1>
    616e:	2e 3f       	cpi	r18, 0xFE	; 254
    6170:	81 f0       	breq	.+32     	; 0x6192 <MS_Device_ProcessControlRequest+0x48>
    6172:	2f 3f       	cpi	r18, 0xFF	; 255
    6174:	41 f5       	brne	.+80     	; 0x61c6 <MS_Device_ProcessControlRequest+0x7c>
    6176:	20 91 af 09 	lds	r18, 0x09AF	; 0x8009af <USB_ControlRequest>
    617a:	21 32       	cpi	r18, 0x21	; 33
    617c:	21 f5       	brne	.+72     	; 0x61c6 <MS_Device_ProcessControlRequest+0x7c>
    617e:	ec 01       	movw	r28, r24
    6180:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6184:	87 7f       	andi	r24, 0xF7	; 247
    6186:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    618a:	ea d3       	rcall	.+2004   	; 0x6960 <Endpoint_ClearStatusStage>
    618c:	81 e0       	ldi	r24, 0x01	; 1
    618e:	88 af       	std	Y+56, r24	; 0x38
    6190:	1a c0       	rjmp	.+52     	; 0x61c6 <MS_Device_ProcessControlRequest+0x7c>
    6192:	20 91 af 09 	lds	r18, 0x09AF	; 0x8009af <USB_ControlRequest>
    6196:	21 3a       	cpi	r18, 0xA1	; 161
    6198:	b1 f4       	brne	.+44     	; 0x61c6 <MS_Device_ProcessControlRequest+0x7c>
    619a:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    619e:	27 7f       	andi	r18, 0xF7	; 247
    61a0:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    61a4:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    61a8:	20 ff       	sbrs	r18, 0
    61aa:	fc cf       	rjmp	.-8      	; 0x61a4 <MS_Device_ProcessControlRequest+0x5a>
    61ac:	fc 01       	movw	r30, r24
    61ae:	83 85       	ldd	r24, Z+11	; 0x0b
    61b0:	81 50       	subi	r24, 0x01	; 1
    61b2:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    61b6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    61ba:	8e 77       	andi	r24, 0x7E	; 126
    61bc:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    61c0:	df 91       	pop	r29
    61c2:	cf 91       	pop	r28
    61c4:	cd c3       	rjmp	.+1946   	; 0x6960 <Endpoint_ClearStatusStage>
    61c6:	df 91       	pop	r29
    61c8:	cf 91       	pop	r28
    61ca:	08 95       	ret

000061cc <MS_Device_ConfigureEndpoints>:
    61cc:	cf 93       	push	r28
    61ce:	df 93       	push	r29
    61d0:	ec 01       	movw	r28, r24
    61d2:	fc 01       	movw	r30, r24
    61d4:	3c 96       	adiw	r30, 0x0c	; 12
    61d6:	8d e2       	ldi	r24, 0x2D	; 45
    61d8:	df 01       	movw	r26, r30
    61da:	1d 92       	st	X+, r1
    61dc:	8a 95       	dec	r24
    61de:	e9 f7       	brne	.-6      	; 0x61da <MS_Device_ConfigureEndpoints+0xe>
    61e0:	82 e0       	ldi	r24, 0x02	; 2
    61e2:	8c 83       	std	Y+4, r24	; 0x04
    61e4:	89 87       	std	Y+9, r24	; 0x09
    61e6:	61 e0       	ldi	r22, 0x01	; 1
    61e8:	ce 01       	movw	r24, r28
    61ea:	01 96       	adiw	r24, 0x01	; 1
    61ec:	7c d3       	rcall	.+1784   	; 0x68e6 <Endpoint_ConfigureEndpointTable>
    61ee:	88 23       	and	r24, r24
    61f0:	31 f0       	breq	.+12     	; 0x61fe <MS_Device_ConfigureEndpoints+0x32>
    61f2:	61 e0       	ldi	r22, 0x01	; 1
    61f4:	ce 01       	movw	r24, r28
    61f6:	06 96       	adiw	r24, 0x06	; 6
    61f8:	df 91       	pop	r29
    61fa:	cf 91       	pop	r28
    61fc:	74 c3       	rjmp	.+1768   	; 0x68e6 <Endpoint_ConfigureEndpointTable>
    61fe:	80 e0       	ldi	r24, 0x00	; 0
    6200:	df 91       	pop	r29
    6202:	cf 91       	pop	r28
    6204:	08 95       	ret

00006206 <MS_Device_USBTask>:
    6206:	ef 92       	push	r14
    6208:	ff 92       	push	r15
    620a:	0f 93       	push	r16
    620c:	1f 93       	push	r17
    620e:	cf 93       	push	r28
    6210:	df 93       	push	r29
    6212:	00 d0       	rcall	.+0      	; 0x6214 <MS_Device_USBTask+0xe>
    6214:	cd b7       	in	r28, 0x3d	; 61
    6216:	de b7       	in	r29, 0x3e	; 62
    6218:	20 91 ae 09 	lds	r18, 0x09AE	; 0x8009ae <USB_DeviceState>
    621c:	24 30       	cpi	r18, 0x04	; 4
    621e:	09 f0       	breq	.+2      	; 0x6222 <MS_Device_USBTask+0x1c>
    6220:	03 c1       	rjmp	.+518    	; 0x6428 <MS_Device_USBTask+0x222>
    6222:	8c 01       	movw	r16, r24
    6224:	fc 01       	movw	r30, r24
    6226:	86 81       	ldd	r24, Z+6	; 0x06
    6228:	8f 70       	andi	r24, 0x0F	; 15
    622a:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    622e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6232:	82 ff       	sbrs	r24, 2
    6234:	c0 c0       	rjmp	.+384    	; 0x63b6 <MS_Device_USBTask+0x1b0>
    6236:	86 81       	ldd	r24, Z+6	; 0x06
    6238:	8f 70       	andi	r24, 0x0F	; 15
    623a:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    623e:	1a 82       	std	Y+2, r1	; 0x02
    6240:	19 82       	std	Y+1, r1	; 0x01
    6242:	78 01       	movw	r14, r16
    6244:	fc e0       	ldi	r31, 0x0C	; 12
    6246:	ef 0e       	add	r14, r31
    6248:	f1 1c       	adc	r15, r1
    624a:	ae 01       	movw	r20, r28
    624c:	4f 5f       	subi	r20, 0xFF	; 255
    624e:	5f 4f       	sbci	r21, 0xFF	; 255
    6250:	6f e0       	ldi	r22, 0x0F	; 15
    6252:	70 e0       	ldi	r23, 0x00	; 0
    6254:	c7 01       	movw	r24, r14
    6256:	c9 d1       	rcall	.+914    	; 0x65ea <Endpoint_Read_Stream_LE>
    6258:	f8 01       	movw	r30, r16
    625a:	85 30       	cpi	r24, 0x05	; 5
    625c:	21 f4       	brne	.+8      	; 0x6266 <MS_Device_USBTask+0x60>
    625e:	80 ad       	ldd	r24, Z+56	; 0x38
    6260:	88 23       	and	r24, r24
    6262:	99 f3       	breq	.-26     	; 0x624a <MS_Device_USBTask+0x44>
    6264:	a8 c0       	rjmp	.+336    	; 0x63b6 <MS_Device_USBTask+0x1b0>
    6266:	84 85       	ldd	r24, Z+12	; 0x0c
    6268:	95 85       	ldd	r25, Z+13	; 0x0d
    626a:	a6 85       	ldd	r26, Z+14	; 0x0e
    626c:	b7 85       	ldd	r27, Z+15	; 0x0f
    626e:	85 35       	cpi	r24, 0x55	; 85
    6270:	93 45       	sbci	r25, 0x53	; 83
    6272:	a2 44       	sbci	r26, 0x42	; 66
    6274:	b3 44       	sbci	r27, 0x43	; 67
    6276:	61 f4       	brne	.+24     	; 0x6290 <MS_Device_USBTask+0x8a>
    6278:	f8 01       	movw	r30, r16
    627a:	91 8d       	ldd	r25, Z+25	; 0x19
    627c:	83 85       	ldd	r24, Z+11	; 0x0b
    627e:	98 17       	cp	r25, r24
    6280:	38 f4       	brcc	.+14     	; 0x6290 <MS_Device_USBTask+0x8a>
    6282:	80 8d       	ldd	r24, Z+24	; 0x18
    6284:	8f 71       	andi	r24, 0x1F	; 31
    6286:	21 f4       	brne	.+8      	; 0x6290 <MS_Device_USBTask+0x8a>
    6288:	82 8d       	ldd	r24, Z+26	; 0x1a
    628a:	81 50       	subi	r24, 0x01	; 1
    628c:	80 31       	cpi	r24, 0x10	; 16
    628e:	80 f0       	brcs	.+32     	; 0x62b0 <MS_Device_USBTask+0xaa>
    6290:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6294:	80 62       	ori	r24, 0x20	; 32
    6296:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    629a:	f8 01       	movw	r30, r16
    629c:	81 81       	ldd	r24, Z+1	; 0x01
    629e:	8f 70       	andi	r24, 0x0F	; 15
    62a0:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    62a4:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    62a8:	80 62       	ori	r24, 0x20	; 32
    62aa:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    62ae:	83 c0       	rjmp	.+262    	; 0x63b6 <MS_Device_USBTask+0x1b0>
    62b0:	1a 82       	std	Y+2, r1	; 0x02
    62b2:	19 82       	std	Y+1, r1	; 0x01
    62b4:	78 01       	movw	r14, r16
    62b6:	fb e1       	ldi	r31, 0x1B	; 27
    62b8:	ef 0e       	add	r14, r31
    62ba:	f1 1c       	adc	r15, r1
    62bc:	f8 01       	movw	r30, r16
    62be:	62 8d       	ldd	r22, Z+26	; 0x1a
    62c0:	70 e0       	ldi	r23, 0x00	; 0
    62c2:	ae 01       	movw	r20, r28
    62c4:	4f 5f       	subi	r20, 0xFF	; 255
    62c6:	5f 4f       	sbci	r21, 0xFF	; 255
    62c8:	c7 01       	movw	r24, r14
    62ca:	8f d1       	rcall	.+798    	; 0x65ea <Endpoint_Read_Stream_LE>
    62cc:	85 30       	cpi	r24, 0x05	; 5
    62ce:	29 f4       	brne	.+10     	; 0x62da <MS_Device_USBTask+0xd4>
    62d0:	f8 01       	movw	r30, r16
    62d2:	80 ad       	ldd	r24, Z+56	; 0x38
    62d4:	88 23       	and	r24, r24
    62d6:	91 f3       	breq	.-28     	; 0x62bc <MS_Device_USBTask+0xb6>
    62d8:	6e c0       	rjmp	.+220    	; 0x63b6 <MS_Device_USBTask+0x1b0>
    62da:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    62de:	8b 77       	andi	r24, 0x7B	; 123
    62e0:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    62e4:	f8 01       	movw	r30, r16
    62e6:	80 8d       	ldd	r24, Z+24	; 0x18
    62e8:	87 ff       	sbrs	r24, 7
    62ea:	04 c0       	rjmp	.+8      	; 0x62f4 <MS_Device_USBTask+0xee>
    62ec:	81 81       	ldd	r24, Z+1	; 0x01
    62ee:	8f 70       	andi	r24, 0x0F	; 15
    62f0:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    62f4:	c8 01       	movw	r24, r16
    62f6:	0e 94 04 28 	call	0x5008	; 0x5008 <CALLBACK_MS_Device_SCSICommandReceived>
    62fa:	91 e0       	ldi	r25, 0x01	; 1
    62fc:	98 27       	eor	r25, r24
    62fe:	f8 01       	movw	r30, r16
    6300:	97 ab       	std	Z+55, r25	; 0x37
    6302:	45 e5       	ldi	r20, 0x55	; 85
    6304:	53 e5       	ldi	r21, 0x53	; 83
    6306:	62 e4       	ldi	r22, 0x42	; 66
    6308:	73 e5       	ldi	r23, 0x53	; 83
    630a:	43 a7       	std	Z+43, r20	; 0x2b
    630c:	54 a7       	std	Z+44, r21	; 0x2c
    630e:	65 a7       	std	Z+45, r22	; 0x2d
    6310:	76 a7       	std	Z+46, r23	; 0x2e
    6312:	40 89       	ldd	r20, Z+16	; 0x10
    6314:	51 89       	ldd	r21, Z+17	; 0x11
    6316:	62 89       	ldd	r22, Z+18	; 0x12
    6318:	73 89       	ldd	r23, Z+19	; 0x13
    631a:	47 a7       	std	Z+47, r20	; 0x2f
    631c:	50 ab       	std	Z+48, r21	; 0x30
    631e:	61 ab       	std	Z+49, r22	; 0x31
    6320:	72 ab       	std	Z+50, r23	; 0x32
    6322:	44 89       	ldd	r20, Z+20	; 0x14
    6324:	55 89       	ldd	r21, Z+21	; 0x15
    6326:	66 89       	ldd	r22, Z+22	; 0x16
    6328:	77 89       	ldd	r23, Z+23	; 0x17
    632a:	43 ab       	std	Z+51, r20	; 0x33
    632c:	54 ab       	std	Z+52, r21	; 0x34
    632e:	65 ab       	std	Z+53, r22	; 0x35
    6330:	76 ab       	std	Z+54, r23	; 0x36
    6332:	81 11       	cpse	r24, r1
    6334:	09 c0       	rjmp	.+18     	; 0x6348 <MS_Device_USBTask+0x142>
    6336:	45 2b       	or	r20, r21
    6338:	46 2b       	or	r20, r22
    633a:	47 2b       	or	r20, r23
    633c:	29 f0       	breq	.+10     	; 0x6348 <MS_Device_USBTask+0x142>
    633e:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6342:	80 62       	ori	r24, 0x20	; 32
    6344:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6348:	f8 01       	movw	r30, r16
    634a:	86 81       	ldd	r24, Z+6	; 0x06
    634c:	8f 70       	andi	r24, 0x0F	; 15
    634e:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    6352:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6356:	85 ff       	sbrs	r24, 5
    6358:	06 c0       	rjmp	.+12     	; 0x6366 <MS_Device_USBTask+0x160>
    635a:	ec d5       	rcall	.+3032   	; 0x6f34 <USB_USBTask>
    635c:	f8 01       	movw	r30, r16
    635e:	80 ad       	ldd	r24, Z+56	; 0x38
    6360:	88 23       	and	r24, r24
    6362:	b9 f3       	breq	.-18     	; 0x6352 <MS_Device_USBTask+0x14c>
    6364:	28 c0       	rjmp	.+80     	; 0x63b6 <MS_Device_USBTask+0x1b0>
    6366:	f8 01       	movw	r30, r16
    6368:	81 81       	ldd	r24, Z+1	; 0x01
    636a:	8f 70       	andi	r24, 0x0F	; 15
    636c:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    6370:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6374:	85 ff       	sbrs	r24, 5
    6376:	06 c0       	rjmp	.+12     	; 0x6384 <MS_Device_USBTask+0x17e>
    6378:	dd d5       	rcall	.+3002   	; 0x6f34 <USB_USBTask>
    637a:	f8 01       	movw	r30, r16
    637c:	80 ad       	ldd	r24, Z+56	; 0x38
    637e:	88 23       	and	r24, r24
    6380:	b9 f3       	breq	.-18     	; 0x6370 <MS_Device_USBTask+0x16a>
    6382:	19 c0       	rjmp	.+50     	; 0x63b6 <MS_Device_USBTask+0x1b0>
    6384:	1a 82       	std	Y+2, r1	; 0x02
    6386:	19 82       	std	Y+1, r1	; 0x01
    6388:	78 01       	movw	r14, r16
    638a:	fb e2       	ldi	r31, 0x2B	; 43
    638c:	ef 0e       	add	r14, r31
    638e:	f1 1c       	adc	r15, r1
    6390:	ae 01       	movw	r20, r28
    6392:	4f 5f       	subi	r20, 0xFF	; 255
    6394:	5f 4f       	sbci	r21, 0xFF	; 255
    6396:	6d e0       	ldi	r22, 0x0D	; 13
    6398:	70 e0       	ldi	r23, 0x00	; 0
    639a:	c7 01       	movw	r24, r14
    639c:	8d d0       	rcall	.+282    	; 0x64b8 <Endpoint_Write_Stream_LE>
    639e:	85 30       	cpi	r24, 0x05	; 5
    63a0:	29 f4       	brne	.+10     	; 0x63ac <MS_Device_USBTask+0x1a6>
    63a2:	f8 01       	movw	r30, r16
    63a4:	80 ad       	ldd	r24, Z+56	; 0x38
    63a6:	88 23       	and	r24, r24
    63a8:	99 f3       	breq	.-26     	; 0x6390 <MS_Device_USBTask+0x18a>
    63aa:	05 c0       	rjmp	.+10     	; 0x63b6 <MS_Device_USBTask+0x1b0>
    63ac:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    63b0:	8e 77       	andi	r24, 0x7E	; 126
    63b2:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    63b6:	f8 01       	movw	r30, r16
    63b8:	80 ad       	ldd	r24, Z+56	; 0x38
    63ba:	88 23       	and	r24, r24
    63bc:	a9 f1       	breq	.+106    	; 0x6428 <MS_Device_USBTask+0x222>
    63be:	26 81       	ldd	r18, Z+6	; 0x06
    63c0:	2f 70       	andi	r18, 0x0F	; 15
    63c2:	81 e0       	ldi	r24, 0x01	; 1
    63c4:	90 e0       	ldi	r25, 0x00	; 0
    63c6:	ac 01       	movw	r20, r24
    63c8:	02 c0       	rjmp	.+4      	; 0x63ce <MS_Device_USBTask+0x1c8>
    63ca:	44 0f       	add	r20, r20
    63cc:	55 1f       	adc	r21, r21
    63ce:	2a 95       	dec	r18
    63d0:	e2 f7       	brpl	.-8      	; 0x63ca <MS_Device_USBTask+0x1c4>
    63d2:	40 93 ea 00 	sts	0x00EA, r20	; 0x8000ea <__DATA_REGION_ORIGIN__+0x8a>
    63d6:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <__DATA_REGION_ORIGIN__+0x8a>
    63da:	21 81       	ldd	r18, Z+1	; 0x01
    63dc:	2f 70       	andi	r18, 0x0F	; 15
    63de:	01 c0       	rjmp	.+2      	; 0x63e2 <MS_Device_USBTask+0x1dc>
    63e0:	88 0f       	add	r24, r24
    63e2:	2a 95       	dec	r18
    63e4:	ea f7       	brpl	.-6      	; 0x63e0 <MS_Device_USBTask+0x1da>
    63e6:	80 93 ea 00 	sts	0x00EA, r24	; 0x8000ea <__DATA_REGION_ORIGIN__+0x8a>
    63ea:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <__DATA_REGION_ORIGIN__+0x8a>
    63ee:	86 81       	ldd	r24, Z+6	; 0x06
    63f0:	8f 70       	andi	r24, 0x0F	; 15
    63f2:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    63f6:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    63fa:	80 61       	ori	r24, 0x10	; 16
    63fc:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6400:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6404:	88 60       	ori	r24, 0x08	; 8
    6406:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    640a:	81 81       	ldd	r24, Z+1	; 0x01
    640c:	8f 70       	andi	r24, 0x0F	; 15
    640e:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    6412:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6416:	80 61       	ori	r24, 0x10	; 16
    6418:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    641c:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6420:	88 60       	ori	r24, 0x08	; 8
    6422:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6426:	10 ae       	std	Z+56, r1	; 0x38
    6428:	0f 90       	pop	r0
    642a:	0f 90       	pop	r0
    642c:	df 91       	pop	r29
    642e:	cf 91       	pop	r28
    6430:	1f 91       	pop	r17
    6432:	0f 91       	pop	r16
    6434:	ff 90       	pop	r15
    6436:	ef 90       	pop	r14
    6438:	08 95       	ret

0000643a <Endpoint_Null_Stream>:
    643a:	ef 92       	push	r14
    643c:	ff 92       	push	r15
    643e:	0f 93       	push	r16
    6440:	1f 93       	push	r17
    6442:	cf 93       	push	r28
    6444:	df 93       	push	r29
    6446:	ec 01       	movw	r28, r24
    6448:	8b 01       	movw	r16, r22
    644a:	a9 d2       	rcall	.+1362   	; 0x699e <Endpoint_WaitUntilReady>
    644c:	81 11       	cpse	r24, r1
    644e:	2d c0       	rjmp	.+90     	; 0x64aa <Endpoint_Null_Stream+0x70>
    6450:	01 15       	cp	r16, r1
    6452:	11 05       	cpc	r17, r1
    6454:	29 f0       	breq	.+10     	; 0x6460 <Endpoint_Null_Stream+0x26>
    6456:	f8 01       	movw	r30, r16
    6458:	80 81       	ld	r24, Z
    645a:	91 81       	ldd	r25, Z+1	; 0x01
    645c:	c8 1b       	sub	r28, r24
    645e:	d9 0b       	sbc	r29, r25
    6460:	e1 2c       	mov	r14, r1
    6462:	f1 2c       	mov	r15, r1
    6464:	20 97       	sbiw	r28, 0x00	; 0
    6466:	01 f1       	breq	.+64     	; 0x64a8 <Endpoint_Null_Stream+0x6e>
    6468:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    646c:	85 fd       	sbrc	r24, 5
    646e:	15 c0       	rjmp	.+42     	; 0x649a <Endpoint_Null_Stream+0x60>
    6470:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6474:	8e 77       	andi	r24, 0x7E	; 126
    6476:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    647a:	01 15       	cp	r16, r1
    647c:	11 05       	cpc	r17, r1
    647e:	49 f0       	breq	.+18     	; 0x6492 <Endpoint_Null_Stream+0x58>
    6480:	f8 01       	movw	r30, r16
    6482:	80 81       	ld	r24, Z
    6484:	91 81       	ldd	r25, Z+1	; 0x01
    6486:	e8 0e       	add	r14, r24
    6488:	f9 1e       	adc	r15, r25
    648a:	f1 82       	std	Z+1, r15	; 0x01
    648c:	e0 82       	st	Z, r14
    648e:	85 e0       	ldi	r24, 0x05	; 5
    6490:	0c c0       	rjmp	.+24     	; 0x64aa <Endpoint_Null_Stream+0x70>
    6492:	85 d2       	rcall	.+1290   	; 0x699e <Endpoint_WaitUntilReady>
    6494:	88 23       	and	r24, r24
    6496:	31 f3       	breq	.-52     	; 0x6464 <Endpoint_Null_Stream+0x2a>
    6498:	08 c0       	rjmp	.+16     	; 0x64aa <Endpoint_Null_Stream+0x70>
    649a:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    649e:	21 97       	sbiw	r28, 0x01	; 1
    64a0:	ff ef       	ldi	r31, 0xFF	; 255
    64a2:	ef 1a       	sub	r14, r31
    64a4:	ff 0a       	sbc	r15, r31
    64a6:	de cf       	rjmp	.-68     	; 0x6464 <Endpoint_Null_Stream+0x2a>
    64a8:	80 e0       	ldi	r24, 0x00	; 0
    64aa:	df 91       	pop	r29
    64ac:	cf 91       	pop	r28
    64ae:	1f 91       	pop	r17
    64b0:	0f 91       	pop	r16
    64b2:	ff 90       	pop	r15
    64b4:	ef 90       	pop	r14
    64b6:	08 95       	ret

000064b8 <Endpoint_Write_Stream_LE>:
    64b8:	cf 92       	push	r12
    64ba:	df 92       	push	r13
    64bc:	ef 92       	push	r14
    64be:	ff 92       	push	r15
    64c0:	0f 93       	push	r16
    64c2:	1f 93       	push	r17
    64c4:	cf 93       	push	r28
    64c6:	df 93       	push	r29
    64c8:	ec 01       	movw	r28, r24
    64ca:	8b 01       	movw	r16, r22
    64cc:	7a 01       	movw	r14, r20
    64ce:	67 d2       	rcall	.+1230   	; 0x699e <Endpoint_WaitUntilReady>
    64d0:	81 11       	cpse	r24, r1
    64d2:	33 c0       	rjmp	.+102    	; 0x653a <Endpoint_Write_Stream_LE+0x82>
    64d4:	e1 14       	cp	r14, r1
    64d6:	f1 04       	cpc	r15, r1
    64d8:	39 f0       	breq	.+14     	; 0x64e8 <Endpoint_Write_Stream_LE+0x30>
    64da:	f7 01       	movw	r30, r14
    64dc:	80 81       	ld	r24, Z
    64de:	91 81       	ldd	r25, Z+1	; 0x01
    64e0:	08 1b       	sub	r16, r24
    64e2:	19 0b       	sbc	r17, r25
    64e4:	c8 0f       	add	r28, r24
    64e6:	d9 1f       	adc	r29, r25
    64e8:	c1 2c       	mov	r12, r1
    64ea:	d1 2c       	mov	r13, r1
    64ec:	01 15       	cp	r16, r1
    64ee:	11 05       	cpc	r17, r1
    64f0:	19 f1       	breq	.+70     	; 0x6538 <Endpoint_Write_Stream_LE+0x80>
    64f2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    64f6:	85 fd       	sbrc	r24, 5
    64f8:	16 c0       	rjmp	.+44     	; 0x6526 <Endpoint_Write_Stream_LE+0x6e>
    64fa:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    64fe:	8e 77       	andi	r24, 0x7E	; 126
    6500:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6504:	17 d5       	rcall	.+2606   	; 0x6f34 <USB_USBTask>
    6506:	e1 14       	cp	r14, r1
    6508:	f1 04       	cpc	r15, r1
    650a:	49 f0       	breq	.+18     	; 0x651e <Endpoint_Write_Stream_LE+0x66>
    650c:	f7 01       	movw	r30, r14
    650e:	80 81       	ld	r24, Z
    6510:	91 81       	ldd	r25, Z+1	; 0x01
    6512:	c8 0e       	add	r12, r24
    6514:	d9 1e       	adc	r13, r25
    6516:	d1 82       	std	Z+1, r13	; 0x01
    6518:	c0 82       	st	Z, r12
    651a:	85 e0       	ldi	r24, 0x05	; 5
    651c:	0e c0       	rjmp	.+28     	; 0x653a <Endpoint_Write_Stream_LE+0x82>
    651e:	3f d2       	rcall	.+1150   	; 0x699e <Endpoint_WaitUntilReady>
    6520:	88 23       	and	r24, r24
    6522:	21 f3       	breq	.-56     	; 0x64ec <Endpoint_Write_Stream_LE+0x34>
    6524:	0a c0       	rjmp	.+20     	; 0x653a <Endpoint_Write_Stream_LE+0x82>
    6526:	89 91       	ld	r24, Y+
    6528:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    652c:	01 50       	subi	r16, 0x01	; 1
    652e:	11 09       	sbc	r17, r1
    6530:	ff ef       	ldi	r31, 0xFF	; 255
    6532:	cf 1a       	sub	r12, r31
    6534:	df 0a       	sbc	r13, r31
    6536:	da cf       	rjmp	.-76     	; 0x64ec <Endpoint_Write_Stream_LE+0x34>
    6538:	80 e0       	ldi	r24, 0x00	; 0
    653a:	df 91       	pop	r29
    653c:	cf 91       	pop	r28
    653e:	1f 91       	pop	r17
    6540:	0f 91       	pop	r16
    6542:	ff 90       	pop	r15
    6544:	ef 90       	pop	r14
    6546:	df 90       	pop	r13
    6548:	cf 90       	pop	r12
    654a:	08 95       	ret

0000654c <Endpoint_Write_Stream_BE>:
    654c:	cf 92       	push	r12
    654e:	df 92       	push	r13
    6550:	ef 92       	push	r14
    6552:	ff 92       	push	r15
    6554:	0f 93       	push	r16
    6556:	1f 93       	push	r17
    6558:	cf 93       	push	r28
    655a:	df 93       	push	r29
    655c:	ec 01       	movw	r28, r24
    655e:	8b 01       	movw	r16, r22
    6560:	7a 01       	movw	r14, r20
    6562:	1d d2       	rcall	.+1082   	; 0x699e <Endpoint_WaitUntilReady>
    6564:	81 11       	cpse	r24, r1
    6566:	38 c0       	rjmp	.+112    	; 0x65d8 <Endpoint_Write_Stream_BE+0x8c>
    6568:	c8 01       	movw	r24, r16
    656a:	01 97       	sbiw	r24, 0x01	; 1
    656c:	c8 0f       	add	r28, r24
    656e:	d9 1f       	adc	r29, r25
    6570:	e1 14       	cp	r14, r1
    6572:	f1 04       	cpc	r15, r1
    6574:	39 f0       	breq	.+14     	; 0x6584 <Endpoint_Write_Stream_BE+0x38>
    6576:	f7 01       	movw	r30, r14
    6578:	80 81       	ld	r24, Z
    657a:	91 81       	ldd	r25, Z+1	; 0x01
    657c:	08 1b       	sub	r16, r24
    657e:	19 0b       	sbc	r17, r25
    6580:	c8 1b       	sub	r28, r24
    6582:	d9 0b       	sbc	r29, r25
    6584:	c1 2c       	mov	r12, r1
    6586:	d1 2c       	mov	r13, r1
    6588:	01 15       	cp	r16, r1
    658a:	11 05       	cpc	r17, r1
    658c:	21 f1       	breq	.+72     	; 0x65d6 <Endpoint_Write_Stream_BE+0x8a>
    658e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6592:	85 fd       	sbrc	r24, 5
    6594:	16 c0       	rjmp	.+44     	; 0x65c2 <Endpoint_Write_Stream_BE+0x76>
    6596:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    659a:	8e 77       	andi	r24, 0x7E	; 126
    659c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    65a0:	c9 d4       	rcall	.+2450   	; 0x6f34 <USB_USBTask>
    65a2:	e1 14       	cp	r14, r1
    65a4:	f1 04       	cpc	r15, r1
    65a6:	49 f0       	breq	.+18     	; 0x65ba <Endpoint_Write_Stream_BE+0x6e>
    65a8:	f7 01       	movw	r30, r14
    65aa:	80 81       	ld	r24, Z
    65ac:	91 81       	ldd	r25, Z+1	; 0x01
    65ae:	c8 0e       	add	r12, r24
    65b0:	d9 1e       	adc	r13, r25
    65b2:	d1 82       	std	Z+1, r13	; 0x01
    65b4:	c0 82       	st	Z, r12
    65b6:	85 e0       	ldi	r24, 0x05	; 5
    65b8:	0f c0       	rjmp	.+30     	; 0x65d8 <Endpoint_Write_Stream_BE+0x8c>
    65ba:	f1 d1       	rcall	.+994    	; 0x699e <Endpoint_WaitUntilReady>
    65bc:	88 23       	and	r24, r24
    65be:	21 f3       	breq	.-56     	; 0x6588 <Endpoint_Write_Stream_BE+0x3c>
    65c0:	0b c0       	rjmp	.+22     	; 0x65d8 <Endpoint_Write_Stream_BE+0x8c>
    65c2:	88 81       	ld	r24, Y
    65c4:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    65c8:	21 97       	sbiw	r28, 0x01	; 1
    65ca:	01 50       	subi	r16, 0x01	; 1
    65cc:	11 09       	sbc	r17, r1
    65ce:	ff ef       	ldi	r31, 0xFF	; 255
    65d0:	cf 1a       	sub	r12, r31
    65d2:	df 0a       	sbc	r13, r31
    65d4:	d9 cf       	rjmp	.-78     	; 0x6588 <Endpoint_Write_Stream_BE+0x3c>
    65d6:	80 e0       	ldi	r24, 0x00	; 0
    65d8:	df 91       	pop	r29
    65da:	cf 91       	pop	r28
    65dc:	1f 91       	pop	r17
    65de:	0f 91       	pop	r16
    65e0:	ff 90       	pop	r15
    65e2:	ef 90       	pop	r14
    65e4:	df 90       	pop	r13
    65e6:	cf 90       	pop	r12
    65e8:	08 95       	ret

000065ea <Endpoint_Read_Stream_LE>:
    65ea:	cf 92       	push	r12
    65ec:	df 92       	push	r13
    65ee:	ef 92       	push	r14
    65f0:	ff 92       	push	r15
    65f2:	0f 93       	push	r16
    65f4:	1f 93       	push	r17
    65f6:	cf 93       	push	r28
    65f8:	df 93       	push	r29
    65fa:	ec 01       	movw	r28, r24
    65fc:	8b 01       	movw	r16, r22
    65fe:	7a 01       	movw	r14, r20
    6600:	ce d1       	rcall	.+924    	; 0x699e <Endpoint_WaitUntilReady>
    6602:	81 11       	cpse	r24, r1
    6604:	33 c0       	rjmp	.+102    	; 0x666c <Endpoint_Read_Stream_LE+0x82>
    6606:	e1 14       	cp	r14, r1
    6608:	f1 04       	cpc	r15, r1
    660a:	39 f0       	breq	.+14     	; 0x661a <Endpoint_Read_Stream_LE+0x30>
    660c:	f7 01       	movw	r30, r14
    660e:	80 81       	ld	r24, Z
    6610:	91 81       	ldd	r25, Z+1	; 0x01
    6612:	08 1b       	sub	r16, r24
    6614:	19 0b       	sbc	r17, r25
    6616:	c8 0f       	add	r28, r24
    6618:	d9 1f       	adc	r29, r25
    661a:	c1 2c       	mov	r12, r1
    661c:	d1 2c       	mov	r13, r1
    661e:	01 15       	cp	r16, r1
    6620:	11 05       	cpc	r17, r1
    6622:	19 f1       	breq	.+70     	; 0x666a <Endpoint_Read_Stream_LE+0x80>
    6624:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6628:	85 fd       	sbrc	r24, 5
    662a:	16 c0       	rjmp	.+44     	; 0x6658 <Endpoint_Read_Stream_LE+0x6e>
    662c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6630:	8b 77       	andi	r24, 0x7B	; 123
    6632:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6636:	7e d4       	rcall	.+2300   	; 0x6f34 <USB_USBTask>
    6638:	e1 14       	cp	r14, r1
    663a:	f1 04       	cpc	r15, r1
    663c:	49 f0       	breq	.+18     	; 0x6650 <Endpoint_Read_Stream_LE+0x66>
    663e:	f7 01       	movw	r30, r14
    6640:	80 81       	ld	r24, Z
    6642:	91 81       	ldd	r25, Z+1	; 0x01
    6644:	c8 0e       	add	r12, r24
    6646:	d9 1e       	adc	r13, r25
    6648:	d1 82       	std	Z+1, r13	; 0x01
    664a:	c0 82       	st	Z, r12
    664c:	85 e0       	ldi	r24, 0x05	; 5
    664e:	0e c0       	rjmp	.+28     	; 0x666c <Endpoint_Read_Stream_LE+0x82>
    6650:	a6 d1       	rcall	.+844    	; 0x699e <Endpoint_WaitUntilReady>
    6652:	88 23       	and	r24, r24
    6654:	21 f3       	breq	.-56     	; 0x661e <Endpoint_Read_Stream_LE+0x34>
    6656:	0a c0       	rjmp	.+20     	; 0x666c <Endpoint_Read_Stream_LE+0x82>
    6658:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    665c:	89 93       	st	Y+, r24
    665e:	01 50       	subi	r16, 0x01	; 1
    6660:	11 09       	sbc	r17, r1
    6662:	ff ef       	ldi	r31, 0xFF	; 255
    6664:	cf 1a       	sub	r12, r31
    6666:	df 0a       	sbc	r13, r31
    6668:	da cf       	rjmp	.-76     	; 0x661e <Endpoint_Read_Stream_LE+0x34>
    666a:	80 e0       	ldi	r24, 0x00	; 0
    666c:	df 91       	pop	r29
    666e:	cf 91       	pop	r28
    6670:	1f 91       	pop	r17
    6672:	0f 91       	pop	r16
    6674:	ff 90       	pop	r15
    6676:	ef 90       	pop	r14
    6678:	df 90       	pop	r13
    667a:	cf 90       	pop	r12
    667c:	08 95       	ret

0000667e <Endpoint_Write_Control_Stream_LE>:
    667e:	20 91 b5 09 	lds	r18, 0x09B5	; 0x8009b5 <USB_ControlRequest+0x6>
    6682:	30 91 b6 09 	lds	r19, 0x09B6	; 0x8009b6 <USB_ControlRequest+0x7>
    6686:	26 17       	cp	r18, r22
    6688:	37 07       	cpc	r19, r23
    668a:	48 f0       	brcs	.+18     	; 0x669e <Endpoint_Write_Control_Stream_LE+0x20>
    668c:	61 15       	cp	r22, r1
    668e:	71 05       	cpc	r23, r1
    6690:	39 f4       	brne	.+14     	; 0x66a0 <Endpoint_Write_Control_Stream_LE+0x22>
    6692:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6696:	2e 77       	andi	r18, 0x7E	; 126
    6698:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    669c:	01 c0       	rjmp	.+2      	; 0x66a0 <Endpoint_Write_Control_Stream_LE+0x22>
    669e:	b9 01       	movw	r22, r18
    66a0:	fc 01       	movw	r30, r24
    66a2:	20 e0       	ldi	r18, 0x00	; 0
    66a4:	61 15       	cp	r22, r1
    66a6:	71 05       	cpc	r23, r1
    66a8:	79 f1       	breq	.+94     	; 0x6708 <Endpoint_Write_Control_Stream_LE+0x8a>
    66aa:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    66ae:	88 23       	and	r24, r24
    66b0:	f1 f1       	breq	.+124    	; 0x672e <Endpoint_Write_Control_Stream_LE+0xb0>
    66b2:	85 30       	cpi	r24, 0x05	; 5
    66b4:	f1 f1       	breq	.+124    	; 0x6732 <Endpoint_Write_Control_Stream_LE+0xb4>
    66b6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    66ba:	83 fd       	sbrc	r24, 3
    66bc:	3c c0       	rjmp	.+120    	; 0x6736 <Endpoint_Write_Control_Stream_LE+0xb8>
    66be:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    66c2:	82 fd       	sbrc	r24, 2
    66c4:	2e c0       	rjmp	.+92     	; 0x6722 <Endpoint_Write_Control_Stream_LE+0xa4>
    66c6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    66ca:	80 ff       	sbrs	r24, 0
    66cc:	eb cf       	rjmp	.-42     	; 0x66a4 <Endpoint_Write_Control_Stream_LE+0x26>
    66ce:	20 91 f3 00 	lds	r18, 0x00F3	; 0x8000f3 <__DATA_REGION_ORIGIN__+0x93>
    66d2:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__DATA_REGION_ORIGIN__+0x92>
    66d6:	90 e0       	ldi	r25, 0x00	; 0
    66d8:	92 2b       	or	r25, r18
    66da:	61 15       	cp	r22, r1
    66dc:	71 05       	cpc	r23, r1
    66de:	51 f0       	breq	.+20     	; 0x66f4 <Endpoint_Write_Control_Stream_LE+0x76>
    66e0:	88 30       	cpi	r24, 0x08	; 8
    66e2:	91 05       	cpc	r25, r1
    66e4:	38 f4       	brcc	.+14     	; 0x66f4 <Endpoint_Write_Control_Stream_LE+0x76>
    66e6:	21 91       	ld	r18, Z+
    66e8:	20 93 f1 00 	sts	0x00F1, r18	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    66ec:	61 50       	subi	r22, 0x01	; 1
    66ee:	71 09       	sbc	r23, r1
    66f0:	01 96       	adiw	r24, 0x01	; 1
    66f2:	f3 cf       	rjmp	.-26     	; 0x66da <Endpoint_Write_Control_Stream_LE+0x5c>
    66f4:	21 e0       	ldi	r18, 0x01	; 1
    66f6:	08 97       	sbiw	r24, 0x08	; 8
    66f8:	09 f0       	breq	.+2      	; 0x66fc <Endpoint_Write_Control_Stream_LE+0x7e>
    66fa:	20 e0       	ldi	r18, 0x00	; 0
    66fc:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6700:	8e 77       	andi	r24, 0x7E	; 126
    6702:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6706:	ce cf       	rjmp	.-100    	; 0x66a4 <Endpoint_Write_Control_Stream_LE+0x26>
    6708:	21 11       	cpse	r18, r1
    670a:	cf cf       	rjmp	.-98     	; 0x66aa <Endpoint_Write_Control_Stream_LE+0x2c>
    670c:	0a c0       	rjmp	.+20     	; 0x6722 <Endpoint_Write_Control_Stream_LE+0xa4>
    670e:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    6712:	88 23       	and	r24, r24
    6714:	61 f0       	breq	.+24     	; 0x672e <Endpoint_Write_Control_Stream_LE+0xb0>
    6716:	85 30       	cpi	r24, 0x05	; 5
    6718:	61 f0       	breq	.+24     	; 0x6732 <Endpoint_Write_Control_Stream_LE+0xb4>
    671a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    671e:	83 fd       	sbrc	r24, 3
    6720:	0a c0       	rjmp	.+20     	; 0x6736 <Endpoint_Write_Control_Stream_LE+0xb8>
    6722:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6726:	82 ff       	sbrs	r24, 2
    6728:	f2 cf       	rjmp	.-28     	; 0x670e <Endpoint_Write_Control_Stream_LE+0x90>
    672a:	80 e0       	ldi	r24, 0x00	; 0
    672c:	08 95       	ret
    672e:	82 e0       	ldi	r24, 0x02	; 2
    6730:	08 95       	ret
    6732:	83 e0       	ldi	r24, 0x03	; 3
    6734:	08 95       	ret
    6736:	81 e0       	ldi	r24, 0x01	; 1
    6738:	08 95       	ret

0000673a <Endpoint_Read_Control_Stream_LE>:
    673a:	61 15       	cp	r22, r1
    673c:	71 05       	cpc	r23, r1
    673e:	29 f4       	brne	.+10     	; 0x674a <Endpoint_Read_Control_Stream_LE+0x10>
    6740:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6744:	2b 77       	andi	r18, 0x7B	; 123
    6746:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    674a:	fc 01       	movw	r30, r24
    674c:	61 15       	cp	r22, r1
    674e:	71 05       	cpc	r23, r1
    6750:	41 f1       	breq	.+80     	; 0x67a2 <Endpoint_Read_Control_Stream_LE+0x68>
    6752:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    6756:	88 23       	and	r24, r24
    6758:	61 f1       	breq	.+88     	; 0x67b2 <Endpoint_Read_Control_Stream_LE+0x78>
    675a:	85 30       	cpi	r24, 0x05	; 5
    675c:	61 f1       	breq	.+88     	; 0x67b6 <Endpoint_Read_Control_Stream_LE+0x7c>
    675e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6762:	83 fd       	sbrc	r24, 3
    6764:	24 c0       	rjmp	.+72     	; 0x67ae <Endpoint_Read_Control_Stream_LE+0x74>
    6766:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    676a:	82 ff       	sbrs	r24, 2
    676c:	ef cf       	rjmp	.-34     	; 0x674c <Endpoint_Read_Control_Stream_LE+0x12>
    676e:	20 91 f3 00 	lds	r18, 0x00F3	; 0x8000f3 <__DATA_REGION_ORIGIN__+0x93>
    6772:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__DATA_REGION_ORIGIN__+0x92>
    6776:	90 e0       	ldi	r25, 0x00	; 0
    6778:	92 2b       	or	r25, r18
    677a:	89 2b       	or	r24, r25
    677c:	31 f0       	breq	.+12     	; 0x678a <Endpoint_Read_Control_Stream_LE+0x50>
    677e:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    6782:	81 93       	st	Z+, r24
    6784:	61 50       	subi	r22, 0x01	; 1
    6786:	71 09       	sbc	r23, r1
    6788:	91 f7       	brne	.-28     	; 0x676e <Endpoint_Read_Control_Stream_LE+0x34>
    678a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    678e:	8b 77       	andi	r24, 0x7B	; 123
    6790:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6794:	db cf       	rjmp	.-74     	; 0x674c <Endpoint_Read_Control_Stream_LE+0x12>
    6796:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    679a:	88 23       	and	r24, r24
    679c:	51 f0       	breq	.+20     	; 0x67b2 <Endpoint_Read_Control_Stream_LE+0x78>
    679e:	85 30       	cpi	r24, 0x05	; 5
    67a0:	51 f0       	breq	.+20     	; 0x67b6 <Endpoint_Read_Control_Stream_LE+0x7c>
    67a2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    67a6:	80 ff       	sbrs	r24, 0
    67a8:	f6 cf       	rjmp	.-20     	; 0x6796 <Endpoint_Read_Control_Stream_LE+0x5c>
    67aa:	80 e0       	ldi	r24, 0x00	; 0
    67ac:	08 95       	ret
    67ae:	81 e0       	ldi	r24, 0x01	; 1
    67b0:	08 95       	ret
    67b2:	82 e0       	ldi	r24, 0x02	; 2
    67b4:	08 95       	ret
    67b6:	83 e0       	ldi	r24, 0x03	; 3
    67b8:	08 95       	ret

000067ba <Endpoint_Write_Control_PStream_LE>:
    67ba:	20 91 b5 09 	lds	r18, 0x09B5	; 0x8009b5 <USB_ControlRequest+0x6>
    67be:	30 91 b6 09 	lds	r19, 0x09B6	; 0x8009b6 <USB_ControlRequest+0x7>
    67c2:	26 17       	cp	r18, r22
    67c4:	37 07       	cpc	r19, r23
    67c6:	48 f0       	brcs	.+18     	; 0x67da <Endpoint_Write_Control_PStream_LE+0x20>
    67c8:	61 15       	cp	r22, r1
    67ca:	71 05       	cpc	r23, r1
    67cc:	39 f4       	brne	.+14     	; 0x67dc <Endpoint_Write_Control_PStream_LE+0x22>
    67ce:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    67d2:	2e 77       	andi	r18, 0x7E	; 126
    67d4:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    67d8:	01 c0       	rjmp	.+2      	; 0x67dc <Endpoint_Write_Control_PStream_LE+0x22>
    67da:	b9 01       	movw	r22, r18
    67dc:	fc 01       	movw	r30, r24
    67de:	20 e0       	ldi	r18, 0x00	; 0
    67e0:	61 15       	cp	r22, r1
    67e2:	71 05       	cpc	r23, r1
    67e4:	91 f1       	breq	.+100    	; 0x684a <Endpoint_Write_Control_PStream_LE+0x90>
    67e6:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    67ea:	88 23       	and	r24, r24
    67ec:	09 f4       	brne	.+2      	; 0x67f0 <Endpoint_Write_Control_PStream_LE+0x36>
    67ee:	40 c0       	rjmp	.+128    	; 0x6870 <Endpoint_Write_Control_PStream_LE+0xb6>
    67f0:	85 30       	cpi	r24, 0x05	; 5
    67f2:	09 f4       	brne	.+2      	; 0x67f6 <Endpoint_Write_Control_PStream_LE+0x3c>
    67f4:	3f c0       	rjmp	.+126    	; 0x6874 <Endpoint_Write_Control_PStream_LE+0xba>
    67f6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    67fa:	83 fd       	sbrc	r24, 3
    67fc:	3d c0       	rjmp	.+122    	; 0x6878 <Endpoint_Write_Control_PStream_LE+0xbe>
    67fe:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6802:	82 fd       	sbrc	r24, 2
    6804:	2f c0       	rjmp	.+94     	; 0x6864 <Endpoint_Write_Control_PStream_LE+0xaa>
    6806:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    680a:	80 ff       	sbrs	r24, 0
    680c:	e9 cf       	rjmp	.-46     	; 0x67e0 <Endpoint_Write_Control_PStream_LE+0x26>
    680e:	20 91 f3 00 	lds	r18, 0x00F3	; 0x8000f3 <__DATA_REGION_ORIGIN__+0x93>
    6812:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__DATA_REGION_ORIGIN__+0x92>
    6816:	90 e0       	ldi	r25, 0x00	; 0
    6818:	92 2b       	or	r25, r18
    681a:	61 15       	cp	r22, r1
    681c:	71 05       	cpc	r23, r1
    681e:	59 f0       	breq	.+22     	; 0x6836 <Endpoint_Write_Control_PStream_LE+0x7c>
    6820:	88 30       	cpi	r24, 0x08	; 8
    6822:	91 05       	cpc	r25, r1
    6824:	40 f4       	brcc	.+16     	; 0x6836 <Endpoint_Write_Control_PStream_LE+0x7c>
    6826:	24 91       	lpm	r18, Z
    6828:	20 93 f1 00 	sts	0x00F1, r18	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    682c:	31 96       	adiw	r30, 0x01	; 1
    682e:	61 50       	subi	r22, 0x01	; 1
    6830:	71 09       	sbc	r23, r1
    6832:	01 96       	adiw	r24, 0x01	; 1
    6834:	f2 cf       	rjmp	.-28     	; 0x681a <Endpoint_Write_Control_PStream_LE+0x60>
    6836:	21 e0       	ldi	r18, 0x01	; 1
    6838:	08 97       	sbiw	r24, 0x08	; 8
    683a:	09 f0       	breq	.+2      	; 0x683e <Endpoint_Write_Control_PStream_LE+0x84>
    683c:	20 e0       	ldi	r18, 0x00	; 0
    683e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6842:	8e 77       	andi	r24, 0x7E	; 126
    6844:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6848:	cb cf       	rjmp	.-106    	; 0x67e0 <Endpoint_Write_Control_PStream_LE+0x26>
    684a:	21 11       	cpse	r18, r1
    684c:	cc cf       	rjmp	.-104    	; 0x67e6 <Endpoint_Write_Control_PStream_LE+0x2c>
    684e:	0a c0       	rjmp	.+20     	; 0x6864 <Endpoint_Write_Control_PStream_LE+0xaa>
    6850:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    6854:	88 23       	and	r24, r24
    6856:	61 f0       	breq	.+24     	; 0x6870 <Endpoint_Write_Control_PStream_LE+0xb6>
    6858:	85 30       	cpi	r24, 0x05	; 5
    685a:	61 f0       	breq	.+24     	; 0x6874 <Endpoint_Write_Control_PStream_LE+0xba>
    685c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6860:	83 fd       	sbrc	r24, 3
    6862:	0a c0       	rjmp	.+20     	; 0x6878 <Endpoint_Write_Control_PStream_LE+0xbe>
    6864:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6868:	82 ff       	sbrs	r24, 2
    686a:	f2 cf       	rjmp	.-28     	; 0x6850 <Endpoint_Write_Control_PStream_LE+0x96>
    686c:	80 e0       	ldi	r24, 0x00	; 0
    686e:	08 95       	ret
    6870:	82 e0       	ldi	r24, 0x02	; 2
    6872:	08 95       	ret
    6874:	83 e0       	ldi	r24, 0x03	; 3
    6876:	08 95       	ret
    6878:	81 e0       	ldi	r24, 0x01	; 1
    687a:	08 95       	ret

0000687c <Endpoint_ConfigureEndpoint_Prv>:
    687c:	98 2f       	mov	r25, r24
    687e:	97 30       	cpi	r25, 0x07	; 7
    6880:	68 f5       	brcc	.+90     	; 0x68dc <Endpoint_ConfigureEndpoint_Prv+0x60>
    6882:	90 93 e9 00 	sts	0x00E9, r25	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    6886:	98 17       	cp	r25, r24
    6888:	39 f0       	breq	.+14     	; 0x6898 <Endpoint_ConfigureEndpoint_Prv+0x1c>
    688a:	70 91 ec 00 	lds	r23, 0x00EC	; 0x8000ec <__DATA_REGION_ORIGIN__+0x8c>
    688e:	20 91 ed 00 	lds	r18, 0x00ED	; 0x8000ed <__DATA_REGION_ORIGIN__+0x8d>
    6892:	50 91 f0 00 	lds	r21, 0x00F0	; 0x8000f0 <__DATA_REGION_ORIGIN__+0x90>
    6896:	03 c0       	rjmp	.+6      	; 0x689e <Endpoint_ConfigureEndpoint_Prv+0x22>
    6898:	24 2f       	mov	r18, r20
    689a:	76 2f       	mov	r23, r22
    689c:	50 e0       	ldi	r21, 0x00	; 0
    689e:	21 fd       	sbrc	r18, 1
    68a0:	02 c0       	rjmp	.+4      	; 0x68a6 <Endpoint_ConfigureEndpoint_Prv+0x2a>
    68a2:	9f 5f       	subi	r25, 0xFF	; 255
    68a4:	ec cf       	rjmp	.-40     	; 0x687e <Endpoint_ConfigureEndpoint_Prv+0x2>
    68a6:	30 91 eb 00 	lds	r19, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    68aa:	3e 7f       	andi	r19, 0xFE	; 254
    68ac:	30 93 eb 00 	sts	0x00EB, r19	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    68b0:	30 91 ed 00 	lds	r19, 0x00ED	; 0x8000ed <__DATA_REGION_ORIGIN__+0x8d>
    68b4:	3d 7f       	andi	r19, 0xFD	; 253
    68b6:	30 93 ed 00 	sts	0x00ED, r19	; 0x8000ed <__DATA_REGION_ORIGIN__+0x8d>
    68ba:	30 91 eb 00 	lds	r19, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    68be:	31 60       	ori	r19, 0x01	; 1
    68c0:	30 93 eb 00 	sts	0x00EB, r19	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    68c4:	70 93 ec 00 	sts	0x00EC, r23	; 0x8000ec <__DATA_REGION_ORIGIN__+0x8c>
    68c8:	20 93 ed 00 	sts	0x00ED, r18	; 0x8000ed <__DATA_REGION_ORIGIN__+0x8d>
    68cc:	50 93 f0 00 	sts	0x00F0, r21	; 0x8000f0 <__DATA_REGION_ORIGIN__+0x90>
    68d0:	20 91 ee 00 	lds	r18, 0x00EE	; 0x8000ee <__DATA_REGION_ORIGIN__+0x8e>
    68d4:	27 fd       	sbrc	r18, 7
    68d6:	e5 cf       	rjmp	.-54     	; 0x68a2 <Endpoint_ConfigureEndpoint_Prv+0x26>
    68d8:	80 e0       	ldi	r24, 0x00	; 0
    68da:	08 95       	ret
    68dc:	8f 70       	andi	r24, 0x0F	; 15
    68de:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    68e2:	81 e0       	ldi	r24, 0x01	; 1
    68e4:	08 95       	ret

000068e6 <Endpoint_ConfigureEndpointTable>:
    68e6:	0f 93       	push	r16
    68e8:	1f 93       	push	r17
    68ea:	cf 93       	push	r28
    68ec:	df 93       	push	r29
    68ee:	06 2f       	mov	r16, r22
    68f0:	ec 01       	movw	r28, r24
    68f2:	10 e0       	ldi	r17, 0x00	; 0
    68f4:	10 17       	cp	r17, r16
    68f6:	71 f1       	breq	.+92     	; 0x6954 <Endpoint_ConfigureEndpointTable+0x6e>
    68f8:	68 81       	ld	r22, Y
    68fa:	61 11       	cpse	r22, r1
    68fc:	03 c0       	rjmp	.+6      	; 0x6904 <Endpoint_ConfigureEndpointTable+0x1e>
    68fe:	1f 5f       	subi	r17, 0xFF	; 255
    6900:	25 96       	adiw	r28, 0x05	; 5
    6902:	f8 cf       	rjmp	.-16     	; 0x68f4 <Endpoint_ConfigureEndpointTable+0xe>
    6904:	2c 81       	ldd	r18, Y+4	; 0x04
    6906:	a9 81       	ldd	r26, Y+1	; 0x01
    6908:	ba 81       	ldd	r27, Y+2	; 0x02
    690a:	9b 81       	ldd	r25, Y+3	; 0x03
    690c:	86 2f       	mov	r24, r22
    690e:	8f 70       	andi	r24, 0x0F	; 15
    6910:	87 30       	cpi	r24, 0x07	; 7
    6912:	10 f0       	brcs	.+4      	; 0x6918 <Endpoint_ConfigureEndpointTable+0x32>
    6914:	80 e0       	ldi	r24, 0x00	; 0
    6916:	1f c0       	rjmp	.+62     	; 0x6956 <Endpoint_ConfigureEndpointTable+0x70>
    6918:	22 30       	cpi	r18, 0x02	; 2
    691a:	10 f4       	brcc	.+4      	; 0x6920 <Endpoint_ConfigureEndpointTable+0x3a>
    691c:	42 e0       	ldi	r20, 0x02	; 2
    691e:	01 c0       	rjmp	.+2      	; 0x6922 <Endpoint_ConfigureEndpointTable+0x3c>
    6920:	46 e0       	ldi	r20, 0x06	; 6
    6922:	e8 e0       	ldi	r30, 0x08	; 8
    6924:	f0 e0       	ldi	r31, 0x00	; 0
    6926:	20 e0       	ldi	r18, 0x00	; 0
    6928:	ea 17       	cp	r30, r26
    692a:	fb 07       	cpc	r31, r27
    692c:	20 f4       	brcc	.+8      	; 0x6936 <Endpoint_ConfigureEndpointTable+0x50>
    692e:	2f 5f       	subi	r18, 0xFF	; 255
    6930:	ee 0f       	add	r30, r30
    6932:	ff 1f       	adc	r31, r31
    6934:	f9 cf       	rjmp	.-14     	; 0x6928 <Endpoint_ConfigureEndpointTable+0x42>
    6936:	22 95       	swap	r18
    6938:	20 7f       	andi	r18, 0xF0	; 240
    693a:	42 2b       	or	r20, r18
    693c:	50 e4       	ldi	r21, 0x40	; 64
    693e:	95 9f       	mul	r25, r21
    6940:	90 01       	movw	r18, r0
    6942:	11 24       	eor	r1, r1
    6944:	66 1f       	adc	r22, r22
    6946:	66 27       	eor	r22, r22
    6948:	66 1f       	adc	r22, r22
    694a:	62 2b       	or	r22, r18
    694c:	97 df       	rcall	.-210    	; 0x687c <Endpoint_ConfigureEndpoint_Prv>
    694e:	81 11       	cpse	r24, r1
    6950:	d6 cf       	rjmp	.-84     	; 0x68fe <Endpoint_ConfigureEndpointTable+0x18>
    6952:	e0 cf       	rjmp	.-64     	; 0x6914 <Endpoint_ConfigureEndpointTable+0x2e>
    6954:	81 e0       	ldi	r24, 0x01	; 1
    6956:	df 91       	pop	r29
    6958:	cf 91       	pop	r28
    695a:	1f 91       	pop	r17
    695c:	0f 91       	pop	r16
    695e:	08 95       	ret

00006960 <Endpoint_ClearStatusStage>:
    6960:	80 91 af 09 	lds	r24, 0x09AF	; 0x8009af <USB_ControlRequest>
    6964:	87 ff       	sbrs	r24, 7
    6966:	11 c0       	rjmp	.+34     	; 0x698a <Endpoint_ClearStatusStage+0x2a>
    6968:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    696c:	82 fd       	sbrc	r24, 2
    696e:	05 c0       	rjmp	.+10     	; 0x697a <Endpoint_ClearStatusStage+0x1a>
    6970:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    6974:	81 11       	cpse	r24, r1
    6976:	f8 cf       	rjmp	.-16     	; 0x6968 <Endpoint_ClearStatusStage+0x8>
    6978:	11 c0       	rjmp	.+34     	; 0x699c <Endpoint_ClearStatusStage+0x3c>
    697a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    697e:	8b 77       	andi	r24, 0x7B	; 123
    6980:	0b c0       	rjmp	.+22     	; 0x6998 <Endpoint_ClearStatusStage+0x38>
    6982:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    6986:	88 23       	and	r24, r24
    6988:	49 f0       	breq	.+18     	; 0x699c <Endpoint_ClearStatusStage+0x3c>
    698a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    698e:	80 ff       	sbrs	r24, 0
    6990:	f8 cf       	rjmp	.-16     	; 0x6982 <Endpoint_ClearStatusStage+0x22>
    6992:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6996:	8e 77       	andi	r24, 0x7E	; 126
    6998:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    699c:	08 95       	ret

0000699e <Endpoint_WaitUntilReady>:
    699e:	20 91 e4 00 	lds	r18, 0x00E4	; 0x8000e4 <__DATA_REGION_ORIGIN__+0x84>
    69a2:	30 91 e5 00 	lds	r19, 0x00E5	; 0x8000e5 <__DATA_REGION_ORIGIN__+0x85>
    69a6:	95 e6       	ldi	r25, 0x65	; 101
    69a8:	40 91 ec 00 	lds	r20, 0x00EC	; 0x8000ec <__DATA_REGION_ORIGIN__+0x8c>
    69ac:	84 2f       	mov	r24, r20
    69ae:	81 70       	andi	r24, 0x01	; 1
    69b0:	40 ff       	sbrs	r20, 0
    69b2:	23 c0       	rjmp	.+70     	; 0x69fa <Endpoint_WaitUntilReady+0x5c>
    69b4:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    69b8:	80 fd       	sbrc	r24, 0
    69ba:	1d c0       	rjmp	.+58     	; 0x69f6 <Endpoint_WaitUntilReady+0x58>
    69bc:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    69c0:	88 23       	and	r24, r24
    69c2:	99 f0       	breq	.+38     	; 0x69ea <Endpoint_WaitUntilReady+0x4c>
    69c4:	85 30       	cpi	r24, 0x05	; 5
    69c6:	99 f0       	breq	.+38     	; 0x69ee <Endpoint_WaitUntilReady+0x50>
    69c8:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    69cc:	85 fd       	sbrc	r24, 5
    69ce:	11 c0       	rjmp	.+34     	; 0x69f2 <Endpoint_WaitUntilReady+0x54>
    69d0:	40 91 e4 00 	lds	r20, 0x00E4	; 0x8000e4 <__DATA_REGION_ORIGIN__+0x84>
    69d4:	50 91 e5 00 	lds	r21, 0x00E5	; 0x8000e5 <__DATA_REGION_ORIGIN__+0x85>
    69d8:	24 17       	cp	r18, r20
    69da:	35 07       	cpc	r19, r21
    69dc:	29 f3       	breq	.-54     	; 0x69a8 <Endpoint_WaitUntilReady+0xa>
    69de:	91 50       	subi	r25, 0x01	; 1
    69e0:	11 f0       	breq	.+4      	; 0x69e6 <Endpoint_WaitUntilReady+0x48>
    69e2:	9a 01       	movw	r18, r20
    69e4:	e1 cf       	rjmp	.-62     	; 0x69a8 <Endpoint_WaitUntilReady+0xa>
    69e6:	84 e0       	ldi	r24, 0x04	; 4
    69e8:	08 95       	ret
    69ea:	82 e0       	ldi	r24, 0x02	; 2
    69ec:	08 95       	ret
    69ee:	83 e0       	ldi	r24, 0x03	; 3
    69f0:	08 95       	ret
    69f2:	81 e0       	ldi	r24, 0x01	; 1
    69f4:	08 95       	ret
    69f6:	80 e0       	ldi	r24, 0x00	; 0
    69f8:	08 95       	ret
    69fa:	40 91 e8 00 	lds	r20, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    69fe:	42 ff       	sbrs	r20, 2
    6a00:	dd cf       	rjmp	.-70     	; 0x69bc <Endpoint_WaitUntilReady+0x1e>
    6a02:	08 95       	ret

00006a04 <USB_Disable>:
    6a04:	67 d0       	rcall	.+206    	; 0x6ad4 <USB_INT_DisableAllInterrupts>
    6a06:	6e d0       	rcall	.+220    	; 0x6ae4 <USB_INT_ClearAllInterrupts>
    6a08:	e0 ee       	ldi	r30, 0xE0	; 224
    6a0a:	f0 e0       	ldi	r31, 0x00	; 0
    6a0c:	80 81       	ld	r24, Z
    6a0e:	81 60       	ori	r24, 0x01	; 1
    6a10:	80 83       	st	Z, r24
    6a12:	e8 ed       	ldi	r30, 0xD8	; 216
    6a14:	f0 e0       	ldi	r31, 0x00	; 0
    6a16:	80 81       	ld	r24, Z
    6a18:	8f 77       	andi	r24, 0x7F	; 127
    6a1a:	80 83       	st	Z, r24
    6a1c:	19 bc       	out	0x29, r1	; 41
    6a1e:	a7 ed       	ldi	r26, 0xD7	; 215
    6a20:	b0 e0       	ldi	r27, 0x00	; 0
    6a22:	8c 91       	ld	r24, X
    6a24:	8e 7f       	andi	r24, 0xFE	; 254
    6a26:	8c 93       	st	X, r24
    6a28:	80 81       	ld	r24, Z
    6a2a:	8f 7e       	andi	r24, 0xEF	; 239
    6a2c:	80 83       	st	Z, r24
    6a2e:	10 92 ad 09 	sts	0x09AD, r1	; 0x8009ad <USB_IsInitialized>
    6a32:	08 95       	ret

00006a34 <USB_ResetInterface>:
    6a34:	0f 93       	push	r16
    6a36:	1f 93       	push	r17
    6a38:	cf 93       	push	r28
    6a3a:	df 93       	push	r29
    6a3c:	4b d0       	rcall	.+150    	; 0x6ad4 <USB_INT_DisableAllInterrupts>
    6a3e:	52 d0       	rcall	.+164    	; 0x6ae4 <USB_INT_ClearAllInterrupts>
    6a40:	c8 ed       	ldi	r28, 0xD8	; 216
    6a42:	d0 e0       	ldi	r29, 0x00	; 0
    6a44:	88 81       	ld	r24, Y
    6a46:	8f 77       	andi	r24, 0x7F	; 127
    6a48:	88 83       	st	Y, r24
    6a4a:	88 81       	ld	r24, Y
    6a4c:	80 68       	ori	r24, 0x80	; 128
    6a4e:	88 83       	st	Y, r24
    6a50:	88 81       	ld	r24, Y
    6a52:	8f 7d       	andi	r24, 0xDF	; 223
    6a54:	88 83       	st	Y, r24
    6a56:	19 bc       	out	0x29, r1	; 41
    6a58:	10 92 ae 09 	sts	0x09AE, r1	; 0x8009ae <USB_DeviceState>
    6a5c:	10 92 aa 09 	sts	0x09AA, r1	; 0x8009aa <USB_Device_ConfigurationNumber>
    6a60:	10 92 ac 09 	sts	0x09AC, r1	; 0x8009ac <USB_Device_RemoteWakeupEnabled>
    6a64:	10 92 ab 09 	sts	0x09AB, r1	; 0x8009ab <USB_Device_CurrentlySelfPowered>
    6a68:	00 ee       	ldi	r16, 0xE0	; 224
    6a6a:	10 e0       	ldi	r17, 0x00	; 0
    6a6c:	f8 01       	movw	r30, r16
    6a6e:	80 81       	ld	r24, Z
    6a70:	8b 7f       	andi	r24, 0xFB	; 251
    6a72:	80 83       	st	Z, r24
    6a74:	88 81       	ld	r24, Y
    6a76:	81 60       	ori	r24, 0x01	; 1
    6a78:	88 83       	st	Y, r24
    6a7a:	42 e0       	ldi	r20, 0x02	; 2
    6a7c:	60 e0       	ldi	r22, 0x00	; 0
    6a7e:	80 e0       	ldi	r24, 0x00	; 0
    6a80:	fd de       	rcall	.-518    	; 0x687c <Endpoint_ConfigureEndpoint_Prv>
    6a82:	e1 ee       	ldi	r30, 0xE1	; 225
    6a84:	f0 e0       	ldi	r31, 0x00	; 0
    6a86:	80 81       	ld	r24, Z
    6a88:	8e 7f       	andi	r24, 0xFE	; 254
    6a8a:	80 83       	st	Z, r24
    6a8c:	e2 ee       	ldi	r30, 0xE2	; 226
    6a8e:	f0 e0       	ldi	r31, 0x00	; 0
    6a90:	80 81       	ld	r24, Z
    6a92:	81 60       	ori	r24, 0x01	; 1
    6a94:	80 83       	st	Z, r24
    6a96:	80 81       	ld	r24, Z
    6a98:	88 60       	ori	r24, 0x08	; 8
    6a9a:	80 83       	st	Z, r24
    6a9c:	f8 01       	movw	r30, r16
    6a9e:	80 81       	ld	r24, Z
    6aa0:	8e 7f       	andi	r24, 0xFE	; 254
    6aa2:	80 83       	st	Z, r24
    6aa4:	88 81       	ld	r24, Y
    6aa6:	80 61       	ori	r24, 0x10	; 16
    6aa8:	88 83       	st	Y, r24
    6aaa:	df 91       	pop	r29
    6aac:	cf 91       	pop	r28
    6aae:	1f 91       	pop	r17
    6ab0:	0f 91       	pop	r16
    6ab2:	08 95       	ret

00006ab4 <USB_Init>:
    6ab4:	e8 ed       	ldi	r30, 0xD8	; 216
    6ab6:	f0 e0       	ldi	r31, 0x00	; 0
    6ab8:	80 81       	ld	r24, Z
    6aba:	8f 7e       	andi	r24, 0xEF	; 239
    6abc:	80 83       	st	Z, r24
    6abe:	e7 ed       	ldi	r30, 0xD7	; 215
    6ac0:	f0 e0       	ldi	r31, 0x00	; 0
    6ac2:	80 81       	ld	r24, Z
    6ac4:	81 60       	ori	r24, 0x01	; 1
    6ac6:	80 83       	st	Z, r24
    6ac8:	84 e0       	ldi	r24, 0x04	; 4
    6aca:	82 bf       	out	0x32, r24	; 50
    6acc:	81 e0       	ldi	r24, 0x01	; 1
    6ace:	80 93 ad 09 	sts	0x09AD, r24	; 0x8009ad <USB_IsInitialized>
    6ad2:	b0 cf       	rjmp	.-160    	; 0x6a34 <USB_ResetInterface>

00006ad4 <USB_INT_DisableAllInterrupts>:
    6ad4:	e8 ed       	ldi	r30, 0xD8	; 216
    6ad6:	f0 e0       	ldi	r31, 0x00	; 0
    6ad8:	80 81       	ld	r24, Z
    6ada:	8e 7f       	andi	r24, 0xFE	; 254
    6adc:	80 83       	st	Z, r24
    6ade:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6ae2:	08 95       	ret

00006ae4 <USB_INT_ClearAllInterrupts>:
    6ae4:	10 92 da 00 	sts	0x00DA, r1	; 0x8000da <__DATA_REGION_ORIGIN__+0x7a>
    6ae8:	10 92 e1 00 	sts	0x00E1, r1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    6aec:	08 95       	ret

00006aee <__vector_10>:
    6aee:	1f 92       	push	r1
    6af0:	0f 92       	push	r0
    6af2:	0f b6       	in	r0, 0x3f	; 63
    6af4:	0f 92       	push	r0
    6af6:	11 24       	eor	r1, r1
    6af8:	2f 93       	push	r18
    6afa:	3f 93       	push	r19
    6afc:	4f 93       	push	r20
    6afe:	5f 93       	push	r21
    6b00:	6f 93       	push	r22
    6b02:	7f 93       	push	r23
    6b04:	8f 93       	push	r24
    6b06:	9f 93       	push	r25
    6b08:	af 93       	push	r26
    6b0a:	bf 93       	push	r27
    6b0c:	ef 93       	push	r30
    6b0e:	ff 93       	push	r31
    6b10:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    6b14:	82 ff       	sbrs	r24, 2
    6b16:	0b c0       	rjmp	.+22     	; 0x6b2e <__vector_10+0x40>
    6b18:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6b1c:	82 ff       	sbrs	r24, 2
    6b1e:	07 c0       	rjmp	.+14     	; 0x6b2e <__vector_10+0x40>
    6b20:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    6b24:	8b 7f       	andi	r24, 0xFB	; 251
    6b26:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    6b2a:	0e 94 f8 27 	call	0x4ff0	; 0x4ff0 <EVENT_USB_Device_StartOfFrame>
    6b2e:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__DATA_REGION_ORIGIN__+0x7a>
    6b32:	80 ff       	sbrs	r24, 0
    6b34:	1d c0       	rjmp	.+58     	; 0x6b70 <__vector_10+0x82>
    6b36:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>
    6b3a:	80 ff       	sbrs	r24, 0
    6b3c:	19 c0       	rjmp	.+50     	; 0x6b70 <__vector_10+0x82>
    6b3e:	80 91 da 00 	lds	r24, 0x00DA	; 0x8000da <__DATA_REGION_ORIGIN__+0x7a>
    6b42:	8e 7f       	andi	r24, 0xFE	; 254
    6b44:	80 93 da 00 	sts	0x00DA, r24	; 0x8000da <__DATA_REGION_ORIGIN__+0x7a>
    6b48:	80 91 d9 00 	lds	r24, 0x00D9	; 0x8000d9 <__DATA_REGION_ORIGIN__+0x79>
    6b4c:	19 bc       	out	0x29, r1	; 41
    6b4e:	80 ff       	sbrs	r24, 0
    6b50:	0b c0       	rjmp	.+22     	; 0x6b68 <__vector_10+0x7a>
    6b52:	82 e0       	ldi	r24, 0x02	; 2
    6b54:	89 bd       	out	0x29, r24	; 41
    6b56:	09 b4       	in	r0, 0x29	; 41
    6b58:	00 fe       	sbrs	r0, 0
    6b5a:	fd cf       	rjmp	.-6      	; 0x6b56 <__vector_10+0x68>
    6b5c:	81 e0       	ldi	r24, 0x01	; 1
    6b5e:	80 93 ae 09 	sts	0x09AE, r24	; 0x8009ae <USB_DeviceState>
    6b62:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <EVENT_USB_Device_Connect>
    6b66:	04 c0       	rjmp	.+8      	; 0x6b70 <__vector_10+0x82>
    6b68:	10 92 ae 09 	sts	0x09AE, r1	; 0x8009ae <USB_DeviceState>
    6b6c:	0e 94 db 27 	call	0x4fb6	; 0x4fb6 <EVENT_USB_Device_Disconnect>
    6b70:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    6b74:	80 ff       	sbrs	r24, 0
    6b76:	19 c0       	rjmp	.+50     	; 0x6baa <__vector_10+0xbc>
    6b78:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6b7c:	80 ff       	sbrs	r24, 0
    6b7e:	15 c0       	rjmp	.+42     	; 0x6baa <__vector_10+0xbc>
    6b80:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6b84:	8e 7f       	andi	r24, 0xFE	; 254
    6b86:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6b8a:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6b8e:	80 61       	ori	r24, 0x10	; 16
    6b90:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6b94:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>
    6b98:	80 62       	ori	r24, 0x20	; 32
    6b9a:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>
    6b9e:	19 bc       	out	0x29, r1	; 41
    6ba0:	85 e0       	ldi	r24, 0x05	; 5
    6ba2:	80 93 ae 09 	sts	0x09AE, r24	; 0x8009ae <USB_DeviceState>
    6ba6:	0e 94 e2 27 	call	0x4fc4	; 0x4fc4 <EVENT_USB_Device_Suspend>
    6baa:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    6bae:	84 ff       	sbrs	r24, 4
    6bb0:	2f c0       	rjmp	.+94     	; 0x6c10 <__vector_10+0x122>
    6bb2:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6bb6:	84 ff       	sbrs	r24, 4
    6bb8:	2b c0       	rjmp	.+86     	; 0x6c10 <__vector_10+0x122>
    6bba:	19 bc       	out	0x29, r1	; 41
    6bbc:	82 e0       	ldi	r24, 0x02	; 2
    6bbe:	89 bd       	out	0x29, r24	; 41
    6bc0:	09 b4       	in	r0, 0x29	; 41
    6bc2:	00 fe       	sbrs	r0, 0
    6bc4:	fd cf       	rjmp	.-6      	; 0x6bc0 <__vector_10+0xd2>
    6bc6:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>
    6bca:	8f 7d       	andi	r24, 0xDF	; 223
    6bcc:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>
    6bd0:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    6bd4:	8f 7e       	andi	r24, 0xEF	; 239
    6bd6:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    6bda:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6bde:	8f 7e       	andi	r24, 0xEF	; 239
    6be0:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6be4:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6be8:	81 60       	ori	r24, 0x01	; 1
    6bea:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6bee:	80 91 aa 09 	lds	r24, 0x09AA	; 0x8009aa <USB_Device_ConfigurationNumber>
    6bf2:	88 23       	and	r24, r24
    6bf4:	11 f0       	breq	.+4      	; 0x6bfa <__vector_10+0x10c>
    6bf6:	84 e0       	ldi	r24, 0x04	; 4
    6bf8:	07 c0       	rjmp	.+14     	; 0x6c08 <__vector_10+0x11a>
    6bfa:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__DATA_REGION_ORIGIN__+0x83>
    6bfe:	87 fd       	sbrc	r24, 7
    6c00:	02 c0       	rjmp	.+4      	; 0x6c06 <__vector_10+0x118>
    6c02:	81 e0       	ldi	r24, 0x01	; 1
    6c04:	01 c0       	rjmp	.+2      	; 0x6c08 <__vector_10+0x11a>
    6c06:	83 e0       	ldi	r24, 0x03	; 3
    6c08:	80 93 ae 09 	sts	0x09AE, r24	; 0x8009ae <USB_DeviceState>
    6c0c:	0e 94 e3 27 	call	0x4fc6	; 0x4fc6 <EVENT_USB_Device_WakeUp>
    6c10:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    6c14:	83 ff       	sbrs	r24, 3
    6c16:	22 c0       	rjmp	.+68     	; 0x6c5c <__vector_10+0x16e>
    6c18:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6c1c:	83 ff       	sbrs	r24, 3
    6c1e:	1e c0       	rjmp	.+60     	; 0x6c5c <__vector_10+0x16e>
    6c20:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    6c24:	87 7f       	andi	r24, 0xF7	; 247
    6c26:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    6c2a:	82 e0       	ldi	r24, 0x02	; 2
    6c2c:	80 93 ae 09 	sts	0x09AE, r24	; 0x8009ae <USB_DeviceState>
    6c30:	10 92 aa 09 	sts	0x09AA, r1	; 0x8009aa <USB_Device_ConfigurationNumber>
    6c34:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    6c38:	8e 7f       	andi	r24, 0xFE	; 254
    6c3a:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    6c3e:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6c42:	8e 7f       	andi	r24, 0xFE	; 254
    6c44:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6c48:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6c4c:	80 61       	ori	r24, 0x10	; 16
    6c4e:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    6c52:	42 e0       	ldi	r20, 0x02	; 2
    6c54:	60 e0       	ldi	r22, 0x00	; 0
    6c56:	80 e0       	ldi	r24, 0x00	; 0
    6c58:	11 de       	rcall	.-990    	; 0x687c <Endpoint_ConfigureEndpoint_Prv>
    6c5a:	6b d1       	rcall	.+726    	; 0x6f32 <USB_Event_Stub>
    6c5c:	ff 91       	pop	r31
    6c5e:	ef 91       	pop	r30
    6c60:	bf 91       	pop	r27
    6c62:	af 91       	pop	r26
    6c64:	9f 91       	pop	r25
    6c66:	8f 91       	pop	r24
    6c68:	7f 91       	pop	r23
    6c6a:	6f 91       	pop	r22
    6c6c:	5f 91       	pop	r21
    6c6e:	4f 91       	pop	r20
    6c70:	3f 91       	pop	r19
    6c72:	2f 91       	pop	r18
    6c74:	0f 90       	pop	r0
    6c76:	0f be       	out	0x3f, r0	; 63
    6c78:	0f 90       	pop	r0
    6c7a:	1f 90       	pop	r1
    6c7c:	18 95       	reti

00006c7e <USB_Device_ProcessControlRequest>:
    6c7e:	1f 93       	push	r17
    6c80:	cf 93       	push	r28
    6c82:	df 93       	push	r29
    6c84:	cd b7       	in	r28, 0x3d	; 61
    6c86:	de b7       	in	r29, 0x3e	; 62
    6c88:	aa 97       	sbiw	r28, 0x2a	; 42
    6c8a:	0f b6       	in	r0, 0x3f	; 63
    6c8c:	f8 94       	cli
    6c8e:	de bf       	out	0x3e, r29	; 62
    6c90:	0f be       	out	0x3f, r0	; 63
    6c92:	cd bf       	out	0x3d, r28	; 61
    6c94:	ef ea       	ldi	r30, 0xAF	; 175
    6c96:	f9 e0       	ldi	r31, 0x09	; 9
    6c98:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    6c9c:	81 93       	st	Z+, r24
    6c9e:	29 e0       	ldi	r18, 0x09	; 9
    6ca0:	e7 3b       	cpi	r30, 0xB7	; 183
    6ca2:	f2 07       	cpc	r31, r18
    6ca4:	c9 f7       	brne	.-14     	; 0x6c98 <USB_Device_ProcessControlRequest+0x1a>
    6ca6:	0e 94 f1 27 	call	0x4fe2	; 0x4fe2 <EVENT_USB_Device_ControlRequest>
    6caa:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6cae:	83 ff       	sbrs	r24, 3
    6cb0:	28 c1       	rjmp	.+592    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6cb2:	80 91 af 09 	lds	r24, 0x09AF	; 0x8009af <USB_ControlRequest>
    6cb6:	90 91 b0 09 	lds	r25, 0x09B0	; 0x8009b0 <USB_ControlRequest+0x1>
    6cba:	95 30       	cpi	r25, 0x05	; 5
    6cbc:	09 f4       	brne	.+2      	; 0x6cc0 <USB_Device_ProcessControlRequest+0x42>
    6cbe:	78 c0       	rjmp	.+240    	; 0x6db0 <USB_Device_ProcessControlRequest+0x132>
    6cc0:	30 f4       	brcc	.+12     	; 0x6cce <USB_Device_ProcessControlRequest+0x50>
    6cc2:	91 30       	cpi	r25, 0x01	; 1
    6cc4:	81 f1       	breq	.+96     	; 0x6d26 <USB_Device_ProcessControlRequest+0xa8>
    6cc6:	68 f0       	brcs	.+26     	; 0x6ce2 <USB_Device_ProcessControlRequest+0x64>
    6cc8:	93 30       	cpi	r25, 0x03	; 3
    6cca:	69 f1       	breq	.+90     	; 0x6d26 <USB_Device_ProcessControlRequest+0xa8>
    6ccc:	1a c1       	rjmp	.+564    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6cce:	98 30       	cpi	r25, 0x08	; 8
    6cd0:	09 f4       	brne	.+2      	; 0x6cd4 <USB_Device_ProcessControlRequest+0x56>
    6cd2:	e3 c0       	rjmp	.+454    	; 0x6e9a <USB_Device_ProcessControlRequest+0x21c>
    6cd4:	99 30       	cpi	r25, 0x09	; 9
    6cd6:	09 f4       	brne	.+2      	; 0x6cda <USB_Device_ProcessControlRequest+0x5c>
    6cd8:	f2 c0       	rjmp	.+484    	; 0x6ebe <USB_Device_ProcessControlRequest+0x240>
    6cda:	96 30       	cpi	r25, 0x06	; 6
    6cdc:	09 f0       	breq	.+2      	; 0x6ce0 <USB_Device_ProcessControlRequest+0x62>
    6cde:	11 c1       	rjmp	.+546    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6ce0:	89 c0       	rjmp	.+274    	; 0x6df4 <USB_Device_ProcessControlRequest+0x176>
    6ce2:	80 38       	cpi	r24, 0x80	; 128
    6ce4:	81 f0       	breq	.+32     	; 0x6d06 <USB_Device_ProcessControlRequest+0x88>
    6ce6:	82 38       	cpi	r24, 0x82	; 130
    6ce8:	09 f0       	breq	.+2      	; 0x6cec <USB_Device_ProcessControlRequest+0x6e>
    6cea:	0b c1       	rjmp	.+534    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6cec:	80 91 b3 09 	lds	r24, 0x09B3	; 0x8009b3 <USB_ControlRequest+0x4>
    6cf0:	8f 70       	andi	r24, 0x0F	; 15
    6cf2:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    6cf6:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6cfa:	85 fb       	bst	r24, 5
    6cfc:	88 27       	eor	r24, r24
    6cfe:	80 f9       	bld	r24, 0
    6d00:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    6d04:	06 c0       	rjmp	.+12     	; 0x6d12 <USB_Device_ProcessControlRequest+0x94>
    6d06:	80 91 ab 09 	lds	r24, 0x09AB	; 0x8009ab <USB_Device_CurrentlySelfPowered>
    6d0a:	90 91 ac 09 	lds	r25, 0x09AC	; 0x8009ac <USB_Device_RemoteWakeupEnabled>
    6d0e:	91 11       	cpse	r25, r1
    6d10:	82 60       	ori	r24, 0x02	; 2
    6d12:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6d16:	97 7f       	andi	r25, 0xF7	; 247
    6d18:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6d1c:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    6d20:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    6d24:	c5 c0       	rjmp	.+394    	; 0x6eb0 <USB_Device_ProcessControlRequest+0x232>
    6d26:	28 2f       	mov	r18, r24
    6d28:	2d 7f       	andi	r18, 0xFD	; 253
    6d2a:	09 f0       	breq	.+2      	; 0x6d2e <USB_Device_ProcessControlRequest+0xb0>
    6d2c:	ea c0       	rjmp	.+468    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6d2e:	88 23       	and	r24, r24
    6d30:	19 f0       	breq	.+6      	; 0x6d38 <USB_Device_ProcessControlRequest+0xba>
    6d32:	82 30       	cpi	r24, 0x02	; 2
    6d34:	61 f0       	breq	.+24     	; 0x6d4e <USB_Device_ProcessControlRequest+0xd0>
    6d36:	e5 c0       	rjmp	.+458    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6d38:	80 91 b1 09 	lds	r24, 0x09B1	; 0x8009b1 <USB_ControlRequest+0x2>
    6d3c:	81 30       	cpi	r24, 0x01	; 1
    6d3e:	09 f0       	breq	.+2      	; 0x6d42 <USB_Device_ProcessControlRequest+0xc4>
    6d40:	e0 c0       	rjmp	.+448    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6d42:	93 30       	cpi	r25, 0x03	; 3
    6d44:	09 f0       	breq	.+2      	; 0x6d48 <USB_Device_ProcessControlRequest+0xca>
    6d46:	80 e0       	ldi	r24, 0x00	; 0
    6d48:	80 93 ac 09 	sts	0x09AC, r24	; 0x8009ac <USB_Device_RemoteWakeupEnabled>
    6d4c:	2b c0       	rjmp	.+86     	; 0x6da4 <USB_Device_ProcessControlRequest+0x126>
    6d4e:	80 91 b1 09 	lds	r24, 0x09B1	; 0x8009b1 <USB_ControlRequest+0x2>
    6d52:	81 11       	cpse	r24, r1
    6d54:	27 c0       	rjmp	.+78     	; 0x6da4 <USB_Device_ProcessControlRequest+0x126>
    6d56:	80 91 b3 09 	lds	r24, 0x09B3	; 0x8009b3 <USB_ControlRequest+0x4>
    6d5a:	8f 70       	andi	r24, 0x0F	; 15
    6d5c:	09 f4       	brne	.+2      	; 0x6d60 <USB_Device_ProcessControlRequest+0xe2>
    6d5e:	d1 c0       	rjmp	.+418    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6d60:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    6d64:	20 91 eb 00 	lds	r18, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6d68:	20 ff       	sbrs	r18, 0
    6d6a:	1c c0       	rjmp	.+56     	; 0x6da4 <USB_Device_ProcessControlRequest+0x126>
    6d6c:	93 30       	cpi	r25, 0x03	; 3
    6d6e:	21 f4       	brne	.+8      	; 0x6d78 <USB_Device_ProcessControlRequest+0xfa>
    6d70:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6d74:	80 62       	ori	r24, 0x20	; 32
    6d76:	14 c0       	rjmp	.+40     	; 0x6da0 <USB_Device_ProcessControlRequest+0x122>
    6d78:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6d7c:	90 61       	ori	r25, 0x10	; 16
    6d7e:	90 93 eb 00 	sts	0x00EB, r25	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6d82:	21 e0       	ldi	r18, 0x01	; 1
    6d84:	30 e0       	ldi	r19, 0x00	; 0
    6d86:	a9 01       	movw	r20, r18
    6d88:	02 c0       	rjmp	.+4      	; 0x6d8e <USB_Device_ProcessControlRequest+0x110>
    6d8a:	44 0f       	add	r20, r20
    6d8c:	55 1f       	adc	r21, r21
    6d8e:	8a 95       	dec	r24
    6d90:	e2 f7       	brpl	.-8      	; 0x6d8a <USB_Device_ProcessControlRequest+0x10c>
    6d92:	40 93 ea 00 	sts	0x00EA, r20	; 0x8000ea <__DATA_REGION_ORIGIN__+0x8a>
    6d96:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <__DATA_REGION_ORIGIN__+0x8a>
    6d9a:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6d9e:	88 60       	ori	r24, 0x08	; 8
    6da0:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6da4:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    6da8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6dac:	87 7f       	andi	r24, 0xF7	; 247
    6dae:	83 c0       	rjmp	.+262    	; 0x6eb6 <USB_Device_ProcessControlRequest+0x238>
    6db0:	81 11       	cpse	r24, r1
    6db2:	a7 c0       	rjmp	.+334    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6db4:	10 91 b1 09 	lds	r17, 0x09B1	; 0x8009b1 <USB_ControlRequest+0x2>
    6db8:	1f 77       	andi	r17, 0x7F	; 127
    6dba:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__DATA_REGION_ORIGIN__+0x83>
    6dbe:	80 78       	andi	r24, 0x80	; 128
    6dc0:	81 2b       	or	r24, r17
    6dc2:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__DATA_REGION_ORIGIN__+0x83>
    6dc6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6dca:	87 7f       	andi	r24, 0xF7	; 247
    6dcc:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6dd0:	c7 dd       	rcall	.-1138   	; 0x6960 <Endpoint_ClearStatusStage>
    6dd2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6dd6:	80 ff       	sbrs	r24, 0
    6dd8:	fc cf       	rjmp	.-8      	; 0x6dd2 <USB_Device_ProcessControlRequest+0x154>
    6dda:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__DATA_REGION_ORIGIN__+0x83>
    6dde:	80 68       	ori	r24, 0x80	; 128
    6de0:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__DATA_REGION_ORIGIN__+0x83>
    6de4:	11 11       	cpse	r17, r1
    6de6:	02 c0       	rjmp	.+4      	; 0x6dec <USB_Device_ProcessControlRequest+0x16e>
    6de8:	82 e0       	ldi	r24, 0x02	; 2
    6dea:	01 c0       	rjmp	.+2      	; 0x6dee <USB_Device_ProcessControlRequest+0x170>
    6dec:	83 e0       	ldi	r24, 0x03	; 3
    6dee:	80 93 ae 09 	sts	0x09AE, r24	; 0x8009ae <USB_DeviceState>
    6df2:	87 c0       	rjmp	.+270    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6df4:	80 58       	subi	r24, 0x80	; 128
    6df6:	82 30       	cpi	r24, 0x02	; 2
    6df8:	08 f0       	brcs	.+2      	; 0x6dfc <USB_Device_ProcessControlRequest+0x17e>
    6dfa:	83 c0       	rjmp	.+262    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6dfc:	80 91 b1 09 	lds	r24, 0x09B1	; 0x8009b1 <USB_ControlRequest+0x2>
    6e00:	90 91 b2 09 	lds	r25, 0x09B2	; 0x8009b2 <USB_ControlRequest+0x3>
    6e04:	8c 3d       	cpi	r24, 0xDC	; 220
    6e06:	53 e0       	ldi	r21, 0x03	; 3
    6e08:	95 07       	cpc	r25, r21
    6e0a:	71 f5       	brne	.+92     	; 0x6e68 <USB_Device_ProcessControlRequest+0x1ea>
    6e0c:	83 e0       	ldi	r24, 0x03	; 3
    6e0e:	8a 83       	std	Y+2, r24	; 0x02
    6e10:	8a e2       	ldi	r24, 0x2A	; 42
    6e12:	89 83       	std	Y+1, r24	; 0x01
    6e14:	4f b7       	in	r20, 0x3f	; 63
    6e16:	f8 94       	cli
    6e18:	de 01       	movw	r26, r28
    6e1a:	13 96       	adiw	r26, 0x03	; 3
    6e1c:	20 e0       	ldi	r18, 0x00	; 0
    6e1e:	3e e0       	ldi	r19, 0x0E	; 14
    6e20:	51 e2       	ldi	r21, 0x21	; 33
    6e22:	e3 2f       	mov	r30, r19
    6e24:	f0 e0       	ldi	r31, 0x00	; 0
    6e26:	50 93 57 00 	sts	0x0057, r21	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    6e2a:	e4 91       	lpm	r30, Z
    6e2c:	20 ff       	sbrs	r18, 0
    6e2e:	03 c0       	rjmp	.+6      	; 0x6e36 <USB_Device_ProcessControlRequest+0x1b8>
    6e30:	e2 95       	swap	r30
    6e32:	ef 70       	andi	r30, 0x0F	; 15
    6e34:	3f 5f       	subi	r19, 0xFF	; 255
    6e36:	ef 70       	andi	r30, 0x0F	; 15
    6e38:	8e 2f       	mov	r24, r30
    6e3a:	90 e0       	ldi	r25, 0x00	; 0
    6e3c:	ea 30       	cpi	r30, 0x0A	; 10
    6e3e:	10 f0       	brcs	.+4      	; 0x6e44 <USB_Device_ProcessControlRequest+0x1c6>
    6e40:	c7 96       	adiw	r24, 0x37	; 55
    6e42:	01 c0       	rjmp	.+2      	; 0x6e46 <USB_Device_ProcessControlRequest+0x1c8>
    6e44:	c0 96       	adiw	r24, 0x30	; 48
    6e46:	8d 93       	st	X+, r24
    6e48:	9d 93       	st	X+, r25
    6e4a:	2f 5f       	subi	r18, 0xFF	; 255
    6e4c:	24 31       	cpi	r18, 0x14	; 20
    6e4e:	49 f7       	brne	.-46     	; 0x6e22 <USB_Device_ProcessControlRequest+0x1a4>
    6e50:	4f bf       	out	0x3f, r20	; 63
    6e52:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6e56:	87 7f       	andi	r24, 0xF7	; 247
    6e58:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6e5c:	6a e2       	ldi	r22, 0x2A	; 42
    6e5e:	70 e0       	ldi	r23, 0x00	; 0
    6e60:	ce 01       	movw	r24, r28
    6e62:	01 96       	adiw	r24, 0x01	; 1
    6e64:	0c dc       	rcall	.-2024   	; 0x667e <Endpoint_Write_Control_Stream_LE>
    6e66:	13 c0       	rjmp	.+38     	; 0x6e8e <USB_Device_ProcessControlRequest+0x210>
    6e68:	ae 01       	movw	r20, r28
    6e6a:	4f 5f       	subi	r20, 0xFF	; 255
    6e6c:	5f 4f       	sbci	r21, 0xFF	; 255
    6e6e:	60 91 b3 09 	lds	r22, 0x09B3	; 0x8009b3 <USB_ControlRequest+0x4>
    6e72:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <CALLBACK_USB_GetDescriptor>
    6e76:	bc 01       	movw	r22, r24
    6e78:	89 2b       	or	r24, r25
    6e7a:	09 f4       	brne	.+2      	; 0x6e7e <USB_Device_ProcessControlRequest+0x200>
    6e7c:	42 c0       	rjmp	.+132    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6e7e:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6e82:	97 7f       	andi	r25, 0xF7	; 247
    6e84:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6e88:	89 81       	ldd	r24, Y+1	; 0x01
    6e8a:	9a 81       	ldd	r25, Y+2	; 0x02
    6e8c:	96 dc       	rcall	.-1748   	; 0x67ba <Endpoint_Write_Control_PStream_LE>
    6e8e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6e92:	8b 77       	andi	r24, 0x7B	; 123
    6e94:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6e98:	34 c0       	rjmp	.+104    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6e9a:	80 38       	cpi	r24, 0x80	; 128
    6e9c:	91 f5       	brne	.+100    	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6e9e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6ea2:	87 7f       	andi	r24, 0xF7	; 247
    6ea4:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6ea8:	80 91 aa 09 	lds	r24, 0x09AA	; 0x8009aa <USB_Device_ConfigurationNumber>
    6eac:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>
    6eb0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6eb4:	8e 77       	andi	r24, 0x7E	; 126
    6eb6:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6eba:	52 dd       	rcall	.-1372   	; 0x6960 <Endpoint_ClearStatusStage>
    6ebc:	22 c0       	rjmp	.+68     	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6ebe:	81 11       	cpse	r24, r1
    6ec0:	20 c0       	rjmp	.+64     	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6ec2:	80 91 b1 09 	lds	r24, 0x09B1	; 0x8009b1 <USB_ControlRequest+0x2>
    6ec6:	90 91 b2 09 	lds	r25, 0x09B2	; 0x8009b2 <USB_ControlRequest+0x3>
    6eca:	99 27       	eor	r25, r25
    6ecc:	02 97       	sbiw	r24, 0x02	; 2
    6ece:	cc f4       	brge	.+50     	; 0x6f02 <USB_Device_ProcessControlRequest+0x284>
    6ed0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6ed4:	87 7f       	andi	r24, 0xF7	; 247
    6ed6:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6eda:	80 91 b1 09 	lds	r24, 0x09B1	; 0x8009b1 <USB_ControlRequest+0x2>
    6ede:	80 93 aa 09 	sts	0x09AA, r24	; 0x8009aa <USB_Device_ConfigurationNumber>
    6ee2:	3e dd       	rcall	.-1412   	; 0x6960 <Endpoint_ClearStatusStage>
    6ee4:	80 91 aa 09 	lds	r24, 0x09AA	; 0x8009aa <USB_Device_ConfigurationNumber>
    6ee8:	81 11       	cpse	r24, r1
    6eea:	06 c0       	rjmp	.+12     	; 0x6ef8 <USB_Device_ProcessControlRequest+0x27a>
    6eec:	80 91 e3 00 	lds	r24, 0x00E3	; 0x8000e3 <__DATA_REGION_ORIGIN__+0x83>
    6ef0:	87 fd       	sbrc	r24, 7
    6ef2:	02 c0       	rjmp	.+4      	; 0x6ef8 <USB_Device_ProcessControlRequest+0x27a>
    6ef4:	81 e0       	ldi	r24, 0x01	; 1
    6ef6:	01 c0       	rjmp	.+2      	; 0x6efa <USB_Device_ProcessControlRequest+0x27c>
    6ef8:	84 e0       	ldi	r24, 0x04	; 4
    6efa:	80 93 ae 09 	sts	0x09AE, r24	; 0x8009ae <USB_DeviceState>
    6efe:	0e 94 e4 27 	call	0x4fc8	; 0x4fc8 <EVENT_USB_Device_ConfigurationChanged>
    6f02:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6f06:	83 ff       	sbrs	r24, 3
    6f08:	0a c0       	rjmp	.+20     	; 0x6f1e <USB_Device_ProcessControlRequest+0x2a0>
    6f0a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6f0e:	87 7f       	andi	r24, 0xF7	; 247
    6f10:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6f14:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6f18:	80 62       	ori	r24, 0x20	; 32
    6f1a:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    6f1e:	aa 96       	adiw	r28, 0x2a	; 42
    6f20:	0f b6       	in	r0, 0x3f	; 63
    6f22:	f8 94       	cli
    6f24:	de bf       	out	0x3e, r29	; 62
    6f26:	0f be       	out	0x3f, r0	; 63
    6f28:	cd bf       	out	0x3d, r28	; 61
    6f2a:	df 91       	pop	r29
    6f2c:	cf 91       	pop	r28
    6f2e:	1f 91       	pop	r17
    6f30:	08 95       	ret

00006f32 <USB_Event_Stub>:
    6f32:	08 95       	ret

00006f34 <USB_USBTask>:
    6f34:	cf 93       	push	r28
    6f36:	80 91 ae 09 	lds	r24, 0x09AE	; 0x8009ae <USB_DeviceState>
    6f3a:	88 23       	and	r24, r24
    6f3c:	99 f0       	breq	.+38     	; 0x6f64 <USB_USBTask+0x30>
    6f3e:	c0 91 e9 00 	lds	r28, 0x00E9	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    6f42:	cf 70       	andi	r28, 0x0F	; 15
    6f44:	90 91 ec 00 	lds	r25, 0x00EC	; 0x8000ec <__DATA_REGION_ORIGIN__+0x8c>
    6f48:	89 2f       	mov	r24, r25
    6f4a:	81 70       	andi	r24, 0x01	; 1
    6f4c:	90 fd       	sbrc	r25, 0
    6f4e:	80 e8       	ldi	r24, 0x80	; 128
    6f50:	c8 2b       	or	r28, r24
    6f52:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    6f56:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    6f5a:	83 fd       	sbrc	r24, 3
    6f5c:	90 de       	rcall	.-736    	; 0x6c7e <USB_Device_ProcessControlRequest>
    6f5e:	cf 70       	andi	r28, 0x0F	; 15
    6f60:	c0 93 e9 00 	sts	0x00E9, r28	; 0x8000e9 <__DATA_REGION_ORIGIN__+0x89>
    6f64:	cf 91       	pop	r28
    6f66:	08 95       	ret

00006f68 <__udivmodqi4>:
    6f68:	99 1b       	sub	r25, r25
    6f6a:	79 e0       	ldi	r23, 0x09	; 9
    6f6c:	04 c0       	rjmp	.+8      	; 0x6f76 <__udivmodqi4_ep>

00006f6e <__udivmodqi4_loop>:
    6f6e:	99 1f       	adc	r25, r25
    6f70:	96 17       	cp	r25, r22
    6f72:	08 f0       	brcs	.+2      	; 0x6f76 <__udivmodqi4_ep>
    6f74:	96 1b       	sub	r25, r22

00006f76 <__udivmodqi4_ep>:
    6f76:	88 1f       	adc	r24, r24
    6f78:	7a 95       	dec	r23
    6f7a:	c9 f7       	brne	.-14     	; 0x6f6e <__udivmodqi4_loop>
    6f7c:	80 95       	com	r24
    6f7e:	08 95       	ret

00006f80 <__divmodhi4>:
    6f80:	97 fb       	bst	r25, 7
    6f82:	07 2e       	mov	r0, r23
    6f84:	16 f4       	brtc	.+4      	; 0x6f8a <__divmodhi4+0xa>
    6f86:	00 94       	com	r0
    6f88:	06 d0       	rcall	.+12     	; 0x6f96 <__divmodhi4_neg1>
    6f8a:	77 fd       	sbrc	r23, 7
    6f8c:	08 d0       	rcall	.+16     	; 0x6f9e <__divmodhi4_neg2>
    6f8e:	82 d0       	rcall	.+260    	; 0x7094 <__udivmodhi4>
    6f90:	07 fc       	sbrc	r0, 7
    6f92:	05 d0       	rcall	.+10     	; 0x6f9e <__divmodhi4_neg2>
    6f94:	3e f4       	brtc	.+14     	; 0x6fa4 <__divmodhi4_exit>

00006f96 <__divmodhi4_neg1>:
    6f96:	90 95       	com	r25
    6f98:	81 95       	neg	r24
    6f9a:	9f 4f       	sbci	r25, 0xFF	; 255
    6f9c:	08 95       	ret

00006f9e <__divmodhi4_neg2>:
    6f9e:	70 95       	com	r23
    6fa0:	61 95       	neg	r22
    6fa2:	7f 4f       	sbci	r23, 0xFF	; 255

00006fa4 <__divmodhi4_exit>:
    6fa4:	08 95       	ret

00006fa6 <__udivmodsi4>:
    6fa6:	a1 e2       	ldi	r26, 0x21	; 33
    6fa8:	1a 2e       	mov	r1, r26
    6faa:	aa 1b       	sub	r26, r26
    6fac:	bb 1b       	sub	r27, r27
    6fae:	fd 01       	movw	r30, r26
    6fb0:	0d c0       	rjmp	.+26     	; 0x6fcc <__udivmodsi4_ep>

00006fb2 <__udivmodsi4_loop>:
    6fb2:	aa 1f       	adc	r26, r26
    6fb4:	bb 1f       	adc	r27, r27
    6fb6:	ee 1f       	adc	r30, r30
    6fb8:	ff 1f       	adc	r31, r31
    6fba:	a2 17       	cp	r26, r18
    6fbc:	b3 07       	cpc	r27, r19
    6fbe:	e4 07       	cpc	r30, r20
    6fc0:	f5 07       	cpc	r31, r21
    6fc2:	20 f0       	brcs	.+8      	; 0x6fcc <__udivmodsi4_ep>
    6fc4:	a2 1b       	sub	r26, r18
    6fc6:	b3 0b       	sbc	r27, r19
    6fc8:	e4 0b       	sbc	r30, r20
    6fca:	f5 0b       	sbc	r31, r21

00006fcc <__udivmodsi4_ep>:
    6fcc:	66 1f       	adc	r22, r22
    6fce:	77 1f       	adc	r23, r23
    6fd0:	88 1f       	adc	r24, r24
    6fd2:	99 1f       	adc	r25, r25
    6fd4:	1a 94       	dec	r1
    6fd6:	69 f7       	brne	.-38     	; 0x6fb2 <__udivmodsi4_loop>
    6fd8:	60 95       	com	r22
    6fda:	70 95       	com	r23
    6fdc:	80 95       	com	r24
    6fde:	90 95       	com	r25
    6fe0:	9b 01       	movw	r18, r22
    6fe2:	ac 01       	movw	r20, r24
    6fe4:	bd 01       	movw	r22, r26
    6fe6:	cf 01       	movw	r24, r30
    6fe8:	08 95       	ret

00006fea <__muluhisi3>:
    6fea:	81 d0       	rcall	.+258    	; 0x70ee <__umulhisi3>
    6fec:	a5 9f       	mul	r26, r21
    6fee:	90 0d       	add	r25, r0
    6ff0:	b4 9f       	mul	r27, r20
    6ff2:	90 0d       	add	r25, r0
    6ff4:	a4 9f       	mul	r26, r20
    6ff6:	80 0d       	add	r24, r0
    6ff8:	91 1d       	adc	r25, r1
    6ffa:	11 24       	eor	r1, r1
    6ffc:	08 95       	ret

00006ffe <__clzdi2>:
    6ffe:	5e d0       	rcall	.+188    	; 0x70bc <__clzsi2>
    7000:	85 ff       	sbrs	r24, 5
    7002:	08 95       	ret
    7004:	b9 01       	movw	r22, r18
    7006:	ca 01       	movw	r24, r20
    7008:	59 d0       	rcall	.+178    	; 0x70bc <__clzsi2>
    700a:	80 5e       	subi	r24, 0xE0	; 224
    700c:	08 95       	ret

0000700e <__ashldi3>:
    700e:	0f 93       	push	r16
    7010:	08 30       	cpi	r16, 0x08	; 8
    7012:	90 f0       	brcs	.+36     	; 0x7038 <__ashldi3+0x2a>
    7014:	98 2f       	mov	r25, r24
    7016:	87 2f       	mov	r24, r23
    7018:	76 2f       	mov	r23, r22
    701a:	65 2f       	mov	r22, r21
    701c:	54 2f       	mov	r21, r20
    701e:	43 2f       	mov	r20, r19
    7020:	32 2f       	mov	r19, r18
    7022:	22 27       	eor	r18, r18
    7024:	08 50       	subi	r16, 0x08	; 8
    7026:	f4 cf       	rjmp	.-24     	; 0x7010 <__ashldi3+0x2>
    7028:	22 0f       	add	r18, r18
    702a:	33 1f       	adc	r19, r19
    702c:	44 1f       	adc	r20, r20
    702e:	55 1f       	adc	r21, r21
    7030:	66 1f       	adc	r22, r22
    7032:	77 1f       	adc	r23, r23
    7034:	88 1f       	adc	r24, r24
    7036:	99 1f       	adc	r25, r25
    7038:	0a 95       	dec	r16
    703a:	b2 f7       	brpl	.-20     	; 0x7028 <__ashldi3+0x1a>
    703c:	0f 91       	pop	r16
    703e:	08 95       	ret

00007040 <__ashrdi3>:
    7040:	97 fb       	bst	r25, 7
    7042:	10 f8       	bld	r1, 0

00007044 <__lshrdi3>:
    7044:	16 94       	lsr	r1
    7046:	00 08       	sbc	r0, r0
    7048:	0f 93       	push	r16
    704a:	08 30       	cpi	r16, 0x08	; 8
    704c:	98 f0       	brcs	.+38     	; 0x7074 <__lshrdi3+0x30>
    704e:	08 50       	subi	r16, 0x08	; 8
    7050:	23 2f       	mov	r18, r19
    7052:	34 2f       	mov	r19, r20
    7054:	45 2f       	mov	r20, r21
    7056:	56 2f       	mov	r21, r22
    7058:	67 2f       	mov	r22, r23
    705a:	78 2f       	mov	r23, r24
    705c:	89 2f       	mov	r24, r25
    705e:	90 2d       	mov	r25, r0
    7060:	f4 cf       	rjmp	.-24     	; 0x704a <__lshrdi3+0x6>
    7062:	05 94       	asr	r0
    7064:	97 95       	ror	r25
    7066:	87 95       	ror	r24
    7068:	77 95       	ror	r23
    706a:	67 95       	ror	r22
    706c:	57 95       	ror	r21
    706e:	47 95       	ror	r20
    7070:	37 95       	ror	r19
    7072:	27 95       	ror	r18
    7074:	0a 95       	dec	r16
    7076:	aa f7       	brpl	.-22     	; 0x7062 <__lshrdi3+0x1e>
    7078:	0f 91       	pop	r16
    707a:	08 95       	ret

0000707c <__cmpdi2_s8>:
    707c:	00 24       	eor	r0, r0
    707e:	a7 fd       	sbrc	r26, 7
    7080:	00 94       	com	r0
    7082:	2a 17       	cp	r18, r26
    7084:	30 05       	cpc	r19, r0
    7086:	40 05       	cpc	r20, r0
    7088:	50 05       	cpc	r21, r0
    708a:	60 05       	cpc	r22, r0
    708c:	70 05       	cpc	r23, r0
    708e:	80 05       	cpc	r24, r0
    7090:	90 05       	cpc	r25, r0
    7092:	08 95       	ret

00007094 <__udivmodhi4>:
    7094:	aa 1b       	sub	r26, r26
    7096:	bb 1b       	sub	r27, r27
    7098:	51 e1       	ldi	r21, 0x11	; 17
    709a:	07 c0       	rjmp	.+14     	; 0x70aa <__udivmodhi4_ep>

0000709c <__udivmodhi4_loop>:
    709c:	aa 1f       	adc	r26, r26
    709e:	bb 1f       	adc	r27, r27
    70a0:	a6 17       	cp	r26, r22
    70a2:	b7 07       	cpc	r27, r23
    70a4:	10 f0       	brcs	.+4      	; 0x70aa <__udivmodhi4_ep>
    70a6:	a6 1b       	sub	r26, r22
    70a8:	b7 0b       	sbc	r27, r23

000070aa <__udivmodhi4_ep>:
    70aa:	88 1f       	adc	r24, r24
    70ac:	99 1f       	adc	r25, r25
    70ae:	5a 95       	dec	r21
    70b0:	a9 f7       	brne	.-22     	; 0x709c <__udivmodhi4_loop>
    70b2:	80 95       	com	r24
    70b4:	90 95       	com	r25
    70b6:	bc 01       	movw	r22, r24
    70b8:	cd 01       	movw	r24, r26
    70ba:	08 95       	ret

000070bc <__clzsi2>:
    70bc:	06 d0       	rcall	.+12     	; 0x70ca <__clzhi2>
    70be:	84 ff       	sbrs	r24, 4
    70c0:	08 95       	ret
    70c2:	cb 01       	movw	r24, r22
    70c4:	02 d0       	rcall	.+4      	; 0x70ca <__clzhi2>
    70c6:	80 5f       	subi	r24, 0xF0	; 240
    70c8:	08 95       	ret

000070ca <__clzhi2>:
    70ca:	aa 27       	eor	r26, r26
    70cc:	99 23       	and	r25, r25
    70ce:	29 f4       	brne	.+10     	; 0x70da <__clzhi2+0x10>
    70d0:	a8 5f       	subi	r26, 0xF8	; 248
    70d2:	98 2b       	or	r25, r24
    70d4:	11 f4       	brne	.+4      	; 0x70da <__clzhi2+0x10>
    70d6:	80 e1       	ldi	r24, 0x10	; 16
    70d8:	08 95       	ret
    70da:	90 31       	cpi	r25, 0x10	; 16
    70dc:	18 f4       	brcc	.+6      	; 0x70e4 <__clzhi2+0x1a>
    70de:	ad 5f       	subi	r26, 0xFD	; 253
    70e0:	92 95       	swap	r25
    70e2:	a3 95       	inc	r26
    70e4:	99 0f       	add	r25, r25
    70e6:	e8 f7       	brcc	.-6      	; 0x70e2 <__clzhi2+0x18>
    70e8:	8a 2f       	mov	r24, r26
    70ea:	99 27       	eor	r25, r25
    70ec:	08 95       	ret

000070ee <__umulhisi3>:
    70ee:	a2 9f       	mul	r26, r18
    70f0:	b0 01       	movw	r22, r0
    70f2:	b3 9f       	mul	r27, r19
    70f4:	c0 01       	movw	r24, r0
    70f6:	a3 9f       	mul	r26, r19
    70f8:	70 0d       	add	r23, r0
    70fa:	81 1d       	adc	r24, r1
    70fc:	11 24       	eor	r1, r1
    70fe:	91 1d       	adc	r25, r1
    7100:	b2 9f       	mul	r27, r18
    7102:	70 0d       	add	r23, r0
    7104:	81 1d       	adc	r24, r1
    7106:	11 24       	eor	r1, r1
    7108:	91 1d       	adc	r25, r1
    710a:	08 95       	ret

0000710c <toupper>:
    710c:	91 11       	cpse	r25, r1
    710e:	08 95       	ret
    7110:	81 56       	subi	r24, 0x61	; 97
    7112:	8a 51       	subi	r24, 0x1A	; 26
    7114:	08 f4       	brcc	.+2      	; 0x7118 <toupper+0xc>
    7116:	80 52       	subi	r24, 0x20	; 32
    7118:	85 58       	subi	r24, 0x85	; 133
    711a:	08 95       	ret

0000711c <strcpy_P>:
    711c:	fb 01       	movw	r30, r22
    711e:	dc 01       	movw	r26, r24
    7120:	05 90       	lpm	r0, Z+
    7122:	0d 92       	st	X+, r0
    7124:	00 20       	and	r0, r0
    7126:	e1 f7       	brne	.-8      	; 0x7120 <strcpy_P+0x4>
    7128:	08 95       	ret

0000712a <strtok>:
    712a:	40 ee       	ldi	r20, 0xE0	; 224
    712c:	52 e0       	ldi	r21, 0x02	; 2
    712e:	24 c0       	rjmp	.+72     	; 0x7178 <strtok_r>

00007130 <memcmp>:
    7130:	fb 01       	movw	r30, r22
    7132:	dc 01       	movw	r26, r24
    7134:	04 c0       	rjmp	.+8      	; 0x713e <memcmp+0xe>
    7136:	8d 91       	ld	r24, X+
    7138:	01 90       	ld	r0, Z+
    713a:	80 19       	sub	r24, r0
    713c:	21 f4       	brne	.+8      	; 0x7146 <memcmp+0x16>
    713e:	41 50       	subi	r20, 0x01	; 1
    7140:	50 40       	sbci	r21, 0x00	; 0
    7142:	c8 f7       	brcc	.-14     	; 0x7136 <memcmp+0x6>
    7144:	88 1b       	sub	r24, r24
    7146:	99 0b       	sbc	r25, r25
    7148:	08 95       	ret

0000714a <memcpy>:
    714a:	fb 01       	movw	r30, r22
    714c:	dc 01       	movw	r26, r24
    714e:	02 c0       	rjmp	.+4      	; 0x7154 <memcpy+0xa>
    7150:	01 90       	ld	r0, Z+
    7152:	0d 92       	st	X+, r0
    7154:	41 50       	subi	r20, 0x01	; 1
    7156:	50 40       	sbci	r21, 0x00	; 0
    7158:	d8 f7       	brcc	.-10     	; 0x7150 <memcpy+0x6>
    715a:	08 95       	ret

0000715c <memset>:
    715c:	dc 01       	movw	r26, r24
    715e:	01 c0       	rjmp	.+2      	; 0x7162 <memset+0x6>
    7160:	6d 93       	st	X+, r22
    7162:	41 50       	subi	r20, 0x01	; 1
    7164:	50 40       	sbci	r21, 0x00	; 0
    7166:	e0 f7       	brcc	.-8      	; 0x7160 <memset+0x4>
    7168:	08 95       	ret

0000716a <strcpy>:
    716a:	fb 01       	movw	r30, r22
    716c:	dc 01       	movw	r26, r24
    716e:	01 90       	ld	r0, Z+
    7170:	0d 92       	st	X+, r0
    7172:	00 20       	and	r0, r0
    7174:	e1 f7       	brne	.-8      	; 0x716e <strcpy+0x4>
    7176:	08 95       	ret

00007178 <strtok_r>:
    7178:	fa 01       	movw	r30, r20
    717a:	a1 91       	ld	r26, Z+
    717c:	b0 81       	ld	r27, Z
    717e:	00 97       	sbiw	r24, 0x00	; 0
    7180:	19 f4       	brne	.+6      	; 0x7188 <strtok_r+0x10>
    7182:	10 97       	sbiw	r26, 0x00	; 0
    7184:	e1 f0       	breq	.+56     	; 0x71be <strtok_r+0x46>
    7186:	cd 01       	movw	r24, r26
    7188:	dc 01       	movw	r26, r24
    718a:	cd 01       	movw	r24, r26
    718c:	0d 90       	ld	r0, X+
    718e:	00 20       	and	r0, r0
    7190:	11 f4       	brne	.+4      	; 0x7196 <strtok_r+0x1e>
    7192:	c0 01       	movw	r24, r0
    7194:	13 c0       	rjmp	.+38     	; 0x71bc <strtok_r+0x44>
    7196:	fb 01       	movw	r30, r22
    7198:	21 91       	ld	r18, Z+
    719a:	22 23       	and	r18, r18
    719c:	19 f0       	breq	.+6      	; 0x71a4 <strtok_r+0x2c>
    719e:	20 15       	cp	r18, r0
    71a0:	d9 f7       	brne	.-10     	; 0x7198 <strtok_r+0x20>
    71a2:	f3 cf       	rjmp	.-26     	; 0x718a <strtok_r+0x12>
    71a4:	fb 01       	movw	r30, r22
    71a6:	21 91       	ld	r18, Z+
    71a8:	20 15       	cp	r18, r0
    71aa:	19 f4       	brne	.+6      	; 0x71b2 <strtok_r+0x3a>
    71ac:	1e 92       	st	-X, r1
    71ae:	11 96       	adiw	r26, 0x01	; 1
    71b0:	06 c0       	rjmp	.+12     	; 0x71be <strtok_r+0x46>
    71b2:	22 23       	and	r18, r18
    71b4:	c1 f7       	brne	.-16     	; 0x71a6 <strtok_r+0x2e>
    71b6:	0d 90       	ld	r0, X+
    71b8:	00 20       	and	r0, r0
    71ba:	a1 f7       	brne	.-24     	; 0x71a4 <strtok_r+0x2c>
    71bc:	d0 01       	movw	r26, r0
    71be:	fa 01       	movw	r30, r20
    71c0:	a1 93       	st	Z+, r26
    71c2:	b0 83       	st	Z, r27
    71c4:	08 95       	ret

000071c6 <sprintf>:
    71c6:	ae e0       	ldi	r26, 0x0E	; 14
    71c8:	b0 e0       	ldi	r27, 0x00	; 0
    71ca:	e8 ee       	ldi	r30, 0xE8	; 232
    71cc:	f8 e3       	ldi	r31, 0x38	; 56
    71ce:	f3 c2       	rjmp	.+1510   	; 0x77b6 <__prologue_saves__+0x1c>
    71d0:	0d 89       	ldd	r16, Y+21	; 0x15
    71d2:	1e 89       	ldd	r17, Y+22	; 0x16
    71d4:	86 e0       	ldi	r24, 0x06	; 6
    71d6:	8c 83       	std	Y+4, r24	; 0x04
    71d8:	1a 83       	std	Y+2, r17	; 0x02
    71da:	09 83       	std	Y+1, r16	; 0x01
    71dc:	8f ef       	ldi	r24, 0xFF	; 255
    71de:	9f e7       	ldi	r25, 0x7F	; 127
    71e0:	9e 83       	std	Y+6, r25	; 0x06
    71e2:	8d 83       	std	Y+5, r24	; 0x05
    71e4:	ae 01       	movw	r20, r28
    71e6:	47 5e       	subi	r20, 0xE7	; 231
    71e8:	5f 4f       	sbci	r21, 0xFF	; 255
    71ea:	6f 89       	ldd	r22, Y+23	; 0x17
    71ec:	78 8d       	ldd	r23, Y+24	; 0x18
    71ee:	ce 01       	movw	r24, r28
    71f0:	01 96       	adiw	r24, 0x01	; 1
    71f2:	08 d0       	rcall	.+16     	; 0x7204 <vfprintf>
    71f4:	ef 81       	ldd	r30, Y+7	; 0x07
    71f6:	f8 85       	ldd	r31, Y+8	; 0x08
    71f8:	e0 0f       	add	r30, r16
    71fa:	f1 1f       	adc	r31, r17
    71fc:	10 82       	st	Z, r1
    71fe:	2e 96       	adiw	r28, 0x0e	; 14
    7200:	e4 e0       	ldi	r30, 0x04	; 4
    7202:	f5 c2       	rjmp	.+1514   	; 0x77ee <__epilogue_restores__+0x1c>

00007204 <vfprintf>:
    7204:	ab e0       	ldi	r26, 0x0B	; 11
    7206:	b0 e0       	ldi	r27, 0x00	; 0
    7208:	e7 e0       	ldi	r30, 0x07	; 7
    720a:	f9 e3       	ldi	r31, 0x39	; 57
    720c:	c6 c2       	rjmp	.+1420   	; 0x779a <__prologue_saves__>
    720e:	6c 01       	movw	r12, r24
    7210:	7b 01       	movw	r14, r22
    7212:	8a 01       	movw	r16, r20
    7214:	fc 01       	movw	r30, r24
    7216:	17 82       	std	Z+7, r1	; 0x07
    7218:	16 82       	std	Z+6, r1	; 0x06
    721a:	83 81       	ldd	r24, Z+3	; 0x03
    721c:	81 ff       	sbrs	r24, 1
    721e:	bf c1       	rjmp	.+894    	; 0x759e <vfprintf+0x39a>
    7220:	ce 01       	movw	r24, r28
    7222:	01 96       	adiw	r24, 0x01	; 1
    7224:	3c 01       	movw	r6, r24
    7226:	f6 01       	movw	r30, r12
    7228:	93 81       	ldd	r25, Z+3	; 0x03
    722a:	f7 01       	movw	r30, r14
    722c:	93 fd       	sbrc	r25, 3
    722e:	85 91       	lpm	r24, Z+
    7230:	93 ff       	sbrs	r25, 3
    7232:	81 91       	ld	r24, Z+
    7234:	7f 01       	movw	r14, r30
    7236:	88 23       	and	r24, r24
    7238:	09 f4       	brne	.+2      	; 0x723c <vfprintf+0x38>
    723a:	ad c1       	rjmp	.+858    	; 0x7596 <vfprintf+0x392>
    723c:	85 32       	cpi	r24, 0x25	; 37
    723e:	39 f4       	brne	.+14     	; 0x724e <vfprintf+0x4a>
    7240:	93 fd       	sbrc	r25, 3
    7242:	85 91       	lpm	r24, Z+
    7244:	93 ff       	sbrs	r25, 3
    7246:	81 91       	ld	r24, Z+
    7248:	7f 01       	movw	r14, r30
    724a:	85 32       	cpi	r24, 0x25	; 37
    724c:	21 f4       	brne	.+8      	; 0x7256 <vfprintf+0x52>
    724e:	b6 01       	movw	r22, r12
    7250:	90 e0       	ldi	r25, 0x00	; 0
    7252:	c0 d1       	rcall	.+896    	; 0x75d4 <fputc>
    7254:	e8 cf       	rjmp	.-48     	; 0x7226 <vfprintf+0x22>
    7256:	91 2c       	mov	r9, r1
    7258:	21 2c       	mov	r2, r1
    725a:	31 2c       	mov	r3, r1
    725c:	ff e1       	ldi	r31, 0x1F	; 31
    725e:	f3 15       	cp	r31, r3
    7260:	d8 f0       	brcs	.+54     	; 0x7298 <vfprintf+0x94>
    7262:	8b 32       	cpi	r24, 0x2B	; 43
    7264:	79 f0       	breq	.+30     	; 0x7284 <vfprintf+0x80>
    7266:	38 f4       	brcc	.+14     	; 0x7276 <vfprintf+0x72>
    7268:	80 32       	cpi	r24, 0x20	; 32
    726a:	79 f0       	breq	.+30     	; 0x728a <vfprintf+0x86>
    726c:	83 32       	cpi	r24, 0x23	; 35
    726e:	a1 f4       	brne	.+40     	; 0x7298 <vfprintf+0x94>
    7270:	23 2d       	mov	r18, r3
    7272:	20 61       	ori	r18, 0x10	; 16
    7274:	1d c0       	rjmp	.+58     	; 0x72b0 <vfprintf+0xac>
    7276:	8d 32       	cpi	r24, 0x2D	; 45
    7278:	61 f0       	breq	.+24     	; 0x7292 <vfprintf+0x8e>
    727a:	80 33       	cpi	r24, 0x30	; 48
    727c:	69 f4       	brne	.+26     	; 0x7298 <vfprintf+0x94>
    727e:	23 2d       	mov	r18, r3
    7280:	21 60       	ori	r18, 0x01	; 1
    7282:	16 c0       	rjmp	.+44     	; 0x72b0 <vfprintf+0xac>
    7284:	83 2d       	mov	r24, r3
    7286:	82 60       	ori	r24, 0x02	; 2
    7288:	38 2e       	mov	r3, r24
    728a:	e3 2d       	mov	r30, r3
    728c:	e4 60       	ori	r30, 0x04	; 4
    728e:	3e 2e       	mov	r3, r30
    7290:	2a c0       	rjmp	.+84     	; 0x72e6 <vfprintf+0xe2>
    7292:	f3 2d       	mov	r31, r3
    7294:	f8 60       	ori	r31, 0x08	; 8
    7296:	1d c0       	rjmp	.+58     	; 0x72d2 <vfprintf+0xce>
    7298:	37 fc       	sbrc	r3, 7
    729a:	2d c0       	rjmp	.+90     	; 0x72f6 <vfprintf+0xf2>
    729c:	20 ed       	ldi	r18, 0xD0	; 208
    729e:	28 0f       	add	r18, r24
    72a0:	2a 30       	cpi	r18, 0x0A	; 10
    72a2:	40 f0       	brcs	.+16     	; 0x72b4 <vfprintf+0xb0>
    72a4:	8e 32       	cpi	r24, 0x2E	; 46
    72a6:	b9 f4       	brne	.+46     	; 0x72d6 <vfprintf+0xd2>
    72a8:	36 fc       	sbrc	r3, 6
    72aa:	75 c1       	rjmp	.+746    	; 0x7596 <vfprintf+0x392>
    72ac:	23 2d       	mov	r18, r3
    72ae:	20 64       	ori	r18, 0x40	; 64
    72b0:	32 2e       	mov	r3, r18
    72b2:	19 c0       	rjmp	.+50     	; 0x72e6 <vfprintf+0xe2>
    72b4:	36 fe       	sbrs	r3, 6
    72b6:	06 c0       	rjmp	.+12     	; 0x72c4 <vfprintf+0xc0>
    72b8:	8a e0       	ldi	r24, 0x0A	; 10
    72ba:	98 9e       	mul	r9, r24
    72bc:	20 0d       	add	r18, r0
    72be:	11 24       	eor	r1, r1
    72c0:	92 2e       	mov	r9, r18
    72c2:	11 c0       	rjmp	.+34     	; 0x72e6 <vfprintf+0xe2>
    72c4:	ea e0       	ldi	r30, 0x0A	; 10
    72c6:	2e 9e       	mul	r2, r30
    72c8:	20 0d       	add	r18, r0
    72ca:	11 24       	eor	r1, r1
    72cc:	22 2e       	mov	r2, r18
    72ce:	f3 2d       	mov	r31, r3
    72d0:	f0 62       	ori	r31, 0x20	; 32
    72d2:	3f 2e       	mov	r3, r31
    72d4:	08 c0       	rjmp	.+16     	; 0x72e6 <vfprintf+0xe2>
    72d6:	8c 36       	cpi	r24, 0x6C	; 108
    72d8:	21 f4       	brne	.+8      	; 0x72e2 <vfprintf+0xde>
    72da:	83 2d       	mov	r24, r3
    72dc:	80 68       	ori	r24, 0x80	; 128
    72de:	38 2e       	mov	r3, r24
    72e0:	02 c0       	rjmp	.+4      	; 0x72e6 <vfprintf+0xe2>
    72e2:	88 36       	cpi	r24, 0x68	; 104
    72e4:	41 f4       	brne	.+16     	; 0x72f6 <vfprintf+0xf2>
    72e6:	f7 01       	movw	r30, r14
    72e8:	93 fd       	sbrc	r25, 3
    72ea:	85 91       	lpm	r24, Z+
    72ec:	93 ff       	sbrs	r25, 3
    72ee:	81 91       	ld	r24, Z+
    72f0:	7f 01       	movw	r14, r30
    72f2:	81 11       	cpse	r24, r1
    72f4:	b3 cf       	rjmp	.-154    	; 0x725c <vfprintf+0x58>
    72f6:	98 2f       	mov	r25, r24
    72f8:	9f 7d       	andi	r25, 0xDF	; 223
    72fa:	95 54       	subi	r25, 0x45	; 69
    72fc:	93 30       	cpi	r25, 0x03	; 3
    72fe:	28 f4       	brcc	.+10     	; 0x730a <vfprintf+0x106>
    7300:	0c 5f       	subi	r16, 0xFC	; 252
    7302:	1f 4f       	sbci	r17, 0xFF	; 255
    7304:	9f e3       	ldi	r25, 0x3F	; 63
    7306:	99 83       	std	Y+1, r25	; 0x01
    7308:	0d c0       	rjmp	.+26     	; 0x7324 <vfprintf+0x120>
    730a:	83 36       	cpi	r24, 0x63	; 99
    730c:	31 f0       	breq	.+12     	; 0x731a <vfprintf+0x116>
    730e:	83 37       	cpi	r24, 0x73	; 115
    7310:	71 f0       	breq	.+28     	; 0x732e <vfprintf+0x12a>
    7312:	83 35       	cpi	r24, 0x53	; 83
    7314:	09 f0       	breq	.+2      	; 0x7318 <vfprintf+0x114>
    7316:	55 c0       	rjmp	.+170    	; 0x73c2 <vfprintf+0x1be>
    7318:	20 c0       	rjmp	.+64     	; 0x735a <vfprintf+0x156>
    731a:	f8 01       	movw	r30, r16
    731c:	80 81       	ld	r24, Z
    731e:	89 83       	std	Y+1, r24	; 0x01
    7320:	0e 5f       	subi	r16, 0xFE	; 254
    7322:	1f 4f       	sbci	r17, 0xFF	; 255
    7324:	88 24       	eor	r8, r8
    7326:	83 94       	inc	r8
    7328:	91 2c       	mov	r9, r1
    732a:	53 01       	movw	r10, r6
    732c:	12 c0       	rjmp	.+36     	; 0x7352 <vfprintf+0x14e>
    732e:	28 01       	movw	r4, r16
    7330:	f2 e0       	ldi	r31, 0x02	; 2
    7332:	4f 0e       	add	r4, r31
    7334:	51 1c       	adc	r5, r1
    7336:	f8 01       	movw	r30, r16
    7338:	a0 80       	ld	r10, Z
    733a:	b1 80       	ldd	r11, Z+1	; 0x01
    733c:	36 fe       	sbrs	r3, 6
    733e:	03 c0       	rjmp	.+6      	; 0x7346 <vfprintf+0x142>
    7340:	69 2d       	mov	r22, r9
    7342:	70 e0       	ldi	r23, 0x00	; 0
    7344:	02 c0       	rjmp	.+4      	; 0x734a <vfprintf+0x146>
    7346:	6f ef       	ldi	r22, 0xFF	; 255
    7348:	7f ef       	ldi	r23, 0xFF	; 255
    734a:	c5 01       	movw	r24, r10
    734c:	38 d1       	rcall	.+624    	; 0x75be <strnlen>
    734e:	4c 01       	movw	r8, r24
    7350:	82 01       	movw	r16, r4
    7352:	f3 2d       	mov	r31, r3
    7354:	ff 77       	andi	r31, 0x7F	; 127
    7356:	3f 2e       	mov	r3, r31
    7358:	15 c0       	rjmp	.+42     	; 0x7384 <vfprintf+0x180>
    735a:	28 01       	movw	r4, r16
    735c:	22 e0       	ldi	r18, 0x02	; 2
    735e:	42 0e       	add	r4, r18
    7360:	51 1c       	adc	r5, r1
    7362:	f8 01       	movw	r30, r16
    7364:	a0 80       	ld	r10, Z
    7366:	b1 80       	ldd	r11, Z+1	; 0x01
    7368:	36 fe       	sbrs	r3, 6
    736a:	03 c0       	rjmp	.+6      	; 0x7372 <vfprintf+0x16e>
    736c:	69 2d       	mov	r22, r9
    736e:	70 e0       	ldi	r23, 0x00	; 0
    7370:	02 c0       	rjmp	.+4      	; 0x7376 <vfprintf+0x172>
    7372:	6f ef       	ldi	r22, 0xFF	; 255
    7374:	7f ef       	ldi	r23, 0xFF	; 255
    7376:	c5 01       	movw	r24, r10
    7378:	17 d1       	rcall	.+558    	; 0x75a8 <strnlen_P>
    737a:	4c 01       	movw	r8, r24
    737c:	f3 2d       	mov	r31, r3
    737e:	f0 68       	ori	r31, 0x80	; 128
    7380:	3f 2e       	mov	r3, r31
    7382:	82 01       	movw	r16, r4
    7384:	33 fc       	sbrc	r3, 3
    7386:	19 c0       	rjmp	.+50     	; 0x73ba <vfprintf+0x1b6>
    7388:	82 2d       	mov	r24, r2
    738a:	90 e0       	ldi	r25, 0x00	; 0
    738c:	88 16       	cp	r8, r24
    738e:	99 06       	cpc	r9, r25
    7390:	a0 f4       	brcc	.+40     	; 0x73ba <vfprintf+0x1b6>
    7392:	b6 01       	movw	r22, r12
    7394:	80 e2       	ldi	r24, 0x20	; 32
    7396:	90 e0       	ldi	r25, 0x00	; 0
    7398:	1d d1       	rcall	.+570    	; 0x75d4 <fputc>
    739a:	2a 94       	dec	r2
    739c:	f5 cf       	rjmp	.-22     	; 0x7388 <vfprintf+0x184>
    739e:	f5 01       	movw	r30, r10
    73a0:	37 fc       	sbrc	r3, 7
    73a2:	85 91       	lpm	r24, Z+
    73a4:	37 fe       	sbrs	r3, 7
    73a6:	81 91       	ld	r24, Z+
    73a8:	5f 01       	movw	r10, r30
    73aa:	b6 01       	movw	r22, r12
    73ac:	90 e0       	ldi	r25, 0x00	; 0
    73ae:	12 d1       	rcall	.+548    	; 0x75d4 <fputc>
    73b0:	21 10       	cpse	r2, r1
    73b2:	2a 94       	dec	r2
    73b4:	21 e0       	ldi	r18, 0x01	; 1
    73b6:	82 1a       	sub	r8, r18
    73b8:	91 08       	sbc	r9, r1
    73ba:	81 14       	cp	r8, r1
    73bc:	91 04       	cpc	r9, r1
    73be:	79 f7       	brne	.-34     	; 0x739e <vfprintf+0x19a>
    73c0:	e1 c0       	rjmp	.+450    	; 0x7584 <vfprintf+0x380>
    73c2:	84 36       	cpi	r24, 0x64	; 100
    73c4:	11 f0       	breq	.+4      	; 0x73ca <vfprintf+0x1c6>
    73c6:	89 36       	cpi	r24, 0x69	; 105
    73c8:	39 f5       	brne	.+78     	; 0x7418 <vfprintf+0x214>
    73ca:	f8 01       	movw	r30, r16
    73cc:	37 fe       	sbrs	r3, 7
    73ce:	07 c0       	rjmp	.+14     	; 0x73de <vfprintf+0x1da>
    73d0:	60 81       	ld	r22, Z
    73d2:	71 81       	ldd	r23, Z+1	; 0x01
    73d4:	82 81       	ldd	r24, Z+2	; 0x02
    73d6:	93 81       	ldd	r25, Z+3	; 0x03
    73d8:	0c 5f       	subi	r16, 0xFC	; 252
    73da:	1f 4f       	sbci	r17, 0xFF	; 255
    73dc:	08 c0       	rjmp	.+16     	; 0x73ee <vfprintf+0x1ea>
    73de:	60 81       	ld	r22, Z
    73e0:	71 81       	ldd	r23, Z+1	; 0x01
    73e2:	07 2e       	mov	r0, r23
    73e4:	00 0c       	add	r0, r0
    73e6:	88 0b       	sbc	r24, r24
    73e8:	99 0b       	sbc	r25, r25
    73ea:	0e 5f       	subi	r16, 0xFE	; 254
    73ec:	1f 4f       	sbci	r17, 0xFF	; 255
    73ee:	f3 2d       	mov	r31, r3
    73f0:	ff 76       	andi	r31, 0x6F	; 111
    73f2:	3f 2e       	mov	r3, r31
    73f4:	97 ff       	sbrs	r25, 7
    73f6:	09 c0       	rjmp	.+18     	; 0x740a <vfprintf+0x206>
    73f8:	90 95       	com	r25
    73fa:	80 95       	com	r24
    73fc:	70 95       	com	r23
    73fe:	61 95       	neg	r22
    7400:	7f 4f       	sbci	r23, 0xFF	; 255
    7402:	8f 4f       	sbci	r24, 0xFF	; 255
    7404:	9f 4f       	sbci	r25, 0xFF	; 255
    7406:	f0 68       	ori	r31, 0x80	; 128
    7408:	3f 2e       	mov	r3, r31
    740a:	2a e0       	ldi	r18, 0x0A	; 10
    740c:	30 e0       	ldi	r19, 0x00	; 0
    740e:	a3 01       	movw	r20, r6
    7410:	1d d1       	rcall	.+570    	; 0x764c <__ultoa_invert>
    7412:	88 2e       	mov	r8, r24
    7414:	86 18       	sub	r8, r6
    7416:	44 c0       	rjmp	.+136    	; 0x74a0 <vfprintf+0x29c>
    7418:	85 37       	cpi	r24, 0x75	; 117
    741a:	31 f4       	brne	.+12     	; 0x7428 <vfprintf+0x224>
    741c:	23 2d       	mov	r18, r3
    741e:	2f 7e       	andi	r18, 0xEF	; 239
    7420:	b2 2e       	mov	r11, r18
    7422:	2a e0       	ldi	r18, 0x0A	; 10
    7424:	30 e0       	ldi	r19, 0x00	; 0
    7426:	25 c0       	rjmp	.+74     	; 0x7472 <vfprintf+0x26e>
    7428:	93 2d       	mov	r25, r3
    742a:	99 7f       	andi	r25, 0xF9	; 249
    742c:	b9 2e       	mov	r11, r25
    742e:	8f 36       	cpi	r24, 0x6F	; 111
    7430:	c1 f0       	breq	.+48     	; 0x7462 <vfprintf+0x25e>
    7432:	18 f4       	brcc	.+6      	; 0x743a <vfprintf+0x236>
    7434:	88 35       	cpi	r24, 0x58	; 88
    7436:	79 f0       	breq	.+30     	; 0x7456 <vfprintf+0x252>
    7438:	ae c0       	rjmp	.+348    	; 0x7596 <vfprintf+0x392>
    743a:	80 37       	cpi	r24, 0x70	; 112
    743c:	19 f0       	breq	.+6      	; 0x7444 <vfprintf+0x240>
    743e:	88 37       	cpi	r24, 0x78	; 120
    7440:	21 f0       	breq	.+8      	; 0x744a <vfprintf+0x246>
    7442:	a9 c0       	rjmp	.+338    	; 0x7596 <vfprintf+0x392>
    7444:	e9 2f       	mov	r30, r25
    7446:	e0 61       	ori	r30, 0x10	; 16
    7448:	be 2e       	mov	r11, r30
    744a:	b4 fe       	sbrs	r11, 4
    744c:	0d c0       	rjmp	.+26     	; 0x7468 <vfprintf+0x264>
    744e:	fb 2d       	mov	r31, r11
    7450:	f4 60       	ori	r31, 0x04	; 4
    7452:	bf 2e       	mov	r11, r31
    7454:	09 c0       	rjmp	.+18     	; 0x7468 <vfprintf+0x264>
    7456:	34 fe       	sbrs	r3, 4
    7458:	0a c0       	rjmp	.+20     	; 0x746e <vfprintf+0x26a>
    745a:	29 2f       	mov	r18, r25
    745c:	26 60       	ori	r18, 0x06	; 6
    745e:	b2 2e       	mov	r11, r18
    7460:	06 c0       	rjmp	.+12     	; 0x746e <vfprintf+0x26a>
    7462:	28 e0       	ldi	r18, 0x08	; 8
    7464:	30 e0       	ldi	r19, 0x00	; 0
    7466:	05 c0       	rjmp	.+10     	; 0x7472 <vfprintf+0x26e>
    7468:	20 e1       	ldi	r18, 0x10	; 16
    746a:	30 e0       	ldi	r19, 0x00	; 0
    746c:	02 c0       	rjmp	.+4      	; 0x7472 <vfprintf+0x26e>
    746e:	20 e1       	ldi	r18, 0x10	; 16
    7470:	32 e0       	ldi	r19, 0x02	; 2
    7472:	f8 01       	movw	r30, r16
    7474:	b7 fe       	sbrs	r11, 7
    7476:	07 c0       	rjmp	.+14     	; 0x7486 <vfprintf+0x282>
    7478:	60 81       	ld	r22, Z
    747a:	71 81       	ldd	r23, Z+1	; 0x01
    747c:	82 81       	ldd	r24, Z+2	; 0x02
    747e:	93 81       	ldd	r25, Z+3	; 0x03
    7480:	0c 5f       	subi	r16, 0xFC	; 252
    7482:	1f 4f       	sbci	r17, 0xFF	; 255
    7484:	06 c0       	rjmp	.+12     	; 0x7492 <vfprintf+0x28e>
    7486:	60 81       	ld	r22, Z
    7488:	71 81       	ldd	r23, Z+1	; 0x01
    748a:	80 e0       	ldi	r24, 0x00	; 0
    748c:	90 e0       	ldi	r25, 0x00	; 0
    748e:	0e 5f       	subi	r16, 0xFE	; 254
    7490:	1f 4f       	sbci	r17, 0xFF	; 255
    7492:	a3 01       	movw	r20, r6
    7494:	db d0       	rcall	.+438    	; 0x764c <__ultoa_invert>
    7496:	88 2e       	mov	r8, r24
    7498:	86 18       	sub	r8, r6
    749a:	fb 2d       	mov	r31, r11
    749c:	ff 77       	andi	r31, 0x7F	; 127
    749e:	3f 2e       	mov	r3, r31
    74a0:	36 fe       	sbrs	r3, 6
    74a2:	0d c0       	rjmp	.+26     	; 0x74be <vfprintf+0x2ba>
    74a4:	23 2d       	mov	r18, r3
    74a6:	2e 7f       	andi	r18, 0xFE	; 254
    74a8:	a2 2e       	mov	r10, r18
    74aa:	89 14       	cp	r8, r9
    74ac:	58 f4       	brcc	.+22     	; 0x74c4 <vfprintf+0x2c0>
    74ae:	34 fe       	sbrs	r3, 4
    74b0:	0b c0       	rjmp	.+22     	; 0x74c8 <vfprintf+0x2c4>
    74b2:	32 fc       	sbrc	r3, 2
    74b4:	09 c0       	rjmp	.+18     	; 0x74c8 <vfprintf+0x2c4>
    74b6:	83 2d       	mov	r24, r3
    74b8:	8e 7e       	andi	r24, 0xEE	; 238
    74ba:	a8 2e       	mov	r10, r24
    74bc:	05 c0       	rjmp	.+10     	; 0x74c8 <vfprintf+0x2c4>
    74be:	b8 2c       	mov	r11, r8
    74c0:	a3 2c       	mov	r10, r3
    74c2:	03 c0       	rjmp	.+6      	; 0x74ca <vfprintf+0x2c6>
    74c4:	b8 2c       	mov	r11, r8
    74c6:	01 c0       	rjmp	.+2      	; 0x74ca <vfprintf+0x2c6>
    74c8:	b9 2c       	mov	r11, r9
    74ca:	a4 fe       	sbrs	r10, 4
    74cc:	0f c0       	rjmp	.+30     	; 0x74ec <vfprintf+0x2e8>
    74ce:	fe 01       	movw	r30, r28
    74d0:	e8 0d       	add	r30, r8
    74d2:	f1 1d       	adc	r31, r1
    74d4:	80 81       	ld	r24, Z
    74d6:	80 33       	cpi	r24, 0x30	; 48
    74d8:	21 f4       	brne	.+8      	; 0x74e2 <vfprintf+0x2de>
    74da:	9a 2d       	mov	r25, r10
    74dc:	99 7e       	andi	r25, 0xE9	; 233
    74de:	a9 2e       	mov	r10, r25
    74e0:	09 c0       	rjmp	.+18     	; 0x74f4 <vfprintf+0x2f0>
    74e2:	a2 fe       	sbrs	r10, 2
    74e4:	06 c0       	rjmp	.+12     	; 0x74f2 <vfprintf+0x2ee>
    74e6:	b3 94       	inc	r11
    74e8:	b3 94       	inc	r11
    74ea:	04 c0       	rjmp	.+8      	; 0x74f4 <vfprintf+0x2f0>
    74ec:	8a 2d       	mov	r24, r10
    74ee:	86 78       	andi	r24, 0x86	; 134
    74f0:	09 f0       	breq	.+2      	; 0x74f4 <vfprintf+0x2f0>
    74f2:	b3 94       	inc	r11
    74f4:	a3 fc       	sbrc	r10, 3
    74f6:	10 c0       	rjmp	.+32     	; 0x7518 <vfprintf+0x314>
    74f8:	a0 fe       	sbrs	r10, 0
    74fa:	06 c0       	rjmp	.+12     	; 0x7508 <vfprintf+0x304>
    74fc:	b2 14       	cp	r11, r2
    74fe:	80 f4       	brcc	.+32     	; 0x7520 <vfprintf+0x31c>
    7500:	28 0c       	add	r2, r8
    7502:	92 2c       	mov	r9, r2
    7504:	9b 18       	sub	r9, r11
    7506:	0d c0       	rjmp	.+26     	; 0x7522 <vfprintf+0x31e>
    7508:	b2 14       	cp	r11, r2
    750a:	58 f4       	brcc	.+22     	; 0x7522 <vfprintf+0x31e>
    750c:	b6 01       	movw	r22, r12
    750e:	80 e2       	ldi	r24, 0x20	; 32
    7510:	90 e0       	ldi	r25, 0x00	; 0
    7512:	60 d0       	rcall	.+192    	; 0x75d4 <fputc>
    7514:	b3 94       	inc	r11
    7516:	f8 cf       	rjmp	.-16     	; 0x7508 <vfprintf+0x304>
    7518:	b2 14       	cp	r11, r2
    751a:	18 f4       	brcc	.+6      	; 0x7522 <vfprintf+0x31e>
    751c:	2b 18       	sub	r2, r11
    751e:	02 c0       	rjmp	.+4      	; 0x7524 <vfprintf+0x320>
    7520:	98 2c       	mov	r9, r8
    7522:	21 2c       	mov	r2, r1
    7524:	a4 fe       	sbrs	r10, 4
    7526:	0f c0       	rjmp	.+30     	; 0x7546 <vfprintf+0x342>
    7528:	b6 01       	movw	r22, r12
    752a:	80 e3       	ldi	r24, 0x30	; 48
    752c:	90 e0       	ldi	r25, 0x00	; 0
    752e:	52 d0       	rcall	.+164    	; 0x75d4 <fputc>
    7530:	a2 fe       	sbrs	r10, 2
    7532:	16 c0       	rjmp	.+44     	; 0x7560 <vfprintf+0x35c>
    7534:	a1 fc       	sbrc	r10, 1
    7536:	03 c0       	rjmp	.+6      	; 0x753e <vfprintf+0x33a>
    7538:	88 e7       	ldi	r24, 0x78	; 120
    753a:	90 e0       	ldi	r25, 0x00	; 0
    753c:	02 c0       	rjmp	.+4      	; 0x7542 <vfprintf+0x33e>
    753e:	88 e5       	ldi	r24, 0x58	; 88
    7540:	90 e0       	ldi	r25, 0x00	; 0
    7542:	b6 01       	movw	r22, r12
    7544:	0c c0       	rjmp	.+24     	; 0x755e <vfprintf+0x35a>
    7546:	8a 2d       	mov	r24, r10
    7548:	86 78       	andi	r24, 0x86	; 134
    754a:	51 f0       	breq	.+20     	; 0x7560 <vfprintf+0x35c>
    754c:	a1 fe       	sbrs	r10, 1
    754e:	02 c0       	rjmp	.+4      	; 0x7554 <vfprintf+0x350>
    7550:	8b e2       	ldi	r24, 0x2B	; 43
    7552:	01 c0       	rjmp	.+2      	; 0x7556 <vfprintf+0x352>
    7554:	80 e2       	ldi	r24, 0x20	; 32
    7556:	a7 fc       	sbrc	r10, 7
    7558:	8d e2       	ldi	r24, 0x2D	; 45
    755a:	b6 01       	movw	r22, r12
    755c:	90 e0       	ldi	r25, 0x00	; 0
    755e:	3a d0       	rcall	.+116    	; 0x75d4 <fputc>
    7560:	89 14       	cp	r8, r9
    7562:	30 f4       	brcc	.+12     	; 0x7570 <vfprintf+0x36c>
    7564:	b6 01       	movw	r22, r12
    7566:	80 e3       	ldi	r24, 0x30	; 48
    7568:	90 e0       	ldi	r25, 0x00	; 0
    756a:	34 d0       	rcall	.+104    	; 0x75d4 <fputc>
    756c:	9a 94       	dec	r9
    756e:	f8 cf       	rjmp	.-16     	; 0x7560 <vfprintf+0x35c>
    7570:	8a 94       	dec	r8
    7572:	f3 01       	movw	r30, r6
    7574:	e8 0d       	add	r30, r8
    7576:	f1 1d       	adc	r31, r1
    7578:	80 81       	ld	r24, Z
    757a:	b6 01       	movw	r22, r12
    757c:	90 e0       	ldi	r25, 0x00	; 0
    757e:	2a d0       	rcall	.+84     	; 0x75d4 <fputc>
    7580:	81 10       	cpse	r8, r1
    7582:	f6 cf       	rjmp	.-20     	; 0x7570 <vfprintf+0x36c>
    7584:	22 20       	and	r2, r2
    7586:	09 f4       	brne	.+2      	; 0x758a <vfprintf+0x386>
    7588:	4e ce       	rjmp	.-868    	; 0x7226 <vfprintf+0x22>
    758a:	b6 01       	movw	r22, r12
    758c:	80 e2       	ldi	r24, 0x20	; 32
    758e:	90 e0       	ldi	r25, 0x00	; 0
    7590:	21 d0       	rcall	.+66     	; 0x75d4 <fputc>
    7592:	2a 94       	dec	r2
    7594:	f7 cf       	rjmp	.-18     	; 0x7584 <vfprintf+0x380>
    7596:	f6 01       	movw	r30, r12
    7598:	86 81       	ldd	r24, Z+6	; 0x06
    759a:	97 81       	ldd	r25, Z+7	; 0x07
    759c:	02 c0       	rjmp	.+4      	; 0x75a2 <vfprintf+0x39e>
    759e:	8f ef       	ldi	r24, 0xFF	; 255
    75a0:	9f ef       	ldi	r25, 0xFF	; 255
    75a2:	2b 96       	adiw	r28, 0x0b	; 11
    75a4:	e2 e1       	ldi	r30, 0x12	; 18
    75a6:	15 c1       	rjmp	.+554    	; 0x77d2 <__epilogue_restores__>

000075a8 <strnlen_P>:
    75a8:	fc 01       	movw	r30, r24
    75aa:	05 90       	lpm	r0, Z+
    75ac:	61 50       	subi	r22, 0x01	; 1
    75ae:	70 40       	sbci	r23, 0x00	; 0
    75b0:	01 10       	cpse	r0, r1
    75b2:	d8 f7       	brcc	.-10     	; 0x75aa <strnlen_P+0x2>
    75b4:	80 95       	com	r24
    75b6:	90 95       	com	r25
    75b8:	8e 0f       	add	r24, r30
    75ba:	9f 1f       	adc	r25, r31
    75bc:	08 95       	ret

000075be <strnlen>:
    75be:	fc 01       	movw	r30, r24
    75c0:	61 50       	subi	r22, 0x01	; 1
    75c2:	70 40       	sbci	r23, 0x00	; 0
    75c4:	01 90       	ld	r0, Z+
    75c6:	01 10       	cpse	r0, r1
    75c8:	d8 f7       	brcc	.-10     	; 0x75c0 <strnlen+0x2>
    75ca:	80 95       	com	r24
    75cc:	90 95       	com	r25
    75ce:	8e 0f       	add	r24, r30
    75d0:	9f 1f       	adc	r25, r31
    75d2:	08 95       	ret

000075d4 <fputc>:
    75d4:	0f 93       	push	r16
    75d6:	1f 93       	push	r17
    75d8:	cf 93       	push	r28
    75da:	df 93       	push	r29
    75dc:	fb 01       	movw	r30, r22
    75de:	23 81       	ldd	r18, Z+3	; 0x03
    75e0:	21 fd       	sbrc	r18, 1
    75e2:	03 c0       	rjmp	.+6      	; 0x75ea <fputc+0x16>
    75e4:	8f ef       	ldi	r24, 0xFF	; 255
    75e6:	9f ef       	ldi	r25, 0xFF	; 255
    75e8:	2c c0       	rjmp	.+88     	; 0x7642 <fputc+0x6e>
    75ea:	22 ff       	sbrs	r18, 2
    75ec:	16 c0       	rjmp	.+44     	; 0x761a <fputc+0x46>
    75ee:	46 81       	ldd	r20, Z+6	; 0x06
    75f0:	57 81       	ldd	r21, Z+7	; 0x07
    75f2:	24 81       	ldd	r18, Z+4	; 0x04
    75f4:	35 81       	ldd	r19, Z+5	; 0x05
    75f6:	42 17       	cp	r20, r18
    75f8:	53 07       	cpc	r21, r19
    75fa:	44 f4       	brge	.+16     	; 0x760c <fputc+0x38>
    75fc:	a0 81       	ld	r26, Z
    75fe:	b1 81       	ldd	r27, Z+1	; 0x01
    7600:	9d 01       	movw	r18, r26
    7602:	2f 5f       	subi	r18, 0xFF	; 255
    7604:	3f 4f       	sbci	r19, 0xFF	; 255
    7606:	31 83       	std	Z+1, r19	; 0x01
    7608:	20 83       	st	Z, r18
    760a:	8c 93       	st	X, r24
    760c:	26 81       	ldd	r18, Z+6	; 0x06
    760e:	37 81       	ldd	r19, Z+7	; 0x07
    7610:	2f 5f       	subi	r18, 0xFF	; 255
    7612:	3f 4f       	sbci	r19, 0xFF	; 255
    7614:	37 83       	std	Z+7, r19	; 0x07
    7616:	26 83       	std	Z+6, r18	; 0x06
    7618:	14 c0       	rjmp	.+40     	; 0x7642 <fputc+0x6e>
    761a:	8b 01       	movw	r16, r22
    761c:	ec 01       	movw	r28, r24
    761e:	fb 01       	movw	r30, r22
    7620:	00 84       	ldd	r0, Z+8	; 0x08
    7622:	f1 85       	ldd	r31, Z+9	; 0x09
    7624:	e0 2d       	mov	r30, r0
    7626:	09 95       	icall
    7628:	89 2b       	or	r24, r25
    762a:	e1 f6       	brne	.-72     	; 0x75e4 <fputc+0x10>
    762c:	d8 01       	movw	r26, r16
    762e:	16 96       	adiw	r26, 0x06	; 6
    7630:	8d 91       	ld	r24, X+
    7632:	9c 91       	ld	r25, X
    7634:	17 97       	sbiw	r26, 0x07	; 7
    7636:	01 96       	adiw	r24, 0x01	; 1
    7638:	17 96       	adiw	r26, 0x07	; 7
    763a:	9c 93       	st	X, r25
    763c:	8e 93       	st	-X, r24
    763e:	16 97       	sbiw	r26, 0x06	; 6
    7640:	ce 01       	movw	r24, r28
    7642:	df 91       	pop	r29
    7644:	cf 91       	pop	r28
    7646:	1f 91       	pop	r17
    7648:	0f 91       	pop	r16
    764a:	08 95       	ret

0000764c <__ultoa_invert>:
    764c:	fa 01       	movw	r30, r20
    764e:	aa 27       	eor	r26, r26
    7650:	28 30       	cpi	r18, 0x08	; 8
    7652:	51 f1       	breq	.+84     	; 0x76a8 <__ultoa_invert+0x5c>
    7654:	20 31       	cpi	r18, 0x10	; 16
    7656:	81 f1       	breq	.+96     	; 0x76b8 <__ultoa_invert+0x6c>
    7658:	e8 94       	clt
    765a:	6f 93       	push	r22
    765c:	6e 7f       	andi	r22, 0xFE	; 254
    765e:	6e 5f       	subi	r22, 0xFE	; 254
    7660:	7f 4f       	sbci	r23, 0xFF	; 255
    7662:	8f 4f       	sbci	r24, 0xFF	; 255
    7664:	9f 4f       	sbci	r25, 0xFF	; 255
    7666:	af 4f       	sbci	r26, 0xFF	; 255
    7668:	b1 e0       	ldi	r27, 0x01	; 1
    766a:	3e d0       	rcall	.+124    	; 0x76e8 <__ultoa_invert+0x9c>
    766c:	b4 e0       	ldi	r27, 0x04	; 4
    766e:	3c d0       	rcall	.+120    	; 0x76e8 <__ultoa_invert+0x9c>
    7670:	67 0f       	add	r22, r23
    7672:	78 1f       	adc	r23, r24
    7674:	89 1f       	adc	r24, r25
    7676:	9a 1f       	adc	r25, r26
    7678:	a1 1d       	adc	r26, r1
    767a:	68 0f       	add	r22, r24
    767c:	79 1f       	adc	r23, r25
    767e:	8a 1f       	adc	r24, r26
    7680:	91 1d       	adc	r25, r1
    7682:	a1 1d       	adc	r26, r1
    7684:	6a 0f       	add	r22, r26
    7686:	71 1d       	adc	r23, r1
    7688:	81 1d       	adc	r24, r1
    768a:	91 1d       	adc	r25, r1
    768c:	a1 1d       	adc	r26, r1
    768e:	20 d0       	rcall	.+64     	; 0x76d0 <__ultoa_invert+0x84>
    7690:	09 f4       	brne	.+2      	; 0x7694 <__ultoa_invert+0x48>
    7692:	68 94       	set
    7694:	3f 91       	pop	r19
    7696:	2a e0       	ldi	r18, 0x0A	; 10
    7698:	26 9f       	mul	r18, r22
    769a:	11 24       	eor	r1, r1
    769c:	30 19       	sub	r19, r0
    769e:	30 5d       	subi	r19, 0xD0	; 208
    76a0:	31 93       	st	Z+, r19
    76a2:	de f6       	brtc	.-74     	; 0x765a <__ultoa_invert+0xe>
    76a4:	cf 01       	movw	r24, r30
    76a6:	08 95       	ret
    76a8:	46 2f       	mov	r20, r22
    76aa:	47 70       	andi	r20, 0x07	; 7
    76ac:	40 5d       	subi	r20, 0xD0	; 208
    76ae:	41 93       	st	Z+, r20
    76b0:	b3 e0       	ldi	r27, 0x03	; 3
    76b2:	0f d0       	rcall	.+30     	; 0x76d2 <__ultoa_invert+0x86>
    76b4:	c9 f7       	brne	.-14     	; 0x76a8 <__ultoa_invert+0x5c>
    76b6:	f6 cf       	rjmp	.-20     	; 0x76a4 <__ultoa_invert+0x58>
    76b8:	46 2f       	mov	r20, r22
    76ba:	4f 70       	andi	r20, 0x0F	; 15
    76bc:	40 5d       	subi	r20, 0xD0	; 208
    76be:	4a 33       	cpi	r20, 0x3A	; 58
    76c0:	18 f0       	brcs	.+6      	; 0x76c8 <__ultoa_invert+0x7c>
    76c2:	49 5d       	subi	r20, 0xD9	; 217
    76c4:	31 fd       	sbrc	r19, 1
    76c6:	40 52       	subi	r20, 0x20	; 32
    76c8:	41 93       	st	Z+, r20
    76ca:	02 d0       	rcall	.+4      	; 0x76d0 <__ultoa_invert+0x84>
    76cc:	a9 f7       	brne	.-22     	; 0x76b8 <__ultoa_invert+0x6c>
    76ce:	ea cf       	rjmp	.-44     	; 0x76a4 <__ultoa_invert+0x58>
    76d0:	b4 e0       	ldi	r27, 0x04	; 4
    76d2:	a6 95       	lsr	r26
    76d4:	97 95       	ror	r25
    76d6:	87 95       	ror	r24
    76d8:	77 95       	ror	r23
    76da:	67 95       	ror	r22
    76dc:	ba 95       	dec	r27
    76de:	c9 f7       	brne	.-14     	; 0x76d2 <__ultoa_invert+0x86>
    76e0:	00 97       	sbiw	r24, 0x00	; 0
    76e2:	61 05       	cpc	r22, r1
    76e4:	71 05       	cpc	r23, r1
    76e6:	08 95       	ret
    76e8:	9b 01       	movw	r18, r22
    76ea:	ac 01       	movw	r20, r24
    76ec:	0a 2e       	mov	r0, r26
    76ee:	06 94       	lsr	r0
    76f0:	57 95       	ror	r21
    76f2:	47 95       	ror	r20
    76f4:	37 95       	ror	r19
    76f6:	27 95       	ror	r18
    76f8:	ba 95       	dec	r27
    76fa:	c9 f7       	brne	.-14     	; 0x76ee <__ultoa_invert+0xa2>
    76fc:	62 0f       	add	r22, r18
    76fe:	73 1f       	adc	r23, r19
    7700:	84 1f       	adc	r24, r20
    7702:	95 1f       	adc	r25, r21
    7704:	a0 1d       	adc	r26, r0
    7706:	08 95       	ret

00007708 <eeprom_read_block>:
    7708:	dc 01       	movw	r26, r24
    770a:	cb 01       	movw	r24, r22

0000770c <eeprom_read_blraw>:
    770c:	fc 01       	movw	r30, r24
    770e:	f9 99       	sbic	0x1f, 1	; 31
    7710:	fe cf       	rjmp	.-4      	; 0x770e <eeprom_read_blraw+0x2>
    7712:	06 c0       	rjmp	.+12     	; 0x7720 <eeprom_read_blraw+0x14>
    7714:	f2 bd       	out	0x22, r31	; 34
    7716:	e1 bd       	out	0x21, r30	; 33
    7718:	f8 9a       	sbi	0x1f, 0	; 31
    771a:	31 96       	adiw	r30, 0x01	; 1
    771c:	00 b4       	in	r0, 0x20	; 32
    771e:	0d 92       	st	X+, r0
    7720:	41 50       	subi	r20, 0x01	; 1
    7722:	50 40       	sbci	r21, 0x00	; 0
    7724:	b8 f7       	brcc	.-18     	; 0x7714 <eeprom_read_blraw+0x8>
    7726:	08 95       	ret

00007728 <eeprom_read_byte>:
    7728:	f9 99       	sbic	0x1f, 1	; 31
    772a:	fe cf       	rjmp	.-4      	; 0x7728 <eeprom_read_byte>
    772c:	92 bd       	out	0x22, r25	; 34
    772e:	81 bd       	out	0x21, r24	; 33
    7730:	f8 9a       	sbi	0x1f, 0	; 31
    7732:	99 27       	eor	r25, r25
    7734:	80 b5       	in	r24, 0x20	; 32
    7736:	08 95       	ret

00007738 <eeprom_read_word>:
    7738:	a8 e1       	ldi	r26, 0x18	; 24
    773a:	b0 e0       	ldi	r27, 0x00	; 0
    773c:	42 e0       	ldi	r20, 0x02	; 2
    773e:	50 e0       	ldi	r21, 0x00	; 0
    7740:	e5 cf       	rjmp	.-54     	; 0x770c <eeprom_read_blraw>

00007742 <eeprom_update_byte>:
    7742:	26 2f       	mov	r18, r22

00007744 <eeprom_update_r18>:
    7744:	f9 99       	sbic	0x1f, 1	; 31
    7746:	fe cf       	rjmp	.-4      	; 0x7744 <eeprom_update_r18>
    7748:	92 bd       	out	0x22, r25	; 34
    774a:	81 bd       	out	0x21, r24	; 33
    774c:	f8 9a       	sbi	0x1f, 0	; 31
    774e:	01 97       	sbiw	r24, 0x01	; 1
    7750:	00 b4       	in	r0, 0x20	; 32
    7752:	02 16       	cp	r0, r18
    7754:	39 f0       	breq	.+14     	; 0x7764 <eeprom_update_r18+0x20>
    7756:	1f ba       	out	0x1f, r1	; 31
    7758:	20 bd       	out	0x20, r18	; 32
    775a:	0f b6       	in	r0, 0x3f	; 63
    775c:	f8 94       	cli
    775e:	fa 9a       	sbi	0x1f, 2	; 31
    7760:	f9 9a       	sbi	0x1f, 1	; 31
    7762:	0f be       	out	0x3f, r0	; 63
    7764:	08 95       	ret

00007766 <eeprom_write_block>:
    7766:	dc 01       	movw	r26, r24
    7768:	cb 01       	movw	r24, r22
    776a:	02 c0       	rjmp	.+4      	; 0x7770 <eeprom_write_block+0xa>
    776c:	2d 91       	ld	r18, X+
    776e:	05 d0       	rcall	.+10     	; 0x777a <eeprom_write_r18>
    7770:	41 50       	subi	r20, 0x01	; 1
    7772:	50 40       	sbci	r21, 0x00	; 0
    7774:	d8 f7       	brcc	.-10     	; 0x776c <eeprom_write_block+0x6>
    7776:	08 95       	ret

00007778 <eeprom_write_byte>:
    7778:	26 2f       	mov	r18, r22

0000777a <eeprom_write_r18>:
    777a:	f9 99       	sbic	0x1f, 1	; 31
    777c:	fe cf       	rjmp	.-4      	; 0x777a <eeprom_write_r18>
    777e:	1f ba       	out	0x1f, r1	; 31
    7780:	92 bd       	out	0x22, r25	; 34
    7782:	81 bd       	out	0x21, r24	; 33
    7784:	20 bd       	out	0x20, r18	; 32
    7786:	0f b6       	in	r0, 0x3f	; 63
    7788:	f8 94       	cli
    778a:	fa 9a       	sbi	0x1f, 2	; 31
    778c:	f9 9a       	sbi	0x1f, 1	; 31
    778e:	0f be       	out	0x3f, r0	; 63
    7790:	01 96       	adiw	r24, 0x01	; 1
    7792:	08 95       	ret

00007794 <eeprom_write_word>:
    7794:	f1 df       	rcall	.-30     	; 0x7778 <eeprom_write_byte>
    7796:	27 2f       	mov	r18, r23
    7798:	f0 cf       	rjmp	.-32     	; 0x777a <eeprom_write_r18>

0000779a <__prologue_saves__>:
    779a:	2f 92       	push	r2
    779c:	3f 92       	push	r3
    779e:	4f 92       	push	r4
    77a0:	5f 92       	push	r5
    77a2:	6f 92       	push	r6
    77a4:	7f 92       	push	r7
    77a6:	8f 92       	push	r8
    77a8:	9f 92       	push	r9
    77aa:	af 92       	push	r10
    77ac:	bf 92       	push	r11
    77ae:	cf 92       	push	r12
    77b0:	df 92       	push	r13
    77b2:	ef 92       	push	r14
    77b4:	ff 92       	push	r15
    77b6:	0f 93       	push	r16
    77b8:	1f 93       	push	r17
    77ba:	cf 93       	push	r28
    77bc:	df 93       	push	r29
    77be:	cd b7       	in	r28, 0x3d	; 61
    77c0:	de b7       	in	r29, 0x3e	; 62
    77c2:	ca 1b       	sub	r28, r26
    77c4:	db 0b       	sbc	r29, r27
    77c6:	0f b6       	in	r0, 0x3f	; 63
    77c8:	f8 94       	cli
    77ca:	de bf       	out	0x3e, r29	; 62
    77cc:	0f be       	out	0x3f, r0	; 63
    77ce:	cd bf       	out	0x3d, r28	; 61
    77d0:	09 94       	ijmp

000077d2 <__epilogue_restores__>:
    77d2:	2a 88       	ldd	r2, Y+18	; 0x12
    77d4:	39 88       	ldd	r3, Y+17	; 0x11
    77d6:	48 88       	ldd	r4, Y+16	; 0x10
    77d8:	5f 84       	ldd	r5, Y+15	; 0x0f
    77da:	6e 84       	ldd	r6, Y+14	; 0x0e
    77dc:	7d 84       	ldd	r7, Y+13	; 0x0d
    77de:	8c 84       	ldd	r8, Y+12	; 0x0c
    77e0:	9b 84       	ldd	r9, Y+11	; 0x0b
    77e2:	aa 84       	ldd	r10, Y+10	; 0x0a
    77e4:	b9 84       	ldd	r11, Y+9	; 0x09
    77e6:	c8 84       	ldd	r12, Y+8	; 0x08
    77e8:	df 80       	ldd	r13, Y+7	; 0x07
    77ea:	ee 80       	ldd	r14, Y+6	; 0x06
    77ec:	fd 80       	ldd	r15, Y+5	; 0x05
    77ee:	0c 81       	ldd	r16, Y+4	; 0x04
    77f0:	1b 81       	ldd	r17, Y+3	; 0x03
    77f2:	aa 81       	ldd	r26, Y+2	; 0x02
    77f4:	b9 81       	ldd	r27, Y+1	; 0x01
    77f6:	ce 0f       	add	r28, r30
    77f8:	d1 1d       	adc	r29, r1
    77fa:	0f b6       	in	r0, 0x3f	; 63
    77fc:	f8 94       	cli
    77fe:	de bf       	out	0x3e, r29	; 62
    7800:	0f be       	out	0x3f, r0	; 63
    7802:	cd bf       	out	0x3d, r28	; 61
    7804:	ed 01       	movw	r28, r26
    7806:	08 95       	ret

00007808 <_exit>:
    7808:	f8 94       	cli

0000780a <__stop_program>:
    780a:	ff cf       	rjmp	.-2      	; 0x780a <__stop_program>
