
USB Typewriter P2S.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000202  00800100  00007672  00007706  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007672  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006bb  00800302  00800302  00007908  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00007908  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00007964  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007e0  00000000  00000000  000079a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00011896  00000000  00000000  00008184  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003441  00000000  00000000  00019a1a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000159ba  00000000  00000000  0001ce5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001d54  00000000  00000000  00032818  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0001bfca  00000000  00000000  0003456c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000c989  00000000  00000000  00050536  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000a58  00000000  00000000  0005cebf  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000ba2e  00000000  00000000  0005d917  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	43 c3       	rjmp	.+1670   	; 0x688 <__ctors_end>
       2:	00 00       	nop
       4:	5e c3       	rjmp	.+1724   	; 0x6c2 <__bad_interrupt>
       6:	00 00       	nop
       8:	5c c3       	rjmp	.+1720   	; 0x6c2 <__bad_interrupt>
       a:	00 00       	nop
       c:	5a c3       	rjmp	.+1716   	; 0x6c2 <__bad_interrupt>
       e:	00 00       	nop
      10:	58 c3       	rjmp	.+1712   	; 0x6c2 <__bad_interrupt>
      12:	00 00       	nop
      14:	56 c3       	rjmp	.+1708   	; 0x6c2 <__bad_interrupt>
      16:	00 00       	nop
      18:	54 c3       	rjmp	.+1704   	; 0x6c2 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	52 c3       	rjmp	.+1700   	; 0x6c2 <__bad_interrupt>
      1e:	00 00       	nop
      20:	50 c3       	rjmp	.+1696   	; 0x6c2 <__bad_interrupt>
      22:	00 00       	nop
      24:	4e c3       	rjmp	.+1692   	; 0x6c2 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 c1 34 	jmp	0x6982	; 0x6982 <__vector_10>
      2c:	4a c3       	rjmp	.+1684   	; 0x6c2 <__bad_interrupt>
      2e:	00 00       	nop
      30:	48 c3       	rjmp	.+1680   	; 0x6c2 <__bad_interrupt>
      32:	00 00       	nop
      34:	46 c3       	rjmp	.+1676   	; 0x6c2 <__bad_interrupt>
      36:	00 00       	nop
      38:	44 c3       	rjmp	.+1672   	; 0x6c2 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	42 c3       	rjmp	.+1668   	; 0x6c2 <__bad_interrupt>
      3e:	00 00       	nop
      40:	40 c3       	rjmp	.+1664   	; 0x6c2 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 45 26 	jmp	0x4c8a	; 0x4c8a <__vector_17>
      48:	3c c3       	rjmp	.+1656   	; 0x6c2 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	3a c3       	rjmp	.+1652   	; 0x6c2 <__bad_interrupt>
      4e:	00 00       	nop
      50:	38 c3       	rjmp	.+1648   	; 0x6c2 <__bad_interrupt>
      52:	00 00       	nop
      54:	36 c3       	rjmp	.+1644   	; 0x6c2 <__bad_interrupt>
      56:	00 00       	nop
      58:	34 c3       	rjmp	.+1640   	; 0x6c2 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	32 c3       	rjmp	.+1636   	; 0x6c2 <__bad_interrupt>
      5e:	00 00       	nop
      60:	30 c3       	rjmp	.+1632   	; 0x6c2 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 a1 25 	jmp	0x4b42	; 0x4b42 <__vector_25>
      68:	0c 94 cf 25 	jmp	0x4b9e	; 0x4b9e <__vector_26>
      6c:	2a c3       	rjmp	.+1620   	; 0x6c2 <__bad_interrupt>
      6e:	00 00       	nop
      70:	28 c3       	rjmp	.+1616   	; 0x6c2 <__bad_interrupt>
      72:	00 00       	nop
      74:	26 c3       	rjmp	.+1612   	; 0x6c2 <__bad_interrupt>
      76:	00 00       	nop
      78:	24 c3       	rjmp	.+1608   	; 0x6c2 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	22 c3       	rjmp	.+1604   	; 0x6c2 <__bad_interrupt>
      7e:	00 00       	nop
      80:	20 c3       	rjmp	.+1600   	; 0x6c2 <__bad_interrupt>
      82:	00 00       	nop
      84:	1e c3       	rjmp	.+1596   	; 0x6c2 <__bad_interrupt>
      86:	00 00       	nop
      88:	1c c3       	rjmp	.+1592   	; 0x6c2 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	1a c3       	rjmp	.+1588   	; 0x6c2 <__bad_interrupt>
      8e:	00 00       	nop
      90:	18 c3       	rjmp	.+1584   	; 0x6c2 <__bad_interrupt>
      92:	00 00       	nop
      94:	16 c3       	rjmp	.+1580   	; 0x6c2 <__bad_interrupt>
      96:	00 00       	nop
      98:	14 c3       	rjmp	.+1576   	; 0x6c2 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	12 c3       	rjmp	.+1572   	; 0x6c2 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	10 c3       	rjmp	.+1568   	; 0x6c2 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	0c 94 f7 0c 	jmp	0x19ee	; 0x19ee <__vector_41>
      a8:	0c c3       	rjmp	.+1560   	; 0x6c2 <__bad_interrupt>
	...

000000ac <SET_BYPASS_MODE>:
      ac:	41 54 2b 42 50 3d 30 34 2c 30 37 2c 30 30 00        AT+BP=04,07,00.

000000bb <CONNECT_TO_PAIRED_DEVICE>:
      bb:	41 54 2b 43 54 00                                   AT+CT.

000000c1 <CHECK_DISCOVERABLE>:
      c1:	41 54 2b 4d 44 00                                   AT+MD.

000000c7 <DISABLE_SLEEP>:
      c7:	41 54 2b 53 50 3d 30 30 00                          AT+SP=00.

000000d0 <CLEAR_PAIRED_LIST>:
      d0:	41 54 2b 43 50 00                                   AT+CP.

000000d6 <DISABLE_PIN>:
      d6:	41 54 2b 49 4f 3d 30 33 00                          AT+IO=03.

000000df <DISABLE_MIM>:
      df:	41 54 2b 4d 4d 3d 30 30 00                          AT+MM=00.

000000e8 <SET_MODULE_FEATURES>:
      e8:	41 54 2b 46 54 3d 46 46 2c 30 31 2c 46 46 2c 31     AT+FT=FF,01,FF,1
      f8:	30 2c 30 31 2c 30 31 30 00                          0,01,010.

00000101 <SET_HID_PARAMS>:
     101:	41 54 2b 50 46 3d 30 30 2c 30 31 2c 30 30 2c 30     AT+PF=00,01,00,0
     111:	30 2c 30 30 00                                      0,00.

00000116 <SET_PROXY_MODE>:
     116:	41 54 2b 42 50 3d 30 30 2c 30 30 00                 AT+BP=00,00.

00000122 <ENABLE_UI>:
     122:	41 54 2b 55 49 3d 30 31 00                          AT+UI=01.

0000012b <SET_FRIENDLY_NAME>:
     12b:	41 54 2b 4e 4d 3d 55 53 42 20 54 79 70 65 77 72     AT+NM=USB Typewr
     13b:	69 74 65 72 20 42 54 00                             iter BT.

00000143 <Str_Header>:
     143:	0d 43 48 41 52 3a 09 43 4f 4e 54 41 43 54 23 3a     .CHAR:.CONTACT#:
     153:	0d 00                                               ..

00000155 <Str_Reed>:
     155:	52 45 45 44 00                                      REED.

0000015a <Str_Shift_Plus>:
     15a:	53 48 49 46 54 2b 00                                SHIFT+.

00000161 <Str_How_To_Exit>:
     161:	50 72 65 73 73 20 43 4d 44 2b 53 50 41 43 45 42     Press CMD+SPACEB
     171:	41 52 20 74 6f 20 73 61 76 65 20 63 68 61 6e 67     AR to save chang
     181:	65 73 20 61 6e 64 20 65 78 69 74 2e 0d 00           es and exit...

0000018f <Str_How_To_Scroll_Back>:
     18f:	50 72 65 73 73 20 43 54 52 4c 2b 53 50 41 43 45     Press CTRL+SPACE
     19f:	42 41 52 20 74 6f 20 73 63 72 6f 6c 6c 20 62 61     BAR to scroll ba
     1af:	63 6b 77 61 72 64 73 2e 0d 00                       ckwards...

000001b9 <Str_How_To_Scroll>:
     1b9:	50 72 65 73 73 20 53 50 41 43 45 42 41 52 20 74     Press SPACEBAR t
     1c9:	6f 20 73 63 72 6f 6c 6c 20 74 68 72 6f 75 67 68     o scroll through
     1d9:	20 63 68 61 72 61 63 74 65 72 73 2e 0d 00            characters...

000001e7 <Str_S_For_SD>:
     1e7:	50 72 65 73 73 20 53 20 69 66 20 63 68 61 6e 67     Press S if chang
     1f7:	65 73 20 73 68 6f 75 6c 64 20 61 70 70 6c 79 20     es should apply 
     207:	74 6f 20 53 44 20 6d 6f 64 65 2e 0d 00              to SD mode...

00000214 <Str_U_For_USB>:
     214:	50 72 65 73 73 20 55 20 69 66 20 63 68 61 6e 67     Press U if chang
     224:	65 73 20 73 68 6f 75 6c 64 20 61 70 70 6c 79 20     es should apply 
     234:	74 6f 20 55 53 42 2f 42 54 20 6d 6f 64 65 2e 0d     to USB/BT mode..
	...

00000245 <Str_Manual_Calibration>:
     245:	4d 41 4e 55 41 4c 20 43 41 4c 49 42 52 41 54 49     MANUAL CALIBRATI
     255:	4f 4e 20 4d 4f 44 45 2e 2e 2e 0d 00                 ON MODE.....

00000261 <Str_Settings_Saved>:
     261:	53 45 54 54 49 4e 47 53 20 53 41 56 45 44 21 0d     SETTINGS SAVED!.
	...

00000272 <Str_Spacebar_Blocks_Enter>:
     272:	0d 49 47 4e 4f 52 45 20 45 4e 54 45 52 20 4b 45     .IGNORE ENTER KE
     282:	59 20 57 48 45 4e 20 53 50 41 43 45 42 41 52 20     Y WHEN SPACEBAR 
     292:	49 53 20 48 45 4c 44 3f 0d 00                       IS HELD?..

0000029c <Str_Set_Reed_Time>:
     29c:	0d 4e 4f 57 20 53 45 54 20 52 45 45 44 20 52 45     .NOW SET REED RE
     2ac:	41 43 54 49 4f 4e 20 54 49 4d 45 2e 2e 2e 0d 00     ACTION TIME.....

000002bc <Str_Set_Double_Time>:
     2bc:	0d 4e 4f 57 20 53 45 54 20 44 45 4c 41 59 20 42     .NOW SET DELAY B
     2cc:	45 54 57 45 45 4e 20 44 4f 55 42 4c 45 20 4b 45     ETWEEN DOUBLE KE
     2dc:	59 20 50 52 45 53 53 45 53 2e 2e 2e 0d 00           Y PRESSES.....

000002ea <Str_Set_Release_Time>:
     2ea:	0d 4e 4f 57 20 53 45 54 20 4b 45 59 20 52 45 4c     .NOW SET KEY REL
     2fa:	45 41 53 45 20 54 49 4d 45 2e 2e 2e 0d 00           EASE TIME.....

00000308 <Str_Set_Reaction_Time>:
     308:	50 52 45 53 53 20 43 54 52 4c 20 41 4e 44 20 41     PRESS CTRL AND A
     318:	4c 54 20 54 4f 20 53 45 54 20 4b 45 59 20 52 45     LT TO SET KEY RE
     328:	41 43 54 49 4f 4e 20 54 49 4d 45 2e 2e 2e 0d 00     ACTION TIME.....

00000338 <Str_Press_CMD>:
     338:	50 52 45 53 53 20 43 4d 44 20 4b 45 59 20 54 4f     PRESS CMD KEY TO
     348:	20 43 4f 4e 54 49 4e 55 45 2e 2e 2e 0d 00            CONTINUE.....

00000356 <Str_Adj_Sensitivity>:
     356:	41 44 4a 55 53 54 49 4e 47 20 4b 45 59 20 53 45     ADJUSTING KEY SE
     366:	4e 53 49 54 49 56 49 54 59 2e 0d 00                 NSITIVITY...

00000372 <Str_No_Hall>:
     372:	4e 4f 20 48 41 4c 4c 20 45 46 46 45 43 54 20 53     NO HALL EFFECT S
     382:	45 4e 53 4f 52 20 44 45 54 45 43 54 45 44 2e 20     ENSOR DETECTED. 
     392:	28 4e 4f 54 20 41 20 50 52 4f 42 4c 45 4d 29 0d     (NOT A PROBLEM).
	...

000003a3 <Str_Calibrate_Hall>:
     3a3:	48 4f 4c 44 20 44 4f 57 4e 20 41 4e 59 20 4b 45     HOLD DOWN ANY KE
     3b3:	59 20 54 4f 20 43 41 4c 49 42 52 41 54 45 20 48     Y TO CALIBRATE H
     3c3:	41 4c 4c 20 45 46 46 45 43 54 20 53 45 4e 53 4f     ALL EFFECT SENSO
     3d3:	52 2e 2e 2e 0d 00                                   R.....

000003d9 <Str_Backspace>:
     3d9:	42 41 43 4b 53 50 41 43 45 00                       BACKSPACE.

000003e3 <Str_Post>:
     3e3:	53 45 4e 44 00                                      SEND.

000003e8 <Str_Second_Enter>:
     3e8:	53 45 43 4f 4e 44 41 52 59 20 45 4e 54 45 52 00     SECONDARY ENTER.

000003f8 <Str_Enter>:
     3f8:	45 4e 54 45 52 00                                   ENTER.

000003fe <Str_Spacebar>:
     3fe:	53 50 41 43 45 42 41 52 00                          SPACEBAR.

00000407 <Str_Quick_Calibrate>:
     407:	51 55 49 43 4b 20 43 41 4c 49 42 52 41 54 49 4f     QUICK CALIBRATIO
     417:	4e 20 4d 4f 44 45 2e 2e 2e 0d 00                    N MODE.....

00000422 <Str_No_Dummy_Load>:
     422:	44 55 4d 4d 59 20 4c 4f 41 44 20 44 45 41 43 54     DUMMY LOAD DEACT
     432:	49 56 41 54 45 44 0d 00                             IVATED..

0000043a <Str_Dummy_Load>:
     43a:	44 55 4d 4d 59 20 4c 4f 41 44 20 41 43 54 49 56     DUMMY LOAD ACTIV
     44a:	41 54 45 44 0d 00                                   ATED..

00000450 <Str_USB_Only>:
     450:	20 28 44 55 52 49 4e 47 20 55 53 42 2f 42 4c 55      (DURING USB/BLU
     460:	45 54 4f 4f 54 48 20 4d 4f 44 45 29 3a 00           ETOOTH MODE):.

0000046e <Str_SD_Only>:
     46e:	20 28 44 55 52 49 4e 47 20 53 44 20 43 41 52 44      (DURING SD CARD
     47e:	20 4d 4f 44 45 29 3a 00                              MODE):.

00000486 <Str_Shift_Error>:
     486:	45 52 52 4f 52 2e 2e 2e 53 48 49 46 54 20 4d 55     ERROR...SHIFT MU
     496:	53 54 20 42 45 20 41 20 52 45 45 44 20 53 57 49     ST BE A REED SWI
     4a6:	54 43 48 2e 0d 00                                   TCH...

000004ac <Str_Type_The_Following>:
     4ac:	54 59 50 45 20 54 48 45 20 46 4f 4c 4c 4f 57 49     TYPE THE FOLLOWI
     4bc:	4e 47 20 4b 45 59 53 20 28 50 52 45 53 53 20 53     NG KEYS (PRESS S
     4cc:	50 41 43 45 20 54 4f 20 53 4b 49 50 29 2e 2e 2e     PACE TO SKIP)...
     4dc:	0d 00                                               ..

000004de <Str_Calibrating>:
     4de:	43 41 4c 49 42 52 41 54 49 4e 47 2e 2e 2e 0d 00     CALIBRATING.....

000004ee <Str_SD_Mode>:
     4ee:	53 44 20 43 41 52 44 20 53 54 4f 52 41 47 45 20     SD CARD STORAGE 
     4fe:	4d 4f 44 45 0d 00                                   MODE..

00000504 <Str_Combo_Mode>:
     504:	55 53 42 20 4b 45 59 42 4f 41 52 44 2f 43 41 52     USB KEYBOARD/CAR
     514:	44 20 52 45 41 44 45 52 20 4d 4f 44 45 0d 00        D READER MODE..

00000523 <Str_Light_Mode>:
     523:	4c 49 47 48 54 20 4d 4f 44 45 20 28 53 44 20 43     LIGHT MODE (SD C
     533:	41 52 44 20 52 45 41 44 45 52 20 44 49 53 41 42     ARD READER DISAB
     543:	4c 45 44 29 0d 00                                   LED)..

00000549 <Str_BT_Mode>:
     549:	42 4c 55 45 54 4f 4f 54 48 20 4b 45 59 42 4f 41     BLUETOOTH KEYBOA
     559:	52 44 20 4d 4f 44 45 0d 00                          RD MODE..

00000562 <Str_Typewriter_Mode>:
     562:	44 45 46 41 55 4c 54 20 53 45 54 54 49 4e 47 3a     DEFAULT SETTING:
     572:	20 00                                                .

00000574 <Str_Firmware_Ver>:
     574:	46 49 52 4d 57 41 52 45 20 56 45 52 20 35 2e 34     FIRMWARE VER 5.4
     584:	2e 36 2e 45 48 00                                   .6.EH.

0000058a <Str_USB_Typewriter>:
     58a:	55 53 42 20 54 59 50 45 57 52 49 54 45 52 20 28     USB TYPEWRITER (
     59a:	54 4d 29 0d 00                                      TM)..

0000059f <ProductString>:
     59f:	30 03 55 00 53 00 42 00 20 00 54 00 79 00 70 00     0.U.S.B. .T.y.p.
     5af:	65 00 77 00 72 00 69 00 74 00 65 00 72 00 20 00     e.w.r.i.t.e.r. .
     5bf:	4b 00 65 00 79 00 62 00 6f 00 61 00 72 00 64 00     K.e.y.b.o.a.r.d.
	...

000005d1 <ManufacturerString>:
     5d1:	26 03 55 00 53 00 42 00 20 00 54 00 59 00 50 00     &.U.S.B. .T.Y.P.
     5e1:	45 00 57 00 52 00 49 00 54 00 45 00 52 00 20 00     E.W.R.I.T.E.R. .
     5f1:	4c 00 4c 00 43 00 00 00                             L.L.C...

000005f9 <LanguageString>:
     5f9:	04 03 09 04                                         ....

000005fd <ConfigurationDescriptor>:
     5fd:	09 02 39 00 02 01 00 80 07 09 04 00 00 02 08 06     ..9.............
     60d:	50 00 07 05 83 02 40 00 05 07 05 04 02 40 00 05     P.....@......@..
     61d:	09 04 01 00 01 03 01 01 00 09 21 11 01 00 01 22     ..........!...."
     62d:	3f 00 07 05 81 03 08 00 05                          ?........

00000636 <DeviceDescriptor>:
     636:	12 01 10 01 00 00 00 08 eb 03 61 20 86 00 01 02     ..........a ....
     646:	dc 01                                               ..

00000648 <KeyboardReport>:
     648:	05 01 09 06 a1 01 05 07 19 e0 29 e7 15 00 25 01     ..........)...%.
     658:	75 01 95 08 81 02 95 01 75 08 81 01 05 08 19 01     u.......u.......
     668:	29 05 95 05 75 01 91 02 95 01 75 03 91 01 15 00     )...u.....u.....
     678:	25 ff 05 07 19 00 29 ff 95 06 75 08 81 00 c0 00     %.....)...u.....

00000688 <__ctors_end>:
     688:	11 24       	eor	r1, r1
     68a:	1f be       	out	0x3f, r1	; 63
     68c:	cf ef       	ldi	r28, 0xFF	; 255
     68e:	da e0       	ldi	r29, 0x0A	; 10
     690:	de bf       	out	0x3e, r29	; 62
     692:	cd bf       	out	0x3d, r28	; 61

00000694 <__do_copy_data>:
     694:	13 e0       	ldi	r17, 0x03	; 3
     696:	a0 e0       	ldi	r26, 0x00	; 0
     698:	b1 e0       	ldi	r27, 0x01	; 1
     69a:	e2 e7       	ldi	r30, 0x72	; 114
     69c:	f6 e7       	ldi	r31, 0x76	; 118
     69e:	02 c0       	rjmp	.+4      	; 0x6a4 <__do_copy_data+0x10>
     6a0:	05 90       	lpm	r0, Z+
     6a2:	0d 92       	st	X+, r0
     6a4:	a2 30       	cpi	r26, 0x02	; 2
     6a6:	b1 07       	cpc	r27, r17
     6a8:	d9 f7       	brne	.-10     	; 0x6a0 <__do_copy_data+0xc>

000006aa <__do_clear_bss>:
     6aa:	29 e0       	ldi	r18, 0x09	; 9
     6ac:	a2 e0       	ldi	r26, 0x02	; 2
     6ae:	b3 e0       	ldi	r27, 0x03	; 3
     6b0:	01 c0       	rjmp	.+2      	; 0x6b4 <.do_clear_bss_start>

000006b2 <.do_clear_bss_loop>:
     6b2:	1d 92       	st	X+, r1

000006b4 <.do_clear_bss_start>:
     6b4:	ad 3b       	cpi	r26, 0xBD	; 189
     6b6:	b2 07       	cpc	r27, r18
     6b8:	e1 f7       	brne	.-8      	; 0x6b2 <.do_clear_bss_loop>
     6ba:	0e 94 f7 27 	call	0x4fee	; 0x4fee <main>
     6be:	0c 94 37 3b 	jmp	0x766e	; 0x766e <_exit>

000006c2 <__bad_interrupt>:
     6c2:	9e cc       	rjmp	.-1732   	; 0x0 <__vectors>

000006c4 <Get_Response.part.0>:
}

void BT_Wake(){
	if (BT_Asleep){
		Bluetooth_Send_PROGMEM_CMD(DISABLE_SLEEP,true); //disable sleep mode
		BT_Asleep = false; //bt is no longer asleep
     6c4:	0f 93       	push	r16
     6c6:	1f 93       	push	r17
     6c8:	cf 93       	push	r28
     6ca:	2f ef       	ldi	r18, 0xFF	; 255
     6cc:	80 e7       	ldi	r24, 0x70	; 112
     6ce:	92 e0       	ldi	r25, 0x02	; 2
     6d0:	21 50       	subi	r18, 0x01	; 1
     6d2:	80 40       	sbci	r24, 0x00	; 0
     6d4:	90 40       	sbci	r25, 0x00	; 0
     6d6:	e1 f7       	brne	.-8      	; 0x6d0 <Get_Response.part.0+0xc>
     6d8:	00 c0       	rjmp	.+0      	; 0x6da <Get_Response.part.0+0x16>
     6da:	00 00       	nop
     6dc:	10 92 f9 05 	sts	0x05F9, r1
     6e0:	10 92 fa 05 	sts	0x05FA, r1
     6e4:	10 92 fb 05 	sts	0x05FB, r1
     6e8:	10 92 fd 05 	sts	0x05FD, r1
     6ec:	09 ef       	ldi	r16, 0xF9	; 249
     6ee:	15 e0       	ldi	r17, 0x05	; 5
     6f0:	c0 e0       	ldi	r28, 0x00	; 0
     6f2:	0e 94 12 26 	call	0x4c24	; 0x4c24 <uart_getc>
     6f6:	9c 01       	movw	r18, r24
     6f8:	22 27       	eor	r18, r18
     6fa:	23 2b       	or	r18, r19
     6fc:	31 f0       	breq	.+12     	; 0x70a <Get_Response.part.0+0x46>
     6fe:	ec 2f       	mov	r30, r28
     700:	f0 e0       	ldi	r31, 0x00	; 0
     702:	e7 50       	subi	r30, 0x07	; 7
     704:	fa 4f       	sbci	r31, 0xFA	; 250
     706:	10 82       	st	Z, r1
     708:	0a c0       	rjmp	.+20     	; 0x71e <Get_Response.part.0+0x5a>
     70a:	cf 31       	cpi	r28, 0x1F	; 31
     70c:	19 f4       	brne	.+6      	; 0x714 <Get_Response.part.0+0x50>
     70e:	10 92 18 06 	sts	0x0618, r1
     712:	05 c0       	rjmp	.+10     	; 0x71e <Get_Response.part.0+0x5a>
     714:	f8 01       	movw	r30, r16
     716:	81 93       	st	Z+, r24
     718:	8f 01       	movw	r16, r30
     71a:	cf 5f       	subi	r28, 0xFF	; 255
     71c:	ea cf       	rjmp	.-44     	; 0x6f2 <Get_Response.part.0+0x2e>
     71e:	90 91 f9 05 	lds	r25, 0x05F9
     722:	9f 34       	cpi	r25, 0x4F	; 79
     724:	49 f0       	breq	.+18     	; 0x738 <Get_Response.part.0+0x74>
     726:	80 91 fb 05 	lds	r24, 0x05FB
     72a:	8d 33       	cpi	r24, 0x3D	; 61
     72c:	29 f0       	breq	.+10     	; 0x738 <Get_Response.part.0+0x74>
     72e:	81 e0       	ldi	r24, 0x01	; 1
     730:	93 34       	cpi	r25, 0x43	; 67
     732:	19 f0       	breq	.+6      	; 0x73a <Get_Response.part.0+0x76>
     734:	80 e0       	ldi	r24, 0x00	; 0
     736:	01 c0       	rjmp	.+2      	; 0x73a <Get_Response.part.0+0x76>
     738:	81 e0       	ldi	r24, 0x01	; 1
     73a:	cf 91       	pop	r28
     73c:	1f 91       	pop	r17
     73e:	0f 91       	pop	r16
     740:	08 95       	ret

00000742 <Bluetooth_Send>:
     742:	1f 93       	push	r17
     744:	cf 93       	push	r28
     746:	df 93       	push	r29
     748:	1f 92       	push	r1
     74a:	cd b7       	in	r28, 0x3d	; 61
     74c:	de b7       	in	r29, 0x3e	; 62
     74e:	18 2f       	mov	r17, r24
     750:	87 ff       	sbrs	r24, 7
     752:	02 c0       	rjmp	.+4      	; 0x758 <Bluetooth_Send+0x16>
     754:	1f 77       	andi	r17, 0x7F	; 127
     756:	62 e0       	ldi	r22, 0x02	; 2
     758:	14 37       	cpi	r17, 0x74	; 116
     75a:	11 f4       	brne	.+4      	; 0x760 <Bluetooth_Send+0x1e>
     75c:	61 e0       	ldi	r22, 0x01	; 1
     75e:	18 e2       	ldi	r17, 0x28	; 40
     760:	81 ea       	ldi	r24, 0xA1	; 161
     762:	69 83       	std	Y+1, r22	; 0x01
     764:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     76e:	69 81       	ldd	r22, Y+1	; 0x01
     770:	86 2f       	mov	r24, r22
     772:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     776:	80 e0       	ldi	r24, 0x00	; 0
     778:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     77c:	81 2f       	mov	r24, r17
     77e:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     782:	80 e0       	ldi	r24, 0x00	; 0
     784:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     788:	80 e0       	ldi	r24, 0x00	; 0
     78a:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     78e:	80 e0       	ldi	r24, 0x00	; 0
     790:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     794:	80 e0       	ldi	r24, 0x00	; 0
     796:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     79a:	80 e0       	ldi	r24, 0x00	; 0
     79c:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     7a0:	8f e0       	ldi	r24, 0x0F	; 15
     7a2:	97 e2       	ldi	r25, 0x27	; 39
     7a4:	01 97       	sbiw	r24, 0x01	; 1
     7a6:	f1 f7       	brne	.-4      	; 0x7a4 <Bluetooth_Send+0x62>
     7a8:	00 c0       	rjmp	.+0      	; 0x7aa <Bluetooth_Send+0x68>
     7aa:	00 00       	nop
     7ac:	81 ea       	ldi	r24, 0xA1	; 161
     7ae:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     7b2:	81 e0       	ldi	r24, 0x01	; 1
     7b4:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     7b8:	80 e0       	ldi	r24, 0x00	; 0
     7ba:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     7be:	80 e0       	ldi	r24, 0x00	; 0
     7c0:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     7c4:	80 e0       	ldi	r24, 0x00	; 0
     7c6:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     7ca:	80 e0       	ldi	r24, 0x00	; 0
     7cc:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     7d0:	80 e0       	ldi	r24, 0x00	; 0
     7d2:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     7d6:	80 e0       	ldi	r24, 0x00	; 0
     7d8:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     7dc:	80 e0       	ldi	r24, 0x00	; 0
     7de:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     7e2:	80 e0       	ldi	r24, 0x00	; 0
     7e4:	0f 90       	pop	r0
     7e6:	df 91       	pop	r29
     7e8:	cf 91       	pop	r28
     7ea:	1f 91       	pop	r17
     7ec:	0c 94 30 26 	jmp	0x4c60	; 0x4c60 <uart_putc>

000007f0 <Bluetooth_Reset>:
     7f0:	8f 98       	cbi	0x11, 7	; 17
     7f2:	2f e7       	ldi	r18, 0x7F	; 127
     7f4:	88 e3       	ldi	r24, 0x38	; 56
     7f6:	91 e0       	ldi	r25, 0x01	; 1
     7f8:	21 50       	subi	r18, 0x01	; 1
     7fa:	80 40       	sbci	r24, 0x00	; 0
     7fc:	90 40       	sbci	r25, 0x00	; 0
     7fe:	e1 f7       	brne	.-8      	; 0x7f8 <Bluetooth_Reset+0x8>
     800:	00 c0       	rjmp	.+0      	; 0x802 <Bluetooth_Reset+0x12>
     802:	00 00       	nop
     804:	8f 9a       	sbi	0x11, 7	; 17
     806:	2f ef       	ldi	r18, 0xFF	; 255
     808:	84 e3       	ldi	r24, 0x34	; 52
     80a:	9c e0       	ldi	r25, 0x0C	; 12
     80c:	21 50       	subi	r18, 0x01	; 1
     80e:	80 40       	sbci	r24, 0x00	; 0
     810:	90 40       	sbci	r25, 0x00	; 0
     812:	e1 f7       	brne	.-8      	; 0x80c <Bluetooth_Reset+0x1c>
     814:	00 c0       	rjmp	.+0      	; 0x816 <Bluetooth_Reset+0x26>
     816:	00 00       	nop
     818:	08 95       	ret

0000081a <Get_Response>:
     81a:	81 11       	cpse	r24, r1
     81c:	53 cf       	rjmp	.-346    	; 0x6c4 <Get_Response.part.0>
     81e:	81 e0       	ldi	r24, 0x01	; 1
     820:	08 95       	ret

00000822 <Bluetooth_Send_CMD>:
     822:	ef 92       	push	r14
     824:	ff 92       	push	r15
     826:	1f 93       	push	r17
     828:	cf 93       	push	r28
     82a:	df 93       	push	r29
     82c:	00 d0       	rcall	.+0      	; 0x82e <Bluetooth_Send_CMD+0xc>
     82e:	cd b7       	in	r28, 0x3d	; 61
     830:	de b7       	in	r29, 0x3e	; 62
     832:	16 2f       	mov	r17, r22
     834:	89 83       	std	Y+1, r24	; 0x01
     836:	9a 83       	std	Y+2, r25	; 0x02
     838:	0e 94 2b 26 	call	0x4c56	; 0x4c56 <uart_clear_rx_buffer>
     83c:	89 81       	ldd	r24, Y+1	; 0x01
     83e:	e8 2e       	mov	r14, r24
     840:	9a 81       	ldd	r25, Y+2	; 0x02
     842:	f9 2e       	mov	r15, r25
     844:	f7 01       	movw	r30, r14
     846:	81 91       	ld	r24, Z+
     848:	7f 01       	movw	r14, r30
     84a:	88 23       	and	r24, r24
     84c:	19 f0       	breq	.+6      	; 0x854 <Bluetooth_Send_CMD+0x32>
     84e:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     852:	f8 cf       	rjmp	.-16     	; 0x844 <Bluetooth_Send_CMD+0x22>
     854:	8d e0       	ldi	r24, 0x0D	; 13
     856:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     85a:	8a e0       	ldi	r24, 0x0A	; 10
     85c:	0e 94 30 26 	call	0x4c60	; 0x4c60 <uart_putc>
     860:	81 e0       	ldi	r24, 0x01	; 1
     862:	11 23       	and	r17, r17
     864:	41 f0       	breq	.+16     	; 0x876 <Bluetooth_Send_CMD+0x54>
     866:	0f 90       	pop	r0
     868:	0f 90       	pop	r0
     86a:	df 91       	pop	r29
     86c:	cf 91       	pop	r28
     86e:	1f 91       	pop	r17
     870:	ff 90       	pop	r15
     872:	ef 90       	pop	r14
     874:	d2 cf       	rjmp	.-92     	; 0x81a <Get_Response>
     876:	0f 90       	pop	r0
     878:	0f 90       	pop	r0
     87a:	df 91       	pop	r29
     87c:	cf 91       	pop	r28
     87e:	1f 91       	pop	r17
     880:	ff 90       	pop	r15
     882:	ef 90       	pop	r14
     884:	08 95       	ret

00000886 <Bluetooth_Send_PROGMEM_CMD>:
     886:	cf 93       	push	r28
     888:	c6 2f       	mov	r28, r22
     88a:	bc 01       	movw	r22, r24
     88c:	82 ef       	ldi	r24, 0xF2	; 242
     88e:	96 e0       	ldi	r25, 0x06	; 6
     890:	0e 94 d3 37 	call	0x6fa6	; 0x6fa6 <strcpy_P>
     894:	6c 2f       	mov	r22, r28
     896:	82 ef       	ldi	r24, 0xF2	; 242
     898:	96 e0       	ldi	r25, 0x06	; 6
     89a:	cf 91       	pop	r28
     89c:	c2 cf       	rjmp	.-124    	; 0x822 <Bluetooth_Send_CMD>

0000089e <Bluetooth_Enter_Proxy_Mode>:
     89e:	2f ef       	ldi	r18, 0xFF	; 255
     8a0:	89 e6       	ldi	r24, 0x69	; 105
     8a2:	98 e1       	ldi	r25, 0x18	; 24
     8a4:	21 50       	subi	r18, 0x01	; 1
     8a6:	80 40       	sbci	r24, 0x00	; 0
     8a8:	90 40       	sbci	r25, 0x00	; 0
     8aa:	e1 f7       	brne	.-8      	; 0x8a4 <Bluetooth_Enter_Proxy_Mode+0x6>
     8ac:	00 c0       	rjmp	.+0      	; 0x8ae <Bluetooth_Enter_Proxy_Mode+0x10>
     8ae:	00 00       	nop
     8b0:	60 e0       	ldi	r22, 0x00	; 0
     8b2:	86 e1       	ldi	r24, 0x16	; 22
     8b4:	91 e0       	ldi	r25, 0x01	; 1
     8b6:	e7 df       	rcall	.-50     	; 0x886 <Bluetooth_Send_PROGMEM_CMD>
     8b8:	2f ef       	ldi	r18, 0xFF	; 255
     8ba:	89 e6       	ldi	r24, 0x69	; 105
     8bc:	98 e1       	ldi	r25, 0x18	; 24
     8be:	21 50       	subi	r18, 0x01	; 1
     8c0:	80 40       	sbci	r24, 0x00	; 0
     8c2:	90 40       	sbci	r25, 0x00	; 0
     8c4:	e1 f7       	brne	.-8      	; 0x8be <Bluetooth_Enter_Proxy_Mode+0x20>
     8c6:	00 c0       	rjmp	.+0      	; 0x8c8 <Bluetooth_Enter_Proxy_Mode+0x2a>
     8c8:	00 00       	nop
     8ca:	08 95       	ret

000008cc <Bluetooth_Exit_Proxy_Mode>:
     8cc:	60 e0       	ldi	r22, 0x00	; 0
     8ce:	8c ea       	ldi	r24, 0xAC	; 172
     8d0:	90 e0       	ldi	r25, 0x00	; 0
     8d2:	d9 cf       	rjmp	.-78     	; 0x886 <Bluetooth_Send_PROGMEM_CMD>

000008d4 <Bluetooth_Init>:
     8d4:	83 e3       	ldi	r24, 0x33	; 51
     8d6:	90 e0       	ldi	r25, 0x00	; 0
     8d8:	0e 94 f9 25 	call	0x4bf2	; 0x4bf2 <uart_init>
     8dc:	89 df       	rcall	.-238    	; 0x7f0 <Bluetooth_Reset>
     8de:	2f ef       	ldi	r18, 0xFF	; 255
     8e0:	89 e6       	ldi	r24, 0x69	; 105
     8e2:	98 e1       	ldi	r25, 0x18	; 24
     8e4:	21 50       	subi	r18, 0x01	; 1
     8e6:	80 40       	sbci	r24, 0x00	; 0
     8e8:	90 40       	sbci	r25, 0x00	; 0
     8ea:	e1 f7       	brne	.-8      	; 0x8e4 <Bluetooth_Init+0x10>
     8ec:	00 c0       	rjmp	.+0      	; 0x8ee <Bluetooth_Init+0x1a>
     8ee:	00 00       	nop
     8f0:	e9 de       	rcall	.-558    	; 0x6c4 <Get_Response.part.0>
     8f2:	88 23       	and	r24, r24
     8f4:	e1 f0       	breq	.+56     	; 0x92e <Bluetooth_Init+0x5a>
     8f6:	d3 df       	rcall	.-90     	; 0x89e <Bluetooth_Enter_Proxy_Mode>
     8f8:	60 e0       	ldi	r22, 0x00	; 0
     8fa:	89 e6       	ldi	r24, 0x69	; 105
     8fc:	91 e0       	ldi	r25, 0x01	; 1
     8fe:	91 df       	rcall	.-222    	; 0x822 <Bluetooth_Send_CMD>
     900:	2f ef       	ldi	r18, 0xFF	; 255
     902:	80 e7       	ldi	r24, 0x70	; 112
     904:	92 e0       	ldi	r25, 0x02	; 2
     906:	21 50       	subi	r18, 0x01	; 1
     908:	80 40       	sbci	r24, 0x00	; 0
     90a:	90 40       	sbci	r25, 0x00	; 0
     90c:	e1 f7       	brne	.-8      	; 0x906 <Bluetooth_Init+0x32>
     90e:	00 c0       	rjmp	.+0      	; 0x910 <Bluetooth_Init+0x3c>
     910:	00 00       	nop
     912:	88 e0       	ldi	r24, 0x08	; 8
     914:	90 e0       	ldi	r25, 0x00	; 0
     916:	0e 94 f9 25 	call	0x4bf2	; 0x4bf2 <uart_init>
     91a:	d8 df       	rcall	.-80     	; 0x8cc <Bluetooth_Exit_Proxy_Mode>
     91c:	2f ef       	ldi	r18, 0xFF	; 255
     91e:	80 e7       	ldi	r24, 0x70	; 112
     920:	92 e0       	ldi	r25, 0x02	; 2
     922:	21 50       	subi	r18, 0x01	; 1
     924:	80 40       	sbci	r24, 0x00	; 0
     926:	90 40       	sbci	r25, 0x00	; 0
     928:	e1 f7       	brne	.-8      	; 0x922 <Bluetooth_Init+0x4e>
     92a:	00 c0       	rjmp	.+0      	; 0x92c <Bluetooth_Init+0x58>
     92c:	00 00       	nop
     92e:	88 e0       	ldi	r24, 0x08	; 8
     930:	90 e0       	ldi	r25, 0x00	; 0
     932:	0e 94 f9 25 	call	0x4bf2	; 0x4bf2 <uart_init>
     936:	81 e0       	ldi	r24, 0x01	; 1
     938:	80 93 19 06 	sts	0x0619, r24
     93c:	08 95       	ret

0000093e <Bluetooth_Configure>:
     93e:	cf 93       	push	r28
     940:	c9 df       	rcall	.-110    	; 0x8d4 <Bluetooth_Init>
     942:	ad df       	rcall	.-166    	; 0x89e <Bluetooth_Enter_Proxy_Mode>
     944:	61 e0       	ldi	r22, 0x01	; 1
     946:	82 e2       	ldi	r24, 0x22	; 34
     948:	91 e0       	ldi	r25, 0x01	; 1
     94a:	9d df       	rcall	.-198    	; 0x886 <Bluetooth_Send_PROGMEM_CMD>
     94c:	c8 2f       	mov	r28, r24
     94e:	61 e0       	ldi	r22, 0x01	; 1
     950:	8b e2       	ldi	r24, 0x2B	; 43
     952:	91 e0       	ldi	r25, 0x01	; 1
     954:	98 df       	rcall	.-208    	; 0x886 <Bluetooth_Send_PROGMEM_CMD>
     956:	61 e0       	ldi	r22, 0x01	; 1
     958:	86 e1       	ldi	r24, 0x16	; 22
     95a:	91 e0       	ldi	r25, 0x01	; 1
     95c:	94 df       	rcall	.-216    	; 0x886 <Bluetooth_Send_PROGMEM_CMD>
     95e:	61 e0       	ldi	r22, 0x01	; 1
     960:	81 e0       	ldi	r24, 0x01	; 1
     962:	91 e0       	ldi	r25, 0x01	; 1
     964:	90 df       	rcall	.-224    	; 0x886 <Bluetooth_Send_PROGMEM_CMD>
     966:	2f ef       	ldi	r18, 0xFF	; 255
     968:	84 e3       	ldi	r24, 0x34	; 52
     96a:	9c e0       	ldi	r25, 0x0C	; 12
     96c:	21 50       	subi	r18, 0x01	; 1
     96e:	80 40       	sbci	r24, 0x00	; 0
     970:	90 40       	sbci	r25, 0x00	; 0
     972:	e1 f7       	brne	.-8      	; 0x96c <Bluetooth_Configure+0x2e>
     974:	00 c0       	rjmp	.+0      	; 0x976 <Bluetooth_Configure+0x38>
     976:	00 00       	nop
     978:	61 e0       	ldi	r22, 0x01	; 1
     97a:	88 ee       	ldi	r24, 0xE8	; 232
     97c:	90 e0       	ldi	r25, 0x00	; 0
     97e:	83 df       	rcall	.-250    	; 0x886 <Bluetooth_Send_PROGMEM_CMD>
     980:	61 e0       	ldi	r22, 0x01	; 1
     982:	8f ed       	ldi	r24, 0xDF	; 223
     984:	90 e0       	ldi	r25, 0x00	; 0
     986:	7f df       	rcall	.-258    	; 0x886 <Bluetooth_Send_PROGMEM_CMD>
     988:	61 e0       	ldi	r22, 0x01	; 1
     98a:	86 ed       	ldi	r24, 0xD6	; 214
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	7b df       	rcall	.-266    	; 0x886 <Bluetooth_Send_PROGMEM_CMD>
     990:	61 e0       	ldi	r22, 0x01	; 1
     992:	87 ec       	ldi	r24, 0xC7	; 199
     994:	90 e0       	ldi	r25, 0x00	; 0
     996:	77 df       	rcall	.-274    	; 0x886 <Bluetooth_Send_PROGMEM_CMD>
     998:	61 e0       	ldi	r22, 0x01	; 1
     99a:	80 ed       	ldi	r24, 0xD0	; 208
     99c:	90 e0       	ldi	r25, 0x00	; 0
     99e:	73 df       	rcall	.-282    	; 0x886 <Bluetooth_Send_PROGMEM_CMD>
     9a0:	95 df       	rcall	.-214    	; 0x8cc <Bluetooth_Exit_Proxy_Mode>
     9a2:	8c 2f       	mov	r24, r28
     9a4:	cf 91       	pop	r28
     9a6:	08 95       	ret

000009a8 <BluetoothInquire>:
     9a8:	61 e0       	ldi	r22, 0x01	; 1
     9aa:	80 ed       	ldi	r24, 0xD0	; 208
     9ac:	90 e0       	ldi	r25, 0x00	; 0
     9ae:	6b cf       	rjmp	.-298    	; 0x886 <Bluetooth_Send_PROGMEM_CMD>

000009b0 <Bluetooth_Connect>:
	}
}

bool Bluetooth_Connect(){
     9b0:	cf 93       	push	r28
     9b2:	df 93       	push	r29
     9b4:	00 d0       	rcall	.+0      	; 0x9b6 <Bluetooth_Connect+0x6>
     9b6:	00 d0       	rcall	.+0      	; 0x9b8 <Bluetooth_Connect+0x8>
     9b8:	cd b7       	in	r28, 0x3d	; 61
     9ba:	de b7       	in	r29, 0x3e	; 62
//	if (is_low(BT_CONNECTED)) // if bluetooth is not already connected:
	const char s[4] = "MD=";
     9bc:	8d e4       	ldi	r24, 0x4D	; 77
     9be:	94 e4       	ldi	r25, 0x44	; 68
     9c0:	ad e3       	ldi	r26, 0x3D	; 61
     9c2:	b0 e0       	ldi	r27, 0x00	; 0
     9c4:	89 83       	std	Y+1, r24	; 0x01
     9c6:	9a 83       	std	Y+2, r25	; 0x02
     9c8:	ab 83       	std	Y+3, r26	; 0x03
     9ca:	bc 83       	std	Y+4, r27	; 0x04
	
	Bluetooth_Enter_Proxy_Mode();
     9cc:	68 df       	rcall	.-304    	; 0x89e <Bluetooth_Enter_Proxy_Mode>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     9ce:	2f ef       	ldi	r18, 0xFF	; 255
     9d0:	89 e6       	ldi	r24, 0x69	; 105
     9d2:	98 e1       	ldi	r25, 0x18	; 24
     9d4:	21 50       	subi	r18, 0x01	; 1
     9d6:	80 40       	sbci	r24, 0x00	; 0
     9d8:	90 40       	sbci	r25, 0x00	; 0
     9da:	e1 f7       	brne	.-8      	; 0x9d4 <Bluetooth_Connect+0x24>
     9dc:	00 c0       	rjmp	.+0      	; 0x9de <Bluetooth_Connect+0x2e>
     9de:	00 00       	nop
	#ifdef BT_DEBUG
		USBSendString("connect\n");
	#endif
	
	Delay_MS(1000);
	Bluetooth_Send_PROGMEM_CMD(ENABLE_UI,false); //enable ui
     9e0:	60 e0       	ldi	r22, 0x00	; 0
     9e2:	82 e2       	ldi	r24, 0x22	; 34
     9e4:	91 e0       	ldi	r25, 0x01	; 1
     9e6:	4f df       	rcall	.-354    	; 0x886 <Bluetooth_Send_PROGMEM_CMD>
	Bluetooth_Send_PROGMEM_CMD(CHECK_DISCOVERABLE,true);
     9e8:	61 e0       	ldi	r22, 0x01	; 1
     9ea:	81 ec       	ldi	r24, 0xC1	; 193
     9ec:	90 e0       	ldi	r25, 0x00	; 0
     9ee:	4b df       	rcall	.-362    	; 0x886 <Bluetooth_Send_PROGMEM_CMD>
	char* numericalresponse = strtok(response,s); //parse result so we only get the part after MD=
     9f0:	be 01       	movw	r22, r28
     9f2:	6f 5f       	subi	r22, 0xFF	; 255
     9f4:	7f 4f       	sbci	r23, 0xFF	; 255
     9f6:	89 ef       	ldi	r24, 0xF9	; 249
     9f8:	95 e0       	ldi	r25, 0x05	; 5
     9fa:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <strtok>
	numericalresponse = strtok(NULL, s); // calling function again accesses everything after the delimiter
     9fe:	be 01       	movw	r22, r28
     a00:	6f 5f       	subi	r22, 0xFF	; 255
     a02:	7f 4f       	sbci	r23, 0xFF	; 255
     a04:	80 e0       	ldi	r24, 0x00	; 0
     a06:	90 e0       	ldi	r25, 0x00	; 0
     a08:	0e 94 da 37 	call	0x6fb4	; 0x6fb4 <strtok>
	if (numericalresponse != NULL){ //if there is anything to report.
     a0c:	00 97       	sbiw	r24, 0x00	; 0
     a0e:	51 f0       	breq	.+20     	; 0xa24 <Bluetooth_Connect+0x74>
		if((numericalresponse[1] == '0')&&(is_low(BT_CONNECTED))){ //if this is not discoverable mode, and no connection has been made...
     a10:	fc 01       	movw	r30, r24
     a12:	81 81       	ldd	r24, Z+1	; 0x01
     a14:	80 33       	cpi	r24, 0x30	; 48
     a16:	31 f4       	brne	.+12     	; 0xa24 <Bluetooth_Connect+0x74>
     a18:	79 99       	sbic	0x0f, 1	; 15
     a1a:	04 c0       	rjmp	.+8      	; 0xa24 <Bluetooth_Connect+0x74>
				#ifdef BT_DEBUG
				USBSendString("connect\n");
				#endif
	
			Bluetooth_Send_PROGMEM_CMD(CONNECT_TO_PAIRED_DEVICE,true); //then attempt a new connection.
     a1c:	61 e0       	ldi	r22, 0x01	; 1
     a1e:	8b eb       	ldi	r24, 0xBB	; 187
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	31 df       	rcall	.-414    	; 0x886 <Bluetooth_Send_PROGMEM_CMD>
		}
	}
	
	Bluetooth_Exit_Proxy_Mode();
     a24:	53 df       	rcall	.-346    	; 0x8cc <Bluetooth_Exit_Proxy_Mode>
	return true;
}
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	0f 90       	pop	r0
     a2a:	0f 90       	pop	r0
     a2c:	0f 90       	pop	r0
     a2e:	0f 90       	pop	r0
     a30:	df 91       	pop	r29
     a32:	cf 91       	pop	r28
     a34:	08 95       	ret

00000a36 <Get_Bluetooth_State>:
#error "BT MODULE NAME INVALID"
#endif

uint8_t Get_Bluetooth_State(){
	return BT_State;
}
     a36:	80 91 19 06 	lds	r24, 0x0619
     a3a:	08 95       	ret

00000a3c <SaveCalibration>:
	
}


void SaveCalibration(){
		 USBSendString("SAVING...\r");
     a3c:	82 e7       	ldi	r24, 0x72	; 114
     a3e:	91 e0       	ldi	r25, 0x01	; 1
     a40:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
		 eeprom_write_block (KeyCodeLookUpTable, (void *) KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
     a44:	40 e4       	ldi	r20, 0x40	; 64
     a46:	50 e0       	ldi	r21, 0x00	; 0
     a48:	60 e0       	ldi	r22, 0x00	; 0
     a4a:	70 e0       	ldi	r23, 0x00	; 0
     a4c:	82 e2       	ldi	r24, 0x22	; 34
     a4e:	96 e0       	ldi	r25, 0x06	; 6
     a50:	0e 94 e6 3a 	call	0x75cc	; 0x75cc <eeprom_write_block>
		 eeprom_write_block (FnKeyCodeLookUpTable, (void *) FN_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
     a54:	40 e4       	ldi	r20, 0x40	; 64
     a56:	50 e0       	ldi	r21, 0x00	; 0
     a58:	60 e4       	ldi	r22, 0x40	; 64
     a5a:	70 e0       	ldi	r23, 0x00	; 0
     a5c:	80 e7       	ldi	r24, 0x70	; 112
     a5e:	99 e0       	ldi	r25, 0x09	; 9
     a60:	0e 94 e6 3a 	call	0x75cc	; 0x75cc <eeprom_write_block>
		 eeprom_write_block (ShiftKeyCodeLookUpTable, (void *) SHIFT_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
     a64:	40 e4       	ldi	r20, 0x40	; 64
     a66:	50 e0       	ldi	r21, 0x00	; 0
     a68:	60 e8       	ldi	r22, 0x80	; 128
     a6a:	70 e0       	ldi	r23, 0x00	; 0
     a6c:	8f e6       	ldi	r24, 0x6F	; 111
     a6e:	96 e0       	ldi	r25, 0x06	; 6
     a70:	0e 94 e6 3a 	call	0x75cc	; 0x75cc <eeprom_write_block>
		 eeprom_write_block (ASCIILookUpTable,(void *) ASCII_ADDR, KEYCODE_ARRAY_LENGTH);
     a74:	40 e4       	ldi	r20, 0x40	; 64
     a76:	50 e0       	ldi	r21, 0x00	; 0
     a78:	60 ec       	ldi	r22, 0xC0	; 192
     a7a:	70 e0       	ldi	r23, 0x00	; 0
     a7c:	8f e2       	ldi	r24, 0x2F	; 47
     a7e:	97 e0       	ldi	r25, 0x07	; 7
     a80:	0e 94 e6 3a 	call	0x75cc	; 0x75cc <eeprom_write_block>
		 eeprom_write_block (ASCIIShiftLookUpTable,(void *) ASCII_SHIFT_ADDR, KEYCODE_ARRAY_LENGTH);
     a84:	40 e4       	ldi	r20, 0x40	; 64
     a86:	50 e0       	ldi	r21, 0x00	; 0
     a88:	60 e0       	ldi	r22, 0x00	; 0
     a8a:	71 e0       	ldi	r23, 0x01	; 1
     a8c:	80 eb       	ldi	r24, 0xB0	; 176
     a8e:	96 e0       	ldi	r25, 0x06	; 6
     a90:	0e 94 e6 3a 	call	0x75cc	; 0x75cc <eeprom_write_block>
		 
		 eeprom_update_byte ((uint8_t *)SHIFT_REED_ADDR, Shift_Reed);
     a94:	60 91 64 06 	lds	r22, 0x0664
     a98:	85 e0       	ldi	r24, 0x05	; 5
     a9a:	92 e0       	ldi	r25, 0x02	; 2
     a9c:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
		 
		 eeprom_update_byte ((uint8_t *)REED_1_POLARITY_ADDR,Reed1Polarity);
     aa0:	60 91 6e 06 	lds	r22, 0x066E
     aa4:	86 e0       	ldi	r24, 0x06	; 6
     aa6:	92 e0       	ldi	r25, 0x02	; 2
     aa8:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
		 eeprom_update_byte ((uint8_t *)REED_2_POLARITY_ADDR,Reed2Polarity);
     aac:	60 91 1c 06 	lds	r22, 0x061C
     ab0:	87 e0       	ldi	r24, 0x07	; 7
     ab2:	92 e0       	ldi	r25, 0x02	; 2
     ab4:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
		 eeprom_update_byte ((uint8_t *)REED_3_POLARITY_ADDR,Reed3Polarity);
     ab8:	60 91 f0 06 	lds	r22, 0x06F0
     abc:	88 e0       	ldi	r24, 0x08	; 8
     abe:	92 e0       	ldi	r25, 0x02	; 2
     ac0:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
		 eeprom_update_byte ((uint8_t *)REED_4_POLARITY_ADDR,Reed4Polarity);
     ac4:	60 91 2e 07 	lds	r22, 0x072E
     ac8:	89 e0       	ldi	r24, 0x09	; 9
     aca:	92 e0       	ldi	r25, 0x02	; 2
     acc:	0c 94 d4 3a 	jmp	0x75a8	; 0x75a8 <eeprom_update_byte>

00000ad0 <DetectHallSensor>:
	TeachASCIIKey(' ',KeyPressed,LOWER); // ascii space key
	USBSend(KEY_ENTER,LOWER);
	
}

bool DetectHallSensor(){
     ad0:	cf 93       	push	r28
     ad2:	df 93       	push	r29
	bool HallSensorTest1;
	bool HallSensorTest2;

	
			UseHallSensor = HALL_NOT_PRESENT;  //make sure the hall effect bit is not cleared as soon as it is read.
     ad4:	10 92 f1 06 	sts	0x06F1, r1
			HallSensorTest1 = getHallState(); //sample the hall effect sensor bit
     ad8:	0e 94 ec 2c 	call	0x59d8	; 0x59d8 <getHallState>
     adc:	d8 2f       	mov	r29, r24
			USBSendPROGString(Str_Calibrate_Hall);
     ade:	83 ea       	ldi	r24, 0xA3	; 163
     ae0:	93 e0       	ldi	r25, 0x03	; 3
     ae2:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
     ae6:	2f ef       	ldi	r18, 0xFF	; 255
     ae8:	87 ea       	ldi	r24, 0xA7	; 167
     aea:	91 e6       	ldi	r25, 0x61	; 97
     aec:	21 50       	subi	r18, 0x01	; 1
     aee:	80 40       	sbci	r24, 0x00	; 0
     af0:	90 40       	sbci	r25, 0x00	; 0
     af2:	e1 f7       	brne	.-8      	; 0xaec <DetectHallSensor+0x1c>
     af4:	00 c0       	rjmp	.+0      	; 0xaf6 <DetectHallSensor+0x26>
     af6:	00 00       	nop
			Delay_MS(4000);
			HallSensorTest2 = getHallState(); //sample it again
     af8:	0e 94 ec 2c 	call	0x59d8	; 0x59d8 <getHallState>
     afc:	c8 2f       	mov	r28, r24
			if (HallSensorTest1 == HallSensorTest2){ //if it has not changed, hall effect sensor is not present.
     afe:	d8 13       	cpse	r29, r24
     b00:	07 c0       	rjmp	.+14     	; 0xb10 <__stack+0x11>
				USBSendPROGString(Str_No_Hall);
     b02:	82 e7       	ldi	r24, 0x72	; 114
     b04:	93 e0       	ldi	r25, 0x03	; 3
     b06:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
				UseHallSensor = HALL_NOT_PRESENT;
     b0a:	10 92 f1 06 	sts	0x06F1, r1
     b0e:	23 c0       	rjmp	.+70     	; 0xb56 <__stack+0x57>
			}
			else{ // if it has changed, the "active" polarity of the hall effect sensor is HallSensorTest2
				USBSendString("Hall Sensor Detected!\r");
     b10:	8d e7       	ldi	r24, 0x7D	; 125
     b12:	91 e0       	ldi	r25, 0x01	; 1
     b14:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
				UseHallSensor = HALL_NOT_ACTIVE;
     b18:	81 e0       	ldi	r24, 0x01	; 1
     b1a:	80 93 f1 06 	sts	0x06F1, r24
				HallSensorPolarity = HallSensorTest2;
     b1e:	c0 93 6c 06 	sts	0x066C, r28
				USBSendString("Press CTRL key now to activate Hall Sensor...");
     b22:	84 e9       	ldi	r24, 0x94	; 148
     b24:	91 e0       	ldi	r25, 0x01	; 1
     b26:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
     b2a:	83 e6       	ldi	r24, 0x63	; 99
     b2c:	90 e0       	ldi	r25, 0x00	; 0
				for (int i=1; i < 100; i++){
					if(is_low(CTRL_KEY)) UseHallSensor = HALL_ACTIVE; 
     b2e:	22 e0       	ldi	r18, 0x02	; 2
     b30:	7c 9b       	sbis	0x0f, 4	; 15
     b32:	20 93 f1 06 	sts	0x06F1, r18
     b36:	ef e5       	ldi	r30, 0x5F	; 95
     b38:	fa ee       	ldi	r31, 0xEA	; 234
     b3a:	31 97       	sbiw	r30, 0x01	; 1
     b3c:	f1 f7       	brne	.-4      	; 0xb3a <__stack+0x3b>
     b3e:	00 c0       	rjmp	.+0      	; 0xb40 <__stack+0x41>
     b40:	00 00       	nop
     b42:	01 97       	sbiw	r24, 0x01	; 1
			else{ // if it has changed, the "active" polarity of the hall effect sensor is HallSensorTest2
				USBSendString("Hall Sensor Detected!\r");
				UseHallSensor = HALL_NOT_ACTIVE;
				HallSensorPolarity = HallSensorTest2;
				USBSendString("Press CTRL key now to activate Hall Sensor...");
				for (int i=1; i < 100; i++){
     b44:	a9 f7       	brne	.-22     	; 0xb30 <__stack+0x31>
					if(is_low(CTRL_KEY)) UseHallSensor = HALL_ACTIVE; 
					Delay_MS(30);
				}
				if (UseHallSensor == HALL_ACTIVE) USBSendString("\rHall Sensor Activated!\r");
     b46:	80 91 f1 06 	lds	r24, 0x06F1
     b4a:	82 30       	cpi	r24, 0x02	; 2
     b4c:	21 f4       	brne	.+8      	; 0xb56 <__stack+0x57>
     b4e:	82 ec       	ldi	r24, 0xC2	; 194
     b50:	91 e0       	ldi	r25, 0x01	; 1
     b52:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
			}
			
			if(is_low(CMD_KEY)){
     b56:	7e 99       	sbic	0x0f, 6	; 15
     b58:	03 c0       	rjmp	.+6      	; 0xb60 <__stack+0x61>
				UseHallSensor = HALL_NOT_ACTIVE; //In the event that the hall sensor is acting erratically or not at all, holding CMD can force it off.
     b5a:	81 e0       	ldi	r24, 0x01	; 1
     b5c:	80 93 f1 06 	sts	0x06F1, r24
			}
			
			/*Save the hall effect parameters to eeprom right away:*/
			eeprom_update_byte ((uint8_t *)USE_HALL_SENSOR_ADDR, UseHallSensor);
     b60:	60 91 f1 06 	lds	r22, 0x06F1
     b64:	83 e0       	ldi	r24, 0x03	; 3
     b66:	92 e0       	ldi	r25, 0x02	; 2
     b68:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
			eeprom_update_byte ((uint8_t *)HALL_SENSOR_POLARITY_ADDR, HallSensorPolarity);
     b6c:	60 91 6c 06 	lds	r22, 0x066C
     b70:	84 e0       	ldi	r24, 0x04	; 4
     b72:	92 e0       	ldi	r25, 0x02	; 2
     b74:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
			
			return UseHallSensor;
     b78:	81 e0       	ldi	r24, 0x01	; 1
     b7a:	90 91 f1 06 	lds	r25, 0x06F1
     b7e:	91 11       	cpse	r25, r1
     b80:	01 c0       	rjmp	.+2      	; 0xb84 <__stack+0x85>
     b82:	80 e0       	ldi	r24, 0x00	; 0
}
     b84:	df 91       	pop	r29
     b86:	cf 91       	pop	r28
     b88:	08 95       	ret

00000b8a <WaitForKeypress>:
     b8a:	2f ef       	ldi	r18, 0xFF	; 255
     b8c:	81 ee       	ldi	r24, 0xE1	; 225
     b8e:	94 e0       	ldi	r25, 0x04	; 4
     b90:	21 50       	subi	r18, 0x01	; 1
     b92:	80 40       	sbci	r24, 0x00	; 0
     b94:	90 40       	sbci	r25, 0x00	; 0
     b96:	e1 f7       	brne	.-8      	; 0xb90 <WaitForKeypress+0x6>
     b98:	00 c0       	rjmp	.+0      	; 0xb9a <WaitForKeypress+0x10>
     b9a:	00 00       	nop
	int KeyPressed = 0;
	
	Delay_MS(200);//implement 500 MS delay before detecting a key.  (prevents rapid re-detection of keys over and over.
	
	while(KeyPressed == 0){ //keep getting a key until there is a key to get.
		KeyPressed = GetKeySimple();
     b9c:	0e 94 55 2b 	call	0x56aa	; 0x56aa <GetKeySimple>
     ba0:	90 e0       	ldi	r25, 0x00	; 0
int WaitForKeypress(){
	int KeyPressed = 0;
	
	Delay_MS(200);//implement 500 MS delay before detecting a key.  (prevents rapid re-detection of keys over and over.
	
	while(KeyPressed == 0){ //keep getting a key until there is a key to get.
     ba2:	00 97       	sbiw	r24, 0x00	; 0
     ba4:	d9 f3       	breq	.-10     	; 0xb9c <WaitForKeypress+0x12>
		KeyPressed = GetKeySimple();
	}
	return KeyPressed;
}
     ba6:	08 95       	ret

00000ba8 <TeachHIDKey>:
	
	
void TeachHIDKey(char teachkey, int keypressed, char Modifier){
     ba8:	cf 93       	push	r28
     baa:	df 93       	push	r29
     bac:	eb 01       	movw	r28, r22
	if (Modifier == UPPER){
		ShiftKeyCodeLookUpTable[keypressed] = teachkey;
     bae:	fb 01       	movw	r30, r22
	return KeyPressed;
}
	
	
void TeachHIDKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
     bb0:	42 30       	cpi	r20, 0x02	; 2
     bb2:	41 f4       	brne	.+16     	; 0xbc4 <TeachHIDKey+0x1c>
		ShiftKeyCodeLookUpTable[keypressed] = teachkey;
     bb4:	e1 59       	subi	r30, 0x91	; 145
     bb6:	f9 4f       	sbci	r31, 0xF9	; 249
     bb8:	80 83       	st	Z, r24
		USBSendPROGString(Str_Shift_Plus);
     bba:	8a e5       	ldi	r24, 0x5A	; 90
     bbc:	91 e0       	ldi	r25, 0x01	; 1
     bbe:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
     bc2:	11 c0       	rjmp	.+34     	; 0xbe6 <TeachHIDKey+0x3e>
	}
	else if (Modifier == HID_KEYBOARD_MODIFIER_LEFTALT){ //if FN is being held down,
     bc4:	44 30       	cpi	r20, 0x04	; 4
     bc6:	61 f4       	brne	.+24     	; 0xbe0 <TeachHIDKey+0x38>
		FnKeyCodeLookUpTable[keypressed] = teachkey;
     bc8:	e0 59       	subi	r30, 0x90	; 144
     bca:	f6 4f       	sbci	r31, 0xF6	; 246
     bcc:	80 83       	st	Z, r24
		//send "FN+number"
		USBSendString("FN");
     bce:	8b ed       	ldi	r24, 0xDB	; 219
     bd0:	91 e0       	ldi	r25, 0x01	; 1
     bd2:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
		USBSend(KEY_EQ,UPPER); //send a + sign
     bd6:	62 e0       	ldi	r22, 0x02	; 2
     bd8:	8e e2       	ldi	r24, 0x2E	; 46
     bda:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
     bde:	03 c0       	rjmp	.+6      	; 0xbe6 <TeachHIDKey+0x3e>
	}
	else{
		KeyCodeLookUpTable[keypressed] = teachkey;
     be0:	ee 5d       	subi	r30, 0xDE	; 222
     be2:	f9 4f       	sbci	r31, 0xF9	; 249
     be4:	80 83       	st	Z, r24
	}
	
	if(keypressed <= NUM_REED_SWITCHES+1){USBSendPROGString(Str_Reed);}
     be6:	c6 30       	cpi	r28, 0x06	; 6
     be8:	d1 05       	cpc	r29, r1
     bea:	24 f4       	brge	.+8      	; 0xbf4 <TeachHIDKey+0x4c>
     bec:	85 e5       	ldi	r24, 0x55	; 85
     bee:	91 e0       	ldi	r25, 0x01	; 1
     bf0:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSendNumber(keypressed);
     bf4:	8c 2f       	mov	r24, r28
     bf6:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
     bfa:	2f ef       	ldi	r18, 0xFF	; 255
     bfc:	84 e3       	ldi	r24, 0x34	; 52
     bfe:	9c e0       	ldi	r25, 0x0C	; 12
     c00:	21 50       	subi	r18, 0x01	; 1
     c02:	80 40       	sbci	r24, 0x00	; 0
     c04:	90 40       	sbci	r25, 0x00	; 0
     c06:	e1 f7       	brne	.-8      	; 0xc00 <TeachHIDKey+0x58>
     c08:	00 c0       	rjmp	.+0      	; 0xc0a <TeachHIDKey+0x62>
     c0a:	00 00       	nop
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}
     c0c:	df 91       	pop	r29
     c0e:	cf 91       	pop	r28
     c10:	08 95       	ret

00000c12 <CalibrateReeds>:
		 eeprom_update_byte ((uint8_t *)REED_2_POLARITY_ADDR,Reed2Polarity);
		 eeprom_update_byte ((uint8_t *)REED_3_POLARITY_ADDR,Reed3Polarity);
		 eeprom_update_byte ((uint8_t *)REED_4_POLARITY_ADDR,Reed4Polarity);
}

void CalibrateReeds(){	
     c12:	1f 93       	push	r17
     c14:	cf 93       	push	r28
     c16:	df 93       	push	r29
	uint8_t Modifier;
	uint8_t KeyPressed;
	
//-------TEACH BACKSPACE KEY ---------
	USBSendPROGString(Str_Backspace);
     c18:	89 ed       	ldi	r24, 0xD9	; 217
     c1a:	93 e0       	ldi	r25, 0x03	; 3
     c1c:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSend(KEY_TAB,LOWER);
     c20:	60 e0       	ldi	r22, 0x00	; 0
     c22:	8b e2       	ldi	r24, 0x2B	; 43
     c24:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
     c28:	b0 df       	rcall	.-160    	; 0xb8a <WaitForKeypress>
     c2a:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
     c2c:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
     c30:	18 2f       	mov	r17, r24
	
	TeachHIDKey(KEY_BACKSPACE,KeyPressed,Modifier); 
     c32:	dd 27       	eor	r29, r29
     c34:	48 2f       	mov	r20, r24
     c36:	be 01       	movw	r22, r28
     c38:	8a e2       	ldi	r24, 0x2A	; 42
     c3a:	b6 df       	rcall	.-148    	; 0xba8 <TeachHIDKey>
	if (!(Modifier & FN_MODIFIER)){//sd card does not use fn modifier.
     c3c:	12 fd       	sbrc	r17, 2
     c3e:	04 c0       	rjmp	.+8      	; 0xc48 <CalibrateReeds+0x36>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     c40:	c1 5d       	subi	r28, 0xD1	; 209
     c42:	d8 4f       	sbci	r29, 0xF8	; 248
     c44:	88 e0       	ldi	r24, 0x08	; 8
     c46:	88 83       	st	Y, r24
	
	TeachHIDKey(KEY_BACKSPACE,KeyPressed,Modifier); 
	if (!(Modifier & FN_MODIFIER)){//sd card does not use fn modifier.
		TeachASCIIKey(8,KeyPressed,LOWER); // 8 is ascii backspace
	}
	USBSend(KEY_ENTER,LOWER);
     c48:	60 e0       	ldi	r22, 0x00	; 0
     c4a:	88 e2       	ldi	r24, 0x28	; 40
     c4c:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
//------TEACH ESC KEY ----------
	USBSendString("ESC");
     c50:	8e ed       	ldi	r24, 0xDE	; 222
     c52:	91 e0       	ldi	r25, 0x01	; 1
     c54:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
	USBSend(KEY_TAB,LOWER);
     c58:	60 e0       	ldi	r22, 0x00	; 0
     c5a:	8b e2       	ldi	r24, 0x2B	; 43
     c5c:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
     c60:	94 df       	rcall	.-216    	; 0xb8a <WaitForKeypress>
     c62:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
     c64:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
	TeachHIDKey(KEY_ESC,KeyPressed,Modifier); 
     c68:	be 01       	movw	r22, r28
     c6a:	77 27       	eor	r23, r23
     c6c:	48 2f       	mov	r20, r24
     c6e:	89 e2       	ldi	r24, 0x29	; 41
     c70:	9b df       	rcall	.-202    	; 0xba8 <TeachHIDKey>
	//no ascii character stored for this key.
	USBSend(KEY_ENTER,LOWER);
     c72:	60 e0       	ldi	r22, 0x00	; 0
     c74:	88 e2       	ldi	r24, 0x28	; 40
     c76:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
	//------TEACH TAB KEY ---------
	USBSendString("TAB");
     c7a:	82 ee       	ldi	r24, 0xE2	; 226
     c7c:	91 e0       	ldi	r25, 0x01	; 1
     c7e:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
	USBSend(KEY_TAB,LOWER);
     c82:	60 e0       	ldi	r22, 0x00	; 0
     c84:	8b e2       	ldi	r24, 0x2B	; 43
     c86:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
     c8a:	7f df       	rcall	.-258    	; 0xb8a <WaitForKeypress>
     c8c:	ec 01       	movw	r28, r24
	Modifier = GetModifier();
     c8e:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
     c92:	18 2f       	mov	r17, r24
	TeachHIDKey(KEY_TAB,KeyPressed,Modifier);
     c94:	dd 27       	eor	r29, r29
     c96:	48 2f       	mov	r20, r24
     c98:	be 01       	movw	r22, r28
     c9a:	8b e2       	ldi	r24, 0x2B	; 43
     c9c:	85 df       	rcall	.-246    	; 0xba8 <TeachHIDKey>
	
	if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
     c9e:	12 fd       	sbrc	r17, 2
     ca0:	09 c0       	rjmp	.+18     	; 0xcb4 <CalibrateReeds+0xa2>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     ca2:	fe 01       	movw	r30, r28
     ca4:	e1 5d       	subi	r30, 0xD1	; 209
     ca6:	f8 4f       	sbci	r31, 0xF8	; 248
     ca8:	89 e0       	ldi	r24, 0x09	; 9
     caa:	80 83       	st	Z, r24
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
     cac:	c0 55       	subi	r28, 0x50	; 80
     cae:	d9 4f       	sbci	r29, 0xF9	; 249
     cb0:	84 e7       	ldi	r24, 0x74	; 116
     cb2:	88 83       	st	Y, r24
	if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
		TeachASCIIKey('\t',KeyPressed,LOWER); // tab key
		TeachASCIIKey('t',KeyPressed,UPPER); //tab key + shift is still tab
	}

	USBSend(KEY_ENTER,LOWER);
     cb4:	60 e0       	ldi	r22, 0x00	; 0
     cb6:	88 e2       	ldi	r24, 0x28	; 40
     cb8:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
//--------TEACH ENTER KEY --------
	USBSendPROGString(Str_Enter);
     cbc:	88 ef       	ldi	r24, 0xF8	; 248
     cbe:	93 e0       	ldi	r25, 0x03	; 3
     cc0:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSend(KEY_TAB,LOWER);// used to be a colon
     cc4:	60 e0       	ldi	r22, 0x00	; 0
     cc6:	8b e2       	ldi	r24, 0x2B	; 43
     cc8:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
     ccc:	5e df       	rcall	.-324    	; 0xb8a <WaitForKeypress>
	
	//Enter key cannot use modifiers
	TeachHIDKey(KEY_ENTER, KeyPressed, LOWER); //teach the hid keycode array about this key.
     cce:	ec 01       	movw	r28, r24
     cd0:	dd 27       	eor	r29, r29
     cd2:	40 e0       	ldi	r20, 0x00	; 0
     cd4:	be 01       	movw	r22, r28
     cd6:	88 e2       	ldi	r24, 0x28	; 40
     cd8:	67 df       	rcall	.-306    	; 0xba8 <TeachHIDKey>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     cda:	c1 5d       	subi	r28, 0xD1	; 209
     cdc:	d8 4f       	sbci	r29, 0xF8	; 248
     cde:	8d e0       	ldi	r24, 0x0D	; 13
     ce0:	88 83       	st	Y, r24
	KeyPressed = WaitForKeypress();
	
	//Enter key cannot use modifiers
	TeachHIDKey(KEY_ENTER, KeyPressed, LOWER); //teach the hid keycode array about this key.
	TeachASCIIKey('\r',KeyPressed, LOWER);//return carriage for ascii users
	USBSend(KEY_ENTER,LOWER);
     ce2:	60 e0       	ldi	r22, 0x00	; 0
     ce4:	88 e2       	ldi	r24, 0x28	; 40
     ce6:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
//-------TEACH SECONDARY ENTER KEY ----------
	
	USBSendPROGString(Str_Second_Enter);
     cea:	88 ee       	ldi	r24, 0xE8	; 232
     cec:	93 e0       	ldi	r25, 0x03	; 3
     cee:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSend(KEY_TAB,LOWER);// used to be a colon
     cf2:	60 e0       	ldi	r22, 0x00	; 0
     cf4:	8b e2       	ldi	r24, 0x2B	; 43
     cf6:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress(KEY_EXECUTE);
     cfa:	84 e7       	ldi	r24, 0x74	; 116
     cfc:	90 e0       	ldi	r25, 0x00	; 0
     cfe:	45 df       	rcall	.-374    	; 0xb8a <WaitForKeypress>
	
	//Enter key cannot use modifiers
	TeachHIDKey(KEY_ENTER, KeyPressed, LOWER); //teach the hid keycode array about this key.
     d00:	bc 01       	movw	r22, r24
     d02:	77 27       	eor	r23, r23
     d04:	40 e0       	ldi	r20, 0x00	; 0
     d06:	88 e2       	ldi	r24, 0x28	; 40
     d08:	4f df       	rcall	.-354    	; 0xba8 <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
     d0a:	60 e0       	ldi	r22, 0x00	; 0
     d0c:	88 e2       	ldi	r24, 0x28	; 40
     d0e:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
// -------TEACH SEND KEY --------------
	USBSendPROGString(Str_Post);
     d12:	83 ee       	ldi	r24, 0xE3	; 227
     d14:	93 e0       	ldi	r25, 0x03	; 3
     d16:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSend(KEY_TAB,LOWER);// used to be a colon
     d1a:	60 e0       	ldi	r22, 0x00	; 0
     d1c:	8b e2       	ldi	r24, 0x2B	; 43
     d1e:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
     d22:	33 df       	rcall	.-410    	; 0xb8a <WaitForKeypress>
	TeachHIDKey(KEY_EXECUTE, KeyPressed, LOWER); //teach the hid keycode array about this key.
     d24:	bc 01       	movw	r22, r24
     d26:	77 27       	eor	r23, r23
     d28:	40 e0       	ldi	r20, 0x00	; 0
     d2a:	84 e7       	ldi	r24, 0x74	; 116
     d2c:	3d df       	rcall	.-390    	; 0xba8 <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
     d2e:	60 e0       	ldi	r22, 0x00	; 0
     d30:	88 e2       	ldi	r24, 0x28	; 40
     d32:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
//------TEACH SPACE BAR ---- must be the last thing programmed (because of "Press space to skip" instruction)
	USBSendPROGString(Str_Spacebar);
     d36:	8e ef       	ldi	r24, 0xFE	; 254
     d38:	93 e0       	ldi	r25, 0x03	; 3
     d3a:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSend(KEY_TAB,LOWER);
     d3e:	60 e0       	ldi	r22, 0x00	; 0
     d40:	8b e2       	ldi	r24, 0x2B	; 43
     d42:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
     d46:	21 df       	rcall	.-446    	; 0xb8a <WaitForKeypress>
	
	TeachHIDKey(KEY_SPACE,KeyPressed,LOWER); //space bar is independent of modifier.
     d48:	ec 01       	movw	r28, r24
     d4a:	dd 27       	eor	r29, r29
     d4c:	40 e0       	ldi	r20, 0x00	; 0
     d4e:	be 01       	movw	r22, r28
     d50:	8c e2       	ldi	r24, 0x2C	; 44
     d52:	2a df       	rcall	.-428    	; 0xba8 <TeachHIDKey>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     d54:	c1 5d       	subi	r28, 0xD1	; 209
     d56:	d8 4f       	sbci	r29, 0xF8	; 248
     d58:	80 e2       	ldi	r24, 0x20	; 32
     d5a:	88 83       	st	Y, r24
	USBSend(KEY_TAB,LOWER);
	KeyPressed = WaitForKeypress();
	
	TeachHIDKey(KEY_SPACE,KeyPressed,LOWER); //space bar is independent of modifier.
	TeachASCIIKey(' ',KeyPressed,LOWER); // ascii space key
	USBSend(KEY_ENTER,LOWER);
     d5c:	60 e0       	ldi	r22, 0x00	; 0
     d5e:	88 e2       	ldi	r24, 0x28	; 40
	
}
     d60:	df 91       	pop	r29
     d62:	cf 91       	pop	r28
     d64:	1f 91       	pop	r17
	USBSend(KEY_TAB,LOWER);
	KeyPressed = WaitForKeypress();
	
	TeachHIDKey(KEY_SPACE,KeyPressed,LOWER); //space bar is independent of modifier.
	TeachASCIIKey(' ',KeyPressed,LOWER); // ascii space key
	USBSend(KEY_ENTER,LOWER);
     d66:	0c 94 f7 28 	jmp	0x51ee	; 0x51ee <USBSend>

00000d6a <QuickCalibrate>:

void QuickCalibrate(){
	uint8_t KeyPressed; //
	
	
	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
     d6a:	80 91 b4 09 	lds	r24, 0x09B4
     d6e:	84 30       	cpi	r24, 0x04	; 4
     d70:	e1 f7       	brne	.-8      	; 0xd6a <QuickCalibrate>
     d72:	2f ef       	ldi	r18, 0xFF	; 255
     d74:	89 e6       	ldi	r24, 0x69	; 105
     d76:	98 e1       	ldi	r25, 0x18	; 24
     d78:	21 50       	subi	r18, 0x01	; 1
     d7a:	80 40       	sbci	r24, 0x00	; 0
     d7c:	90 40       	sbci	r25, 0x00	; 0
     d7e:	e1 f7       	brne	.-8      	; 0xd78 <QuickCalibrate+0xe>
     d80:	00 c0       	rjmp	.+0      	; 0xd82 <QuickCalibrate+0x18>
     d82:	00 00       	nop
	Delay_MS(1000);//wait 1 second.
	
	USBSendPROGString(Str_Quick_Calibrate);
     d84:	87 e0       	ldi	r24, 0x07	; 7
     d86:	94 e0       	ldi	r25, 0x04	; 4
     d88:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	
	/*Measure the reed switch polarities*/
	Reed1Polarity = is_low(REED_1); //if reed_1 is low at start of calibration, then the polarity of reed 1 is active high
     d8c:	99 b1       	in	r25, 0x09	; 9
     d8e:	81 e0       	ldi	r24, 0x01	; 1
     d90:	92 95       	swap	r25
     d92:	91 70       	andi	r25, 0x01	; 1
     d94:	98 27       	eor	r25, r24
     d96:	90 93 6e 06 	sts	0x066E, r25
	Reed2Polarity= is_low(REED_2);
     d9a:	99 b1       	in	r25, 0x09	; 9
     d9c:	96 fb       	bst	r25, 6
     d9e:	99 27       	eor	r25, r25
     da0:	90 f9       	bld	r25, 0
     da2:	98 27       	eor	r25, r24
     da4:	90 93 1c 06 	sts	0x061C, r25
	Reed3Polarity = is_low(REED_3);
     da8:	99 b1       	in	r25, 0x09	; 9
     daa:	90 95       	com	r25
     dac:	99 1f       	adc	r25, r25
     dae:	99 27       	eor	r25, r25
     db0:	99 1f       	adc	r25, r25
     db2:	90 93 f0 06 	sts	0x06F0, r25
	Reed4Polarity = is_low(REED_4);
     db6:	93 b1       	in	r25, 0x03	; 3
     db8:	92 95       	swap	r25
     dba:	91 70       	andi	r25, 0x01	; 1
     dbc:	89 27       	eor	r24, r25
     dbe:	80 93 2e 07 	sts	0x072E, r24
	
	
	
	//Find out if user wants to use the hall effect sensor (probably not).
	DetectHallSensor();
     dc2:	86 de       	rcall	.-756    	; 0xad0 <DetectHallSensor>

	USBSendPROGString(Str_Type_The_Following);
     dc4:	8c ea       	ldi	r24, 0xAC	; 172
     dc6:	94 e0       	ldi	r25, 0x04	; 4
     dc8:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>

	//--------TEACH SHIFT KEY-----------
	USBSendString("SHIFT");
     dcc:	86 ee       	ldi	r24, 0xE6	; 230
     dce:	91 e0       	ldi	r25, 0x01	; 1
     dd0:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
	Shift_Reed = 0; //reset the shift reed to 0 (undefined) so that WaitForKeypress() doesn't ignore any of the reeds
     dd4:	10 92 64 06 	sts	0x0664, r1
	USBSend(KEY_TAB,LOWER);// used to be a colon
     dd8:	60 e0       	ldi	r22, 0x00	; 0
     dda:	8b e2       	ldi	r24, 0x2B	; 43
     ddc:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
     de0:	d4 de       	rcall	.-600    	; 0xb8a <WaitForKeypress>
	if((KeyPressed)&&(KeyPressed <= 8)){ //if keypressed is 1, 2, 3, or 4, it represents a reed switch being held down.
     de2:	9f ef       	ldi	r25, 0xFF	; 255
     de4:	98 0f       	add	r25, r24
     de6:	98 30       	cpi	r25, 0x08	; 8
     de8:	58 f4       	brcc	.+22     	; 0xe00 <QuickCalibrate+0x96>
		Shift_Reed = KeyPressed;
     dea:	80 93 64 06 	sts	0x0664, r24
		USBSendPROGString(Str_Reed);
     dee:	85 e5       	ldi	r24, 0x55	; 85
     df0:	91 e0       	ldi	r25, 0x01	; 1
     df2:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
		USBSendNumber(Shift_Reed);
     df6:	80 91 64 06 	lds	r24, 0x0664
     dfa:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
     dfe:	04 c0       	rjmp	.+8      	; 0xe08 <QuickCalibrate+0x9e>
	}
	else{
		USBSendPROGString(Str_Shift_Error);
     e00:	86 e8       	ldi	r24, 0x86	; 134
     e02:	94 e0       	ldi	r25, 0x04	; 4
     e04:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	}
	USBSend(KEY_ENTER,LOWER);
     e08:	60 e0       	ldi	r22, 0x00	; 0
     e0a:	88 e2       	ldi	r24, 0x28	; 40
     e0c:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
	CalibrateReeds();
     e10:	00 df       	rcall	.-512    	; 0xc12 <CalibrateReeds>
	
	SaveCalibration();
     e12:	14 de       	rcall	.-984    	; 0xa3c <SaveCalibration>
	
	USBSendPROGString(Str_Settings_Saved);
     e14:	81 e6       	ldi	r24, 0x61	; 97
     e16:	92 e0       	ldi	r25, 0x02	; 2
     e18:	0c 94 c1 29 	jmp	0x5382	; 0x5382 <USBSendPROGString>

00000e1c <TeachASCIIKey>:
	USBSendNumber(keypressed);
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
     e1c:	42 30       	cpi	r20, 0x02	; 2
     e1e:	21 f4       	brne	.+8      	; 0xe28 <TeachASCIIKey+0xc>
		ASCIIShiftLookUpTable[keypressed] = teachkey;
     e20:	fb 01       	movw	r30, r22
     e22:	e0 55       	subi	r30, 0x50	; 80
     e24:	f9 4f       	sbci	r31, 0xF9	; 249
     e26:	05 c0       	rjmp	.+10     	; 0xe32 <TeachASCIIKey+0x16>
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
     e28:	42 fd       	sbrc	r20, 2
     e2a:	04 c0       	rjmp	.+8      	; 0xe34 <TeachASCIIKey+0x18>
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     e2c:	fb 01       	movw	r30, r22
     e2e:	e1 5d       	subi	r30, 0xD1	; 209
     e30:	f8 4f       	sbci	r31, 0xF8	; 248
     e32:	80 83       	st	Z, r24
     e34:	08 95       	ret

00000e36 <Calibrate>:
	const char Str_Assign[]	PROGMEM = " CHARACTER SELECTED. PRESS A KEY TO ASSIGN... ";
	const char Str_Shift_Plus[] PROGMEM = "SHIFT+";
	const char Str_Reed[] PROGMEM ="REED";
	const char Str_Header[] PROGMEM = "\rCHAR:\tCONTACT#:\r";

void Calibrate(){
     e36:	5f 92       	push	r5
     e38:	6f 92       	push	r6
     e3a:	7f 92       	push	r7
     e3c:	8f 92       	push	r8
     e3e:	9f 92       	push	r9
     e40:	af 92       	push	r10
     e42:	bf 92       	push	r11
     e44:	cf 92       	push	r12
     e46:	df 92       	push	r13
     e48:	ef 92       	push	r14
     e4a:	ff 92       	push	r15
     e4c:	0f 93       	push	r16
     e4e:	1f 93       	push	r17
     e50:	cf 93       	push	r28
     e52:	df 93       	push	r29
     e54:	cd b7       	in	r28, 0x3d	; 61
     e56:	de b7       	in	r29, 0x3e	; 62
     e58:	29 97       	sbiw	r28, 0x09	; 9
     e5a:	0f b6       	in	r0, 0x3f	; 63
     e5c:	f8 94       	cli
     e5e:	de bf       	out	0x3e, r29	; 62
     e60:	0f be       	out	0x3f, r0	; 63
     e62:	cd bf       	out	0x3d, r28	; 61
	uint8_t Modifier;
	uint8_t KeyPressed;
	
	uint8_t Default_Mode;

	ClearKeyCodeTables();//clear keycode tables (in memory)
     e64:	0e 94 54 2d 	call	0x5aa8	; 0x5aa8 <ClearKeyCodeTables>

	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
     e68:	80 91 b4 09 	lds	r24, 0x09B4
     e6c:	84 30       	cpi	r24, 0x04	; 4
     e6e:	e1 f7       	brne	.-8      	; 0xe68 <Calibrate+0x32>
     e70:	2f ef       	ldi	r18, 0xFF	; 255
     e72:	89 e6       	ldi	r24, 0x69	; 105
     e74:	98 e1       	ldi	r25, 0x18	; 24
     e76:	21 50       	subi	r18, 0x01	; 1
     e78:	80 40       	sbci	r24, 0x00	; 0
     e7a:	90 40       	sbci	r25, 0x00	; 0
     e7c:	e1 f7       	brne	.-8      	; 0xe76 <Calibrate+0x40>
     e7e:	00 c0       	rjmp	.+0      	; 0xe80 <Calibrate+0x4a>
     e80:	00 00       	nop
	Delay_MS(1000);//wait 1 second.
	
//--------SEND PROMPT TO USER -----------

    USBSendPROGString(Str_USB_Typewriter);
     e82:	8a e8       	ldi	r24, 0x8A	; 138
     e84:	95 e0       	ldi	r25, 0x05	; 5
     e86:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSendPROGString(Str_Firmware_Ver);
     e8a:	84 e7       	ldi	r24, 0x74	; 116
     e8c:	95 e0       	ldi	r25, 0x05	; 5
     e8e:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSend(KEY_ENTER,LOWER);
     e92:	60 e0       	ldi	r22, 0x00	; 0
     e94:	88 e2       	ldi	r24, 0x28	; 40
     e96:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
	
	Default_Mode = eeprom_read_byte((uint8_t*)DEFAULT_MODE_ADDR);
     e9a:	8d e0       	ldi	r24, 0x0D	; 13
     e9c:	92 e0       	ldi	r25, 0x02	; 2
     e9e:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
     ea2:	18 2f       	mov	r17, r24
	USBSendPROGString(Str_Typewriter_Mode);
     ea4:	82 e6       	ldi	r24, 0x62	; 98
     ea6:	95 e0       	ldi	r25, 0x05	; 5
     ea8:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	switch(Default_Mode){
     eac:	12 30       	cpi	r17, 0x02	; 2
     eae:	91 f0       	breq	.+36     	; 0xed4 <Calibrate+0x9e>
     eb0:	28 f4       	brcc	.+10     	; 0xebc <Calibrate+0x86>
     eb2:	11 30       	cpi	r17, 0x01	; 1
     eb4:	91 f4       	brne	.+36     	; 0xeda <Calibrate+0xa4>
		case USB_COMBO_MODE: 
			USBSendPROGString(Str_Combo_Mode); 
     eb6:	84 e0       	ldi	r24, 0x04	; 4
     eb8:	95 e0       	ldi	r25, 0x05	; 5
     eba:	09 c0       	rjmp	.+18     	; 0xece <Calibrate+0x98>
	USBSend(KEY_ENTER,LOWER);
	
	
	Default_Mode = eeprom_read_byte((uint8_t*)DEFAULT_MODE_ADDR);
	USBSendPROGString(Str_Typewriter_Mode);
	switch(Default_Mode){
     ebc:	19 30       	cpi	r17, 0x09	; 9
     ebe:	29 f0       	breq	.+10     	; 0xeca <Calibrate+0x94>
     ec0:	1d 30       	cpi	r17, 0x0D	; 13
     ec2:	59 f4       	brne	.+22     	; 0xeda <Calibrate+0xa4>
		break;
		case SD_MODE: 
			USBSendPROGString(Str_SD_Mode);
		break;
		case USB_LIGHT_MODE:
			USBSendPROGString(Str_Light_Mode);
     ec4:	83 e2       	ldi	r24, 0x23	; 35
     ec6:	95 e0       	ldi	r25, 0x05	; 5
     ec8:	02 c0       	rjmp	.+4      	; 0xece <Calibrate+0x98>
	switch(Default_Mode){
		case USB_COMBO_MODE: 
			USBSendPROGString(Str_Combo_Mode); 
		break;
		case BLUETOOTH_MODE: 
			USBSendPROGString(Str_BT_Mode); 
     eca:	89 e4       	ldi	r24, 0x49	; 73
     ecc:	95 e0       	ldi	r25, 0x05	; 5
     ece:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
		break;
     ed2:	07 c0       	rjmp	.+14     	; 0xee2 <Calibrate+0xac>
		case SD_MODE: 
			USBSendPROGString(Str_SD_Mode);
     ed4:	8e ee       	ldi	r24, 0xEE	; 238
     ed6:	94 e0       	ldi	r25, 0x04	; 4
     ed8:	fa cf       	rjmp	.-12     	; 0xece <Calibrate+0x98>
		break;
		case USB_LIGHT_MODE:
			USBSendPROGString(Str_Light_Mode);
		break;
		default: USBSendString("NONE\r"); break;
     eda:	8c ee       	ldi	r24, 0xEC	; 236
     edc:	91 e0       	ldi	r25, 0x01	; 1
     ede:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
	}
	
	USBSendPROGString(Str_Calibrating);
     ee2:	8e ed       	ldi	r24, 0xDE	; 222
     ee4:	94 e0       	ldi	r25, 0x04	; 4
     ee6:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	
	/*Measure the reed switch polarities*/
		Reed1Polarity = is_low(REED_1); //if reed_1 is low at start of calibration, then the polarity of reed 1 is active high
     eea:	89 b1       	in	r24, 0x09	; 9
     eec:	11 e0       	ldi	r17, 0x01	; 1
     eee:	82 95       	swap	r24
     ef0:	81 70       	andi	r24, 0x01	; 1
     ef2:	81 27       	eor	r24, r17
     ef4:	80 93 6e 06 	sts	0x066E, r24
		Reed2Polarity= is_low(REED_2);
     ef8:	89 b1       	in	r24, 0x09	; 9
     efa:	86 fb       	bst	r24, 6
     efc:	88 27       	eor	r24, r24
     efe:	80 f9       	bld	r24, 0
     f00:	81 27       	eor	r24, r17
     f02:	80 93 1c 06 	sts	0x061C, r24
		Reed3Polarity = is_low(REED_3);
     f06:	89 b1       	in	r24, 0x09	; 9
     f08:	80 95       	com	r24
     f0a:	88 1f       	adc	r24, r24
     f0c:	88 27       	eor	r24, r24
     f0e:	88 1f       	adc	r24, r24
     f10:	80 93 f0 06 	sts	0x06F0, r24
		Reed4Polarity = is_low(REED_4);
     f14:	83 b1       	in	r24, 0x03	; 3
     f16:	82 95       	swap	r24
     f18:	81 70       	andi	r24, 0x01	; 1
     f1a:	81 27       	eor	r24, r17
     f1c:	80 93 2e 07 	sts	0x072E, r24

		DetectHallSensor();
     f20:	d7 dd       	rcall	.-1106   	; 0xad0 <DetectHallSensor>
	
	if (is_low(S2)){//hold down to activate the dummy load
     f22:	7d 99       	sbic	0x0f, 5	; 15
     f24:	15 c0       	rjmp	.+42     	; 0xf50 <Calibrate+0x11a>
		if (UseDummyLoad) {
     f26:	80 91 1d 06 	lds	r24, 0x061D
     f2a:	88 23       	and	r24, r24
     f2c:	29 f0       	breq	.+10     	; 0xf38 <Calibrate+0x102>
			UseDummyLoad = 0; 
     f2e:	10 92 1d 06 	sts	0x061D, r1
			USBSendPROGString(Str_No_Dummy_Load);
     f32:	82 e2       	ldi	r24, 0x22	; 34
     f34:	94 e0       	ldi	r25, 0x04	; 4
     f36:	04 c0       	rjmp	.+8      	; 0xf40 <Calibrate+0x10a>
		}
		else {
		UseDummyLoad = 1; 
     f38:	10 93 1d 06 	sts	0x061D, r17
		USBSendPROGString(Str_Dummy_Load);
     f3c:	8a e3       	ldi	r24, 0x3A	; 58
     f3e:	94 e0       	ldi	r25, 0x04	; 4
     f40:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
		}
		eeprom_update_byte((uint8_t*)DUMMY_LOAD_ADDR, UseDummyLoad);
     f44:	60 91 1d 06 	lds	r22, 0x061D
     f48:	8f e0       	ldi	r24, 0x0F	; 15
     f4a:	92 e0       	ldi	r25, 0x02	; 2
     f4c:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
	}
	
	USBSendPROGString(Str_Type_The_Following);
     f50:	8c ea       	ldi	r24, 0xAC	; 172
     f52:	94 e0       	ldi	r25, 0x04	; 4
     f54:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSendPROGString(Str_Header);
     f58:	83 e4       	ldi	r24, 0x43	; 67
     f5a:	91 e0       	ldi	r25, 0x01	; 1
     f5c:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	
//--------TEACH LETTER KEYS----------
	for (HIDKey = KEY_A; HIDKey <= KEY_Z; HIDKey ++){
     f60:	14 e0       	ldi	r17, 0x04	; 4
					
		TeachHIDKey(HIDKey, KeyPressed, Modifier); //all alphanumeric keys programmed as a/A pairs -- no special shift keys allowed.
		ASCIIKey = HIDKey-KEY_A+ASCII_A; //calculated corresponding sd card Ascii key
		
		if(HIDKey  == HID_KEYBOARD_SC_L){ //if the key is l, make sure fn+l=1
			FnKeyCodeLookUpTable[KeyPressed] = KEY_1;
     f62:	0e e1       	ldi	r16, 0x1E	; 30
     f64:	d0 2e       	mov	r13, r16
	USBSendPROGString(Str_Type_The_Following);
	USBSendPROGString(Str_Header);
	
//--------TEACH LETTER KEYS----------
	for (HIDKey = KEY_A; HIDKey <= KEY_Z; HIDKey ++){
		USBSend(HIDKey, UPPER);
     f66:	62 e0       	ldi	r22, 0x02	; 2
     f68:	81 2f       	mov	r24, r17
     f6a:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
		USBSend(KEY_TAB,LOWER);// used to be a colon
     f6e:	60 e0       	ldi	r22, 0x00	; 0
     f70:	8b e2       	ldi	r24, 0x2B	; 43
     f72:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
		KeyPressed = WaitForKeypress();
     f76:	09 de       	rcall	.-1006   	; 0xb8a <WaitForKeypress>
     f78:	7c 01       	movw	r14, r24
		Modifier = GetModifier();
     f7a:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
     f7e:	08 2f       	mov	r16, r24
		
		Modifier &= ~(HID_KEYBOARD_MODIFIER_LEFTSHIFT); //Lower-case version of the modifier indicator (overrid user's shift key)
					
		TeachHIDKey(HIDKey, KeyPressed, Modifier); //all alphanumeric keys programmed as a/A pairs -- no special shift keys allowed.
     f80:	ff 24       	eor	r15, r15
		USBSend(HIDKey, UPPER);
		USBSend(KEY_TAB,LOWER);// used to be a colon
		KeyPressed = WaitForKeypress();
		Modifier = GetModifier();
		
		Modifier &= ~(HID_KEYBOARD_MODIFIER_LEFTSHIFT); //Lower-case version of the modifier indicator (overrid user's shift key)
     f82:	48 2f       	mov	r20, r24
     f84:	4d 7f       	andi	r20, 0xFD	; 253
					
		TeachHIDKey(HIDKey, KeyPressed, Modifier); //all alphanumeric keys programmed as a/A pairs -- no special shift keys allowed.
     f86:	b7 01       	movw	r22, r14
     f88:	81 2f       	mov	r24, r17
     f8a:	0e de       	rcall	.-996    	; 0xba8 <TeachHIDKey>
		ASCIIKey = HIDKey-KEY_A+ASCII_A; //calculated corresponding sd card Ascii key
		
		if(HIDKey  == HID_KEYBOARD_SC_L){ //if the key is l, make sure fn+l=1
     f8c:	1f 30       	cpi	r17, 0x0F	; 15
     f8e:	21 f4       	brne	.+8      	; 0xf98 <Calibrate+0x162>
			FnKeyCodeLookUpTable[KeyPressed] = KEY_1;
     f90:	f7 01       	movw	r30, r14
     f92:	e0 59       	subi	r30, 0x90	; 144
     f94:	f6 4f       	sbci	r31, 0xF6	; 246
     f96:	d0 82       	st	Z, r13
		}
		
		if (!(Modifier & FN_MODIFIER)) { //only bother to program sd card letters if the fn key is not being pressed (sd card doesn't use fn key)
     f98:	02 fd       	sbrc	r16, 2
     f9a:	0c c0       	rjmp	.+24     	; 0xfb4 <Calibrate+0x17e>
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
     f9c:	f7 01       	movw	r30, r14
     f9e:	e0 55       	subi	r30, 0x50	; 80
     fa0:	f9 4f       	sbci	r31, 0xF9	; 249
		Modifier = GetModifier();
		
		Modifier &= ~(HID_KEYBOARD_MODIFIER_LEFTSHIFT); //Lower-case version of the modifier indicator (overrid user's shift key)
					
		TeachHIDKey(HIDKey, KeyPressed, Modifier); //all alphanumeric keys programmed as a/A pairs -- no special shift keys allowed.
		ASCIIKey = HIDKey-KEY_A+ASCII_A; //calculated corresponding sd card Ascii key
     fa2:	8d e3       	ldi	r24, 0x3D	; 61
     fa4:	81 0f       	add	r24, r17
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
     fa6:	80 83       	st	Z, r24
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     fa8:	f7 01       	movw	r30, r14
     faa:	e1 5d       	subi	r30, 0xD1	; 209
     fac:	f8 4f       	sbci	r31, 0xF8	; 248
     fae:	8d e5       	ldi	r24, 0x5D	; 93
     fb0:	81 0f       	add	r24, r17
     fb2:	80 83       	st	Z, r24
		if (!(Modifier & FN_MODIFIER)) { //only bother to program sd card letters if the fn key is not being pressed (sd card doesn't use fn key)
			TeachASCIIKey(ASCIIKey, KeyPressed, UPPER);  //program this key into memory as an upper case key
			TeachASCIIKey(ASCIIKey+0x20, KeyPressed, LOWER); // and as a lower case key
		}
		
		USBSend(KEY_ENTER,LOWER);
     fb4:	60 e0       	ldi	r22, 0x00	; 0
     fb6:	88 e2       	ldi	r24, 0x28	; 40
     fb8:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
	USBSendPROGString(Str_Type_The_Following);
	USBSendPROGString(Str_Header);
	
//--------TEACH LETTER KEYS----------
	for (HIDKey = KEY_A; HIDKey <= KEY_Z; HIDKey ++){
     fbc:	1f 5f       	subi	r17, 0xFF	; 255
     fbe:	1e 31       	cpi	r17, 0x1E	; 30
     fc0:	91 f6       	brne	.-92     	; 0xf66 <Calibrate+0x130>
     fc2:	be e1       	ldi	r27, 0x1E	; 30
     fc4:	cb 2e       	mov	r12, r27
     fc6:	b2 e0       	ldi	r27, 0x02	; 2
     fc8:	db 2e       	mov	r13, r27
     fca:	e1 2c       	mov	r14, r1
     fcc:	f1 2c       	mov	r15, r1
		USBSend(KEY_ENTER,LOWER);
	}

//--------TEACH NUMBER KEYS---------
	for (int i = 0; i <= 9; i ++){
			USBSend(HIDNumbers[i], LOWER);
     fce:	f6 01       	movw	r30, r12
     fd0:	a1 90       	ld	r10, Z+
     fd2:	6f 01       	movw	r12, r30
     fd4:	60 e0       	ldi	r22, 0x00	; 0
     fd6:	8a 2d       	mov	r24, r10
     fd8:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
			USBSend(KEY_TAB,LOWER);// used to be a colon
     fdc:	60 e0       	ldi	r22, 0x00	; 0
     fde:	8b e2       	ldi	r24, 0x2B	; 43
     fe0:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
			KeyPressed = WaitForKeypress();
     fe4:	d2 dd       	rcall	.-1116   	; 0xb8a <WaitForKeypress>
     fe6:	8c 01       	movw	r16, r24
			Modifier = GetModifier();
     fe8:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
     fec:	b8 2e       	mov	r11, r24
			
			Modifier &= ~(HID_KEYBOARD_MODIFIER_LEFTSHIFT); //numbers are always lower-case (override user's shift key)
			
			TeachHIDKey(HIDNumbers[i], KeyPressed, Modifier); //teach the hid keycode array about this key -- must be lowercase.
     fee:	11 27       	eor	r17, r17
			USBSend(HIDNumbers[i], LOWER);
			USBSend(KEY_TAB,LOWER);// used to be a colon
			KeyPressed = WaitForKeypress();
			Modifier = GetModifier();
			
			Modifier &= ~(HID_KEYBOARD_MODIFIER_LEFTSHIFT); //numbers are always lower-case (override user's shift key)
     ff0:	48 2f       	mov	r20, r24
     ff2:	4d 7f       	andi	r20, 0xFD	; 253
			
			TeachHIDKey(HIDNumbers[i], KeyPressed, Modifier); //teach the hid keycode array about this key -- must be lowercase.
     ff4:	b8 01       	movw	r22, r16
     ff6:	8a 2d       	mov	r24, r10
     ff8:	d7 dd       	rcall	.-1106   	; 0xba8 <TeachHIDKey>
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
     ffa:	b2 fc       	sbrc	r11, 2
     ffc:	16 c0       	rjmp	.+44     	; 0x102a <Calibrate+0x1f4>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     ffe:	f8 01       	movw	r30, r16
    1000:	e1 5d       	subi	r30, 0xD1	; 209
    1002:	f8 4f       	sbci	r31, 0xF8	; 248
    1004:	d7 01       	movw	r26, r14
    1006:	ac 5e       	subi	r26, 0xEC	; 236
    1008:	bd 4f       	sbci	r27, 0xFD	; 253
    100a:	8c 91       	ld	r24, X
    100c:	80 83       	st	Z, r24
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    100e:	f8 01       	movw	r30, r16
    1010:	e0 55       	subi	r30, 0x50	; 80
    1012:	f9 4f       	sbci	r31, 0xF9	; 249
    1014:	d7 01       	movw	r26, r14
    1016:	a6 5f       	subi	r26, 0xF6	; 246
    1018:	bd 4f       	sbci	r27, 0xFD	; 253
    101a:	8c 91       	ld	r24, X
    101c:	80 83       	st	Z, r24
			TeachHIDKey(HIDNumbers[i], KeyPressed, Modifier); //teach the hid keycode array about this key -- must be lowercase.
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				TeachASCIIKey(ASCIINumbers[i], KeyPressed, LOWER); // and the ascii array about this key
				TeachASCIIKey(ASCIINumSymbols[i],KeyPressed, UPPER); // and the symbols above the numbers on most typewriters, for asii (sd card) use only.
				FnKeyCodeLookUpTable[KeyPressed] = (KEY_F1+i);			}
    101e:	f8 01       	movw	r30, r16
    1020:	e0 59       	subi	r30, 0x90	; 144
    1022:	f6 4f       	sbci	r31, 0xF6	; 246
    1024:	8a e3       	ldi	r24, 0x3A	; 58
    1026:	8e 0d       	add	r24, r14
    1028:	80 83       	st	Z, r24
			
			USBSend(KEY_ENTER,LOWER);
    102a:	60 e0       	ldi	r22, 0x00	; 0
    102c:	88 e2       	ldi	r24, 0x28	; 40
    102e:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
		
		USBSend(KEY_ENTER,LOWER);
	}

//--------TEACH NUMBER KEYS---------
	for (int i = 0; i <= 9; i ++){
    1032:	ff ef       	ldi	r31, 0xFF	; 255
    1034:	ef 1a       	sub	r14, r31
    1036:	ff 0a       	sbc	r15, r31
    1038:	2a e0       	ldi	r18, 0x0A	; 10
    103a:	e2 16       	cp	r14, r18
    103c:	f1 04       	cpc	r15, r1
    103e:	39 f6       	brne	.-114    	; 0xfce <Calibrate+0x198>
			
			USBSend(KEY_ENTER,LOWER);
	}
	
//----TEACH F1, F11, F12
	USBSendString("F1");
    1040:	82 ef       	ldi	r24, 0xF2	; 242
    1042:	91 e0       	ldi	r25, 0x01	; 1
    1044:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
	USBSend(KEY_TAB,LOWER);
    1048:	60 e0       	ldi	r22, 0x00	; 0
    104a:	8b e2       	ldi	r24, 0x2B	; 43
    104c:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
    1050:	9c dd       	rcall	.-1224   	; 0xb8a <WaitForKeypress>
    1052:	8c 01       	movw	r16, r24
	Modifier = GetModifier();
    1054:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
	TeachHIDKey(KEY_F1, KeyPressed, Modifier); 
    1058:	b8 01       	movw	r22, r16
    105a:	77 27       	eor	r23, r23
    105c:	48 2f       	mov	r20, r24
    105e:	8a e3       	ldi	r24, 0x3A	; 58
    1060:	a3 dd       	rcall	.-1210   	; 0xba8 <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
    1062:	60 e0       	ldi	r22, 0x00	; 0
    1064:	88 e2       	ldi	r24, 0x28	; 40
    1066:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
	USBSendString("F11");
    106a:	85 ef       	ldi	r24, 0xF5	; 245
    106c:	91 e0       	ldi	r25, 0x01	; 1
    106e:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
	USBSend(KEY_TAB,LOWER);
    1072:	60 e0       	ldi	r22, 0x00	; 0
    1074:	8b e2       	ldi	r24, 0x2B	; 43
    1076:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
    107a:	87 dd       	rcall	.-1266   	; 0xb8a <WaitForKeypress>
    107c:	8c 01       	movw	r16, r24
	Modifier = GetModifier();
    107e:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
	TeachHIDKey(KEY_F11, KeyPressed, Modifier);
    1082:	b8 01       	movw	r22, r16
    1084:	77 27       	eor	r23, r23
    1086:	48 2f       	mov	r20, r24
    1088:	84 e4       	ldi	r24, 0x44	; 68
    108a:	8e dd       	rcall	.-1252   	; 0xba8 <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
    108c:	60 e0       	ldi	r22, 0x00	; 0
    108e:	88 e2       	ldi	r24, 0x28	; 40
    1090:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
	USBSendString("F12");
    1094:	89 ef       	ldi	r24, 0xF9	; 249
    1096:	91 e0       	ldi	r25, 0x01	; 1
    1098:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
	USBSend(KEY_TAB,LOWER);
    109c:	60 e0       	ldi	r22, 0x00	; 0
    109e:	8b e2       	ldi	r24, 0x2B	; 43
    10a0:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
    10a4:	72 dd       	rcall	.-1308   	; 0xb8a <WaitForKeypress>
    10a6:	8c 01       	movw	r16, r24
	Modifier = GetModifier();
    10a8:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
	TeachHIDKey(KEY_F12, KeyPressed, Modifier);
    10ac:	b8 01       	movw	r22, r16
    10ae:	77 27       	eor	r23, r23
    10b0:	48 2f       	mov	r20, r24
    10b2:	85 e4       	ldi	r24, 0x45	; 69
    10b4:	79 dd       	rcall	.-1294   	; 0xba8 <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);	
    10b6:	60 e0       	ldi	r22, 0x00	; 0
    10b8:	88 e2       	ldi	r24, 0x28	; 40
    10ba:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
//--------TEACH SHIFT KEY-----------
	USBSendString("SHIFT");
    10be:	86 ee       	ldi	r24, 0xE6	; 230
    10c0:	91 e0       	ldi	r25, 0x01	; 1
    10c2:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
	USBSend(KEY_TAB,LOWER);// used to be a colon
    10c6:	60 e0       	ldi	r22, 0x00	; 0
    10c8:	8b e2       	ldi	r24, 0x2B	; 43
    10ca:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
    10ce:	5d dd       	rcall	.-1350   	; 0xb8a <WaitForKeypress>
	if((KeyPressed)&&(KeyPressed <= 8)){ //if keypressed is 1, 2, 3, or 4, it represents a reed switch being held down.
    10d0:	9f ef       	ldi	r25, 0xFF	; 255
    10d2:	98 0f       	add	r25, r24
    10d4:	98 30       	cpi	r25, 0x08	; 8
    10d6:	58 f4       	brcc	.+22     	; 0x10ee <Calibrate+0x2b8>
		Shift_Reed = KeyPressed;
    10d8:	80 93 64 06 	sts	0x0664, r24
		USBSendPROGString(Str_Reed);
    10dc:	85 e5       	ldi	r24, 0x55	; 85
    10de:	91 e0       	ldi	r25, 0x01	; 1
    10e0:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
		USBSendNumber(Shift_Reed);
    10e4:	80 91 64 06 	lds	r24, 0x0664
    10e8:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
    10ec:	04 c0       	rjmp	.+8      	; 0x10f6 <Calibrate+0x2c0>
	}
	else{
		USBSendPROGString(Str_Shift_Error);
    10ee:	86 e8       	ldi	r24, 0x86	; 134
    10f0:	94 e0       	ldi	r25, 0x04	; 4
    10f2:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
    10f6:	8f ef       	ldi	r24, 0xFF	; 255
    10f8:	94 e3       	ldi	r25, 0x34	; 52
    10fa:	ec e0       	ldi	r30, 0x0C	; 12
    10fc:	81 50       	subi	r24, 0x01	; 1
    10fe:	90 40       	sbci	r25, 0x00	; 0
    1100:	e0 40       	sbci	r30, 0x00	; 0
    1102:	e1 f7       	brne	.-8      	; 0x10fc <Calibrate+0x2c6>
    1104:	00 c0       	rjmp	.+0      	; 0x1106 <Calibrate+0x2d0>
    1106:	00 00       	nop
	}
	Delay_MS(CALIBRATION_DELAY);
	USBSend(KEY_ENTER,LOWER);
    1108:	60 e0       	ldi	r22, 0x00	; 0
    110a:	88 e2       	ldi	r24, 0x28	; 40
    110c:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
//----------TEACH SYMBOL KEYS------------	
	for (HIDKey = KEY_DASH; HIDKey <= KEY_SLASH; HIDKey ++){
    1110:	2d e2       	ldi	r18, 0x2D	; 45
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1112:	8e e2       	ldi	r24, 0x2E	; 46
    1114:	f8 2e       	mov	r15, r24
    1116:	9c e2       	ldi	r25, 0x2C	; 44
    1118:	c9 2e       	mov	r12, r25
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    111a:	3f e3       	ldi	r19, 0x3F	; 63
    111c:	e3 2e       	mov	r14, r19
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    111e:	4f e2       	ldi	r20, 0x2F	; 47
    1120:	b4 2e       	mov	r11, r20
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1122:	5a e2       	ldi	r21, 0x2A	; 42
    1124:	a5 2e       	mov	r10, r21
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1126:	60 e6       	ldi	r22, 0x60	; 96
    1128:	96 2e       	mov	r9, r22
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    112a:	7e e7       	ldi	r23, 0x7E	; 126
    112c:	87 2e       	mov	r8, r23
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    112e:	ed e3       	ldi	r30, 0x3D	; 61
    1130:	7e 2e       	mov	r7, r30
    1132:	fb e3       	ldi	r31, 0x3B	; 59
    1134:	6f 2e       	mov	r6, r31
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1136:	aa e3       	ldi	r26, 0x3A	; 58
    1138:	5a 2e       	mov	r5, r26
	Delay_MS(CALIBRATION_DELAY);
	USBSend(KEY_ENTER,LOWER);
	
//----------TEACH SYMBOL KEYS------------	
	for (HIDKey = KEY_DASH; HIDKey <= KEY_SLASH; HIDKey ++){
			if (HIDKey != HID_KEYBOARD_SC_NON_US_HASHMARK_AND_TILDE){ //don't bother to program the non-us hash key, which is a weird and confusing key.
    113a:	22 33       	cpi	r18, 0x32	; 50
    113c:	09 f4       	brne	.+2      	; 0x1140 <Calibrate+0x30a>
    113e:	66 c0       	rjmp	.+204    	; 0x120c <Calibrate+0x3d6>
			USBSend(HIDKey, LOWER);
    1140:	60 e0       	ldi	r22, 0x00	; 0
    1142:	82 2f       	mov	r24, r18
    1144:	29 87       	std	Y+9, r18	; 0x09
    1146:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
			USBSend(KEY_TAB,LOWER);// used to be a colon
    114a:	60 e0       	ldi	r22, 0x00	; 0
    114c:	8b e2       	ldi	r24, 0x2B	; 43
    114e:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
			KeyPressed = WaitForKeypress();
    1152:	1b dd       	rcall	.-1482   	; 0xb8a <WaitForKeypress>
    1154:	8c 01       	movw	r16, r24
			Modifier = GetModifier();
    1156:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
    115a:	d8 2e       	mov	r13, r24
			
			TeachHIDKey(HIDKey, KeyPressed, Modifier); //program these characters, including the modifer used when programming them.
    115c:	11 27       	eor	r17, r17
    115e:	48 2f       	mov	r20, r24
    1160:	b8 01       	movw	r22, r16
    1162:	29 85       	ldd	r18, Y+9	; 0x09
    1164:	82 2f       	mov	r24, r18
    1166:	20 dd       	rcall	.-1472   	; 0xba8 <TeachHIDKey>
			
			//some of these keys (but not all) are also used for the SD card mode:			
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
    1168:	29 85       	ldd	r18, Y+9	; 0x09
    116a:	d2 fc       	sbrc	r13, 2
    116c:	49 c0       	rjmp	.+146    	; 0x1200 <Calibrate+0x3ca>
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
    116e:	23 33       	cpi	r18, 0x33	; 51
    1170:	49 f4       	brne	.+18     	; 0x1184 <Calibrate+0x34e>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1172:	f8 01       	movw	r30, r16
    1174:	e1 5d       	subi	r30, 0xD1	; 209
    1176:	f8 4f       	sbci	r31, 0xF8	; 248
    1178:	60 82       	st	Z, r6
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    117a:	f8 01       	movw	r30, r16
    117c:	e0 55       	subi	r30, 0x50	; 80
    117e:	f9 4f       	sbci	r31, 0xF9	; 249
    1180:	50 82       	st	Z, r5
    1182:	3e c0       	rjmp	.+124    	; 0x1200 <Calibrate+0x3ca>
			
			//some of these keys (but not all) are also used for the SD card mode:			
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
    1184:	2e 32       	cpi	r18, 0x2E	; 46
    1186:	51 f4       	brne	.+20     	; 0x119c <Calibrate+0x366>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    1188:	f8 01       	movw	r30, r16
    118a:	e1 5d       	subi	r30, 0xD1	; 209
    118c:	f8 4f       	sbci	r31, 0xF8	; 248
    118e:	70 82       	st	Z, r7
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    1190:	f8 01       	movw	r30, r16
    1192:	e0 55       	subi	r30, 0x50	; 80
    1194:	f9 4f       	sbci	r31, 0xF9	; 249
    1196:	8b e2       	ldi	r24, 0x2B	; 43
    1198:	80 83       	st	Z, r24
    119a:	32 c0       	rjmp	.+100    	; 0x1200 <Calibrate+0x3ca>
			//some of these keys (but not all) are also used for the SD card mode:			
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
    119c:	25 33       	cpi	r18, 0x35	; 53
    119e:	49 f4       	brne	.+18     	; 0x11b2 <Calibrate+0x37c>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    11a0:	f8 01       	movw	r30, r16
    11a2:	e1 5d       	subi	r30, 0xD1	; 209
    11a4:	f8 4f       	sbci	r31, 0xF8	; 248
    11a6:	90 82       	st	Z, r9
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    11a8:	f8 01       	movw	r30, r16
    11aa:	e0 55       	subi	r30, 0x50	; 80
    11ac:	f9 4f       	sbci	r31, 0xF9	; 249
    11ae:	80 82       	st	Z, r8
    11b0:	27 c0       	rjmp	.+78     	; 0x1200 <Calibrate+0x3ca>
			
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
				if(HIDKey == KEY_DASH){TeachASCIIKey('-', KeyPressed, LOWER); TeachASCIIKey('*', KeyPressed, UPPER);}
    11b2:	2d 32       	cpi	r18, 0x2D	; 45
    11b4:	49 f4       	brne	.+18     	; 0x11c8 <Calibrate+0x392>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    11b6:	f8 01       	movw	r30, r16
    11b8:	e1 5d       	subi	r30, 0xD1	; 209
    11ba:	f8 4f       	sbci	r31, 0xF8	; 248
    11bc:	20 83       	st	Z, r18
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    11be:	f8 01       	movw	r30, r16
    11c0:	e0 55       	subi	r30, 0x50	; 80
    11c2:	f9 4f       	sbci	r31, 0xF9	; 249
    11c4:	a0 82       	st	Z, r10
    11c6:	1c c0       	rjmp	.+56     	; 0x1200 <Calibrate+0x3ca>
			if ( !(Modifier & FN_MODIFIER)) { //if the fn key is not being pressed (sd card doesn't use fn key)
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
				if(HIDKey == KEY_DASH){TeachASCIIKey('-', KeyPressed, LOWER); TeachASCIIKey('*', KeyPressed, UPPER);}
				if(HIDKey == KEY_SLASH){TeachASCIIKey('/', KeyPressed, LOWER);TeachASCIIKey('?', KeyPressed, UPPER);}
    11c8:	28 33       	cpi	r18, 0x38	; 56
    11ca:	29 f4       	brne	.+10     	; 0x11d6 <Calibrate+0x3a0>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    11cc:	f8 01       	movw	r30, r16
    11ce:	e1 5d       	subi	r30, 0xD1	; 209
    11d0:	f8 4f       	sbci	r31, 0xF8	; 248
    11d2:	b0 82       	st	Z, r11
    11d4:	06 c0       	rjmp	.+12     	; 0x11e2 <Calibrate+0x3ac>
				if(HIDKey == HID_KEYBOARD_SC_SEMICOLON_AND_COLON){TeachASCIIKey(';', KeyPressed, LOWER);TeachASCIIKey(':', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
				if(HIDKey == KEY_DASH){TeachASCIIKey('-', KeyPressed, LOWER); TeachASCIIKey('*', KeyPressed, UPPER);}
				if(HIDKey == KEY_SLASH){TeachASCIIKey('/', KeyPressed, LOWER);TeachASCIIKey('?', KeyPressed, UPPER);}
				if(HIDKey == KEY_COMMA){TeachASCIIKey(',', KeyPressed, LOWER); TeachASCIIKey('?', KeyPressed, UPPER);}
    11d6:	26 33       	cpi	r18, 0x36	; 54
    11d8:	49 f4       	brne	.+18     	; 0x11ec <Calibrate+0x3b6>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    11da:	f8 01       	movw	r30, r16
    11dc:	e1 5d       	subi	r30, 0xD1	; 209
    11de:	f8 4f       	sbci	r31, 0xF8	; 248
    11e0:	c0 82       	st	Z, r12
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    11e2:	f8 01       	movw	r30, r16
    11e4:	e0 55       	subi	r30, 0x50	; 80
    11e6:	f9 4f       	sbci	r31, 0xF9	; 249
    11e8:	e0 82       	st	Z, r14
    11ea:	0a c0       	rjmp	.+20     	; 0x1200 <Calibrate+0x3ca>
				if(HIDKey == HID_KEYBOARD_SC_EQUAL_AND_PLUS){TeachASCIIKey('=', KeyPressed, LOWER);TeachASCIIKey('+', KeyPressed, UPPER);}
				if(HIDKey == HID_KEYBOARD_SC_GRAVE_ACCENT_AND_TILDE){TeachASCIIKey('`', KeyPressed, LOWER);TeachASCIIKey('~', KeyPressed, UPPER);}
				if(HIDKey == KEY_DASH){TeachASCIIKey('-', KeyPressed, LOWER); TeachASCIIKey('*', KeyPressed, UPPER);}
				if(HIDKey == KEY_SLASH){TeachASCIIKey('/', KeyPressed, LOWER);TeachASCIIKey('?', KeyPressed, UPPER);}
				if(HIDKey == KEY_COMMA){TeachASCIIKey(',', KeyPressed, LOWER); TeachASCIIKey('?', KeyPressed, UPPER);}
				if(HIDKey == KEY_PERIOD){TeachASCIIKey('.', KeyPressed, LOWER); TeachASCIIKey('.', KeyPressed, UPPER);}
    11ec:	27 33       	cpi	r18, 0x37	; 55
    11ee:	41 f4       	brne	.+16     	; 0x1200 <Calibrate+0x3ca>
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
    11f0:	f8 01       	movw	r30, r16
    11f2:	e1 5d       	subi	r30, 0xD1	; 209
    11f4:	f8 4f       	sbci	r31, 0xF8	; 248
    11f6:	f0 82       	st	Z, r15
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
}

void TeachASCIIKey(char teachkey, int keypressed, char Modifier){
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
    11f8:	f8 01       	movw	r30, r16
    11fa:	e0 55       	subi	r30, 0x50	; 80
    11fc:	f9 4f       	sbci	r31, 0xF9	; 249
    11fe:	f0 82       	st	Z, r15
				if(HIDKey == KEY_PERIOD){TeachASCIIKey('.', KeyPressed, LOWER); TeachASCIIKey('.', KeyPressed, UPPER);}
			}
			
			
				
			USBSend(KEY_ENTER,LOWER);
    1200:	60 e0       	ldi	r22, 0x00	; 0
    1202:	88 e2       	ldi	r24, 0x28	; 40
    1204:	29 87       	std	Y+9, r18	; 0x09
    1206:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
    120a:	29 85       	ldd	r18, Y+9	; 0x09
	}
	Delay_MS(CALIBRATION_DELAY);
	USBSend(KEY_ENTER,LOWER);
	
//----------TEACH SYMBOL KEYS------------	
	for (HIDKey = KEY_DASH; HIDKey <= KEY_SLASH; HIDKey ++){
    120c:	2f 5f       	subi	r18, 0xFF	; 255
    120e:	29 33       	cpi	r18, 0x39	; 57
    1210:	09 f0       	breq	.+2      	; 0x1214 <Calibrate+0x3de>
    1212:	93 cf       	rjmp	.-218    	; 0x113a <Calibrate+0x304>
			USBSend(KEY_ENTER,LOWER);
		}
	}
	
//=======TEACH ARROW KEYS========
uint8_t hid_arrows[] = {HID_KEYBOARD_SC_LEFT_ARROW,HID_KEYBOARD_SC_RIGHT_ARROW,HID_KEYBOARD_SC_UP_ARROW,HID_KEYBOARD_SC_DOWN_ARROW};
    1214:	80 e5       	ldi	r24, 0x50	; 80
    1216:	8d 83       	std	Y+5, r24	; 0x05
    1218:	8f e4       	ldi	r24, 0x4F	; 79
    121a:	8e 83       	std	Y+6, r24	; 0x06
    121c:	82 e5       	ldi	r24, 0x52	; 82
    121e:	8f 83       	std	Y+7, r24	; 0x07
    1220:	81 e5       	ldi	r24, 0x51	; 81
    1222:	88 87       	std	Y+8, r24	; 0x08
uint8_t unicode_arrows[] = {27,26,24,25}; //corresponding unicode for the arrow keys above
    1224:	8b e1       	ldi	r24, 0x1B	; 27
    1226:	89 83       	std	Y+1, r24	; 0x01
    1228:	8a e1       	ldi	r24, 0x1A	; 26
    122a:	8a 83       	std	Y+2, r24	; 0x02
    122c:	88 e1       	ldi	r24, 0x18	; 24
    122e:	8b 83       	std	Y+3, r24	; 0x03
    1230:	89 e1       	ldi	r24, 0x19	; 25
    1232:	8c 83       	std	Y+4, r24	; 0x04
    1234:	8e 01       	movw	r16, r28
    1236:	0f 5f       	subi	r16, 0xFF	; 255
    1238:	1f 4f       	sbci	r17, 0xFF	; 255
    123a:	7e 01       	movw	r14, r28
    123c:	f5 e0       	ldi	r31, 0x05	; 5
    123e:	ef 0e       	add	r14, r31
    1240:	f1 1c       	adc	r15, r1
    1242:	57 01       	movw	r10, r14
	
for(int i=0;i<4;i++){
	USBSendASCII(unicode_arrows[i]);
    1244:	f8 01       	movw	r30, r16
    1246:	81 91       	ld	r24, Z+
    1248:	8f 01       	movw	r16, r30
    124a:	0e 94 0f 2a 	call	0x541e	; 0x541e <USBSendASCII>
	USBSend(KEY_TAB,LOWER);// used to be a colon
    124e:	60 e0       	ldi	r22, 0x00	; 0
    1250:	8b e2       	ldi	r24, 0x2B	; 43
    1252:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
    1256:	99 dc       	rcall	.-1742   	; 0xb8a <WaitForKeypress>
    1258:	6c 01       	movw	r12, r24
	Modifier = GetModifier();
    125a:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
	TeachHIDKey(hid_arrows[i],KeyPressed,Modifier);
    125e:	b6 01       	movw	r22, r12
    1260:	77 27       	eor	r23, r23
    1262:	48 2f       	mov	r20, r24
    1264:	f7 01       	movw	r30, r14
    1266:	81 91       	ld	r24, Z+
    1268:	7f 01       	movw	r14, r30
    126a:	9e dc       	rcall	.-1732   	; 0xba8 <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
    126c:	60 e0       	ldi	r22, 0x00	; 0
    126e:	88 e2       	ldi	r24, 0x28	; 40
    1270:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
//=======TEACH ARROW KEYS========
uint8_t hid_arrows[] = {HID_KEYBOARD_SC_LEFT_ARROW,HID_KEYBOARD_SC_RIGHT_ARROW,HID_KEYBOARD_SC_UP_ARROW,HID_KEYBOARD_SC_DOWN_ARROW};
uint8_t unicode_arrows[] = {27,26,24,25}; //corresponding unicode for the arrow keys above
	
for(int i=0;i<4;i++){
    1274:	0a 15       	cp	r16, r10
    1276:	1b 05       	cpc	r17, r11
    1278:	29 f7       	brne	.-54     	; 0x1244 <Calibrate+0x40e>
}


//-------TEACH VARIOUS UPPER CASE SYMBOLS ---------
	//@ for sd
	USBSend(KEY_2,UPPER);
    127a:	62 e0       	ldi	r22, 0x02	; 2
    127c:	8f e1       	ldi	r24, 0x1F	; 31
    127e:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	USBSendPROGString(Str_SD_Only);
    1282:	8e e6       	ldi	r24, 0x6E	; 110
    1284:	94 e0       	ldi	r25, 0x04	; 4
    1286:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSend(KEY_TAB,LOWER);
    128a:	60 e0       	ldi	r22, 0x00	; 0
    128c:	8b e2       	ldi	r24, 0x2B	; 43
    128e:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
    1292:	7b dc       	rcall	.-1802   	; 0xb8a <WaitForKeypress>
    1294:	18 2f       	mov	r17, r24
	Modifier = GetModifier();
    1296:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
	
		if(Modifier==HID_KEYBOARD_MODIFIER_LEFTSHIFT){
    129a:	82 30       	cpi	r24, 0x02	; 2
    129c:	41 f4       	brne	.+16     	; 0x12ae <Calibrate+0x478>
			USBSendString("SHIFT");
    129e:	86 ee       	ldi	r24, 0xE6	; 230
    12a0:	91 e0       	ldi	r25, 0x01	; 1
    12a2:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
			USBSend(KEY_EQ,UPPER); //send a + sign
    12a6:	62 e0       	ldi	r22, 0x02	; 2
    12a8:	8e e2       	ldi	r24, 0x2E	; 46
    12aa:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
		}
	USBSendNumber(KeyPressed);
    12ae:	81 2f       	mov	r24, r17
    12b0:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    12b4:	60 e0       	ldi	r22, 0x00	; 0
    12b6:	88 e2       	ldi	r24, 0x28	; 40
    12b8:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
    12bc:	ff ef       	ldi	r31, 0xFF	; 255
    12be:	24 e3       	ldi	r18, 0x34	; 52
    12c0:	8c e0       	ldi	r24, 0x0C	; 12
    12c2:	f1 50       	subi	r31, 0x01	; 1
    12c4:	20 40       	sbci	r18, 0x00	; 0
    12c6:	80 40       	sbci	r24, 0x00	; 0
    12c8:	e1 f7       	brne	.-8      	; 0x12c2 <Calibrate+0x48c>
    12ca:	00 c0       	rjmp	.+0      	; 0x12cc <Calibrate+0x496>
    12cc:	00 00       	nop
	
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
	
	//@ for usb
	USBSend(KEY_2,UPPER);
    12ce:	62 e0       	ldi	r22, 0x02	; 2
    12d0:	8f e1       	ldi	r24, 0x1F	; 31
    12d2:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	USBSendPROGString(Str_USB_Only);
    12d6:	80 e5       	ldi	r24, 0x50	; 80
    12d8:	94 e0       	ldi	r25, 0x04	; 4
    12da:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	KeyPressed = WaitForKeypress();
    12de:	55 dc       	rcall	.-1878   	; 0xb8a <WaitForKeypress>
    12e0:	8c 01       	movw	r16, r24
	Modifier = GetModifier();
    12e2:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>

	TeachHIDKey(KEY_2|FORCE_UPPER,KeyPressed,Modifier);
    12e6:	b8 01       	movw	r22, r16
    12e8:	77 27       	eor	r23, r23
    12ea:	48 2f       	mov	r20, r24
    12ec:	8f e9       	ldi	r24, 0x9F	; 159
    12ee:	5c dc       	rcall	.-1864   	; 0xba8 <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
    12f0:	60 e0       	ldi	r22, 0x00	; 0
    12f2:	88 e2       	ldi	r24, 0x28	; 40
    12f4:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
	//?
	USBSend(KEY_SLASH,UPPER);
    12f8:	62 e0       	ldi	r22, 0x02	; 2
    12fa:	88 e3       	ldi	r24, 0x38	; 56
    12fc:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	USBSendPROGString(Str_SD_Only);
    1300:	8e e6       	ldi	r24, 0x6E	; 110
    1302:	94 e0       	ldi	r25, 0x04	; 4
    1304:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSend(KEY_TAB,LOWER);
    1308:	60 e0       	ldi	r22, 0x00	; 0
    130a:	8b e2       	ldi	r24, 0x2B	; 43
    130c:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
    1310:	3c dc       	rcall	.-1928   	; 0xb8a <WaitForKeypress>
    1312:	8c 01       	movw	r16, r24
	Modifier = GetModifier();
    1314:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
    1318:	f8 2e       	mov	r15, r24
	TeachASCIIKey('?',KeyPressed,Modifier);
    131a:	b8 01       	movw	r22, r16
    131c:	77 27       	eor	r23, r23
    131e:	48 2f       	mov	r20, r24
    1320:	8f e3       	ldi	r24, 0x3F	; 63
    1322:	7c dd       	rcall	.-1288   	; 0xe1c <TeachASCIIKey>
	if(Modifier==HID_KEYBOARD_MODIFIER_LEFTSHIFT){
    1324:	92 e0       	ldi	r25, 0x02	; 2
    1326:	f9 12       	cpse	r15, r25
    1328:	08 c0       	rjmp	.+16     	; 0x133a <Calibrate+0x504>
		USBSendString("SHIFT");
    132a:	86 ee       	ldi	r24, 0xE6	; 230
    132c:	91 e0       	ldi	r25, 0x01	; 1
    132e:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
		USBSend(KEY_EQ,UPPER); //send a + sign
    1332:	62 e0       	ldi	r22, 0x02	; 2
    1334:	8e e2       	ldi	r24, 0x2E	; 46
    1336:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	}
	USBSendNumber(KeyPressed);
    133a:	80 2f       	mov	r24, r16
    133c:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    1340:	60 e0       	ldi	r22, 0x00	; 0
    1342:	88 e2       	ldi	r24, 0x28	; 40
    1344:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
    1348:	ef ef       	ldi	r30, 0xFF	; 255
    134a:	f4 e3       	ldi	r31, 0x34	; 52
    134c:	2c e0       	ldi	r18, 0x0C	; 12
    134e:	e1 50       	subi	r30, 0x01	; 1
    1350:	f0 40       	sbci	r31, 0x00	; 0
    1352:	20 40       	sbci	r18, 0x00	; 0
    1354:	e1 f7       	brne	.-8      	; 0x134e <Calibrate+0x518>
    1356:	00 c0       	rjmp	.+0      	; 0x1358 <Calibrate+0x522>
    1358:	00 00       	nop
	
	Delay_MS(CALIBRATION_DELAY);//delay between programming keys.
	
//for USB

	USBSend(KEY_SLASH,UPPER);
    135a:	62 e0       	ldi	r22, 0x02	; 2
    135c:	88 e3       	ldi	r24, 0x38	; 56
    135e:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	USBSendPROGString(Str_USB_Only);
    1362:	80 e5       	ldi	r24, 0x50	; 80
    1364:	94 e0       	ldi	r25, 0x04	; 4
    1366:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	KeyPressed = WaitForKeypress();
    136a:	0f dc       	rcall	.-2018   	; 0xb8a <WaitForKeypress>
    136c:	8c 01       	movw	r16, r24
	Modifier = GetModifier();
    136e:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>

	TeachHIDKey(KEY_SLASH|FORCE_UPPER,KeyPressed,Modifier);
    1372:	b8 01       	movw	r22, r16
    1374:	77 27       	eor	r23, r23
    1376:	48 2f       	mov	r20, r24
    1378:	88 eb       	ldi	r24, 0xB8	; 184
    137a:	16 dc       	rcall	.-2004   	; 0xba8 <TeachHIDKey>
	USBSend(KEY_ENTER,LOWER);
    137c:	60 e0       	ldi	r22, 0x00	; 0
    137e:	88 e2       	ldi	r24, 0x28	; 40
    1380:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
	//!
	USBSend(KEY_1|FORCE_UPPER,UPPER);
    1384:	62 e0       	ldi	r22, 0x02	; 2
    1386:	8e e9       	ldi	r24, 0x9E	; 158
    1388:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	USBSend(KEY_TAB,LOWER);
    138c:	60 e0       	ldi	r22, 0x00	; 0
    138e:	8b e2       	ldi	r24, 0x2B	; 43
    1390:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	KeyPressed = WaitForKeypress();
    1394:	fa db       	rcall	.-2060   	; 0xb8a <WaitForKeypress>
    1396:	8c 01       	movw	r16, r24
	Modifier = GetModifier();
    1398:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
    139c:	f8 2e       	mov	r15, r24

	if(!(Modifier&FN_MODIFIER&UPPER)){ //don't bother dealing with complicated combinations of FN and Shift to produce an !
		TeachHIDKey(KEY_1|FORCE_UPPER,KeyPressed,Modifier);
    139e:	11 27       	eor	r17, r17
    13a0:	48 2f       	mov	r20, r24
    13a2:	b8 01       	movw	r22, r16
    13a4:	8e e9       	ldi	r24, 0x9E	; 158
    13a6:	00 dc       	rcall	.-2048   	; 0xba8 <TeachHIDKey>
		TeachASCIIKey('!',KeyPressed,Modifier);
    13a8:	4f 2d       	mov	r20, r15
    13aa:	b8 01       	movw	r22, r16
    13ac:	81 e2       	ldi	r24, 0x21	; 33
    13ae:	36 dd       	rcall	.-1428   	; 0xe1c <TeachASCIIKey>
	}
	 
	USBSend(KEY_ENTER,LOWER);
    13b0:	60 e0       	ldi	r22, 0x00	; 0
    13b2:	88 e2       	ldi	r24, 0x28	; 40
    13b4:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	
	
//------TEACH REED SWITCHES--------//
	CalibrateReeds();
    13b8:	2c dc       	rcall	.-1960   	; 0xc12 <CalibrateReeds>
	
	SaveCalibration();
    13ba:	40 db       	rcall	.-2432   	; 0xa3c <SaveCalibration>
	
	USBSendPROGString(Str_Settings_Saved);
    13bc:	81 e6       	ldi	r24, 0x61	; 97
    13be:	92 e0       	ldi	r25, 0x02	; 2
	
}
    13c0:	29 96       	adiw	r28, 0x09	; 9
    13c2:	0f b6       	in	r0, 0x3f	; 63
    13c4:	f8 94       	cli
    13c6:	de bf       	out	0x3e, r29	; 62
    13c8:	0f be       	out	0x3f, r0	; 63
    13ca:	cd bf       	out	0x3d, r28	; 61
    13cc:	df 91       	pop	r29
    13ce:	cf 91       	pop	r28
    13d0:	1f 91       	pop	r17
    13d2:	0f 91       	pop	r16
    13d4:	ff 90       	pop	r15
    13d6:	ef 90       	pop	r14
    13d8:	df 90       	pop	r13
    13da:	cf 90       	pop	r12
    13dc:	bf 90       	pop	r11
    13de:	af 90       	pop	r10
    13e0:	9f 90       	pop	r9
    13e2:	8f 90       	pop	r8
    13e4:	7f 90       	pop	r7
    13e6:	6f 90       	pop	r6
    13e8:	5f 90       	pop	r5
//------TEACH REED SWITCHES--------//
	CalibrateReeds();
	
	SaveCalibration();
	
	USBSendPROGString(Str_Settings_Saved);
    13ea:	0c 94 c1 29 	jmp	0x5382	; 0x5382 <USBSendPROGString>

000013ee <Adjust_Sensitivity>:
	else{
		ASCIILookUpTable[keypressed] = teachkey;
	}
}

void Adjust_Sensitivity(){
    13ee:	cf 93       	push	r28
	KeyHoldTime = eeprom_read_byte((uint8_t*)HOLD_TIME_ADDR);
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	92 e0       	ldi	r25, 0x02	; 2
    13f4:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    13f8:	80 93 af 06 	sts	0x06AF, r24
	KeyReleaseTime = eeprom_read_byte((uint8_t*)RELEASE_TIME_ADDR);
    13fc:	82 e0       	ldi	r24, 0x02	; 2
    13fe:	92 e0       	ldi	r25, 0x02	; 2
    1400:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    1404:	80 93 20 06 	sts	0x0620, r24
	DoubleTapTime= eeprom_read_byte((uint8_t*)DOUBLE_TAP_ADDR);
    1408:	80 e0       	ldi	r24, 0x00	; 0
    140a:	92 e0       	ldi	r25, 0x02	; 2
    140c:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    1410:	80 93 63 06 	sts	0x0663, r24
	
	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
    1414:	80 91 b4 09 	lds	r24, 0x09B4
    1418:	84 30       	cpi	r24, 0x04	; 4
    141a:	e1 f7       	brne	.-8      	; 0x1414 <Adjust_Sensitivity+0x26>
    141c:	2f ef       	ldi	r18, 0xFF	; 255
    141e:	89 e6       	ldi	r24, 0x69	; 105
    1420:	98 e1       	ldi	r25, 0x18	; 24
    1422:	21 50       	subi	r18, 0x01	; 1
    1424:	80 40       	sbci	r24, 0x00	; 0
    1426:	90 40       	sbci	r25, 0x00	; 0
    1428:	e1 f7       	brne	.-8      	; 0x1422 <Adjust_Sensitivity+0x34>
    142a:	00 c0       	rjmp	.+0      	; 0x142c <Adjust_Sensitivity+0x3e>
    142c:	00 00       	nop
	Delay_MS(1000);//wait 1 second.
	
	USBSendPROGString(Str_Adj_Sensitivity);
    142e:	86 e5       	ldi	r24, 0x56	; 86
    1430:	93 e0       	ldi	r25, 0x03	; 3
    1432:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSendPROGString(Str_Press_CMD);
    1436:	88 e3       	ldi	r24, 0x38	; 56
    1438:	93 e0       	ldi	r25, 0x03	; 3
    143a:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	while(is_high(S3)){;}
    143e:	7e 99       	sbic	0x0f, 6	; 15
    1440:	fe cf       	rjmp	.-4      	; 0x143e <Adjust_Sensitivity+0x50>
	
	USBSendPROGString(Str_Set_Reaction_Time);
    1442:	88 e0       	ldi	r24, 0x08	; 8
    1444:	93 e0       	ldi	r25, 0x03	; 3
    1446:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSendNumber(KeyHoldTime);
    144a:	80 91 af 06 	lds	r24, 0x06AF
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
		if(is_low(S1)){KeyHoldTime++;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){KeyHoldTime--;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
    144e:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
    1452:	60 e0       	ldi	r22, 0x00	; 0
    1454:	88 e2       	ldi	r24, 0x28	; 40
    1456:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	while(is_high(S3)){;}
	
	USBSendPROGString(Str_Set_Reaction_Time);
	USBSendNumber(KeyHoldTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    145a:	7e 9b       	sbis	0x0f, 6	; 15
    145c:	15 c0       	rjmp	.+42     	; 0x1488 <Adjust_Sensitivity+0x9a>
		if(is_low(S1)){KeyHoldTime++;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
    145e:	7c 99       	sbic	0x0f, 4	; 15
    1460:	0b c0       	rjmp	.+22     	; 0x1478 <Adjust_Sensitivity+0x8a>
    1462:	80 91 af 06 	lds	r24, 0x06AF
    1466:	8f 5f       	subi	r24, 0xFF	; 255
    1468:	80 93 af 06 	sts	0x06AF, r24
    146c:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
    1470:	60 e0       	ldi	r22, 0x00	; 0
    1472:	88 e2       	ldi	r24, 0x28	; 40
    1474:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
		if(is_low(S2)){KeyHoldTime--;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
    1478:	7d 99       	sbic	0x0f, 5	; 15
    147a:	ef cf       	rjmp	.-34     	; 0x145a <Adjust_Sensitivity+0x6c>
    147c:	80 91 af 06 	lds	r24, 0x06AF
    1480:	81 50       	subi	r24, 0x01	; 1
    1482:	80 93 af 06 	sts	0x06AF, r24
    1486:	e3 cf       	rjmp	.-58     	; 0x144e <Adjust_Sensitivity+0x60>
	}
	
	USBSendPROGString(Str_Set_Release_Time);
    1488:	8a ee       	ldi	r24, 0xEA	; 234
    148a:	92 e0       	ldi	r25, 0x02	; 2
    148c:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSendNumber(KeyReleaseTime);
    1490:	80 91 20 06 	lds	r24, 0x0620
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
		if(is_low(S1)){KeyReleaseTime++;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){KeyReleaseTime--;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
    1494:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
    1498:	60 e0       	ldi	r22, 0x00	; 0
    149a:	88 e2       	ldi	r24, 0x28	; 40
    149c:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	}
	
	USBSendPROGString(Str_Set_Release_Time);
	USBSendNumber(KeyReleaseTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    14a0:	7e 9b       	sbis	0x0f, 6	; 15
    14a2:	15 c0       	rjmp	.+42     	; 0x14ce <Adjust_Sensitivity+0xe0>
		if(is_low(S1)){KeyReleaseTime++;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
    14a4:	7c 99       	sbic	0x0f, 4	; 15
    14a6:	0b c0       	rjmp	.+22     	; 0x14be <Adjust_Sensitivity+0xd0>
    14a8:	80 91 20 06 	lds	r24, 0x0620
    14ac:	8f 5f       	subi	r24, 0xFF	; 255
    14ae:	80 93 20 06 	sts	0x0620, r24
    14b2:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
    14b6:	60 e0       	ldi	r22, 0x00	; 0
    14b8:	88 e2       	ldi	r24, 0x28	; 40
    14ba:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
		if(is_low(S2)){KeyReleaseTime--;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
    14be:	7d 99       	sbic	0x0f, 5	; 15
    14c0:	ef cf       	rjmp	.-34     	; 0x14a0 <Adjust_Sensitivity+0xb2>
    14c2:	80 91 20 06 	lds	r24, 0x0620
    14c6:	81 50       	subi	r24, 0x01	; 1
    14c8:	80 93 20 06 	sts	0x0620, r24
    14cc:	e3 cf       	rjmp	.-58     	; 0x1494 <Adjust_Sensitivity+0xa6>
	}
	
	USBSendPROGString(Str_Set_Double_Time);
    14ce:	8c eb       	ldi	r24, 0xBC	; 188
    14d0:	92 e0       	ldi	r25, 0x02	; 2
    14d2:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSendNumber(DoubleTapTime);
    14d6:	80 91 63 06 	lds	r24, 0x0663
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
		if(is_low(S1)){DoubleTapTime++;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){DoubleTapTime--;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
    14da:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
    14de:	60 e0       	ldi	r22, 0x00	; 0
    14e0:	88 e2       	ldi	r24, 0x28	; 40
    14e2:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	}
	
	USBSendPROGString(Str_Set_Double_Time);
	USBSendNumber(DoubleTapTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    14e6:	7e 9b       	sbis	0x0f, 6	; 15
    14e8:	15 c0       	rjmp	.+42     	; 0x1514 <Adjust_Sensitivity+0x126>
		if(is_low(S1)){DoubleTapTime++;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
    14ea:	7c 99       	sbic	0x0f, 4	; 15
    14ec:	0b c0       	rjmp	.+22     	; 0x1504 <Adjust_Sensitivity+0x116>
    14ee:	80 91 63 06 	lds	r24, 0x0663
    14f2:	8f 5f       	subi	r24, 0xFF	; 255
    14f4:	80 93 63 06 	sts	0x0663, r24
    14f8:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
    14fc:	60 e0       	ldi	r22, 0x00	; 0
    14fe:	88 e2       	ldi	r24, 0x28	; 40
    1500:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
		if(is_low(S2)){DoubleTapTime--;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
    1504:	7d 99       	sbic	0x0f, 5	; 15
    1506:	ef cf       	rjmp	.-34     	; 0x14e6 <Adjust_Sensitivity+0xf8>
    1508:	80 91 63 06 	lds	r24, 0x0663
    150c:	81 50       	subi	r24, 0x01	; 1
    150e:	80 93 63 06 	sts	0x0663, r24
    1512:	e3 cf       	rjmp	.-58     	; 0x14da <Adjust_Sensitivity+0xec>
	}
	
	USBSendPROGString(Str_Set_Reed_Time);
    1514:	8c e9       	ldi	r24, 0x9C	; 156
    1516:	92 e0       	ldi	r25, 0x02	; 2
    1518:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSendNumber(ReedHoldTime);
    151c:	80 91 62 06 	lds	r24, 0x0662
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
		if(is_low(S1)){ReedHoldTime++;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
    1520:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
    1524:	60 e0       	ldi	r22, 0x00	; 0
    1526:	88 e2       	ldi	r24, 0x28	; 40
    1528:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	}
	
	USBSendPROGString(Str_Set_Reed_Time);
	USBSendNumber(ReedHoldTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    152c:	7e 9b       	sbis	0x0f, 6	; 15
    152e:	15 c0       	rjmp	.+42     	; 0x155a <Adjust_Sensitivity+0x16c>
		if(is_low(S1)){ReedHoldTime++;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
    1530:	7c 99       	sbic	0x0f, 4	; 15
    1532:	0b c0       	rjmp	.+22     	; 0x154a <Adjust_Sensitivity+0x15c>
    1534:	80 91 62 06 	lds	r24, 0x0662
    1538:	8f 5f       	subi	r24, 0xFF	; 255
    153a:	80 93 62 06 	sts	0x0662, r24
    153e:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
    1542:	60 e0       	ldi	r22, 0x00	; 0
    1544:	88 e2       	ldi	r24, 0x28	; 40
    1546:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
    154a:	7d 99       	sbic	0x0f, 5	; 15
    154c:	ef cf       	rjmp	.-34     	; 0x152c <Adjust_Sensitivity+0x13e>
    154e:	80 91 62 06 	lds	r24, 0x0662
    1552:	81 50       	subi	r24, 0x01	; 1
    1554:	80 93 62 06 	sts	0x0662, r24
    1558:	e3 cf       	rjmp	.-58     	; 0x1520 <Adjust_Sensitivity+0x132>
	}	
	
	USBSendPROGString(Str_Spacebar_Blocks_Enter);
    155a:	82 e7       	ldi	r24, 0x72	; 114
    155c:	92 e0       	ldi	r25, 0x02	; 2
    155e:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	Reeds_Are_Independent ? USBSendString("NO\r") : USBSendString("YES\r");
    1562:	80 91 1e 06 	lds	r24, 0x061E
    1566:	88 23       	and	r24, r24
    1568:	19 f0       	breq	.+6      	; 0x1570 <Adjust_Sensitivity+0x182>
    156a:	8d ef       	ldi	r24, 0xFD	; 253
    156c:	91 e0       	ldi	r25, 0x01	; 1
    156e:	02 c0       	rjmp	.+4      	; 0x1574 <Adjust_Sensitivity+0x186>
    1570:	81 e0       	ldi	r24, 0x01	; 1
    1572:	92 e0       	ldi	r25, 0x02	; 2
    1574:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
	while(is_high(S3)){
		if(is_low(S1)){Reeds_Are_Independent = false; USBSendString("YES\r");}
		if(is_low(S2)){Reeds_Are_Independent = true; USBSendString("NO\r");}
    1578:	c1 e0       	ldi	r28, 0x01	; 1
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
	}	
	
	USBSendPROGString(Str_Spacebar_Blocks_Enter);
	Reeds_Are_Independent ? USBSendString("NO\r") : USBSendString("YES\r");
	while(is_high(S3)){
    157a:	7e 9b       	sbis	0x0f, 6	; 15
    157c:	15 c0       	rjmp	.+42     	; 0x15a8 <Adjust_Sensitivity+0x1ba>
		if(is_low(S1)){Reeds_Are_Independent = false; USBSendString("YES\r");}
    157e:	7c 99       	sbic	0x0f, 4	; 15
    1580:	06 c0       	rjmp	.+12     	; 0x158e <Adjust_Sensitivity+0x1a0>
    1582:	10 92 1e 06 	sts	0x061E, r1
    1586:	81 e0       	ldi	r24, 0x01	; 1
    1588:	92 e0       	ldi	r25, 0x02	; 2
    158a:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
		if(is_low(S2)){Reeds_Are_Independent = true; USBSendString("NO\r");}
    158e:	7d 99       	sbic	0x0f, 5	; 15
    1590:	06 c0       	rjmp	.+12     	; 0x159e <Adjust_Sensitivity+0x1b0>
    1592:	c0 93 1e 06 	sts	0x061E, r28
    1596:	8d ef       	ldi	r24, 0xFD	; 253
    1598:	91 e0       	ldi	r25, 0x01	; 1
    159a:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
		while(is_low(S1)||is_low(S2)){;}//wait until one of the switches is released before looping.
    159e:	7c 9b       	sbis	0x0f, 4	; 15
    15a0:	fe cf       	rjmp	.-4      	; 0x159e <Adjust_Sensitivity+0x1b0>
    15a2:	7d 9b       	sbis	0x0f, 5	; 15
    15a4:	fc cf       	rjmp	.-8      	; 0x159e <Adjust_Sensitivity+0x1b0>
    15a6:	e9 cf       	rjmp	.-46     	; 0x157a <Adjust_Sensitivity+0x18c>
	}
	
	eeprom_update_byte((uint8_t*)DOUBLE_TAP_ADDR,DoubleTapTime);
    15a8:	60 91 63 06 	lds	r22, 0x0663
    15ac:	80 e0       	ldi	r24, 0x00	; 0
    15ae:	92 e0       	ldi	r25, 0x02	; 2
    15b0:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)RELEASE_TIME_ADDR,KeyReleaseTime);
    15b4:	60 91 20 06 	lds	r22, 0x0620
    15b8:	82 e0       	ldi	r24, 0x02	; 2
    15ba:	92 e0       	ldi	r25, 0x02	; 2
    15bc:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)HOLD_TIME_ADDR,KeyHoldTime);
    15c0:	60 91 af 06 	lds	r22, 0x06AF
    15c4:	81 e0       	ldi	r24, 0x01	; 1
    15c6:	92 e0       	ldi	r25, 0x02	; 2
    15c8:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)REED_HOLD_TIME_ADDR,ReedHoldTime);
    15cc:	60 91 62 06 	lds	r22, 0x0662
    15d0:	8c e0       	ldi	r24, 0x0C	; 12
    15d2:	92 e0       	ldi	r25, 0x02	; 2
    15d4:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)REEDS_INDEPENDENT_ADDR,Reeds_Are_Independent);
    15d8:	60 91 1e 06 	lds	r22, 0x061E
    15dc:	8e e0       	ldi	r24, 0x0E	; 14
    15de:	92 e0       	ldi	r25, 0x02	; 2
    15e0:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
	
	USBSendPROGString(Str_Settings_Saved);
    15e4:	81 e6       	ldi	r24, 0x61	; 97
    15e6:	92 e0       	ldi	r25, 0x02	; 2
}
    15e8:	cf 91       	pop	r28
	eeprom_update_byte((uint8_t*)RELEASE_TIME_ADDR,KeyReleaseTime);
	eeprom_update_byte((uint8_t*)HOLD_TIME_ADDR,KeyHoldTime);
	eeprom_update_byte((uint8_t*)REED_HOLD_TIME_ADDR,ReedHoldTime);
	eeprom_update_byte((uint8_t*)REEDS_INDEPENDENT_ADDR,Reeds_Are_Independent);
	
	USBSendPROGString(Str_Settings_Saved);
    15ea:	0c 94 c1 29 	jmp	0x5382	; 0x5382 <USBSendPROGString>

000015ee <Get_User_Response>:
}

char Get_User_Response(){
	uint8_t code;
	while(1){
		code = WaitForKeypress();
    15ee:	cd da       	rcall	.-2662   	; 0xb8a <WaitForKeypress>
		if ((ASCIILookUpTable[code]	== 'u')||(ASCIILookUpTable[code]	== 's')){
    15f0:	fc 01       	movw	r30, r24
    15f2:	ff 27       	eor	r31, r31
    15f4:	e1 5d       	subi	r30, 0xD1	; 209
    15f6:	f8 4f       	sbci	r31, 0xF8	; 248
    15f8:	80 81       	ld	r24, Z
    15fa:	85 37       	cpi	r24, 0x75	; 117
    15fc:	11 f0       	breq	.+4      	; 0x1602 <Get_User_Response+0x14>
    15fe:	83 37       	cpi	r24, 0x73	; 115
    1600:	b1 f7       	brne	.-20     	; 0x15ee <Get_User_Response>
			break;
		}
	}
	return ASCIILookUpTable[code];
}
    1602:	08 95       	ret

00001604 <Calibrate_Manually>:
		USBSendASCII(code);\
	}\
}


void Calibrate_Manually(){
    1604:	9f 92       	push	r9
    1606:	af 92       	push	r10
    1608:	bf 92       	push	r11
    160a:	cf 92       	push	r12
    160c:	df 92       	push	r13
    160e:	ef 92       	push	r14
    1610:	ff 92       	push	r15
    1612:	0f 93       	push	r16
    1614:	1f 93       	push	r17
    1616:	cf 93       	push	r28
    1618:	df 93       	push	r29
	uint8_t codeend2;
	uint8_t keypressed;
	uint8_t modifier;
	char edit_mode = 's';
	
	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
    161a:	80 91 b4 09 	lds	r24, 0x09B4
    161e:	84 30       	cpi	r24, 0x04	; 4
    1620:	e1 f7       	brne	.-8      	; 0x161a <Calibrate_Manually+0x16>
    1622:	2f ef       	ldi	r18, 0xFF	; 255
    1624:	89 e6       	ldi	r24, 0x69	; 105
    1626:	98 e1       	ldi	r25, 0x18	; 24
    1628:	21 50       	subi	r18, 0x01	; 1
    162a:	80 40       	sbci	r24, 0x00	; 0
    162c:	90 40       	sbci	r25, 0x00	; 0
    162e:	e1 f7       	brne	.-8      	; 0x1628 <Calibrate_Manually+0x24>
    1630:	00 c0       	rjmp	.+0      	; 0x1632 <Calibrate_Manually+0x2e>
    1632:	00 00       	nop
	Delay_MS(1000);
		
	//tell user what is up
	USBSendPROGString(Str_Manual_Calibration);
    1634:	85 e4       	ldi	r24, 0x45	; 69
    1636:	92 e0       	ldi	r25, 0x02	; 2
    1638:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSendPROGString(Str_U_For_USB);
    163c:	84 e1       	ldi	r24, 0x14	; 20
    163e:	92 e0       	ldi	r25, 0x02	; 2
    1640:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSendPROGString(Str_S_For_SD);
    1644:	87 ee       	ldi	r24, 0xE7	; 231
    1646:	91 e0       	ldi	r25, 0x01	; 1
    1648:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	edit_mode = Get_User_Response();
    164c:	d0 df       	rcall	.-96     	; 0x15ee <Get_User_Response>
    164e:	08 2f       	mov	r16, r24
	USBSendString("OK\r");
    1650:	86 e0       	ldi	r24, 0x06	; 6
    1652:	92 e0       	ldi	r25, 0x02	; 2
    1654:	0e 94 42 29 	call	0x5284	; 0x5284 <USBSendString>
	USBSendPROGString(Str_How_To_Scroll);
    1658:	89 eb       	ldi	r24, 0xB9	; 185
    165a:	91 e0       	ldi	r25, 0x01	; 1
    165c:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSendPROGString(Str_How_To_Scroll_Back);
    1660:	8f e8       	ldi	r24, 0x8F	; 143
    1662:	91 e0       	ldi	r25, 0x01	; 1
    1664:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	USBSendPROGString(Str_How_To_Exit);
    1668:	81 e6       	ldi	r24, 0x61	; 97
    166a:	91 e0       	ldi	r25, 0x01	; 1
    166c:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
	
	//set ranges of ascii/hid codes over which to calibrate.  there are two ranges.
	if(edit_mode == 'u'){
    1670:	05 37       	cpi	r16, 0x75	; 117
    1672:	09 f0       	breq	.+2      	; 0x1676 <Calibrate_Manually+0x72>
    1674:	29 c1       	rjmp	.+594    	; 0x18c8 <Calibrate_Manually+0x2c4>
		codestart2 = 153;
		codeend2 = 0xFF;
	}
	
	code = codestart1;
	if (edit_mode == 'u'){USBSend(code,LOWER);}
    1676:	60 e0       	ldi	r22, 0x00	; 0
    1678:	8d e2       	ldi	r24, 0x2D	; 45
    167a:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
	//set ranges of ascii/hid codes over which to calibrate.  there are two ranges.
	if(edit_mode == 'u'){
		codestart1 = 0x2D;
		codeend1 = 0x38;
		codestart2 = 0x1E|FORCE_UPPER;
		codeend2 = 0x38|FORCE_UPPER;
    167e:	98 eb       	ldi	r25, 0xB8	; 184
    1680:	99 2e       	mov	r9, r25
	
	//set ranges of ascii/hid codes over which to calibrate.  there are two ranges.
	if(edit_mode == 'u'){
		codestart1 = 0x2D;
		codeend1 = 0x38;
		codestart2 = 0x1E|FORCE_UPPER;
    1682:	1e e9       	ldi	r17, 0x9E	; 158
	USBSendPROGString(Str_How_To_Exit);
	
	//set ranges of ascii/hid codes over which to calibrate.  there are two ranges.
	if(edit_mode == 'u'){
		codestart1 = 0x2D;
		codeend1 = 0x38;
    1684:	28 e3       	ldi	r18, 0x38	; 56
    1686:	e2 2e       	mov	r14, r18
	USBSendPROGString(Str_How_To_Scroll_Back);
	USBSendPROGString(Str_How_To_Exit);
	
	//set ranges of ascii/hid codes over which to calibrate.  there are two ranges.
	if(edit_mode == 'u'){
		codestart1 = 0x2D;
    1688:	dd e2       	ldi	r29, 0x2D	; 45
    168a:	cd 2f       	mov	r28, r29
	code = codestart1;
	if (edit_mode == 'u'){USBSend(code,LOWER);}
	else {USBSendASCII(code);}
	
	while(1){			
			keypressed = WaitForKeypress();
    168c:	7e da       	rcall	.-2820   	; 0xb8a <WaitForKeypress>
    168e:	5c 01       	movw	r10, r24
			modifier = GetModifier();
    1690:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
    1694:	f8 2e       	mov	r15, r24
			if(KeyCodeLookUpTable[keypressed]!=KEY_SPACE){//if the key pressed is not spacebar, program the code -- otherwise skip to next line
    1696:	65 01       	movw	r12, r10
    1698:	dd 24       	eor	r13, r13
    169a:	f6 01       	movw	r30, r12
    169c:	ee 5d       	subi	r30, 0xDE	; 222
    169e:	f9 4f       	sbci	r31, 0xF9	; 249
    16a0:	80 81       	ld	r24, Z
    16a2:	8c 32       	cpi	r24, 0x2C	; 44
    16a4:	09 f4       	brne	.+2      	; 0x16a8 <Calibrate_Manually+0xa4>
    16a6:	71 c0       	rjmp	.+226    	; 0x178a <Calibrate_Manually+0x186>
				if (edit_mode == 'u'){
    16a8:	05 37       	cpi	r16, 0x75	; 117
    16aa:	29 f4       	brne	.+10     	; 0x16b6 <Calibrate_Manually+0xb2>
					TeachHIDKey(code,keypressed,modifier);
    16ac:	4f 2d       	mov	r20, r15
    16ae:	b6 01       	movw	r22, r12
    16b0:	8c 2f       	mov	r24, r28
    16b2:	7a da       	rcall	.-2828   	; 0xba8 <TeachHIDKey>
    16b4:	19 c0       	rjmp	.+50     	; 0x16e8 <Calibrate_Manually+0xe4>
				}
				else if (edit_mode=='s'){
    16b6:	03 37       	cpi	r16, 0x73	; 115
    16b8:	b9 f4       	brne	.+46     	; 0x16e8 <Calibrate_Manually+0xe4>
					TeachASCIIKey(code,keypressed,modifier);
    16ba:	4f 2d       	mov	r20, r15
    16bc:	b6 01       	movw	r22, r12
    16be:	8c 2f       	mov	r24, r28
    16c0:	ad db       	rcall	.-2214   	; 0xe1c <TeachASCIIKey>
					if(modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT){USBSendPROGString(Str_Shift_Plus);}
    16c2:	f1 fe       	sbrs	r15, 1
    16c4:	04 c0       	rjmp	.+8      	; 0x16ce <Calibrate_Manually+0xca>
    16c6:	8a e5       	ldi	r24, 0x5A	; 90
    16c8:	91 e0       	ldi	r25, 0x01	; 1
    16ca:	0e 94 c1 29 	call	0x5382	; 0x5382 <USBSendPROGString>
					USBSendNumber(keypressed);
    16ce:	8a 2d       	mov	r24, r10
    16d0:	0e 94 c9 29 	call	0x5392	; 0x5392 <USBSendNumber>
					if((code >= 'a') && (code <='z')){
    16d4:	8f e9       	ldi	r24, 0x9F	; 159
    16d6:	8c 0f       	add	r24, r28
    16d8:	8a 31       	cpi	r24, 0x1A	; 26
    16da:	30 f4       	brcc	.+12     	; 0x16e8 <Calibrate_Manually+0xe4>
						TeachASCIIKey(code-'a'+'A',keypressed,modifier|HID_KEYBOARD_MODIFIER_LEFTSHIFT);//program upper case letters too
    16dc:	4f 2d       	mov	r20, r15
    16de:	42 60       	ori	r20, 0x02	; 2
    16e0:	b6 01       	movw	r22, r12
    16e2:	80 ee       	ldi	r24, 0xE0	; 224
    16e4:	8c 0f       	add	r24, r28
    16e6:	9a db       	rcall	.-2252   	; 0xe1c <TeachASCIIKey>
					}
				}
			INCREMENT_CODE();			
    16e8:	cf 5f       	subi	r28, 0xFF	; 255
    16ea:	41 f0       	breq	.+16     	; 0x16fc <Calibrate_Manually+0xf8>
    16ec:	9c 16       	cp	r9, r28
    16ee:	30 f0       	brcs	.+12     	; 0x16fc <Calibrate_Manually+0xf8>
    16f0:	ec 16       	cp	r14, r28
    16f2:	28 f4       	brcc	.+10     	; 0x16fe <Calibrate_Manually+0xfa>
    16f4:	c1 17       	cp	r28, r17
    16f6:	18 f4       	brcc	.+6      	; 0x16fe <Calibrate_Manually+0xfa>
    16f8:	c1 2f       	mov	r28, r17
    16fa:	01 c0       	rjmp	.+2      	; 0x16fe <Calibrate_Manually+0xfa>
    16fc:	cd 2f       	mov	r28, r29
    16fe:	60 e0       	ldi	r22, 0x00	; 0
    1700:	88 e2       	ldi	r24, 0x28	; 40
    1702:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
    1706:	05 37       	cpi	r16, 0x75	; 117
    1708:	61 f4       	brne	.+24     	; 0x1722 <Calibrate_Manually+0x11e>
    170a:	8c 2f       	mov	r24, r28
    170c:	80 68       	ori	r24, 0x80	; 128
    170e:	88 5a       	subi	r24, 0xA8	; 168
    1710:	85 30       	cpi	r24, 0x05	; 5
    1712:	10 f4       	brcc	.+4      	; 0x1718 <Calibrate_Manually+0x114>
    1714:	cf 5f       	subi	r28, 0xFF	; 255
    1716:	f9 cf       	rjmp	.-14     	; 0x170a <Calibrate_Manually+0x106>
    1718:	60 e0       	ldi	r22, 0x00	; 0
    171a:	8c 2f       	mov	r24, r28
    171c:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
    1720:	2a c0       	rjmp	.+84     	; 0x1776 <Calibrate_Manually+0x172>
    1722:	c1 34       	cpi	r28, 0x41	; 65
    1724:	21 f0       	breq	.+8      	; 0x172e <Calibrate_Manually+0x12a>
    1726:	c0 33       	cpi	r28, 0x30	; 48
    1728:	39 f4       	brne	.+14     	; 0x1738 <Calibrate_Manually+0x134>
    172a:	ca e3       	ldi	r28, 0x3A	; 58
    172c:	05 c0       	rjmp	.+10     	; 0x1738 <Calibrate_Manually+0x134>
    172e:	cb e5       	ldi	r28, 0x5B	; 91
    1730:	03 c0       	rjmp	.+6      	; 0x1738 <Calibrate_Manually+0x134>
    1732:	c4 38       	cpi	r28, 0x84	; 132
    1734:	31 f4       	brne	.+12     	; 0x1742 <Calibrate_Manually+0x13e>
    1736:	cf 5f       	subi	r28, 0xFF	; 255
    1738:	8f e7       	ldi	r24, 0x7F	; 127
    173a:	8c 0f       	add	r24, r28
    173c:	82 30       	cpi	r24, 0x02	; 2
    173e:	c8 f7       	brcc	.-14     	; 0x1732 <Calibrate_Manually+0x12e>
    1740:	fa cf       	rjmp	.-12     	; 0x1736 <Calibrate_Manually+0x132>
    1742:	8c 2f       	mov	r24, r28
    1744:	8f 7e       	andi	r24, 0xEF	; 239
    1746:	8d 38       	cpi	r24, 0x8D	; 141
    1748:	b1 f3       	breq	.-20     	; 0x1736 <Calibrate_Manually+0x132>
    174a:	cb 39       	cpi	r28, 0x9B	; 155
    174c:	a1 f3       	breq	.-24     	; 0x1736 <Calibrate_Manually+0x132>
    174e:	8c 2f       	mov	r24, r28
    1750:	87 7f       	andi	r24, 0xF7	; 247
    1752:	80 3a       	cpi	r24, 0xA0	; 160
    1754:	81 f3       	breq	.-32     	; 0x1736 <Calibrate_Manually+0x132>
    1756:	c4 3b       	cpi	r28, 0xB4	; 180
    1758:	71 f3       	breq	.-36     	; 0x1736 <Calibrate_Manually+0x132>
    175a:	8c 2f       	mov	r24, r28
    175c:	8d 7f       	andi	r24, 0xFD	; 253
    175e:	8d 3a       	cpi	r24, 0xAD	; 173
    1760:	51 f3       	breq	.-44     	; 0x1736 <Calibrate_Manually+0x132>
    1762:	89 e4       	ldi	r24, 0x49	; 73
    1764:	8c 0f       	add	r24, r28
    1766:	82 30       	cpi	r24, 0x02	; 2
    1768:	30 f3       	brcs	.-52     	; 0x1736 <Calibrate_Manually+0x132>
    176a:	c2 39       	cpi	r28, 0x92	; 146
    176c:	09 f4       	brne	.+2      	; 0x1770 <Calibrate_Manually+0x16c>
    176e:	cb e9       	ldi	r28, 0x9B	; 155
    1770:	8c 2f       	mov	r24, r28
    1772:	0e 94 0f 2a 	call	0x541e	; 0x541e <USBSendASCII>
    1776:	2f ef       	ldi	r18, 0xFF	; 255
    1778:	84 e3       	ldi	r24, 0x34	; 52
    177a:	9c e0       	ldi	r25, 0x0C	; 12
    177c:	21 50       	subi	r18, 0x01	; 1
    177e:	80 40       	sbci	r24, 0x00	; 0
    1780:	90 40       	sbci	r25, 0x00	; 0
    1782:	e1 f7       	brne	.-8      	; 0x177c <Calibrate_Manually+0x178>
    1784:	00 c0       	rjmp	.+0      	; 0x1786 <Calibrate_Manually+0x182>
    1786:	00 00       	nop
    1788:	81 cf       	rjmp	.-254    	; 0x168c <Calibrate_Manually+0x88>
			Delay_MS(CALIBRATION_DELAY);
			}
			else{ //if key pressed is spacebar
				if (is_low(CTRL_KEY)){DECREMENT_CODE();}
    178a:	7c 99       	sbic	0x0f, 4	; 15
    178c:	43 c0       	rjmp	.+134    	; 0x1814 <Calibrate_Manually+0x210>
    178e:	dc 17       	cp	r29, r28
    1790:	30 f4       	brcc	.+12     	; 0x179e <Calibrate_Manually+0x19a>
    1792:	1c 17       	cp	r17, r28
    1794:	10 f0       	brcs	.+4      	; 0x179a <Calibrate_Manually+0x196>
    1796:	ec 16       	cp	r14, r28
    1798:	20 f0       	brcs	.+8      	; 0x17a2 <Calibrate_Manually+0x19e>
    179a:	c1 50       	subi	r28, 0x01	; 1
    179c:	03 c0       	rjmp	.+6      	; 0x17a4 <Calibrate_Manually+0x1a0>
    179e:	c9 2d       	mov	r28, r9
    17a0:	01 c0       	rjmp	.+2      	; 0x17a4 <Calibrate_Manually+0x1a0>
    17a2:	ce 2d       	mov	r28, r14
    17a4:	60 e0       	ldi	r22, 0x00	; 0
    17a6:	88 e2       	ldi	r24, 0x28	; 40
    17a8:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
    17ac:	05 37       	cpi	r16, 0x75	; 117
    17ae:	41 f4       	brne	.+16     	; 0x17c0 <Calibrate_Manually+0x1bc>
    17b0:	8c 2f       	mov	r24, r28
    17b2:	80 68       	ori	r24, 0x80	; 128
    17b4:	88 5a       	subi	r24, 0xA8	; 168
    17b6:	85 30       	cpi	r24, 0x05	; 5
    17b8:	08 f0       	brcs	.+2      	; 0x17bc <Calibrate_Manually+0x1b8>
    17ba:	46 c0       	rjmp	.+140    	; 0x1848 <Calibrate_Manually+0x244>
    17bc:	c1 50       	subi	r28, 0x01	; 1
    17be:	f8 cf       	rjmp	.-16     	; 0x17b0 <Calibrate_Manually+0x1ac>
    17c0:	ca 35       	cpi	r28, 0x5A	; 90
    17c2:	31 f0       	breq	.+12     	; 0x17d0 <Calibrate_Manually+0x1cc>
    17c4:	c9 33       	cpi	r28, 0x39	; 57
    17c6:	31 f0       	breq	.+12     	; 0x17d4 <Calibrate_Manually+0x1d0>
    17c8:	ca 39       	cpi	r28, 0x9A	; 154
    17ca:	49 f4       	brne	.+18     	; 0x17de <Calibrate_Manually+0x1da>
    17cc:	c1 e9       	ldi	r28, 0x91	; 145
    17ce:	07 c0       	rjmp	.+14     	; 0x17de <Calibrate_Manually+0x1da>
    17d0:	c0 e4       	ldi	r28, 0x40	; 64
    17d2:	05 c0       	rjmp	.+10     	; 0x17de <Calibrate_Manually+0x1da>
    17d4:	cf e2       	ldi	r28, 0x2F	; 47
    17d6:	03 c0       	rjmp	.+6      	; 0x17de <Calibrate_Manually+0x1da>
    17d8:	c4 38       	cpi	r28, 0x84	; 132
    17da:	31 f4       	brne	.+12     	; 0x17e8 <Calibrate_Manually+0x1e4>
    17dc:	c1 50       	subi	r28, 0x01	; 1
    17de:	8f e7       	ldi	r24, 0x7F	; 127
    17e0:	8c 0f       	add	r24, r28
    17e2:	82 30       	cpi	r24, 0x02	; 2
    17e4:	c8 f7       	brcc	.-14     	; 0x17d8 <Calibrate_Manually+0x1d4>
    17e6:	fa cf       	rjmp	.-12     	; 0x17dc <Calibrate_Manually+0x1d8>
    17e8:	8c 2f       	mov	r24, r28
    17ea:	8f 7e       	andi	r24, 0xEF	; 239
    17ec:	8d 38       	cpi	r24, 0x8D	; 141
    17ee:	b1 f3       	breq	.-20     	; 0x17dc <Calibrate_Manually+0x1d8>
    17f0:	cb 39       	cpi	r28, 0x9B	; 155
    17f2:	a1 f3       	breq	.-24     	; 0x17dc <Calibrate_Manually+0x1d8>
    17f4:	8c 2f       	mov	r24, r28
    17f6:	87 7f       	andi	r24, 0xF7	; 247
    17f8:	80 3a       	cpi	r24, 0xA0	; 160
    17fa:	81 f3       	breq	.-32     	; 0x17dc <Calibrate_Manually+0x1d8>
    17fc:	c4 3b       	cpi	r28, 0xB4	; 180
    17fe:	71 f3       	breq	.-36     	; 0x17dc <Calibrate_Manually+0x1d8>
    1800:	8c 2f       	mov	r24, r28
    1802:	8d 7f       	andi	r24, 0xFD	; 253
    1804:	8d 3a       	cpi	r24, 0xAD	; 173
    1806:	51 f3       	breq	.-44     	; 0x17dc <Calibrate_Manually+0x1d8>
    1808:	89 e4       	ldi	r24, 0x49	; 73
    180a:	8c 0f       	add	r24, r28
    180c:	82 30       	cpi	r24, 0x02	; 2
    180e:	08 f0       	brcs	.+2      	; 0x1812 <Calibrate_Manually+0x20e>
    1810:	47 c0       	rjmp	.+142    	; 0x18a0 <Calibrate_Manually+0x29c>
    1812:	e4 cf       	rjmp	.-56     	; 0x17dc <Calibrate_Manually+0x1d8>
				else if (is_low(CMD_KEY)){break;}
    1814:	7e 9b       	sbis	0x0f, 6	; 15
    1816:	48 c0       	rjmp	.+144    	; 0x18a8 <Calibrate_Manually+0x2a4>
				else {INCREMENT_CODE();}
    1818:	cf 5f       	subi	r28, 0xFF	; 255
    181a:	41 f0       	breq	.+16     	; 0x182c <Calibrate_Manually+0x228>
    181c:	9c 16       	cp	r9, r28
    181e:	30 f0       	brcs	.+12     	; 0x182c <Calibrate_Manually+0x228>
    1820:	ec 16       	cp	r14, r28
    1822:	28 f4       	brcc	.+10     	; 0x182e <Calibrate_Manually+0x22a>
    1824:	c1 17       	cp	r28, r17
    1826:	18 f4       	brcc	.+6      	; 0x182e <Calibrate_Manually+0x22a>
    1828:	c1 2f       	mov	r28, r17
    182a:	01 c0       	rjmp	.+2      	; 0x182e <Calibrate_Manually+0x22a>
    182c:	cd 2f       	mov	r28, r29
    182e:	60 e0       	ldi	r22, 0x00	; 0
    1830:	88 e2       	ldi	r24, 0x28	; 40
    1832:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
    1836:	05 37       	cpi	r16, 0x75	; 117
    1838:	61 f4       	brne	.+24     	; 0x1852 <Calibrate_Manually+0x24e>
    183a:	8c 2f       	mov	r24, r28
    183c:	80 68       	ori	r24, 0x80	; 128
    183e:	88 5a       	subi	r24, 0xA8	; 168
    1840:	85 30       	cpi	r24, 0x05	; 5
    1842:	10 f4       	brcc	.+4      	; 0x1848 <Calibrate_Manually+0x244>
    1844:	cf 5f       	subi	r28, 0xFF	; 255
    1846:	f9 cf       	rjmp	.-14     	; 0x183a <Calibrate_Manually+0x236>
    1848:	60 e0       	ldi	r22, 0x00	; 0
    184a:	8c 2f       	mov	r24, r28
    184c:	0e 94 f7 28 	call	0x51ee	; 0x51ee <USBSend>
    1850:	1d cf       	rjmp	.-454    	; 0x168c <Calibrate_Manually+0x88>
    1852:	c1 34       	cpi	r28, 0x41	; 65
    1854:	21 f0       	breq	.+8      	; 0x185e <Calibrate_Manually+0x25a>
    1856:	c0 33       	cpi	r28, 0x30	; 48
    1858:	39 f4       	brne	.+14     	; 0x1868 <Calibrate_Manually+0x264>
    185a:	ca e3       	ldi	r28, 0x3A	; 58
    185c:	05 c0       	rjmp	.+10     	; 0x1868 <Calibrate_Manually+0x264>
    185e:	cb e5       	ldi	r28, 0x5B	; 91
    1860:	03 c0       	rjmp	.+6      	; 0x1868 <Calibrate_Manually+0x264>
    1862:	c4 38       	cpi	r28, 0x84	; 132
    1864:	31 f4       	brne	.+12     	; 0x1872 <Calibrate_Manually+0x26e>
    1866:	cf 5f       	subi	r28, 0xFF	; 255
    1868:	8f e7       	ldi	r24, 0x7F	; 127
    186a:	8c 0f       	add	r24, r28
    186c:	82 30       	cpi	r24, 0x02	; 2
    186e:	c8 f7       	brcc	.-14     	; 0x1862 <Calibrate_Manually+0x25e>
    1870:	fa cf       	rjmp	.-12     	; 0x1866 <Calibrate_Manually+0x262>
    1872:	8c 2f       	mov	r24, r28
    1874:	8f 7e       	andi	r24, 0xEF	; 239
    1876:	8d 38       	cpi	r24, 0x8D	; 141
    1878:	b1 f3       	breq	.-20     	; 0x1866 <Calibrate_Manually+0x262>
    187a:	cb 39       	cpi	r28, 0x9B	; 155
    187c:	a1 f3       	breq	.-24     	; 0x1866 <Calibrate_Manually+0x262>
    187e:	8c 2f       	mov	r24, r28
    1880:	87 7f       	andi	r24, 0xF7	; 247
    1882:	80 3a       	cpi	r24, 0xA0	; 160
    1884:	81 f3       	breq	.-32     	; 0x1866 <Calibrate_Manually+0x262>
    1886:	c4 3b       	cpi	r28, 0xB4	; 180
    1888:	71 f3       	breq	.-36     	; 0x1866 <Calibrate_Manually+0x262>
    188a:	8c 2f       	mov	r24, r28
    188c:	8d 7f       	andi	r24, 0xFD	; 253
    188e:	8d 3a       	cpi	r24, 0xAD	; 173
    1890:	51 f3       	breq	.-44     	; 0x1866 <Calibrate_Manually+0x262>
    1892:	89 e4       	ldi	r24, 0x49	; 73
    1894:	8c 0f       	add	r24, r28
    1896:	82 30       	cpi	r24, 0x02	; 2
    1898:	30 f3       	brcs	.-52     	; 0x1866 <Calibrate_Manually+0x262>
    189a:	c2 39       	cpi	r28, 0x92	; 146
    189c:	09 f4       	brne	.+2      	; 0x18a0 <Calibrate_Manually+0x29c>
    189e:	cb e9       	ldi	r28, 0x9B	; 155
    18a0:	8c 2f       	mov	r24, r28
    18a2:	0e 94 0f 2a 	call	0x541e	; 0x541e <USBSendASCII>
    18a6:	f2 ce       	rjmp	.-540    	; 0x168c <Calibrate_Manually+0x88>
			}
	}
	
	SaveCalibration(); //save your work.
    18a8:	c9 d8       	rcall	.-3694   	; 0xa3c <SaveCalibration>
	USBSendPROGString(Str_Settings_Saved);
    18aa:	81 e6       	ldi	r24, 0x61	; 97
    18ac:	92 e0       	ldi	r25, 0x02	; 2
	
}
    18ae:	df 91       	pop	r29
    18b0:	cf 91       	pop	r28
    18b2:	1f 91       	pop	r17
    18b4:	0f 91       	pop	r16
    18b6:	ff 90       	pop	r15
    18b8:	ef 90       	pop	r14
    18ba:	df 90       	pop	r13
    18bc:	cf 90       	pop	r12
    18be:	bf 90       	pop	r11
    18c0:	af 90       	pop	r10
    18c2:	9f 90       	pop	r9
				else {INCREMENT_CODE();}
			}
	}
	
	SaveCalibration(); //save your work.
	USBSendPROGString(Str_Settings_Saved);
    18c4:	0c 94 c1 29 	jmp	0x5382	; 0x5382 <USBSendPROGString>
		codeend2 = 0xFF;
	}
	
	code = codestart1;
	if (edit_mode == 'u'){USBSend(code,LOWER);}
	else {USBSendASCII(code);}
    18c8:	81 e2       	ldi	r24, 0x21	; 33
    18ca:	0e 94 0f 2a 	call	0x541e	; 0x541e <USBSendASCII>
	}
	else{
		codestart1 = 0x21;
		codeend1 = 142;// see http://www.peterstagg.com/blog/wp-content/uploads/2012/05/letter-spagetti.png
		codestart2 = 153;
		codeend2 = 0xFF;
    18ce:	99 24       	eor	r9, r9
    18d0:	9a 94       	dec	r9
		codeend2 = 0x38|FORCE_UPPER;
	}
	else{
		codestart1 = 0x21;
		codeend1 = 142;// see http://www.peterstagg.com/blog/wp-content/uploads/2012/05/letter-spagetti.png
		codestart2 = 153;
    18d2:	19 e9       	ldi	r17, 0x99	; 153
		codestart2 = 0x1E|FORCE_UPPER;
		codeend2 = 0x38|FORCE_UPPER;
	}
	else{
		codestart1 = 0x21;
		codeend1 = 142;// see http://www.peterstagg.com/blog/wp-content/uploads/2012/05/letter-spagetti.png
    18d4:	8e e8       	ldi	r24, 0x8E	; 142
    18d6:	e8 2e       	mov	r14, r24
		codeend1 = 0x38;
		codestart2 = 0x1E|FORCE_UPPER;
		codeend2 = 0x38|FORCE_UPPER;
	}
	else{
		codestart1 = 0x21;
    18d8:	d1 e2       	ldi	r29, 0x21	; 33
    18da:	d7 ce       	rjmp	.-594    	; 0x168a <Calibrate_Manually+0x86>

000018dc <Config_Interrupts>:


void Config_Interrupts(){

	
	bit_clr(PRR0,PRTIM1); // clear power-reduction bit for timer1
    18dc:	e4 e6       	ldi	r30, 0x64	; 100
    18de:	f0 e0       	ldi	r31, 0x00	; 0
    18e0:	80 81       	ld	r24, Z
    18e2:	87 7f       	andi	r24, 0xF7	; 247
    18e4:	80 83       	st	Z, r24
	TCCR1B = BIT(CTC1) | BIT(CS11); //set CTC (clear timer on compare equal mode) and set tmr prescaler to 8 -- page 125 of datasheet
    18e6:	8a e0       	ldi	r24, 0x0A	; 10
    18e8:	80 93 81 00 	sts	0x0081, r24
	
	OCR1AH = TIMER1_COMPARE_HIGH;//high register MUST be written before low register.  Datasheet says so!
    18ec:	87 e2       	ldi	r24, 0x27	; 39
    18ee:	80 93 89 00 	sts	0x0089, r24
	OCR1AL = UINT8_C(TIMER1_COMPARE_LOW); //we only want the first 8 bits of the "low" variable.
    18f2:	80 e1       	ldi	r24, 0x10	; 16
    18f4:	80 93 88 00 	sts	0x0088, r24
	
	bit_set(TIMSK1,OCIE1A); //enable output compare interrupt for timer1
    18f8:	ef e6       	ldi	r30, 0x6F	; 111
    18fa:	f0 e0       	ldi	r31, 0x00	; 0
    18fc:	80 81       	ld	r24, Z
    18fe:	82 60       	ori	r24, 0x02	; 2
    1900:	80 83       	st	Z, r24
    1902:	08 95       	ret

00001904 <Config_IO>:
volatile uint8_t GlowDirection; //global variable that sets direction of led glow (fade up or down)


void Config_IO(){
	
	configure_as_input(SD_DETECT);
    1904:	20 98       	cbi	0x04, 0	; 4
	pullup_on(SD_DETECT);
    1906:	28 9a       	sbi	0x05, 0	; 5
	
	configure_as_input(REED_1);
    1908:	54 98       	cbi	0x0a, 4	; 10
	pullup_on(REED_1);
    190a:	5c 9a       	sbi	0x0b, 4	; 11
	
	configure_as_input(REED_2);
    190c:	56 98       	cbi	0x0a, 6	; 10
	pullup_on(REED_2);	
    190e:	5e 9a       	sbi	0x0b, 6	; 11

	configure_as_input(REED_3);
    1910:	57 98       	cbi	0x0a, 7	; 10
	pullup_on(REED_3);	
    1912:	5f 9a       	sbi	0x0b, 7	; 11
	
	configure_as_input(REED_4);
    1914:	24 98       	cbi	0x04, 4	; 4
	pullup_on(REED_4);	
    1916:	2c 9a       	sbi	0x05, 4	; 5
	
	
	set_high(SD_MISO);
    1918:	2b 9a       	sbi	0x05, 3	; 5
	configure_as_input(SD_MISO);
    191a:	23 98       	cbi	0x04, 3	; 4
	pullup_on(SD_MISO);
    191c:	2b 9a       	sbi	0x05, 3	; 5
	
	set_high(SD_MOSI);
    191e:	2a 9a       	sbi	0x05, 2	; 5
	configure_as_input(SD_MOSI);
    1920:	22 98       	cbi	0x04, 2	; 4
	pullup_on(SD_MOSI);
    1922:	2a 9a       	sbi	0x05, 2	; 5
	
	configure_as_output(SENSE_CLK);
    1924:	6a 9a       	sbi	0x0d, 2	; 13
	
	configure_as_input(SENSE_SER);
    1926:	25 98       	cbi	0x04, 5	; 4
	pullup_on(SENSE_SER);
    1928:	2d 9a       	sbi	0x05, 5	; 5

	set_high(SD_CLK);
    192a:	29 9a       	sbi	0x05, 1	; 5
	configure_as_input(SD_CLK);
    192c:	21 98       	cbi	0x04, 1	; 4
	pullup_on(SD_CLK);
    192e:	29 9a       	sbi	0x05, 1	; 5
	
	set_high(SD_CHIP_SELECT);
    1930:	59 9a       	sbi	0x0b, 1	; 11
	configure_as_output(SD_CHIP_SELECT);
    1932:	51 9a       	sbi	0x0a, 1	; 10
	
	configure_as_input(DUMMY_LOAD);
    1934:	55 98       	cbi	0x0a, 5	; 10
	//no pullup;
	
	set_high(TX);
    1936:	5b 9a       	sbi	0x0b, 3	; 11
	configure_as_output(TX);
    1938:	53 9a       	sbi	0x0a, 3	; 10
	
	configure_as_input(RX);
    193a:	52 98       	cbi	0x0a, 2	; 10
	pullup_on(RX);
    193c:	5a 9a       	sbi	0x0b, 2	; 11
	
	configure_as_input(S1);
    193e:	84 98       	cbi	0x10, 4	; 16
	pullup_on(S1);
    1940:	8c 9a       	sbi	0x11, 4	; 17
	
	configure_as_input(S2);
    1942:	85 98       	cbi	0x10, 5	; 16
	pullup_on(S2);
    1944:	8d 9a       	sbi	0x11, 5	; 17
	
	configure_as_input(S3);
    1946:	86 98       	cbi	0x10, 6	; 16
	pullup_on(S3);
    1948:	8e 9a       	sbi	0x11, 6	; 17
	
	set_low(BT_RESET);// bt is off by default
    194a:	8f 98       	cbi	0x11, 7	; 17
	configure_as_output(BT_RESET); 
    194c:	87 9a       	sbi	0x10, 7	; 16
	
	set_high(BT_BAUD);
    194e:	47 9a       	sbi	0x08, 7	; 8
	configure_as_output(BT_BAUD);
    1950:	3f 9a       	sbi	0x07, 7	; 7
	
	configure_as_input(BT_CONNECTED);
    1952:	81 98       	cbi	0x10, 1	; 16
	pullup_on(BT_CONNECTED);
    1954:	89 9a       	sbi	0x11, 1	; 17
	
	set_high(BT_CTS);
    1956:	76 9a       	sbi	0x0e, 6	; 14
	configure_as_output(BT_CTS);
    1958:	6e 9a       	sbi	0x0d, 6	; 13
	
	set_high(LED1);
    195a:	46 9a       	sbi	0x08, 6	; 8
	configure_as_output(LED1);
    195c:	3e 9a       	sbi	0x07, 6	; 7
	
	set_high(LED2);
    195e:	2e 9a       	sbi	0x05, 6	; 5
	configure_as_output(LED2);
    1960:	26 9a       	sbi	0x04, 6	; 4
    1962:	08 95       	ret

00001964 <GlowGreenLED>:
}

void GlowGreenLED(uint8_t speed, uint8_t mode){

	//green led is also called the ~OC4A pin
	cli();//disable interrupts;
    1964:	f8 94       	cli
	OCR4C = 0xFF; //clear tmr4 when reaching this value
    1966:	9f ef       	ldi	r25, 0xFF	; 255
    1968:	90 93 d1 00 	sts	0x00D1, r25
	TC4H = 0x00; //clearing this register sets timer4 to 8-bit mode
    196c:	10 92 bf 00 	sts	0x00BF, r1
	OCR4A = 0x20; //when counter reaches this value, it triggers LED.
    1970:	90 e2       	ldi	r25, 0x20	; 32
    1972:	90 93 cf 00 	sts	0x00CF, r25
	
	if(mode == SOLID){
		bit_clr(TCCR4E,OC4OE0);//disconnect ~oc4a output
    1976:	90 91 c4 00 	lds	r25, 0x00C4
	cli();//disable interrupts;
	OCR4C = 0xFF; //clear tmr4 when reaching this value
	TC4H = 0x00; //clearing this register sets timer4 to 8-bit mode
	OCR4A = 0x20; //when counter reaches this value, it triggers LED.
	
	if(mode == SOLID){
    197a:	61 30       	cpi	r22, 0x01	; 1
    197c:	51 f4       	brne	.+20     	; 0x1992 <GlowGreenLED+0x2e>
		bit_clr(TCCR4E,OC4OE0);//disconnect ~oc4a output
    197e:	9e 7f       	andi	r25, 0xFE	; 254
    1980:	90 93 c4 00 	sts	0x00C4, r25
		bit_clr(TCCR4A,COM4A0); //clear the bit for ~OC4A pin to be active in fast pwm mode
    1984:	90 91 c0 00 	lds	r25, 0x00C0
    1988:	9f 7b       	andi	r25, 0xBF	; 191
    198a:	90 93 c0 00 	sts	0x00C0, r25
		set_low(GREEN_LED);	//manually pull led low
    198e:	46 98       	cbi	0x08, 6	; 8
    1990:	08 c0       	rjmp	.+16     	; 0x19a2 <GlowGreenLED+0x3e>
	}
	else{
		bit_set(TCCR4E,OC4OE0);//enable the ~oc4a output
    1992:	91 60       	ori	r25, 0x01	; 1
    1994:	90 93 c4 00 	sts	0x00C4, r25
		bit_set(TCCR4A,COM4A0); //set the bit for ~OC4A pin to be active in fast pwm mode
    1998:	90 91 c0 00 	lds	r25, 0x00C0
    199c:	90 64       	ori	r25, 0x40	; 64
    199e:	90 93 c0 00 	sts	0x00C0, r25
	}
	
	
	bit_set(TCCR4A,PWM4A);//activate fast pwm mode
    19a2:	90 91 c0 00 	lds	r25, 0x00C0
    19a6:	92 60       	ori	r25, 0x02	; 2
    19a8:	90 93 c0 00 	sts	0x00C0, r25
	bit_set(TIMSK4,TOIE4);//enable timer overflow interrupts.
    19ac:	90 91 72 00 	lds	r25, 0x0072
    19b0:	94 60       	ori	r25, 0x04	; 4
    19b2:	90 93 72 00 	sts	0x0072, r25
	switch(speed){
    19b6:	81 30       	cpi	r24, 0x01	; 1
    19b8:	69 f0       	breq	.+26     	; 0x19d4 <GlowGreenLED+0x70>
    19ba:	30 f0       	brcs	.+12     	; 0x19c8 <GlowGreenLED+0x64>
    19bc:	82 30       	cpi	r24, 0x02	; 2
    19be:	41 f0       	breq	.+16     	; 0x19d0 <GlowGreenLED+0x6c>
    19c0:	83 30       	cpi	r24, 0x03	; 3
    19c2:	41 f4       	brne	.+16     	; 0x19d4 <GlowGreenLED+0x70>
		break;
		case 2:
			TCCR4B = BIT(CS42)|BIT(CS41)|BIT(CS40);
		break;
		case 3:
			TCCR4B = BIT(CS42)|BIT(CS41);
    19c4:	86 e0       	ldi	r24, 0x06	; 6
    19c6:	09 c0       	rjmp	.+18     	; 0x19da <GlowGreenLED+0x76>
	
	bit_set(TCCR4A,PWM4A);//activate fast pwm mode
	bit_set(TIMSK4,TOIE4);//enable timer overflow interrupts.
	switch(speed){
		case 0:
			TCCR4B = BIT(CS43)|BIT(CS40);
    19c8:	89 e0       	ldi	r24, 0x09	; 9
    19ca:	80 93 c1 00 	sts	0x00C1, r24
    19ce:	02 c0       	rjmp	.+4      	; 0x19d4 <GlowGreenLED+0x70>
		case 1:
			bit_set(TCCR4B,CS43);//enable 1:128 prescaler (should make each tick worth about 10khZ).
		break;
		case 2:
			TCCR4B = BIT(CS42)|BIT(CS41)|BIT(CS40);
    19d0:	87 e0       	ldi	r24, 0x07	; 7
    19d2:	03 c0       	rjmp	.+6      	; 0x19da <GlowGreenLED+0x76>
		break;
		case 3:
			TCCR4B = BIT(CS42)|BIT(CS41);
		break;
		default:
			bit_set(TCCR4B,CS43);
    19d4:	80 91 c1 00 	lds	r24, 0x00C1
    19d8:	88 60       	ori	r24, 0x08	; 8
    19da:	80 93 c1 00 	sts	0x00C1, r24
		break;
	}
		
		GlowDirection = BRIGHTEN;
    19de:	10 92 1b 06 	sts	0x061B, r1
		TCNT4 = 0;//clear the timer to 0;}
    19e2:	10 92 bf 00 	sts	0x00BF, r1
    19e6:	10 92 be 00 	sts	0x00BE, r1

	sei();//enable interrupts again.
    19ea:	78 94       	sei
    19ec:	08 95       	ret

000019ee <__vector_41>:
}

ISR(TIMER4_OVF_vect){ //called each time timer1 counts up to the OCR1A register (every couple ms)
    19ee:	1f 92       	push	r1
    19f0:	0f 92       	push	r0
    19f2:	0f b6       	in	r0, 0x3f	; 63
    19f4:	0f 92       	push	r0
    19f6:	11 24       	eor	r1, r1
    19f8:	8f 93       	push	r24
    19fa:	9f 93       	push	r25

	uint8_t temp;
	temp = OCR4A;
    19fc:	80 91 cf 00 	lds	r24, 0x00CF
	switch(GlowDirection){
    1a00:	90 91 1b 06 	lds	r25, 0x061B
    1a04:	99 23       	and	r25, r25
    1a06:	19 f0       	breq	.+6      	; 0x1a0e <__vector_41+0x20>
    1a08:	92 30       	cpi	r25, 0x02	; 2
    1a0a:	39 f0       	breq	.+14     	; 0x1a1a <__vector_41+0x2c>
    1a0c:	0a c0       	rjmp	.+20     	; 0x1a22 <__vector_41+0x34>
	case BRIGHTEN:
		if(temp==0xFF) GlowDirection = DIM;
    1a0e:	8f 3f       	cpi	r24, 0xFF	; 255
    1a10:	31 f4       	brne	.+12     	; 0x1a1e <__vector_41+0x30>
    1a12:	91 e0       	ldi	r25, 0x01	; 1
    1a14:	90 93 1b 06 	sts	0x061B, r25
    1a18:	10 c0       	rjmp	.+32     	; 0x1a3a <__vector_41+0x4c>
		else temp++;
	break;
	case BRIGHTEN_ONLY:
			if(temp!=0xFF) temp++;
    1a1a:	8f 3f       	cpi	r24, 0xFF	; 255
    1a1c:	71 f0       	breq	.+28     	; 0x1a3a <__vector_41+0x4c>
    1a1e:	8f 5f       	subi	r24, 0xFF	; 255
    1a20:	0c c0       	rjmp	.+24     	; 0x1a3a <__vector_41+0x4c>
	break;
	case DIM:
	default:
		if(temp == 0x00){
    1a22:	81 11       	cpse	r24, r1
    1a24:	09 c0       	rjmp	.+18     	; 0x1a38 <__vector_41+0x4a>
			bit_clr(TCCR4A,COM4A0); //disconnect green led output pin
    1a26:	90 91 c0 00 	lds	r25, 0x00C0
    1a2a:	9f 7b       	andi	r25, 0xBF	; 191
    1a2c:	90 93 c0 00 	sts	0x00C0, r25
			TCCR4B = 0;//clear the timer4 register (disable the timer);
    1a30:	10 92 c1 00 	sts	0x00C1, r1
			set_high(GREEN_LED); //turn off led
    1a34:	46 9a       	sbi	0x08, 6	; 8
    1a36:	01 c0       	rjmp	.+2      	; 0x1a3a <__vector_41+0x4c>
		}
		else{
			temp--;
    1a38:	81 50       	subi	r24, 0x01	; 1
		}
	break;
	}
	OCR4A = temp;
    1a3a:	80 93 cf 00 	sts	0x00CF, r24
}
    1a3e:	9f 91       	pop	r25
    1a40:	8f 91       	pop	r24
    1a42:	0f 90       	pop	r0
    1a44:	0f be       	out	0x3f, r0	; 63
    1a46:	0f 90       	pop	r0
    1a48:	1f 90       	pop	r1
    1a4a:	18 95       	reti

00001a4c <CALLBACK_USB_GetDescriptor>:
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
    1a4c:	29 2f       	mov	r18, r25
    1a4e:	33 27       	eor	r19, r19
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
    1a50:	23 30       	cpi	r18, 0x03	; 3
    1a52:	31 05       	cpc	r19, r1
    1a54:	e1 f0       	breq	.+56     	; 0x1a8e <CALLBACK_USB_GetDescriptor+0x42>
    1a56:	5c f4       	brge	.+22     	; 0x1a6e <CALLBACK_USB_GetDescriptor+0x22>
    1a58:	21 30       	cpi	r18, 0x01	; 1
    1a5a:	31 05       	cpc	r19, r1
    1a5c:	99 f0       	breq	.+38     	; 0x1a84 <CALLBACK_USB_GetDescriptor+0x38>
    1a5e:	22 30       	cpi	r18, 0x02	; 2
    1a60:	31 05       	cpc	r19, r1
    1a62:	79 f5       	brne	.+94     	; 0x1ac2 <CALLBACK_USB_GetDescriptor+0x76>
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
    1a64:	89 e3       	ldi	r24, 0x39	; 57
    1a66:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
    1a68:	2d ef       	ldi	r18, 0xFD	; 253
    1a6a:	35 e0       	ldi	r19, 0x05	; 5
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
    1a6c:	2e c0       	rjmp	.+92     	; 0x1aca <CALLBACK_USB_GetDescriptor+0x7e>
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
    1a6e:	21 32       	cpi	r18, 0x21	; 33
    1a70:	31 05       	cpc	r19, r1
    1a72:	11 f1       	breq	.+68     	; 0x1ab8 <CALLBACK_USB_GetDescriptor+0x6c>
    1a74:	22 32       	cpi	r18, 0x22	; 34
    1a76:	31 05       	cpc	r19, r1
    1a78:	21 f5       	brne	.+72     	; 0x1ac2 <CALLBACK_USB_GetDescriptor+0x76>
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
		case HID_DTYPE_Report:
			Address = &KeyboardReport;
			Size    = sizeof(KeyboardReport);
    1a7a:	8f e3       	ldi	r24, 0x3F	; 63
    1a7c:	90 e0       	ldi	r25, 0x00	; 0
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
		case HID_DTYPE_Report:
			Address = &KeyboardReport;
    1a7e:	28 e4       	ldi	r18, 0x48	; 72
    1a80:	36 e0       	ldi	r19, 0x06	; 6
			Size    = sizeof(KeyboardReport);
			break;
    1a82:	23 c0       	rjmp	.+70     	; 0x1aca <CALLBACK_USB_GetDescriptor+0x7e>

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
    1a84:	82 e1       	ldi	r24, 0x12	; 18
    1a86:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
    1a88:	26 e3       	ldi	r18, 0x36	; 54
    1a8a:	36 e0       	ldi	r19, 0x06	; 6
    1a8c:	1e c0       	rjmp	.+60     	; 0x1aca <CALLBACK_USB_GetDescriptor+0x7e>
    1a8e:	99 27       	eor	r25, r25
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
    1a90:	81 30       	cpi	r24, 0x01	; 1
    1a92:	91 05       	cpc	r25, r1
    1a94:	41 f0       	breq	.+16     	; 0x1aa6 <CALLBACK_USB_GetDescriptor+0x5a>
    1a96:	82 30       	cpi	r24, 0x02	; 2
    1a98:	91 05       	cpc	r25, r1
    1a9a:	41 f0       	breq	.+16     	; 0x1aac <CALLBACK_USB_GetDescriptor+0x60>
    1a9c:	89 2b       	or	r24, r25
    1a9e:	89 f4       	brne	.+34     	; 0x1ac2 <CALLBACK_USB_GetDescriptor+0x76>
			{
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
    1aa0:	e9 ef       	ldi	r30, 0xF9	; 249
    1aa2:	f5 e0       	ldi	r31, 0x05	; 5
    1aa4:	05 c0       	rjmp	.+10     	; 0x1ab0 <CALLBACK_USB_GetDescriptor+0x64>
					break;
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
    1aa6:	e1 ed       	ldi	r30, 0xD1	; 209
    1aa8:	f5 e0       	ldi	r31, 0x05	; 5
    1aaa:	02 c0       	rjmp	.+4      	; 0x1ab0 <CALLBACK_USB_GetDescriptor+0x64>
					break;
				case STRING_ID_Product:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
    1aac:	ef e9       	ldi	r30, 0x9F	; 159
    1aae:	f5 e0       	ldi	r31, 0x05	; 5
    1ab0:	84 91       	lpm	r24, Z
    1ab2:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case STRING_ID_Product:
					Address = &ProductString;
    1ab4:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
    1ab6:	09 c0       	rjmp	.+18     	; 0x1aca <CALLBACK_USB_GetDescriptor+0x7e>
			}

			break;
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
    1ab8:	89 e0       	ldi	r24, 0x09	; 9
    1aba:	90 e0       	ldi	r25, 0x00	; 0
					break;
			}

			break;
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
    1abc:	26 e2       	ldi	r18, 0x26	; 38
    1abe:	36 e0       	ldi	r19, 0x06	; 6
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
    1ac0:	04 c0       	rjmp	.+8      	; 0x1aca <CALLBACK_USB_GetDescriptor+0x7e>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
    1ac2:	80 e0       	ldi	r24, 0x00	; 0
    1ac4:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
    1ac6:	20 e0       	ldi	r18, 0x00	; 0
    1ac8:	30 e0       	ldi	r19, 0x00	; 0
			Address = &KeyboardReport;
			Size    = sizeof(KeyboardReport);
			break;
	}

	*DescriptorAddress = Address;
    1aca:	fa 01       	movw	r30, r20
    1acc:	31 83       	std	Z+1, r19	; 0x01
    1ace:	20 83       	st	Z, r18
	return Size;
}
    1ad0:	08 95       	ret

00001ad2 <OpenLogFile>:
			CloseLogFile(); // close log file so a new one can be opened later.
}

/** Opens the log file on the Dataflash's FAT formatted partition according to the current date */
FRESULT OpenLogFile(void)
{
    1ad2:	cf 93       	push	r28
	
//	if (USB_DeviceState == DEVICE_STATE_Configured){
//		return FR_LOCKED; //the disk is locked if the USB is engaged.  This prevents collision with filesystem read/writes
//	}
	
		diskstatus = f_open(&LogFile, FileName, FA_OPEN_ALWAYS | FA_WRITE);
    1ad4:	42 e1       	ldi	r20, 0x12	; 18
    1ad6:	60 e0       	ldi	r22, 0x00	; 0
    1ad8:	71 e0       	ldi	r23, 0x01	; 1
    1ada:	89 e0       	ldi	r24, 0x09	; 9
    1adc:	93 e0       	ldi	r25, 0x03	; 3
    1ade:	0e 94 c1 1d 	call	0x3b82	; 0x3b82 <f_open>
		f_sync(&LogFile);
    1ae2:	89 e0       	ldi	r24, 0x09	; 9
    1ae4:	93 e0       	ldi	r25, 0x03	; 3
    1ae6:	0e 94 7d 20 	call	0x40fa	; 0x40fa <f_sync>
		f_close(&LogFile);
    1aea:	89 e0       	ldi	r24, 0x09	; 9
    1aec:	93 e0       	ldi	r25, 0x03	; 3
    1aee:	0e 94 c0 20 	call	0x4180	; 0x4180 <f_close>
		diskstatus = f_open(&LogFile, FileName, FA_OPEN_ALWAYS | FA_WRITE);
    1af2:	42 e1       	ldi	r20, 0x12	; 18
    1af4:	60 e0       	ldi	r22, 0x00	; 0
    1af6:	71 e0       	ldi	r23, 0x01	; 1
    1af8:	89 e0       	ldi	r24, 0x09	; 9
    1afa:	93 e0       	ldi	r25, 0x03	; 3
    1afc:	0e 94 c1 1d 	call	0x3b82	; 0x3b82 <f_open>
    1b00:	c8 2f       	mov	r28, r24
		
		f_lseek(&LogFile, LogFile.fsize);
    1b02:	40 91 13 03 	lds	r20, 0x0313
    1b06:	50 91 14 03 	lds	r21, 0x0314
    1b0a:	60 91 15 03 	lds	r22, 0x0315
    1b0e:	70 91 16 03 	lds	r23, 0x0316
    1b12:	89 e0       	ldi	r24, 0x09	; 9
    1b14:	93 e0       	ldi	r25, 0x03	; 3
    1b16:	0e 94 d0 20 	call	0x41a0	; 0x41a0 <f_lseek>
	
	return diskstatus;
}
    1b1a:	8c 2f       	mov	r24, r28
    1b1c:	cf 91       	pop	r28
    1b1e:	08 95       	ret

00001b20 <CloseLogFile>:

/** Closes the open data log file on the Dataflash's FAT formatted partition */
void CloseLogFile(void)
{
	/* Sync any data waiting to be written, unmount the storage device */
	f_sync(&LogFile);
    1b20:	89 e0       	ldi	r24, 0x09	; 9
    1b22:	93 e0       	ldi	r25, 0x03	; 3
    1b24:	0e 94 7d 20 	call	0x40fa	; 0x40fa <f_sync>
	f_close(&LogFile);
    1b28:	89 e0       	ldi	r24, 0x09	; 9
    1b2a:	93 e0       	ldi	r25, 0x03	; 3
    1b2c:	0c 94 c0 20 	jmp	0x4180	; 0x4180 <f_close>

00001b30 <MountFilesystem>:
}

bool MountFilesystem(){
	bool diskstatus;
	diskstatus = f_mount(&DiskFATState,"",1);
    1b30:	41 e0       	ldi	r20, 0x01	; 1
    1b32:	6c e3       	ldi	r22, 0x3C	; 60
    1b34:	72 e0       	ldi	r23, 0x02	; 2
    1b36:	89 e2       	ldi	r24, 0x29	; 41
    1b38:	93 e0       	ldi	r25, 0x03	; 3
    1b3a:	0e 94 79 1d 	call	0x3af2	; 0x3af2 <f_mount>
    1b3e:	91 e0       	ldi	r25, 0x01	; 1
    1b40:	81 11       	cpse	r24, r1
    1b42:	01 c0       	rjmp	.+2      	; 0x1b46 <MountFilesystem+0x16>
    1b44:	90 e0       	ldi	r25, 0x00	; 0
	return diskstatus;
}
    1b46:	89 2f       	mov	r24, r25
    1b48:	08 95       	ret

00001b4a <get_num_of_sectors>:

uint32_t get_num_of_sectors(){
	static uint32_t tot_sect;
	if(!tot_sect){ //if we have not yet read a valid value into totsect
    1b4a:	80 91 05 03 	lds	r24, 0x0305
    1b4e:	90 91 06 03 	lds	r25, 0x0306
    1b52:	a0 91 07 03 	lds	r26, 0x0307
    1b56:	b0 91 08 03 	lds	r27, 0x0308
    1b5a:	89 2b       	or	r24, r25
    1b5c:	8a 2b       	or	r24, r26
    1b5e:	8b 2b       	or	r24, r27
    1b60:	d9 f4       	brne	.+54     	; 0x1b98 <get_num_of_sectors+0x4e>
		tot_sect = (DiskFATState.n_fatent - 2) * DiskFATState.csize;
    1b62:	a0 91 2b 03 	lds	r26, 0x032B
    1b66:	40 91 3b 03 	lds	r20, 0x033B
    1b6a:	50 91 3c 03 	lds	r21, 0x033C
    1b6e:	60 91 3d 03 	lds	r22, 0x033D
    1b72:	70 91 3e 03 	lds	r23, 0x033E
    1b76:	9a 01       	movw	r18, r20
    1b78:	ab 01       	movw	r20, r22
    1b7a:	22 50       	subi	r18, 0x02	; 2
    1b7c:	31 09       	sbc	r19, r1
    1b7e:	41 09       	sbc	r20, r1
    1b80:	51 09       	sbc	r21, r1
    1b82:	b0 e0       	ldi	r27, 0x00	; 0
    1b84:	0e 94 3a 37 	call	0x6e74	; 0x6e74 <__muluhisi3>
    1b88:	60 93 05 03 	sts	0x0305, r22
    1b8c:	70 93 06 03 	sts	0x0306, r23
    1b90:	80 93 07 03 	sts	0x0307, r24
    1b94:	90 93 08 03 	sts	0x0308, r25
	}
	return 	tot_sect;
    1b98:	60 91 05 03 	lds	r22, 0x0305
    1b9c:	70 91 06 03 	lds	r23, 0x0306
    1ba0:	80 91 07 03 	lds	r24, 0x0307
    1ba4:	90 91 08 03 	lds	r25, 0x0308
}
    1ba8:	08 95       	ret

00001baa <WriteToLogFile>:

bool WriteToLogFile(){
    1baa:	1f 93       	push	r17
    1bac:	cf 93       	push	r28
    1bae:	df 93       	push	r29
    1bb0:	00 d0       	rcall	.+0      	; 0x1bb2 <WriteToLogFile+0x8>
    1bb2:	cd b7       	in	r28, 0x3d	; 61
    1bb4:	de b7       	in	r29, 0x3e	; 62
	UINT BytesWritten;
	uint8_t result;
	
	
	BytesWritten = strlen((char*)SD_Buffer);
    1bb6:	e0 e7       	ldi	r30, 0x70	; 112
    1bb8:	f7 e0       	ldi	r31, 0x07	; 7
    1bba:	01 90       	ld	r0, Z+
    1bbc:	00 20       	and	r0, r0
    1bbe:	e9 f7       	brne	.-6      	; 0x1bba <WriteToLogFile+0x10>
    1bc0:	31 97       	sbiw	r30, 0x01	; 1
    1bc2:	e0 57       	subi	r30, 0x70	; 112
    1bc4:	f7 40       	sbci	r31, 0x07	; 7
    1bc6:	fa 83       	std	Y+2, r31	; 0x02
    1bc8:	e9 83       	std	Y+1, r30	; 0x01
//	BytesWritten = sprintf(SD_Buffer, "TESTINGTESTING/r/n");//debug 
	f_lseek(&LogFile, LogFile.fsize);
    1bca:	40 91 13 03 	lds	r20, 0x0313
    1bce:	50 91 14 03 	lds	r21, 0x0314
    1bd2:	60 91 15 03 	lds	r22, 0x0315
    1bd6:	70 91 16 03 	lds	r23, 0x0316
    1bda:	89 e0       	ldi	r24, 0x09	; 9
    1bdc:	93 e0       	ldi	r25, 0x03	; 3
    1bde:	0e 94 d0 20 	call	0x41a0	; 0x41a0 <f_lseek>
	result = f_write(&LogFile, (void *) SD_Buffer, BytesWritten, &BytesWritten);
    1be2:	49 81       	ldd	r20, Y+1	; 0x01
    1be4:	5a 81       	ldd	r21, Y+2	; 0x02
    1be6:	9e 01       	movw	r18, r28
    1be8:	2f 5f       	subi	r18, 0xFF	; 255
    1bea:	3f 4f       	sbci	r19, 0xFF	; 255
    1bec:	60 e7       	ldi	r22, 0x70	; 112
    1bee:	77 e0       	ldi	r23, 0x07	; 7
    1bf0:	89 e0       	ldi	r24, 0x09	; 9
    1bf2:	93 e0       	ldi	r25, 0x03	; 3
    1bf4:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <f_write>
    1bf8:	18 2f       	mov	r17, r24
	SD_Buffer[0] = '\0'; //a simple way to clear the buffer (equivalent to saving an empty string into the buffer)
    1bfa:	10 92 70 07 	sts	0x0770, r1
	f_sync(&LogFile);
    1bfe:	89 e0       	ldi	r24, 0x09	; 9
    1c00:	93 e0       	ldi	r25, 0x03	; 3
    1c02:	0e 94 7d 20 	call	0x40fa	; 0x40fa <f_sync>
	
	return result;
    1c06:	81 e0       	ldi	r24, 0x01	; 1
    1c08:	11 11       	cpse	r17, r1
    1c0a:	01 c0       	rjmp	.+2      	; 0x1c0e <WriteToLogFile+0x64>
    1c0c:	80 e0       	ldi	r24, 0x00	; 0
	
}
    1c0e:	0f 90       	pop	r0
    1c10:	0f 90       	pop	r0
    1c12:	df 91       	pop	r29
    1c14:	cf 91       	pop	r28
    1c16:	1f 91       	pop	r17
    1c18:	08 95       	ret

00001c1a <TestSDHardware>:

void TestSDHardware(){
		FRESULT diskstatus;
		
		diskstatus = MountFilesystem();
    1c1a:	8a df       	rcall	.-236    	; 0x1b30 <MountFilesystem>
		
		if (diskstatus != FR_OK){
    1c1c:	88 23       	and	r24, r24
    1c1e:	21 f0       	breq	.+8      	; 0x1c28 <TestSDHardware+0xe>
			Typewriter_Mode = PANIC_MODE;
    1c20:	8a e0       	ldi	r24, 0x0A	; 10
    1c22:	80 93 6f 07 	sts	0x076F, r24
    1c26:	08 95       	ret
			return;
		}
		
		strcpy(FileName, "SDHW.TXT");
    1c28:	68 e2       	ldi	r22, 0x28	; 40
    1c2a:	72 e0       	ldi	r23, 0x02	; 2
    1c2c:	80 e0       	ldi	r24, 0x00	; 0
    1c2e:	91 e0       	ldi	r25, 0x01	; 1
    1c30:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <strcpy>
		while(1){
		OpenLogFile();
    1c34:	4e df       	rcall	.-356    	; 0x1ad2 <OpenLogFile>
		strcpy((CHAR*)SD_Buffer,"testphrase\n");
    1c36:	61 e3       	ldi	r22, 0x31	; 49
    1c38:	72 e0       	ldi	r23, 0x02	; 2
    1c3a:	80 e7       	ldi	r24, 0x70	; 112
    1c3c:	97 e0       	ldi	r25, 0x07	; 7
    1c3e:	0e 94 fa 37 	call	0x6ff4	; 0x6ff4 <strcpy>
		WriteToLogFile();
    1c42:	b3 df       	rcall	.-154    	; 0x1baa <WriteToLogFile>
		CloseLogFile();
    1c44:	6d df       	rcall	.-294    	; 0x1b20 <CloseLogFile>
    1c46:	2f ef       	ldi	r18, 0xFF	; 255
    1c48:	80 e7       	ldi	r24, 0x70	; 112
    1c4a:	92 e0       	ldi	r25, 0x02	; 2
    1c4c:	21 50       	subi	r18, 0x01	; 1
    1c4e:	80 40       	sbci	r24, 0x00	; 0
    1c50:	90 40       	sbci	r25, 0x00	; 0
    1c52:	e1 f7       	brne	.-8      	; 0x1c4c <TestSDHardware+0x32>
    1c54:	00 c0       	rjmp	.+0      	; 0x1c56 <TestSDHardware+0x3c>
    1c56:	00 00       	nop
    1c58:	ed cf       	rjmp	.-38     	; 0x1c34 <TestSDHardware+0x1a>

00001c5a <AddToSDBuffer>:

void AddToSDBuffer(char character){
	UINT index;
	static char prevcharacter;
	
	index = strlen((char*)SD_Buffer); //index is moved to the end of the string saved in the SD_Buffer.
    1c5a:	e0 e7       	ldi	r30, 0x70	; 112
    1c5c:	f7 e0       	ldi	r31, 0x07	; 7
    1c5e:	01 90       	ld	r0, Z+
    1c60:	00 20       	and	r0, r0
    1c62:	e9 f7       	brne	.-6      	; 0x1c5e <AddToSDBuffer+0x4>
    1c64:	31 97       	sbiw	r30, 0x01	; 1
    1c66:	9f 01       	movw	r18, r30
    1c68:	20 57       	subi	r18, 0x70	; 112
    1c6a:	37 40       	sbci	r19, 0x07	; 7
	if (index >= SD_BUFFER_LENGTH-10){
    1c6c:	26 3f       	cpi	r18, 0xF6	; 246
    1c6e:	91 e0       	ldi	r25, 0x01	; 1
    1c70:	39 07       	cpc	r19, r25
    1c72:	08 f0       	brcs	.+2      	; 0x1c76 <AddToSDBuffer+0x1c>
    1c74:	41 c0       	rjmp	.+130    	; 0x1cf8 <AddToSDBuffer+0x9e>
		return; //take no action if SD_Buffer is nearly full.  this could over-write other variables and cause a mess.
	}
	
	if (character == '\r'){ //special treatment for return character
    1c76:	8d 30       	cpi	r24, 0x0D	; 13
    1c78:	81 f5       	brne	.+96     	; 0x1cda <AddToSDBuffer+0x80>
		if(prevcharacter != '\r'){ //if this is first time \r is pressed, insert a space instead, and save to file.
    1c7a:	90 91 04 03 	lds	r25, 0x0304
    1c7e:	f9 01       	movw	r30, r18
    1c80:	e0 59       	subi	r30, 0x90	; 144
    1c82:	f8 4f       	sbci	r31, 0xF8	; 248
    1c84:	a9 01       	movw	r20, r18
    1c86:	4f 5f       	subi	r20, 0xFF	; 255
    1c88:	5f 4f       	sbci	r21, 0xFF	; 255
    1c8a:	9d 30       	cpi	r25, 0x0D	; 13
    1c8c:	21 f0       	breq	.+8      	; 0x1c96 <AddToSDBuffer+0x3c>
			SD_Buffer[index] = ' ';
    1c8e:	90 e2       	ldi	r25, 0x20	; 32
    1c90:	90 83       	st	Z, r25
			SD_Buffer[index+1] = '\0';
    1c92:	fa 01       	movw	r30, r20
    1c94:	1f c0       	rjmp	.+62     	; 0x1cd4 <AddToSDBuffer+0x7a>
		}
		else if (SD_Buffer[index-1] == ' '){//if a space was inserted last time in place of \r\n, user has pressed return twice.
    1c96:	d9 01       	movw	r26, r18
    1c98:	a1 59       	subi	r26, 0x91	; 145
    1c9a:	b8 4f       	sbci	r27, 0xF8	; 248
    1c9c:	9c 91       	ld	r25, X
    1c9e:	b9 01       	movw	r22, r18
    1ca0:	6e 5f       	subi	r22, 0xFE	; 254
    1ca2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ca4:	90 32       	cpi	r25, 0x20	; 32
    1ca6:	79 f4       	brne	.+30     	; 0x1cc6 <AddToSDBuffer+0x6c>
			SD_Buffer[index-1] = '\r'; //so put the missing \r\n in now
    1ca8:	8c 93       	st	X, r24
			SD_Buffer[index] = '\n';
    1caa:	9a e0       	ldi	r25, 0x0A	; 10
    1cac:	90 83       	st	Z, r25
			SD_Buffer[index+1] = '\r';
    1cae:	fa 01       	movw	r30, r20
    1cb0:	e0 59       	subi	r30, 0x90	; 144
    1cb2:	f8 4f       	sbci	r31, 0xF8	; 248
    1cb4:	80 83       	st	Z, r24
			SD_Buffer[index+2] = '\n';
    1cb6:	fb 01       	movw	r30, r22
    1cb8:	e0 59       	subi	r30, 0x90	; 144
    1cba:	f8 4f       	sbci	r31, 0xF8	; 248
    1cbc:	90 83       	st	Z, r25
			SD_Buffer[index+3] = '\0';
    1cbe:	f9 01       	movw	r30, r18
    1cc0:	ed 58       	subi	r30, 0x8D	; 141
    1cc2:	f8 4f       	sbci	r31, 0xF8	; 248
    1cc4:	16 c0       	rjmp	.+44     	; 0x1cf2 <AddToSDBuffer+0x98>
		}
		else { //but if the last character entered was not recorded as a space (\r has already been pressed several times), then call a spade a spade.
			SD_Buffer[index] = '\r';
    1cc6:	80 83       	st	Z, r24
			SD_Buffer[index+1] = '\n';
    1cc8:	fa 01       	movw	r30, r20
    1cca:	e0 59       	subi	r30, 0x90	; 144
    1ccc:	f8 4f       	sbci	r31, 0xF8	; 248
    1cce:	9a e0       	ldi	r25, 0x0A	; 10
    1cd0:	90 83       	st	Z, r25
			SD_Buffer[index+2] = '\0';
    1cd2:	fb 01       	movw	r30, r22
    1cd4:	e0 59       	subi	r30, 0x90	; 144
    1cd6:	f8 4f       	sbci	r31, 0xF8	; 248
    1cd8:	0c c0       	rjmp	.+24     	; 0x1cf2 <AddToSDBuffer+0x98>
		}
	}
	else if (character == '\b'){ //for a backspace character,
		SD_Buffer[index-1] = '\0'; //turn the previous character into an "end of string" character 
    1cda:	f9 01       	movw	r30, r18
			SD_Buffer[index] = '\r';
			SD_Buffer[index+1] = '\n';
			SD_Buffer[index+2] = '\0';
		}
	}
	else if (character == '\b'){ //for a backspace character,
    1cdc:	88 30       	cpi	r24, 0x08	; 8
    1cde:	19 f4       	brne	.+6      	; 0x1ce6 <AddToSDBuffer+0x8c>
		SD_Buffer[index-1] = '\0'; //turn the previous character into an "end of string" character 
    1ce0:	e1 59       	subi	r30, 0x91	; 145
    1ce2:	f8 4f       	sbci	r31, 0xF8	; 248
    1ce4:	06 c0       	rjmp	.+12     	; 0x1cf2 <AddToSDBuffer+0x98>
	}
	else{ //the most common scenario -- put a character at the end of the buffer, then follow with a \0;
		SD_Buffer[index] = character;
    1ce6:	e0 59       	subi	r30, 0x90	; 144
    1ce8:	f8 4f       	sbci	r31, 0xF8	; 248
    1cea:	80 83       	st	Z, r24
		SD_Buffer[index+1] = '\0';
    1cec:	f9 01       	movw	r30, r18
    1cee:	ef 58       	subi	r30, 0x8F	; 143
    1cf0:	f8 4f       	sbci	r31, 0xF8	; 248
    1cf2:	10 82       	st	Z, r1
	}
	
	prevcharacter = character; // save the character just pressed.
    1cf4:	80 93 04 03 	sts	0x0304, r24
    1cf8:	08 95       	ret

00001cfa <LogKeystrokes>:
static FATFS DiskFATState;

/** FAT Fs structure to hold a FAT file handle for the log data write destination. */
static FIL LogFile;

void LogKeystrokes(){
    1cfa:	cf 92       	push	r12
    1cfc:	df 92       	push	r13
    1cfe:	ef 92       	push	r14
    1d00:	ff 92       	push	r15
    1d02:	0f 93       	push	r16
    1d04:	1f 93       	push	r17
    1d06:	cf 93       	push	r28
    1d08:	df 93       	push	r29
    1d0a:	cd b7       	in	r28, 0x3d	; 61
    1d0c:	de b7       	in	r29, 0x3e	; 62
    1d0e:	66 97       	sbiw	r28, 0x16	; 22
    1d10:	0f b6       	in	r0, 0x3f	; 63
    1d12:	f8 94       	cli
    1d14:	de bf       	out	0x3e, r29	; 62
    1d16:	0f be       	out	0x3f, r0	; 63
    1d18:	cd bf       	out	0x3d, r28	; 61
	uint16_t filenum;
	char code = 0;
	uint8_t modifier;
	uint8_t key;
	
	SD_Buffer[0] = '\0'; // A simple way to erase the SD_Buffer string -- first character is now the end of the string;
    1d1a:	10 92 70 07 	sts	0x0770, r1

	diskstatus = MountFilesystem();
    1d1e:	08 df       	rcall	.-496    	; 0x1b30 <MountFilesystem>
	
	if (diskstatus != FR_OK){
    1d20:	81 11       	cpse	r24, r1
    1d22:	47 c0       	rjmp	.+142    	; 0x1db2 <LogKeystrokes+0xb8>
		Typewriter_Mode = PANIC_MODE;
		return;
	}
	else{
		GlowGreenLED(VERY_SLOW,SOLID);
    1d24:	61 e0       	ldi	r22, 0x01	; 1
    1d26:	80 e0       	ldi	r24, 0x00	; 0
    1d28:	1d de       	rcall	.-966    	; 0x1964 <GlowGreenLED>
	}
	
	filenum = eeprom_read_word((uint16_t *)FILENUM_ADDR); //filenum is the last used filenum, plus 1;
    1d2a:	8a e0       	ldi	r24, 0x0A	; 10
    1d2c:	92 e0       	ldi	r25, 0x02	; 2
    1d2e:	0e 94 cf 3a 	call	0x759e	; 0x759e <eeprom_read_word>
    1d32:	8c 01       	movw	r16, r24
	
	if (filenum>9999){
    1d34:	80 31       	cpi	r24, 0x10	; 16
    1d36:	97 42       	sbci	r25, 0x27	; 39
    1d38:	10 f0       	brcs	.+4      	; 0x1d3e <LogKeystrokes+0x44>
		filenum = 0;
    1d3a:	00 e0       	ldi	r16, 0x00	; 0
    1d3c:	10 e0       	ldi	r17, 0x00	; 0
	} //filenum can only be 4 digits long.

	do{ //increment filenum until a file name is found that does not already exist ("no file" error)
		filenum++; //increment file number
		sprintf(FileName,"PAGE%04d.TXT",filenum); //filename can only be 8 characters long (not including .TXT).
    1d3e:	8d e3       	ldi	r24, 0x3D	; 61
    1d40:	c8 2e       	mov	r12, r24
    1d42:	82 e0       	ldi	r24, 0x02	; 2
    1d44:	d8 2e       	mov	r13, r24
    1d46:	90 e0       	ldi	r25, 0x00	; 0
    1d48:	e9 2e       	mov	r14, r25
    1d4a:	91 e0       	ldi	r25, 0x01	; 1
    1d4c:	f9 2e       	mov	r15, r25
	if (filenum>9999){
		filenum = 0;
	} //filenum can only be 4 digits long.

	do{ //increment filenum until a file name is found that does not already exist ("no file" error)
		filenum++; //increment file number
    1d4e:	0f 5f       	subi	r16, 0xFF	; 255
    1d50:	1f 4f       	sbci	r17, 0xFF	; 255
		sprintf(FileName,"PAGE%04d.TXT",filenum); //filename can only be 8 characters long (not including .TXT).
    1d52:	1f 93       	push	r17
    1d54:	0f 93       	push	r16
    1d56:	df 92       	push	r13
    1d58:	cf 92       	push	r12
    1d5a:	ff 92       	push	r15
    1d5c:	ef 92       	push	r14
    1d5e:	0e 94 28 38 	call	0x7050	; 0x7050 <sprintf>
		filestatus = f_stat(FileName, &fileinfo);
    1d62:	be 01       	movw	r22, r28
    1d64:	6f 5f       	subi	r22, 0xFF	; 255
    1d66:	7f 4f       	sbci	r23, 0xFF	; 255
    1d68:	80 e0       	ldi	r24, 0x00	; 0
    1d6a:	91 e0       	ldi	r25, 0x01	; 1
    1d6c:	0e 94 5f 22 	call	0x44be	; 0x44be <f_stat>
	}while(filestatus == FR_OK); //at the end of this loop, FileName is unique
    1d70:	0f 90       	pop	r0
    1d72:	0f 90       	pop	r0
    1d74:	0f 90       	pop	r0
    1d76:	0f 90       	pop	r0
    1d78:	0f 90       	pop	r0
    1d7a:	0f 90       	pop	r0
    1d7c:	88 23       	and	r24, r24
    1d7e:	39 f3       	breq	.-50     	; 0x1d4e <LogKeystrokes+0x54>
	
	if (filestatus != FR_NO_FILE){ //if the error was not "no file" something went wrong
    1d80:	84 30       	cpi	r24, 0x04	; 4
    1d82:	b9 f4       	brne	.+46     	; 0x1db2 <LogKeystrokes+0xb8>
		Typewriter_Mode = PANIC_MODE; // go into panic mode
		return;
	}
	
	while(!code){ // wait for a key to be pressed before actually opening the file -- this stops lots of empty files from being created
		key = GetKey();
    1d84:	0e 94 7d 2b 	call	0x56fa	; 0x56fa <GetKey>
    1d88:	f8 2e       	mov	r15, r24
		modifier = GetModifier();
    1d8a:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
		code = GetASCIIKeyCode(key,modifier);
    1d8e:	68 2f       	mov	r22, r24
    1d90:	8f 2d       	mov	r24, r15
    1d92:	0e 94 d9 2c 	call	0x59b2	; 0x59b2 <GetASCIIKeyCode>
	if (filestatus != FR_NO_FILE){ //if the error was not "no file" something went wrong
		Typewriter_Mode = PANIC_MODE; // go into panic mode
		return;
	}
	
	while(!code){ // wait for a key to be pressed before actually opening the file -- this stops lots of empty files from being created
    1d96:	88 23       	and	r24, r24
    1d98:	a9 f3       	breq	.-22     	; 0x1d84 <LogKeystrokes+0x8a>
		key = GetKey();
		modifier = GetModifier();
		code = GetASCIIKeyCode(key,modifier);
	}
	if((code!='s')||(Ignore_Flag==0)){
    1d9a:	83 37       	cpi	r24, 0x73	; 115
    1d9c:	21 f4       	brne	.+8      	; 0x1da6 <LogKeystrokes+0xac>
    1d9e:	90 91 69 06 	lds	r25, 0x0669
    1da2:	91 11       	cpse	r25, r1
    1da4:	03 c0       	rjmp	.+6      	; 0x1dac <LogKeystrokes+0xb2>
		AddToSDBuffer(code); //save this first key pressed to the buffer.  there will be more, and those will be handled in the main loop
    1da6:	59 df       	rcall	.-334    	; 0x1c5a <AddToSDBuffer>
		Ignore_Flag = 0;
    1da8:	10 92 69 06 	sts	0x0669, r1
	}
	if (OpenLogFile()!=FR_OK){ //open the new log file.
    1dac:	92 de       	rcall	.-732    	; 0x1ad2 <OpenLogFile>
    1dae:	88 23       	and	r24, r24
    1db0:	21 f0       	breq	.+8      	; 0x1dba <LogKeystrokes+0xc0>
		Typewriter_Mode = PANIC_MODE; // go into panic mode
    1db2:	8a e0       	ldi	r24, 0x0A	; 10
    1db4:	80 93 6f 07 	sts	0x076F, r24
		return;
    1db8:	57 c0       	rjmp	.+174    	; 0x1e68 <LogKeystrokes+0x16e>
	}
	
	eeprom_write_word((uint16_t *)FILENUM_ADDR,filenum); // save the new filenumber for next time
    1dba:	b8 01       	movw	r22, r16
    1dbc:	8a e0       	ldi	r24, 0x0A	; 10
    1dbe:	92 e0       	ldi	r25, 0x02	; 2
    1dc0:	0e 94 fd 3a 	call	0x75fa	; 0x75fa <eeprom_write_word>
	
	myTimeoutCounter = 0; //reset timeout
    1dc4:	10 92 68 06 	sts	0x0668, r1
    1dc8:	10 92 67 06 	sts	0x0667, r1

	while(myTimeoutCounter < (SD_TIMEOUT)){ //keep listening for keys and adding them to buffer. Clear buffer occassionally.
    1dcc:	80 91 67 06 	lds	r24, 0x0667
    1dd0:	90 91 68 06 	lds	r25, 0x0668
    1dd4:	80 32       	cpi	r24, 0x20	; 32
    1dd6:	9f 4b       	sbci	r25, 0xBF	; 191
    1dd8:	08 f0       	brcs	.+2      	; 0x1ddc <LogKeystrokes+0xe2>
    1dda:	41 c0       	rjmp	.+130    	; 0x1e5e <LogKeystrokes+0x164>
			key = GetKey();
    1ddc:	0e 94 7d 2b 	call	0x56fa	; 0x56fa <GetKey>
    1de0:	18 2f       	mov	r17, r24
			modifier = GetModifier();
    1de2:	0e 94 73 2a 	call	0x54e6	; 0x54e6 <GetModifier>
			
			code = GetASCIIKeyCode(key, modifier);
    1de6:	68 2f       	mov	r22, r24
    1de8:	81 2f       	mov	r24, r17
    1dea:	0e 94 d9 2c 	call	0x59b2	; 0x59b2 <GetASCIIKeyCode>
    1dee:	18 2f       	mov	r17, r24
			
			if(code){
    1df0:	88 23       	and	r24, r24
    1df2:	b9 f0       	breq	.+46     	; 0x1e22 <LogKeystrokes+0x128>
				//if ((code == 's') && Ignore_Flag) code = 0; //if user is holding down S on startup, don't add this to file.
				//Ignore_Flag = 0;
				AddToSDBuffer(code); //this adds the character to the sd write buffer.
    1df4:	32 df       	rcall	.-412    	; 0x1c5a <AddToSDBuffer>
				myTimeoutCounter = 0; //reset timeout every time a key is pressed.
    1df6:	10 92 68 06 	sts	0x0668, r1
    1dfa:	10 92 67 06 	sts	0x0667, r1
			}
			if((code == '\r')||(code == '.')||(code == ',')||(code == '!')||(code == '?')||(code == ':')||(code == '\"')){
    1dfe:	1d 30       	cpi	r17, 0x0D	; 13
    1e00:	61 f0       	breq	.+24     	; 0x1e1a <LogKeystrokes+0x120>
    1e02:	81 2f       	mov	r24, r17
    1e04:	8d 7f       	andi	r24, 0xFD	; 253
    1e06:	8c 32       	cpi	r24, 0x2C	; 44
    1e08:	41 f0       	breq	.+16     	; 0x1e1a <LogKeystrokes+0x120>
    1e0a:	8f ed       	ldi	r24, 0xDF	; 223
    1e0c:	81 0f       	add	r24, r17
    1e0e:	82 30       	cpi	r24, 0x02	; 2
    1e10:	20 f0       	brcs	.+8      	; 0x1e1a <LogKeystrokes+0x120>
    1e12:	1f 33       	cpi	r17, 0x3F	; 63
    1e14:	11 f0       	breq	.+4      	; 0x1e1a <LogKeystrokes+0x120>
    1e16:	1a 33       	cpi	r17, 0x3A	; 58
    1e18:	21 f4       	brne	.+8      	; 0x1e22 <LogKeystrokes+0x128>
				GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
    1e1a:	60 e0       	ldi	r22, 0x00	; 0
    1e1c:	82 e0       	ldi	r24, 0x02	; 2
    1e1e:	a2 dd       	rcall	.-1212   	; 0x1964 <GlowGreenLED>
				WriteToLogFile(); //save your work every time enter key is pressed.
    1e20:	c4 de       	rcall	.-632    	; 0x1baa <WriteToLogFile>
    1e22:	8f ec       	ldi	r24, 0xCF	; 207
    1e24:	97 e0       	ldi	r25, 0x07	; 7
    1e26:	01 97       	sbiw	r24, 0x01	; 1
    1e28:	f1 f7       	brne	.-4      	; 0x1e26 <LogKeystrokes+0x12c>
    1e2a:	00 c0       	rjmp	.+0      	; 0x1e2c <LogKeystrokes+0x132>
    1e2c:	00 00       	nop
			}
			Delay_MS(SENSE_DELAY);
			
			if ((myTimeoutCounter > SD_SAVE_TIME) && (SD_Buffer[0] != '\0')){
    1e2e:	80 91 67 06 	lds	r24, 0x0667
    1e32:	90 91 68 06 	lds	r25, 0x0668
    1e36:	89 3b       	cpi	r24, 0xB9	; 185
    1e38:	9b 40       	sbci	r25, 0x0B	; 11
    1e3a:	40 f2       	brcs	.-112    	; 0x1dcc <LogKeystrokes+0xd2>
    1e3c:	80 91 70 07 	lds	r24, 0x0770
    1e40:	88 23       	and	r24, r24
    1e42:	21 f2       	breq	.-120    	; 0x1dcc <LogKeystrokes+0xd2>
				set_low(GREEN_LED);
    1e44:	46 98       	cbi	0x08, 6	; 8
    1e46:	8f ef       	ldi	r24, 0xFF	; 255
    1e48:	9d e3       	ldi	r25, 0x3D	; 61
    1e4a:	29 e4       	ldi	r18, 0x49	; 73
    1e4c:	81 50       	subi	r24, 0x01	; 1
    1e4e:	90 40       	sbci	r25, 0x00	; 0
    1e50:	20 40       	sbci	r18, 0x00	; 0
    1e52:	e1 f7       	brne	.-8      	; 0x1e4c <LogKeystrokes+0x152>
    1e54:	00 c0       	rjmp	.+0      	; 0x1e56 <LogKeystrokes+0x15c>
    1e56:	00 00       	nop
				Delay_MS(3000);
				WriteToLogFile();
    1e58:	a8 de       	rcall	.-688    	; 0x1baa <WriteToLogFile>
				set_high(GREEN_LED);
    1e5a:	46 9a       	sbi	0x08, 6	; 8
    1e5c:	b7 cf       	rjmp	.-146    	; 0x1dcc <LogKeystrokes+0xd2>
			}
	}
	
			GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
    1e5e:	60 e0       	ldi	r22, 0x00	; 0
    1e60:	82 e0       	ldi	r24, 0x02	; 2
    1e62:	80 dd       	rcall	.-1280   	; 0x1964 <GlowGreenLED>
			WriteToLogFile(); //save your work then "sleep" -- stop recording keystrokes
    1e64:	a2 de       	rcall	.-700    	; 0x1baa <WriteToLogFile>
			CloseLogFile(); // close log file so a new one can be opened later.
    1e66:	5c de       	rcall	.-840    	; 0x1b20 <CloseLogFile>
}
    1e68:	66 96       	adiw	r28, 0x16	; 22
    1e6a:	0f b6       	in	r0, 0x3f	; 63
    1e6c:	f8 94       	cli
    1e6e:	de bf       	out	0x3e, r29	; 62
    1e70:	0f be       	out	0x3f, r0	; 63
    1e72:	cd bf       	out	0x3d, r28	; 61
    1e74:	df 91       	pop	r29
    1e76:	cf 91       	pop	r28
    1e78:	1f 91       	pop	r17
    1e7a:	0f 91       	pop	r16
    1e7c:	ff 90       	pop	r15
    1e7e:	ef 90       	pop	r14
    1e80:	df 90       	pop	r13
    1e82:	cf 90       	pop	r12
    1e84:	08 95       	ret

00001e86 <dly_us>:

static
void dly_us (UINT n)	/* Delay n microseconds (avr-gcc -Os) */
{
	do {
		PINB;
    1e86:	23 b1       	in	r18, 0x03	; 3
		PINB;
    1e88:	23 b1       	in	r18, 0x03	; 3
		 //PINB is a throwaway command that wastes one op cycle.  1 PINB commands is recommended for 8MHZ clock.  We can lengthen this or randomize this for EMC reasons.
	} while (--n);
    1e8a:	01 97       	sbiw	r24, 0x01	; 1
    1e8c:	e1 f7       	brne	.-8      	; 0x1e86 <dly_us>
}
    1e8e:	08 95       	ret

00001e90 <xmit_mmc>:
static
void xmit_mmc (
	const BYTE* buff,	/* Data to be sent */
	UINT bc				/* Number of bytes to send */
)
{
    1e90:	fc 01       	movw	r30, r24
    1e92:	68 0f       	add	r22, r24
    1e94:	79 1f       	adc	r23, r25
	BYTE d;


	do {
		d = *buff++;	/* Get a byte to be sent */
    1e96:	91 91       	ld	r25, Z+
		if (d & 0x80) DI_H(); else DI_L();	/* bit7 */
    1e98:	97 ff       	sbrs	r25, 7
    1e9a:	02 c0       	rjmp	.+4      	; 0x1ea0 <xmit_mmc+0x10>
    1e9c:	2a 9a       	sbi	0x05, 2	; 5
    1e9e:	01 c0       	rjmp	.+2      	; 0x1ea2 <xmit_mmc+0x12>
    1ea0:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1ea2:	29 9a       	sbi	0x05, 1	; 5
    1ea4:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x40) DI_H(); else DI_L();	/* bit6 */
    1ea6:	96 ff       	sbrs	r25, 6
    1ea8:	02 c0       	rjmp	.+4      	; 0x1eae <xmit_mmc+0x1e>
    1eaa:	2a 9a       	sbi	0x05, 2	; 5
    1eac:	01 c0       	rjmp	.+2      	; 0x1eb0 <xmit_mmc+0x20>
    1eae:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1eb0:	29 9a       	sbi	0x05, 1	; 5
    1eb2:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x20) DI_H(); else DI_L();	/* bit5 */
    1eb4:	95 ff       	sbrs	r25, 5
    1eb6:	02 c0       	rjmp	.+4      	; 0x1ebc <xmit_mmc+0x2c>
    1eb8:	2a 9a       	sbi	0x05, 2	; 5
    1eba:	01 c0       	rjmp	.+2      	; 0x1ebe <xmit_mmc+0x2e>
    1ebc:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1ebe:	29 9a       	sbi	0x05, 1	; 5
    1ec0:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x10) DI_H(); else DI_L();	/* bit4 */
    1ec2:	94 ff       	sbrs	r25, 4
    1ec4:	02 c0       	rjmp	.+4      	; 0x1eca <xmit_mmc+0x3a>
    1ec6:	2a 9a       	sbi	0x05, 2	; 5
    1ec8:	01 c0       	rjmp	.+2      	; 0x1ecc <xmit_mmc+0x3c>
    1eca:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1ecc:	29 9a       	sbi	0x05, 1	; 5
    1ece:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x08) DI_H(); else DI_L();	/* bit3 */
    1ed0:	93 ff       	sbrs	r25, 3
    1ed2:	02 c0       	rjmp	.+4      	; 0x1ed8 <xmit_mmc+0x48>
    1ed4:	2a 9a       	sbi	0x05, 2	; 5
    1ed6:	01 c0       	rjmp	.+2      	; 0x1eda <xmit_mmc+0x4a>
    1ed8:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1eda:	29 9a       	sbi	0x05, 1	; 5
    1edc:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x04) DI_H(); else DI_L();	/* bit2 */
    1ede:	92 ff       	sbrs	r25, 2
    1ee0:	02 c0       	rjmp	.+4      	; 0x1ee6 <xmit_mmc+0x56>
    1ee2:	2a 9a       	sbi	0x05, 2	; 5
    1ee4:	01 c0       	rjmp	.+2      	; 0x1ee8 <xmit_mmc+0x58>
    1ee6:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1ee8:	29 9a       	sbi	0x05, 1	; 5
    1eea:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x02) DI_H(); else DI_L();	/* bit1 */
    1eec:	91 ff       	sbrs	r25, 1
    1eee:	02 c0       	rjmp	.+4      	; 0x1ef4 <xmit_mmc+0x64>
    1ef0:	2a 9a       	sbi	0x05, 2	; 5
    1ef2:	01 c0       	rjmp	.+2      	; 0x1ef6 <xmit_mmc+0x66>
    1ef4:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1ef6:	29 9a       	sbi	0x05, 1	; 5
    1ef8:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x01) DI_H(); else DI_L();	/* bit0 */
    1efa:	90 ff       	sbrs	r25, 0
    1efc:	02 c0       	rjmp	.+4      	; 0x1f02 <xmit_mmc+0x72>
    1efe:	2a 9a       	sbi	0x05, 2	; 5
    1f00:	01 c0       	rjmp	.+2      	; 0x1f04 <xmit_mmc+0x74>
    1f02:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1f04:	29 9a       	sbi	0x05, 1	; 5
    1f06:	29 98       	cbi	0x05, 1	; 5
	} while (--bc);
    1f08:	e6 17       	cp	r30, r22
    1f0a:	f7 07       	cpc	r31, r23
    1f0c:	21 f6       	brne	.-120    	; 0x1e96 <xmit_mmc+0x6>
}
    1f0e:	08 95       	ret

00001f10 <rcvr_mmc>:
)
{
	BYTE r;


	DI_H();	/* Send 0xFF */
    1f10:	2a 9a       	sbi	0x05, 2	; 5
    1f12:	fc 01       	movw	r30, r24
    1f14:	68 0f       	add	r22, r24
    1f16:	79 1f       	adc	r23, r25

	do {
		r = 0;	 if (DO) r++;	/* bit7 */
    1f18:	93 b1       	in	r25, 0x03	; 3
		CK_H(); CK_L();
    1f1a:	29 9a       	sbi	0x05, 1	; 5
    1f1c:	29 98       	cbi	0x05, 1	; 5


	DI_H();	/* Send 0xFF */

	do {
		r = 0;	 if (DO) r++;	/* bit7 */
    1f1e:	93 fb       	bst	r25, 3
    1f20:	99 27       	eor	r25, r25
    1f22:	90 f9       	bld	r25, 0
		CK_H(); CK_L();
		r <<= 1; if (DO) r++;	/* bit6 */
    1f24:	99 0f       	add	r25, r25
    1f26:	1b 99       	sbic	0x03, 3	; 3
    1f28:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1f2a:	29 9a       	sbi	0x05, 1	; 5
    1f2c:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit5 */
    1f2e:	99 0f       	add	r25, r25
    1f30:	1b 99       	sbic	0x03, 3	; 3
    1f32:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1f34:	29 9a       	sbi	0x05, 1	; 5
    1f36:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit4 */
    1f38:	99 0f       	add	r25, r25
    1f3a:	1b 99       	sbic	0x03, 3	; 3
    1f3c:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1f3e:	29 9a       	sbi	0x05, 1	; 5
    1f40:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit3 */
    1f42:	99 0f       	add	r25, r25
    1f44:	1b 99       	sbic	0x03, 3	; 3
    1f46:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1f48:	29 9a       	sbi	0x05, 1	; 5
    1f4a:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit2 */
    1f4c:	99 0f       	add	r25, r25
    1f4e:	1b 99       	sbic	0x03, 3	; 3
    1f50:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1f52:	29 9a       	sbi	0x05, 1	; 5
    1f54:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit1 */
    1f56:	99 0f       	add	r25, r25
    1f58:	1b 99       	sbic	0x03, 3	; 3
    1f5a:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1f5c:	29 9a       	sbi	0x05, 1	; 5
    1f5e:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit0 */
    1f60:	99 0f       	add	r25, r25
    1f62:	1b 99       	sbic	0x03, 3	; 3
    1f64:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1f66:	29 9a       	sbi	0x05, 1	; 5
    1f68:	29 98       	cbi	0x05, 1	; 5
		*buff++ = r;			/* Store a received byte */
    1f6a:	91 93       	st	Z+, r25
	} while (--bc);
    1f6c:	e6 17       	cp	r30, r22
    1f6e:	f7 07       	cpc	r31, r23
    1f70:	99 f6       	brne	.-90     	; 0x1f18 <rcvr_mmc+0x8>
}
    1f72:	08 95       	ret

00001f74 <wait_ready>:
/* Wait for card ready                                                   */
/*-----------------------------------------------------------------------*/

static
int wait_ready (void)	/* 1:OK, 0:Timeout */
{
    1f74:	0f 93       	push	r16
    1f76:	1f 93       	push	r17
    1f78:	cf 93       	push	r28
    1f7a:	df 93       	push	r29
    1f7c:	1f 92       	push	r1
    1f7e:	cd b7       	in	r28, 0x3d	; 61
    1f80:	de b7       	in	r29, 0x3e	; 62
	BYTE d;
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
    1f82:	08 e8       	ldi	r16, 0x88	; 136
    1f84:	13 e1       	ldi	r17, 0x13	; 19
		rcvr_mmc(&d, 1);
    1f86:	61 e0       	ldi	r22, 0x01	; 1
    1f88:	70 e0       	ldi	r23, 0x00	; 0
    1f8a:	ce 01       	movw	r24, r28
    1f8c:	01 96       	adiw	r24, 0x01	; 1
    1f8e:	c0 df       	rcall	.-128    	; 0x1f10 <rcvr_mmc>
		if (d == 0xFF) break;
    1f90:	89 81       	ldd	r24, Y+1	; 0x01
    1f92:	8f 3f       	cpi	r24, 0xFF	; 255
    1f94:	31 f0       	breq	.+12     	; 0x1fa2 <wait_ready+0x2e>
		dly_us(100);
    1f96:	84 e6       	ldi	r24, 0x64	; 100
    1f98:	90 e0       	ldi	r25, 0x00	; 0
    1f9a:	75 df       	rcall	.-278    	; 0x1e86 <dly_us>
{
	BYTE d;
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
    1f9c:	01 50       	subi	r16, 0x01	; 1
    1f9e:	11 09       	sbc	r17, r1
    1fa0:	91 f7       	brne	.-28     	; 0x1f86 <wait_ready+0x12>
		rcvr_mmc(&d, 1);
		if (d == 0xFF) break;
		dly_us(100);
	}

	return tmr ? 1 : 0;
    1fa2:	81 e0       	ldi	r24, 0x01	; 1
    1fa4:	90 e0       	ldi	r25, 0x00	; 0
    1fa6:	01 2b       	or	r16, r17
    1fa8:	11 f4       	brne	.+4      	; 0x1fae <wait_ready+0x3a>
    1faa:	80 e0       	ldi	r24, 0x00	; 0
    1fac:	90 e0       	ldi	r25, 0x00	; 0
}
    1fae:	0f 90       	pop	r0
    1fb0:	df 91       	pop	r29
    1fb2:	cf 91       	pop	r28
    1fb4:	1f 91       	pop	r17
    1fb6:	0f 91       	pop	r16
    1fb8:	08 95       	ret

00001fba <deselect>:
/* Deselect the card and release SPI bus                                 */
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
    1fba:	cf 93       	push	r28
    1fbc:	df 93       	push	r29
    1fbe:	1f 92       	push	r1
    1fc0:	cd b7       	in	r28, 0x3d	; 61
    1fc2:	de b7       	in	r29, 0x3e	; 62
	BYTE d;

	CS_H();
    1fc4:	59 9a       	sbi	0x0b, 1	; 11
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
    1fc6:	61 e0       	ldi	r22, 0x01	; 1
    1fc8:	70 e0       	ldi	r23, 0x00	; 0
    1fca:	ce 01       	movw	r24, r28
    1fcc:	01 96       	adiw	r24, 0x01	; 1
    1fce:	a0 df       	rcall	.-192    	; 0x1f10 <rcvr_mmc>
}
    1fd0:	0f 90       	pop	r0
    1fd2:	df 91       	pop	r29
    1fd4:	cf 91       	pop	r28
    1fd6:	08 95       	ret

00001fd8 <select>:
/* Select the card and wait for ready                                    */
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
    1fd8:	cf 93       	push	r28
    1fda:	df 93       	push	r29
    1fdc:	00 d0       	rcall	.+0      	; 0x1fde <select+0x6>
    1fde:	1f 92       	push	r1
    1fe0:	cd b7       	in	r28, 0x3d	; 61
    1fe2:	de b7       	in	r29, 0x3e	; 62
	BYTE d;

	CS_L();
    1fe4:	59 98       	cbi	0x0b, 1	; 11
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO enabled) */
    1fe6:	61 e0       	ldi	r22, 0x01	; 1
    1fe8:	70 e0       	ldi	r23, 0x00	; 0
    1fea:	ce 01       	movw	r24, r28
    1fec:	01 96       	adiw	r24, 0x01	; 1
    1fee:	90 df       	rcall	.-224    	; 0x1f10 <rcvr_mmc>

	if (wait_ready()) return 1;	/* OK */
    1ff0:	c1 df       	rcall	.-126    	; 0x1f74 <wait_ready>
    1ff2:	00 97       	sbiw	r24, 0x00	; 0
    1ff4:	31 f4       	brne	.+12     	; 0x2002 <select+0x2a>
	deselect();
    1ff6:	8a 83       	std	Y+2, r24	; 0x02
    1ff8:	9b 83       	std	Y+3, r25	; 0x03
    1ffa:	df df       	rcall	.-66     	; 0x1fba <deselect>
	return 0;			/* Failed */
    1ffc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ffe:	9b 81       	ldd	r25, Y+3	; 0x03
    2000:	02 c0       	rjmp	.+4      	; 0x2006 <select+0x2e>
	BYTE d;

	CS_L();
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO enabled) */

	if (wait_ready()) return 1;	/* OK */
    2002:	81 e0       	ldi	r24, 0x01	; 1
    2004:	90 e0       	ldi	r25, 0x00	; 0
	deselect();
	return 0;			/* Failed */
}
    2006:	0f 90       	pop	r0
    2008:	0f 90       	pop	r0
    200a:	0f 90       	pop	r0
    200c:	df 91       	pop	r29
    200e:	cf 91       	pop	r28
    2010:	08 95       	ret

00002012 <rcvr_datablock>:
static
int rcvr_datablock (	/* 1:OK, 0:Failed */
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count */
)
{
    2012:	cf 92       	push	r12
    2014:	df 92       	push	r13
    2016:	ef 92       	push	r14
    2018:	ff 92       	push	r15
    201a:	0f 93       	push	r16
    201c:	1f 93       	push	r17
    201e:	cf 93       	push	r28
    2020:	df 93       	push	r29
    2022:	00 d0       	rcall	.+0      	; 0x2024 <rcvr_datablock+0x12>
    2024:	cd b7       	in	r28, 0x3d	; 61
    2026:	de b7       	in	r29, 0x3e	; 62
    2028:	7c 01       	movw	r14, r24
    202a:	6b 01       	movw	r12, r22
    202c:	08 ee       	ldi	r16, 0xE8	; 232
    202e:	13 e0       	ldi	r17, 0x03	; 3
	BYTE d[2];
	UINT tmr;


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
		rcvr_mmc(d, 1);
    2030:	61 e0       	ldi	r22, 0x01	; 1
    2032:	70 e0       	ldi	r23, 0x00	; 0
    2034:	ce 01       	movw	r24, r28
    2036:	01 96       	adiw	r24, 0x01	; 1
    2038:	6b df       	rcall	.-298    	; 0x1f10 <rcvr_mmc>
		if (d[0] != 0xFF) break;
    203a:	89 81       	ldd	r24, Y+1	; 0x01
    203c:	8f 3f       	cpi	r24, 0xFF	; 255
    203e:	71 f0       	breq	.+28     	; 0x205c <rcvr_datablock+0x4a>
		dly_us(100);
	}
	if (d[0] != 0xFE) return 0;		/* If not valid data token, return with error */
    2040:	89 81       	ldd	r24, Y+1	; 0x01
    2042:	8e 3f       	cpi	r24, 0xFE	; 254
    2044:	91 f4       	brne	.+36     	; 0x206a <rcvr_datablock+0x58>

	rcvr_mmc(buff, btr);			/* Receive the data block into buffer */
    2046:	b6 01       	movw	r22, r12
    2048:	c7 01       	movw	r24, r14
    204a:	62 df       	rcall	.-316    	; 0x1f10 <rcvr_mmc>
	rcvr_mmc(d, 2);					/* Discard CRC */
    204c:	62 e0       	ldi	r22, 0x02	; 2
    204e:	70 e0       	ldi	r23, 0x00	; 0
    2050:	ce 01       	movw	r24, r28
    2052:	01 96       	adiw	r24, 0x01	; 1
    2054:	5d df       	rcall	.-326    	; 0x1f10 <rcvr_mmc>

	return 1;						/* Return with success */
    2056:	81 e0       	ldi	r24, 0x01	; 1
    2058:	90 e0       	ldi	r25, 0x00	; 0
    205a:	09 c0       	rjmp	.+18     	; 0x206e <rcvr_datablock+0x5c>


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
		rcvr_mmc(d, 1);
		if (d[0] != 0xFF) break;
		dly_us(100);
    205c:	84 e6       	ldi	r24, 0x64	; 100
    205e:	90 e0       	ldi	r25, 0x00	; 0
    2060:	12 df       	rcall	.-476    	; 0x1e86 <dly_us>
    2062:	01 50       	subi	r16, 0x01	; 1
    2064:	11 09       	sbc	r17, r1
{
	BYTE d[2];
	UINT tmr;


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
    2066:	21 f7       	brne	.-56     	; 0x2030 <rcvr_datablock+0x1e>
    2068:	eb cf       	rjmp	.-42     	; 0x2040 <rcvr_datablock+0x2e>
		rcvr_mmc(d, 1);
		if (d[0] != 0xFF) break;
		dly_us(100);
	}
	if (d[0] != 0xFE) return 0;		/* If not valid data token, return with error */
    206a:	80 e0       	ldi	r24, 0x00	; 0
    206c:	90 e0       	ldi	r25, 0x00	; 0

	rcvr_mmc(buff, btr);			/* Receive the data block into buffer */
	rcvr_mmc(d, 2);					/* Discard CRC */

	return 1;						/* Return with success */
}
    206e:	0f 90       	pop	r0
    2070:	0f 90       	pop	r0
    2072:	df 91       	pop	r29
    2074:	cf 91       	pop	r28
    2076:	1f 91       	pop	r17
    2078:	0f 91       	pop	r16
    207a:	ff 90       	pop	r15
    207c:	ef 90       	pop	r14
    207e:	df 90       	pop	r13
    2080:	cf 90       	pop	r12
    2082:	08 95       	ret

00002084 <send_cmd>:
static
BYTE send_cmd (		/* Returns command response (bit7==1:Send failed)*/
	BYTE cmd,		/* Command byte */
	DWORD arg		/* Argument */
)
{
    2084:	df 92       	push	r13
    2086:	ef 92       	push	r14
    2088:	ff 92       	push	r15
    208a:	0f 93       	push	r16
    208c:	1f 93       	push	r17
    208e:	cf 93       	push	r28
    2090:	df 93       	push	r29
    2092:	cd b7       	in	r28, 0x3d	; 61
    2094:	de b7       	in	r29, 0x3e	; 62
    2096:	27 97       	sbiw	r28, 0x07	; 7
    2098:	0f b6       	in	r0, 0x3f	; 63
    209a:	f8 94       	cli
    209c:	de bf       	out	0x3e, r29	; 62
    209e:	0f be       	out	0x3f, r0	; 63
    20a0:	cd bf       	out	0x3d, r28	; 61
    20a2:	18 2f       	mov	r17, r24
    20a4:	04 2f       	mov	r16, r20
    20a6:	f5 2e       	mov	r15, r21
    20a8:	e6 2e       	mov	r14, r22
    20aa:	d7 2e       	mov	r13, r23
	BYTE n, d, buf[6];


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
    20ac:	87 ff       	sbrs	r24, 7
    20ae:	08 c0       	rjmp	.+16     	; 0x20c0 <send_cmd+0x3c>
		cmd &= 0x7F;
		n = send_cmd(CMD55, 0);
    20b0:	40 e0       	ldi	r20, 0x00	; 0
    20b2:	50 e0       	ldi	r21, 0x00	; 0
    20b4:	ba 01       	movw	r22, r20
    20b6:	87 e3       	ldi	r24, 0x37	; 55
    20b8:	e5 df       	rcall	.-54     	; 0x2084 <send_cmd>
		if (n > 1) return n;
    20ba:	82 30       	cpi	r24, 0x02	; 2
    20bc:	90 f5       	brcc	.+100    	; 0x2122 <send_cmd+0x9e>
{
	BYTE n, d, buf[6];


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
    20be:	1f 77       	andi	r17, 0x7F	; 127
		n = send_cmd(CMD55, 0);
		if (n > 1) return n;
	}

	/* Select the card and wait for ready except to stop multiple block read */
	if (cmd != CMD12) {
    20c0:	1c 30       	cpi	r17, 0x0C	; 12
    20c2:	51 f4       	brne	.+20     	; 0x20d8 <send_cmd+0x54>
		deselect();
		if (!select()) return 0xFF;
	}

	/* Send a command packet */
	buf[0] = 0x40 | cmd;			/* Start + Command index */
    20c4:	81 2f       	mov	r24, r17
    20c6:	80 64       	ori	r24, 0x40	; 64
    20c8:	89 83       	std	Y+1, r24	; 0x01
	buf[1] = (BYTE)(arg >> 24);		/* Argument[31..24] */
    20ca:	da 82       	std	Y+2, r13	; 0x02
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
    20cc:	eb 82       	std	Y+3, r14	; 0x03
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
    20ce:	fc 82       	std	Y+4, r15	; 0x04
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
    20d0:	0d 83       	std	Y+5, r16	; 0x05
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
    20d2:	11 23       	and	r17, r17
    20d4:	59 f0       	breq	.+22     	; 0x20ec <send_cmd+0x68>
    20d6:	06 c0       	rjmp	.+12     	; 0x20e4 <send_cmd+0x60>
		if (n > 1) return n;
	}

	/* Select the card and wait for ready except to stop multiple block read */
	if (cmd != CMD12) {
		deselect();
    20d8:	70 df       	rcall	.-288    	; 0x1fba <deselect>
		if (!select()) return 0xFF;
    20da:	7e df       	rcall	.-260    	; 0x1fd8 <select>
    20dc:	89 2b       	or	r24, r25
    20de:	91 f7       	brne	.-28     	; 0x20c4 <send_cmd+0x40>
    20e0:	8f ef       	ldi	r24, 0xFF	; 255
    20e2:	1f c0       	rjmp	.+62     	; 0x2122 <send_cmd+0x9e>
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
    20e4:	18 30       	cpi	r17, 0x08	; 8
    20e6:	21 f0       	breq	.+8      	; 0x20f0 <send_cmd+0x6c>
	buf[0] = 0x40 | cmd;			/* Start + Command index */
	buf[1] = (BYTE)(arg >> 24);		/* Argument[31..24] */
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
    20e8:	81 e0       	ldi	r24, 0x01	; 1
    20ea:	03 c0       	rjmp	.+6      	; 0x20f2 <send_cmd+0x6e>
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
    20ec:	85 e9       	ldi	r24, 0x95	; 149
    20ee:	01 c0       	rjmp	.+2      	; 0x20f2 <send_cmd+0x6e>
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
    20f0:	87 e8       	ldi	r24, 0x87	; 135
	buf[5] = n;
    20f2:	8e 83       	std	Y+6, r24	; 0x06
	xmit_mmc(buf, 6);
    20f4:	66 e0       	ldi	r22, 0x06	; 6
    20f6:	70 e0       	ldi	r23, 0x00	; 0
    20f8:	ce 01       	movw	r24, r28
    20fa:	01 96       	adiw	r24, 0x01	; 1
    20fc:	c9 de       	rcall	.-622    	; 0x1e90 <xmit_mmc>

	/* Receive command response */
	if (cmd == CMD12) rcvr_mmc(&d, 1);	/* Skip a stuff byte when stop reading */
    20fe:	1c 30       	cpi	r17, 0x0C	; 12
    2100:	29 f4       	brne	.+10     	; 0x210c <send_cmd+0x88>
    2102:	61 e0       	ldi	r22, 0x01	; 1
    2104:	70 e0       	ldi	r23, 0x00	; 0
    2106:	ce 01       	movw	r24, r28
    2108:	07 96       	adiw	r24, 0x07	; 7
    210a:	02 df       	rcall	.-508    	; 0x1f10 <rcvr_mmc>
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
    210c:	1a e0       	ldi	r17, 0x0A	; 10

	/* Receive command response */
	if (cmd == CMD12) rcvr_mmc(&d, 1);	/* Skip a stuff byte when stop reading */
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		rcvr_mmc(&d, 1);
    210e:	61 e0       	ldi	r22, 0x01	; 1
    2110:	70 e0       	ldi	r23, 0x00	; 0
    2112:	ce 01       	movw	r24, r28
    2114:	07 96       	adiw	r24, 0x07	; 7
    2116:	fc de       	rcall	.-520    	; 0x1f10 <rcvr_mmc>
	while ((d & 0x80) && --n);
    2118:	8f 81       	ldd	r24, Y+7	; 0x07
    211a:	87 ff       	sbrs	r24, 7
    211c:	02 c0       	rjmp	.+4      	; 0x2122 <send_cmd+0x9e>
    211e:	11 50       	subi	r17, 0x01	; 1
    2120:	b1 f7       	brne	.-20     	; 0x210e <send_cmd+0x8a>

	return d;			/* Return with the response value */
}
    2122:	27 96       	adiw	r28, 0x07	; 7
    2124:	0f b6       	in	r0, 0x3f	; 63
    2126:	f8 94       	cli
    2128:	de bf       	out	0x3e, r29	; 62
    212a:	0f be       	out	0x3f, r0	; 63
    212c:	cd bf       	out	0x3d, r28	; 61
    212e:	df 91       	pop	r29
    2130:	cf 91       	pop	r28
    2132:	1f 91       	pop	r17
    2134:	0f 91       	pop	r16
    2136:	ff 90       	pop	r15
    2138:	ef 90       	pop	r14
    213a:	df 90       	pop	r13
    213c:	08 95       	ret

0000213e <xmit_datablock>:
static
int xmit_datablock (	/* 1:OK, 0:Failed */
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
    213e:	ef 92       	push	r14
    2140:	ff 92       	push	r15
    2142:	1f 93       	push	r17
    2144:	cf 93       	push	r28
    2146:	df 93       	push	r29
    2148:	00 d0       	rcall	.+0      	; 0x214a <xmit_datablock+0xc>
    214a:	cd b7       	in	r28, 0x3d	; 61
    214c:	de b7       	in	r29, 0x3e	; 62
    214e:	7c 01       	movw	r14, r24
    2150:	16 2f       	mov	r17, r22
	BYTE d[2];


	if (!wait_ready()) return 0;
    2152:	10 df       	rcall	.-480    	; 0x1f74 <wait_ready>
    2154:	00 97       	sbiw	r24, 0x00	; 0
    2156:	11 f1       	breq	.+68     	; 0x219c <xmit_datablock+0x5e>

	d[0] = token;
    2158:	19 83       	std	Y+1, r17	; 0x01
	xmit_mmc(d, 1);				/* Xmit a token */
    215a:	61 e0       	ldi	r22, 0x01	; 1
    215c:	70 e0       	ldi	r23, 0x00	; 0
    215e:	ce 01       	movw	r24, r28
    2160:	01 96       	adiw	r24, 0x01	; 1
    2162:	96 de       	rcall	.-724    	; 0x1e90 <xmit_mmc>
	if (token != 0xFD) {		/* Is it data token? */
    2164:	1d 3f       	cpi	r17, 0xFD	; 253
    2166:	c1 f0       	breq	.+48     	; 0x2198 <xmit_datablock+0x5a>
		xmit_mmc(buff, 512);	/* Xmit the 512 byte data block to MMC */
    2168:	60 e0       	ldi	r22, 0x00	; 0
    216a:	72 e0       	ldi	r23, 0x02	; 2
    216c:	c7 01       	movw	r24, r14
    216e:	90 de       	rcall	.-736    	; 0x1e90 <xmit_mmc>
		rcvr_mmc(d, 2);			/* Xmit dummy CRC (0xFF,0xFF) */
    2170:	62 e0       	ldi	r22, 0x02	; 2
    2172:	70 e0       	ldi	r23, 0x00	; 0
    2174:	ce 01       	movw	r24, r28
    2176:	01 96       	adiw	r24, 0x01	; 1
    2178:	cb de       	rcall	.-618    	; 0x1f10 <rcvr_mmc>
		rcvr_mmc(d, 1);			/* Receive data response */
    217a:	61 e0       	ldi	r22, 0x01	; 1
    217c:	70 e0       	ldi	r23, 0x00	; 0
    217e:	ce 01       	movw	r24, r28
    2180:	01 96       	adiw	r24, 0x01	; 1
    2182:	c6 de       	rcall	.-628    	; 0x1f10 <rcvr_mmc>
		if ((d[0] & 0x1F) != 0x05)	/* If not accepted, return with error */
    2184:	89 81       	ldd	r24, Y+1	; 0x01
    2186:	8f 71       	andi	r24, 0x1F	; 31
    2188:	31 e0       	ldi	r19, 0x01	; 1
    218a:	20 e0       	ldi	r18, 0x00	; 0
    218c:	85 30       	cpi	r24, 0x05	; 5
    218e:	09 f0       	breq	.+2      	; 0x2192 <xmit_datablock+0x54>
    2190:	30 e0       	ldi	r19, 0x00	; 0
			return 0;
	}

	return 1;
    2192:	83 2f       	mov	r24, r19
    2194:	92 2f       	mov	r25, r18
    2196:	02 c0       	rjmp	.+4      	; 0x219c <xmit_datablock+0x5e>
    2198:	81 e0       	ldi	r24, 0x01	; 1
    219a:	90 e0       	ldi	r25, 0x00	; 0
}
    219c:	0f 90       	pop	r0
    219e:	0f 90       	pop	r0
    21a0:	df 91       	pop	r29
    21a2:	cf 91       	pop	r28
    21a4:	1f 91       	pop	r17
    21a6:	ff 90       	pop	r15
    21a8:	ef 90       	pop	r14
    21aa:	08 95       	ret

000021ac <disk_status>:

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    21ac:	81 11       	cpse	r24, r1
    21ae:	03 c0       	rjmp	.+6      	; 0x21b6 <disk_status+0xa>

	return Stat;
    21b0:	80 91 0d 01 	lds	r24, 0x010D
    21b4:	08 95       	ret

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    21b6:	81 e0       	ldi	r24, 0x01	; 1

	return Stat;
}
    21b8:	08 95       	ret

000021ba <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
    21ba:	ef 92       	push	r14
    21bc:	ff 92       	push	r15
    21be:	0f 93       	push	r16
    21c0:	1f 93       	push	r17
    21c2:	cf 93       	push	r28
    21c4:	df 93       	push	r29
    21c6:	00 d0       	rcall	.+0      	; 0x21c8 <disk_initialize+0xe>
    21c8:	00 d0       	rcall	.+0      	; 0x21ca <disk_initialize+0x10>
    21ca:	cd b7       	in	r28, 0x3d	; 61
    21cc:	de b7       	in	r29, 0x3e	; 62
	BYTE n, ty, cmd, buf[4];
	UINT tmr;
	DSTATUS s;


	if (drv) return RES_NOTRDY;
    21ce:	81 11       	cpse	r24, r1
    21d0:	5f c0       	rjmp	.+190    	; 0x2290 <disk_initialize+0xd6>

	dly_us(10000);			/* 10ms */
    21d2:	80 e1       	ldi	r24, 0x10	; 16
    21d4:	97 e2       	ldi	r25, 0x27	; 39
    21d6:	57 de       	rcall	.-850    	; 0x1e86 <dly_us>
	CS_INIT(); CS_H();		/* Initialize port pin tied to CS */
    21d8:	51 9a       	sbi	0x0a, 1	; 10
    21da:	59 9a       	sbi	0x0b, 1	; 11
	CK_INIT(); CK_L();		/* Initialize port pin tied to SCLK */
    21dc:	29 98       	cbi	0x05, 1	; 5
    21de:	21 9a       	sbi	0x04, 1	; 4
    21e0:	29 98       	cbi	0x05, 1	; 5
	DI_INIT();				/* Initialize port pin tied to DI */
    21e2:	22 9a       	sbi	0x04, 2	; 4
	DO_INIT();				/* Initialize port pin tied to DO */
    21e4:	2b 9a       	sbi	0x05, 3	; 5
    21e6:	1a e0       	ldi	r17, 0x0A	; 10

	for (n = 10; n; n--) rcvr_mmc(buf, 1);	/* Apply 80 dummy clocks and the card gets ready to receive command */
    21e8:	61 e0       	ldi	r22, 0x01	; 1
    21ea:	70 e0       	ldi	r23, 0x00	; 0
    21ec:	ce 01       	movw	r24, r28
    21ee:	01 96       	adiw	r24, 0x01	; 1
    21f0:	8f de       	rcall	.-738    	; 0x1f10 <rcvr_mmc>
    21f2:	11 50       	subi	r17, 0x01	; 1
    21f4:	c9 f7       	brne	.-14     	; 0x21e8 <disk_initialize+0x2e>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
    21f6:	40 e0       	ldi	r20, 0x00	; 0
    21f8:	50 e0       	ldi	r21, 0x00	; 0
    21fa:	ba 01       	movw	r22, r20
    21fc:	80 e0       	ldi	r24, 0x00	; 0
    21fe:	42 df       	rcall	.-380    	; 0x2084 <send_cmd>
    2200:	81 30       	cpi	r24, 0x01	; 1
    2202:	09 f0       	breq	.+2      	; 0x2206 <disk_initialize+0x4c>
    2204:	6b c0       	rjmp	.+214    	; 0x22dc <disk_initialize+0x122>
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
    2206:	4a ea       	ldi	r20, 0xAA	; 170
    2208:	51 e0       	ldi	r21, 0x01	; 1
    220a:	60 e0       	ldi	r22, 0x00	; 0
    220c:	70 e0       	ldi	r23, 0x00	; 0
    220e:	88 e0       	ldi	r24, 0x08	; 8
    2210:	39 df       	rcall	.-398    	; 0x2084 <send_cmd>
    2212:	81 30       	cpi	r24, 0x01	; 1
    2214:	f1 f4       	brne	.+60     	; 0x2252 <disk_initialize+0x98>
			rcvr_mmc(buf, 4);							/* Get trailing return value of R7 resp */
    2216:	64 e0       	ldi	r22, 0x04	; 4
    2218:	70 e0       	ldi	r23, 0x00	; 0
    221a:	ce 01       	movw	r24, r28
    221c:	01 96       	adiw	r24, 0x01	; 1
    221e:	78 de       	rcall	.-784    	; 0x1f10 <rcvr_mmc>
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
    2220:	8b 81       	ldd	r24, Y+3	; 0x03
    2222:	81 30       	cpi	r24, 0x01	; 1
    2224:	09 f0       	breq	.+2      	; 0x2228 <disk_initialize+0x6e>
    2226:	5a c0       	rjmp	.+180    	; 0x22dc <disk_initialize+0x122>
    2228:	8c 81       	ldd	r24, Y+4	; 0x04
    222a:	8a 3a       	cpi	r24, 0xAA	; 170
    222c:	09 f0       	breq	.+2      	; 0x2230 <disk_initialize+0x76>
    222e:	56 c0       	rjmp	.+172    	; 0x22dc <disk_initialize+0x122>
    2230:	08 ee       	ldi	r16, 0xE8	; 232
    2232:	13 e0       	ldi	r17, 0x03	; 3
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
    2234:	40 e0       	ldi	r20, 0x00	; 0
    2236:	50 e0       	ldi	r21, 0x00	; 0
    2238:	60 e0       	ldi	r22, 0x00	; 0
    223a:	70 e4       	ldi	r23, 0x40	; 64
    223c:	89 ea       	ldi	r24, 0xA9	; 169
    223e:	22 df       	rcall	.-444    	; 0x2084 <send_cmd>
    2240:	88 23       	and	r24, r24
    2242:	41 f1       	breq	.+80     	; 0x2294 <disk_initialize+0xda>
					dly_us(1000);
    2244:	88 ee       	ldi	r24, 0xE8	; 232
    2246:	93 e0       	ldi	r25, 0x03	; 3
    2248:	1e de       	rcall	.-964    	; 0x1e86 <dly_us>
    224a:	01 50       	subi	r16, 0x01	; 1
    224c:	11 09       	sbc	r17, r1
	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			rcvr_mmc(buf, 4);							/* Get trailing return value of R7 resp */
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
    224e:	91 f7       	brne	.-28     	; 0x2234 <disk_initialize+0x7a>
    2250:	45 c0       	rjmp	.+138    	; 0x22dc <disk_initialize+0x122>
					rcvr_mmc(buf, 4);
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
    2252:	40 e0       	ldi	r20, 0x00	; 0
    2254:	50 e0       	ldi	r21, 0x00	; 0
    2256:	ba 01       	movw	r22, r20
    2258:	89 ea       	ldi	r24, 0xA9	; 169
    225a:	14 df       	rcall	.-472    	; 0x2084 <send_cmd>
    225c:	82 30       	cpi	r24, 0x02	; 2
    225e:	18 f0       	brcs	.+6      	; 0x2266 <disk_initialize+0xac>
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
    2260:	01 e0       	ldi	r16, 0x01	; 1
    2262:	11 e0       	ldi	r17, 0x01	; 1
    2264:	02 c0       	rjmp	.+4      	; 0x226a <disk_initialize+0xb0>
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
    2266:	09 ea       	ldi	r16, 0xA9	; 169
    2268:	12 e0       	ldi	r17, 0x02	; 2
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
    226a:	88 ee       	ldi	r24, 0xE8	; 232
    226c:	e8 2e       	mov	r14, r24
    226e:	83 e0       	ldi	r24, 0x03	; 3
    2270:	f8 2e       	mov	r15, r24
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
				if (send_cmd(cmd, 0) == 0) break;
    2272:	40 e0       	ldi	r20, 0x00	; 0
    2274:	50 e0       	ldi	r21, 0x00	; 0
    2276:	ba 01       	movw	r22, r20
    2278:	80 2f       	mov	r24, r16
    227a:	04 df       	rcall	.-504    	; 0x2084 <send_cmd>
    227c:	88 23       	and	r24, r24
    227e:	31 f1       	breq	.+76     	; 0x22cc <disk_initialize+0x112>
				dly_us(1000);
    2280:	88 ee       	ldi	r24, 0xE8	; 232
    2282:	93 e0       	ldi	r25, 0x03	; 3
    2284:	00 de       	rcall	.-1024   	; 0x1e86 <dly_us>
    2286:	81 e0       	ldi	r24, 0x01	; 1
    2288:	e8 1a       	sub	r14, r24
    228a:	f1 08       	sbc	r15, r1
			if (send_cmd(ACMD41, 0) <= 1) 	{
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
    228c:	91 f7       	brne	.-28     	; 0x2272 <disk_initialize+0xb8>
    228e:	26 c0       	rjmp	.+76     	; 0x22dc <disk_initialize+0x122>
	BYTE n, ty, cmd, buf[4];
	UINT tmr;
	DSTATUS s;


	if (drv) return RES_NOTRDY;
    2290:	83 e0       	ldi	r24, 0x03	; 3
    2292:	26 c0       	rjmp	.+76     	; 0x22e0 <disk_initialize+0x126>
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
					dly_us(1000);
				}
				if (tmr && send_cmd(CMD58, 0) == 0) {	/* Check CCS bit in the OCR */
    2294:	40 e0       	ldi	r20, 0x00	; 0
    2296:	50 e0       	ldi	r21, 0x00	; 0
    2298:	ba 01       	movw	r22, r20
    229a:	8a e3       	ldi	r24, 0x3A	; 58
    229c:	f3 de       	rcall	.-538    	; 0x2084 <send_cmd>
    229e:	81 11       	cpse	r24, r1
    22a0:	1d c0       	rjmp	.+58     	; 0x22dc <disk_initialize+0x122>
					rcvr_mmc(buf, 4);
    22a2:	64 e0       	ldi	r22, 0x04	; 4
    22a4:	70 e0       	ldi	r23, 0x00	; 0
    22a6:	ce 01       	movw	r24, r28
    22a8:	01 96       	adiw	r24, 0x01	; 1
    22aa:	32 de       	rcall	.-924    	; 0x1f10 <rcvr_mmc>
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
    22ac:	89 81       	ldd	r24, Y+1	; 0x01
    22ae:	86 fd       	sbrc	r24, 6
    22b0:	02 c0       	rjmp	.+4      	; 0x22b6 <disk_initialize+0xfc>
    22b2:	14 e0       	ldi	r17, 0x04	; 4
    22b4:	01 c0       	rjmp	.+2      	; 0x22b8 <disk_initialize+0xfe>
    22b6:	1c e0       	ldi	r17, 0x0C	; 12
			}
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
		}
	}
	CardType = ty;
    22b8:	10 93 57 05 	sts	0x0557, r17
	
				
	s = ty ? 0 : STA_NOINIT;
    22bc:	01 e0       	ldi	r16, 0x01	; 1
    22be:	11 11       	cpse	r17, r1
    22c0:	00 e0       	ldi	r16, 0x00	; 0
	Stat = s;
    22c2:	00 93 0d 01 	sts	0x010D, r16

	deselect();
    22c6:	79 de       	rcall	.-782    	; 0x1fba <deselect>

	return s;
    22c8:	80 2f       	mov	r24, r16
    22ca:	0a c0       	rjmp	.+20     	; 0x22e0 <disk_initialize+0x126>
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
				if (send_cmd(cmd, 0) == 0) break;
				dly_us(1000);
			}
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
    22cc:	40 e0       	ldi	r20, 0x00	; 0
    22ce:	52 e0       	ldi	r21, 0x02	; 2
    22d0:	60 e0       	ldi	r22, 0x00	; 0
    22d2:	70 e0       	ldi	r23, 0x00	; 0
    22d4:	80 e1       	ldi	r24, 0x10	; 16
    22d6:	d6 de       	rcall	.-596    	; 0x2084 <send_cmd>
    22d8:	88 23       	and	r24, r24
    22da:	71 f3       	breq	.-36     	; 0x22b8 <disk_initialize+0xfe>
				ty = 0;
    22dc:	10 e0       	ldi	r17, 0x00	; 0
    22de:	ec cf       	rjmp	.-40     	; 0x22b8 <disk_initialize+0xfe>
	Stat = s;

	deselect();

	return s;
}
    22e0:	0f 90       	pop	r0
    22e2:	0f 90       	pop	r0
    22e4:	0f 90       	pop	r0
    22e6:	0f 90       	pop	r0
    22e8:	df 91       	pop	r29
    22ea:	cf 91       	pop	r28
    22ec:	1f 91       	pop	r17
    22ee:	0f 91       	pop	r16
    22f0:	ff 90       	pop	r15
    22f2:	ef 90       	pop	r14
    22f4:	08 95       	ret

000022f6 <disk_read>:
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
    22f6:	ef 92       	push	r14
    22f8:	ff 92       	push	r15
    22fa:	0f 93       	push	r16
    22fc:	1f 93       	push	r17
    22fe:	cf 93       	push	r28
    2300:	7b 01       	movw	r14, r22
    2302:	ba 01       	movw	r22, r20
    2304:	a9 01       	movw	r20, r18

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    2306:	81 11       	cpse	r24, r1
    2308:	03 c0       	rjmp	.+6      	; 0x2310 <disk_read+0x1a>

	return Stat;
    230a:	80 91 0d 01 	lds	r24, 0x010D
    230e:	01 c0       	rjmp	.+2      	; 0x2312 <disk_read+0x1c>

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    2310:	81 e0       	ldi	r24, 0x01	; 1
)
{
	BYTE cmd;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    2312:	80 fd       	sbrc	r24, 0
    2314:	2d c0       	rjmp	.+90     	; 0x2370 <disk_read+0x7a>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
    2316:	80 91 57 05 	lds	r24, 0x0557
    231a:	83 fd       	sbrc	r24, 3
    231c:	07 c0       	rjmp	.+14     	; 0x232c <disk_read+0x36>
    231e:	89 e0       	ldi	r24, 0x09	; 9
    2320:	44 0f       	add	r20, r20
    2322:	55 1f       	adc	r21, r21
    2324:	66 1f       	adc	r22, r22
    2326:	77 1f       	adc	r23, r23
    2328:	8a 95       	dec	r24
    232a:	d1 f7       	brne	.-12     	; 0x2320 <disk_read+0x2a>

	cmd = count > 1 ? CMD18 : CMD17;			/*  READ_MULTIPLE_BLOCK : READ_SINGLE_BLOCK */
    232c:	02 30       	cpi	r16, 0x02	; 2
    232e:	11 05       	cpc	r17, r1
    2330:	10 f4       	brcc	.+4      	; 0x2336 <disk_read+0x40>
    2332:	c1 e1       	ldi	r28, 0x11	; 17
    2334:	01 c0       	rjmp	.+2      	; 0x2338 <disk_read+0x42>
    2336:	c2 e1       	ldi	r28, 0x12	; 18
	if (send_cmd(cmd, sector) == 0) {
    2338:	8c 2f       	mov	r24, r28
    233a:	a4 de       	rcall	.-696    	; 0x2084 <send_cmd>
    233c:	81 11       	cpse	r24, r1
    233e:	12 c0       	rjmp	.+36     	; 0x2364 <disk_read+0x6e>
		do {
			if (!rcvr_datablock(buff, 512)) break;
    2340:	60 e0       	ldi	r22, 0x00	; 0
    2342:	72 e0       	ldi	r23, 0x02	; 2
    2344:	c7 01       	movw	r24, r14
    2346:	65 de       	rcall	.-822    	; 0x2012 <rcvr_datablock>
    2348:	89 2b       	or	r24, r25
    234a:	29 f0       	breq	.+10     	; 0x2356 <disk_read+0x60>
			buff += 512;
    234c:	8e ef       	ldi	r24, 0xFE	; 254
    234e:	f8 1a       	sub	r15, r24
		} while (--count);
    2350:	01 50       	subi	r16, 0x01	; 1
    2352:	11 09       	sbc	r17, r1
    2354:	a9 f7       	brne	.-22     	; 0x2340 <disk_read+0x4a>
		if (cmd == CMD18) send_cmd(CMD12, 0);	/* STOP_TRANSMISSION */
    2356:	c2 31       	cpi	r28, 0x12	; 18
    2358:	29 f4       	brne	.+10     	; 0x2364 <disk_read+0x6e>
    235a:	40 e0       	ldi	r20, 0x00	; 0
    235c:	50 e0       	ldi	r21, 0x00	; 0
    235e:	ba 01       	movw	r22, r20
    2360:	8c e0       	ldi	r24, 0x0C	; 12
    2362:	90 de       	rcall	.-736    	; 0x2084 <send_cmd>
	}
	deselect();
    2364:	2a de       	rcall	.-940    	; 0x1fba <deselect>

	return count ? RES_ERROR : RES_OK;
    2366:	81 e0       	ldi	r24, 0x01	; 1
    2368:	01 2b       	or	r16, r17
    236a:	19 f4       	brne	.+6      	; 0x2372 <disk_read+0x7c>
    236c:	80 e0       	ldi	r24, 0x00	; 0
    236e:	01 c0       	rjmp	.+2      	; 0x2372 <disk_read+0x7c>
)
{
	BYTE cmd;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    2370:	83 e0       	ldi	r24, 0x03	; 3
		if (cmd == CMD18) send_cmd(CMD12, 0);	/* STOP_TRANSMISSION */
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
    2372:	cf 91       	pop	r28
    2374:	1f 91       	pop	r17
    2376:	0f 91       	pop	r16
    2378:	ff 90       	pop	r15
    237a:	ef 90       	pop	r14
    237c:	08 95       	ret

0000237e <disk_write>:
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
    237e:	cf 92       	push	r12
    2380:	df 92       	push	r13
    2382:	ef 92       	push	r14
    2384:	ff 92       	push	r15
    2386:	0f 93       	push	r16
    2388:	1f 93       	push	r17
    238a:	cf 93       	push	r28
    238c:	df 93       	push	r29
    238e:	eb 01       	movw	r28, r22
    2390:	69 01       	movw	r12, r18
    2392:	7a 01       	movw	r14, r20

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    2394:	81 11       	cpse	r24, r1
    2396:	03 c0       	rjmp	.+6      	; 0x239e <disk_write+0x20>

	return Stat;
    2398:	80 91 0d 01 	lds	r24, 0x010D
    239c:	01 c0       	rjmp	.+2      	; 0x23a0 <disk_write+0x22>

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    239e:	81 e0       	ldi	r24, 0x01	; 1
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    23a0:	80 fd       	sbrc	r24, 0
    23a2:	43 c0       	rjmp	.+134    	; 0x242a <disk_write+0xac>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
    23a4:	80 91 57 05 	lds	r24, 0x0557
    23a8:	83 fd       	sbrc	r24, 3
    23aa:	07 c0       	rjmp	.+14     	; 0x23ba <disk_write+0x3c>
    23ac:	99 e0       	ldi	r25, 0x09	; 9
    23ae:	cc 0c       	add	r12, r12
    23b0:	dd 1c       	adc	r13, r13
    23b2:	ee 1c       	adc	r14, r14
    23b4:	ff 1c       	adc	r15, r15
    23b6:	9a 95       	dec	r25
    23b8:	d1 f7       	brne	.-12     	; 0x23ae <disk_write+0x30>

	if (count == 1) {	/* Single block write */
    23ba:	01 30       	cpi	r16, 0x01	; 1
    23bc:	11 05       	cpc	r17, r1
    23be:	89 f4       	brne	.+34     	; 0x23e2 <disk_write+0x64>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
    23c0:	b7 01       	movw	r22, r14
    23c2:	a6 01       	movw	r20, r12
    23c4:	88 e1       	ldi	r24, 0x18	; 24
    23c6:	5e de       	rcall	.-836    	; 0x2084 <send_cmd>
    23c8:	81 11       	cpse	r24, r1
    23ca:	29 c0       	rjmp	.+82     	; 0x241e <disk_write+0xa0>
			&& xmit_datablock(buff, 0xFE))
    23cc:	6e ef       	ldi	r22, 0xFE	; 254
    23ce:	ce 01       	movw	r24, r28
    23d0:	b6 de       	rcall	.-660    	; 0x213e <xmit_datablock>
    23d2:	31 e0       	ldi	r19, 0x01	; 1
    23d4:	20 e0       	ldi	r18, 0x00	; 0
    23d6:	89 2b       	or	r24, r25
    23d8:	09 f0       	breq	.+2      	; 0x23dc <disk_write+0x5e>
    23da:	30 e0       	ldi	r19, 0x00	; 0
    23dc:	03 2f       	mov	r16, r19
    23de:	12 2f       	mov	r17, r18
    23e0:	1e c0       	rjmp	.+60     	; 0x241e <disk_write+0xa0>
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
    23e2:	86 70       	andi	r24, 0x06	; 6
    23e4:	29 f0       	breq	.+10     	; 0x23f0 <disk_write+0x72>
    23e6:	a8 01       	movw	r20, r16
    23e8:	60 e0       	ldi	r22, 0x00	; 0
    23ea:	70 e0       	ldi	r23, 0x00	; 0
    23ec:	87 e9       	ldi	r24, 0x97	; 151
    23ee:	4a de       	rcall	.-876    	; 0x2084 <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
    23f0:	b7 01       	movw	r22, r14
    23f2:	a6 01       	movw	r20, r12
    23f4:	89 e1       	ldi	r24, 0x19	; 25
    23f6:	46 de       	rcall	.-884    	; 0x2084 <send_cmd>
    23f8:	81 11       	cpse	r24, r1
    23fa:	11 c0       	rjmp	.+34     	; 0x241e <disk_write+0xa0>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
    23fc:	6c ef       	ldi	r22, 0xFC	; 252
    23fe:	ce 01       	movw	r24, r28
    2400:	9e de       	rcall	.-708    	; 0x213e <xmit_datablock>
    2402:	89 2b       	or	r24, r25
    2404:	21 f0       	breq	.+8      	; 0x240e <disk_write+0x90>
				buff += 512;
    2406:	de 5f       	subi	r29, 0xFE	; 254
			} while (--count);
    2408:	01 50       	subi	r16, 0x01	; 1
    240a:	11 09       	sbc	r17, r1
    240c:	b9 f7       	brne	.-18     	; 0x23fc <disk_write+0x7e>
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
    240e:	6d ef       	ldi	r22, 0xFD	; 253
    2410:	80 e0       	ldi	r24, 0x00	; 0
    2412:	90 e0       	ldi	r25, 0x00	; 0
    2414:	94 de       	rcall	.-728    	; 0x213e <xmit_datablock>
    2416:	89 2b       	or	r24, r25
    2418:	11 f4       	brne	.+4      	; 0x241e <disk_write+0xa0>
				count = 1;
    241a:	01 e0       	ldi	r16, 0x01	; 1
    241c:	10 e0       	ldi	r17, 0x00	; 0
		}
	}
	deselect();
    241e:	cd dd       	rcall	.-1126   	; 0x1fba <deselect>

	return count ? RES_ERROR : RES_OK;
    2420:	81 e0       	ldi	r24, 0x01	; 1
    2422:	01 2b       	or	r16, r17
    2424:	19 f4       	brne	.+6      	; 0x242c <disk_write+0xae>
    2426:	80 e0       	ldi	r24, 0x00	; 0
    2428:	01 c0       	rjmp	.+2      	; 0x242c <disk_write+0xae>
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    242a:	83 e0       	ldi	r24, 0x03	; 3
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
    242c:	df 91       	pop	r29
    242e:	cf 91       	pop	r28
    2430:	1f 91       	pop	r17
    2432:	0f 91       	pop	r16
    2434:	ff 90       	pop	r15
    2436:	ef 90       	pop	r14
    2438:	df 90       	pop	r13
    243a:	cf 90       	pop	r12
    243c:	08 95       	ret

0000243e <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
    243e:	0f 93       	push	r16
    2440:	1f 93       	push	r17
    2442:	cf 93       	push	r28
    2444:	df 93       	push	r29
    2446:	cd b7       	in	r28, 0x3d	; 61
    2448:	de b7       	in	r29, 0x3e	; 62
    244a:	60 97       	sbiw	r28, 0x10	; 16
    244c:	0f b6       	in	r0, 0x3f	; 63
    244e:	f8 94       	cli
    2450:	de bf       	out	0x3e, r29	; 62
    2452:	0f be       	out	0x3f, r0	; 63
    2454:	cd bf       	out	0x3d, r28	; 61

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    2456:	81 11       	cpse	r24, r1
    2458:	03 c0       	rjmp	.+6      	; 0x2460 <disk_ioctl+0x22>

	return Stat;
    245a:	80 91 0d 01 	lds	r24, 0x010D
    245e:	01 c0       	rjmp	.+2      	; 0x2462 <disk_ioctl+0x24>

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    2460:	81 e0       	ldi	r24, 0x01	; 1
	DRESULT res;
	BYTE n, csd[16];
	DWORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */
    2462:	80 fd       	sbrc	r24, 0
    2464:	7c c0       	rjmp	.+248    	; 0x255e <disk_ioctl+0x120>
    2466:	8a 01       	movw	r16, r20

	res = RES_ERROR;
	switch (ctrl) {
    2468:	61 30       	cpi	r22, 0x01	; 1
    246a:	79 f0       	breq	.+30     	; 0x248a <disk_ioctl+0x4c>
    246c:	40 f0       	brcs	.+16     	; 0x247e <disk_ioctl+0x40>
    246e:	63 30       	cpi	r22, 0x03	; 3
    2470:	09 f0       	breq	.+2      	; 0x2474 <disk_ioctl+0x36>
    2472:	71 c0       	rjmp	.+226    	; 0x2556 <disk_ioctl+0x118>
				res = RES_OK;
			}
			break;

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			*(DWORD*)buff = 128;
    2474:	80 e8       	ldi	r24, 0x80	; 128
    2476:	90 e0       	ldi	r25, 0x00	; 0
    2478:	a0 e0       	ldi	r26, 0x00	; 0
    247a:	b0 e0       	ldi	r27, 0x00	; 0
    247c:	65 c0       	rjmp	.+202    	; 0x2548 <disk_ioctl+0x10a>
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */

	res = RES_ERROR;
	switch (ctrl) {
		case CTRL_SYNC :		/* Make sure that no pending write process */
			if (select()) res = RES_OK;
    247e:	ac dd       	rcall	.-1192   	; 0x1fd8 <select>
    2480:	11 e0       	ldi	r17, 0x01	; 1
    2482:	89 2b       	or	r24, r25
    2484:	09 f4       	brne	.+2      	; 0x2488 <disk_ioctl+0x4a>
    2486:	68 c0       	rjmp	.+208    	; 0x2558 <disk_ioctl+0x11a>
    2488:	64 c0       	rjmp	.+200    	; 0x2552 <disk_ioctl+0x114>
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
    248a:	40 e0       	ldi	r20, 0x00	; 0
    248c:	50 e0       	ldi	r21, 0x00	; 0
    248e:	ba 01       	movw	r22, r20
    2490:	89 e0       	ldi	r24, 0x09	; 9
    2492:	f8 dd       	rcall	.-1040   	; 0x2084 <send_cmd>
    2494:	88 23       	and	r24, r24
    2496:	11 f0       	breq	.+4      	; 0x249c <disk_ioctl+0x5e>
	DWORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */

	res = RES_ERROR;
    2498:	11 e0       	ldi	r17, 0x01	; 1
    249a:	5e c0       	rjmp	.+188    	; 0x2558 <disk_ioctl+0x11a>
		case CTRL_SYNC :		/* Make sure that no pending write process */
			if (select()) res = RES_OK;
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
    249c:	60 e1       	ldi	r22, 0x10	; 16
    249e:	70 e0       	ldi	r23, 0x00	; 0
    24a0:	ce 01       	movw	r24, r28
    24a2:	01 96       	adiw	r24, 0x01	; 1
    24a4:	b6 dd       	rcall	.-1172   	; 0x2012 <rcvr_datablock>
    24a6:	89 2b       	or	r24, r25
    24a8:	b9 f3       	breq	.-18     	; 0x2498 <disk_ioctl+0x5a>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
    24aa:	99 81       	ldd	r25, Y+1	; 0x01
    24ac:	92 95       	swap	r25
    24ae:	96 95       	lsr	r25
    24b0:	96 95       	lsr	r25
    24b2:	93 70       	andi	r25, 0x03	; 3
    24b4:	88 85       	ldd	r24, Y+8	; 0x08
    24b6:	49 85       	ldd	r20, Y+9	; 0x09
    24b8:	2a 85       	ldd	r18, Y+10	; 0x0a
    24ba:	91 30       	cpi	r25, 0x01	; 1
    24bc:	e1 f4       	brne	.+56     	; 0x24f6 <disk_ioctl+0xb8>
					cs = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
    24be:	8f 73       	andi	r24, 0x3F	; 63
    24c0:	90 e0       	ldi	r25, 0x00	; 0
    24c2:	a0 e0       	ldi	r26, 0x00	; 0
    24c4:	b0 e0       	ldi	r27, 0x00	; 0
    24c6:	dc 01       	movw	r26, r24
    24c8:	99 27       	eor	r25, r25
    24ca:	88 27       	eor	r24, r24
    24cc:	01 96       	adiw	r24, 0x01	; 1
    24ce:	a1 1d       	adc	r26, r1
    24d0:	b1 1d       	adc	r27, r1
    24d2:	50 e0       	ldi	r21, 0x00	; 0
    24d4:	54 2f       	mov	r21, r20
    24d6:	44 27       	eor	r20, r20
    24d8:	ba 01       	movw	r22, r20
    24da:	62 0f       	add	r22, r18
    24dc:	71 1d       	adc	r23, r1
    24de:	86 0f       	add	r24, r22
    24e0:	97 1f       	adc	r25, r23
    24e2:	a1 1d       	adc	r26, r1
    24e4:	b1 1d       	adc	r27, r1
					*(DWORD*)buff = cs << 10;
    24e6:	7a e0       	ldi	r23, 0x0A	; 10
    24e8:	88 0f       	add	r24, r24
    24ea:	99 1f       	adc	r25, r25
    24ec:	aa 1f       	adc	r26, r26
    24ee:	bb 1f       	adc	r27, r27
    24f0:	7a 95       	dec	r23
    24f2:	d1 f7       	brne	.-12     	; 0x24e8 <disk_ioctl+0xaa>
    24f4:	29 c0       	rjmp	.+82     	; 0x2548 <disk_ioctl+0x10a>
				} else {					/* SDC ver 1.XX or MMC */
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
    24f6:	42 95       	swap	r20
    24f8:	46 95       	lsr	r20
    24fa:	46 95       	lsr	r20
    24fc:	43 70       	andi	r20, 0x03	; 3
    24fe:	f4 e0       	ldi	r31, 0x04	; 4
    2500:	8f 9f       	mul	r24, r31
    2502:	c0 01       	movw	r24, r0
    2504:	11 24       	eor	r1, r1
    2506:	84 0f       	add	r24, r20
    2508:	91 1d       	adc	r25, r1
    250a:	01 96       	adiw	r24, 0x01	; 1
    250c:	4f 81       	ldd	r20, Y+7	; 0x07
    250e:	43 70       	andi	r20, 0x03	; 3
    2510:	50 e0       	ldi	r21, 0x00	; 0
    2512:	54 2f       	mov	r21, r20
    2514:	44 27       	eor	r20, r20
    2516:	55 0f       	add	r21, r21
    2518:	55 0f       	add	r21, r21
    251a:	84 0f       	add	r24, r20
    251c:	95 1f       	adc	r25, r21
    251e:	a0 e0       	ldi	r26, 0x00	; 0
    2520:	b0 e0       	ldi	r27, 0x00	; 0
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					cs = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = cs << 10;
				} else {					/* SDC ver 1.XX or MMC */
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
    2522:	3e 81       	ldd	r19, Y+6	; 0x06
    2524:	43 2f       	mov	r20, r19
    2526:	4f 70       	andi	r20, 0x0F	; 15
    2528:	3b 85       	ldd	r19, Y+11	; 0x0b
    252a:	33 1f       	adc	r19, r19
    252c:	33 27       	eor	r19, r19
    252e:	33 1f       	adc	r19, r19
    2530:	34 0f       	add	r19, r20
    2532:	23 70       	andi	r18, 0x03	; 3
    2534:	22 0f       	add	r18, r18
    2536:	23 0f       	add	r18, r19
					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = cs << (n - 9);
    2538:	27 50       	subi	r18, 0x07	; 7
    253a:	04 c0       	rjmp	.+8      	; 0x2544 <disk_ioctl+0x106>
    253c:	88 0f       	add	r24, r24
    253e:	99 1f       	adc	r25, r25
    2540:	aa 1f       	adc	r26, r26
    2542:	bb 1f       	adc	r27, r27
    2544:	2a 95       	dec	r18
    2546:	d2 f7       	brpl	.-12     	; 0x253c <disk_ioctl+0xfe>
    2548:	f8 01       	movw	r30, r16
    254a:	80 83       	st	Z, r24
    254c:	91 83       	std	Z+1, r25	; 0x01
    254e:	a2 83       	std	Z+2, r26	; 0x02
    2550:	b3 83       	std	Z+3, r27	; 0x03
				}
				res = RES_OK;
    2552:	10 e0       	ldi	r17, 0x00	; 0
    2554:	01 c0       	rjmp	.+2      	; 0x2558 <disk_ioctl+0x11a>
			*(DWORD*)buff = 128;
			res = RES_OK;
			break;

		default:
			res = RES_PARERR;
    2556:	14 e0       	ldi	r17, 0x04	; 4
	}

	deselect();
    2558:	30 dd       	rcall	.-1440   	; 0x1fba <deselect>

	return res;
    255a:	81 2f       	mov	r24, r17
    255c:	01 c0       	rjmp	.+2      	; 0x2560 <disk_ioctl+0x122>
	DRESULT res;
	BYTE n, csd[16];
	DWORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */
    255e:	83 e0       	ldi	r24, 0x03	; 3
	}

	deselect();

	return res;
}
    2560:	60 96       	adiw	r28, 0x10	; 16
    2562:	0f b6       	in	r0, 0x3f	; 63
    2564:	f8 94       	cli
    2566:	de bf       	out	0x3e, r29	; 62
    2568:	0f be       	out	0x3f, r0	; 63
    256a:	cd bf       	out	0x3d, r28	; 61
    256c:	df 91       	pop	r29
    256e:	cf 91       	pop	r28
    2570:	1f 91       	pop	r17
    2572:	0f 91       	pop	r16
    2574:	08 95       	ret

00002576 <mem_cpy>:
			FREE_BUF();
		}
	}

	LEAVE_FF(dp->fs, res);
}
    2576:	cf 93       	push	r28
    2578:	df 93       	push	r29
    257a:	eb 01       	movw	r28, r22
    257c:	dc 01       	movw	r26, r24
    257e:	fa 01       	movw	r30, r20
    2580:	e2 30       	cpi	r30, 0x02	; 2
    2582:	f1 05       	cpc	r31, r1
    2584:	30 f0       	brcs	.+12     	; 0x2592 <mem_cpy+0x1c>
    2586:	29 91       	ld	r18, Y+
    2588:	39 91       	ld	r19, Y+
    258a:	2d 93       	st	X+, r18
    258c:	3d 93       	st	X+, r19
    258e:	32 97       	sbiw	r30, 0x02	; 2
    2590:	f7 cf       	rjmp	.-18     	; 0x2580 <mem_cpy+0xa>
    2592:	9a 01       	movw	r18, r20
    2594:	2e 7f       	andi	r18, 0xFE	; 254
    2596:	dc 01       	movw	r26, r24
    2598:	a2 0f       	add	r26, r18
    259a:	b3 1f       	adc	r27, r19
    259c:	fb 01       	movw	r30, r22
    259e:	e2 0f       	add	r30, r18
    25a0:	f3 1f       	adc	r31, r19
    25a2:	40 ff       	sbrs	r20, 0
    25a4:	02 c0       	rjmp	.+4      	; 0x25aa <mem_cpy+0x34>
    25a6:	20 81       	ld	r18, Z
    25a8:	2c 93       	st	X, r18
    25aa:	df 91       	pop	r29
    25ac:	cf 91       	pop	r28
    25ae:	08 95       	ret

000025b0 <get_fileinfo>:
    25b0:	0f 93       	push	r16
    25b2:	1f 93       	push	r17
    25b4:	cf 93       	push	r28
    25b6:	df 93       	push	r29
    25b8:	8b 01       	movw	r16, r22
    25ba:	fb 01       	movw	r30, r22
    25bc:	39 96       	adiw	r30, 0x09	; 9
    25be:	dc 01       	movw	r26, r24
    25c0:	1e 96       	adiw	r26, 0x0e	; 14
    25c2:	4d 91       	ld	r20, X+
    25c4:	5d 91       	ld	r21, X+
    25c6:	6d 91       	ld	r22, X+
    25c8:	7c 91       	ld	r23, X
    25ca:	51 97       	sbiw	r26, 0x11	; 17
    25cc:	45 2b       	or	r20, r21
    25ce:	46 2b       	or	r20, r22
    25d0:	47 2b       	or	r20, r23
    25d2:	a9 f1       	breq	.+106    	; 0x263e <get_fileinfo+0x8e>
    25d4:	52 96       	adiw	r26, 0x12	; 18
    25d6:	cd 91       	ld	r28, X+
    25d8:	dc 91       	ld	r29, X
    25da:	53 97       	sbiw	r26, 0x13	; 19
    25dc:	ae 01       	movw	r20, r28
    25de:	80 e0       	ldi	r24, 0x00	; 0
    25e0:	90 e0       	ldi	r25, 0x00	; 0
    25e2:	3e e2       	ldi	r19, 0x2E	; 46
    25e4:	01 96       	adiw	r24, 0x01	; 1
    25e6:	da 01       	movw	r26, r20
    25e8:	2d 91       	ld	r18, X+
    25ea:	ad 01       	movw	r20, r26
    25ec:	20 32       	cpi	r18, 0x20	; 32
    25ee:	51 f0       	breq	.+20     	; 0x2604 <get_fileinfo+0x54>
    25f0:	25 30       	cpi	r18, 0x05	; 5
    25f2:	09 f4       	brne	.+2      	; 0x25f6 <get_fileinfo+0x46>
    25f4:	25 ee       	ldi	r18, 0xE5	; 229
    25f6:	89 30       	cpi	r24, 0x09	; 9
    25f8:	91 05       	cpc	r25, r1
    25fa:	11 f4       	brne	.+4      	; 0x2600 <get_fileinfo+0x50>
    25fc:	30 83       	st	Z, r19
    25fe:	31 96       	adiw	r30, 0x01	; 1
    2600:	20 83       	st	Z, r18
    2602:	31 96       	adiw	r30, 0x01	; 1
    2604:	8b 30       	cpi	r24, 0x0B	; 11
    2606:	91 05       	cpc	r25, r1
    2608:	69 f7       	brne	.-38     	; 0x25e4 <get_fileinfo+0x34>
    260a:	8b 85       	ldd	r24, Y+11	; 0x0b
    260c:	d8 01       	movw	r26, r16
    260e:	18 96       	adiw	r26, 0x08	; 8
    2610:	8c 93       	st	X, r24
    2612:	18 97       	sbiw	r26, 0x08	; 8
    2614:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2616:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2618:	6e 8d       	ldd	r22, Y+30	; 0x1e
    261a:	7f 8d       	ldd	r23, Y+31	; 0x1f
    261c:	4d 93       	st	X+, r20
    261e:	5d 93       	st	X+, r21
    2620:	6d 93       	st	X+, r22
    2622:	7c 93       	st	X, r23
    2624:	13 97       	sbiw	r26, 0x03	; 3
    2626:	88 8d       	ldd	r24, Y+24	; 0x18
    2628:	99 8d       	ldd	r25, Y+25	; 0x19
    262a:	15 96       	adiw	r26, 0x05	; 5
    262c:	9c 93       	st	X, r25
    262e:	8e 93       	st	-X, r24
    2630:	14 97       	sbiw	r26, 0x04	; 4
    2632:	8e 89       	ldd	r24, Y+22	; 0x16
    2634:	9f 89       	ldd	r25, Y+23	; 0x17
    2636:	17 96       	adiw	r26, 0x07	; 7
    2638:	9c 93       	st	X, r25
    263a:	8e 93       	st	-X, r24
    263c:	16 97       	sbiw	r26, 0x06	; 6
    263e:	10 82       	st	Z, r1
    2640:	df 91       	pop	r29
    2642:	cf 91       	pop	r28
    2644:	1f 91       	pop	r17
    2646:	0f 91       	pop	r16
    2648:	08 95       	ret

0000264a <get_ldnumber>:
    264a:	fc 01       	movw	r30, r24
    264c:	20 81       	ld	r18, Z
    264e:	31 81       	ldd	r19, Z+1	; 0x01
    2650:	21 15       	cp	r18, r1
    2652:	31 05       	cpc	r19, r1
    2654:	b1 f0       	breq	.+44     	; 0x2682 <get_ldnumber+0x38>
    2656:	f9 01       	movw	r30, r18
    2658:	bf 01       	movw	r22, r30
    265a:	41 91       	ld	r20, Z+
    265c:	41 32       	cpi	r20, 0x21	; 33
    265e:	70 f0       	brcs	.+28     	; 0x267c <get_ldnumber+0x32>
    2660:	4a 33       	cpi	r20, 0x3A	; 58
    2662:	d1 f7       	brne	.-12     	; 0x2658 <get_ldnumber+0xe>
    2664:	f9 01       	movw	r30, r18
    2666:	41 91       	ld	r20, Z+
    2668:	6e 17       	cp	r22, r30
    266a:	7f 07       	cpc	r23, r31
    266c:	51 f4       	brne	.+20     	; 0x2682 <get_ldnumber+0x38>
    266e:	40 33       	cpi	r20, 0x30	; 48
    2670:	41 f4       	brne	.+16     	; 0x2682 <get_ldnumber+0x38>
    2672:	2e 5f       	subi	r18, 0xFE	; 254
    2674:	3f 4f       	sbci	r19, 0xFF	; 255
    2676:	fc 01       	movw	r30, r24
    2678:	31 83       	std	Z+1, r19	; 0x01
    267a:	20 83       	st	Z, r18
    267c:	80 e0       	ldi	r24, 0x00	; 0
    267e:	90 e0       	ldi	r25, 0x00	; 0
    2680:	08 95       	ret
    2682:	8f ef       	ldi	r24, 0xFF	; 255
    2684:	9f ef       	ldi	r25, 0xFF	; 255
    2686:	08 95       	ret

00002688 <validate>:
    2688:	00 97       	sbiw	r24, 0x00	; 0
    268a:	c1 f0       	breq	.+48     	; 0x26bc <validate+0x34>
    268c:	dc 01       	movw	r26, r24
    268e:	ed 91       	ld	r30, X+
    2690:	fc 91       	ld	r31, X
    2692:	11 97       	sbiw	r26, 0x01	; 1
    2694:	30 97       	sbiw	r30, 0x00	; 0
    2696:	91 f0       	breq	.+36     	; 0x26bc <validate+0x34>
    2698:	20 81       	ld	r18, Z
    269a:	22 23       	and	r18, r18
    269c:	79 f0       	breq	.+30     	; 0x26bc <validate+0x34>
    269e:	26 81       	ldd	r18, Z+6	; 0x06
    26a0:	37 81       	ldd	r19, Z+7	; 0x07
    26a2:	12 96       	adiw	r26, 0x02	; 2
    26a4:	8d 91       	ld	r24, X+
    26a6:	9c 91       	ld	r25, X
    26a8:	13 97       	sbiw	r26, 0x03	; 3
    26aa:	28 17       	cp	r18, r24
    26ac:	39 07       	cpc	r19, r25
    26ae:	31 f4       	brne	.+12     	; 0x26bc <validate+0x34>
    26b0:	81 81       	ldd	r24, Z+1	; 0x01
    26b2:	7c dd       	rcall	.-1288   	; 0x21ac <disk_status>
    26b4:	80 fd       	sbrc	r24, 0
    26b6:	04 c0       	rjmp	.+8      	; 0x26c0 <validate+0x38>
    26b8:	80 e0       	ldi	r24, 0x00	; 0
    26ba:	08 95       	ret
    26bc:	89 e0       	ldi	r24, 0x09	; 9
    26be:	08 95       	ret
    26c0:	83 e0       	ldi	r24, 0x03	; 3
    26c2:	08 95       	ret

000026c4 <sync_window>:
    26c4:	8f 92       	push	r8
    26c6:	9f 92       	push	r9
    26c8:	af 92       	push	r10
    26ca:	bf 92       	push	r11
    26cc:	cf 92       	push	r12
    26ce:	df 92       	push	r13
    26d0:	ef 92       	push	r14
    26d2:	ff 92       	push	r15
    26d4:	0f 93       	push	r16
    26d6:	1f 93       	push	r17
    26d8:	cf 93       	push	r28
    26da:	df 93       	push	r29
    26dc:	fc 01       	movw	r30, r24
    26de:	24 81       	ldd	r18, Z+4	; 0x04
    26e0:	21 11       	cpse	r18, r1
    26e2:	02 c0       	rjmp	.+4      	; 0x26e8 <sync_window+0x24>
    26e4:	80 e0       	ldi	r24, 0x00	; 0
    26e6:	40 c0       	rjmp	.+128    	; 0x2768 <sync_window+0xa4>
    26e8:	ec 01       	movw	r28, r24
    26ea:	c2 a4       	ldd	r12, Z+42	; 0x2a
    26ec:	d3 a4       	ldd	r13, Z+43	; 0x2b
    26ee:	e4 a4       	ldd	r14, Z+44	; 0x2c
    26f0:	f5 a4       	ldd	r15, Z+45	; 0x2d
    26f2:	5c 01       	movw	r10, r24
    26f4:	fe e2       	ldi	r31, 0x2E	; 46
    26f6:	af 0e       	add	r10, r31
    26f8:	b1 1c       	adc	r11, r1
    26fa:	01 e0       	ldi	r16, 0x01	; 1
    26fc:	10 e0       	ldi	r17, 0x00	; 0
    26fe:	a7 01       	movw	r20, r14
    2700:	96 01       	movw	r18, r12
    2702:	b5 01       	movw	r22, r10
    2704:	89 81       	ldd	r24, Y+1	; 0x01
    2706:	3b de       	rcall	.-906    	; 0x237e <disk_write>
    2708:	81 11       	cpse	r24, r1
    270a:	2d c0       	rjmp	.+90     	; 0x2766 <sync_window+0xa2>
    270c:	1c 82       	std	Y+4, r1	; 0x04
    270e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2710:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2712:	a8 a1       	ldd	r26, Y+32	; 0x20
    2714:	b9 a1       	ldd	r27, Y+33	; 0x21
    2716:	b7 01       	movw	r22, r14
    2718:	a6 01       	movw	r20, r12
    271a:	48 1b       	sub	r20, r24
    271c:	59 0b       	sbc	r21, r25
    271e:	6a 0b       	sbc	r22, r26
    2720:	7b 0b       	sbc	r23, r27
    2722:	8e 89       	ldd	r24, Y+22	; 0x16
    2724:	9f 89       	ldd	r25, Y+23	; 0x17
    2726:	a8 8d       	ldd	r26, Y+24	; 0x18
    2728:	b9 8d       	ldd	r27, Y+25	; 0x19
    272a:	48 17       	cp	r20, r24
    272c:	59 07       	cpc	r21, r25
    272e:	6a 07       	cpc	r22, r26
    2730:	7b 07       	cpc	r23, r27
    2732:	c0 f6       	brcc	.-80     	; 0x26e4 <sync_window+0x20>
    2734:	8b 80       	ldd	r8, Y+3	; 0x03
    2736:	91 2c       	mov	r9, r1
    2738:	e2 e0       	ldi	r30, 0x02	; 2
    273a:	8e 16       	cp	r8, r30
    273c:	91 04       	cpc	r9, r1
    273e:	90 f2       	brcs	.-92     	; 0x26e4 <sync_window+0x20>
    2740:	8e 89       	ldd	r24, Y+22	; 0x16
    2742:	9f 89       	ldd	r25, Y+23	; 0x17
    2744:	a8 8d       	ldd	r26, Y+24	; 0x18
    2746:	b9 8d       	ldd	r27, Y+25	; 0x19
    2748:	c8 0e       	add	r12, r24
    274a:	d9 1e       	adc	r13, r25
    274c:	ea 1e       	adc	r14, r26
    274e:	fb 1e       	adc	r15, r27
    2750:	01 e0       	ldi	r16, 0x01	; 1
    2752:	10 e0       	ldi	r17, 0x00	; 0
    2754:	a7 01       	movw	r20, r14
    2756:	96 01       	movw	r18, r12
    2758:	b5 01       	movw	r22, r10
    275a:	89 81       	ldd	r24, Y+1	; 0x01
    275c:	10 de       	rcall	.-992    	; 0x237e <disk_write>
    275e:	81 e0       	ldi	r24, 0x01	; 1
    2760:	88 1a       	sub	r8, r24
    2762:	91 08       	sbc	r9, r1
    2764:	e9 cf       	rjmp	.-46     	; 0x2738 <sync_window+0x74>
    2766:	81 e0       	ldi	r24, 0x01	; 1
    2768:	df 91       	pop	r29
    276a:	cf 91       	pop	r28
    276c:	1f 91       	pop	r17
    276e:	0f 91       	pop	r16
    2770:	ff 90       	pop	r15
    2772:	ef 90       	pop	r14
    2774:	df 90       	pop	r13
    2776:	cf 90       	pop	r12
    2778:	bf 90       	pop	r11
    277a:	af 90       	pop	r10
    277c:	9f 90       	pop	r9
    277e:	8f 90       	pop	r8
    2780:	08 95       	ret

00002782 <sync_fs>:
    2782:	0f 93       	push	r16
    2784:	1f 93       	push	r17
    2786:	cf 93       	push	r28
    2788:	df 93       	push	r29
    278a:	ec 01       	movw	r28, r24
    278c:	9b df       	rcall	.-202    	; 0x26c4 <sync_window>
    278e:	98 2f       	mov	r25, r24
    2790:	81 11       	cpse	r24, r1
    2792:	5a c0       	rjmp	.+180    	; 0x2848 <sync_fs+0xc6>
    2794:	88 81       	ld	r24, Y
    2796:	83 30       	cpi	r24, 0x03	; 3
    2798:	09 f0       	breq	.+2      	; 0x279c <sync_fs+0x1a>
    279a:	4d c0       	rjmp	.+154    	; 0x2836 <sync_fs+0xb4>
    279c:	8d 81       	ldd	r24, Y+5	; 0x05
    279e:	81 30       	cpi	r24, 0x01	; 1
    27a0:	09 f0       	breq	.+2      	; 0x27a4 <sync_fs+0x22>
    27a2:	49 c0       	rjmp	.+146    	; 0x2836 <sync_fs+0xb4>
    27a4:	be 01       	movw	r22, r28
    27a6:	62 5d       	subi	r22, 0xD2	; 210
    27a8:	7f 4f       	sbci	r23, 0xFF	; 255
    27aa:	fb 01       	movw	r30, r22
    27ac:	ce 01       	movw	r24, r28
    27ae:	82 5d       	subi	r24, 0xD2	; 210
    27b0:	9d 4f       	sbci	r25, 0xFD	; 253
    27b2:	e8 17       	cp	r30, r24
    27b4:	f9 07       	cpc	r31, r25
    27b6:	11 f0       	breq	.+4      	; 0x27bc <sync_fs+0x3a>
    27b8:	11 92       	st	Z+, r1
    27ba:	fb cf       	rjmp	.-10     	; 0x27b2 <sync_fs+0x30>
    27bc:	85 e5       	ldi	r24, 0x55	; 85
    27be:	9a ea       	ldi	r25, 0xAA	; 170
    27c0:	fe 01       	movw	r30, r28
    27c2:	e4 5d       	subi	r30, 0xD4	; 212
    27c4:	fd 4f       	sbci	r31, 0xFD	; 253
    27c6:	91 83       	std	Z+1, r25	; 0x01
    27c8:	80 83       	st	Z, r24
    27ca:	82 e5       	ldi	r24, 0x52	; 82
    27cc:	92 e5       	ldi	r25, 0x52	; 82
    27ce:	a1 e6       	ldi	r26, 0x61	; 97
    27d0:	b1 e4       	ldi	r27, 0x41	; 65
    27d2:	8e a7       	std	Y+46, r24	; 0x2e
    27d4:	9f a7       	std	Y+47, r25	; 0x2f
    27d6:	a8 ab       	std	Y+48, r26	; 0x30
    27d8:	b9 ab       	std	Y+49, r27	; 0x31
    27da:	82 e7       	ldi	r24, 0x72	; 114
    27dc:	92 e7       	ldi	r25, 0x72	; 114
    27de:	a1 e4       	ldi	r26, 0x41	; 65
    27e0:	b1 e6       	ldi	r27, 0x61	; 97
    27e2:	7a 97       	sbiw	r30, 0x1a	; 26
    27e4:	80 83       	st	Z, r24
    27e6:	91 83       	std	Z+1, r25	; 0x01
    27e8:	a2 83       	std	Z+2, r26	; 0x02
    27ea:	b3 83       	std	Z+3, r27	; 0x03
    27ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    27ee:	9f 85       	ldd	r25, Y+15	; 0x0f
    27f0:	a8 89       	ldd	r26, Y+16	; 0x10
    27f2:	b9 89       	ldd	r27, Y+17	; 0x11
    27f4:	34 96       	adiw	r30, 0x04	; 4
    27f6:	80 83       	st	Z, r24
    27f8:	91 83       	std	Z+1, r25	; 0x01
    27fa:	a2 83       	std	Z+2, r26	; 0x02
    27fc:	b3 83       	std	Z+3, r27	; 0x03
    27fe:	8a 85       	ldd	r24, Y+10	; 0x0a
    2800:	9b 85       	ldd	r25, Y+11	; 0x0b
    2802:	ac 85       	ldd	r26, Y+12	; 0x0c
    2804:	bd 85       	ldd	r27, Y+13	; 0x0d
    2806:	34 96       	adiw	r30, 0x04	; 4
    2808:	80 83       	st	Z, r24
    280a:	91 83       	std	Z+1, r25	; 0x01
    280c:	a2 83       	std	Z+2, r26	; 0x02
    280e:	b3 83       	std	Z+3, r27	; 0x03
    2810:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2812:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2814:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2816:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2818:	9c 01       	movw	r18, r24
    281a:	ad 01       	movw	r20, r26
    281c:	2f 5f       	subi	r18, 0xFF	; 255
    281e:	3f 4f       	sbci	r19, 0xFF	; 255
    2820:	4f 4f       	sbci	r20, 0xFF	; 255
    2822:	5f 4f       	sbci	r21, 0xFF	; 255
    2824:	2a a7       	std	Y+42, r18	; 0x2a
    2826:	3b a7       	std	Y+43, r19	; 0x2b
    2828:	4c a7       	std	Y+44, r20	; 0x2c
    282a:	5d a7       	std	Y+45, r21	; 0x2d
    282c:	01 e0       	ldi	r16, 0x01	; 1
    282e:	10 e0       	ldi	r17, 0x00	; 0
    2830:	89 81       	ldd	r24, Y+1	; 0x01
    2832:	a5 dd       	rcall	.-1206   	; 0x237e <disk_write>
    2834:	1d 82       	std	Y+5, r1	; 0x05
    2836:	40 e0       	ldi	r20, 0x00	; 0
    2838:	50 e0       	ldi	r21, 0x00	; 0
    283a:	60 e0       	ldi	r22, 0x00	; 0
    283c:	89 81       	ldd	r24, Y+1	; 0x01
    283e:	ff dd       	rcall	.-1026   	; 0x243e <disk_ioctl>
    2840:	91 e0       	ldi	r25, 0x01	; 1
    2842:	81 11       	cpse	r24, r1
    2844:	01 c0       	rjmp	.+2      	; 0x2848 <sync_fs+0xc6>
    2846:	90 e0       	ldi	r25, 0x00	; 0
    2848:	89 2f       	mov	r24, r25
    284a:	df 91       	pop	r29
    284c:	cf 91       	pop	r28
    284e:	1f 91       	pop	r17
    2850:	0f 91       	pop	r16
    2852:	08 95       	ret

00002854 <move_window>:
    2854:	8f 92       	push	r8
    2856:	9f 92       	push	r9
    2858:	af 92       	push	r10
    285a:	bf 92       	push	r11
    285c:	ff 92       	push	r15
    285e:	0f 93       	push	r16
    2860:	1f 93       	push	r17
    2862:	cf 93       	push	r28
    2864:	df 93       	push	r29
    2866:	ec 01       	movw	r28, r24
    2868:	4a 01       	movw	r8, r20
    286a:	5b 01       	movw	r10, r22
    286c:	8a a5       	ldd	r24, Y+42	; 0x2a
    286e:	9b a5       	ldd	r25, Y+43	; 0x2b
    2870:	ac a5       	ldd	r26, Y+44	; 0x2c
    2872:	bd a5       	ldd	r27, Y+45	; 0x2d
    2874:	48 17       	cp	r20, r24
    2876:	59 07       	cpc	r21, r25
    2878:	6a 07       	cpc	r22, r26
    287a:	7b 07       	cpc	r23, r27
    287c:	d9 f0       	breq	.+54     	; 0x28b4 <move_window+0x60>
    287e:	ce 01       	movw	r24, r28
    2880:	21 df       	rcall	.-446    	; 0x26c4 <sync_window>
    2882:	f8 2e       	mov	r15, r24
    2884:	81 11       	cpse	r24, r1
    2886:	17 c0       	rjmp	.+46     	; 0x28b6 <move_window+0x62>
    2888:	01 e0       	ldi	r16, 0x01	; 1
    288a:	10 e0       	ldi	r17, 0x00	; 0
    288c:	a5 01       	movw	r20, r10
    288e:	94 01       	movw	r18, r8
    2890:	be 01       	movw	r22, r28
    2892:	62 5d       	subi	r22, 0xD2	; 210
    2894:	7f 4f       	sbci	r23, 0xFF	; 255
    2896:	89 81       	ldd	r24, Y+1	; 0x01
    2898:	2e dd       	rcall	.-1444   	; 0x22f6 <disk_read>
    289a:	88 23       	and	r24, r24
    289c:	31 f0       	breq	.+12     	; 0x28aa <move_window+0x56>
    289e:	ff 24       	eor	r15, r15
    28a0:	f3 94       	inc	r15
    28a2:	88 24       	eor	r8, r8
    28a4:	8a 94       	dec	r8
    28a6:	98 2c       	mov	r9, r8
    28a8:	54 01       	movw	r10, r8
    28aa:	8a a6       	std	Y+42, r8	; 0x2a
    28ac:	9b a6       	std	Y+43, r9	; 0x2b
    28ae:	ac a6       	std	Y+44, r10	; 0x2c
    28b0:	bd a6       	std	Y+45, r11	; 0x2d
    28b2:	01 c0       	rjmp	.+2      	; 0x28b6 <move_window+0x62>
    28b4:	f1 2c       	mov	r15, r1
    28b6:	8f 2d       	mov	r24, r15
    28b8:	df 91       	pop	r29
    28ba:	cf 91       	pop	r28
    28bc:	1f 91       	pop	r17
    28be:	0f 91       	pop	r16
    28c0:	ff 90       	pop	r15
    28c2:	bf 90       	pop	r11
    28c4:	af 90       	pop	r10
    28c6:	9f 90       	pop	r9
    28c8:	8f 90       	pop	r8
    28ca:	08 95       	ret

000028cc <check_fs>:
    28cc:	cf 93       	push	r28
    28ce:	df 93       	push	r29
    28d0:	ec 01       	movw	r28, r24
    28d2:	1c 82       	std	Y+4, r1	; 0x04
    28d4:	8f ef       	ldi	r24, 0xFF	; 255
    28d6:	9f ef       	ldi	r25, 0xFF	; 255
    28d8:	dc 01       	movw	r26, r24
    28da:	8a a7       	std	Y+42, r24	; 0x2a
    28dc:	9b a7       	std	Y+43, r25	; 0x2b
    28de:	ac a7       	std	Y+44, r26	; 0x2c
    28e0:	bd a7       	std	Y+45, r27	; 0x2d
    28e2:	ce 01       	movw	r24, r28
    28e4:	b7 df       	rcall	.-146    	; 0x2854 <move_window>
    28e6:	81 11       	cpse	r24, r1
    28e8:	22 c0       	rjmp	.+68     	; 0x292e <check_fs+0x62>
    28ea:	fe 01       	movw	r30, r28
    28ec:	e4 5d       	subi	r30, 0xD4	; 212
    28ee:	fd 4f       	sbci	r31, 0xFD	; 253
    28f0:	80 81       	ld	r24, Z
    28f2:	91 81       	ldd	r25, Z+1	; 0x01
    28f4:	85 35       	cpi	r24, 0x55	; 85
    28f6:	9a 4a       	sbci	r25, 0xAA	; 170
    28f8:	e1 f4       	brne	.+56     	; 0x2932 <check_fs+0x66>
    28fa:	e8 5c       	subi	r30, 0xC8	; 200
    28fc:	f1 40       	sbci	r31, 0x01	; 1
    28fe:	80 81       	ld	r24, Z
    2900:	91 81       	ldd	r25, Z+1	; 0x01
    2902:	a2 81       	ldd	r26, Z+2	; 0x02
    2904:	b3 81       	ldd	r27, Z+3	; 0x03
    2906:	bb 27       	eor	r27, r27
    2908:	86 34       	cpi	r24, 0x46	; 70
    290a:	91 44       	sbci	r25, 0x41	; 65
    290c:	a4 45       	sbci	r26, 0x54	; 84
    290e:	b1 05       	cpc	r27, r1
    2910:	91 f0       	breq	.+36     	; 0x2936 <check_fs+0x6a>
    2912:	c0 58       	subi	r28, 0x80	; 128
    2914:	df 4f       	sbci	r29, 0xFF	; 255
    2916:	48 81       	ld	r20, Y
    2918:	59 81       	ldd	r21, Y+1	; 0x01
    291a:	6a 81       	ldd	r22, Y+2	; 0x02
    291c:	7b 81       	ldd	r23, Y+3	; 0x03
    291e:	77 27       	eor	r23, r23
    2920:	81 e0       	ldi	r24, 0x01	; 1
    2922:	46 34       	cpi	r20, 0x46	; 70
    2924:	51 44       	sbci	r21, 0x41	; 65
    2926:	64 45       	sbci	r22, 0x54	; 84
    2928:	71 05       	cpc	r23, r1
    292a:	31 f4       	brne	.+12     	; 0x2938 <check_fs+0x6c>
    292c:	04 c0       	rjmp	.+8      	; 0x2936 <check_fs+0x6a>
    292e:	83 e0       	ldi	r24, 0x03	; 3
    2930:	03 c0       	rjmp	.+6      	; 0x2938 <check_fs+0x6c>
    2932:	82 e0       	ldi	r24, 0x02	; 2
    2934:	01 c0       	rjmp	.+2      	; 0x2938 <check_fs+0x6c>
    2936:	80 e0       	ldi	r24, 0x00	; 0
    2938:	df 91       	pop	r29
    293a:	cf 91       	pop	r28
    293c:	08 95       	ret

0000293e <find_volume>:
    293e:	2f 92       	push	r2
    2940:	3f 92       	push	r3
    2942:	4f 92       	push	r4
    2944:	5f 92       	push	r5
    2946:	6f 92       	push	r6
    2948:	7f 92       	push	r7
    294a:	8f 92       	push	r8
    294c:	9f 92       	push	r9
    294e:	af 92       	push	r10
    2950:	bf 92       	push	r11
    2952:	cf 92       	push	r12
    2954:	df 92       	push	r13
    2956:	ef 92       	push	r14
    2958:	ff 92       	push	r15
    295a:	0f 93       	push	r16
    295c:	1f 93       	push	r17
    295e:	cf 93       	push	r28
    2960:	df 93       	push	r29
    2962:	cd b7       	in	r28, 0x3d	; 61
    2964:	de b7       	in	r29, 0x3e	; 62
    2966:	6d 97       	sbiw	r28, 0x1d	; 29
    2968:	0f b6       	in	r0, 0x3f	; 63
    296a:	f8 94       	cli
    296c:	de bf       	out	0x3e, r29	; 62
    296e:	0f be       	out	0x3f, r0	; 63
    2970:	cd bf       	out	0x3d, r28	; 61
    2972:	5c 01       	movw	r10, r24
    2974:	cb 01       	movw	r24, r22
    2976:	d4 2e       	mov	r13, r20
    2978:	d5 01       	movw	r26, r10
    297a:	1d 92       	st	X+, r1
    297c:	1c 92       	st	X, r1
    297e:	65 de       	rcall	.-822    	; 0x264a <get_ldnumber>
    2980:	7c 01       	movw	r14, r24
    2982:	97 fd       	sbrc	r25, 7
    2984:	18 c2       	rjmp	.+1072   	; 0x2db6 <find_volume+0x478>
    2986:	fc 01       	movw	r30, r24
    2988:	ee 0f       	add	r30, r30
    298a:	ff 1f       	adc	r31, r31
    298c:	e6 5a       	subi	r30, 0xA6	; 166
    298e:	fa 4f       	sbci	r31, 0xFA	; 250
    2990:	00 81       	ld	r16, Z
    2992:	11 81       	ldd	r17, Z+1	; 0x01
    2994:	01 15       	cp	r16, r1
    2996:	11 05       	cpc	r17, r1
    2998:	09 f4       	brne	.+2      	; 0x299c <find_volume+0x5e>
    299a:	0f c2       	rjmp	.+1054   	; 0x2dba <find_volume+0x47c>
    299c:	f5 01       	movw	r30, r10
    299e:	11 83       	std	Z+1, r17	; 0x01
    29a0:	00 83       	st	Z, r16
    29a2:	d8 01       	movw	r26, r16
    29a4:	8c 91       	ld	r24, X
    29a6:	88 23       	and	r24, r24
    29a8:	61 f0       	breq	.+24     	; 0x29c2 <find_volume+0x84>
    29aa:	11 96       	adiw	r26, 0x01	; 1
    29ac:	8c 91       	ld	r24, X
    29ae:	fe db       	rcall	.-2052   	; 0x21ac <disk_status>
    29b0:	80 fd       	sbrc	r24, 0
    29b2:	07 c0       	rjmp	.+14     	; 0x29c2 <find_volume+0x84>
    29b4:	dd 20       	and	r13, r13
    29b6:	09 f4       	brne	.+2      	; 0x29ba <find_volume+0x7c>
    29b8:	02 c2       	rjmp	.+1028   	; 0x2dbe <find_volume+0x480>
    29ba:	82 ff       	sbrs	r24, 2
    29bc:	00 c2       	rjmp	.+1024   	; 0x2dbe <find_volume+0x480>
    29be:	8a e0       	ldi	r24, 0x0A	; 10
    29c0:	03 c2       	rjmp	.+1030   	; 0x2dc8 <find_volume+0x48a>
    29c2:	f8 01       	movw	r30, r16
    29c4:	10 82       	st	Z, r1
    29c6:	e1 82       	std	Z+1, r14	; 0x01
    29c8:	8e 2d       	mov	r24, r14
    29ca:	f7 db       	rcall	.-2066   	; 0x21ba <disk_initialize>
    29cc:	80 fd       	sbrc	r24, 0
    29ce:	f9 c1       	rjmp	.+1010   	; 0x2dc2 <find_volume+0x484>
    29d0:	dd 20       	and	r13, r13
    29d2:	11 f0       	breq	.+4      	; 0x29d8 <find_volume+0x9a>
    29d4:	82 fd       	sbrc	r24, 2
    29d6:	f3 cf       	rjmp	.-26     	; 0x29be <find_volume+0x80>
    29d8:	40 e0       	ldi	r20, 0x00	; 0
    29da:	50 e0       	ldi	r21, 0x00	; 0
    29dc:	ba 01       	movw	r22, r20
    29de:	c8 01       	movw	r24, r16
    29e0:	75 df       	rcall	.-278    	; 0x28cc <check_fs>
    29e2:	81 30       	cpi	r24, 0x01	; 1
    29e4:	c9 f5       	brne	.+114    	; 0x2a58 <find_volume+0x11a>
    29e6:	f8 01       	movw	r30, r16
    29e8:	e0 51       	subi	r30, 0x10	; 16
    29ea:	fe 4f       	sbci	r31, 0xFE	; 254
    29ec:	9e 01       	movw	r18, r28
    29ee:	2f 5f       	subi	r18, 0xFF	; 255
    29f0:	3f 4f       	sbci	r19, 0xFF	; 255
    29f2:	69 01       	movw	r12, r18
    29f4:	c8 01       	movw	r24, r16
    29f6:	80 5d       	subi	r24, 0xD0	; 208
    29f8:	9d 4f       	sbci	r25, 0xFD	; 253
    29fa:	d9 01       	movw	r26, r18
    29fc:	20 81       	ld	r18, Z
    29fe:	22 23       	and	r18, r18
    2a00:	29 f0       	breq	.+10     	; 0x2a0c <find_volume+0xce>
    2a02:	44 81       	ldd	r20, Z+4	; 0x04
    2a04:	55 81       	ldd	r21, Z+5	; 0x05
    2a06:	66 81       	ldd	r22, Z+6	; 0x06
    2a08:	77 81       	ldd	r23, Z+7	; 0x07
    2a0a:	03 c0       	rjmp	.+6      	; 0x2a12 <find_volume+0xd4>
    2a0c:	40 e0       	ldi	r20, 0x00	; 0
    2a0e:	50 e0       	ldi	r21, 0x00	; 0
    2a10:	ba 01       	movw	r22, r20
    2a12:	4d 93       	st	X+, r20
    2a14:	5d 93       	st	X+, r21
    2a16:	6d 93       	st	X+, r22
    2a18:	7d 93       	st	X+, r23
    2a1a:	70 96       	adiw	r30, 0x10	; 16
    2a1c:	e8 17       	cp	r30, r24
    2a1e:	f9 07       	cpc	r31, r25
    2a20:	69 f7       	brne	.-38     	; 0x29fc <find_volume+0xbe>
    2a22:	7e 01       	movw	r14, r28
    2a24:	31 e1       	ldi	r19, 0x11	; 17
    2a26:	e3 0e       	add	r14, r19
    2a28:	f1 1c       	adc	r15, r1
    2a2a:	d6 01       	movw	r26, r12
    2a2c:	4d 90       	ld	r4, X+
    2a2e:	5d 90       	ld	r5, X+
    2a30:	6d 90       	ld	r6, X+
    2a32:	7d 90       	ld	r7, X+
    2a34:	6d 01       	movw	r12, r26
    2a36:	41 14       	cp	r4, r1
    2a38:	51 04       	cpc	r5, r1
    2a3a:	61 04       	cpc	r6, r1
    2a3c:	71 04       	cpc	r7, r1
    2a3e:	39 f0       	breq	.+14     	; 0x2a4e <find_volume+0x110>
    2a40:	b3 01       	movw	r22, r6
    2a42:	a2 01       	movw	r20, r4
    2a44:	c8 01       	movw	r24, r16
    2a46:	42 df       	rcall	.-380    	; 0x28cc <check_fs>
    2a48:	81 11       	cpse	r24, r1
    2a4a:	02 c0       	rjmp	.+4      	; 0x2a50 <find_volume+0x112>
    2a4c:	0f c0       	rjmp	.+30     	; 0x2a6c <find_volume+0x12e>
    2a4e:	82 e0       	ldi	r24, 0x02	; 2
    2a50:	ce 14       	cp	r12, r14
    2a52:	df 04       	cpc	r13, r15
    2a54:	51 f7       	brne	.-44     	; 0x2a2a <find_volume+0xec>
    2a56:	03 c0       	rjmp	.+6      	; 0x2a5e <find_volume+0x120>
    2a58:	41 2c       	mov	r4, r1
    2a5a:	51 2c       	mov	r5, r1
    2a5c:	32 01       	movw	r6, r4
    2a5e:	83 30       	cpi	r24, 0x03	; 3
    2a60:	09 f4       	brne	.+2      	; 0x2a64 <find_volume+0x126>
    2a62:	b1 c1       	rjmp	.+866    	; 0x2dc6 <find_volume+0x488>
    2a64:	88 23       	and	r24, r24
    2a66:	11 f0       	breq	.+4      	; 0x2a6c <find_volume+0x12e>
    2a68:	8d e0       	ldi	r24, 0x0D	; 13
    2a6a:	ae c1       	rjmp	.+860    	; 0x2dc8 <find_volume+0x48a>
    2a6c:	f8 01       	movw	r30, r16
    2a6e:	81 ad       	ldd	r24, Z+57	; 0x39
    2a70:	92 ad       	ldd	r25, Z+58	; 0x3a
    2a72:	81 15       	cp	r24, r1
    2a74:	92 40       	sbci	r25, 0x02	; 2
    2a76:	c1 f7       	brne	.-16     	; 0x2a68 <find_volume+0x12a>
    2a78:	f8 01       	movw	r30, r16
    2a7a:	ec 5b       	subi	r30, 0xBC	; 188
    2a7c:	ff 4f       	sbci	r31, 0xFF	; 255
    2a7e:	80 80       	ld	r8, Z
    2a80:	91 80       	ldd	r9, Z+1	; 0x01
    2a82:	a1 2c       	mov	r10, r1
    2a84:	b1 2c       	mov	r11, r1
    2a86:	81 14       	cp	r8, r1
    2a88:	91 04       	cpc	r9, r1
    2a8a:	a1 04       	cpc	r10, r1
    2a8c:	b1 04       	cpc	r11, r1
    2a8e:	29 f4       	brne	.+10     	; 0x2a9a <find_volume+0x15c>
    2a90:	3e 96       	adiw	r30, 0x0e	; 14
    2a92:	80 80       	ld	r8, Z
    2a94:	91 80       	ldd	r9, Z+1	; 0x01
    2a96:	a2 80       	ldd	r10, Z+2	; 0x02
    2a98:	b3 80       	ldd	r11, Z+3	; 0x03
    2a9a:	d8 01       	movw	r26, r16
    2a9c:	56 96       	adiw	r26, 0x16	; 22
    2a9e:	8d 92       	st	X+, r8
    2aa0:	9d 92       	st	X+, r9
    2aa2:	ad 92       	st	X+, r10
    2aa4:	bc 92       	st	X, r11
    2aa6:	59 97       	sbiw	r26, 0x19	; 25
    2aa8:	de 96       	adiw	r26, 0x3e	; 62
    2aaa:	4c 91       	ld	r20, X
    2aac:	de 97       	sbiw	r26, 0x3e	; 62
    2aae:	13 96       	adiw	r26, 0x03	; 3
    2ab0:	4c 93       	st	X, r20
    2ab2:	13 97       	sbiw	r26, 0x03	; 3
    2ab4:	8f ef       	ldi	r24, 0xFF	; 255
    2ab6:	84 0f       	add	r24, r20
    2ab8:	82 30       	cpi	r24, 0x02	; 2
    2aba:	b0 f6       	brcc	.-84     	; 0x2a68 <find_volume+0x12a>
    2abc:	db 96       	adiw	r26, 0x3b	; 59
    2abe:	ec 91       	ld	r30, X
    2ac0:	db 97       	sbiw	r26, 0x3b	; 59
    2ac2:	e9 8b       	std	Y+17, r30	; 0x11
    2ac4:	12 96       	adiw	r26, 0x02	; 2
    2ac6:	ec 93       	st	X, r30
    2ac8:	12 97       	sbiw	r26, 0x02	; 2
    2aca:	ee 23       	and	r30, r30
    2acc:	69 f2       	breq	.-102    	; 0x2a68 <find_volume+0x12a>
    2ace:	8e 2f       	mov	r24, r30
    2ad0:	90 e0       	ldi	r25, 0x00	; 0
    2ad2:	9c 01       	movw	r18, r24
    2ad4:	21 50       	subi	r18, 0x01	; 1
    2ad6:	31 09       	sbc	r19, r1
    2ad8:	82 23       	and	r24, r18
    2ada:	93 23       	and	r25, r19
    2adc:	89 2b       	or	r24, r25
    2ade:	21 f6       	brne	.-120    	; 0x2a68 <find_volume+0x12a>
    2ae0:	f8 01       	movw	r30, r16
    2ae2:	ff 96       	adiw	r30, 0x3f	; 63
    2ae4:	20 80       	ld	r2, Z
    2ae6:	31 80       	ldd	r3, Z+1	; 0x01
    2ae8:	19 96       	adiw	r26, 0x09	; 9
    2aea:	3c 92       	st	X, r3
    2aec:	2e 92       	st	-X, r2
    2aee:	18 97       	sbiw	r26, 0x08	; 8
    2af0:	c1 01       	movw	r24, r2
    2af2:	8f 70       	andi	r24, 0x0F	; 15
    2af4:	99 27       	eor	r25, r25
    2af6:	89 2b       	or	r24, r25
    2af8:	09 f0       	breq	.+2      	; 0x2afc <find_volume+0x1be>
    2afa:	b6 cf       	rjmp	.-148    	; 0x2a68 <find_volume+0x12a>
    2afc:	32 96       	adiw	r30, 0x02	; 2
    2afe:	c0 80       	ld	r12, Z
    2b00:	d1 80       	ldd	r13, Z+1	; 0x01
    2b02:	e1 2c       	mov	r14, r1
    2b04:	f1 2c       	mov	r15, r1
    2b06:	c1 14       	cp	r12, r1
    2b08:	d1 04       	cpc	r13, r1
    2b0a:	e1 04       	cpc	r14, r1
    2b0c:	f1 04       	cpc	r15, r1
    2b0e:	29 f4       	brne	.+10     	; 0x2b1a <find_volume+0x1dc>
    2b10:	3d 96       	adiw	r30, 0x0d	; 13
    2b12:	c0 80       	ld	r12, Z
    2b14:	d1 80       	ldd	r13, Z+1	; 0x01
    2b16:	e2 80       	ldd	r14, Z+2	; 0x02
    2b18:	f3 80       	ldd	r15, Z+3	; 0x03
    2b1a:	d8 01       	movw	r26, r16
    2b1c:	dc 96       	adiw	r26, 0x3c	; 60
    2b1e:	ed 91       	ld	r30, X+
    2b20:	fc 91       	ld	r31, X
    2b22:	dd 97       	sbiw	r26, 0x3d	; 61
    2b24:	30 97       	sbiw	r30, 0x00	; 0
    2b26:	09 f4       	brne	.+2      	; 0x2b2a <find_volume+0x1ec>
    2b28:	9f cf       	rjmp	.-194    	; 0x2a68 <find_volume+0x12a>
    2b2a:	a4 2f       	mov	r26, r20
    2b2c:	b0 e0       	ldi	r27, 0x00	; 0
    2b2e:	a5 01       	movw	r20, r10
    2b30:	94 01       	movw	r18, r8
    2b32:	0e 94 3a 37 	call	0x6e74	; 0x6e74 <__muluhisi3>
    2b36:	6e 8b       	std	Y+22, r22	; 0x16
    2b38:	7f 8b       	std	Y+23, r23	; 0x17
    2b3a:	88 8f       	std	Y+24, r24	; 0x18
    2b3c:	99 8f       	std	Y+25, r25	; 0x19
    2b3e:	9f 01       	movw	r18, r30
    2b40:	40 e0       	ldi	r20, 0x00	; 0
    2b42:	50 e0       	ldi	r21, 0x00	; 0
    2b44:	2a 8f       	std	Y+26, r18	; 0x1a
    2b46:	3b 8f       	std	Y+27, r19	; 0x1b
    2b48:	4c 8f       	std	Y+28, r20	; 0x1c
    2b4a:	5d 8f       	std	Y+29, r21	; 0x1d
    2b4c:	c1 01       	movw	r24, r2
    2b4e:	64 e0       	ldi	r22, 0x04	; 4
    2b50:	96 95       	lsr	r25
    2b52:	87 95       	ror	r24
    2b54:	6a 95       	dec	r22
    2b56:	e1 f7       	brne	.-8      	; 0x2b50 <find_volume+0x212>
    2b58:	28 0f       	add	r18, r24
    2b5a:	39 1f       	adc	r19, r25
    2b5c:	41 1d       	adc	r20, r1
    2b5e:	51 1d       	adc	r21, r1
    2b60:	da 01       	movw	r26, r20
    2b62:	c9 01       	movw	r24, r18
    2b64:	2e 89       	ldd	r18, Y+22	; 0x16
    2b66:	3f 89       	ldd	r19, Y+23	; 0x17
    2b68:	48 8d       	ldd	r20, Y+24	; 0x18
    2b6a:	59 8d       	ldd	r21, Y+25	; 0x19
    2b6c:	28 0f       	add	r18, r24
    2b6e:	39 1f       	adc	r19, r25
    2b70:	4a 1f       	adc	r20, r26
    2b72:	5b 1f       	adc	r21, r27
    2b74:	2a 8b       	std	Y+18, r18	; 0x12
    2b76:	3b 8b       	std	Y+19, r19	; 0x13
    2b78:	4c 8b       	std	Y+20, r20	; 0x14
    2b7a:	5d 8b       	std	Y+21, r21	; 0x15
    2b7c:	c2 16       	cp	r12, r18
    2b7e:	d3 06       	cpc	r13, r19
    2b80:	e4 06       	cpc	r14, r20
    2b82:	f5 06       	cpc	r15, r21
    2b84:	08 f4       	brcc	.+2      	; 0x2b88 <find_volume+0x24a>
    2b86:	70 cf       	rjmp	.-288    	; 0x2a68 <find_volume+0x12a>
    2b88:	c7 01       	movw	r24, r14
    2b8a:	b6 01       	movw	r22, r12
    2b8c:	62 1b       	sub	r22, r18
    2b8e:	73 0b       	sbc	r23, r19
    2b90:	84 0b       	sbc	r24, r20
    2b92:	95 0b       	sbc	r25, r21
    2b94:	e9 89       	ldd	r30, Y+17	; 0x11
    2b96:	2e 2f       	mov	r18, r30
    2b98:	30 e0       	ldi	r19, 0x00	; 0
    2b9a:	40 e0       	ldi	r20, 0x00	; 0
    2b9c:	50 e0       	ldi	r21, 0x00	; 0
    2b9e:	0e 94 18 37 	call	0x6e30	; 0x6e30 <__udivmodsi4>
    2ba2:	21 15       	cp	r18, r1
    2ba4:	31 05       	cpc	r19, r1
    2ba6:	41 05       	cpc	r20, r1
    2ba8:	51 05       	cpc	r21, r1
    2baa:	09 f4       	brne	.+2      	; 0x2bae <find_volume+0x270>
    2bac:	5d cf       	rjmp	.-326    	; 0x2a68 <find_volume+0x12a>
    2bae:	26 3f       	cpi	r18, 0xF6	; 246
    2bb0:	ff e0       	ldi	r31, 0x0F	; 15
    2bb2:	3f 07       	cpc	r19, r31
    2bb4:	41 05       	cpc	r20, r1
    2bb6:	51 05       	cpc	r21, r1
    2bb8:	48 f0       	brcs	.+18     	; 0x2bcc <find_volume+0x28e>
    2bba:	26 3f       	cpi	r18, 0xF6	; 246
    2bbc:	8f ef       	ldi	r24, 0xFF	; 255
    2bbe:	38 07       	cpc	r19, r24
    2bc0:	41 05       	cpc	r20, r1
    2bc2:	51 05       	cpc	r21, r1
    2bc4:	30 f4       	brcc	.+12     	; 0x2bd2 <find_volume+0x294>
    2bc6:	92 e0       	ldi	r25, 0x02	; 2
    2bc8:	99 8b       	std	Y+17, r25	; 0x11
    2bca:	05 c0       	rjmp	.+10     	; 0x2bd6 <find_volume+0x298>
    2bcc:	a1 e0       	ldi	r26, 0x01	; 1
    2bce:	a9 8b       	std	Y+17, r26	; 0x11
    2bd0:	02 c0       	rjmp	.+4      	; 0x2bd6 <find_volume+0x298>
    2bd2:	b3 e0       	ldi	r27, 0x03	; 3
    2bd4:	b9 8b       	std	Y+17, r27	; 0x11
    2bd6:	69 01       	movw	r12, r18
    2bd8:	7a 01       	movw	r14, r20
    2bda:	e2 e0       	ldi	r30, 0x02	; 2
    2bdc:	ce 0e       	add	r12, r30
    2bde:	d1 1c       	adc	r13, r1
    2be0:	e1 1c       	adc	r14, r1
    2be2:	f1 1c       	adc	r15, r1
    2be4:	d8 01       	movw	r26, r16
    2be6:	52 96       	adiw	r26, 0x12	; 18
    2be8:	cd 92       	st	X+, r12
    2bea:	dd 92       	st	X+, r13
    2bec:	ed 92       	st	X+, r14
    2bee:	fc 92       	st	X, r15
    2bf0:	55 97       	sbiw	r26, 0x15	; 21
    2bf2:	f8 01       	movw	r30, r16
    2bf4:	42 8e       	std	Z+26, r4	; 0x1a
    2bf6:	53 8e       	std	Z+27, r5	; 0x1b
    2bf8:	64 8e       	std	Z+28, r6	; 0x1c
    2bfa:	75 8e       	std	Z+29, r7	; 0x1d
    2bfc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2bfe:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2c00:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2c02:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2c04:	84 0d       	add	r24, r4
    2c06:	95 1d       	adc	r25, r5
    2c08:	a6 1d       	adc	r26, r6
    2c0a:	b7 1d       	adc	r27, r7
    2c0c:	86 8f       	std	Z+30, r24	; 0x1e
    2c0e:	97 8f       	std	Z+31, r25	; 0x1f
    2c10:	a0 a3       	std	Z+32, r26	; 0x20
    2c12:	b1 a3       	std	Z+33, r27	; 0x21
    2c14:	4a 89       	ldd	r20, Y+18	; 0x12
    2c16:	5b 89       	ldd	r21, Y+19	; 0x13
    2c18:	6c 89       	ldd	r22, Y+20	; 0x14
    2c1a:	7d 89       	ldd	r23, Y+21	; 0x15
    2c1c:	44 0d       	add	r20, r4
    2c1e:	55 1d       	adc	r21, r5
    2c20:	66 1d       	adc	r22, r6
    2c22:	77 1d       	adc	r23, r7
    2c24:	46 a3       	std	Z+38, r20	; 0x26
    2c26:	57 a3       	std	Z+39, r21	; 0x27
    2c28:	60 a7       	std	Z+40, r22	; 0x28
    2c2a:	71 a7       	std	Z+41, r23	; 0x29
    2c2c:	f9 89       	ldd	r31, Y+17	; 0x11
    2c2e:	f3 30       	cpi	r31, 0x03	; 3
    2c30:	b9 f4       	brne	.+46     	; 0x2c60 <find_volume+0x322>
    2c32:	23 28       	or	r2, r3
    2c34:	09 f0       	breq	.+2      	; 0x2c38 <find_volume+0x2fa>
    2c36:	18 cf       	rjmp	.-464    	; 0x2a68 <find_volume+0x12a>
    2c38:	f8 01       	movw	r30, r16
    2c3a:	e6 5a       	subi	r30, 0xA6	; 166
    2c3c:	ff 4f       	sbci	r31, 0xFF	; 255
    2c3e:	80 81       	ld	r24, Z
    2c40:	91 81       	ldd	r25, Z+1	; 0x01
    2c42:	a2 81       	ldd	r26, Z+2	; 0x02
    2c44:	b3 81       	ldd	r27, Z+3	; 0x03
    2c46:	f8 01       	movw	r30, r16
    2c48:	82 a3       	std	Z+34, r24	; 0x22
    2c4a:	93 a3       	std	Z+35, r25	; 0x23
    2c4c:	a4 a3       	std	Z+36, r26	; 0x24
    2c4e:	b5 a3       	std	Z+37, r27	; 0x25
    2c50:	42 e0       	ldi	r20, 0x02	; 2
    2c52:	cc 0c       	add	r12, r12
    2c54:	dd 1c       	adc	r13, r13
    2c56:	ee 1c       	adc	r14, r14
    2c58:	ff 1c       	adc	r15, r15
    2c5a:	4a 95       	dec	r20
    2c5c:	d1 f7       	brne	.-12     	; 0x2c52 <find_volume+0x314>
    2c5e:	2d c0       	rjmp	.+90     	; 0x2cba <find_volume+0x37c>
    2c60:	23 28       	or	r2, r3
    2c62:	09 f4       	brne	.+2      	; 0x2c66 <find_volume+0x328>
    2c64:	01 cf       	rjmp	.-510    	; 0x2a68 <find_volume+0x12a>
    2c66:	2e 89       	ldd	r18, Y+22	; 0x16
    2c68:	3f 89       	ldd	r19, Y+23	; 0x17
    2c6a:	48 8d       	ldd	r20, Y+24	; 0x18
    2c6c:	59 8d       	ldd	r21, Y+25	; 0x19
    2c6e:	82 0f       	add	r24, r18
    2c70:	93 1f       	adc	r25, r19
    2c72:	a4 1f       	adc	r26, r20
    2c74:	b5 1f       	adc	r27, r21
    2c76:	f8 01       	movw	r30, r16
    2c78:	82 a3       	std	Z+34, r24	; 0x22
    2c7a:	93 a3       	std	Z+35, r25	; 0x23
    2c7c:	a4 a3       	std	Z+36, r26	; 0x24
    2c7e:	b5 a3       	std	Z+37, r27	; 0x25
    2c80:	f9 89       	ldd	r31, Y+17	; 0x11
    2c82:	f2 30       	cpi	r31, 0x02	; 2
    2c84:	29 f4       	brne	.+10     	; 0x2c90 <find_volume+0x352>
    2c86:	cc 0c       	add	r12, r12
    2c88:	dd 1c       	adc	r13, r13
    2c8a:	ee 1c       	adc	r14, r14
    2c8c:	ff 1c       	adc	r15, r15
    2c8e:	15 c0       	rjmp	.+42     	; 0x2cba <find_volume+0x37c>
    2c90:	a3 e0       	ldi	r26, 0x03	; 3
    2c92:	b0 e0       	ldi	r27, 0x00	; 0
    2c94:	a7 01       	movw	r20, r14
    2c96:	96 01       	movw	r18, r12
    2c98:	0e 94 3a 37 	call	0x6e74	; 0x6e74 <__muluhisi3>
    2c9c:	dc 01       	movw	r26, r24
    2c9e:	cb 01       	movw	r24, r22
    2ca0:	b6 95       	lsr	r27
    2ca2:	a7 95       	ror	r26
    2ca4:	97 95       	ror	r25
    2ca6:	87 95       	ror	r24
    2ca8:	21 e0       	ldi	r18, 0x01	; 1
    2caa:	c2 22       	and	r12, r18
    2cac:	dd 24       	eor	r13, r13
    2cae:	ee 24       	eor	r14, r14
    2cb0:	ff 24       	eor	r15, r15
    2cb2:	c8 0e       	add	r12, r24
    2cb4:	d9 1e       	adc	r13, r25
    2cb6:	ea 1e       	adc	r14, r26
    2cb8:	fb 1e       	adc	r15, r27
    2cba:	3f ef       	ldi	r19, 0xFF	; 255
    2cbc:	c3 0e       	add	r12, r19
    2cbe:	31 e0       	ldi	r19, 0x01	; 1
    2cc0:	d3 1e       	adc	r13, r19
    2cc2:	e1 1c       	adc	r14, r1
    2cc4:	f1 1c       	adc	r15, r1
    2cc6:	89 e0       	ldi	r24, 0x09	; 9
    2cc8:	f6 94       	lsr	r15
    2cca:	e7 94       	ror	r14
    2ccc:	d7 94       	ror	r13
    2cce:	c7 94       	ror	r12
    2cd0:	8a 95       	dec	r24
    2cd2:	d1 f7       	brne	.-12     	; 0x2cc8 <find_volume+0x38a>
    2cd4:	8c 14       	cp	r8, r12
    2cd6:	9d 04       	cpc	r9, r13
    2cd8:	ae 04       	cpc	r10, r14
    2cda:	bf 04       	cpc	r11, r15
    2cdc:	08 f4       	brcc	.+2      	; 0x2ce0 <find_volume+0x3a2>
    2cde:	c4 ce       	rjmp	.-632    	; 0x2a68 <find_volume+0x12a>
    2ce0:	8f ef       	ldi	r24, 0xFF	; 255
    2ce2:	9f ef       	ldi	r25, 0xFF	; 255
    2ce4:	dc 01       	movw	r26, r24
    2ce6:	f8 01       	movw	r30, r16
    2ce8:	86 87       	std	Z+14, r24	; 0x0e
    2cea:	97 87       	std	Z+15, r25	; 0x0f
    2cec:	a0 8b       	std	Z+16, r26	; 0x10
    2cee:	b1 8b       	std	Z+17, r27	; 0x11
    2cf0:	82 87       	std	Z+10, r24	; 0x0a
    2cf2:	93 87       	std	Z+11, r25	; 0x0b
    2cf4:	a4 87       	std	Z+12, r26	; 0x0c
    2cf6:	b5 87       	std	Z+13, r27	; 0x0d
    2cf8:	80 e8       	ldi	r24, 0x80	; 128
    2cfa:	85 83       	std	Z+5, r24	; 0x05
    2cfc:	f9 89       	ldd	r31, Y+17	; 0x11
    2cfe:	f3 30       	cpi	r31, 0x03	; 3
    2d00:	09 f0       	breq	.+2      	; 0x2d04 <find_volume+0x3c6>
    2d02:	48 c0       	rjmp	.+144    	; 0x2d94 <find_volume+0x456>
    2d04:	f8 01       	movw	r30, r16
    2d06:	e2 5a       	subi	r30, 0xA2	; 162
    2d08:	ff 4f       	sbci	r31, 0xFF	; 255
    2d0a:	80 81       	ld	r24, Z
    2d0c:	91 81       	ldd	r25, Z+1	; 0x01
    2d0e:	01 97       	sbiw	r24, 0x01	; 1
    2d10:	09 f0       	breq	.+2      	; 0x2d14 <find_volume+0x3d6>
    2d12:	40 c0       	rjmp	.+128    	; 0x2d94 <find_volume+0x456>
    2d14:	b3 01       	movw	r22, r6
    2d16:	a2 01       	movw	r20, r4
    2d18:	4f 5f       	subi	r20, 0xFF	; 255
    2d1a:	5f 4f       	sbci	r21, 0xFF	; 255
    2d1c:	6f 4f       	sbci	r22, 0xFF	; 255
    2d1e:	7f 4f       	sbci	r23, 0xFF	; 255
    2d20:	c8 01       	movw	r24, r16
    2d22:	98 dd       	rcall	.-1232   	; 0x2854 <move_window>
    2d24:	81 11       	cpse	r24, r1
    2d26:	36 c0       	rjmp	.+108    	; 0x2d94 <find_volume+0x456>
    2d28:	d8 01       	movw	r26, r16
    2d2a:	15 96       	adiw	r26, 0x05	; 5
    2d2c:	1c 92       	st	X, r1
    2d2e:	f8 01       	movw	r30, r16
    2d30:	e4 5d       	subi	r30, 0xD4	; 212
    2d32:	fd 4f       	sbci	r31, 0xFD	; 253
    2d34:	80 81       	ld	r24, Z
    2d36:	91 81       	ldd	r25, Z+1	; 0x01
    2d38:	85 35       	cpi	r24, 0x55	; 85
    2d3a:	9a 4a       	sbci	r25, 0xAA	; 170
    2d3c:	59 f5       	brne	.+86     	; 0x2d94 <find_volume+0x456>
    2d3e:	f8 01       	movw	r30, r16
    2d40:	86 a5       	ldd	r24, Z+46	; 0x2e
    2d42:	97 a5       	ldd	r25, Z+47	; 0x2f
    2d44:	a0 a9       	ldd	r26, Z+48	; 0x30
    2d46:	b1 a9       	ldd	r27, Z+49	; 0x31
    2d48:	82 35       	cpi	r24, 0x52	; 82
    2d4a:	92 45       	sbci	r25, 0x52	; 82
    2d4c:	a1 46       	sbci	r26, 0x61	; 97
    2d4e:	b1 44       	sbci	r27, 0x41	; 65
    2d50:	09 f5       	brne	.+66     	; 0x2d94 <find_volume+0x456>
    2d52:	f8 01       	movw	r30, r16
    2d54:	ee 5e       	subi	r30, 0xEE	; 238
    2d56:	fd 4f       	sbci	r31, 0xFD	; 253
    2d58:	80 81       	ld	r24, Z
    2d5a:	91 81       	ldd	r25, Z+1	; 0x01
    2d5c:	a2 81       	ldd	r26, Z+2	; 0x02
    2d5e:	b3 81       	ldd	r27, Z+3	; 0x03
    2d60:	82 37       	cpi	r24, 0x72	; 114
    2d62:	92 47       	sbci	r25, 0x72	; 114
    2d64:	a1 44       	sbci	r26, 0x41	; 65
    2d66:	b1 46       	sbci	r27, 0x61	; 97
    2d68:	a9 f4       	brne	.+42     	; 0x2d94 <find_volume+0x456>
    2d6a:	34 96       	adiw	r30, 0x04	; 4
    2d6c:	80 81       	ld	r24, Z
    2d6e:	91 81       	ldd	r25, Z+1	; 0x01
    2d70:	a2 81       	ldd	r26, Z+2	; 0x02
    2d72:	b3 81       	ldd	r27, Z+3	; 0x03
    2d74:	f8 01       	movw	r30, r16
    2d76:	86 87       	std	Z+14, r24	; 0x0e
    2d78:	97 87       	std	Z+15, r25	; 0x0f
    2d7a:	a0 8b       	std	Z+16, r26	; 0x10
    2d7c:	b1 8b       	std	Z+17, r27	; 0x11
    2d7e:	e6 5e       	subi	r30, 0xE6	; 230
    2d80:	fd 4f       	sbci	r31, 0xFD	; 253
    2d82:	80 81       	ld	r24, Z
    2d84:	91 81       	ldd	r25, Z+1	; 0x01
    2d86:	a2 81       	ldd	r26, Z+2	; 0x02
    2d88:	b3 81       	ldd	r27, Z+3	; 0x03
    2d8a:	f8 01       	movw	r30, r16
    2d8c:	82 87       	std	Z+10, r24	; 0x0a
    2d8e:	93 87       	std	Z+11, r25	; 0x0b
    2d90:	a4 87       	std	Z+12, r26	; 0x0c
    2d92:	b5 87       	std	Z+13, r27	; 0x0d
    2d94:	e9 89       	ldd	r30, Y+17	; 0x11
    2d96:	d8 01       	movw	r26, r16
    2d98:	ec 93       	st	X, r30
    2d9a:	80 91 58 05 	lds	r24, 0x0558
    2d9e:	90 91 59 05 	lds	r25, 0x0559
    2da2:	01 96       	adiw	r24, 0x01	; 1
    2da4:	90 93 59 05 	sts	0x0559, r25
    2da8:	80 93 58 05 	sts	0x0558, r24
    2dac:	17 96       	adiw	r26, 0x07	; 7
    2dae:	9c 93       	st	X, r25
    2db0:	8e 93       	st	-X, r24
    2db2:	16 97       	sbiw	r26, 0x06	; 6
    2db4:	04 c0       	rjmp	.+8      	; 0x2dbe <find_volume+0x480>
    2db6:	8b e0       	ldi	r24, 0x0B	; 11
    2db8:	07 c0       	rjmp	.+14     	; 0x2dc8 <find_volume+0x48a>
    2dba:	8c e0       	ldi	r24, 0x0C	; 12
    2dbc:	05 c0       	rjmp	.+10     	; 0x2dc8 <find_volume+0x48a>
    2dbe:	80 e0       	ldi	r24, 0x00	; 0
    2dc0:	03 c0       	rjmp	.+6      	; 0x2dc8 <find_volume+0x48a>
    2dc2:	83 e0       	ldi	r24, 0x03	; 3
    2dc4:	01 c0       	rjmp	.+2      	; 0x2dc8 <find_volume+0x48a>
    2dc6:	81 e0       	ldi	r24, 0x01	; 1
    2dc8:	6d 96       	adiw	r28, 0x1d	; 29
    2dca:	0f b6       	in	r0, 0x3f	; 63
    2dcc:	f8 94       	cli
    2dce:	de bf       	out	0x3e, r29	; 62
    2dd0:	0f be       	out	0x3f, r0	; 63
    2dd2:	cd bf       	out	0x3d, r28	; 61
    2dd4:	df 91       	pop	r29
    2dd6:	cf 91       	pop	r28
    2dd8:	1f 91       	pop	r17
    2dda:	0f 91       	pop	r16
    2ddc:	ff 90       	pop	r15
    2dde:	ef 90       	pop	r14
    2de0:	df 90       	pop	r13
    2de2:	cf 90       	pop	r12
    2de4:	bf 90       	pop	r11
    2de6:	af 90       	pop	r10
    2de8:	9f 90       	pop	r9
    2dea:	8f 90       	pop	r8
    2dec:	7f 90       	pop	r7
    2dee:	6f 90       	pop	r6
    2df0:	5f 90       	pop	r5
    2df2:	4f 90       	pop	r4
    2df4:	3f 90       	pop	r3
    2df6:	2f 90       	pop	r2
    2df8:	08 95       	ret

00002dfa <clust2sect>:
    2dfa:	0f 93       	push	r16
    2dfc:	1f 93       	push	r17
    2dfe:	fc 01       	movw	r30, r24
    2e00:	9a 01       	movw	r18, r20
    2e02:	ab 01       	movw	r20, r22
    2e04:	22 50       	subi	r18, 0x02	; 2
    2e06:	31 09       	sbc	r19, r1
    2e08:	41 09       	sbc	r20, r1
    2e0a:	51 09       	sbc	r21, r1
    2e0c:	82 89       	ldd	r24, Z+18	; 0x12
    2e0e:	93 89       	ldd	r25, Z+19	; 0x13
    2e10:	a4 89       	ldd	r26, Z+20	; 0x14
    2e12:	b5 89       	ldd	r27, Z+21	; 0x15
    2e14:	02 97       	sbiw	r24, 0x02	; 2
    2e16:	a1 09       	sbc	r26, r1
    2e18:	b1 09       	sbc	r27, r1
    2e1a:	28 17       	cp	r18, r24
    2e1c:	39 07       	cpc	r19, r25
    2e1e:	4a 07       	cpc	r20, r26
    2e20:	5b 07       	cpc	r21, r27
    2e22:	68 f4       	brcc	.+26     	; 0x2e3e <clust2sect+0x44>
    2e24:	a2 81       	ldd	r26, Z+2	; 0x02
    2e26:	b0 e0       	ldi	r27, 0x00	; 0
    2e28:	0e 94 3a 37 	call	0x6e74	; 0x6e74 <__muluhisi3>
    2e2c:	06 a1       	ldd	r16, Z+38	; 0x26
    2e2e:	17 a1       	ldd	r17, Z+39	; 0x27
    2e30:	20 a5       	ldd	r18, Z+40	; 0x28
    2e32:	31 a5       	ldd	r19, Z+41	; 0x29
    2e34:	60 0f       	add	r22, r16
    2e36:	71 1f       	adc	r23, r17
    2e38:	82 1f       	adc	r24, r18
    2e3a:	93 1f       	adc	r25, r19
    2e3c:	03 c0       	rjmp	.+6      	; 0x2e44 <clust2sect+0x4a>
    2e3e:	60 e0       	ldi	r22, 0x00	; 0
    2e40:	70 e0       	ldi	r23, 0x00	; 0
    2e42:	cb 01       	movw	r24, r22
    2e44:	1f 91       	pop	r17
    2e46:	0f 91       	pop	r16
    2e48:	08 95       	ret

00002e4a <get_fat>:
    2e4a:	af 92       	push	r10
    2e4c:	bf 92       	push	r11
    2e4e:	cf 92       	push	r12
    2e50:	df 92       	push	r13
    2e52:	ef 92       	push	r14
    2e54:	ff 92       	push	r15
    2e56:	0f 93       	push	r16
    2e58:	1f 93       	push	r17
    2e5a:	cf 93       	push	r28
    2e5c:	df 93       	push	r29
    2e5e:	8c 01       	movw	r16, r24
    2e60:	6a 01       	movw	r12, r20
    2e62:	7b 01       	movw	r14, r22
    2e64:	42 30       	cpi	r20, 0x02	; 2
    2e66:	51 05       	cpc	r21, r1
    2e68:	61 05       	cpc	r22, r1
    2e6a:	71 05       	cpc	r23, r1
    2e6c:	08 f4       	brcc	.+2      	; 0x2e70 <get_fat+0x26>
    2e6e:	a9 c0       	rjmp	.+338    	; 0x2fc2 <get_fat+0x178>
    2e70:	f8 01       	movw	r30, r16
    2e72:	82 89       	ldd	r24, Z+18	; 0x12
    2e74:	93 89       	ldd	r25, Z+19	; 0x13
    2e76:	a4 89       	ldd	r26, Z+20	; 0x14
    2e78:	b5 89       	ldd	r27, Z+21	; 0x15
    2e7a:	48 17       	cp	r20, r24
    2e7c:	59 07       	cpc	r21, r25
    2e7e:	6a 07       	cpc	r22, r26
    2e80:	7b 07       	cpc	r23, r27
    2e82:	08 f0       	brcs	.+2      	; 0x2e86 <get_fat+0x3c>
    2e84:	9e c0       	rjmp	.+316    	; 0x2fc2 <get_fat+0x178>
    2e86:	80 81       	ld	r24, Z
    2e88:	82 30       	cpi	r24, 0x02	; 2
    2e8a:	09 f4       	brne	.+2      	; 0x2e8e <get_fat+0x44>
    2e8c:	4b c0       	rjmp	.+150    	; 0x2f24 <get_fat+0xda>
    2e8e:	83 30       	cpi	r24, 0x03	; 3
    2e90:	09 f4       	brne	.+2      	; 0x2e94 <get_fat+0x4a>
    2e92:	6b c0       	rjmp	.+214    	; 0x2f6a <get_fat+0x120>
    2e94:	81 30       	cpi	r24, 0x01	; 1
    2e96:	09 f0       	breq	.+2      	; 0x2e9a <get_fat+0x50>
    2e98:	94 c0       	rjmp	.+296    	; 0x2fc2 <get_fat+0x178>
    2e9a:	ea 01       	movw	r28, r20
    2e9c:	d6 95       	lsr	r29
    2e9e:	c7 95       	ror	r28
    2ea0:	cc 0d       	add	r28, r12
    2ea2:	dd 1d       	adc	r29, r13
    2ea4:	ce 01       	movw	r24, r28
    2ea6:	89 2f       	mov	r24, r25
    2ea8:	99 27       	eor	r25, r25
    2eaa:	86 95       	lsr	r24
    2eac:	46 8d       	ldd	r20, Z+30	; 0x1e
    2eae:	57 8d       	ldd	r21, Z+31	; 0x1f
    2eb0:	60 a1       	ldd	r22, Z+32	; 0x20
    2eb2:	71 a1       	ldd	r23, Z+33	; 0x21
    2eb4:	48 0f       	add	r20, r24
    2eb6:	59 1f       	adc	r21, r25
    2eb8:	61 1d       	adc	r22, r1
    2eba:	71 1d       	adc	r23, r1
    2ebc:	c8 01       	movw	r24, r16
    2ebe:	ca dc       	rcall	.-1644   	; 0x2854 <move_window>
    2ec0:	88 23       	and	r24, r24
    2ec2:	21 f0       	breq	.+8      	; 0x2ecc <get_fat+0x82>
    2ec4:	6f ef       	ldi	r22, 0xFF	; 255
    2ec6:	7f ef       	ldi	r23, 0xFF	; 255
    2ec8:	cb 01       	movw	r24, r22
    2eca:	7f c0       	rjmp	.+254    	; 0x2fca <get_fat+0x180>
    2ecc:	5e 01       	movw	r10, r28
    2ece:	ff ef       	ldi	r31, 0xFF	; 255
    2ed0:	af 1a       	sub	r10, r31
    2ed2:	bf 0a       	sbc	r11, r31
    2ed4:	d1 70       	andi	r29, 0x01	; 1
    2ed6:	c0 0f       	add	r28, r16
    2ed8:	d1 1f       	adc	r29, r17
    2eda:	ce a5       	ldd	r28, Y+46	; 0x2e
    2edc:	c5 01       	movw	r24, r10
    2ede:	89 2f       	mov	r24, r25
    2ee0:	99 27       	eor	r25, r25
    2ee2:	86 95       	lsr	r24
    2ee4:	f8 01       	movw	r30, r16
    2ee6:	46 8d       	ldd	r20, Z+30	; 0x1e
    2ee8:	57 8d       	ldd	r21, Z+31	; 0x1f
    2eea:	60 a1       	ldd	r22, Z+32	; 0x20
    2eec:	71 a1       	ldd	r23, Z+33	; 0x21
    2eee:	48 0f       	add	r20, r24
    2ef0:	59 1f       	adc	r21, r25
    2ef2:	61 1d       	adc	r22, r1
    2ef4:	71 1d       	adc	r23, r1
    2ef6:	c8 01       	movw	r24, r16
    2ef8:	ad dc       	rcall	.-1702   	; 0x2854 <move_window>
    2efa:	81 11       	cpse	r24, r1
    2efc:	e3 cf       	rjmp	.-58     	; 0x2ec4 <get_fat+0x7a>
    2efe:	f1 e0       	ldi	r31, 0x01	; 1
    2f00:	bf 22       	and	r11, r31
    2f02:	f8 01       	movw	r30, r16
    2f04:	ea 0d       	add	r30, r10
    2f06:	fb 1d       	adc	r31, r11
    2f08:	86 a5       	ldd	r24, Z+46	; 0x2e
    2f0a:	6c 2f       	mov	r22, r28
    2f0c:	70 e0       	ldi	r23, 0x00	; 0
    2f0e:	78 2b       	or	r23, r24
    2f10:	c0 fe       	sbrs	r12, 0
    2f12:	06 c0       	rjmp	.+12     	; 0x2f20 <get_fat+0xd6>
    2f14:	54 e0       	ldi	r21, 0x04	; 4
    2f16:	76 95       	lsr	r23
    2f18:	67 95       	ror	r22
    2f1a:	5a 95       	dec	r21
    2f1c:	e1 f7       	brne	.-8      	; 0x2f16 <get_fat+0xcc>
    2f1e:	22 c0       	rjmp	.+68     	; 0x2f64 <get_fat+0x11a>
    2f20:	7f 70       	andi	r23, 0x0F	; 15
    2f22:	20 c0       	rjmp	.+64     	; 0x2f64 <get_fat+0x11a>
    2f24:	77 27       	eor	r23, r23
    2f26:	6f 2d       	mov	r22, r15
    2f28:	5e 2d       	mov	r21, r14
    2f2a:	4d 2d       	mov	r20, r13
    2f2c:	f8 01       	movw	r30, r16
    2f2e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f30:	97 8d       	ldd	r25, Z+31	; 0x1f
    2f32:	a0 a1       	ldd	r26, Z+32	; 0x20
    2f34:	b1 a1       	ldd	r27, Z+33	; 0x21
    2f36:	48 0f       	add	r20, r24
    2f38:	59 1f       	adc	r21, r25
    2f3a:	6a 1f       	adc	r22, r26
    2f3c:	7b 1f       	adc	r23, r27
    2f3e:	c8 01       	movw	r24, r16
    2f40:	89 dc       	rcall	.-1774   	; 0x2854 <move_window>
    2f42:	81 11       	cpse	r24, r1
    2f44:	bf cf       	rjmp	.-130    	; 0x2ec4 <get_fat+0x7a>
    2f46:	cc 0c       	add	r12, r12
    2f48:	dd 1c       	adc	r13, r13
    2f4a:	ee 1c       	adc	r14, r14
    2f4c:	ff 1c       	adc	r15, r15
    2f4e:	e8 94       	clt
    2f50:	c0 f8       	bld	r12, 0
    2f52:	f1 e0       	ldi	r31, 0x01	; 1
    2f54:	df 22       	and	r13, r31
    2f56:	ee 24       	eor	r14, r14
    2f58:	ff 24       	eor	r15, r15
    2f5a:	f8 01       	movw	r30, r16
    2f5c:	ec 0d       	add	r30, r12
    2f5e:	fd 1d       	adc	r31, r13
    2f60:	66 a5       	ldd	r22, Z+46	; 0x2e
    2f62:	77 a5       	ldd	r23, Z+47	; 0x2f
    2f64:	80 e0       	ldi	r24, 0x00	; 0
    2f66:	90 e0       	ldi	r25, 0x00	; 0
    2f68:	30 c0       	rjmp	.+96     	; 0x2fca <get_fat+0x180>
    2f6a:	f8 01       	movw	r30, r16
    2f6c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2f6e:	97 8d       	ldd	r25, Z+31	; 0x1f
    2f70:	a0 a1       	ldd	r26, Z+32	; 0x20
    2f72:	b1 a1       	ldd	r27, Z+33	; 0x21
    2f74:	27 e0       	ldi	r18, 0x07	; 7
    2f76:	76 95       	lsr	r23
    2f78:	67 95       	ror	r22
    2f7a:	57 95       	ror	r21
    2f7c:	47 95       	ror	r20
    2f7e:	2a 95       	dec	r18
    2f80:	d1 f7       	brne	.-12     	; 0x2f76 <get_fat+0x12c>
    2f82:	48 0f       	add	r20, r24
    2f84:	59 1f       	adc	r21, r25
    2f86:	6a 1f       	adc	r22, r26
    2f88:	7b 1f       	adc	r23, r27
    2f8a:	c8 01       	movw	r24, r16
    2f8c:	63 dc       	rcall	.-1850   	; 0x2854 <move_window>
    2f8e:	81 11       	cpse	r24, r1
    2f90:	99 cf       	rjmp	.-206    	; 0x2ec4 <get_fat+0x7a>
    2f92:	82 e0       	ldi	r24, 0x02	; 2
    2f94:	cc 0c       	add	r12, r12
    2f96:	dd 1c       	adc	r13, r13
    2f98:	ee 1c       	adc	r14, r14
    2f9a:	ff 1c       	adc	r15, r15
    2f9c:	8a 95       	dec	r24
    2f9e:	d1 f7       	brne	.-12     	; 0x2f94 <get_fat+0x14a>
    2fa0:	fc ef       	ldi	r31, 0xFC	; 252
    2fa2:	cf 22       	and	r12, r31
    2fa4:	f1 e0       	ldi	r31, 0x01	; 1
    2fa6:	df 22       	and	r13, r31
    2fa8:	ee 24       	eor	r14, r14
    2faa:	ff 24       	eor	r15, r15
    2fac:	f8 01       	movw	r30, r16
    2fae:	ec 0d       	add	r30, r12
    2fb0:	fd 1d       	adc	r31, r13
    2fb2:	86 a5       	ldd	r24, Z+46	; 0x2e
    2fb4:	97 a5       	ldd	r25, Z+47	; 0x2f
    2fb6:	a0 a9       	ldd	r26, Z+48	; 0x30
    2fb8:	b1 a9       	ldd	r27, Z+49	; 0x31
    2fba:	bc 01       	movw	r22, r24
    2fbc:	cd 01       	movw	r24, r26
    2fbe:	9f 70       	andi	r25, 0x0F	; 15
    2fc0:	04 c0       	rjmp	.+8      	; 0x2fca <get_fat+0x180>
    2fc2:	61 e0       	ldi	r22, 0x01	; 1
    2fc4:	70 e0       	ldi	r23, 0x00	; 0
    2fc6:	80 e0       	ldi	r24, 0x00	; 0
    2fc8:	90 e0       	ldi	r25, 0x00	; 0
    2fca:	df 91       	pop	r29
    2fcc:	cf 91       	pop	r28
    2fce:	1f 91       	pop	r17
    2fd0:	0f 91       	pop	r16
    2fd2:	ff 90       	pop	r15
    2fd4:	ef 90       	pop	r14
    2fd6:	df 90       	pop	r13
    2fd8:	cf 90       	pop	r12
    2fda:	bf 90       	pop	r11
    2fdc:	af 90       	pop	r10
    2fde:	08 95       	ret

00002fe0 <dir_sdi>:
    2fe0:	af 92       	push	r10
    2fe2:	bf 92       	push	r11
    2fe4:	cf 92       	push	r12
    2fe6:	df 92       	push	r13
    2fe8:	ef 92       	push	r14
    2fea:	ff 92       	push	r15
    2fec:	0f 93       	push	r16
    2fee:	1f 93       	push	r17
    2ff0:	cf 93       	push	r28
    2ff2:	df 93       	push	r29
    2ff4:	8c 01       	movw	r16, r24
    2ff6:	eb 01       	movw	r28, r22
    2ff8:	dc 01       	movw	r26, r24
    2ffa:	15 96       	adiw	r26, 0x05	; 5
    2ffc:	7c 93       	st	X, r23
    2ffe:	6e 93       	st	-X, r22
    3000:	14 97       	sbiw	r26, 0x04	; 4
    3002:	16 96       	adiw	r26, 0x06	; 6
    3004:	cd 90       	ld	r12, X+
    3006:	dd 90       	ld	r13, X+
    3008:	ed 90       	ld	r14, X+
    300a:	fc 90       	ld	r15, X
    300c:	19 97       	sbiw	r26, 0x09	; 9
    300e:	b1 e0       	ldi	r27, 0x01	; 1
    3010:	cb 16       	cp	r12, r27
    3012:	d1 04       	cpc	r13, r1
    3014:	e1 04       	cpc	r14, r1
    3016:	f1 04       	cpc	r15, r1
    3018:	11 f4       	brne	.+4      	; 0x301e <dir_sdi+0x3e>
    301a:	82 e0       	ldi	r24, 0x02	; 2
    301c:	87 c0       	rjmp	.+270    	; 0x312c <dir_sdi+0x14c>
    301e:	dc 01       	movw	r26, r24
    3020:	ed 91       	ld	r30, X+
    3022:	fc 91       	ld	r31, X
    3024:	82 89       	ldd	r24, Z+18	; 0x12
    3026:	93 89       	ldd	r25, Z+19	; 0x13
    3028:	a4 89       	ldd	r26, Z+20	; 0x14
    302a:	b5 89       	ldd	r27, Z+21	; 0x15
    302c:	c8 16       	cp	r12, r24
    302e:	d9 06       	cpc	r13, r25
    3030:	ea 06       	cpc	r14, r26
    3032:	fb 06       	cpc	r15, r27
    3034:	90 f7       	brcc	.-28     	; 0x301a <dir_sdi+0x3a>
    3036:	c1 14       	cp	r12, r1
    3038:	d1 04       	cpc	r13, r1
    303a:	e1 04       	cpc	r14, r1
    303c:	f1 04       	cpc	r15, r1
    303e:	b9 f4       	brne	.+46     	; 0x306e <dir_sdi+0x8e>
    3040:	80 81       	ld	r24, Z
    3042:	83 30       	cpi	r24, 0x03	; 3
    3044:	41 f4       	brne	.+16     	; 0x3056 <dir_sdi+0x76>
    3046:	82 a1       	ldd	r24, Z+34	; 0x22
    3048:	93 a1       	ldd	r25, Z+35	; 0x23
    304a:	a4 a1       	ldd	r26, Z+36	; 0x24
    304c:	b5 a1       	ldd	r27, Z+37	; 0x25
    304e:	00 97       	sbiw	r24, 0x00	; 0
    3050:	a1 05       	cpc	r26, r1
    3052:	b1 05       	cpc	r27, r1
    3054:	51 f4       	brne	.+20     	; 0x306a <dir_sdi+0x8a>
    3056:	80 85       	ldd	r24, Z+8	; 0x08
    3058:	91 85       	ldd	r25, Z+9	; 0x09
    305a:	c8 17       	cp	r28, r24
    305c:	d9 07       	cpc	r29, r25
    305e:	e8 f6       	brcc	.-70     	; 0x301a <dir_sdi+0x3a>
    3060:	62 a1       	ldd	r22, Z+34	; 0x22
    3062:	73 a1       	ldd	r23, Z+35	; 0x23
    3064:	84 a1       	ldd	r24, Z+36	; 0x24
    3066:	95 a1       	ldd	r25, Z+37	; 0x25
    3068:	32 c0       	rjmp	.+100    	; 0x30ce <dir_sdi+0xee>
    306a:	6c 01       	movw	r12, r24
    306c:	7d 01       	movw	r14, r26
    306e:	a2 80       	ldd	r10, Z+2	; 0x02
    3070:	b0 e1       	ldi	r27, 0x10	; 16
    3072:	ab 9e       	mul	r10, r27
    3074:	50 01       	movw	r10, r0
    3076:	11 24       	eor	r1, r1
    3078:	b7 01       	movw	r22, r14
    307a:	a6 01       	movw	r20, r12
    307c:	f8 01       	movw	r30, r16
    307e:	80 81       	ld	r24, Z
    3080:	91 81       	ldd	r25, Z+1	; 0x01
    3082:	ca 15       	cp	r28, r10
    3084:	db 05       	cpc	r29, r11
    3086:	00 f1       	brcs	.+64     	; 0x30c8 <dir_sdi+0xe8>
    3088:	e0 de       	rcall	.-576    	; 0x2e4a <get_fat>
    308a:	ab 01       	movw	r20, r22
    308c:	bc 01       	movw	r22, r24
    308e:	4f 3f       	cpi	r20, 0xFF	; 255
    3090:	ef ef       	ldi	r30, 0xFF	; 255
    3092:	5e 07       	cpc	r21, r30
    3094:	6e 07       	cpc	r22, r30
    3096:	7e 07       	cpc	r23, r30
    3098:	09 f4       	brne	.+2      	; 0x309c <dir_sdi+0xbc>
    309a:	47 c0       	rjmp	.+142    	; 0x312a <dir_sdi+0x14a>
    309c:	42 30       	cpi	r20, 0x02	; 2
    309e:	51 05       	cpc	r21, r1
    30a0:	61 05       	cpc	r22, r1
    30a2:	71 05       	cpc	r23, r1
    30a4:	08 f4       	brcc	.+2      	; 0x30a8 <dir_sdi+0xc8>
    30a6:	b9 cf       	rjmp	.-142    	; 0x301a <dir_sdi+0x3a>
    30a8:	d8 01       	movw	r26, r16
    30aa:	ed 91       	ld	r30, X+
    30ac:	fc 91       	ld	r31, X
    30ae:	82 89       	ldd	r24, Z+18	; 0x12
    30b0:	93 89       	ldd	r25, Z+19	; 0x13
    30b2:	a4 89       	ldd	r26, Z+20	; 0x14
    30b4:	b5 89       	ldd	r27, Z+21	; 0x15
    30b6:	48 17       	cp	r20, r24
    30b8:	59 07       	cpc	r21, r25
    30ba:	6a 07       	cpc	r22, r26
    30bc:	7b 07       	cpc	r23, r27
    30be:	08 f0       	brcs	.+2      	; 0x30c2 <dir_sdi+0xe2>
    30c0:	ac cf       	rjmp	.-168    	; 0x301a <dir_sdi+0x3a>
    30c2:	ca 19       	sub	r28, r10
    30c4:	db 09       	sbc	r29, r11
    30c6:	da cf       	rjmp	.-76     	; 0x307c <dir_sdi+0x9c>
    30c8:	6a 01       	movw	r12, r20
    30ca:	7b 01       	movw	r14, r22
    30cc:	96 de       	rcall	.-724    	; 0x2dfa <clust2sect>
    30ce:	d8 01       	movw	r26, r16
    30d0:	1a 96       	adiw	r26, 0x0a	; 10
    30d2:	cd 92       	st	X+, r12
    30d4:	dd 92       	st	X+, r13
    30d6:	ed 92       	st	X+, r14
    30d8:	fc 92       	st	X, r15
    30da:	1d 97       	sbiw	r26, 0x0d	; 13
    30dc:	61 15       	cp	r22, r1
    30de:	71 05       	cpc	r23, r1
    30e0:	81 05       	cpc	r24, r1
    30e2:	91 05       	cpc	r25, r1
    30e4:	09 f4       	brne	.+2      	; 0x30e8 <dir_sdi+0x108>
    30e6:	99 cf       	rjmp	.-206    	; 0x301a <dir_sdi+0x3a>
    30e8:	9e 01       	movw	r18, r28
    30ea:	44 e0       	ldi	r20, 0x04	; 4
    30ec:	36 95       	lsr	r19
    30ee:	27 95       	ror	r18
    30f0:	4a 95       	dec	r20
    30f2:	e1 f7       	brne	.-8      	; 0x30ec <dir_sdi+0x10c>
    30f4:	dc 01       	movw	r26, r24
    30f6:	cb 01       	movw	r24, r22
    30f8:	82 0f       	add	r24, r18
    30fa:	93 1f       	adc	r25, r19
    30fc:	a1 1d       	adc	r26, r1
    30fe:	b1 1d       	adc	r27, r1
    3100:	f8 01       	movw	r30, r16
    3102:	86 87       	std	Z+14, r24	; 0x0e
    3104:	97 87       	std	Z+15, r25	; 0x0f
    3106:	a0 8b       	std	Z+16, r26	; 0x10
    3108:	b1 8b       	std	Z+17, r27	; 0x11
    310a:	cf 70       	andi	r28, 0x0F	; 15
    310c:	dd 27       	eor	r29, r29
    310e:	55 e0       	ldi	r21, 0x05	; 5
    3110:	cc 0f       	add	r28, r28
    3112:	dd 1f       	adc	r29, r29
    3114:	5a 95       	dec	r21
    3116:	e1 f7       	brne	.-8      	; 0x3110 <dir_sdi+0x130>
    3118:	ae 96       	adiw	r28, 0x2e	; 46
    311a:	80 81       	ld	r24, Z
    311c:	91 81       	ldd	r25, Z+1	; 0x01
    311e:	c8 0f       	add	r28, r24
    3120:	d9 1f       	adc	r29, r25
    3122:	d3 8b       	std	Z+19, r29	; 0x13
    3124:	c2 8b       	std	Z+18, r28	; 0x12
    3126:	80 e0       	ldi	r24, 0x00	; 0
    3128:	01 c0       	rjmp	.+2      	; 0x312c <dir_sdi+0x14c>
    312a:	81 e0       	ldi	r24, 0x01	; 1
    312c:	df 91       	pop	r29
    312e:	cf 91       	pop	r28
    3130:	1f 91       	pop	r17
    3132:	0f 91       	pop	r16
    3134:	ff 90       	pop	r15
    3136:	ef 90       	pop	r14
    3138:	df 90       	pop	r13
    313a:	cf 90       	pop	r12
    313c:	bf 90       	pop	r11
    313e:	af 90       	pop	r10
    3140:	08 95       	ret

00003142 <put_fat>:
    3142:	2f 92       	push	r2
    3144:	3f 92       	push	r3
    3146:	4f 92       	push	r4
    3148:	5f 92       	push	r5
    314a:	6f 92       	push	r6
    314c:	7f 92       	push	r7
    314e:	8f 92       	push	r8
    3150:	9f 92       	push	r9
    3152:	af 92       	push	r10
    3154:	bf 92       	push	r11
    3156:	cf 92       	push	r12
    3158:	df 92       	push	r13
    315a:	ef 92       	push	r14
    315c:	ff 92       	push	r15
    315e:	0f 93       	push	r16
    3160:	1f 93       	push	r17
    3162:	cf 93       	push	r28
    3164:	df 93       	push	r29
    3166:	00 d0       	rcall	.+0      	; 0x3168 <put_fat+0x26>
    3168:	00 d0       	rcall	.+0      	; 0x316a <put_fat+0x28>
    316a:	cd b7       	in	r28, 0x3d	; 61
    316c:	de b7       	in	r29, 0x3e	; 62
    316e:	1c 01       	movw	r2, r24
    3170:	6a 01       	movw	r12, r20
    3172:	7b 01       	movw	r14, r22
    3174:	28 01       	movw	r4, r16
    3176:	39 01       	movw	r6, r18
    3178:	42 30       	cpi	r20, 0x02	; 2
    317a:	51 05       	cpc	r21, r1
    317c:	61 05       	cpc	r22, r1
    317e:	71 05       	cpc	r23, r1
    3180:	08 f4       	brcc	.+2      	; 0x3184 <put_fat+0x42>
    3182:	e0 c0       	rjmp	.+448    	; 0x3344 <put_fat+0x202>
    3184:	fc 01       	movw	r30, r24
    3186:	82 89       	ldd	r24, Z+18	; 0x12
    3188:	93 89       	ldd	r25, Z+19	; 0x13
    318a:	a4 89       	ldd	r26, Z+20	; 0x14
    318c:	b5 89       	ldd	r27, Z+21	; 0x15
    318e:	48 17       	cp	r20, r24
    3190:	59 07       	cpc	r21, r25
    3192:	6a 07       	cpc	r22, r26
    3194:	7b 07       	cpc	r23, r27
    3196:	08 f0       	brcs	.+2      	; 0x319a <put_fat+0x58>
    3198:	d5 c0       	rjmp	.+426    	; 0x3344 <put_fat+0x202>
    319a:	80 81       	ld	r24, Z
    319c:	82 30       	cpi	r24, 0x02	; 2
    319e:	09 f4       	brne	.+2      	; 0x31a2 <put_fat+0x60>
    31a0:	71 c0       	rjmp	.+226    	; 0x3284 <put_fat+0x142>
    31a2:	83 30       	cpi	r24, 0x03	; 3
    31a4:	09 f4       	brne	.+2      	; 0x31a8 <put_fat+0x66>
    31a6:	92 c0       	rjmp	.+292    	; 0x32cc <put_fat+0x18a>
    31a8:	81 30       	cpi	r24, 0x01	; 1
    31aa:	09 f0       	breq	.+2      	; 0x31ae <put_fat+0x6c>
    31ac:	cb c0       	rjmp	.+406    	; 0x3344 <put_fat+0x202>
    31ae:	5a 01       	movw	r10, r20
    31b0:	b6 94       	lsr	r11
    31b2:	a7 94       	ror	r10
    31b4:	a4 0e       	add	r10, r20
    31b6:	b5 1e       	adc	r11, r21
    31b8:	c5 01       	movw	r24, r10
    31ba:	89 2f       	mov	r24, r25
    31bc:	99 27       	eor	r25, r25
    31be:	86 95       	lsr	r24
    31c0:	46 8d       	ldd	r20, Z+30	; 0x1e
    31c2:	57 8d       	ldd	r21, Z+31	; 0x1f
    31c4:	60 a1       	ldd	r22, Z+32	; 0x20
    31c6:	71 a1       	ldd	r23, Z+33	; 0x21
    31c8:	48 0f       	add	r20, r24
    31ca:	59 1f       	adc	r21, r25
    31cc:	61 1d       	adc	r22, r1
    31ce:	71 1d       	adc	r23, r1
    31d0:	c1 01       	movw	r24, r2
    31d2:	40 db       	rcall	.-2432   	; 0x2854 <move_window>
    31d4:	81 11       	cpse	r24, r1
    31d6:	b7 c0       	rjmp	.+366    	; 0x3346 <put_fat+0x204>
    31d8:	45 01       	movw	r8, r10
    31da:	ff ef       	ldi	r31, 0xFF	; 255
    31dc:	8f 1a       	sub	r8, r31
    31de:	9f 0a       	sbc	r9, r31
    31e0:	21 e0       	ldi	r18, 0x01	; 1
    31e2:	b2 22       	and	r11, r18
    31e4:	a2 0c       	add	r10, r2
    31e6:	b3 1c       	adc	r11, r3
    31e8:	a7 01       	movw	r20, r14
    31ea:	96 01       	movw	r18, r12
    31ec:	21 70       	andi	r18, 0x01	; 1
    31ee:	33 27       	eor	r19, r19
    31f0:	44 27       	eor	r20, r20
    31f2:	55 27       	eor	r21, r21
    31f4:	29 83       	std	Y+1, r18	; 0x01
    31f6:	3a 83       	std	Y+2, r19	; 0x02
    31f8:	4b 83       	std	Y+3, r20	; 0x03
    31fa:	5c 83       	std	Y+4, r21	; 0x04
    31fc:	c0 fe       	sbrs	r12, 0
    31fe:	0b c0       	rjmp	.+22     	; 0x3216 <put_fat+0xd4>
    3200:	d5 01       	movw	r26, r10
    3202:	9e 96       	adiw	r26, 0x2e	; 46
    3204:	8c 91       	ld	r24, X
    3206:	28 2f       	mov	r18, r24
    3208:	2f 70       	andi	r18, 0x0F	; 15
    320a:	b0 e1       	ldi	r27, 0x10	; 16
    320c:	4b 9e       	mul	r4, r27
    320e:	c0 01       	movw	r24, r0
    3210:	11 24       	eor	r1, r1
    3212:	82 2b       	or	r24, r18
    3214:	01 c0       	rjmp	.+2      	; 0x3218 <put_fat+0xd6>
    3216:	84 2d       	mov	r24, r4
    3218:	f5 01       	movw	r30, r10
    321a:	86 a7       	std	Z+46, r24	; 0x2e
    321c:	81 e0       	ldi	r24, 0x01	; 1
    321e:	d1 01       	movw	r26, r2
    3220:	14 96       	adiw	r26, 0x04	; 4
    3222:	8c 93       	st	X, r24
    3224:	14 97       	sbiw	r26, 0x04	; 4
    3226:	5e 96       	adiw	r26, 0x1e	; 30
    3228:	4d 91       	ld	r20, X+
    322a:	5d 91       	ld	r21, X+
    322c:	6d 91       	ld	r22, X+
    322e:	7c 91       	ld	r23, X
    3230:	91 97       	sbiw	r26, 0x21	; 33
    3232:	c4 01       	movw	r24, r8
    3234:	89 2f       	mov	r24, r25
    3236:	99 27       	eor	r25, r25
    3238:	86 95       	lsr	r24
    323a:	48 0f       	add	r20, r24
    323c:	59 1f       	adc	r21, r25
    323e:	61 1d       	adc	r22, r1
    3240:	71 1d       	adc	r23, r1
    3242:	c1 01       	movw	r24, r2
    3244:	07 db       	rcall	.-2546   	; 0x2854 <move_window>
    3246:	81 11       	cpse	r24, r1
    3248:	7e c0       	rjmp	.+252    	; 0x3346 <put_fat+0x204>
    324a:	b1 e0       	ldi	r27, 0x01	; 1
    324c:	9b 22       	and	r9, r27
    324e:	f1 01       	movw	r30, r2
    3250:	e8 0d       	add	r30, r8
    3252:	f9 1d       	adc	r31, r9
    3254:	29 81       	ldd	r18, Y+1	; 0x01
    3256:	3a 81       	ldd	r19, Y+2	; 0x02
    3258:	4b 81       	ldd	r20, Y+3	; 0x03
    325a:	5c 81       	ldd	r21, Y+4	; 0x04
    325c:	23 2b       	or	r18, r19
    325e:	24 2b       	or	r18, r20
    3260:	25 2b       	or	r18, r21
    3262:	41 f0       	breq	.+16     	; 0x3274 <put_fat+0x132>
    3264:	54 e0       	ldi	r21, 0x04	; 4
    3266:	76 94       	lsr	r7
    3268:	67 94       	ror	r6
    326a:	57 94       	ror	r5
    326c:	47 94       	ror	r4
    326e:	5a 95       	dec	r21
    3270:	d1 f7       	brne	.-12     	; 0x3266 <put_fat+0x124>
    3272:	06 c0       	rjmp	.+12     	; 0x3280 <put_fat+0x13e>
    3274:	26 a5       	ldd	r18, Z+46	; 0x2e
    3276:	20 7f       	andi	r18, 0xF0	; 240
    3278:	95 2d       	mov	r25, r5
    327a:	9f 70       	andi	r25, 0x0F	; 15
    327c:	42 2e       	mov	r4, r18
    327e:	49 2a       	or	r4, r25
    3280:	46 a6       	std	Z+46, r4	; 0x2e
    3282:	5b c0       	rjmp	.+182    	; 0x333a <put_fat+0x1f8>
    3284:	77 27       	eor	r23, r23
    3286:	6f 2d       	mov	r22, r15
    3288:	5e 2d       	mov	r21, r14
    328a:	4d 2d       	mov	r20, r13
    328c:	f1 01       	movw	r30, r2
    328e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3290:	97 8d       	ldd	r25, Z+31	; 0x1f
    3292:	a0 a1       	ldd	r26, Z+32	; 0x20
    3294:	b1 a1       	ldd	r27, Z+33	; 0x21
    3296:	48 0f       	add	r20, r24
    3298:	59 1f       	adc	r21, r25
    329a:	6a 1f       	adc	r22, r26
    329c:	7b 1f       	adc	r23, r27
    329e:	c1 01       	movw	r24, r2
    32a0:	d9 da       	rcall	.-2638   	; 0x2854 <move_window>
    32a2:	81 11       	cpse	r24, r1
    32a4:	50 c0       	rjmp	.+160    	; 0x3346 <put_fat+0x204>
    32a6:	cc 0c       	add	r12, r12
    32a8:	dd 1c       	adc	r13, r13
    32aa:	ee 1c       	adc	r14, r14
    32ac:	ff 1c       	adc	r15, r15
    32ae:	e8 94       	clt
    32b0:	c0 f8       	bld	r12, 0
    32b2:	f1 e0       	ldi	r31, 0x01	; 1
    32b4:	df 22       	and	r13, r31
    32b6:	ee 24       	eor	r14, r14
    32b8:	ff 24       	eor	r15, r15
    32ba:	2e e2       	ldi	r18, 0x2E	; 46
    32bc:	c2 0e       	add	r12, r18
    32be:	d1 1c       	adc	r13, r1
    32c0:	f1 01       	movw	r30, r2
    32c2:	ec 0d       	add	r30, r12
    32c4:	fd 1d       	adc	r31, r13
    32c6:	51 82       	std	Z+1, r5	; 0x01
    32c8:	40 82       	st	Z, r4
    32ca:	37 c0       	rjmp	.+110    	; 0x333a <put_fat+0x1f8>
    32cc:	f1 01       	movw	r30, r2
    32ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    32d0:	97 8d       	ldd	r25, Z+31	; 0x1f
    32d2:	a0 a1       	ldd	r26, Z+32	; 0x20
    32d4:	b1 a1       	ldd	r27, Z+33	; 0x21
    32d6:	27 e0       	ldi	r18, 0x07	; 7
    32d8:	76 95       	lsr	r23
    32da:	67 95       	ror	r22
    32dc:	57 95       	ror	r21
    32de:	47 95       	ror	r20
    32e0:	2a 95       	dec	r18
    32e2:	d1 f7       	brne	.-12     	; 0x32d8 <put_fat+0x196>
    32e4:	48 0f       	add	r20, r24
    32e6:	59 1f       	adc	r21, r25
    32e8:	6a 1f       	adc	r22, r26
    32ea:	7b 1f       	adc	r23, r27
    32ec:	c1 01       	movw	r24, r2
    32ee:	b2 da       	rcall	.-2716   	; 0x2854 <move_window>
    32f0:	81 11       	cpse	r24, r1
    32f2:	29 c0       	rjmp	.+82     	; 0x3346 <put_fat+0x204>
    32f4:	92 e0       	ldi	r25, 0x02	; 2
    32f6:	cc 0c       	add	r12, r12
    32f8:	dd 1c       	adc	r13, r13
    32fa:	ee 1c       	adc	r14, r14
    32fc:	ff 1c       	adc	r15, r15
    32fe:	9a 95       	dec	r25
    3300:	d1 f7       	brne	.-12     	; 0x32f6 <put_fat+0x1b4>
    3302:	fc ef       	ldi	r31, 0xFC	; 252
    3304:	cf 22       	and	r12, r31
    3306:	f1 e0       	ldi	r31, 0x01	; 1
    3308:	df 22       	and	r13, r31
    330a:	ee 24       	eor	r14, r14
    330c:	ff 24       	eor	r15, r15
    330e:	2e e2       	ldi	r18, 0x2E	; 46
    3310:	c2 0e       	add	r12, r18
    3312:	d1 1c       	adc	r13, r1
    3314:	f1 01       	movw	r30, r2
    3316:	ec 0d       	add	r30, r12
    3318:	fd 1d       	adc	r31, r13
    331a:	40 81       	ld	r20, Z
    331c:	51 81       	ldd	r21, Z+1	; 0x01
    331e:	62 81       	ldd	r22, Z+2	; 0x02
    3320:	73 81       	ldd	r23, Z+3	; 0x03
    3322:	44 27       	eor	r20, r20
    3324:	55 27       	eor	r21, r21
    3326:	66 27       	eor	r22, r22
    3328:	70 7f       	andi	r23, 0xF0	; 240
    332a:	44 2a       	or	r4, r20
    332c:	55 2a       	or	r5, r21
    332e:	66 2a       	or	r6, r22
    3330:	77 2a       	or	r7, r23
    3332:	40 82       	st	Z, r4
    3334:	51 82       	std	Z+1, r5	; 0x01
    3336:	62 82       	std	Z+2, r6	; 0x02
    3338:	73 82       	std	Z+3, r7	; 0x03
    333a:	91 e0       	ldi	r25, 0x01	; 1
    333c:	d1 01       	movw	r26, r2
    333e:	14 96       	adiw	r26, 0x04	; 4
    3340:	9c 93       	st	X, r25
    3342:	01 c0       	rjmp	.+2      	; 0x3346 <put_fat+0x204>
    3344:	82 e0       	ldi	r24, 0x02	; 2
    3346:	0f 90       	pop	r0
    3348:	0f 90       	pop	r0
    334a:	0f 90       	pop	r0
    334c:	0f 90       	pop	r0
    334e:	df 91       	pop	r29
    3350:	cf 91       	pop	r28
    3352:	1f 91       	pop	r17
    3354:	0f 91       	pop	r16
    3356:	ff 90       	pop	r15
    3358:	ef 90       	pop	r14
    335a:	df 90       	pop	r13
    335c:	cf 90       	pop	r12
    335e:	bf 90       	pop	r11
    3360:	af 90       	pop	r10
    3362:	9f 90       	pop	r9
    3364:	8f 90       	pop	r8
    3366:	7f 90       	pop	r7
    3368:	6f 90       	pop	r6
    336a:	5f 90       	pop	r5
    336c:	4f 90       	pop	r4
    336e:	3f 90       	pop	r3
    3370:	2f 90       	pop	r2
    3372:	08 95       	ret

00003374 <create_chain>:
    3374:	4f 92       	push	r4
    3376:	5f 92       	push	r5
    3378:	6f 92       	push	r6
    337a:	7f 92       	push	r7
    337c:	8f 92       	push	r8
    337e:	9f 92       	push	r9
    3380:	af 92       	push	r10
    3382:	bf 92       	push	r11
    3384:	cf 92       	push	r12
    3386:	df 92       	push	r13
    3388:	ef 92       	push	r14
    338a:	ff 92       	push	r15
    338c:	0f 93       	push	r16
    338e:	1f 93       	push	r17
    3390:	cf 93       	push	r28
    3392:	df 93       	push	r29
    3394:	ec 01       	movw	r28, r24
    3396:	2a 01       	movw	r4, r20
    3398:	3b 01       	movw	r6, r22
    339a:	41 15       	cp	r20, r1
    339c:	51 05       	cpc	r21, r1
    339e:	61 05       	cpc	r22, r1
    33a0:	71 05       	cpc	r23, r1
    33a2:	99 f4       	brne	.+38     	; 0x33ca <create_chain+0x56>
    33a4:	8a 84       	ldd	r8, Y+10	; 0x0a
    33a6:	9b 84       	ldd	r9, Y+11	; 0x0b
    33a8:	ac 84       	ldd	r10, Y+12	; 0x0c
    33aa:	bd 84       	ldd	r11, Y+13	; 0x0d
    33ac:	81 14       	cp	r8, r1
    33ae:	91 04       	cpc	r9, r1
    33b0:	a1 04       	cpc	r10, r1
    33b2:	b1 04       	cpc	r11, r1
    33b4:	59 f1       	breq	.+86     	; 0x340c <create_chain+0x98>
    33b6:	8a 89       	ldd	r24, Y+18	; 0x12
    33b8:	9b 89       	ldd	r25, Y+19	; 0x13
    33ba:	ac 89       	ldd	r26, Y+20	; 0x14
    33bc:	bd 89       	ldd	r27, Y+21	; 0x15
    33be:	88 16       	cp	r8, r24
    33c0:	99 06       	cpc	r9, r25
    33c2:	aa 06       	cpc	r10, r26
    33c4:	bb 06       	cpc	r11, r27
    33c6:	30 f1       	brcs	.+76     	; 0x3414 <create_chain+0xa0>
    33c8:	21 c0       	rjmp	.+66     	; 0x340c <create_chain+0x98>
    33ca:	3f dd       	rcall	.-1410   	; 0x2e4a <get_fat>
    33cc:	6b 01       	movw	r12, r22
    33ce:	7c 01       	movw	r14, r24
    33d0:	62 30       	cpi	r22, 0x02	; 2
    33d2:	71 05       	cpc	r23, r1
    33d4:	81 05       	cpc	r24, r1
    33d6:	91 05       	cpc	r25, r1
    33d8:	08 f4       	brcc	.+2      	; 0x33dc <create_chain+0x68>
    33da:	8a c0       	rjmp	.+276    	; 0x34f0 <create_chain+0x17c>
    33dc:	8f ef       	ldi	r24, 0xFF	; 255
    33de:	c8 16       	cp	r12, r24
    33e0:	d8 06       	cpc	r13, r24
    33e2:	e8 06       	cpc	r14, r24
    33e4:	f8 06       	cpc	r15, r24
    33e6:	29 f4       	brne	.+10     	; 0x33f2 <create_chain+0x7e>
    33e8:	6f ef       	ldi	r22, 0xFF	; 255
    33ea:	7f ef       	ldi	r23, 0xFF	; 255
    33ec:	8f ef       	ldi	r24, 0xFF	; 255
    33ee:	9f ef       	ldi	r25, 0xFF	; 255
    33f0:	86 c0       	rjmp	.+268    	; 0x34fe <create_chain+0x18a>
    33f2:	8a 89       	ldd	r24, Y+18	; 0x12
    33f4:	9b 89       	ldd	r25, Y+19	; 0x13
    33f6:	ac 89       	ldd	r26, Y+20	; 0x14
    33f8:	bd 89       	ldd	r27, Y+21	; 0x15
    33fa:	c8 16       	cp	r12, r24
    33fc:	d9 06       	cpc	r13, r25
    33fe:	ea 06       	cpc	r14, r26
    3400:	fb 06       	cpc	r15, r27
    3402:	08 f4       	brcc	.+2      	; 0x3406 <create_chain+0x92>
    3404:	7a c0       	rjmp	.+244    	; 0x34fa <create_chain+0x186>
    3406:	53 01       	movw	r10, r6
    3408:	42 01       	movw	r8, r4
    340a:	04 c0       	rjmp	.+8      	; 0x3414 <create_chain+0xa0>
    340c:	81 2c       	mov	r8, r1
    340e:	91 2c       	mov	r9, r1
    3410:	54 01       	movw	r10, r8
    3412:	83 94       	inc	r8
    3414:	75 01       	movw	r14, r10
    3416:	64 01       	movw	r12, r8
    3418:	2f ef       	ldi	r18, 0xFF	; 255
    341a:	c2 1a       	sub	r12, r18
    341c:	d2 0a       	sbc	r13, r18
    341e:	e2 0a       	sbc	r14, r18
    3420:	f2 0a       	sbc	r15, r18
    3422:	8a 89       	ldd	r24, Y+18	; 0x12
    3424:	9b 89       	ldd	r25, Y+19	; 0x13
    3426:	ac 89       	ldd	r26, Y+20	; 0x14
    3428:	bd 89       	ldd	r27, Y+21	; 0x15
    342a:	c8 16       	cp	r12, r24
    342c:	d9 06       	cpc	r13, r25
    342e:	ea 06       	cpc	r14, r26
    3430:	fb 06       	cpc	r15, r27
    3432:	68 f0       	brcs	.+26     	; 0x344e <create_chain+0xda>
    3434:	82 e0       	ldi	r24, 0x02	; 2
    3436:	88 16       	cp	r8, r24
    3438:	91 04       	cpc	r9, r1
    343a:	a1 04       	cpc	r10, r1
    343c:	b1 04       	cpc	r11, r1
    343e:	10 f4       	brcc	.+4      	; 0x3444 <create_chain+0xd0>
    3440:	60 e0       	ldi	r22, 0x00	; 0
    3442:	57 c0       	rjmp	.+174    	; 0x34f2 <create_chain+0x17e>
    3444:	82 e0       	ldi	r24, 0x02	; 2
    3446:	c8 2e       	mov	r12, r24
    3448:	d1 2c       	mov	r13, r1
    344a:	e1 2c       	mov	r14, r1
    344c:	f1 2c       	mov	r15, r1
    344e:	b7 01       	movw	r22, r14
    3450:	a6 01       	movw	r20, r12
    3452:	ce 01       	movw	r24, r28
    3454:	fa dc       	rcall	.-1548   	; 0x2e4a <get_fat>
    3456:	8b 01       	movw	r16, r22
    3458:	9c 01       	movw	r18, r24
    345a:	67 2b       	or	r22, r23
    345c:	68 2b       	or	r22, r24
    345e:	69 2b       	or	r22, r25
    3460:	a1 f0       	breq	.+40     	; 0x348a <create_chain+0x116>
    3462:	0f 3f       	cpi	r16, 0xFF	; 255
    3464:	8f ef       	ldi	r24, 0xFF	; 255
    3466:	18 07       	cpc	r17, r24
    3468:	28 07       	cpc	r18, r24
    346a:	38 07       	cpc	r19, r24
    346c:	29 f0       	breq	.+10     	; 0x3478 <create_chain+0x104>
    346e:	01 30       	cpi	r16, 0x01	; 1
    3470:	11 05       	cpc	r17, r1
    3472:	21 05       	cpc	r18, r1
    3474:	31 05       	cpc	r19, r1
    3476:	19 f4       	brne	.+6      	; 0x347e <create_chain+0x10a>
    3478:	b8 01       	movw	r22, r16
    347a:	c9 01       	movw	r24, r18
    347c:	40 c0       	rjmp	.+128    	; 0x34fe <create_chain+0x18a>
    347e:	c8 14       	cp	r12, r8
    3480:	d9 04       	cpc	r13, r9
    3482:	ea 04       	cpc	r14, r10
    3484:	fb 04       	cpc	r15, r11
    3486:	41 f6       	brne	.-112    	; 0x3418 <create_chain+0xa4>
    3488:	db cf       	rjmp	.-74     	; 0x3440 <create_chain+0xcc>
    348a:	0f ef       	ldi	r16, 0xFF	; 255
    348c:	1f ef       	ldi	r17, 0xFF	; 255
    348e:	2f ef       	ldi	r18, 0xFF	; 255
    3490:	3f e0       	ldi	r19, 0x0F	; 15
    3492:	b7 01       	movw	r22, r14
    3494:	a6 01       	movw	r20, r12
    3496:	ce 01       	movw	r24, r28
    3498:	54 de       	rcall	.-856    	; 0x3142 <put_fat>
    349a:	81 11       	cpse	r24, r1
    349c:	26 c0       	rjmp	.+76     	; 0x34ea <create_chain+0x176>
    349e:	41 14       	cp	r4, r1
    34a0:	51 04       	cpc	r5, r1
    34a2:	61 04       	cpc	r6, r1
    34a4:	71 04       	cpc	r7, r1
    34a6:	c9 f4       	brne	.+50     	; 0x34da <create_chain+0x166>
    34a8:	ca 86       	std	Y+10, r12	; 0x0a
    34aa:	db 86       	std	Y+11, r13	; 0x0b
    34ac:	ec 86       	std	Y+12, r14	; 0x0c
    34ae:	fd 86       	std	Y+13, r15	; 0x0d
    34b0:	8e 85       	ldd	r24, Y+14	; 0x0e
    34b2:	9f 85       	ldd	r25, Y+15	; 0x0f
    34b4:	a8 89       	ldd	r26, Y+16	; 0x10
    34b6:	b9 89       	ldd	r27, Y+17	; 0x11
    34b8:	8f 3f       	cpi	r24, 0xFF	; 255
    34ba:	2f ef       	ldi	r18, 0xFF	; 255
    34bc:	92 07       	cpc	r25, r18
    34be:	a2 07       	cpc	r26, r18
    34c0:	b2 07       	cpc	r27, r18
    34c2:	d9 f0       	breq	.+54     	; 0x34fa <create_chain+0x186>
    34c4:	01 97       	sbiw	r24, 0x01	; 1
    34c6:	a1 09       	sbc	r26, r1
    34c8:	b1 09       	sbc	r27, r1
    34ca:	8e 87       	std	Y+14, r24	; 0x0e
    34cc:	9f 87       	std	Y+15, r25	; 0x0f
    34ce:	a8 8b       	std	Y+16, r26	; 0x10
    34d0:	b9 8b       	std	Y+17, r27	; 0x11
    34d2:	8d 81       	ldd	r24, Y+5	; 0x05
    34d4:	81 60       	ori	r24, 0x01	; 1
    34d6:	8d 83       	std	Y+5, r24	; 0x05
    34d8:	10 c0       	rjmp	.+32     	; 0x34fa <create_chain+0x186>
    34da:	97 01       	movw	r18, r14
    34dc:	86 01       	movw	r16, r12
    34de:	b3 01       	movw	r22, r6
    34e0:	a2 01       	movw	r20, r4
    34e2:	ce 01       	movw	r24, r28
    34e4:	2e de       	rcall	.-932    	; 0x3142 <put_fat>
    34e6:	88 23       	and	r24, r24
    34e8:	f9 f2       	breq	.-66     	; 0x34a8 <create_chain+0x134>
    34ea:	81 30       	cpi	r24, 0x01	; 1
    34ec:	09 f4       	brne	.+2      	; 0x34f0 <create_chain+0x17c>
    34ee:	7c cf       	rjmp	.-264    	; 0x33e8 <create_chain+0x74>
    34f0:	61 e0       	ldi	r22, 0x01	; 1
    34f2:	70 e0       	ldi	r23, 0x00	; 0
    34f4:	80 e0       	ldi	r24, 0x00	; 0
    34f6:	90 e0       	ldi	r25, 0x00	; 0
    34f8:	02 c0       	rjmp	.+4      	; 0x34fe <create_chain+0x18a>
    34fa:	b6 01       	movw	r22, r12
    34fc:	c7 01       	movw	r24, r14
    34fe:	df 91       	pop	r29
    3500:	cf 91       	pop	r28
    3502:	1f 91       	pop	r17
    3504:	0f 91       	pop	r16
    3506:	ff 90       	pop	r15
    3508:	ef 90       	pop	r14
    350a:	df 90       	pop	r13
    350c:	cf 90       	pop	r12
    350e:	bf 90       	pop	r11
    3510:	af 90       	pop	r10
    3512:	9f 90       	pop	r9
    3514:	8f 90       	pop	r8
    3516:	7f 90       	pop	r7
    3518:	6f 90       	pop	r6
    351a:	5f 90       	pop	r5
    351c:	4f 90       	pop	r4
    351e:	08 95       	ret

00003520 <dir_next>:
    3520:	7f 92       	push	r7
    3522:	8f 92       	push	r8
    3524:	9f 92       	push	r9
    3526:	af 92       	push	r10
    3528:	bf 92       	push	r11
    352a:	cf 92       	push	r12
    352c:	df 92       	push	r13
    352e:	ef 92       	push	r14
    3530:	ff 92       	push	r15
    3532:	0f 93       	push	r16
    3534:	1f 93       	push	r17
    3536:	cf 93       	push	r28
    3538:	df 93       	push	r29
    353a:	ec 01       	movw	r28, r24
    353c:	6b 01       	movw	r12, r22
    353e:	ec 80       	ldd	r14, Y+4	; 0x04
    3540:	fd 80       	ldd	r15, Y+5	; 0x05
    3542:	8f ef       	ldi	r24, 0xFF	; 255
    3544:	e8 1a       	sub	r14, r24
    3546:	f8 0a       	sbc	r15, r24
    3548:	11 f4       	brne	.+4      	; 0x354e <dir_next+0x2e>
    354a:	84 e0       	ldi	r24, 0x04	; 4
    354c:	db c0       	rjmp	.+438    	; 0x3704 <dir_next+0x1e4>
    354e:	4e 85       	ldd	r20, Y+14	; 0x0e
    3550:	5f 85       	ldd	r21, Y+15	; 0x0f
    3552:	68 89       	ldd	r22, Y+16	; 0x10
    3554:	79 89       	ldd	r23, Y+17	; 0x11
    3556:	41 15       	cp	r20, r1
    3558:	51 05       	cpc	r21, r1
    355a:	61 05       	cpc	r22, r1
    355c:	71 05       	cpc	r23, r1
    355e:	a9 f3       	breq	.-22     	; 0x354a <dir_next+0x2a>
    3560:	87 01       	movw	r16, r14
    3562:	0f 70       	andi	r16, 0x0F	; 15
    3564:	11 27       	eor	r17, r17
    3566:	01 15       	cp	r16, r1
    3568:	11 05       	cpc	r17, r1
    356a:	09 f0       	breq	.+2      	; 0x356e <dir_next+0x4e>
    356c:	b9 c0       	rjmp	.+370    	; 0x36e0 <dir_next+0x1c0>
    356e:	4f 5f       	subi	r20, 0xFF	; 255
    3570:	5f 4f       	sbci	r21, 0xFF	; 255
    3572:	6f 4f       	sbci	r22, 0xFF	; 255
    3574:	7f 4f       	sbci	r23, 0xFF	; 255
    3576:	4e 87       	std	Y+14, r20	; 0x0e
    3578:	5f 87       	std	Y+15, r21	; 0x0f
    357a:	68 8b       	std	Y+16, r22	; 0x10
    357c:	79 8b       	std	Y+17, r23	; 0x11
    357e:	4a 85       	ldd	r20, Y+10	; 0x0a
    3580:	5b 85       	ldd	r21, Y+11	; 0x0b
    3582:	6c 85       	ldd	r22, Y+12	; 0x0c
    3584:	7d 85       	ldd	r23, Y+13	; 0x0d
    3586:	88 81       	ld	r24, Y
    3588:	99 81       	ldd	r25, Y+1	; 0x01
    358a:	fc 01       	movw	r30, r24
    358c:	41 15       	cp	r20, r1
    358e:	51 05       	cpc	r21, r1
    3590:	61 05       	cpc	r22, r1
    3592:	71 05       	cpc	r23, r1
    3594:	31 f4       	brne	.+12     	; 0x35a2 <dir_next+0x82>
    3596:	80 85       	ldd	r24, Z+8	; 0x08
    3598:	91 85       	ldd	r25, Z+9	; 0x09
    359a:	e8 16       	cp	r14, r24
    359c:	f9 06       	cpc	r15, r25
    359e:	a8 f6       	brcc	.-86     	; 0x354a <dir_next+0x2a>
    35a0:	9f c0       	rjmp	.+318    	; 0x36e0 <dir_next+0x1c0>
    35a2:	22 81       	ldd	r18, Z+2	; 0x02
    35a4:	30 e0       	ldi	r19, 0x00	; 0
    35a6:	21 50       	subi	r18, 0x01	; 1
    35a8:	31 09       	sbc	r19, r1
    35aa:	f7 01       	movw	r30, r14
    35ac:	a4 e0       	ldi	r26, 0x04	; 4
    35ae:	f6 95       	lsr	r31
    35b0:	e7 95       	ror	r30
    35b2:	aa 95       	dec	r26
    35b4:	e1 f7       	brne	.-8      	; 0x35ae <dir_next+0x8e>
    35b6:	2e 23       	and	r18, r30
    35b8:	3f 23       	and	r19, r31
    35ba:	23 2b       	or	r18, r19
    35bc:	09 f0       	breq	.+2      	; 0x35c0 <dir_next+0xa0>
    35be:	90 c0       	rjmp	.+288    	; 0x36e0 <dir_next+0x1c0>
    35c0:	44 dc       	rcall	.-1912   	; 0x2e4a <get_fat>
    35c2:	4b 01       	movw	r8, r22
    35c4:	5c 01       	movw	r10, r24
    35c6:	62 30       	cpi	r22, 0x02	; 2
    35c8:	71 05       	cpc	r23, r1
    35ca:	81 05       	cpc	r24, r1
    35cc:	91 05       	cpc	r25, r1
    35ce:	10 f4       	brcc	.+4      	; 0x35d4 <dir_next+0xb4>
    35d0:	82 e0       	ldi	r24, 0x02	; 2
    35d2:	98 c0       	rjmp	.+304    	; 0x3704 <dir_next+0x1e4>
    35d4:	8f ef       	ldi	r24, 0xFF	; 255
    35d6:	88 16       	cp	r8, r24
    35d8:	98 06       	cpc	r9, r24
    35da:	a8 06       	cpc	r10, r24
    35dc:	b8 06       	cpc	r11, r24
    35de:	11 f4       	brne	.+4      	; 0x35e4 <dir_next+0xc4>
    35e0:	81 e0       	ldi	r24, 0x01	; 1
    35e2:	90 c0       	rjmp	.+288    	; 0x3704 <dir_next+0x1e4>
    35e4:	88 81       	ld	r24, Y
    35e6:	99 81       	ldd	r25, Y+1	; 0x01
    35e8:	fc 01       	movw	r30, r24
    35ea:	42 89       	ldd	r20, Z+18	; 0x12
    35ec:	53 89       	ldd	r21, Z+19	; 0x13
    35ee:	64 89       	ldd	r22, Z+20	; 0x14
    35f0:	75 89       	ldd	r23, Z+21	; 0x15
    35f2:	84 16       	cp	r8, r20
    35f4:	95 06       	cpc	r9, r21
    35f6:	a6 06       	cpc	r10, r22
    35f8:	b7 06       	cpc	r11, r23
    35fa:	08 f4       	brcc	.+2      	; 0x35fe <dir_next+0xde>
    35fc:	64 c0       	rjmp	.+200    	; 0x36c6 <dir_next+0x1a6>
    35fe:	cd 28       	or	r12, r13
    3600:	09 f4       	brne	.+2      	; 0x3604 <dir_next+0xe4>
    3602:	a3 cf       	rjmp	.-186    	; 0x354a <dir_next+0x2a>
    3604:	4a 85       	ldd	r20, Y+10	; 0x0a
    3606:	5b 85       	ldd	r21, Y+11	; 0x0b
    3608:	6c 85       	ldd	r22, Y+12	; 0x0c
    360a:	7d 85       	ldd	r23, Y+13	; 0x0d
    360c:	b3 de       	rcall	.-666    	; 0x3374 <create_chain>
    360e:	4b 01       	movw	r8, r22
    3610:	5c 01       	movw	r10, r24
    3612:	61 15       	cp	r22, r1
    3614:	71 05       	cpc	r23, r1
    3616:	81 05       	cpc	r24, r1
    3618:	91 05       	cpc	r25, r1
    361a:	09 f4       	brne	.+2      	; 0x361e <dir_next+0xfe>
    361c:	72 c0       	rjmp	.+228    	; 0x3702 <dir_next+0x1e2>
    361e:	61 30       	cpi	r22, 0x01	; 1
    3620:	71 05       	cpc	r23, r1
    3622:	81 05       	cpc	r24, r1
    3624:	91 05       	cpc	r25, r1
    3626:	a1 f2       	breq	.-88     	; 0x35d0 <dir_next+0xb0>
    3628:	8f ef       	ldi	r24, 0xFF	; 255
    362a:	88 16       	cp	r8, r24
    362c:	98 06       	cpc	r9, r24
    362e:	a8 06       	cpc	r10, r24
    3630:	b8 06       	cpc	r11, r24
    3632:	b1 f2       	breq	.-84     	; 0x35e0 <dir_next+0xc0>
    3634:	88 81       	ld	r24, Y
    3636:	99 81       	ldd	r25, Y+1	; 0x01
    3638:	45 d8       	rcall	.-3958   	; 0x26c4 <sync_window>
    363a:	81 11       	cpse	r24, r1
    363c:	d1 cf       	rjmp	.-94     	; 0x35e0 <dir_next+0xc0>
    363e:	88 81       	ld	r24, Y
    3640:	99 81       	ldd	r25, Y+1	; 0x01
    3642:	fc 01       	movw	r30, r24
    3644:	be 96       	adiw	r30, 0x2e	; 46
    3646:	82 5d       	subi	r24, 0xD2	; 210
    3648:	9d 4f       	sbci	r25, 0xFD	; 253
    364a:	e8 17       	cp	r30, r24
    364c:	f9 07       	cpc	r31, r25
    364e:	11 f0       	breq	.+4      	; 0x3654 <dir_next+0x134>
    3650:	11 92       	st	Z+, r1
    3652:	fb cf       	rjmp	.-10     	; 0x364a <dir_next+0x12a>
    3654:	c8 80       	ld	r12, Y
    3656:	d9 80       	ldd	r13, Y+1	; 0x01
    3658:	b5 01       	movw	r22, r10
    365a:	a4 01       	movw	r20, r8
    365c:	c6 01       	movw	r24, r12
    365e:	cd db       	rcall	.-2150   	; 0x2dfa <clust2sect>
    3660:	f6 01       	movw	r30, r12
    3662:	62 a7       	std	Z+42, r22	; 0x2a
    3664:	73 a7       	std	Z+43, r23	; 0x2b
    3666:	84 a7       	std	Z+44, r24	; 0x2c
    3668:	95 a7       	std	Z+45, r25	; 0x2d
    366a:	c1 2c       	mov	r12, r1
    366c:	d1 2c       	mov	r13, r1
    366e:	77 24       	eor	r7, r7
    3670:	73 94       	inc	r7
    3672:	e8 81       	ld	r30, Y
    3674:	f9 81       	ldd	r31, Y+1	; 0x01
    3676:	82 81       	ldd	r24, Z+2	; 0x02
    3678:	90 e0       	ldi	r25, 0x00	; 0
    367a:	c8 16       	cp	r12, r24
    367c:	d9 06       	cpc	r13, r25
    367e:	b8 f4       	brcc	.+46     	; 0x36ae <dir_next+0x18e>
    3680:	74 82       	std	Z+4, r7	; 0x04
    3682:	88 81       	ld	r24, Y
    3684:	99 81       	ldd	r25, Y+1	; 0x01
    3686:	1e d8       	rcall	.-4036   	; 0x26c4 <sync_window>
    3688:	81 11       	cpse	r24, r1
    368a:	aa cf       	rjmp	.-172    	; 0x35e0 <dir_next+0xc0>
    368c:	e8 81       	ld	r30, Y
    368e:	f9 81       	ldd	r31, Y+1	; 0x01
    3690:	82 a5       	ldd	r24, Z+42	; 0x2a
    3692:	93 a5       	ldd	r25, Z+43	; 0x2b
    3694:	a4 a5       	ldd	r26, Z+44	; 0x2c
    3696:	b5 a5       	ldd	r27, Z+45	; 0x2d
    3698:	01 96       	adiw	r24, 0x01	; 1
    369a:	a1 1d       	adc	r26, r1
    369c:	b1 1d       	adc	r27, r1
    369e:	82 a7       	std	Z+42, r24	; 0x2a
    36a0:	93 a7       	std	Z+43, r25	; 0x2b
    36a2:	a4 a7       	std	Z+44, r26	; 0x2c
    36a4:	b5 a7       	std	Z+45, r27	; 0x2d
    36a6:	ff ef       	ldi	r31, 0xFF	; 255
    36a8:	cf 1a       	sub	r12, r31
    36aa:	df 0a       	sbc	r13, r31
    36ac:	e2 cf       	rjmp	.-60     	; 0x3672 <dir_next+0x152>
    36ae:	82 a5       	ldd	r24, Z+42	; 0x2a
    36b0:	93 a5       	ldd	r25, Z+43	; 0x2b
    36b2:	a4 a5       	ldd	r26, Z+44	; 0x2c
    36b4:	b5 a5       	ldd	r27, Z+45	; 0x2d
    36b6:	8c 19       	sub	r24, r12
    36b8:	9d 09       	sbc	r25, r13
    36ba:	a1 09       	sbc	r26, r1
    36bc:	b1 09       	sbc	r27, r1
    36be:	82 a7       	std	Z+42, r24	; 0x2a
    36c0:	93 a7       	std	Z+43, r25	; 0x2b
    36c2:	a4 a7       	std	Z+44, r26	; 0x2c
    36c4:	b5 a7       	std	Z+45, r27	; 0x2d
    36c6:	8a 86       	std	Y+10, r8	; 0x0a
    36c8:	9b 86       	std	Y+11, r9	; 0x0b
    36ca:	ac 86       	std	Y+12, r10	; 0x0c
    36cc:	bd 86       	std	Y+13, r11	; 0x0d
    36ce:	b5 01       	movw	r22, r10
    36d0:	a4 01       	movw	r20, r8
    36d2:	88 81       	ld	r24, Y
    36d4:	99 81       	ldd	r25, Y+1	; 0x01
    36d6:	91 db       	rcall	.-2270   	; 0x2dfa <clust2sect>
    36d8:	6e 87       	std	Y+14, r22	; 0x0e
    36da:	7f 87       	std	Y+15, r23	; 0x0f
    36dc:	88 8b       	std	Y+16, r24	; 0x10
    36de:	99 8b       	std	Y+17, r25	; 0x11
    36e0:	fd 82       	std	Y+5, r15	; 0x05
    36e2:	ec 82       	std	Y+4, r14	; 0x04
    36e4:	85 e0       	ldi	r24, 0x05	; 5
    36e6:	00 0f       	add	r16, r16
    36e8:	11 1f       	adc	r17, r17
    36ea:	8a 95       	dec	r24
    36ec:	e1 f7       	brne	.-8      	; 0x36e6 <dir_next+0x1c6>
    36ee:	02 5d       	subi	r16, 0xD2	; 210
    36f0:	1f 4f       	sbci	r17, 0xFF	; 255
    36f2:	88 81       	ld	r24, Y
    36f4:	99 81       	ldd	r25, Y+1	; 0x01
    36f6:	08 0f       	add	r16, r24
    36f8:	19 1f       	adc	r17, r25
    36fa:	1b 8b       	std	Y+19, r17	; 0x13
    36fc:	0a 8b       	std	Y+18, r16	; 0x12
    36fe:	80 e0       	ldi	r24, 0x00	; 0
    3700:	01 c0       	rjmp	.+2      	; 0x3704 <dir_next+0x1e4>
    3702:	87 e0       	ldi	r24, 0x07	; 7
    3704:	df 91       	pop	r29
    3706:	cf 91       	pop	r28
    3708:	1f 91       	pop	r17
    370a:	0f 91       	pop	r16
    370c:	ff 90       	pop	r15
    370e:	ef 90       	pop	r14
    3710:	df 90       	pop	r13
    3712:	cf 90       	pop	r12
    3714:	bf 90       	pop	r11
    3716:	af 90       	pop	r10
    3718:	9f 90       	pop	r9
    371a:	8f 90       	pop	r8
    371c:	7f 90       	pop	r7
    371e:	08 95       	ret

00003720 <follow_path>:
    3720:	4f 92       	push	r4
    3722:	5f 92       	push	r5
    3724:	6f 92       	push	r6
    3726:	7f 92       	push	r7
    3728:	9f 92       	push	r9
    372a:	af 92       	push	r10
    372c:	bf 92       	push	r11
    372e:	cf 92       	push	r12
    3730:	df 92       	push	r13
    3732:	ef 92       	push	r14
    3734:	ff 92       	push	r15
    3736:	0f 93       	push	r16
    3738:	1f 93       	push	r17
    373a:	cf 93       	push	r28
    373c:	df 93       	push	r29
    373e:	ec 01       	movw	r28, r24
    3740:	8b 01       	movw	r16, r22
    3742:	db 01       	movw	r26, r22
    3744:	8c 91       	ld	r24, X
    3746:	8f 32       	cpi	r24, 0x2F	; 47
    3748:	11 f0       	breq	.+4      	; 0x374e <follow_path+0x2e>
    374a:	8c 35       	cpi	r24, 0x5C	; 92
    374c:	11 f4       	brne	.+4      	; 0x3752 <follow_path+0x32>
    374e:	0f 5f       	subi	r16, 0xFF	; 255
    3750:	1f 4f       	sbci	r17, 0xFF	; 255
    3752:	1e 82       	std	Y+6, r1	; 0x06
    3754:	1f 82       	std	Y+7, r1	; 0x07
    3756:	18 86       	std	Y+8, r1	; 0x08
    3758:	19 86       	std	Y+9, r1	; 0x09
    375a:	f8 01       	movw	r30, r16
    375c:	80 81       	ld	r24, Z
    375e:	80 32       	cpi	r24, 0x20	; 32
    3760:	28 f0       	brcs	.+10     	; 0x376c <follow_path+0x4c>
    3762:	70 e2       	ldi	r23, 0x20	; 32
    3764:	a7 2e       	mov	r10, r23
    3766:	e5 e0       	ldi	r30, 0x05	; 5
    3768:	be 2e       	mov	r11, r30
    376a:	62 c0       	rjmp	.+196    	; 0x3830 <follow_path+0x110>
    376c:	60 e0       	ldi	r22, 0x00	; 0
    376e:	70 e0       	ldi	r23, 0x00	; 0
    3770:	ce 01       	movw	r24, r28
    3772:	36 dc       	rcall	.-1940   	; 0x2fe0 <dir_sdi>
    3774:	1b 8a       	std	Y+19, r1	; 0x13
    3776:	1a 8a       	std	Y+18, r1	; 0x12
    3778:	f4 c0       	rjmp	.+488    	; 0x3962 <follow_path+0x242>
    377a:	82 01       	movw	r16, r4
    377c:	20 e0       	ldi	r18, 0x00	; 0
    377e:	30 e0       	ldi	r19, 0x00	; 0
    3780:	80 e0       	ldi	r24, 0x00	; 0
    3782:	90 e0       	ldi	r25, 0x00	; 0
    3784:	48 e0       	ldi	r20, 0x08	; 8
    3786:	50 e0       	ldi	r21, 0x00	; 0
    3788:	91 2c       	mov	r9, r1
    378a:	01 96       	adiw	r24, 0x01	; 1
    378c:	d8 01       	movw	r26, r16
    378e:	7d 91       	ld	r23, X+
    3790:	8d 01       	movw	r16, r26
    3792:	71 32       	cpi	r23, 0x21	; 33
    3794:	08 f0       	brcs	.+2      	; 0x3798 <follow_path+0x78>
    3796:	63 c0       	rjmp	.+198    	; 0x385e <follow_path+0x13e>
    3798:	82 01       	movw	r16, r4
    379a:	08 0f       	add	r16, r24
    379c:	19 1f       	adc	r17, r25
    379e:	71 32       	cpi	r23, 0x21	; 33
    37a0:	08 f4       	brcc	.+2      	; 0x37a4 <follow_path+0x84>
    37a2:	87 c0       	rjmp	.+270    	; 0x38b2 <follow_path+0x192>
    37a4:	80 e0       	ldi	r24, 0x00	; 0
    37a6:	23 2b       	or	r18, r19
    37a8:	09 f4       	brne	.+2      	; 0x37ac <follow_path+0x8c>
    37aa:	b7 c0       	rjmp	.+366    	; 0x391a <follow_path+0x1fa>
    37ac:	90 81       	ld	r25, Z
    37ae:	95 3e       	cpi	r25, 0xE5	; 229
    37b0:	09 f4       	brne	.+2      	; 0x37b4 <follow_path+0x94>
    37b2:	b0 82       	st	Z, r11
    37b4:	48 30       	cpi	r20, 0x08	; 8
    37b6:	51 05       	cpc	r21, r1
    37b8:	11 f4       	brne	.+4      	; 0x37be <follow_path+0x9e>
    37ba:	99 0c       	add	r9, r9
    37bc:	99 0c       	add	r9, r9
    37be:	99 2d       	mov	r25, r9
    37c0:	93 70       	andi	r25, 0x03	; 3
    37c2:	91 30       	cpi	r25, 0x01	; 1
    37c4:	09 f4       	brne	.+2      	; 0x37c8 <follow_path+0xa8>
    37c6:	80 61       	ori	r24, 0x10	; 16
    37c8:	99 2d       	mov	r25, r9
    37ca:	9c 70       	andi	r25, 0x0C	; 12
    37cc:	94 30       	cpi	r25, 0x04	; 4
    37ce:	09 f4       	brne	.+2      	; 0x37d2 <follow_path+0xb2>
    37d0:	88 60       	ori	r24, 0x08	; 8
    37d2:	83 87       	std	Z+11, r24	; 0x0b
    37d4:	60 e0       	ldi	r22, 0x00	; 0
    37d6:	70 e0       	ldi	r23, 0x00	; 0
    37d8:	ce 01       	movw	r24, r28
    37da:	02 dc       	rcall	.-2044   	; 0x2fe0 <dir_sdi>
    37dc:	88 23       	and	r24, r24
    37de:	09 f4       	brne	.+2      	; 0x37e2 <follow_path+0xc2>
    37e0:	6a c0       	rjmp	.+212    	; 0x38b6 <follow_path+0x196>
    37e2:	ec 89       	ldd	r30, Y+20	; 0x14
    37e4:	fd 89       	ldd	r31, Y+21	; 0x15
    37e6:	93 85       	ldd	r25, Z+11	; 0x0b
    37e8:	81 11       	cpse	r24, r1
    37ea:	8e c0       	rjmp	.+284    	; 0x3908 <follow_path+0x1e8>
    37ec:	92 fd       	sbrc	r25, 2
    37ee:	91 c0       	rjmp	.+290    	; 0x3912 <follow_path+0x1f2>
    37f0:	4a 89       	ldd	r20, Y+18	; 0x12
    37f2:	5b 89       	ldd	r21, Y+19	; 0x13
    37f4:	fa 01       	movw	r30, r20
    37f6:	83 85       	ldd	r24, Z+11	; 0x0b
    37f8:	84 ff       	sbrs	r24, 4
    37fa:	8d c0       	rjmp	.+282    	; 0x3916 <follow_path+0x1f6>
    37fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    37fe:	93 8d       	ldd	r25, Z+27	; 0x1b
    3800:	a0 e0       	ldi	r26, 0x00	; 0
    3802:	b0 e0       	ldi	r27, 0x00	; 0
    3804:	28 81       	ld	r18, Y
    3806:	39 81       	ldd	r19, Y+1	; 0x01
    3808:	f9 01       	movw	r30, r18
    380a:	20 81       	ld	r18, Z
    380c:	23 30       	cpi	r18, 0x03	; 3
    380e:	61 f4       	brne	.+24     	; 0x3828 <follow_path+0x108>
    3810:	fa 01       	movw	r30, r20
    3812:	44 89       	ldd	r20, Z+20	; 0x14
    3814:	55 89       	ldd	r21, Z+21	; 0x15
    3816:	60 e0       	ldi	r22, 0x00	; 0
    3818:	70 e0       	ldi	r23, 0x00	; 0
    381a:	ba 01       	movw	r22, r20
    381c:	55 27       	eor	r21, r21
    381e:	44 27       	eor	r20, r20
    3820:	84 2b       	or	r24, r20
    3822:	95 2b       	or	r25, r21
    3824:	a6 2b       	or	r26, r22
    3826:	b7 2b       	or	r27, r23
    3828:	8e 83       	std	Y+6, r24	; 0x06
    382a:	9f 83       	std	Y+7, r25	; 0x07
    382c:	a8 87       	std	Y+8, r26	; 0x08
    382e:	b9 87       	std	Y+9, r27	; 0x09
    3830:	28 01       	movw	r4, r16
    3832:	d8 01       	movw	r26, r16
    3834:	9c 91       	ld	r25, X
    3836:	0f 5f       	subi	r16, 0xFF	; 255
    3838:	1f 4f       	sbci	r17, 0xFF	; 255
    383a:	9f 32       	cpi	r25, 0x2F	; 47
    383c:	c9 f3       	breq	.-14     	; 0x3830 <follow_path+0x110>
    383e:	9c 35       	cpi	r25, 0x5C	; 92
    3840:	b9 f3       	breq	.-18     	; 0x3830 <follow_path+0x110>
    3842:	ec 89       	ldd	r30, Y+20	; 0x14
    3844:	fd 89       	ldd	r31, Y+21	; 0x15
    3846:	cf 01       	movw	r24, r30
    3848:	9f 01       	movw	r18, r30
    384a:	25 5f       	subi	r18, 0xF5	; 245
    384c:	3f 4f       	sbci	r19, 0xFF	; 255
    384e:	82 17       	cp	r24, r18
    3850:	93 07       	cpc	r25, r19
    3852:	09 f4       	brne	.+2      	; 0x3856 <follow_path+0x136>
    3854:	92 cf       	rjmp	.-220    	; 0x377a <follow_path+0x5a>
    3856:	dc 01       	movw	r26, r24
    3858:	ad 92       	st	X+, r10
    385a:	cd 01       	movw	r24, r26
    385c:	f8 cf       	rjmp	.-16     	; 0x384e <follow_path+0x12e>
    385e:	7f 32       	cpi	r23, 0x2F	; 47
    3860:	09 f4       	brne	.+2      	; 0x3864 <follow_path+0x144>
    3862:	9a cf       	rjmp	.-204    	; 0x3798 <follow_path+0x78>
    3864:	7c 35       	cpi	r23, 0x5C	; 92
    3866:	09 f4       	brne	.+2      	; 0x386a <follow_path+0x14a>
    3868:	97 cf       	rjmp	.-210    	; 0x3798 <follow_path+0x78>
    386a:	7e 32       	cpi	r23, 0x2E	; 46
    386c:	09 f4       	brne	.+2      	; 0x3870 <follow_path+0x150>
    386e:	57 c0       	rjmp	.+174    	; 0x391e <follow_path+0x1fe>
    3870:	24 17       	cp	r18, r20
    3872:	35 07       	cpc	r19, r21
    3874:	08 f0       	brcs	.+2      	; 0x3878 <follow_path+0x158>
    3876:	51 c0       	rjmp	.+162    	; 0x391a <follow_path+0x1fa>
    3878:	77 ff       	sbrs	r23, 7
    387a:	09 c0       	rjmp	.+18     	; 0x388e <follow_path+0x16e>
    387c:	b9 2d       	mov	r27, r9
    387e:	b3 60       	ori	r27, 0x03	; 3
    3880:	9b 2e       	mov	r9, r27
    3882:	67 2f       	mov	r22, r23
    3884:	70 e0       	ldi	r23, 0x00	; 0
    3886:	67 52       	subi	r22, 0x27	; 39
    3888:	7e 4f       	sbci	r23, 0xFE	; 254
    388a:	db 01       	movw	r26, r22
    388c:	7c 91       	ld	r23, X
    388e:	c7 2e       	mov	r12, r23
    3890:	d1 2c       	mov	r13, r1
    3892:	6a e4       	ldi	r22, 0x4A	; 74
    3894:	e6 2e       	mov	r14, r22
    3896:	62 e0       	ldi	r22, 0x02	; 2
    3898:	f6 2e       	mov	r15, r22
    389a:	d7 01       	movw	r26, r14
    389c:	6d 91       	ld	r22, X+
    389e:	7d 01       	movw	r14, r26
    38a0:	66 23       	and	r22, r22
    38a2:	09 f4       	brne	.+2      	; 0x38a6 <follow_path+0x186>
    38a4:	46 c0       	rjmp	.+140    	; 0x3932 <follow_path+0x212>
    38a6:	66 2e       	mov	r6, r22
    38a8:	71 2c       	mov	r7, r1
    38aa:	6c 14       	cp	r6, r12
    38ac:	7d 04       	cpc	r7, r13
    38ae:	a9 f7       	brne	.-22     	; 0x389a <follow_path+0x17a>
    38b0:	34 c0       	rjmp	.+104    	; 0x391a <follow_path+0x1fa>
    38b2:	84 e0       	ldi	r24, 0x04	; 4
    38b4:	78 cf       	rjmp	.-272    	; 0x37a6 <follow_path+0x86>
    38b6:	4e 85       	ldd	r20, Y+14	; 0x0e
    38b8:	5f 85       	ldd	r21, Y+15	; 0x0f
    38ba:	68 89       	ldd	r22, Y+16	; 0x10
    38bc:	79 89       	ldd	r23, Y+17	; 0x11
    38be:	88 81       	ld	r24, Y
    38c0:	99 81       	ldd	r25, Y+1	; 0x01
    38c2:	0e 94 2a 14 	call	0x2854	; 0x2854 <move_window>
    38c6:	81 11       	cpse	r24, r1
    38c8:	8c cf       	rjmp	.-232    	; 0x37e2 <follow_path+0xc2>
    38ca:	ea 89       	ldd	r30, Y+18	; 0x12
    38cc:	fb 89       	ldd	r31, Y+19	; 0x13
    38ce:	80 81       	ld	r24, Z
    38d0:	88 23       	and	r24, r24
    38d2:	b1 f0       	breq	.+44     	; 0x3900 <follow_path+0x1e0>
    38d4:	83 85       	ldd	r24, Z+11	; 0x0b
    38d6:	83 fd       	sbrc	r24, 3
    38d8:	0e c0       	rjmp	.+28     	; 0x38f6 <follow_path+0x1d6>
    38da:	ac 89       	ldd	r26, Y+20	; 0x14
    38dc:	bd 89       	ldd	r27, Y+21	; 0x15
    38de:	af 01       	movw	r20, r30
    38e0:	45 5f       	subi	r20, 0xF5	; 245
    38e2:	5f 4f       	sbci	r21, 0xFF	; 255
    38e4:	e4 17       	cp	r30, r20
    38e6:	f5 07       	cpc	r31, r21
    38e8:	69 f0       	breq	.+26     	; 0x3904 <follow_path+0x1e4>
    38ea:	81 91       	ld	r24, Z+
    38ec:	2d 91       	ld	r18, X+
    38ee:	90 e0       	ldi	r25, 0x00	; 0
    38f0:	82 1b       	sub	r24, r18
    38f2:	91 09       	sbc	r25, r1
    38f4:	b9 f3       	breq	.-18     	; 0x38e4 <follow_path+0x1c4>
    38f6:	60 e0       	ldi	r22, 0x00	; 0
    38f8:	70 e0       	ldi	r23, 0x00	; 0
    38fa:	ce 01       	movw	r24, r28
    38fc:	11 de       	rcall	.-990    	; 0x3520 <dir_next>
    38fe:	6e cf       	rjmp	.-292    	; 0x37dc <follow_path+0xbc>
    3900:	84 e0       	ldi	r24, 0x04	; 4
    3902:	6f cf       	rjmp	.-290    	; 0x37e2 <follow_path+0xc2>
    3904:	80 e0       	ldi	r24, 0x00	; 0
    3906:	6d cf       	rjmp	.-294    	; 0x37e2 <follow_path+0xc2>
    3908:	84 30       	cpi	r24, 0x04	; 4
    390a:	59 f5       	brne	.+86     	; 0x3962 <follow_path+0x242>
    390c:	92 ff       	sbrs	r25, 2
    390e:	03 c0       	rjmp	.+6      	; 0x3916 <follow_path+0x1f6>
    3910:	28 c0       	rjmp	.+80     	; 0x3962 <follow_path+0x242>
    3912:	80 e0       	ldi	r24, 0x00	; 0
    3914:	26 c0       	rjmp	.+76     	; 0x3962 <follow_path+0x242>
    3916:	85 e0       	ldi	r24, 0x05	; 5
    3918:	24 c0       	rjmp	.+72     	; 0x3962 <follow_path+0x242>
    391a:	86 e0       	ldi	r24, 0x06	; 6
    391c:	22 c0       	rjmp	.+68     	; 0x3962 <follow_path+0x242>
    391e:	48 30       	cpi	r20, 0x08	; 8
    3920:	51 05       	cpc	r21, r1
    3922:	d9 f7       	brne	.-10     	; 0x391a <follow_path+0x1fa>
    3924:	99 0c       	add	r9, r9
    3926:	99 0c       	add	r9, r9
    3928:	28 e0       	ldi	r18, 0x08	; 8
    392a:	30 e0       	ldi	r19, 0x00	; 0
    392c:	4b e0       	ldi	r20, 0x0B	; 11
    392e:	50 e0       	ldi	r21, 0x00	; 0
    3930:	2c cf       	rjmp	.-424    	; 0x378a <follow_path+0x6a>
    3932:	6f eb       	ldi	r22, 0xBF	; 191
    3934:	67 0f       	add	r22, r23
    3936:	6a 31       	cpi	r22, 0x1A	; 26
    3938:	20 f4       	brcc	.+8      	; 0x3942 <follow_path+0x222>
    393a:	b9 2d       	mov	r27, r9
    393c:	b2 60       	ori	r27, 0x02	; 2
    393e:	9b 2e       	mov	r9, r27
    3940:	08 c0       	rjmp	.+16     	; 0x3952 <follow_path+0x232>
    3942:	6f e9       	ldi	r22, 0x9F	; 159
    3944:	67 0f       	add	r22, r23
    3946:	6a 31       	cpi	r22, 0x1A	; 26
    3948:	20 f4       	brcc	.+8      	; 0x3952 <follow_path+0x232>
    394a:	69 2d       	mov	r22, r9
    394c:	61 60       	ori	r22, 0x01	; 1
    394e:	96 2e       	mov	r9, r22
    3950:	70 52       	subi	r23, 0x20	; 32
    3952:	7f 01       	movw	r14, r30
    3954:	e2 0e       	add	r14, r18
    3956:	f3 1e       	adc	r15, r19
    3958:	d7 01       	movw	r26, r14
    395a:	7c 93       	st	X, r23
    395c:	2f 5f       	subi	r18, 0xFF	; 255
    395e:	3f 4f       	sbci	r19, 0xFF	; 255
    3960:	14 cf       	rjmp	.-472    	; 0x378a <follow_path+0x6a>
    3962:	df 91       	pop	r29
    3964:	cf 91       	pop	r28
    3966:	1f 91       	pop	r17
    3968:	0f 91       	pop	r16
    396a:	ff 90       	pop	r15
    396c:	ef 90       	pop	r14
    396e:	df 90       	pop	r13
    3970:	cf 90       	pop	r12
    3972:	bf 90       	pop	r11
    3974:	af 90       	pop	r10
    3976:	9f 90       	pop	r9
    3978:	7f 90       	pop	r7
    397a:	6f 90       	pop	r6
    397c:	5f 90       	pop	r5
    397e:	4f 90       	pop	r4
    3980:	08 95       	ret

00003982 <dir_register>:
    3982:	1f 93       	push	r17
    3984:	cf 93       	push	r28
    3986:	df 93       	push	r29
    3988:	ec 01       	movw	r28, r24
    398a:	60 e0       	ldi	r22, 0x00	; 0
    398c:	70 e0       	ldi	r23, 0x00	; 0
    398e:	28 db       	rcall	.-2480   	; 0x2fe0 <dir_sdi>
    3990:	18 2f       	mov	r17, r24
    3992:	81 11       	cpse	r24, r1
    3994:	17 c0       	rjmp	.+46     	; 0x39c4 <dir_register+0x42>
    3996:	4e 85       	ldd	r20, Y+14	; 0x0e
    3998:	5f 85       	ldd	r21, Y+15	; 0x0f
    399a:	68 89       	ldd	r22, Y+16	; 0x10
    399c:	79 89       	ldd	r23, Y+17	; 0x11
    399e:	88 81       	ld	r24, Y
    39a0:	99 81       	ldd	r25, Y+1	; 0x01
    39a2:	0e 94 2a 14 	call	0x2854	; 0x2854 <move_window>
    39a6:	18 2f       	mov	r17, r24
    39a8:	81 11       	cpse	r24, r1
    39aa:	0c c0       	rjmp	.+24     	; 0x39c4 <dir_register+0x42>
    39ac:	ea 89       	ldd	r30, Y+18	; 0x12
    39ae:	fb 89       	ldd	r31, Y+19	; 0x13
    39b0:	80 81       	ld	r24, Z
    39b2:	85 3e       	cpi	r24, 0xE5	; 229
    39b4:	59 f0       	breq	.+22     	; 0x39cc <dir_register+0x4a>
    39b6:	88 23       	and	r24, r24
    39b8:	49 f0       	breq	.+18     	; 0x39cc <dir_register+0x4a>
    39ba:	61 e0       	ldi	r22, 0x01	; 1
    39bc:	70 e0       	ldi	r23, 0x00	; 0
    39be:	ce 01       	movw	r24, r28
    39c0:	af dd       	rcall	.-1186   	; 0x3520 <dir_next>
    39c2:	e6 cf       	rjmp	.-52     	; 0x3990 <dir_register+0xe>
    39c4:	14 30       	cpi	r17, 0x04	; 4
    39c6:	11 f5       	brne	.+68     	; 0x3a0c <dir_register+0x8a>
    39c8:	17 e0       	ldi	r17, 0x07	; 7
    39ca:	20 c0       	rjmp	.+64     	; 0x3a0c <dir_register+0x8a>
    39cc:	4e 85       	ldd	r20, Y+14	; 0x0e
    39ce:	5f 85       	ldd	r21, Y+15	; 0x0f
    39d0:	68 89       	ldd	r22, Y+16	; 0x10
    39d2:	79 89       	ldd	r23, Y+17	; 0x11
    39d4:	88 81       	ld	r24, Y
    39d6:	99 81       	ldd	r25, Y+1	; 0x01
    39d8:	0e 94 2a 14 	call	0x2854	; 0x2854 <move_window>
    39dc:	18 2f       	mov	r17, r24
    39de:	81 11       	cpse	r24, r1
    39e0:	15 c0       	rjmp	.+42     	; 0x3a0c <dir_register+0x8a>
    39e2:	ea 89       	ldd	r30, Y+18	; 0x12
    39e4:	fb 89       	ldd	r31, Y+19	; 0x13
    39e6:	cf 01       	movw	r24, r30
    39e8:	80 96       	adiw	r24, 0x20	; 32
    39ea:	e8 17       	cp	r30, r24
    39ec:	f9 07       	cpc	r31, r25
    39ee:	11 f0       	breq	.+4      	; 0x39f4 <dir_register+0x72>
    39f0:	11 92       	st	Z+, r1
    39f2:	fb cf       	rjmp	.-10     	; 0x39ea <dir_register+0x68>
    39f4:	6c 89       	ldd	r22, Y+20	; 0x14
    39f6:	7d 89       	ldd	r23, Y+21	; 0x15
    39f8:	4b e0       	ldi	r20, 0x0B	; 11
    39fa:	50 e0       	ldi	r21, 0x00	; 0
    39fc:	8a 89       	ldd	r24, Y+18	; 0x12
    39fe:	9b 89       	ldd	r25, Y+19	; 0x13
    3a00:	0e 94 bb 12 	call	0x2576	; 0x2576 <mem_cpy>
    3a04:	e8 81       	ld	r30, Y
    3a06:	f9 81       	ldd	r31, Y+1	; 0x01
    3a08:	81 e0       	ldi	r24, 0x01	; 1
    3a0a:	84 83       	std	Z+4, r24	; 0x04
    3a0c:	81 2f       	mov	r24, r17
    3a0e:	df 91       	pop	r29
    3a10:	cf 91       	pop	r28
    3a12:	1f 91       	pop	r17
    3a14:	08 95       	ret

00003a16 <remove_chain>:
    3a16:	8f 92       	push	r8
    3a18:	9f 92       	push	r9
    3a1a:	af 92       	push	r10
    3a1c:	bf 92       	push	r11
    3a1e:	cf 92       	push	r12
    3a20:	df 92       	push	r13
    3a22:	ef 92       	push	r14
    3a24:	ff 92       	push	r15
    3a26:	0f 93       	push	r16
    3a28:	1f 93       	push	r17
    3a2a:	cf 93       	push	r28
    3a2c:	df 93       	push	r29
    3a2e:	ec 01       	movw	r28, r24
    3a30:	6a 01       	movw	r12, r20
    3a32:	7b 01       	movw	r14, r22
    3a34:	42 30       	cpi	r20, 0x02	; 2
    3a36:	51 05       	cpc	r21, r1
    3a38:	61 05       	cpc	r22, r1
    3a3a:	71 05       	cpc	r23, r1
    3a3c:	10 f4       	brcc	.+4      	; 0x3a42 <remove_chain+0x2c>
    3a3e:	82 e0       	ldi	r24, 0x02	; 2
    3a40:	4b c0       	rjmp	.+150    	; 0x3ad8 <remove_chain+0xc2>
    3a42:	8a 89       	ldd	r24, Y+18	; 0x12
    3a44:	9b 89       	ldd	r25, Y+19	; 0x13
    3a46:	ac 89       	ldd	r26, Y+20	; 0x14
    3a48:	bd 89       	ldd	r27, Y+21	; 0x15
    3a4a:	48 17       	cp	r20, r24
    3a4c:	59 07       	cpc	r21, r25
    3a4e:	6a 07       	cpc	r22, r26
    3a50:	7b 07       	cpc	r23, r27
    3a52:	a8 f7       	brcc	.-22     	; 0x3a3e <remove_chain+0x28>
    3a54:	8a 89       	ldd	r24, Y+18	; 0x12
    3a56:	9b 89       	ldd	r25, Y+19	; 0x13
    3a58:	ac 89       	ldd	r26, Y+20	; 0x14
    3a5a:	bd 89       	ldd	r27, Y+21	; 0x15
    3a5c:	c8 16       	cp	r12, r24
    3a5e:	d9 06       	cpc	r13, r25
    3a60:	ea 06       	cpc	r14, r26
    3a62:	fb 06       	cpc	r15, r27
    3a64:	50 f4       	brcc	.+20     	; 0x3a7a <remove_chain+0x64>
    3a66:	b7 01       	movw	r22, r14
    3a68:	a6 01       	movw	r20, r12
    3a6a:	ce 01       	movw	r24, r28
    3a6c:	ee d9       	rcall	.-3108   	; 0x2e4a <get_fat>
    3a6e:	4b 01       	movw	r8, r22
    3a70:	5c 01       	movw	r10, r24
    3a72:	67 2b       	or	r22, r23
    3a74:	68 2b       	or	r22, r24
    3a76:	69 2b       	or	r22, r25
    3a78:	11 f4       	brne	.+4      	; 0x3a7e <remove_chain+0x68>
    3a7a:	80 e0       	ldi	r24, 0x00	; 0
    3a7c:	2d c0       	rjmp	.+90     	; 0x3ad8 <remove_chain+0xc2>
    3a7e:	81 e0       	ldi	r24, 0x01	; 1
    3a80:	88 16       	cp	r8, r24
    3a82:	91 04       	cpc	r9, r1
    3a84:	a1 04       	cpc	r10, r1
    3a86:	b1 04       	cpc	r11, r1
    3a88:	d1 f2       	breq	.-76     	; 0x3a3e <remove_chain+0x28>
    3a8a:	2f ef       	ldi	r18, 0xFF	; 255
    3a8c:	82 16       	cp	r8, r18
    3a8e:	92 06       	cpc	r9, r18
    3a90:	a2 06       	cpc	r10, r18
    3a92:	b2 06       	cpc	r11, r18
    3a94:	01 f1       	breq	.+64     	; 0x3ad6 <remove_chain+0xc0>
    3a96:	00 e0       	ldi	r16, 0x00	; 0
    3a98:	10 e0       	ldi	r17, 0x00	; 0
    3a9a:	98 01       	movw	r18, r16
    3a9c:	b7 01       	movw	r22, r14
    3a9e:	a6 01       	movw	r20, r12
    3aa0:	ce 01       	movw	r24, r28
    3aa2:	4f db       	rcall	.-2402   	; 0x3142 <put_fat>
    3aa4:	81 11       	cpse	r24, r1
    3aa6:	18 c0       	rjmp	.+48     	; 0x3ad8 <remove_chain+0xc2>
    3aa8:	8e 85       	ldd	r24, Y+14	; 0x0e
    3aaa:	9f 85       	ldd	r25, Y+15	; 0x0f
    3aac:	a8 89       	ldd	r26, Y+16	; 0x10
    3aae:	b9 89       	ldd	r27, Y+17	; 0x11
    3ab0:	8f 3f       	cpi	r24, 0xFF	; 255
    3ab2:	2f ef       	ldi	r18, 0xFF	; 255
    3ab4:	92 07       	cpc	r25, r18
    3ab6:	a2 07       	cpc	r26, r18
    3ab8:	b2 07       	cpc	r27, r18
    3aba:	51 f0       	breq	.+20     	; 0x3ad0 <remove_chain+0xba>
    3abc:	01 96       	adiw	r24, 0x01	; 1
    3abe:	a1 1d       	adc	r26, r1
    3ac0:	b1 1d       	adc	r27, r1
    3ac2:	8e 87       	std	Y+14, r24	; 0x0e
    3ac4:	9f 87       	std	Y+15, r25	; 0x0f
    3ac6:	a8 8b       	std	Y+16, r26	; 0x10
    3ac8:	b9 8b       	std	Y+17, r27	; 0x11
    3aca:	8d 81       	ldd	r24, Y+5	; 0x05
    3acc:	81 60       	ori	r24, 0x01	; 1
    3ace:	8d 83       	std	Y+5, r24	; 0x05
    3ad0:	75 01       	movw	r14, r10
    3ad2:	64 01       	movw	r12, r8
    3ad4:	bf cf       	rjmp	.-130    	; 0x3a54 <remove_chain+0x3e>
    3ad6:	81 e0       	ldi	r24, 0x01	; 1
    3ad8:	df 91       	pop	r29
    3ada:	cf 91       	pop	r28
    3adc:	1f 91       	pop	r17
    3ade:	0f 91       	pop	r16
    3ae0:	ff 90       	pop	r15
    3ae2:	ef 90       	pop	r14
    3ae4:	df 90       	pop	r13
    3ae6:	cf 90       	pop	r12
    3ae8:	bf 90       	pop	r11
    3aea:	af 90       	pop	r10
    3aec:	9f 90       	pop	r9
    3aee:	8f 90       	pop	r8
    3af0:	08 95       	ret

00003af2 <f_mount>:
    3af2:	cf 93       	push	r28
    3af4:	df 93       	push	r29
    3af6:	cd b7       	in	r28, 0x3d	; 61
    3af8:	de b7       	in	r29, 0x3e	; 62
    3afa:	27 97       	sbiw	r28, 0x07	; 7
    3afc:	0f b6       	in	r0, 0x3f	; 63
    3afe:	f8 94       	cli
    3b00:	de bf       	out	0x3e, r29	; 62
    3b02:	0f be       	out	0x3f, r0	; 63
    3b04:	cd bf       	out	0x3d, r28	; 61
    3b06:	9c 83       	std	Y+4, r25	; 0x04
    3b08:	8b 83       	std	Y+3, r24	; 0x03
    3b0a:	7e 83       	std	Y+6, r23	; 0x06
    3b0c:	6d 83       	std	Y+5, r22	; 0x05
    3b0e:	7a 83       	std	Y+2, r23	; 0x02
    3b10:	69 83       	std	Y+1, r22	; 0x01
    3b12:	ce 01       	movw	r24, r28
    3b14:	01 96       	adiw	r24, 0x01	; 1
    3b16:	4f 83       	std	Y+7, r20	; 0x07
    3b18:	0e 94 25 13 	call	0x264a	; 0x264a <get_ldnumber>
    3b1c:	4f 81       	ldd	r20, Y+7	; 0x07
    3b1e:	97 fd       	sbrc	r25, 7
    3b20:	24 c0       	rjmp	.+72     	; 0x3b6a <f_mount+0x78>
    3b22:	88 0f       	add	r24, r24
    3b24:	99 1f       	adc	r25, r25
    3b26:	fc 01       	movw	r30, r24
    3b28:	e6 5a       	subi	r30, 0xA6	; 166
    3b2a:	fa 4f       	sbci	r31, 0xFA	; 250
    3b2c:	01 90       	ld	r0, Z+
    3b2e:	f0 81       	ld	r31, Z
    3b30:	e0 2d       	mov	r30, r0
    3b32:	30 97       	sbiw	r30, 0x00	; 0
    3b34:	09 f0       	breq	.+2      	; 0x3b38 <f_mount+0x46>
    3b36:	10 82       	st	Z, r1
    3b38:	eb 81       	ldd	r30, Y+3	; 0x03
    3b3a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b3c:	30 97       	sbiw	r30, 0x00	; 0
    3b3e:	09 f0       	breq	.+2      	; 0x3b42 <f_mount+0x50>
    3b40:	10 82       	st	Z, r1
    3b42:	2b 81       	ldd	r18, Y+3	; 0x03
    3b44:	3c 81       	ldd	r19, Y+4	; 0x04
    3b46:	fc 01       	movw	r30, r24
    3b48:	e6 5a       	subi	r30, 0xA6	; 166
    3b4a:	fa 4f       	sbci	r31, 0xFA	; 250
    3b4c:	31 83       	std	Z+1, r19	; 0x01
    3b4e:	20 83       	st	Z, r18
    3b50:	23 2b       	or	r18, r19
    3b52:	69 f0       	breq	.+26     	; 0x3b6e <f_mount+0x7c>
    3b54:	41 30       	cpi	r20, 0x01	; 1
    3b56:	59 f4       	brne	.+22     	; 0x3b6e <f_mount+0x7c>
    3b58:	40 e0       	ldi	r20, 0x00	; 0
    3b5a:	be 01       	movw	r22, r28
    3b5c:	6b 5f       	subi	r22, 0xFB	; 251
    3b5e:	7f 4f       	sbci	r23, 0xFF	; 255
    3b60:	ce 01       	movw	r24, r28
    3b62:	03 96       	adiw	r24, 0x03	; 3
    3b64:	0e 94 9f 14 	call	0x293e	; 0x293e <find_volume>
    3b68:	03 c0       	rjmp	.+6      	; 0x3b70 <f_mount+0x7e>
    3b6a:	8b e0       	ldi	r24, 0x0B	; 11
    3b6c:	01 c0       	rjmp	.+2      	; 0x3b70 <f_mount+0x7e>
    3b6e:	80 e0       	ldi	r24, 0x00	; 0
    3b70:	27 96       	adiw	r28, 0x07	; 7
    3b72:	0f b6       	in	r0, 0x3f	; 63
    3b74:	f8 94       	cli
    3b76:	de bf       	out	0x3e, r29	; 62
    3b78:	0f be       	out	0x3f, r0	; 63
    3b7a:	cd bf       	out	0x3d, r28	; 61
    3b7c:	df 91       	pop	r29
    3b7e:	cf 91       	pop	r28
    3b80:	08 95       	ret

00003b82 <f_open>:
    3b82:	4f 92       	push	r4
    3b84:	5f 92       	push	r5
    3b86:	6f 92       	push	r6
    3b88:	7f 92       	push	r7
    3b8a:	8f 92       	push	r8
    3b8c:	9f 92       	push	r9
    3b8e:	af 92       	push	r10
    3b90:	bf 92       	push	r11
    3b92:	df 92       	push	r13
    3b94:	ef 92       	push	r14
    3b96:	ff 92       	push	r15
    3b98:	0f 93       	push	r16
    3b9a:	1f 93       	push	r17
    3b9c:	cf 93       	push	r28
    3b9e:	df 93       	push	r29
    3ba0:	cd b7       	in	r28, 0x3d	; 61
    3ba2:	de b7       	in	r29, 0x3e	; 62
    3ba4:	a4 97       	sbiw	r28, 0x24	; 36
    3ba6:	0f b6       	in	r0, 0x3f	; 63
    3ba8:	f8 94       	cli
    3baa:	de bf       	out	0x3e, r29	; 62
    3bac:	0f be       	out	0x3f, r0	; 63
    3bae:	cd bf       	out	0x3d, r28	; 61
    3bb0:	7c a3       	std	Y+36, r23	; 0x24
    3bb2:	6b a3       	std	Y+35, r22	; 0x23
    3bb4:	00 97       	sbiw	r24, 0x00	; 0
    3bb6:	09 f4       	brne	.+2      	; 0x3bba <f_open+0x38>
    3bb8:	f1 c0       	rjmp	.+482    	; 0x3d9c <f_open+0x21a>
    3bba:	b4 2e       	mov	r11, r20
    3bbc:	7c 01       	movw	r14, r24
    3bbe:	dc 01       	movw	r26, r24
    3bc0:	1d 92       	st	X+, r1
    3bc2:	1c 92       	st	X, r1
    3bc4:	4e 71       	andi	r20, 0x1E	; 30
    3bc6:	be 01       	movw	r22, r28
    3bc8:	6d 5d       	subi	r22, 0xDD	; 221
    3bca:	7f 4f       	sbci	r23, 0xFF	; 255
    3bcc:	ce 01       	movw	r24, r28
    3bce:	01 96       	adiw	r24, 0x01	; 1
    3bd0:	0e 94 9f 14 	call	0x293e	; 0x293e <find_volume>
    3bd4:	81 11       	cpse	r24, r1
    3bd6:	e9 c0       	rjmp	.+466    	; 0x3daa <f_open+0x228>
    3bd8:	ce 01       	movw	r24, r28
    3bda:	47 96       	adiw	r24, 0x17	; 23
    3bdc:	9e 8b       	std	Y+22, r25	; 0x16
    3bde:	8d 8b       	std	Y+21, r24	; 0x15
    3be0:	6b a1       	ldd	r22, Y+35	; 0x23
    3be2:	7c a1       	ldd	r23, Y+36	; 0x24
    3be4:	46 97       	sbiw	r24, 0x16	; 22
    3be6:	9c dd       	rcall	.-1224   	; 0x3720 <follow_path>
    3be8:	0b 89       	ldd	r16, Y+19	; 0x13
    3bea:	1c 89       	ldd	r17, Y+20	; 0x14
    3bec:	81 11       	cpse	r24, r1
    3bee:	04 c0       	rjmp	.+8      	; 0x3bf8 <f_open+0x76>
    3bf0:	01 15       	cp	r16, r1
    3bf2:	11 05       	cpc	r17, r1
    3bf4:	09 f4       	brne	.+2      	; 0x3bf8 <f_open+0x76>
    3bf6:	86 e0       	ldi	r24, 0x06	; 6
    3bf8:	bb 2d       	mov	r27, r11
    3bfa:	bf 71       	andi	r27, 0x1F	; 31
    3bfc:	db 2e       	mov	r13, r27
    3bfe:	9b 2d       	mov	r25, r11
    3c00:	9c 71       	andi	r25, 0x1C	; 28
    3c02:	09 f4       	brne	.+2      	; 0x3c06 <f_open+0x84>
    3c04:	6d c0       	rjmp	.+218    	; 0x3ce0 <f_open+0x15e>
    3c06:	88 23       	and	r24, r24
    3c08:	69 f0       	breq	.+26     	; 0x3c24 <f_open+0xa2>
    3c0a:	84 30       	cpi	r24, 0x04	; 4
    3c0c:	19 f4       	brne	.+6      	; 0x3c14 <f_open+0x92>
    3c0e:	ce 01       	movw	r24, r28
    3c10:	01 96       	adiw	r24, 0x01	; 1
    3c12:	b7 de       	rcall	.-658    	; 0x3982 <dir_register>
    3c14:	ed 2d       	mov	r30, r13
    3c16:	e8 60       	ori	r30, 0x08	; 8
    3c18:	de 2e       	mov	r13, r30
    3c1a:	0b 89       	ldd	r16, Y+19	; 0x13
    3c1c:	1c 89       	ldd	r17, Y+20	; 0x14
    3c1e:	88 23       	and	r24, r24
    3c20:	49 f0       	breq	.+18     	; 0x3c34 <f_open+0xb2>
    3c22:	c3 c0       	rjmp	.+390    	; 0x3daa <f_open+0x228>
    3c24:	d8 01       	movw	r26, r16
    3c26:	1b 96       	adiw	r26, 0x0b	; 11
    3c28:	8c 91       	ld	r24, X
    3c2a:	81 71       	andi	r24, 0x11	; 17
    3c2c:	09 f0       	breq	.+2      	; 0x3c30 <f_open+0xae>
    3c2e:	bc c0       	rjmp	.+376    	; 0x3da8 <f_open+0x226>
    3c30:	b2 fc       	sbrc	r11, 2
    3c32:	b6 c0       	rjmp	.+364    	; 0x3da0 <f_open+0x21e>
    3c34:	d3 fe       	sbrs	r13, 3
    3c36:	5f c0       	rjmp	.+190    	; 0x3cf6 <f_open+0x174>
    3c38:	80 e0       	ldi	r24, 0x00	; 0
    3c3a:	90 e0       	ldi	r25, 0x00	; 0
    3c3c:	a9 e6       	ldi	r26, 0x69	; 105
    3c3e:	b5 e4       	ldi	r27, 0x45	; 69
    3c40:	f8 01       	movw	r30, r16
    3c42:	86 87       	std	Z+14, r24	; 0x0e
    3c44:	97 87       	std	Z+15, r25	; 0x0f
    3c46:	a0 8b       	std	Z+16, r26	; 0x10
    3c48:	b1 8b       	std	Z+17, r27	; 0x11
    3c4a:	13 86       	std	Z+11, r1	; 0x0b
    3c4c:	d8 01       	movw	r26, r16
    3c4e:	14 8e       	std	Z+28, r1	; 0x1c
    3c50:	15 8e       	std	Z+29, r1	; 0x1d
    3c52:	16 8e       	std	Z+30, r1	; 0x1e
    3c54:	17 8e       	std	Z+31, r1	; 0x1f
    3c56:	e9 81       	ldd	r30, Y+1	; 0x01
    3c58:	fa 81       	ldd	r31, Y+2	; 0x02
    3c5a:	5a 96       	adiw	r26, 0x1a	; 26
    3c5c:	8d 90       	ld	r8, X+
    3c5e:	9c 90       	ld	r9, X
    3c60:	5b 97       	sbiw	r26, 0x1b	; 27
    3c62:	a1 2c       	mov	r10, r1
    3c64:	b1 2c       	mov	r11, r1
    3c66:	80 81       	ld	r24, Z
    3c68:	83 30       	cpi	r24, 0x03	; 3
    3c6a:	69 f4       	brne	.+26     	; 0x3c86 <f_open+0x104>
    3c6c:	54 96       	adiw	r26, 0x14	; 20
    3c6e:	4d 91       	ld	r20, X+
    3c70:	5c 91       	ld	r21, X
    3c72:	55 97       	sbiw	r26, 0x15	; 21
    3c74:	60 e0       	ldi	r22, 0x00	; 0
    3c76:	70 e0       	ldi	r23, 0x00	; 0
    3c78:	ba 01       	movw	r22, r20
    3c7a:	55 27       	eor	r21, r21
    3c7c:	44 27       	eor	r20, r20
    3c7e:	84 2a       	or	r8, r20
    3c80:	95 2a       	or	r9, r21
    3c82:	a6 2a       	or	r10, r22
    3c84:	b7 2a       	or	r11, r23
    3c86:	d8 01       	movw	r26, r16
    3c88:	5b 96       	adiw	r26, 0x1b	; 27
    3c8a:	1c 92       	st	X, r1
    3c8c:	1e 92       	st	-X, r1
    3c8e:	5a 97       	sbiw	r26, 0x1a	; 26
    3c90:	55 96       	adiw	r26, 0x15	; 21
    3c92:	1c 92       	st	X, r1
    3c94:	1e 92       	st	-X, r1
    3c96:	54 97       	sbiw	r26, 0x14	; 20
    3c98:	81 e0       	ldi	r24, 0x01	; 1
    3c9a:	84 83       	std	Z+4, r24	; 0x04
    3c9c:	81 14       	cp	r8, r1
    3c9e:	91 04       	cpc	r9, r1
    3ca0:	a1 04       	cpc	r10, r1
    3ca2:	b1 04       	cpc	r11, r1
    3ca4:	41 f1       	breq	.+80     	; 0x3cf6 <f_open+0x174>
    3ca6:	42 a4       	ldd	r4, Z+42	; 0x2a
    3ca8:	53 a4       	ldd	r5, Z+43	; 0x2b
    3caa:	64 a4       	ldd	r6, Z+44	; 0x2c
    3cac:	75 a4       	ldd	r7, Z+45	; 0x2d
    3cae:	b5 01       	movw	r22, r10
    3cb0:	a4 01       	movw	r20, r8
    3cb2:	cf 01       	movw	r24, r30
    3cb4:	b0 de       	rcall	.-672    	; 0x3a16 <remove_chain>
    3cb6:	81 11       	cpse	r24, r1
    3cb8:	78 c0       	rjmp	.+240    	; 0x3daa <f_open+0x228>
    3cba:	89 81       	ldd	r24, Y+1	; 0x01
    3cbc:	9a 81       	ldd	r25, Y+2	; 0x02
    3cbe:	b1 e0       	ldi	r27, 0x01	; 1
    3cc0:	8b 1a       	sub	r8, r27
    3cc2:	91 08       	sbc	r9, r1
    3cc4:	a1 08       	sbc	r10, r1
    3cc6:	b1 08       	sbc	r11, r1
    3cc8:	fc 01       	movw	r30, r24
    3cca:	82 86       	std	Z+10, r8	; 0x0a
    3ccc:	93 86       	std	Z+11, r9	; 0x0b
    3cce:	a4 86       	std	Z+12, r10	; 0x0c
    3cd0:	b5 86       	std	Z+13, r11	; 0x0d
    3cd2:	b3 01       	movw	r22, r6
    3cd4:	a2 01       	movw	r20, r4
    3cd6:	0e 94 2a 14 	call	0x2854	; 0x2854 <move_window>
    3cda:	88 23       	and	r24, r24
    3cdc:	61 f0       	breq	.+24     	; 0x3cf6 <f_open+0x174>
    3cde:	65 c0       	rjmp	.+202    	; 0x3daa <f_open+0x228>
    3ce0:	81 11       	cpse	r24, r1
    3ce2:	63 c0       	rjmp	.+198    	; 0x3daa <f_open+0x228>
    3ce4:	d8 01       	movw	r26, r16
    3ce6:	1b 96       	adiw	r26, 0x0b	; 11
    3ce8:	8c 91       	ld	r24, X
    3cea:	84 fd       	sbrc	r24, 4
    3cec:	5b c0       	rjmp	.+182    	; 0x3da4 <f_open+0x222>
    3cee:	b1 fe       	sbrs	r11, 1
    3cf0:	02 c0       	rjmp	.+4      	; 0x3cf6 <f_open+0x174>
    3cf2:	80 fd       	sbrc	r24, 0
    3cf4:	59 c0       	rjmp	.+178    	; 0x3da8 <f_open+0x226>
    3cf6:	d3 fe       	sbrs	r13, 3
    3cf8:	03 c0       	rjmp	.+6      	; 0x3d00 <f_open+0x17e>
    3cfa:	bd 2d       	mov	r27, r13
    3cfc:	b0 62       	ori	r27, 0x20	; 32
    3cfe:	db 2e       	mov	r13, r27
    3d00:	a9 80       	ldd	r10, Y+1	; 0x01
    3d02:	ba 80       	ldd	r11, Y+2	; 0x02
    3d04:	f5 01       	movw	r30, r10
    3d06:	42 a5       	ldd	r20, Z+42	; 0x2a
    3d08:	53 a5       	ldd	r21, Z+43	; 0x2b
    3d0a:	64 a5       	ldd	r22, Z+44	; 0x2c
    3d0c:	75 a5       	ldd	r23, Z+45	; 0x2d
    3d0e:	d7 01       	movw	r26, r14
    3d10:	5a 96       	adiw	r26, 0x1a	; 26
    3d12:	4d 93       	st	X+, r20
    3d14:	5d 93       	st	X+, r21
    3d16:	6d 93       	st	X+, r22
    3d18:	7c 93       	st	X, r23
    3d1a:	5d 97       	sbiw	r26, 0x1d	; 29
    3d1c:	5f 96       	adiw	r26, 0x1f	; 31
    3d1e:	1c 93       	st	X, r17
    3d20:	0e 93       	st	-X, r16
    3d22:	5e 97       	sbiw	r26, 0x1e	; 30
    3d24:	14 96       	adiw	r26, 0x04	; 4
    3d26:	dc 92       	st	X, r13
    3d28:	14 97       	sbiw	r26, 0x04	; 4
    3d2a:	15 96       	adiw	r26, 0x05	; 5
    3d2c:	1c 92       	st	X, r1
    3d2e:	f8 01       	movw	r30, r16
    3d30:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d32:	93 8d       	ldd	r25, Z+27	; 0x1b
    3d34:	a0 e0       	ldi	r26, 0x00	; 0
    3d36:	b0 e0       	ldi	r27, 0x00	; 0
    3d38:	f5 01       	movw	r30, r10
    3d3a:	20 81       	ld	r18, Z
    3d3c:	23 30       	cpi	r18, 0x03	; 3
    3d3e:	61 f4       	brne	.+24     	; 0x3d58 <f_open+0x1d6>
    3d40:	f8 01       	movw	r30, r16
    3d42:	44 89       	ldd	r20, Z+20	; 0x14
    3d44:	55 89       	ldd	r21, Z+21	; 0x15
    3d46:	60 e0       	ldi	r22, 0x00	; 0
    3d48:	70 e0       	ldi	r23, 0x00	; 0
    3d4a:	ba 01       	movw	r22, r20
    3d4c:	55 27       	eor	r21, r21
    3d4e:	44 27       	eor	r20, r20
    3d50:	84 2b       	or	r24, r20
    3d52:	95 2b       	or	r25, r21
    3d54:	a6 2b       	or	r26, r22
    3d56:	b7 2b       	or	r27, r23
    3d58:	f7 01       	movw	r30, r14
    3d5a:	86 87       	std	Z+14, r24	; 0x0e
    3d5c:	97 87       	std	Z+15, r25	; 0x0f
    3d5e:	a0 8b       	std	Z+16, r26	; 0x10
    3d60:	b1 8b       	std	Z+17, r27	; 0x11
    3d62:	f8 01       	movw	r30, r16
    3d64:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d66:	95 8d       	ldd	r25, Z+29	; 0x1d
    3d68:	a6 8d       	ldd	r26, Z+30	; 0x1e
    3d6a:	b7 8d       	ldd	r27, Z+31	; 0x1f
    3d6c:	f7 01       	movw	r30, r14
    3d6e:	82 87       	std	Z+10, r24	; 0x0a
    3d70:	93 87       	std	Z+11, r25	; 0x0b
    3d72:	a4 87       	std	Z+12, r26	; 0x0c
    3d74:	b5 87       	std	Z+13, r27	; 0x0d
    3d76:	16 82       	std	Z+6, r1	; 0x06
    3d78:	17 82       	std	Z+7, r1	; 0x07
    3d7a:	10 86       	std	Z+8, r1	; 0x08
    3d7c:	11 86       	std	Z+9, r1	; 0x09
    3d7e:	16 8a       	std	Z+22, r1	; 0x16
    3d80:	17 8a       	std	Z+23, r1	; 0x17
    3d82:	10 8e       	std	Z+24, r1	; 0x18
    3d84:	11 8e       	std	Z+25, r1	; 0x19
    3d86:	b1 82       	std	Z+1, r11	; 0x01
    3d88:	a0 82       	st	Z, r10
    3d8a:	d5 01       	movw	r26, r10
    3d8c:	16 96       	adiw	r26, 0x06	; 6
    3d8e:	8d 91       	ld	r24, X+
    3d90:	9c 91       	ld	r25, X
    3d92:	17 97       	sbiw	r26, 0x07	; 7
    3d94:	93 83       	std	Z+3, r25	; 0x03
    3d96:	82 83       	std	Z+2, r24	; 0x02
    3d98:	80 e0       	ldi	r24, 0x00	; 0
    3d9a:	07 c0       	rjmp	.+14     	; 0x3daa <f_open+0x228>
    3d9c:	89 e0       	ldi	r24, 0x09	; 9
    3d9e:	05 c0       	rjmp	.+10     	; 0x3daa <f_open+0x228>
    3da0:	88 e0       	ldi	r24, 0x08	; 8
    3da2:	03 c0       	rjmp	.+6      	; 0x3daa <f_open+0x228>
    3da4:	84 e0       	ldi	r24, 0x04	; 4
    3da6:	01 c0       	rjmp	.+2      	; 0x3daa <f_open+0x228>
    3da8:	87 e0       	ldi	r24, 0x07	; 7
    3daa:	a4 96       	adiw	r28, 0x24	; 36
    3dac:	0f b6       	in	r0, 0x3f	; 63
    3dae:	f8 94       	cli
    3db0:	de bf       	out	0x3e, r29	; 62
    3db2:	0f be       	out	0x3f, r0	; 63
    3db4:	cd bf       	out	0x3d, r28	; 61
    3db6:	df 91       	pop	r29
    3db8:	cf 91       	pop	r28
    3dba:	1f 91       	pop	r17
    3dbc:	0f 91       	pop	r16
    3dbe:	ff 90       	pop	r15
    3dc0:	ef 90       	pop	r14
    3dc2:	df 90       	pop	r13
    3dc4:	bf 90       	pop	r11
    3dc6:	af 90       	pop	r10
    3dc8:	9f 90       	pop	r9
    3dca:	8f 90       	pop	r8
    3dcc:	7f 90       	pop	r7
    3dce:	6f 90       	pop	r6
    3dd0:	5f 90       	pop	r5
    3dd2:	4f 90       	pop	r4
    3dd4:	08 95       	ret

00003dd6 <f_write>:
    3dd6:	2f 92       	push	r2
    3dd8:	3f 92       	push	r3
    3dda:	4f 92       	push	r4
    3ddc:	5f 92       	push	r5
    3dde:	6f 92       	push	r6
    3de0:	7f 92       	push	r7
    3de2:	8f 92       	push	r8
    3de4:	9f 92       	push	r9
    3de6:	af 92       	push	r10
    3de8:	bf 92       	push	r11
    3dea:	cf 92       	push	r12
    3dec:	df 92       	push	r13
    3dee:	ef 92       	push	r14
    3df0:	ff 92       	push	r15
    3df2:	0f 93       	push	r16
    3df4:	1f 93       	push	r17
    3df6:	cf 93       	push	r28
    3df8:	df 93       	push	r29
    3dfa:	ec 01       	movw	r28, r24
    3dfc:	5b 01       	movw	r10, r22
    3dfe:	6a 01       	movw	r12, r20
    3e00:	19 01       	movw	r2, r18
    3e02:	f9 01       	movw	r30, r18
    3e04:	11 82       	std	Z+1, r1	; 0x01
    3e06:	10 82       	st	Z, r1
    3e08:	0e 94 44 13 	call	0x2688	; 0x2688 <validate>
    3e0c:	81 11       	cpse	r24, r1
    3e0e:	62 c1       	rjmp	.+708    	; 0x40d4 <f_write+0x2fe>
    3e10:	8d 81       	ldd	r24, Y+5	; 0x05
    3e12:	81 11       	cpse	r24, r1
    3e14:	5f c1       	rjmp	.+702    	; 0x40d4 <f_write+0x2fe>
    3e16:	8c 81       	ldd	r24, Y+4	; 0x04
    3e18:	81 ff       	sbrs	r24, 1
    3e1a:	5b c1       	rjmp	.+694    	; 0x40d2 <f_write+0x2fc>
    3e1c:	8e 81       	ldd	r24, Y+6	; 0x06
    3e1e:	9f 81       	ldd	r25, Y+7	; 0x07
    3e20:	a8 85       	ldd	r26, Y+8	; 0x08
    3e22:	b9 85       	ldd	r27, Y+9	; 0x09
    3e24:	ac 01       	movw	r20, r24
    3e26:	bd 01       	movw	r22, r26
    3e28:	4c 0d       	add	r20, r12
    3e2a:	5d 1d       	adc	r21, r13
    3e2c:	61 1d       	adc	r22, r1
    3e2e:	71 1d       	adc	r23, r1
    3e30:	48 17       	cp	r20, r24
    3e32:	59 07       	cpc	r21, r25
    3e34:	6a 07       	cpc	r22, r26
    3e36:	7b 07       	cpc	r23, r27
    3e38:	08 f0       	brcs	.+2      	; 0x3e3c <f_write+0x66>
    3e3a:	a3 c0       	rjmp	.+326    	; 0x3f82 <f_write+0x1ac>
    3e3c:	c1 2c       	mov	r12, r1
    3e3e:	d1 2c       	mov	r13, r1
    3e40:	a0 c0       	rjmp	.+320    	; 0x3f82 <f_write+0x1ac>
    3e42:	4e 81       	ldd	r20, Y+6	; 0x06
    3e44:	5f 81       	ldd	r21, Y+7	; 0x07
    3e46:	68 85       	ldd	r22, Y+8	; 0x08
    3e48:	79 85       	ldd	r23, Y+9	; 0x09
    3e4a:	db 01       	movw	r26, r22
    3e4c:	ca 01       	movw	r24, r20
    3e4e:	91 70       	andi	r25, 0x01	; 1
    3e50:	aa 27       	eor	r26, r26
    3e52:	bb 27       	eor	r27, r27
    3e54:	89 2b       	or	r24, r25
    3e56:	8a 2b       	or	r24, r26
    3e58:	8b 2b       	or	r24, r27
    3e5a:	09 f0       	breq	.+2      	; 0x3e5e <f_write+0x88>
    3e5c:	0a c1       	rjmp	.+532    	; 0x4072 <f_write+0x29c>
    3e5e:	e8 81       	ld	r30, Y
    3e60:	f9 81       	ldd	r31, Y+1	; 0x01
    3e62:	22 81       	ldd	r18, Z+2	; 0x02
    3e64:	21 50       	subi	r18, 0x01	; 1
    3e66:	2a 01       	movw	r4, r20
    3e68:	3b 01       	movw	r6, r22
    3e6a:	a9 e0       	ldi	r26, 0x09	; 9
    3e6c:	76 94       	lsr	r7
    3e6e:	67 94       	ror	r6
    3e70:	57 94       	ror	r5
    3e72:	47 94       	ror	r4
    3e74:	aa 95       	dec	r26
    3e76:	d1 f7       	brne	.-12     	; 0x3e6c <f_write+0x96>
    3e78:	12 2f       	mov	r17, r18
    3e7a:	14 21       	and	r17, r4
    3e7c:	09 f4       	brne	.+2      	; 0x3e80 <f_write+0xaa>
    3e7e:	86 c0       	rjmp	.+268    	; 0x3f8c <f_write+0x1b6>
    3e80:	88 81       	ld	r24, Y
    3e82:	99 81       	ldd	r25, Y+1	; 0x01
    3e84:	fc 01       	movw	r30, r24
    3e86:	42 a4       	ldd	r4, Z+42	; 0x2a
    3e88:	53 a4       	ldd	r5, Z+43	; 0x2b
    3e8a:	64 a4       	ldd	r6, Z+44	; 0x2c
    3e8c:	75 a4       	ldd	r7, Z+45	; 0x2d
    3e8e:	4e 89       	ldd	r20, Y+22	; 0x16
    3e90:	5f 89       	ldd	r21, Y+23	; 0x17
    3e92:	68 8d       	ldd	r22, Y+24	; 0x18
    3e94:	79 8d       	ldd	r23, Y+25	; 0x19
    3e96:	44 16       	cp	r4, r20
    3e98:	55 06       	cpc	r5, r21
    3e9a:	66 06       	cpc	r6, r22
    3e9c:	77 06       	cpc	r7, r23
    3e9e:	09 f4       	brne	.+2      	; 0x3ea2 <f_write+0xcc>
    3ea0:	c6 c0       	rjmp	.+396    	; 0x402e <f_write+0x258>
    3ea2:	88 80       	ld	r8, Y
    3ea4:	99 80       	ldd	r9, Y+1	; 0x01
    3ea6:	4a 89       	ldd	r20, Y+18	; 0x12
    3ea8:	5b 89       	ldd	r21, Y+19	; 0x13
    3eaa:	6c 89       	ldd	r22, Y+20	; 0x14
    3eac:	7d 89       	ldd	r23, Y+21	; 0x15
    3eae:	c4 01       	movw	r24, r8
    3eb0:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <clust2sect>
    3eb4:	61 15       	cp	r22, r1
    3eb6:	71 05       	cpc	r23, r1
    3eb8:	81 05       	cpc	r24, r1
    3eba:	91 05       	cpc	r25, r1
    3ebc:	09 f4       	brne	.+2      	; 0x3ec0 <f_write+0xea>
    3ebe:	9a c0       	rjmp	.+308    	; 0x3ff4 <f_write+0x21e>
    3ec0:	2b 01       	movw	r4, r22
    3ec2:	3c 01       	movw	r6, r24
    3ec4:	41 0e       	add	r4, r17
    3ec6:	51 1c       	adc	r5, r1
    3ec8:	61 1c       	adc	r6, r1
    3eca:	71 1c       	adc	r7, r1
    3ecc:	76 01       	movw	r14, r12
    3ece:	ef 2c       	mov	r14, r15
    3ed0:	ff 24       	eor	r15, r15
    3ed2:	e6 94       	lsr	r14
    3ed4:	e1 14       	cp	r14, r1
    3ed6:	f1 04       	cpc	r15, r1
    3ed8:	09 f4       	brne	.+2      	; 0x3edc <f_write+0x106>
    3eda:	af c0       	rjmp	.+350    	; 0x403a <f_write+0x264>
    3edc:	f4 01       	movw	r30, r8
    3ede:	82 81       	ldd	r24, Z+2	; 0x02
    3ee0:	21 2f       	mov	r18, r17
    3ee2:	30 e0       	ldi	r19, 0x00	; 0
    3ee4:	a7 01       	movw	r20, r14
    3ee6:	42 0f       	add	r20, r18
    3ee8:	53 1f       	adc	r21, r19
    3eea:	90 e0       	ldi	r25, 0x00	; 0
    3eec:	84 17       	cp	r24, r20
    3eee:	95 07       	cpc	r25, r21
    3ef0:	18 f4       	brcc	.+6      	; 0x3ef8 <f_write+0x122>
    3ef2:	7c 01       	movw	r14, r24
    3ef4:	e2 1a       	sub	r14, r18
    3ef6:	f3 0a       	sbc	r15, r19
    3ef8:	87 01       	movw	r16, r14
    3efa:	a3 01       	movw	r20, r6
    3efc:	92 01       	movw	r18, r4
    3efe:	b5 01       	movw	r22, r10
    3f00:	f4 01       	movw	r30, r8
    3f02:	81 81       	ldd	r24, Z+1	; 0x01
    3f04:	0e 94 bf 11 	call	0x237e	; 0x237e <disk_write>
    3f08:	81 11       	cpse	r24, r1
    3f0a:	7c c0       	rjmp	.+248    	; 0x4004 <f_write+0x22e>
    3f0c:	88 81       	ld	r24, Y
    3f0e:	99 81       	ldd	r25, Y+1	; 0x01
    3f10:	fc 01       	movw	r30, r24
    3f12:	42 a5       	ldd	r20, Z+42	; 0x2a
    3f14:	53 a5       	ldd	r21, Z+43	; 0x2b
    3f16:	64 a5       	ldd	r22, Z+44	; 0x2c
    3f18:	75 a5       	ldd	r23, Z+45	; 0x2d
    3f1a:	44 19       	sub	r20, r4
    3f1c:	55 09       	sbc	r21, r5
    3f1e:	66 09       	sbc	r22, r6
    3f20:	77 09       	sbc	r23, r7
    3f22:	27 01       	movw	r4, r14
    3f24:	61 2c       	mov	r6, r1
    3f26:	71 2c       	mov	r7, r1
    3f28:	44 15       	cp	r20, r4
    3f2a:	55 05       	cpc	r21, r5
    3f2c:	66 05       	cpc	r22, r6
    3f2e:	77 05       	cpc	r23, r7
    3f30:	70 f4       	brcc	.+28     	; 0x3f4e <f_write+0x178>
    3f32:	54 2f       	mov	r21, r20
    3f34:	44 27       	eor	r20, r20
    3f36:	55 0f       	add	r21, r21
    3f38:	b5 01       	movw	r22, r10
    3f3a:	64 0f       	add	r22, r20
    3f3c:	75 1f       	adc	r23, r21
    3f3e:	40 e0       	ldi	r20, 0x00	; 0
    3f40:	52 e0       	ldi	r21, 0x02	; 2
    3f42:	8e 96       	adiw	r24, 0x2e	; 46
    3f44:	0e 94 bb 12 	call	0x2576	; 0x2576 <mem_cpy>
    3f48:	e8 81       	ld	r30, Y
    3f4a:	f9 81       	ldd	r31, Y+1	; 0x01
    3f4c:	14 82       	std	Z+4, r1	; 0x04
    3f4e:	fe 2c       	mov	r15, r14
    3f50:	ee 24       	eor	r14, r14
    3f52:	ff 0c       	add	r15, r15
    3f54:	ae 0c       	add	r10, r14
    3f56:	bf 1c       	adc	r11, r15
    3f58:	8e 81       	ldd	r24, Y+6	; 0x06
    3f5a:	9f 81       	ldd	r25, Y+7	; 0x07
    3f5c:	a8 85       	ldd	r26, Y+8	; 0x08
    3f5e:	b9 85       	ldd	r27, Y+9	; 0x09
    3f60:	8e 0d       	add	r24, r14
    3f62:	9f 1d       	adc	r25, r15
    3f64:	a1 1d       	adc	r26, r1
    3f66:	b1 1d       	adc	r27, r1
    3f68:	8e 83       	std	Y+6, r24	; 0x06
    3f6a:	9f 83       	std	Y+7, r25	; 0x07
    3f6c:	a8 87       	std	Y+8, r26	; 0x08
    3f6e:	b9 87       	std	Y+9, r27	; 0x09
    3f70:	f1 01       	movw	r30, r2
    3f72:	80 81       	ld	r24, Z
    3f74:	91 81       	ldd	r25, Z+1	; 0x01
    3f76:	8e 0d       	add	r24, r14
    3f78:	9f 1d       	adc	r25, r15
    3f7a:	91 83       	std	Z+1, r25	; 0x01
    3f7c:	80 83       	st	Z, r24
    3f7e:	ce 18       	sub	r12, r14
    3f80:	df 08       	sbc	r13, r15
    3f82:	c1 14       	cp	r12, r1
    3f84:	d1 04       	cpc	r13, r1
    3f86:	09 f0       	breq	.+2      	; 0x3f8a <f_write+0x1b4>
    3f88:	5c cf       	rjmp	.-328    	; 0x3e42 <f_write+0x6c>
    3f8a:	1c c0       	rjmp	.+56     	; 0x3fc4 <f_write+0x1ee>
    3f8c:	45 2b       	or	r20, r21
    3f8e:	46 2b       	or	r20, r22
    3f90:	47 2b       	or	r20, r23
    3f92:	69 f4       	brne	.+26     	; 0x3fae <f_write+0x1d8>
    3f94:	6e 85       	ldd	r22, Y+14	; 0x0e
    3f96:	7f 85       	ldd	r23, Y+15	; 0x0f
    3f98:	88 89       	ldd	r24, Y+16	; 0x10
    3f9a:	99 89       	ldd	r25, Y+17	; 0x11
    3f9c:	61 15       	cp	r22, r1
    3f9e:	71 05       	cpc	r23, r1
    3fa0:	81 05       	cpc	r24, r1
    3fa2:	91 05       	cpc	r25, r1
    3fa4:	11 f5       	brne	.+68     	; 0x3fea <f_write+0x214>
    3fa6:	40 e0       	ldi	r20, 0x00	; 0
    3fa8:	50 e0       	ldi	r21, 0x00	; 0
    3faa:	ba 01       	movw	r22, r20
    3fac:	04 c0       	rjmp	.+8      	; 0x3fb6 <f_write+0x1e0>
    3fae:	4a 89       	ldd	r20, Y+18	; 0x12
    3fb0:	5b 89       	ldd	r21, Y+19	; 0x13
    3fb2:	6c 89       	ldd	r22, Y+20	; 0x14
    3fb4:	7d 89       	ldd	r23, Y+21	; 0x15
    3fb6:	cf 01       	movw	r24, r30
    3fb8:	dd d9       	rcall	.-3142   	; 0x3374 <create_chain>
    3fba:	61 15       	cp	r22, r1
    3fbc:	71 05       	cpc	r23, r1
    3fbe:	81 05       	cpc	r24, r1
    3fc0:	91 05       	cpc	r25, r1
    3fc2:	99 f4       	brne	.+38     	; 0x3fea <f_write+0x214>
    3fc4:	8e 81       	ldd	r24, Y+6	; 0x06
    3fc6:	9f 81       	ldd	r25, Y+7	; 0x07
    3fc8:	a8 85       	ldd	r26, Y+8	; 0x08
    3fca:	b9 85       	ldd	r27, Y+9	; 0x09
    3fcc:	4a 85       	ldd	r20, Y+10	; 0x0a
    3fce:	5b 85       	ldd	r21, Y+11	; 0x0b
    3fd0:	6c 85       	ldd	r22, Y+12	; 0x0c
    3fd2:	7d 85       	ldd	r23, Y+13	; 0x0d
    3fd4:	48 17       	cp	r20, r24
    3fd6:	59 07       	cpc	r21, r25
    3fd8:	6a 07       	cpc	r22, r26
    3fda:	7b 07       	cpc	r23, r27
    3fdc:	08 f0       	brcs	.+2      	; 0x3fe0 <f_write+0x20a>
    3fde:	74 c0       	rjmp	.+232    	; 0x40c8 <f_write+0x2f2>
    3fe0:	8a 87       	std	Y+10, r24	; 0x0a
    3fe2:	9b 87       	std	Y+11, r25	; 0x0b
    3fe4:	ac 87       	std	Y+12, r26	; 0x0c
    3fe6:	bd 87       	std	Y+13, r27	; 0x0d
    3fe8:	6f c0       	rjmp	.+222    	; 0x40c8 <f_write+0x2f2>
    3fea:	61 30       	cpi	r22, 0x01	; 1
    3fec:	71 05       	cpc	r23, r1
    3fee:	81 05       	cpc	r24, r1
    3ff0:	91 05       	cpc	r25, r1
    3ff2:	11 f4       	brne	.+4      	; 0x3ff8 <f_write+0x222>
    3ff4:	82 e0       	ldi	r24, 0x02	; 2
    3ff6:	07 c0       	rjmp	.+14     	; 0x4006 <f_write+0x230>
    3ff8:	6f 3f       	cpi	r22, 0xFF	; 255
    3ffa:	ff ef       	ldi	r31, 0xFF	; 255
    3ffc:	7f 07       	cpc	r23, r31
    3ffe:	8f 07       	cpc	r24, r31
    4000:	9f 07       	cpc	r25, r31
    4002:	19 f4       	brne	.+6      	; 0x400a <f_write+0x234>
    4004:	81 e0       	ldi	r24, 0x01	; 1
    4006:	8d 83       	std	Y+5, r24	; 0x05
    4008:	65 c0       	rjmp	.+202    	; 0x40d4 <f_write+0x2fe>
    400a:	6a 8b       	std	Y+18, r22	; 0x12
    400c:	7b 8b       	std	Y+19, r23	; 0x13
    400e:	8c 8b       	std	Y+20, r24	; 0x14
    4010:	9d 8b       	std	Y+21, r25	; 0x15
    4012:	4e 84       	ldd	r4, Y+14	; 0x0e
    4014:	5f 84       	ldd	r5, Y+15	; 0x0f
    4016:	68 88       	ldd	r6, Y+16	; 0x10
    4018:	79 88       	ldd	r7, Y+17	; 0x11
    401a:	45 28       	or	r4, r5
    401c:	46 28       	or	r4, r6
    401e:	47 28       	or	r4, r7
    4020:	09 f0       	breq	.+2      	; 0x4024 <f_write+0x24e>
    4022:	2e cf       	rjmp	.-420    	; 0x3e80 <f_write+0xaa>
    4024:	6e 87       	std	Y+14, r22	; 0x0e
    4026:	7f 87       	std	Y+15, r23	; 0x0f
    4028:	88 8b       	std	Y+16, r24	; 0x10
    402a:	99 8b       	std	Y+17, r25	; 0x11
    402c:	29 cf       	rjmp	.-430    	; 0x3e80 <f_write+0xaa>
    402e:	0e 94 62 13 	call	0x26c4	; 0x26c4 <sync_window>
    4032:	88 23       	and	r24, r24
    4034:	09 f4       	brne	.+2      	; 0x4038 <f_write+0x262>
    4036:	35 cf       	rjmp	.-406    	; 0x3ea2 <f_write+0xcc>
    4038:	e5 cf       	rjmp	.-54     	; 0x4004 <f_write+0x22e>
    403a:	4e 81       	ldd	r20, Y+6	; 0x06
    403c:	5f 81       	ldd	r21, Y+7	; 0x07
    403e:	68 85       	ldd	r22, Y+8	; 0x08
    4040:	79 85       	ldd	r23, Y+9	; 0x09
    4042:	8a 85       	ldd	r24, Y+10	; 0x0a
    4044:	9b 85       	ldd	r25, Y+11	; 0x0b
    4046:	ac 85       	ldd	r26, Y+12	; 0x0c
    4048:	bd 85       	ldd	r27, Y+13	; 0x0d
    404a:	48 17       	cp	r20, r24
    404c:	59 07       	cpc	r21, r25
    404e:	6a 07       	cpc	r22, r26
    4050:	7b 07       	cpc	r23, r27
    4052:	58 f0       	brcs	.+22     	; 0x406a <f_write+0x294>
    4054:	c4 01       	movw	r24, r8
    4056:	0e 94 62 13 	call	0x26c4	; 0x26c4 <sync_window>
    405a:	81 11       	cpse	r24, r1
    405c:	d3 cf       	rjmp	.-90     	; 0x4004 <f_write+0x22e>
    405e:	e8 81       	ld	r30, Y
    4060:	f9 81       	ldd	r31, Y+1	; 0x01
    4062:	42 a6       	std	Z+42, r4	; 0x2a
    4064:	53 a6       	std	Z+43, r5	; 0x2b
    4066:	64 a6       	std	Z+44, r6	; 0x2c
    4068:	75 a6       	std	Z+45, r7	; 0x2d
    406a:	4e 8a       	std	Y+22, r4	; 0x16
    406c:	5f 8a       	std	Y+23, r5	; 0x17
    406e:	68 8e       	std	Y+24, r6	; 0x18
    4070:	79 8e       	std	Y+25, r7	; 0x19
    4072:	8e 81       	ldd	r24, Y+6	; 0x06
    4074:	9f 81       	ldd	r25, Y+7	; 0x07
    4076:	91 70       	andi	r25, 0x01	; 1
    4078:	20 e0       	ldi	r18, 0x00	; 0
    407a:	32 e0       	ldi	r19, 0x02	; 2
    407c:	28 1b       	sub	r18, r24
    407e:	39 0b       	sbc	r19, r25
    4080:	76 01       	movw	r14, r12
    4082:	2c 15       	cp	r18, r12
    4084:	3d 05       	cpc	r19, r13
    4086:	08 f4       	brcc	.+2      	; 0x408a <f_write+0x2b4>
    4088:	79 01       	movw	r14, r18
    408a:	4e 89       	ldd	r20, Y+22	; 0x16
    408c:	5f 89       	ldd	r21, Y+23	; 0x17
    408e:	68 8d       	ldd	r22, Y+24	; 0x18
    4090:	79 8d       	ldd	r23, Y+25	; 0x19
    4092:	88 81       	ld	r24, Y
    4094:	99 81       	ldd	r25, Y+1	; 0x01
    4096:	0e 94 2a 14 	call	0x2854	; 0x2854 <move_window>
    409a:	81 11       	cpse	r24, r1
    409c:	b3 cf       	rjmp	.-154    	; 0x4004 <f_write+0x22e>
    409e:	8e 81       	ldd	r24, Y+6	; 0x06
    40a0:	9f 81       	ldd	r25, Y+7	; 0x07
    40a2:	a8 85       	ldd	r26, Y+8	; 0x08
    40a4:	b9 85       	ldd	r27, Y+9	; 0x09
    40a6:	91 70       	andi	r25, 0x01	; 1
    40a8:	aa 27       	eor	r26, r26
    40aa:	bb 27       	eor	r27, r27
    40ac:	8e 96       	adiw	r24, 0x2e	; 46
    40ae:	28 81       	ld	r18, Y
    40b0:	39 81       	ldd	r19, Y+1	; 0x01
    40b2:	a7 01       	movw	r20, r14
    40b4:	b5 01       	movw	r22, r10
    40b6:	82 0f       	add	r24, r18
    40b8:	93 1f       	adc	r25, r19
    40ba:	0e 94 bb 12 	call	0x2576	; 0x2576 <mem_cpy>
    40be:	e8 81       	ld	r30, Y
    40c0:	f9 81       	ldd	r31, Y+1	; 0x01
    40c2:	31 e0       	ldi	r19, 0x01	; 1
    40c4:	34 83       	std	Z+4, r19	; 0x04
    40c6:	46 cf       	rjmp	.-372    	; 0x3f54 <f_write+0x17e>
    40c8:	8c 81       	ldd	r24, Y+4	; 0x04
    40ca:	80 62       	ori	r24, 0x20	; 32
    40cc:	8c 83       	std	Y+4, r24	; 0x04
    40ce:	80 e0       	ldi	r24, 0x00	; 0
    40d0:	01 c0       	rjmp	.+2      	; 0x40d4 <f_write+0x2fe>
    40d2:	87 e0       	ldi	r24, 0x07	; 7
    40d4:	df 91       	pop	r29
    40d6:	cf 91       	pop	r28
    40d8:	1f 91       	pop	r17
    40da:	0f 91       	pop	r16
    40dc:	ff 90       	pop	r15
    40de:	ef 90       	pop	r14
    40e0:	df 90       	pop	r13
    40e2:	cf 90       	pop	r12
    40e4:	bf 90       	pop	r11
    40e6:	af 90       	pop	r10
    40e8:	9f 90       	pop	r9
    40ea:	8f 90       	pop	r8
    40ec:	7f 90       	pop	r7
    40ee:	6f 90       	pop	r6
    40f0:	5f 90       	pop	r5
    40f2:	4f 90       	pop	r4
    40f4:	3f 90       	pop	r3
    40f6:	2f 90       	pop	r2
    40f8:	08 95       	ret

000040fa <f_sync>:
    40fa:	cf 93       	push	r28
    40fc:	df 93       	push	r29
    40fe:	ec 01       	movw	r28, r24
    4100:	0e 94 44 13 	call	0x2688	; 0x2688 <validate>
    4104:	81 11       	cpse	r24, r1
    4106:	39 c0       	rjmp	.+114    	; 0x417a <f_sync+0x80>
    4108:	9c 81       	ldd	r25, Y+4	; 0x04
    410a:	95 ff       	sbrs	r25, 5
    410c:	36 c0       	rjmp	.+108    	; 0x417a <f_sync+0x80>
    410e:	4a 8d       	ldd	r20, Y+26	; 0x1a
    4110:	5b 8d       	ldd	r21, Y+27	; 0x1b
    4112:	6c 8d       	ldd	r22, Y+28	; 0x1c
    4114:	7d 8d       	ldd	r23, Y+29	; 0x1d
    4116:	88 81       	ld	r24, Y
    4118:	99 81       	ldd	r25, Y+1	; 0x01
    411a:	0e 94 2a 14 	call	0x2854	; 0x2854 <move_window>
    411e:	81 11       	cpse	r24, r1
    4120:	2c c0       	rjmp	.+88     	; 0x417a <f_sync+0x80>
    4122:	ee 8d       	ldd	r30, Y+30	; 0x1e
    4124:	ff 8d       	ldd	r31, Y+31	; 0x1f
    4126:	83 85       	ldd	r24, Z+11	; 0x0b
    4128:	80 62       	ori	r24, 0x20	; 32
    412a:	83 87       	std	Z+11, r24	; 0x0b
    412c:	8a 85       	ldd	r24, Y+10	; 0x0a
    412e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4130:	ac 85       	ldd	r26, Y+12	; 0x0c
    4132:	bd 85       	ldd	r27, Y+13	; 0x0d
    4134:	84 8f       	std	Z+28, r24	; 0x1c
    4136:	95 8f       	std	Z+29, r25	; 0x1d
    4138:	a6 8f       	std	Z+30, r26	; 0x1e
    413a:	b7 8f       	std	Z+31, r27	; 0x1f
    413c:	8e 85       	ldd	r24, Y+14	; 0x0e
    413e:	9f 85       	ldd	r25, Y+15	; 0x0f
    4140:	a8 89       	ldd	r26, Y+16	; 0x10
    4142:	b9 89       	ldd	r27, Y+17	; 0x11
    4144:	93 8f       	std	Z+27, r25	; 0x1b
    4146:	82 8f       	std	Z+26, r24	; 0x1a
    4148:	b5 8b       	std	Z+21, r27	; 0x15
    414a:	a4 8b       	std	Z+20, r26	; 0x14
    414c:	80 e0       	ldi	r24, 0x00	; 0
    414e:	90 e0       	ldi	r25, 0x00	; 0
    4150:	a9 e6       	ldi	r26, 0x69	; 105
    4152:	b5 e4       	ldi	r27, 0x45	; 69
    4154:	86 8b       	std	Z+22, r24	; 0x16
    4156:	97 8b       	std	Z+23, r25	; 0x17
    4158:	a0 8f       	std	Z+24, r26	; 0x18
    415a:	b1 8f       	std	Z+25, r27	; 0x19
    415c:	13 8a       	std	Z+19, r1	; 0x13
    415e:	12 8a       	std	Z+18, r1	; 0x12
    4160:	8c 81       	ldd	r24, Y+4	; 0x04
    4162:	8f 7d       	andi	r24, 0xDF	; 223
    4164:	8c 83       	std	Y+4, r24	; 0x04
    4166:	e8 81       	ld	r30, Y
    4168:	f9 81       	ldd	r31, Y+1	; 0x01
    416a:	81 e0       	ldi	r24, 0x01	; 1
    416c:	84 83       	std	Z+4, r24	; 0x04
    416e:	88 81       	ld	r24, Y
    4170:	99 81       	ldd	r25, Y+1	; 0x01
    4172:	df 91       	pop	r29
    4174:	cf 91       	pop	r28
    4176:	0c 94 c1 13 	jmp	0x2782	; 0x2782 <sync_fs>
    417a:	df 91       	pop	r29
    417c:	cf 91       	pop	r28
    417e:	08 95       	ret

00004180 <f_close>:
    4180:	cf 93       	push	r28
    4182:	df 93       	push	r29
    4184:	ec 01       	movw	r28, r24
    4186:	b9 df       	rcall	.-142    	; 0x40fa <f_sync>
    4188:	81 11       	cpse	r24, r1
    418a:	07 c0       	rjmp	.+14     	; 0x419a <f_close+0x1a>
    418c:	ce 01       	movw	r24, r28
    418e:	0e 94 44 13 	call	0x2688	; 0x2688 <validate>
    4192:	81 11       	cpse	r24, r1
    4194:	02 c0       	rjmp	.+4      	; 0x419a <f_close+0x1a>
    4196:	19 82       	std	Y+1, r1	; 0x01
    4198:	18 82       	st	Y, r1
    419a:	df 91       	pop	r29
    419c:	cf 91       	pop	r28
    419e:	08 95       	ret

000041a0 <f_lseek>:
    41a0:	2f 92       	push	r2
    41a2:	3f 92       	push	r3
    41a4:	4f 92       	push	r4
    41a6:	5f 92       	push	r5
    41a8:	6f 92       	push	r6
    41aa:	7f 92       	push	r7
    41ac:	8f 92       	push	r8
    41ae:	9f 92       	push	r9
    41b0:	af 92       	push	r10
    41b2:	bf 92       	push	r11
    41b4:	cf 92       	push	r12
    41b6:	df 92       	push	r13
    41b8:	ef 92       	push	r14
    41ba:	ff 92       	push	r15
    41bc:	0f 93       	push	r16
    41be:	1f 93       	push	r17
    41c0:	cf 93       	push	r28
    41c2:	df 93       	push	r29
    41c4:	00 d0       	rcall	.+0      	; 0x41c6 <f_lseek+0x26>
    41c6:	00 d0       	rcall	.+0      	; 0x41c8 <f_lseek+0x28>
    41c8:	cd b7       	in	r28, 0x3d	; 61
    41ca:	de b7       	in	r29, 0x3e	; 62
    41cc:	1c 01       	movw	r2, r24
    41ce:	6a 01       	movw	r12, r20
    41d0:	7b 01       	movw	r14, r22
    41d2:	0e 94 44 13 	call	0x2688	; 0x2688 <validate>
    41d6:	81 11       	cpse	r24, r1
    41d8:	5b c1       	rjmp	.+694    	; 0x4490 <f_lseek+0x2f0>
    41da:	d1 01       	movw	r26, r2
    41dc:	15 96       	adiw	r26, 0x05	; 5
    41de:	8c 91       	ld	r24, X
    41e0:	15 97       	sbiw	r26, 0x05	; 5
    41e2:	81 11       	cpse	r24, r1
    41e4:	55 c1       	rjmp	.+682    	; 0x4490 <f_lseek+0x2f0>
    41e6:	1a 96       	adiw	r26, 0x0a	; 10
    41e8:	8d 91       	ld	r24, X+
    41ea:	9d 91       	ld	r25, X+
    41ec:	0d 90       	ld	r0, X+
    41ee:	bc 91       	ld	r27, X
    41f0:	a0 2d       	mov	r26, r0
    41f2:	8c 15       	cp	r24, r12
    41f4:	9d 05       	cpc	r25, r13
    41f6:	ae 05       	cpc	r26, r14
    41f8:	bf 05       	cpc	r27, r15
    41fa:	30 f4       	brcc	.+12     	; 0x4208 <f_lseek+0x68>
    41fc:	f1 01       	movw	r30, r2
    41fe:	24 81       	ldd	r18, Z+4	; 0x04
    4200:	21 fd       	sbrc	r18, 1
    4202:	02 c0       	rjmp	.+4      	; 0x4208 <f_lseek+0x68>
    4204:	6c 01       	movw	r12, r24
    4206:	7d 01       	movw	r14, r26
    4208:	d1 01       	movw	r26, r2
    420a:	16 96       	adiw	r26, 0x06	; 6
    420c:	4d 90       	ld	r4, X+
    420e:	5d 90       	ld	r5, X+
    4210:	6d 90       	ld	r6, X+
    4212:	7c 90       	ld	r7, X
    4214:	19 97       	sbiw	r26, 0x09	; 9
    4216:	f1 01       	movw	r30, r2
    4218:	16 82       	std	Z+6, r1	; 0x06
    421a:	17 82       	std	Z+7, r1	; 0x07
    421c:	10 86       	std	Z+8, r1	; 0x08
    421e:	11 86       	std	Z+9, r1	; 0x09
    4220:	c1 14       	cp	r12, r1
    4222:	d1 04       	cpc	r13, r1
    4224:	e1 04       	cpc	r14, r1
    4226:	f1 04       	cpc	r15, r1
    4228:	21 f4       	brne	.+8      	; 0x4232 <f_lseek+0x92>
    422a:	c1 2c       	mov	r12, r1
    422c:	d1 2c       	mov	r13, r1
    422e:	76 01       	movw	r14, r12
    4230:	02 c1       	rjmp	.+516    	; 0x4436 <f_lseek+0x296>
    4232:	00 81       	ld	r16, Z
    4234:	11 81       	ldd	r17, Z+1	; 0x01
    4236:	f8 01       	movw	r30, r16
    4238:	82 80       	ldd	r8, Z+2	; 0x02
    423a:	91 2c       	mov	r9, r1
    423c:	a1 2c       	mov	r10, r1
    423e:	b1 2c       	mov	r11, r1
    4240:	39 e0       	ldi	r19, 0x09	; 9
    4242:	88 0c       	add	r8, r8
    4244:	99 1c       	adc	r9, r9
    4246:	aa 1c       	adc	r10, r10
    4248:	bb 1c       	adc	r11, r11
    424a:	3a 95       	dec	r19
    424c:	d1 f7       	brne	.-12     	; 0x4242 <f_lseek+0xa2>
    424e:	41 14       	cp	r4, r1
    4250:	51 04       	cpc	r5, r1
    4252:	61 04       	cpc	r6, r1
    4254:	71 04       	cpc	r7, r1
    4256:	09 f4       	brne	.+2      	; 0x425a <f_lseek+0xba>
    4258:	3f c0       	rjmp	.+126    	; 0x42d8 <f_lseek+0x138>
    425a:	f1 e0       	ldi	r31, 0x01	; 1
    425c:	4f 1a       	sub	r4, r31
    425e:	51 08       	sbc	r5, r1
    4260:	61 08       	sbc	r6, r1
    4262:	71 08       	sbc	r7, r1
    4264:	c7 01       	movw	r24, r14
    4266:	b6 01       	movw	r22, r12
    4268:	61 50       	subi	r22, 0x01	; 1
    426a:	71 09       	sbc	r23, r1
    426c:	81 09       	sbc	r24, r1
    426e:	91 09       	sbc	r25, r1
    4270:	a5 01       	movw	r20, r10
    4272:	94 01       	movw	r18, r8
    4274:	0e 94 18 37 	call	0x6e30	; 0x6e30 <__udivmodsi4>
    4278:	29 83       	std	Y+1, r18	; 0x01
    427a:	3a 83       	std	Y+2, r19	; 0x02
    427c:	4b 83       	std	Y+3, r20	; 0x03
    427e:	5c 83       	std	Y+4, r21	; 0x04
    4280:	c3 01       	movw	r24, r6
    4282:	b2 01       	movw	r22, r4
    4284:	a5 01       	movw	r20, r10
    4286:	94 01       	movw	r18, r8
    4288:	0e 94 18 37 	call	0x6e30	; 0x6e30 <__udivmodsi4>
    428c:	89 81       	ldd	r24, Y+1	; 0x01
    428e:	9a 81       	ldd	r25, Y+2	; 0x02
    4290:	ab 81       	ldd	r26, Y+3	; 0x03
    4292:	bc 81       	ldd	r27, Y+4	; 0x04
    4294:	82 17       	cp	r24, r18
    4296:	93 07       	cpc	r25, r19
    4298:	a4 07       	cpc	r26, r20
    429a:	b5 07       	cpc	r27, r21
    429c:	e8 f0       	brcs	.+58     	; 0x42d8 <f_lseek+0x138>
    429e:	88 27       	eor	r24, r24
    42a0:	99 27       	eor	r25, r25
    42a2:	dc 01       	movw	r26, r24
    42a4:	88 19       	sub	r24, r8
    42a6:	99 09       	sbc	r25, r9
    42a8:	aa 09       	sbc	r26, r10
    42aa:	bb 09       	sbc	r27, r11
    42ac:	48 22       	and	r4, r24
    42ae:	59 22       	and	r5, r25
    42b0:	6a 22       	and	r6, r26
    42b2:	7b 22       	and	r7, r27
    42b4:	d1 01       	movw	r26, r2
    42b6:	16 96       	adiw	r26, 0x06	; 6
    42b8:	4d 92       	st	X+, r4
    42ba:	5d 92       	st	X+, r5
    42bc:	6d 92       	st	X+, r6
    42be:	7c 92       	st	X, r7
    42c0:	19 97       	sbiw	r26, 0x09	; 9
    42c2:	c4 18       	sub	r12, r4
    42c4:	d5 08       	sbc	r13, r5
    42c6:	e6 08       	sbc	r14, r6
    42c8:	f7 08       	sbc	r15, r7
    42ca:	52 96       	adiw	r26, 0x12	; 18
    42cc:	4d 91       	ld	r20, X+
    42ce:	5d 91       	ld	r21, X+
    42d0:	6d 91       	ld	r22, X+
    42d2:	7c 91       	ld	r23, X
    42d4:	55 97       	sbiw	r26, 0x15	; 21
    42d6:	31 c0       	rjmp	.+98     	; 0x433a <f_lseek+0x19a>
    42d8:	f1 01       	movw	r30, r2
    42da:	46 85       	ldd	r20, Z+14	; 0x0e
    42dc:	57 85       	ldd	r21, Z+15	; 0x0f
    42de:	60 89       	ldd	r22, Z+16	; 0x10
    42e0:	71 89       	ldd	r23, Z+17	; 0x11
    42e2:	41 15       	cp	r20, r1
    42e4:	51 05       	cpc	r21, r1
    42e6:	61 05       	cpc	r22, r1
    42e8:	71 05       	cpc	r23, r1
    42ea:	11 f5       	brne	.+68     	; 0x4330 <f_lseek+0x190>
    42ec:	40 e0       	ldi	r20, 0x00	; 0
    42ee:	50 e0       	ldi	r21, 0x00	; 0
    42f0:	ba 01       	movw	r22, r20
    42f2:	c8 01       	movw	r24, r16
    42f4:	3f d8       	rcall	.-3970   	; 0x3374 <create_chain>
    42f6:	ab 01       	movw	r20, r22
    42f8:	bc 01       	movw	r22, r24
    42fa:	41 30       	cpi	r20, 0x01	; 1
    42fc:	51 05       	cpc	r21, r1
    42fe:	61 05       	cpc	r22, r1
    4300:	71 05       	cpc	r23, r1
    4302:	29 f4       	brne	.+10     	; 0x430e <f_lseek+0x16e>
    4304:	82 e0       	ldi	r24, 0x02	; 2
    4306:	d1 01       	movw	r26, r2
    4308:	15 96       	adiw	r26, 0x05	; 5
    430a:	8c 93       	st	X, r24
    430c:	c1 c0       	rjmp	.+386    	; 0x4490 <f_lseek+0x2f0>
    430e:	4f 3f       	cpi	r20, 0xFF	; 255
    4310:	bf ef       	ldi	r27, 0xFF	; 255
    4312:	5b 07       	cpc	r21, r27
    4314:	6b 07       	cpc	r22, r27
    4316:	7b 07       	cpc	r23, r27
    4318:	21 f4       	brne	.+8      	; 0x4322 <f_lseek+0x182>
    431a:	81 e0       	ldi	r24, 0x01	; 1
    431c:	f1 01       	movw	r30, r2
    431e:	85 83       	std	Z+5, r24	; 0x05
    4320:	b7 c0       	rjmp	.+366    	; 0x4490 <f_lseek+0x2f0>
    4322:	d1 01       	movw	r26, r2
    4324:	1e 96       	adiw	r26, 0x0e	; 14
    4326:	4d 93       	st	X+, r20
    4328:	5d 93       	st	X+, r21
    432a:	6d 93       	st	X+, r22
    432c:	7c 93       	st	X, r23
    432e:	51 97       	sbiw	r26, 0x11	; 17
    4330:	f1 01       	movw	r30, r2
    4332:	42 8b       	std	Z+18, r20	; 0x12
    4334:	53 8b       	std	Z+19, r21	; 0x13
    4336:	64 8b       	std	Z+20, r22	; 0x14
    4338:	75 8b       	std	Z+21, r23	; 0x15
    433a:	41 15       	cp	r20, r1
    433c:	51 05       	cpc	r21, r1
    433e:	61 05       	cpc	r22, r1
    4340:	71 05       	cpc	r23, r1
    4342:	09 f4       	brne	.+2      	; 0x4346 <f_lseek+0x1a6>
    4344:	72 cf       	rjmp	.-284    	; 0x422a <f_lseek+0x8a>
    4346:	8c 14       	cp	r8, r12
    4348:	9d 04       	cpc	r9, r13
    434a:	ae 04       	cpc	r10, r14
    434c:	bf 04       	cpc	r11, r15
    434e:	08 f0       	brcs	.+2      	; 0x4352 <f_lseek+0x1b2>
    4350:	46 c0       	rjmp	.+140    	; 0x43de <f_lseek+0x23e>
    4352:	d1 01       	movw	r26, r2
    4354:	14 96       	adiw	r26, 0x04	; 4
    4356:	2c 91       	ld	r18, X
    4358:	14 97       	sbiw	r26, 0x04	; 4
    435a:	8d 91       	ld	r24, X+
    435c:	9c 91       	ld	r25, X
    435e:	21 ff       	sbrs	r18, 1
    4360:	09 c0       	rjmp	.+18     	; 0x4374 <f_lseek+0x1d4>
    4362:	08 d8       	rcall	.-4080   	; 0x3374 <create_chain>
    4364:	ab 01       	movw	r20, r22
    4366:	bc 01       	movw	r22, r24
    4368:	41 15       	cp	r20, r1
    436a:	51 05       	cpc	r21, r1
    436c:	61 05       	cpc	r22, r1
    436e:	71 05       	cpc	r23, r1
    4370:	29 f4       	brne	.+10     	; 0x437c <f_lseek+0x1dc>
    4372:	33 c0       	rjmp	.+102    	; 0x43da <f_lseek+0x23a>
    4374:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <get_fat>
    4378:	ab 01       	movw	r20, r22
    437a:	bc 01       	movw	r22, r24
    437c:	4f 3f       	cpi	r20, 0xFF	; 255
    437e:	bf ef       	ldi	r27, 0xFF	; 255
    4380:	5b 07       	cpc	r21, r27
    4382:	6b 07       	cpc	r22, r27
    4384:	7b 07       	cpc	r23, r27
    4386:	49 f2       	breq	.-110    	; 0x431a <f_lseek+0x17a>
    4388:	42 30       	cpi	r20, 0x02	; 2
    438a:	51 05       	cpc	r21, r1
    438c:	61 05       	cpc	r22, r1
    438e:	71 05       	cpc	r23, r1
    4390:	08 f4       	brcc	.+2      	; 0x4394 <f_lseek+0x1f4>
    4392:	b8 cf       	rjmp	.-144    	; 0x4304 <f_lseek+0x164>
    4394:	d1 01       	movw	r26, r2
    4396:	ed 91       	ld	r30, X+
    4398:	fc 91       	ld	r31, X
    439a:	82 89       	ldd	r24, Z+18	; 0x12
    439c:	93 89       	ldd	r25, Z+19	; 0x13
    439e:	a4 89       	ldd	r26, Z+20	; 0x14
    43a0:	b5 89       	ldd	r27, Z+21	; 0x15
    43a2:	48 17       	cp	r20, r24
    43a4:	59 07       	cpc	r21, r25
    43a6:	6a 07       	cpc	r22, r26
    43a8:	7b 07       	cpc	r23, r27
    43aa:	08 f0       	brcs	.+2      	; 0x43ae <f_lseek+0x20e>
    43ac:	ab cf       	rjmp	.-170    	; 0x4304 <f_lseek+0x164>
    43ae:	f1 01       	movw	r30, r2
    43b0:	42 8b       	std	Z+18, r20	; 0x12
    43b2:	53 8b       	std	Z+19, r21	; 0x13
    43b4:	64 8b       	std	Z+20, r22	; 0x14
    43b6:	75 8b       	std	Z+21, r23	; 0x15
    43b8:	86 81       	ldd	r24, Z+6	; 0x06
    43ba:	97 81       	ldd	r25, Z+7	; 0x07
    43bc:	a0 85       	ldd	r26, Z+8	; 0x08
    43be:	b1 85       	ldd	r27, Z+9	; 0x09
    43c0:	88 0d       	add	r24, r8
    43c2:	99 1d       	adc	r25, r9
    43c4:	aa 1d       	adc	r26, r10
    43c6:	bb 1d       	adc	r27, r11
    43c8:	86 83       	std	Z+6, r24	; 0x06
    43ca:	97 83       	std	Z+7, r25	; 0x07
    43cc:	a0 87       	std	Z+8, r26	; 0x08
    43ce:	b1 87       	std	Z+9, r27	; 0x09
    43d0:	c8 18       	sub	r12, r8
    43d2:	d9 08       	sbc	r13, r9
    43d4:	ea 08       	sbc	r14, r10
    43d6:	fb 08       	sbc	r15, r11
    43d8:	b6 cf       	rjmp	.-148    	; 0x4346 <f_lseek+0x1a6>
    43da:	75 01       	movw	r14, r10
    43dc:	64 01       	movw	r12, r8
    43de:	f1 01       	movw	r30, r2
    43e0:	86 81       	ldd	r24, Z+6	; 0x06
    43e2:	97 81       	ldd	r25, Z+7	; 0x07
    43e4:	a0 85       	ldd	r26, Z+8	; 0x08
    43e6:	b1 85       	ldd	r27, Z+9	; 0x09
    43e8:	8c 0d       	add	r24, r12
    43ea:	9d 1d       	adc	r25, r13
    43ec:	ae 1d       	adc	r26, r14
    43ee:	bf 1d       	adc	r27, r15
    43f0:	86 83       	std	Z+6, r24	; 0x06
    43f2:	97 83       	std	Z+7, r25	; 0x07
    43f4:	a0 87       	std	Z+8, r26	; 0x08
    43f6:	b1 87       	std	Z+9, r27	; 0x09
    43f8:	d7 01       	movw	r26, r14
    43fa:	c6 01       	movw	r24, r12
    43fc:	91 70       	andi	r25, 0x01	; 1
    43fe:	aa 27       	eor	r26, r26
    4400:	bb 27       	eor	r27, r27
    4402:	89 2b       	or	r24, r25
    4404:	8a 2b       	or	r24, r26
    4406:	8b 2b       	or	r24, r27
    4408:	09 f4       	brne	.+2      	; 0x440c <f_lseek+0x26c>
    440a:	0f cf       	rjmp	.-482    	; 0x422a <f_lseek+0x8a>
    440c:	80 81       	ld	r24, Z
    440e:	91 81       	ldd	r25, Z+1	; 0x01
    4410:	0e 94 fd 16 	call	0x2dfa	; 0x2dfa <clust2sect>
    4414:	61 15       	cp	r22, r1
    4416:	71 05       	cpc	r23, r1
    4418:	81 05       	cpc	r24, r1
    441a:	91 05       	cpc	r25, r1
    441c:	09 f4       	brne	.+2      	; 0x4420 <f_lseek+0x280>
    441e:	72 cf       	rjmp	.-284    	; 0x4304 <f_lseek+0x164>
    4420:	29 e0       	ldi	r18, 0x09	; 9
    4422:	f6 94       	lsr	r15
    4424:	e7 94       	ror	r14
    4426:	d7 94       	ror	r13
    4428:	c7 94       	ror	r12
    442a:	2a 95       	dec	r18
    442c:	d1 f7       	brne	.-12     	; 0x4422 <f_lseek+0x282>
    442e:	c6 0e       	add	r12, r22
    4430:	d7 1e       	adc	r13, r23
    4432:	e8 1e       	adc	r14, r24
    4434:	f9 1e       	adc	r15, r25
    4436:	f1 01       	movw	r30, r2
    4438:	86 81       	ldd	r24, Z+6	; 0x06
    443a:	97 81       	ldd	r25, Z+7	; 0x07
    443c:	a0 85       	ldd	r26, Z+8	; 0x08
    443e:	b1 85       	ldd	r27, Z+9	; 0x09
    4440:	ac 01       	movw	r20, r24
    4442:	bd 01       	movw	r22, r26
    4444:	51 70       	andi	r21, 0x01	; 1
    4446:	66 27       	eor	r22, r22
    4448:	77 27       	eor	r23, r23
    444a:	45 2b       	or	r20, r21
    444c:	46 2b       	or	r20, r22
    444e:	47 2b       	or	r20, r23
    4450:	69 f0       	breq	.+26     	; 0x446c <f_lseek+0x2cc>
    4452:	46 89       	ldd	r20, Z+22	; 0x16
    4454:	57 89       	ldd	r21, Z+23	; 0x17
    4456:	60 8d       	ldd	r22, Z+24	; 0x18
    4458:	71 8d       	ldd	r23, Z+25	; 0x19
    445a:	c4 16       	cp	r12, r20
    445c:	d5 06       	cpc	r13, r21
    445e:	e6 06       	cpc	r14, r22
    4460:	f7 06       	cpc	r15, r23
    4462:	21 f0       	breq	.+8      	; 0x446c <f_lseek+0x2cc>
    4464:	c6 8a       	std	Z+22, r12	; 0x16
    4466:	d7 8a       	std	Z+23, r13	; 0x17
    4468:	e0 8e       	std	Z+24, r14	; 0x18
    446a:	f1 8e       	std	Z+25, r15	; 0x19
    446c:	f1 01       	movw	r30, r2
    446e:	42 85       	ldd	r20, Z+10	; 0x0a
    4470:	53 85       	ldd	r21, Z+11	; 0x0b
    4472:	64 85       	ldd	r22, Z+12	; 0x0c
    4474:	75 85       	ldd	r23, Z+13	; 0x0d
    4476:	48 17       	cp	r20, r24
    4478:	59 07       	cpc	r21, r25
    447a:	6a 07       	cpc	r22, r26
    447c:	7b 07       	cpc	r23, r27
    447e:	38 f4       	brcc	.+14     	; 0x448e <f_lseek+0x2ee>
    4480:	82 87       	std	Z+10, r24	; 0x0a
    4482:	93 87       	std	Z+11, r25	; 0x0b
    4484:	a4 87       	std	Z+12, r26	; 0x0c
    4486:	b5 87       	std	Z+13, r27	; 0x0d
    4488:	84 81       	ldd	r24, Z+4	; 0x04
    448a:	80 62       	ori	r24, 0x20	; 32
    448c:	84 83       	std	Z+4, r24	; 0x04
    448e:	80 e0       	ldi	r24, 0x00	; 0
    4490:	0f 90       	pop	r0
    4492:	0f 90       	pop	r0
    4494:	0f 90       	pop	r0
    4496:	0f 90       	pop	r0
    4498:	df 91       	pop	r29
    449a:	cf 91       	pop	r28
    449c:	1f 91       	pop	r17
    449e:	0f 91       	pop	r16
    44a0:	ff 90       	pop	r15
    44a2:	ef 90       	pop	r14
    44a4:	df 90       	pop	r13
    44a6:	cf 90       	pop	r12
    44a8:	bf 90       	pop	r11
    44aa:	af 90       	pop	r10
    44ac:	9f 90       	pop	r9
    44ae:	8f 90       	pop	r8
    44b0:	7f 90       	pop	r7
    44b2:	6f 90       	pop	r6
    44b4:	5f 90       	pop	r5
    44b6:	4f 90       	pop	r4
    44b8:	3f 90       	pop	r3
    44ba:	2f 90       	pop	r2
    44bc:	08 95       	ret

000044be <f_stat>:

FRESULT f_stat (
	const TCHAR* path,	/* Pointer to the file path */
	FILINFO* fno		/* Pointer to file information to return */
)
{
    44be:	ef 92       	push	r14
    44c0:	ff 92       	push	r15
    44c2:	1f 93       	push	r17
    44c4:	cf 93       	push	r28
    44c6:	df 93       	push	r29
    44c8:	cd b7       	in	r28, 0x3d	; 61
    44ca:	de b7       	in	r29, 0x3e	; 62
    44cc:	a4 97       	sbiw	r28, 0x24	; 36
    44ce:	0f b6       	in	r0, 0x3f	; 63
    44d0:	f8 94       	cli
    44d2:	de bf       	out	0x3e, r29	; 62
    44d4:	0f be       	out	0x3f, r0	; 63
    44d6:	cd bf       	out	0x3d, r28	; 61
    44d8:	9c a3       	std	Y+36, r25	; 0x24
    44da:	8b a3       	std	Y+35, r24	; 0x23
    44dc:	7b 01       	movw	r14, r22
	DIR dj;
	DEF_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
    44de:	40 e0       	ldi	r20, 0x00	; 0
    44e0:	be 01       	movw	r22, r28
    44e2:	6d 5d       	subi	r22, 0xDD	; 221
    44e4:	7f 4f       	sbci	r23, 0xFF	; 255
    44e6:	ce 01       	movw	r24, r28
    44e8:	01 96       	adiw	r24, 0x01	; 1
    44ea:	0e 94 9f 14 	call	0x293e	; 0x293e <find_volume>
    44ee:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    44f0:	81 11       	cpse	r24, r1
    44f2:	19 c0       	rjmp	.+50     	; 0x4526 <f_stat+0x68>
		INIT_BUF(dj);
    44f4:	ce 01       	movw	r24, r28
    44f6:	47 96       	adiw	r24, 0x17	; 23
    44f8:	9e 8b       	std	Y+22, r25	; 0x16
    44fa:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    44fc:	6b a1       	ldd	r22, Y+35	; 0x23
    44fe:	7c a1       	ldd	r23, Y+36	; 0x24
    4500:	46 97       	sbiw	r24, 0x16	; 22
    4502:	0e d9       	rcall	.-3556   	; 0x3720 <follow_path>
    4504:	18 2f       	mov	r17, r24
		if (res == FR_OK) {				/* Follow completed */
    4506:	81 11       	cpse	r24, r1
    4508:	0e c0       	rjmp	.+28     	; 0x4526 <f_stat+0x68>
			if (dj.dir) {		/* Found an object */
    450a:	8b 89       	ldd	r24, Y+19	; 0x13
    450c:	9c 89       	ldd	r25, Y+20	; 0x14
    450e:	89 2b       	or	r24, r25
    4510:	49 f0       	breq	.+18     	; 0x4524 <f_stat+0x66>
				if (fno) get_fileinfo(&dj, fno);
    4512:	e1 14       	cp	r14, r1
    4514:	f1 04       	cpc	r15, r1
    4516:	39 f0       	breq	.+14     	; 0x4526 <f_stat+0x68>
    4518:	b7 01       	movw	r22, r14
    451a:	ce 01       	movw	r24, r28
    451c:	01 96       	adiw	r24, 0x01	; 1
    451e:	0e 94 d8 12 	call	0x25b0	; 0x25b0 <get_fileinfo>
    4522:	01 c0       	rjmp	.+2      	; 0x4526 <f_stat+0x68>
			} else {			/* It is root directory */
				res = FR_INVALID_NAME;
    4524:	16 e0       	ldi	r17, 0x06	; 6
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    4526:	81 2f       	mov	r24, r17
    4528:	a4 96       	adiw	r28, 0x24	; 36
    452a:	0f b6       	in	r0, 0x3f	; 63
    452c:	f8 94       	cli
    452e:	de bf       	out	0x3e, r29	; 62
    4530:	0f be       	out	0x3f, r0	; 63
    4532:	cd bf       	out	0x3d, r28	; 61
    4534:	df 91       	pop	r29
    4536:	cf 91       	pop	r28
    4538:	1f 91       	pop	r17
    453a:	ff 90       	pop	r15
    453c:	ef 90       	pop	r14
    453e:	08 95       	ret

00004540 <SCSI_Command_ReadWrite_10>:
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_ReadWrite_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                      const bool IsDataRead)
{
    4540:	bf 92       	push	r11
    4542:	cf 92       	push	r12
    4544:	df 92       	push	r13
    4546:	ef 92       	push	r14
    4548:	ff 92       	push	r15
    454a:	0f 93       	push	r16
    454c:	1f 93       	push	r17
    454e:	cf 93       	push	r28
    4550:	df 93       	push	r29
    4552:	ec 01       	movw	r28, r24
    4554:	b6 2e       	mov	r11, r22

				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
    4556:	c8 a0       	ldd	r12, Y+32	; 0x20
    4558:	df 8c       	ldd	r13, Y+31	; 0x1f
    455a:	ee 8c       	ldd	r14, Y+30	; 0x1e
    455c:	fd 8c       	ldd	r15, Y+29	; 0x1d

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
    455e:	0b a1       	ldd	r16, Y+35	; 0x23
    4560:	1a a1       	ldd	r17, Y+34	; 0x22

	/* Load in the 16-bit total blocks (SCSI uses big-endian, so have to reverse the byte order) */
	TotalBlocks  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[7]);

	/* Check if the block address is outside the maximum allowable value for the LUN */
	if (BlockAddress >= get_num_of_sectors())
    4562:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <get_num_of_sectors>
    4566:	c6 16       	cp	r12, r22
    4568:	d7 06       	cpc	r13, r23
    456a:	e8 06       	cpc	r14, r24
    456c:	f9 06       	cpc	r15, r25
    456e:	68 f0       	brcs	.+26     	; 0x458a <SCSI_Command_ReadWrite_10+0x4a>
	{
		/* Block address is invalid, update SENSE key and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    4570:	80 91 10 01 	lds	r24, 0x0110
    4574:	80 7f       	andi	r24, 0xF0	; 240
    4576:	85 60       	ori	r24, 0x05	; 5
    4578:	80 93 10 01 	sts	0x0110, r24
    457c:	81 e2       	ldi	r24, 0x21	; 33
    457e:	80 93 1a 01 	sts	0x011A, r24
    4582:	10 92 1b 01 	sts	0x011B, r1
    4586:	80 e0       	ldi	r24, 0x00	; 0
    4588:	22 c0       	rjmp	.+68     	; 0x45ce <SCSI_Command_ReadWrite_10+0x8e>
	}

	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
	  //SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
	  SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
    458a:	98 01       	movw	r18, r16
    458c:	b7 01       	movw	r22, r14
    458e:	a6 01       	movw	r20, r12
    4590:	ce 01       	movw	r24, r28

		return false;
	}

	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
    4592:	bb 20       	and	r11, r11
    4594:	11 f0       	breq	.+4      	; 0x459a <SCSI_Command_ReadWrite_10+0x5a>
	  //SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
	  SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
    4596:	79 d2       	rcall	.+1266   	; 0x4a8a <SDCardManager_ReadBlocks>
    4598:	01 c0       	rjmp	.+2      	; 0x459c <SCSI_Command_ReadWrite_10+0x5c>
	else
	  SDCardManager_WriteBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
    459a:	d1 d1       	rcall	.+930    	; 0x493e <SDCardManager_WriteBlocks>

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= ((uint32_t)TotalBlocks * VIRTUAL_MEMORY_BLOCK_SIZE);
    459c:	c8 01       	movw	r24, r16
    459e:	a0 e0       	ldi	r26, 0x00	; 0
    45a0:	b0 e0       	ldi	r27, 0x00	; 0
    45a2:	29 e0       	ldi	r18, 0x09	; 9
    45a4:	88 0f       	add	r24, r24
    45a6:	99 1f       	adc	r25, r25
    45a8:	aa 1f       	adc	r26, r26
    45aa:	bb 1f       	adc	r27, r27
    45ac:	2a 95       	dec	r18
    45ae:	d1 f7       	brne	.-12     	; 0x45a4 <SCSI_Command_ReadWrite_10+0x64>
    45b0:	4c 89       	ldd	r20, Y+20	; 0x14
    45b2:	5d 89       	ldd	r21, Y+21	; 0x15
    45b4:	6e 89       	ldd	r22, Y+22	; 0x16
    45b6:	7f 89       	ldd	r23, Y+23	; 0x17
    45b8:	8a 01       	movw	r16, r20
    45ba:	9b 01       	movw	r18, r22
    45bc:	08 1b       	sub	r16, r24
    45be:	19 0b       	sbc	r17, r25
    45c0:	2a 0b       	sbc	r18, r26
    45c2:	3b 0b       	sbc	r19, r27
    45c4:	0c 8b       	std	Y+20, r16	; 0x14
    45c6:	1d 8b       	std	Y+21, r17	; 0x15
    45c8:	2e 8b       	std	Y+22, r18	; 0x16
    45ca:	3f 8b       	std	Y+23, r19	; 0x17

	return true;
    45cc:	81 e0       	ldi	r24, 0x01	; 1
}
    45ce:	df 91       	pop	r29
    45d0:	cf 91       	pop	r28
    45d2:	1f 91       	pop	r17
    45d4:	0f 91       	pop	r16
    45d6:	ff 90       	pop	r15
    45d8:	ef 90       	pop	r14
    45da:	df 90       	pop	r13
    45dc:	cf 90       	pop	r12
    45de:	bf 90       	pop	r11
    45e0:	08 95       	ret

000045e2 <SCSI_DecodeSCSICommand>:
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise
 */
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    45e2:	cf 92       	push	r12
    45e4:	df 92       	push	r13
    45e6:	ef 92       	push	r14
    45e8:	ff 92       	push	r15
    45ea:	0f 93       	push	r16
    45ec:	1f 93       	push	r17
    45ee:	cf 93       	push	r28
    45f0:	df 93       	push	r29
    45f2:	cd b7       	in	r28, 0x3d	; 61
    45f4:	de b7       	in	r29, 0x3e	; 62
    45f6:	28 97       	sbiw	r28, 0x08	; 8
    45f8:	0f b6       	in	r0, 0x3f	; 63
    45fa:	f8 94       	cli
    45fc:	de bf       	out	0x3e, r29	; 62
    45fe:	0f be       	out	0x3f, r0	; 63
    4600:	cd bf       	out	0x3d, r28	; 61
    4602:	8c 01       	movw	r16, r24
	bool CommandSuccess = false;



	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
    4604:	fc 01       	movw	r30, r24
    4606:	83 8d       	ldd	r24, Z+27	; 0x1b
    4608:	8d 31       	cpi	r24, 0x1D	; 29
    460a:	09 f4       	brne	.+2      	; 0x460e <SCSI_DecodeSCSICommand+0x2c>
    460c:	c2 c0       	rjmp	.+388    	; 0x4792 <SCSI_DecodeSCSICommand+0x1b0>
    460e:	88 f4       	brcc	.+34     	; 0x4632 <SCSI_DecodeSCSICommand+0x50>
    4610:	82 31       	cpi	r24, 0x12	; 18
    4612:	09 f1       	breq	.+66     	; 0x4656 <SCSI_DecodeSCSICommand+0x74>
    4614:	38 f4       	brcc	.+14     	; 0x4624 <SCSI_DecodeSCSICommand+0x42>
    4616:	88 23       	and	r24, r24
    4618:	09 f4       	brne	.+2      	; 0x461c <SCSI_DecodeSCSICommand+0x3a>
    461a:	ff c0       	rjmp	.+510    	; 0x481a <SCSI_DecodeSCSICommand+0x238>
    461c:	83 30       	cpi	r24, 0x03	; 3
    461e:	09 f4       	brne	.+2      	; 0x4622 <SCSI_DecodeSCSICommand+0x40>
    4620:	50 c0       	rjmp	.+160    	; 0x46c2 <SCSI_DecodeSCSICommand+0xe0>
    4622:	0a c1       	rjmp	.+532    	; 0x4838 <SCSI_DecodeSCSICommand+0x256>
    4624:	8a 31       	cpi	r24, 0x1A	; 26
    4626:	09 f4       	brne	.+2      	; 0x462a <SCSI_DecodeSCSICommand+0x48>
    4628:	de c0       	rjmp	.+444    	; 0x47e6 <SCSI_DecodeSCSICommand+0x204>
    462a:	8b 31       	cpi	r24, 0x1B	; 27
    462c:	09 f4       	brne	.+2      	; 0x4630 <SCSI_DecodeSCSICommand+0x4e>
    462e:	fe c0       	rjmp	.+508    	; 0x482c <SCSI_DecodeSCSICommand+0x24a>
    4630:	03 c1       	rjmp	.+518    	; 0x4838 <SCSI_DecodeSCSICommand+0x256>
    4632:	88 32       	cpi	r24, 0x28	; 40
    4634:	09 f4       	brne	.+2      	; 0x4638 <SCSI_DecodeSCSICommand+0x56>
    4636:	c8 c0       	rjmp	.+400    	; 0x47c8 <SCSI_DecodeSCSICommand+0x1e6>
    4638:	38 f4       	brcc	.+14     	; 0x4648 <SCSI_DecodeSCSICommand+0x66>
    463a:	8e 31       	cpi	r24, 0x1E	; 30
    463c:	09 f4       	brne	.+2      	; 0x4640 <SCSI_DecodeSCSICommand+0x5e>
    463e:	f6 c0       	rjmp	.+492    	; 0x482c <SCSI_DecodeSCSICommand+0x24a>
    4640:	85 32       	cpi	r24, 0x25	; 37
    4642:	09 f4       	brne	.+2      	; 0x4646 <SCSI_DecodeSCSICommand+0x64>
    4644:	66 c0       	rjmp	.+204    	; 0x4712 <SCSI_DecodeSCSICommand+0x130>
    4646:	f8 c0       	rjmp	.+496    	; 0x4838 <SCSI_DecodeSCSICommand+0x256>
    4648:	8a 32       	cpi	r24, 0x2A	; 42
    464a:	09 f4       	brne	.+2      	; 0x464e <SCSI_DecodeSCSICommand+0x6c>
    464c:	b2 c0       	rjmp	.+356    	; 0x47b2 <SCSI_DecodeSCSICommand+0x1d0>
    464e:	8f 32       	cpi	r24, 0x2F	; 47
    4650:	09 f4       	brne	.+2      	; 0x4654 <SCSI_DecodeSCSICommand+0x72>
    4652:	ec c0       	rjmp	.+472    	; 0x482c <SCSI_DecodeSCSICommand+0x24a>
    4654:	f1 c0       	rjmp	.+482    	; 0x4838 <SCSI_DecodeSCSICommand+0x256>
    4656:	f8 01       	movw	r30, r16
    4658:	e7 8c       	ldd	r14, Z+31	; 0x1f
    465a:	f6 8c       	ldd	r15, Z+30	; 0x1e
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));

	/* Only the standard INQUIRY data is supported, check if any optional INQUIRY bits set */
	if ((MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & ((1 << 0) | (1 << 1))) ||
    465c:	84 8d       	ldd	r24, Z+28	; 0x1c
    465e:	83 70       	andi	r24, 0x03	; 3
    4660:	19 f4       	brne	.+6      	; 0x4668 <SCSI_DecodeSCSICommand+0x86>
    4662:	85 8d       	ldd	r24, Z+29	; 0x1d
    4664:	88 23       	and	r24, r24
    4666:	41 f0       	breq	.+16     	; 0x4678 <SCSI_DecodeSCSICommand+0x96>
	     MSInterfaceInfo->State.CommandBlock.SCSICommandData[2])
	{
		/* Optional but unsupported bits set - update the SENSE key and fail the request */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    4668:	80 91 10 01 	lds	r24, 0x0110
    466c:	80 7f       	andi	r24, 0xF0	; 240
    466e:	85 60       	ori	r24, 0x05	; 5
    4670:	80 93 10 01 	sts	0x0110, r24
    4674:	84 e2       	ldi	r24, 0x24	; 36
    4676:	e7 c0       	rjmp	.+462    	; 0x4846 <SCSI_DecodeSCSICommand+0x264>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));
    4678:	67 01       	movw	r12, r14
    467a:	f5 e2       	ldi	r31, 0x25	; 37
    467c:	ef 16       	cp	r14, r31
    467e:	f1 04       	cpc	r15, r1
    4680:	18 f0       	brcs	.+6      	; 0x4688 <SCSI_DecodeSCSICommand+0xa6>
    4682:	94 e2       	ldi	r25, 0x24	; 36
    4684:	c9 2e       	mov	r12, r25
    4686:	d1 2c       	mov	r13, r1
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
	}

	Endpoint_Write_Stream_LE(&InquiryData, BytesTransferred, NULL);
    4688:	40 e0       	ldi	r20, 0x00	; 0
    468a:	50 e0       	ldi	r21, 0x00	; 0
    468c:	b6 01       	movw	r22, r12
    468e:	89 ed       	ldi	r24, 0xD9	; 217
    4690:	92 e0       	ldi	r25, 0x02	; 2
    4692:	0e 94 96 31 	call	0x632c	; 0x632c <Endpoint_Write_Stream_LE>

	/* Pad out remaining bytes with 0x00 */
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
    4696:	60 e0       	ldi	r22, 0x00	; 0
    4698:	70 e0       	ldi	r23, 0x00	; 0
    469a:	c7 01       	movw	r24, r14
    469c:	8c 19       	sub	r24, r12
    469e:	9d 09       	sbc	r25, r13
    46a0:	0e 94 58 31 	call	0x62b0	; 0x62b0 <Endpoint_Null_Stream>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    46a4:	80 91 e8 00 	lds	r24, 0x00E8
    46a8:	8e 77       	andi	r24, 0x7E	; 126
    46aa:	80 93 e8 00 	sts	0x00E8, r24

	/* Finalize the stream transfer to send the last packet */
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
    46ae:	f8 01       	movw	r30, r16
    46b0:	84 89       	ldd	r24, Z+20	; 0x14
    46b2:	95 89       	ldd	r25, Z+21	; 0x15
    46b4:	a6 89       	ldd	r26, Z+22	; 0x16
    46b6:	b7 89       	ldd	r27, Z+23	; 0x17
    46b8:	8c 19       	sub	r24, r12
    46ba:	9d 09       	sbc	r25, r13
    46bc:	a1 09       	sbc	r26, r1
    46be:	b1 09       	sbc	r27, r1
    46c0:	a7 c0       	rjmp	.+334    	; 0x4810 <SCSI_DecodeSCSICommand+0x22e>
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint8_t  AllocationLength = MSInterfaceInfo->State.CommandBlock.SCSICommandData[4];
    46c2:	f8 01       	movw	r30, r16
    46c4:	f7 8c       	ldd	r15, Z+31	; 0x1f
	uint8_t  BytesTransferred = MIN(AllocationLength, sizeof(SenseData));
    46c6:	ef 2c       	mov	r14, r15
    46c8:	f2 e1       	ldi	r31, 0x12	; 18
    46ca:	ff 15       	cp	r31, r15
    46cc:	10 f4       	brcc	.+4      	; 0x46d2 <SCSI_DecodeSCSICommand+0xf0>
    46ce:	82 e1       	ldi	r24, 0x12	; 18
    46d0:	e8 2e       	mov	r14, r24

	Endpoint_Write_Stream_LE(&SenseData, BytesTransferred, NULL);
    46d2:	ce 2c       	mov	r12, r14
    46d4:	d1 2c       	mov	r13, r1
    46d6:	40 e0       	ldi	r20, 0x00	; 0
    46d8:	50 e0       	ldi	r21, 0x00	; 0
    46da:	b6 01       	movw	r22, r12
    46dc:	8e e0       	ldi	r24, 0x0E	; 14
    46de:	91 e0       	ldi	r25, 0x01	; 1
    46e0:	0e 94 96 31 	call	0x632c	; 0x632c <Endpoint_Write_Stream_LE>
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
    46e4:	8f 2d       	mov	r24, r15
    46e6:	90 e0       	ldi	r25, 0x00	; 0
    46e8:	60 e0       	ldi	r22, 0x00	; 0
    46ea:	70 e0       	ldi	r23, 0x00	; 0
    46ec:	8c 19       	sub	r24, r12
    46ee:	9d 09       	sbc	r25, r13
    46f0:	0e 94 58 31 	call	0x62b0	; 0x62b0 <Endpoint_Null_Stream>
    46f4:	80 91 e8 00 	lds	r24, 0x00E8
    46f8:	8e 77       	andi	r24, 0x7E	; 126
    46fa:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
    46fe:	f8 01       	movw	r30, r16
    4700:	84 89       	ldd	r24, Z+20	; 0x14
    4702:	95 89       	ldd	r25, Z+21	; 0x15
    4704:	a6 89       	ldd	r26, Z+22	; 0x16
    4706:	b7 89       	ldd	r27, Z+23	; 0x17
    4708:	8e 19       	sub	r24, r14
    470a:	91 09       	sbc	r25, r1
    470c:	a1 09       	sbc	r26, r1
    470e:	b1 09       	sbc	r27, r1
    4710:	7f c0       	rjmp	.+254    	; 0x4810 <SCSI_DecodeSCSICommand+0x22e>
			break;
		case SCSI_CMD_REQUEST_SENSE:
			CommandSuccess = SCSI_Command_Request_Sense(MSInterfaceInfo);
			break;
		case SCSI_CMD_READ_CAPACITY_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    4712:	14 d2       	rcall	.+1064   	; 0x4b3c <SDCardManager_CheckSDCardOperation>
    4714:	81 11       	cpse	r24, r1
    4716:	08 c0       	rjmp	.+16     	; 0x4728 <SCSI_DecodeSCSICommand+0x146>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
    4718:	80 91 10 01 	lds	r24, 0x0110
    471c:	80 7f       	andi	r24, 0xF0	; 240
    471e:	82 60       	ori	r24, 0x02	; 2
    4720:	80 93 10 01 	sts	0x0110, r24
    4724:	8a e3       	ldi	r24, 0x3A	; 58
    4726:	8f c0       	rjmp	.+286    	; 0x4846 <SCSI_DecodeSCSICommand+0x264>
			break;
		case SCSI_CMD_REQUEST_SENSE:
			CommandSuccess = SCSI_Command_Request_Sense(MSInterfaceInfo);
			break;
		case SCSI_CMD_READ_CAPACITY_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    4728:	80 91 6f 07 	lds	r24, 0x076F
    472c:	81 30       	cpi	r24, 0x01	; 1
    472e:	a1 f7       	brne	.-24     	; 0x4718 <SCSI_DecodeSCSICommand+0x136>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Read_Capacity_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint32_t LastBlockAddressInLUN;
	uint32_t MediaBlockSize        = VIRTUAL_MEMORY_BLOCK_SIZE;
    4730:	80 e0       	ldi	r24, 0x00	; 0
    4732:	92 e0       	ldi	r25, 0x02	; 2
    4734:	a0 e0       	ldi	r26, 0x00	; 0
    4736:	b0 e0       	ldi	r27, 0x00	; 0
    4738:	89 83       	std	Y+1, r24	; 0x01
    473a:	9a 83       	std	Y+2, r25	; 0x02
    473c:	ab 83       	std	Y+3, r26	; 0x03
    473e:	bc 83       	std	Y+4, r27	; 0x04

	LastBlockAddressInLUN = get_num_of_sectors()-1;
    4740:	0e 94 a5 0d 	call	0x1b4a	; 0x1b4a <get_num_of_sectors>
    4744:	dc 01       	movw	r26, r24
    4746:	cb 01       	movw	r24, r22
    4748:	01 97       	sbiw	r24, 0x01	; 1
    474a:	a1 09       	sbc	r26, r1
    474c:	b1 09       	sbc	r27, r1
    474e:	8d 83       	std	Y+5, r24	; 0x05
    4750:	9e 83       	std	Y+6, r25	; 0x06
    4752:	af 83       	std	Y+7, r26	; 0x07
    4754:	b8 87       	std	Y+8, r27	; 0x08

	Endpoint_Write_Stream_BE(&LastBlockAddressInLUN, sizeof(LastBlockAddressInLUN), NULL);
    4756:	40 e0       	ldi	r20, 0x00	; 0
    4758:	50 e0       	ldi	r21, 0x00	; 0
    475a:	64 e0       	ldi	r22, 0x04	; 4
    475c:	70 e0       	ldi	r23, 0x00	; 0
    475e:	ce 01       	movw	r24, r28
    4760:	05 96       	adiw	r24, 0x05	; 5
    4762:	0e 94 e0 31 	call	0x63c0	; 0x63c0 <Endpoint_Write_Stream_BE>
	Endpoint_Write_Stream_BE(&MediaBlockSize, sizeof(MediaBlockSize), NULL);
    4766:	40 e0       	ldi	r20, 0x00	; 0
    4768:	50 e0       	ldi	r21, 0x00	; 0
    476a:	64 e0       	ldi	r22, 0x04	; 4
    476c:	70 e0       	ldi	r23, 0x00	; 0
    476e:	ce 01       	movw	r24, r28
    4770:	01 96       	adiw	r24, 0x01	; 1
    4772:	0e 94 e0 31 	call	0x63c0	; 0x63c0 <Endpoint_Write_Stream_BE>
    4776:	80 91 e8 00 	lds	r24, 0x00E8
    477a:	8e 77       	andi	r24, 0x7E	; 126
    477c:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 8;
    4780:	f8 01       	movw	r30, r16
    4782:	84 89       	ldd	r24, Z+20	; 0x14
    4784:	95 89       	ldd	r25, Z+21	; 0x15
    4786:	a6 89       	ldd	r26, Z+22	; 0x16
    4788:	b7 89       	ldd	r27, Z+23	; 0x17
    478a:	08 97       	sbiw	r24, 0x08	; 8
    478c:	a1 09       	sbc	r26, r1
    478e:	b1 09       	sbc	r27, r1
    4790:	3f c0       	rjmp	.+126    	; 0x4810 <SCSI_DecodeSCSICommand+0x22e>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Send_Diagnostic(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	/* Check to see if the SELF TEST bit is not set */
	if (!(MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & (1 << 2)))
    4792:	f8 01       	movw	r30, r16
    4794:	84 8d       	ldd	r24, Z+28	; 0x1c
    4796:	82 ff       	sbrs	r24, 2
    4798:	67 cf       	rjmp	.-306    	; 0x4668 <SCSI_DecodeSCSICommand+0x86>

		return false;
	}

	/* Check to see if all attached Dataflash ICs are functional */
	if (!(SDCardManager_CheckSDCardOperation()))
    479a:	d0 d1       	rcall	.+928    	; 0x4b3c <SDCardManager_CheckSDCardOperation>
    479c:	81 11       	cpse	r24, r1
    479e:	46 c0       	rjmp	.+140    	; 0x482c <SCSI_DecodeSCSICommand+0x24a>
	{
		/* Update SENSE key with a hardware error condition and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_HARDWARE_ERROR,
    47a0:	80 91 10 01 	lds	r24, 0x0110
    47a4:	80 7f       	andi	r24, 0xF0	; 240
    47a6:	84 60       	ori	r24, 0x04	; 4
    47a8:	80 93 10 01 	sts	0x0110, r24
    47ac:	10 92 1a 01 	sts	0x011A, r1
    47b0:	4c c0       	rjmp	.+152    	; 0x484a <SCSI_DecodeSCSICommand+0x268>
			break;
		case SCSI_CMD_SEND_DIAGNOSTIC:
			CommandSuccess = SCSI_Command_Send_Diagnostic(MSInterfaceInfo);
			break;
		case SCSI_CMD_WRITE_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    47b2:	c4 d1       	rcall	.+904    	; 0x4b3c <SDCardManager_CheckSDCardOperation>
    47b4:	88 23       	and	r24, r24
    47b6:	09 f4       	brne	.+2      	; 0x47ba <SCSI_DecodeSCSICommand+0x1d8>
    47b8:	af cf       	rjmp	.-162    	; 0x4718 <SCSI_DecodeSCSICommand+0x136>
    47ba:	80 91 6f 07 	lds	r24, 0x076F
    47be:	81 30       	cpi	r24, 0x01	; 1
    47c0:	09 f0       	breq	.+2      	; 0x47c4 <SCSI_DecodeSCSICommand+0x1e2>
    47c2:	aa cf       	rjmp	.-172    	; 0x4718 <SCSI_DecodeSCSICommand+0x136>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
				return false; //return with an error flag -- send a failure response to host.
			}
			
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_WRITE);
    47c4:	60 e0       	ldi	r22, 0x00	; 0
    47c6:	0a c0       	rjmp	.+20     	; 0x47dc <SCSI_DecodeSCSICommand+0x1fa>
			break;
		case SCSI_CMD_READ_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    47c8:	b9 d1       	rcall	.+882    	; 0x4b3c <SDCardManager_CheckSDCardOperation>
    47ca:	88 23       	and	r24, r24
    47cc:	09 f4       	brne	.+2      	; 0x47d0 <SCSI_DecodeSCSICommand+0x1ee>
    47ce:	a4 cf       	rjmp	.-184    	; 0x4718 <SCSI_DecodeSCSICommand+0x136>
    47d0:	80 91 6f 07 	lds	r24, 0x076F
    47d4:	81 30       	cpi	r24, 0x01	; 1
    47d6:	09 f0       	breq	.+2      	; 0x47da <SCSI_DecodeSCSICommand+0x1f8>
    47d8:	9f cf       	rjmp	.-194    	; 0x4718 <SCSI_DecodeSCSICommand+0x136>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
				return false; //return with an error flag -- send a failure response to host.
			}
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
    47da:	61 e0       	ldi	r22, 0x01	; 1
    47dc:	c8 01       	movw	r24, r16
    47de:	b0 de       	rcall	.-672    	; 0x4540 <SCSI_Command_ReadWrite_10>
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
    47e0:	81 11       	cpse	r24, r1
    47e2:	36 c0       	rjmp	.+108    	; 0x4850 <SCSI_DecodeSCSICommand+0x26e>
    47e4:	40 c0       	rjmp	.+128    	; 0x4866 <SCSI_DecodeSCSICommand+0x284>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    47e6:	10 92 f1 00 	sts	0x00F1, r1
    47ea:	10 92 f1 00 	sts	0x00F1, r1
    47ee:	10 92 f1 00 	sts	0x00F1, r1
    47f2:	10 92 f1 00 	sts	0x00F1, r1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    47f6:	80 91 e8 00 	lds	r24, 0x00E8
    47fa:	8e 77       	andi	r24, 0x7E	; 126
    47fc:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_Write_8(DISK_READ_ONLY ? 0x80 : 0x00);
	Endpoint_Write_8(0x00);
	Endpoint_ClearIN();

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 4;
    4800:	f8 01       	movw	r30, r16
    4802:	84 89       	ldd	r24, Z+20	; 0x14
    4804:	95 89       	ldd	r25, Z+21	; 0x15
    4806:	a6 89       	ldd	r26, Z+22	; 0x16
    4808:	b7 89       	ldd	r27, Z+23	; 0x17
    480a:	04 97       	sbiw	r24, 0x04	; 4
    480c:	a1 09       	sbc	r26, r1
    480e:	b1 09       	sbc	r27, r1
    4810:	84 8b       	std	Z+20, r24	; 0x14
    4812:	95 8b       	std	Z+21, r25	; 0x15
    4814:	a6 8b       	std	Z+22, r26	; 0x16
    4816:	b7 8b       	std	Z+23, r27	; 0x17
			}
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
			break;
		case SCSI_CMD_MODE_SENSE_6:
			CommandSuccess = SCSI_Command_ModeSense_6(MSInterfaceInfo);
			break;
    4818:	1b c0       	rjmp	.+54     	; 0x4850 <SCSI_DecodeSCSICommand+0x26e>
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
			break;
		case SCSI_CMD_TEST_UNIT_READY:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    481a:	90 d1       	rcall	.+800    	; 0x4b3c <SDCardManager_CheckSDCardOperation>
    481c:	88 23       	and	r24, r24
    481e:	09 f4       	brne	.+2      	; 0x4822 <SCSI_DecodeSCSICommand+0x240>
    4820:	7b cf       	rjmp	.-266    	; 0x4718 <SCSI_DecodeSCSICommand+0x136>
    4822:	80 91 6f 07 	lds	r24, 0x076F
    4826:	81 30       	cpi	r24, 0x01	; 1
    4828:	09 f0       	breq	.+2      	; 0x482c <SCSI_DecodeSCSICommand+0x24a>
    482a:	76 cf       	rjmp	.-276    	; 0x4718 <SCSI_DecodeSCSICommand+0x136>
		case SCSI_CMD_START_STOP_UNIT:
		case SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
		case SCSI_CMD_VERIFY_10:
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
    482c:	f8 01       	movw	r30, r16
    482e:	14 8a       	std	Z+20, r1	; 0x14
    4830:	15 8a       	std	Z+21, r1	; 0x15
    4832:	16 8a       	std	Z+22, r1	; 0x16
    4834:	17 8a       	std	Z+23, r1	; 0x17
			break;
    4836:	0c c0       	rjmp	.+24     	; 0x4850 <SCSI_DecodeSCSICommand+0x26e>
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
			break;
		default:
			/* Update the SENSE key to reflect the invalid command */
			SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    4838:	80 91 10 01 	lds	r24, 0x0110
    483c:	80 7f       	andi	r24, 0xF0	; 240
    483e:	85 60       	ori	r24, 0x05	; 5
    4840:	80 93 10 01 	sts	0x0110, r24
    4844:	80 e2       	ldi	r24, 0x20	; 32
    4846:	80 93 1a 01 	sts	0x011A, r24
    484a:	10 92 1b 01 	sts	0x011B, r1
		                   SCSI_ASENSE_INVALID_COMMAND,
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
    484e:	0b c0       	rjmp	.+22     	; 0x4866 <SCSI_DecodeSCSICommand+0x284>
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
	{
		SCSI_SET_SENSE(SCSI_SENSE_KEY_GOOD,
    4850:	80 91 10 01 	lds	r24, 0x0110
    4854:	80 7f       	andi	r24, 0xF0	; 240
    4856:	80 93 10 01 	sts	0x0110, r24
    485a:	10 92 1a 01 	sts	0x011A, r1
    485e:	10 92 1b 01 	sts	0x011B, r1
		               SCSI_ASENSE_NO_ADDITIONAL_INFORMATION,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return true;
    4862:	81 e0       	ldi	r24, 0x01	; 1
    4864:	01 c0       	rjmp	.+2      	; 0x4868 <SCSI_DecodeSCSICommand+0x286>
	}

	return false;
    4866:	80 e0       	ldi	r24, 0x00	; 0
}
    4868:	28 96       	adiw	r28, 0x08	; 8
    486a:	0f b6       	in	r0, 0x3f	; 63
    486c:	f8 94       	cli
    486e:	de bf       	out	0x3e, r29	; 62
    4870:	0f be       	out	0x3f, r0	; 63
    4872:	cd bf       	out	0x3d, r28	; 61
    4874:	df 91       	pop	r29
    4876:	cf 91       	pop	r28
    4878:	1f 91       	pop	r17
    487a:	0f 91       	pop	r16
    487c:	ff 90       	pop	r15
    487e:	ef 90       	pop	r14
    4880:	df 90       	pop	r13
    4882:	cf 90       	pop	r12
    4884:	08 95       	ret

00004886 <SDCardManager_Init>:
static bool SDCard_Present= false;

void SDCardManager_Init(void)
{

	if(disk_initialize(0)==FR_OK){ //if the disk initializes correctly
    4886:	80 e0       	ldi	r24, 0x00	; 0
    4888:	0e 94 dd 10 	call	0x21ba	; 0x21ba <disk_initialize>
    488c:	81 11       	cpse	r24, r1
    488e:	04 c0       	rjmp	.+8      	; 0x4898 <SDCardManager_Init+0x12>
		SDCard_Present = true;
    4890:	81 e0       	ldi	r24, 0x01	; 1
    4892:	80 93 5c 05 	sts	0x055C, r24
    4896:	08 95       	ret
	}
	else{
		SDCard_Present = false; //tell other functions that the SD Card is missing/malfunctioned
    4898:	10 92 5c 05 	sts	0x055C, r1
    489c:	08 95       	ret

0000489e <SDCardManager_WriteBlockHandler>:
	}
}


uintptr_t SDCardManager_WriteBlockHandler(uint8_t* buffer, uint16_t offset)
{
    489e:	0f 93       	push	r16
    48a0:	1f 93       	push	r17
    48a2:	cf 93       	push	r28
    48a4:	df 93       	push	r29
    48a6:	8c 01       	movw	r16, r24
    48a8:	eb 01       	movw	r28, r22
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    48aa:	80 91 e8 00 	lds	r24, 0x00E8

	/* Check if the endpoint is currently empty */
	if (!(Endpoint_IsReadWriteAllowed()))
    48ae:	85 ff       	sbrs	r24, 5
    48b0:	36 c0       	rjmp	.+108    	; 0x491e <SDCardManager_WriteBlockHandler+0x80>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    48b2:	80 91 f1 00 	lds	r24, 0x00F1
		if (Endpoint_WaitUntilReady())
		  return 0;
	}
	
	/* Write one 16-byte chunk of data to the dataflash */
	buffer[0+offset] = Endpoint_Read_8();
    48b6:	f8 01       	movw	r30, r16
    48b8:	ec 0f       	add	r30, r28
    48ba:	fd 1f       	adc	r31, r29
    48bc:	80 83       	st	Z, r24
    48be:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[1+offset] = Endpoint_Read_8();
    48c2:	81 83       	std	Z+1, r24	; 0x01
    48c4:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[2+offset] = Endpoint_Read_8();
    48c8:	82 83       	std	Z+2, r24	; 0x02
    48ca:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[3+offset] = Endpoint_Read_8();
    48ce:	83 83       	std	Z+3, r24	; 0x03
    48d0:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[4+offset] = Endpoint_Read_8();
    48d4:	84 83       	std	Z+4, r24	; 0x04
    48d6:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[5+offset] = Endpoint_Read_8();
    48da:	85 83       	std	Z+5, r24	; 0x05
    48dc:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[6+offset] = Endpoint_Read_8();
    48e0:	86 83       	std	Z+6, r24	; 0x06
    48e2:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[7+offset] = Endpoint_Read_8();
    48e6:	87 83       	std	Z+7, r24	; 0x07
    48e8:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[8+offset] = Endpoint_Read_8();
    48ec:	80 87       	std	Z+8, r24	; 0x08
    48ee:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[9+offset] = Endpoint_Read_8();
    48f2:	81 87       	std	Z+9, r24	; 0x09
    48f4:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[10+offset] = Endpoint_Read_8();
    48f8:	82 87       	std	Z+10, r24	; 0x0a
    48fa:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[11+offset] = Endpoint_Read_8();
    48fe:	83 87       	std	Z+11, r24	; 0x0b
    4900:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[12+offset] = Endpoint_Read_8();
    4904:	84 87       	std	Z+12, r24	; 0x0c
    4906:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[13+offset] = Endpoint_Read_8();
    490a:	85 87       	std	Z+13, r24	; 0x0d
    490c:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[14+offset] = Endpoint_Read_8();
    4910:	86 87       	std	Z+14, r24	; 0x0e
    4912:	80 91 f1 00 	lds	r24, 0x00F1
	buffer[15+offset] = Endpoint_Read_8();
    4916:	87 87       	std	Z+15, r24	; 0x0f
	
	return 16;
    4918:	80 e1       	ldi	r24, 0x10	; 16
    491a:	90 e0       	ldi	r25, 0x00	; 0
    491c:	0b c0       	rjmp	.+22     	; 0x4934 <SDCardManager_WriteBlockHandler+0x96>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    491e:	90 91 e8 00 	lds	r25, 0x00E8
    4922:	9b 77       	andi	r25, 0x7B	; 123
    4924:	90 93 e8 00 	sts	0x00E8, r25
	{
		/* Clear the current endpoint bank */
		Endpoint_ClearOUT();
		
		/* Wait until the host has sent another packet */
		if (Endpoint_WaitUntilReady())
    4928:	0e 94 1a 34 	call	0x6834	; 0x6834 <Endpoint_WaitUntilReady>
    492c:	88 23       	and	r24, r24
    492e:	09 f2       	breq	.-126    	; 0x48b2 <SDCardManager_WriteBlockHandler+0x14>
		  return 0;
    4930:	80 e0       	ldi	r24, 0x00	; 0
    4932:	90 e0       	ldi	r25, 0x00	; 0
	buffer[13+offset] = Endpoint_Read_8();
	buffer[14+offset] = Endpoint_Read_8();
	buffer[15+offset] = Endpoint_Read_8();
	
	return 16;
}
    4934:	df 91       	pop	r29
    4936:	cf 91       	pop	r28
    4938:	1f 91       	pop	r17
    493a:	0f 91       	pop	r16
    493c:	08 95       	ret

0000493e <SDCardManager_WriteBlocks>:
 *
 *  \param[in] BlockAddress  Data block starting address for the write sequence
 *  \param[in] TotalBlocks   Number of blocks of data to write
 */
void SDCardManager_WriteBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo, uint32_t BlockAddress, uint16_t TotalBlocks)
{
    493e:	8f 92       	push	r8
    4940:	9f 92       	push	r9
    4942:	af 92       	push	r10
    4944:	bf 92       	push	r11
    4946:	cf 92       	push	r12
    4948:	df 92       	push	r13
    494a:	ef 92       	push	r14
    494c:	ff 92       	push	r15
    494e:	0f 93       	push	r16
    4950:	1f 93       	push	r17
    4952:	cf 93       	push	r28
    4954:	df 93       	push	r29
    4956:	6c 01       	movw	r12, r24
    4958:	4a 01       	movw	r8, r20
    495a:	5b 01       	movw	r10, r22
    495c:	79 01       	movw	r14, r18
	uint16_t  BytesWritten;

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
    495e:	0e 94 1a 34 	call	0x6834	; 0x6834 <Endpoint_WaitUntilReady>
    4962:	81 11       	cpse	r24, r1
    4964:	33 c0       	rjmp	.+102    	; 0x49cc <SDCardManager_WriteBlocks+0x8e>
	  return;
	
	while (TotalBlocks)
    4966:	e1 14       	cp	r14, r1
    4968:	f1 04       	cpc	r15, r1
    496a:	31 f1       	breq	.+76     	; 0x49b8 <SDCardManager_WriteBlocks+0x7a>
	{
		set_low(RED_LED); //red LED indicates busy status
    496c:	2e 98       	cbi	0x05, 6	; 5
		
		//Reset BytesWritten every time you finish writing a block, Dummy!
		BytesWritten = 0;
    496e:	c0 e0       	ldi	r28, 0x00	; 0
    4970:	d0 e0       	ldi	r29, 0x00	; 0
		
		while((BytesWritten<512)){
			BytesWritten += SDCardManager_WriteBlockHandler((uint8_t*)SD_Buffer, BytesWritten);
    4972:	be 01       	movw	r22, r28
    4974:	80 e7       	ldi	r24, 0x70	; 112
    4976:	97 e0       	ldi	r25, 0x07	; 7
    4978:	92 df       	rcall	.-220    	; 0x489e <SDCardManager_WriteBlockHandler>
    497a:	c8 0f       	add	r28, r24
    497c:	d9 1f       	adc	r29, r25
			if (USB_DeviceState != DEVICE_STATE_Configured){return;}//if the device is not configured, exit out of this
    497e:	80 91 b4 09 	lds	r24, 0x09B4
    4982:	84 30       	cpi	r24, 0x04	; 4
    4984:	19 f5       	brne	.+70     	; 0x49cc <SDCardManager_WriteBlocks+0x8e>
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
    4986:	f6 01       	movw	r30, r12
    4988:	80 ad       	ldd	r24, Z+56	; 0x38
    498a:	81 11       	cpse	r24, r1
    498c:	1f c0       	rjmp	.+62     	; 0x49cc <SDCardManager_WriteBlocks+0x8e>
		set_low(RED_LED); //red LED indicates busy status
		
		//Reset BytesWritten every time you finish writing a block, Dummy!
		BytesWritten = 0;
		
		while((BytesWritten<512)){
    498e:	c1 15       	cp	r28, r1
    4990:	f2 e0       	ldi	r31, 0x02	; 2
    4992:	df 07       	cpc	r29, r31
    4994:	70 f3       	brcs	.-36     	; 0x4972 <SDCardManager_WriteBlocks+0x34>
			BytesWritten += SDCardManager_WriteBlockHandler((uint8_t*)SD_Buffer, BytesWritten);
			if (USB_DeviceState != DEVICE_STATE_Configured){return;}//if the device is not configured, exit out of this
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
		}
		
		disk_write (0, (uint8_t*)SD_Buffer, BlockAddress, 1);//write to disk 0, from Buffer array, into BlockAddress, Write only 1 sector (block);
    4996:	01 e0       	ldi	r16, 0x01	; 1
    4998:	10 e0       	ldi	r17, 0x00	; 0
    499a:	a5 01       	movw	r20, r10
    499c:	94 01       	movw	r18, r8
    499e:	60 e7       	ldi	r22, 0x70	; 112
    49a0:	77 e0       	ldi	r23, 0x07	; 7
    49a2:	0e 94 bf 11 	call	0x237e	; 0x237e <disk_write>
	
		/* Decrement the blocks remaining counter and reset the sub block counter */
		BlockAddress++;
    49a6:	8f ef       	ldi	r24, 0xFF	; 255
    49a8:	88 1a       	sub	r8, r24
    49aa:	98 0a       	sbc	r9, r24
    49ac:	a8 0a       	sbc	r10, r24
    49ae:	b8 0a       	sbc	r11, r24
		TotalBlocks--;			
    49b0:	e1 e0       	ldi	r30, 0x01	; 1
    49b2:	ee 1a       	sub	r14, r30
    49b4:	f1 08       	sbc	r15, r1
    49b6:	d7 cf       	rjmp	.-82     	; 0x4966 <SDCardManager_WriteBlocks+0x28>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    49b8:	80 91 e8 00 	lds	r24, 0x00E8
		
	}

	/* If the endpoint is empty, clear it ready for the next packet from the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    49bc:	85 fd       	sbrc	r24, 5
    49be:	05 c0       	rjmp	.+10     	; 0x49ca <SDCardManager_WriteBlocks+0x8c>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    49c0:	80 91 e8 00 	lds	r24, 0x00E8
    49c4:	8b 77       	andi	r24, 0x7B	; 123
    49c6:	80 93 e8 00 	sts	0x00E8, r24
	  Endpoint_ClearOUT();
	  
	  set_high(RED_LED);
    49ca:	2e 9a       	sbi	0x05, 6	; 5
}
    49cc:	df 91       	pop	r29
    49ce:	cf 91       	pop	r28
    49d0:	1f 91       	pop	r17
    49d2:	0f 91       	pop	r16
    49d4:	ff 90       	pop	r15
    49d6:	ef 90       	pop	r14
    49d8:	df 90       	pop	r13
    49da:	cf 90       	pop	r12
    49dc:	bf 90       	pop	r11
    49de:	af 90       	pop	r10
    49e0:	9f 90       	pop	r9
    49e2:	8f 90       	pop	r8
    49e4:	08 95       	ret

000049e6 <SDCardManager_ReadBlockHandler>:
 *  \param[in] BlockAddress  Data block starting address for the read sequence
 *  \param[in] TotalBlocks   Number of blocks of data to read
 *  \output -- number of bytes forwarded successfully.  Return 16 if they are forwarded successfully, 0 if host rejects them.
 */
uint8_t SDCardManager_ReadBlockHandler(uint8_t* buffer, uint16_t offset)
{
    49e6:	ef 92       	push	r14
    49e8:	ff 92       	push	r15
    49ea:	1f 93       	push	r17
    49ec:	cf 93       	push	r28
    49ee:	df 93       	push	r29
    49f0:	7c 01       	movw	r14, r24
    49f2:	eb 01       	movw	r28, r22
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    49f4:	90 91 e8 00 	lds	r25, 0x00E8

	/* Check if the endpoint is currently full */
	if (!(Endpoint_IsReadWriteAllowed()))
    49f8:	19 2f       	mov	r17, r25
    49fa:	10 72       	andi	r17, 0x20	; 32
    49fc:	95 ff       	sbrs	r25, 5
    49fe:	35 c0       	rjmp	.+106    	; 0x4a6a <SDCardManager_ReadBlockHandler+0x84>
		/* Wait until the endpoint is ready for more data */
		if (Endpoint_WaitUntilReady())
		return 0;
	}
	
	Endpoint_Write_8(buffer[0+offset]);
    4a00:	f7 01       	movw	r30, r14
    4a02:	ec 0f       	add	r30, r28
    4a04:	fd 1f       	adc	r31, r29
    4a06:	80 81       	ld	r24, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4a08:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[1+offset]);
    4a0c:	81 81       	ldd	r24, Z+1	; 0x01
    4a0e:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[2+offset]);
    4a12:	82 81       	ldd	r24, Z+2	; 0x02
    4a14:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[3+offset]);
    4a18:	83 81       	ldd	r24, Z+3	; 0x03
    4a1a:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[4+offset]);
    4a1e:	84 81       	ldd	r24, Z+4	; 0x04
    4a20:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[5+offset]);
    4a24:	85 81       	ldd	r24, Z+5	; 0x05
    4a26:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[6+offset]);
    4a2a:	86 81       	ldd	r24, Z+6	; 0x06
    4a2c:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[7+offset]);
    4a30:	87 81       	ldd	r24, Z+7	; 0x07
    4a32:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[8+offset]);
    4a36:	80 85       	ldd	r24, Z+8	; 0x08
    4a38:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[9+offset]);
    4a3c:	81 85       	ldd	r24, Z+9	; 0x09
    4a3e:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[10+offset]);
    4a42:	82 85       	ldd	r24, Z+10	; 0x0a
    4a44:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[11+offset]);
    4a48:	83 85       	ldd	r24, Z+11	; 0x0b
    4a4a:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[12+offset]);
    4a4e:	84 85       	ldd	r24, Z+12	; 0x0c
    4a50:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[13+offset]);
    4a54:	85 85       	ldd	r24, Z+13	; 0x0d
    4a56:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[14+offset]);
    4a5a:	86 85       	ldd	r24, Z+14	; 0x0e
    4a5c:	80 93 f1 00 	sts	0x00F1, r24
	Endpoint_Write_8(buffer[15+offset]);
    4a60:	87 85       	ldd	r24, Z+15	; 0x0f
    4a62:	80 93 f1 00 	sts	0x00F1, r24
	
	return 16;
    4a66:	10 e1       	ldi	r17, 0x10	; 16
    4a68:	09 c0       	rjmp	.+18     	; 0x4a7c <SDCardManager_ReadBlockHandler+0x96>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4a6a:	90 91 e8 00 	lds	r25, 0x00E8
    4a6e:	9e 77       	andi	r25, 0x7E	; 126
    4a70:	90 93 e8 00 	sts	0x00E8, r25
	{
		/* Clear the endpoint bank to send its contents to the host */
		Endpoint_ClearIN();
		
		/* Wait until the endpoint is ready for more data */
		if (Endpoint_WaitUntilReady())
    4a74:	0e 94 1a 34 	call	0x6834	; 0x6834 <Endpoint_WaitUntilReady>
    4a78:	88 23       	and	r24, r24
    4a7a:	11 f2       	breq	.-124    	; 0x4a00 <SDCardManager_ReadBlockHandler+0x1a>
	Endpoint_Write_8(buffer[13+offset]);
	Endpoint_Write_8(buffer[14+offset]);
	Endpoint_Write_8(buffer[15+offset]);
	
	return 16;
}
    4a7c:	81 2f       	mov	r24, r17
    4a7e:	df 91       	pop	r29
    4a80:	cf 91       	pop	r28
    4a82:	1f 91       	pop	r17
    4a84:	ff 90       	pop	r15
    4a86:	ef 90       	pop	r14
    4a88:	08 95       	ret

00004a8a <SDCardManager_ReadBlocks>:
 *
 *  \param[in] BlockAddress  Data block starting address for the read sequence
 *  \param[in] TotalBlocks   Number of blocks of data to read
 */
void SDCardManager_ReadBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo, uint32_t BlockAddress, uint16_t TotalBlocks)
{
    4a8a:	8f 92       	push	r8
    4a8c:	9f 92       	push	r9
    4a8e:	af 92       	push	r10
    4a90:	bf 92       	push	r11
    4a92:	cf 92       	push	r12
    4a94:	df 92       	push	r13
    4a96:	ef 92       	push	r14
    4a98:	ff 92       	push	r15
    4a9a:	0f 93       	push	r16
    4a9c:	1f 93       	push	r17
    4a9e:	cf 93       	push	r28
    4aa0:	df 93       	push	r29
    4aa2:	6c 01       	movw	r12, r24
    4aa4:	4a 01       	movw	r8, r20
    4aa6:	5b 01       	movw	r10, r22
    4aa8:	79 01       	movw	r14, r18
	uint16_t BytesRead;
	
	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
    4aaa:	0e 94 1a 34 	call	0x6834	; 0x6834 <Endpoint_WaitUntilReady>
    4aae:	81 11       	cpse	r24, r1
    4ab0:	38 c0       	rjmp	.+112    	; 0x4b22 <SDCardManager_ReadBlocks+0x98>
	  return;
	
	while (TotalBlocks)
    4ab2:	e1 14       	cp	r14, r1
    4ab4:	f1 04       	cpc	r15, r1
    4ab6:	59 f1       	breq	.+86     	; 0x4b0e <SDCardManager_ReadBlocks+0x84>
	{		
		set_low(RED_LED); //red LED indicates busy status
    4ab8:	2e 98       	cbi	0x05, 6	; 5
		//Reset tally of BytesRead every time a new block is accessed.  
		BytesRead = 0;
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)
    4aba:	01 e0       	ldi	r16, 0x01	; 1
    4abc:	10 e0       	ldi	r17, 0x00	; 0
    4abe:	a5 01       	movw	r20, r10
    4ac0:	94 01       	movw	r18, r8
    4ac2:	60 e7       	ldi	r22, 0x70	; 112
    4ac4:	77 e0       	ldi	r23, 0x07	; 7
    4ac6:	80 e0       	ldi	r24, 0x00	; 0
    4ac8:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <disk_read>
	
	while (TotalBlocks)
	{		
		set_low(RED_LED); //red LED indicates busy status
		//Reset tally of BytesRead every time a new block is accessed.  
		BytesRead = 0;
    4acc:	c0 e0       	ldi	r28, 0x00	; 0
    4ace:	d0 e0       	ldi	r29, 0x00	; 0
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)

		while(BytesRead<512){  //send the results to the usb endpoint buffer, 16 bytes at a time.
			BytesRead += SDCardManager_ReadBlockHandler((uint8_t*)SD_Buffer, BytesRead); // BytesRead increases 16 every time handler is called, if all goes well.
    4ad0:	be 01       	movw	r22, r28
    4ad2:	80 e7       	ldi	r24, 0x70	; 112
    4ad4:	97 e0       	ldi	r25, 0x07	; 7
    4ad6:	87 df       	rcall	.-242    	; 0x49e6 <SDCardManager_ReadBlockHandler>
    4ad8:	c8 0f       	add	r28, r24
    4ada:	d1 1d       	adc	r29, r1
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
    4adc:	f6 01       	movw	r30, r12
    4ade:	80 ad       	ldd	r24, Z+56	; 0x38
    4ae0:	81 11       	cpse	r24, r1
    4ae2:	1f c0       	rjmp	.+62     	; 0x4b22 <SDCardManager_ReadBlocks+0x98>
			if (USB_DeviceState != DEVICE_STATE_Configured){Typewriter_Mode = PANIC_MODE; return;}
    4ae4:	80 91 b4 09 	lds	r24, 0x09B4
    4ae8:	84 30       	cpi	r24, 0x04	; 4
    4aea:	21 f0       	breq	.+8      	; 0x4af4 <SDCardManager_ReadBlocks+0x6a>
    4aec:	8a e0       	ldi	r24, 0x0A	; 10
    4aee:	80 93 6f 07 	sts	0x076F, r24
    4af2:	17 c0       	rjmp	.+46     	; 0x4b22 <SDCardManager_ReadBlocks+0x98>
		BytesRead = 0;
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)

		while(BytesRead<512){  //send the results to the usb endpoint buffer, 16 bytes at a time.
    4af4:	c1 15       	cp	r28, r1
    4af6:	f2 e0       	ldi	r31, 0x02	; 2
    4af8:	df 07       	cpc	r29, r31
    4afa:	50 f3       	brcs	.-44     	; 0x4ad0 <SDCardManager_ReadBlocks+0x46>
			BytesRead += SDCardManager_ReadBlockHandler((uint8_t*)SD_Buffer, BytesRead); // BytesRead increases 16 every time handler is called, if all goes well.
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
			if (USB_DeviceState != DEVICE_STATE_Configured){Typewriter_Mode = PANIC_MODE; return;}
		}
		/* Decrement the blocks remaining counter */
		BlockAddress++;
    4afc:	8f ef       	ldi	r24, 0xFF	; 255
    4afe:	88 1a       	sub	r8, r24
    4b00:	98 0a       	sbc	r9, r24
    4b02:	a8 0a       	sbc	r10, r24
    4b04:	b8 0a       	sbc	r11, r24
		TotalBlocks--;
    4b06:	e1 e0       	ldi	r30, 0x01	; 1
    4b08:	ee 1a       	sub	r14, r30
    4b0a:	f1 08       	sbc	r15, r1
    4b0c:	d2 cf       	rjmp	.-92     	; 0x4ab2 <SDCardManager_ReadBlocks+0x28>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4b0e:	80 91 e8 00 	lds	r24, 0x00E8
	}
	
	/* If the endpoint is full, send its contents to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    4b12:	85 fd       	sbrc	r24, 5
    4b14:	05 c0       	rjmp	.+10     	; 0x4b20 <SDCardManager_ReadBlocks+0x96>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4b16:	80 91 e8 00 	lds	r24, 0x00E8
    4b1a:	8e 77       	andi	r24, 0x7E	; 126
    4b1c:	80 93 e8 00 	sts	0x00E8, r24
	  Endpoint_ClearIN();
	 
	 set_high(RED_LED);
    4b20:	2e 9a       	sbi	0x05, 6	; 5
}
    4b22:	df 91       	pop	r29
    4b24:	cf 91       	pop	r28
    4b26:	1f 91       	pop	r17
    4b28:	0f 91       	pop	r16
    4b2a:	ff 90       	pop	r15
    4b2c:	ef 90       	pop	r14
    4b2e:	df 90       	pop	r13
    4b30:	cf 90       	pop	r12
    4b32:	bf 90       	pop	r11
    4b34:	af 90       	pop	r10
    4b36:	9f 90       	pop	r9
    4b38:	8f 90       	pop	r8
    4b3a:	08 95       	ret

00004b3c <SDCardManager_CheckSDCardOperation>:
 *  \return Boolean true if all media chips are working, false otherwise
 */
bool SDCardManager_CheckSDCardOperation(void)
{	
	return SDCard_Present; //return whether or not sd card is present and working.
}
    4b3c:	80 91 5c 05 	lds	r24, 0x055C
    4b40:	08 95       	ret

00004b42 <__vector_25>:
ISR (UART0_RECEIVE_INTERRUPT)	
/*************************************************************************
Function: UART Receive Complete interrupt
Purpose:  called when the UART has received a character
**************************************************************************/
{
    4b42:	1f 92       	push	r1
    4b44:	0f 92       	push	r0
    4b46:	0f b6       	in	r0, 0x3f	; 63
    4b48:	0f 92       	push	r0
    4b4a:	11 24       	eor	r1, r1
    4b4c:	2f 93       	push	r18
    4b4e:	8f 93       	push	r24
    4b50:	9f 93       	push	r25
    4b52:	ef 93       	push	r30
    4b54:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART0_STATUS;
    4b56:	80 91 c8 00 	lds	r24, 0x00C8
    data = UART0_DATA;
    4b5a:	90 91 ce 00 	lds	r25, 0x00CE
    
    /* */
#if defined( AT90_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
    4b5e:	88 71       	andi	r24, 0x18	; 24
#elif defined( AT90USB_USART )
    lastRxError = (usr & (_BV(FE1)|_BV(DOR1)) );
#endif
        
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    4b60:	e0 91 5f 05 	lds	r30, 0x055F
    4b64:	ef 5f       	subi	r30, 0xFF	; 255
    4b66:	ef 73       	andi	r30, 0x3F	; 63
    
    if ( tmphead == UART_RxTail ) {
    4b68:	20 91 5e 05 	lds	r18, 0x055E
    4b6c:	e2 17       	cp	r30, r18
    4b6e:	39 f0       	breq	.+14     	; 0x4b7e <__vector_25+0x3c>
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART_RxHead = tmphead;
    4b70:	e0 93 5f 05 	sts	0x055F, r30
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    4b74:	f0 e0       	ldi	r31, 0x00	; 0
    4b76:	ee 59       	subi	r30, 0x9E	; 158
    4b78:	fa 4f       	sbci	r31, 0xFA	; 250
    4b7a:	90 83       	st	Z, r25
    4b7c:	01 c0       	rjmp	.+2      	; 0x4b80 <__vector_25+0x3e>
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    
    if ( tmphead == UART_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    4b7e:	82 e0       	ldi	r24, 0x02	; 2
        /* store new index */
        UART_RxHead = tmphead;
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    }
    UART_LastRxError |= lastRxError;   
    4b80:	90 91 5d 05 	lds	r25, 0x055D
    4b84:	89 2b       	or	r24, r25
    4b86:	80 93 5d 05 	sts	0x055D, r24
}
    4b8a:	ff 91       	pop	r31
    4b8c:	ef 91       	pop	r30
    4b8e:	9f 91       	pop	r25
    4b90:	8f 91       	pop	r24
    4b92:	2f 91       	pop	r18
    4b94:	0f 90       	pop	r0
    4b96:	0f be       	out	0x3f, r0	; 63
    4b98:	0f 90       	pop	r0
    4b9a:	1f 90       	pop	r1
    4b9c:	18 95       	reti

00004b9e <__vector_26>:
ISR (UART0_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/
{
    4b9e:	1f 92       	push	r1
    4ba0:	0f 92       	push	r0
    4ba2:	0f b6       	in	r0, 0x3f	; 63
    4ba4:	0f 92       	push	r0
    4ba6:	11 24       	eor	r1, r1
    4ba8:	8f 93       	push	r24
    4baa:	9f 93       	push	r25
    4bac:	ef 93       	push	r30
    4bae:	ff 93       	push	r31
    unsigned char tmptail;
    
    if ( UART_TxHead != UART_TxTail) {
    4bb0:	90 91 61 05 	lds	r25, 0x0561
    4bb4:	80 91 60 05 	lds	r24, 0x0560
    4bb8:	98 17       	cp	r25, r24
    4bba:	69 f0       	breq	.+26     	; 0x4bd6 <__vector_26+0x38>
        /* calculate and store new buffer index */
        tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
    4bbc:	e0 91 60 05 	lds	r30, 0x0560
    4bc0:	ef 5f       	subi	r30, 0xFF	; 255
    4bc2:	ef 73       	andi	r30, 0x3F	; 63
        UART_TxTail = tmptail;
    4bc4:	e0 93 60 05 	sts	0x0560, r30
        /* get one byte from buffer and write it to UART */
        UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
    4bc8:	f0 e0       	ldi	r31, 0x00	; 0
    4bca:	ee 55       	subi	r30, 0x5E	; 94
    4bcc:	fa 4f       	sbci	r31, 0xFA	; 250
    4bce:	80 81       	ld	r24, Z
    4bd0:	80 93 ce 00 	sts	0x00CE, r24
    4bd4:	05 c0       	rjmp	.+10     	; 0x4be0 <__vector_26+0x42>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART0_CONTROL &= ~_BV(UART0_UDRIE);
    4bd6:	80 91 c9 00 	lds	r24, 0x00C9
    4bda:	8f 7d       	andi	r24, 0xDF	; 223
    4bdc:	80 93 c9 00 	sts	0x00C9, r24
    }
}
    4be0:	ff 91       	pop	r31
    4be2:	ef 91       	pop	r30
    4be4:	9f 91       	pop	r25
    4be6:	8f 91       	pop	r24
    4be8:	0f 90       	pop	r0
    4bea:	0f be       	out	0x3f, r0	; 63
    4bec:	0f 90       	pop	r0
    4bee:	1f 90       	pop	r1
    4bf0:	18 95       	reti

00004bf2 <uart_init>:
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart_init(unsigned int baudrate)
{
    UART_TxHead = 0;
    4bf2:	10 92 61 05 	sts	0x0561, r1
    UART_TxTail = 0;
    4bf6:	10 92 60 05 	sts	0x0560, r1
    UART_RxHead = 0;
    4bfa:	10 92 5f 05 	sts	0x055F, r1
    UART_RxTail = 0;
    4bfe:	10 92 5e 05 	sts	0x055E, r1
    /* enable UART receiver and transmmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);

#elif defined (ATMEGA_USART)
    /* Set baud rate */
    if ( baudrate & 0x8000 )
    4c02:	97 ff       	sbrs	r25, 7
    4c04:	04 c0       	rjmp	.+8      	; 0x4c0e <uart_init+0x1c>
    {
    	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
    4c06:	22 e0       	ldi	r18, 0x02	; 2
    4c08:	20 93 c8 00 	sts	0x00C8, r18
    	 baudrate &= ~0x8000;
    4c0c:	9f 77       	andi	r25, 0x7F	; 127
    }
    UBRRH = (unsigned char)(baudrate>>8);
    4c0e:	90 93 cd 00 	sts	0x00CD, r25
    UBRRL = (unsigned char) baudrate;
    4c12:	80 93 cc 00 	sts	0x00CC, r24
   
    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
    4c16:	88 e9       	ldi	r24, 0x98	; 152
    4c18:	80 93 c9 00 	sts	0x00C9, r24
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
    #ifdef URSEL
    UCSRC = (1<<URSEL)|(3<<UCSZ0);
    #else
    UCSRC = (3<<UCSZ0);
    4c1c:	86 e0       	ldi	r24, 0x06	; 6
    4c1e:	80 93 ca 00 	sts	0x00CA, r24
    4c22:	08 95       	ret

00004c24 <uart_getc>:
{    
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
    4c24:	90 91 5f 05 	lds	r25, 0x055F
    4c28:	80 91 5e 05 	lds	r24, 0x055E
    4c2c:	98 17       	cp	r25, r24
    4c2e:	81 f0       	breq	.+32     	; 0x4c50 <uart_getc+0x2c>
        return UART_NO_DATA;   /* no data available */
    }
    
    /* calculate /store buffer index */
    tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
    4c30:	e0 91 5e 05 	lds	r30, 0x055E
    4c34:	ef 5f       	subi	r30, 0xFF	; 255
    4c36:	ef 73       	andi	r30, 0x3F	; 63
    UART_RxTail = tmptail; 
    4c38:	e0 93 5e 05 	sts	0x055E, r30
    
    /* get data from receive buffer */
    data = UART_RxBuf[tmptail];
    4c3c:	f0 e0       	ldi	r31, 0x00	; 0
    4c3e:	ee 59       	subi	r30, 0x9E	; 158
    4c40:	fa 4f       	sbci	r31, 0xFA	; 250
    4c42:	80 81       	ld	r24, Z
    
    data = (UART_LastRxError << 8) + data;
    4c44:	90 91 5d 05 	lds	r25, 0x055D
    UART_LastRxError = 0;
    4c48:	10 92 5d 05 	sts	0x055D, r1
    return data;
    4c4c:	90 e0       	ldi	r25, 0x00	; 0
    4c4e:	08 95       	ret
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
        return UART_NO_DATA;   /* no data available */
    4c50:	80 e0       	ldi	r24, 0x00	; 0
    4c52:	91 e0       	ldi	r25, 0x01	; 1
    
    data = (UART_LastRxError << 8) + data;
    UART_LastRxError = 0;
    return data;

}/* uart_getc */
    4c54:	08 95       	ret

00004c56 <uart_clear_rx_buffer>:

void uart_clear_rx_buffer(){
//the head and tail define the buffer index of the first and last byte of the received data.  
//If they are equal to each other, no data has been received (buffer empty)
	UART_RxHead = 0;
    4c56:	10 92 5f 05 	sts	0x055F, r1
	UART_RxTail = 0; 
    4c5a:	10 92 5e 05 	sts	0x055E, r1
    4c5e:	08 95       	ret

00004c60 <uart_putc>:
**************************************************************************/
void uart_putc(unsigned char data)
{
    unsigned char tmphead;
    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
    4c60:	90 91 61 05 	lds	r25, 0x0561
    4c64:	9f 5f       	subi	r25, 0xFF	; 255
    4c66:	9f 73       	andi	r25, 0x3F	; 63
    
    while ( tmphead == UART_TxTail ){
    4c68:	20 91 60 05 	lds	r18, 0x0560
    4c6c:	92 17       	cp	r25, r18
    4c6e:	e1 f3       	breq	.-8      	; 0x4c68 <uart_putc+0x8>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
    4c70:	e9 2f       	mov	r30, r25
    4c72:	f0 e0       	ldi	r31, 0x00	; 0
    4c74:	ee 55       	subi	r30, 0x5E	; 94
    4c76:	fa 4f       	sbci	r31, 0xFA	; 250
    4c78:	80 83       	st	Z, r24
    UART_TxHead = tmphead;
    4c7a:	90 93 61 05 	sts	0x0561, r25

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
    4c7e:	80 91 c9 00 	lds	r24, 0x00C9
    4c82:	80 62       	ori	r24, 0x20	; 32
    4c84:	80 93 c9 00 	sts	0x00C9, r24
    4c88:	08 95       	ret

00004c8a <__vector_17>:
		return false;
	}
	else{
		return true;
	}
}
    4c8a:	1f 92       	push	r1
    4c8c:	0f 92       	push	r0
    4c8e:	0f b6       	in	r0, 0x3f	; 63
    4c90:	0f 92       	push	r0
    4c92:	11 24       	eor	r1, r1
    4c94:	2f 93       	push	r18
    4c96:	3f 93       	push	r19
    4c98:	4f 93       	push	r20
    4c9a:	5f 93       	push	r21
    4c9c:	6f 93       	push	r22
    4c9e:	7f 93       	push	r23
    4ca0:	8f 93       	push	r24
    4ca2:	9f 93       	push	r25
    4ca4:	af 93       	push	r26
    4ca6:	bf 93       	push	r27
    4ca8:	ef 93       	push	r30
    4caa:	ff 93       	push	r31
    4cac:	80 91 65 06 	lds	r24, 0x0665
    4cb0:	90 91 66 06 	lds	r25, 0x0666
    4cb4:	01 96       	adiw	r24, 0x01	; 1
    4cb6:	90 93 66 06 	sts	0x0666, r25
    4cba:	80 93 65 06 	sts	0x0665, r24
    4cbe:	80 91 67 06 	lds	r24, 0x0667
    4cc2:	90 91 68 06 	lds	r25, 0x0668
    4cc6:	01 96       	adiw	r24, 0x01	; 1
    4cc8:	90 93 68 06 	sts	0x0668, r25
    4ccc:	80 93 67 06 	sts	0x0667, r24
    4cd0:	80 91 6f 07 	lds	r24, 0x076F
    4cd4:	81 30       	cpi	r24, 0x01	; 1
    4cd6:	79 f0       	breq	.+30     	; 0x4cf6 <__vector_17+0x6c>
    4cd8:	80 91 6f 07 	lds	r24, 0x076F
    4cdc:	8d 30       	cpi	r24, 0x0D	; 13
    4cde:	59 f0       	breq	.+22     	; 0x4cf6 <__vector_17+0x6c>
    4ce0:	80 e3       	ldi	r24, 0x30	; 48
    4ce2:	91 e0       	ldi	r25, 0x01	; 1
    4ce4:	0e 94 3e 30 	call	0x607c	; 0x607c <MS_Device_USBTask>
    4ce8:	80 e2       	ldi	r24, 0x20	; 32
    4cea:	91 e0       	ldi	r25, 0x01	; 1
    4cec:	0e 94 1a 2f 	call	0x5e34	; 0x5e34 <HID_Device_USBTask>
    4cf0:	0e 94 df 36 	call	0x6dbe	; 0x6dbe <USB_USBTask>
    4cf4:	03 c0       	rjmp	.+6      	; 0x4cfc <__vector_17+0x72>
    4cf6:	81 e0       	ldi	r24, 0x01	; 1
    4cf8:	80 93 1f 06 	sts	0x061F, r24
    4cfc:	ff 91       	pop	r31
    4cfe:	ef 91       	pop	r30
    4d00:	bf 91       	pop	r27
    4d02:	af 91       	pop	r26
    4d04:	9f 91       	pop	r25
    4d06:	8f 91       	pop	r24
    4d08:	7f 91       	pop	r23
    4d0a:	6f 91       	pop	r22
    4d0c:	5f 91       	pop	r21
    4d0e:	4f 91       	pop	r20
    4d10:	3f 91       	pop	r19
    4d12:	2f 91       	pop	r18
    4d14:	0f 90       	pop	r0
    4d16:	0f be       	out	0x3f, r0	; 63
    4d18:	0f 90       	pop	r0
    4d1a:	1f 90       	pop	r1
    4d1c:	18 95       	reti

00004d1e <Task_Manager>:
    4d1e:	80 91 1f 06 	lds	r24, 0x061F
    4d22:	81 30       	cpi	r24, 0x01	; 1
    4d24:	29 f4       	brne	.+10     	; 0x4d30 <Task_Manager+0x12>
    4d26:	80 e3       	ldi	r24, 0x30	; 48
    4d28:	91 e0       	ldi	r25, 0x01	; 1
    4d2a:	0e 94 3e 30 	call	0x607c	; 0x607c <MS_Device_USBTask>
    4d2e:	04 c0       	rjmp	.+8      	; 0x4d38 <Task_Manager+0x1a>
    4d30:	80 91 1f 06 	lds	r24, 0x061F
    4d34:	83 30       	cpi	r24, 0x03	; 3
    4d36:	29 f4       	brne	.+10     	; 0x4d42 <Task_Manager+0x24>
    4d38:	80 e2       	ldi	r24, 0x20	; 32
    4d3a:	91 e0       	ldi	r25, 0x01	; 1
    4d3c:	0e 94 1a 2f 	call	0x5e34	; 0x5e34 <HID_Device_USBTask>
    4d40:	08 c0       	rjmp	.+16     	; 0x4d52 <Task_Manager+0x34>
    4d42:	80 91 1f 06 	lds	r24, 0x061F
    4d46:	82 30       	cpi	r24, 0x02	; 2
    4d48:	31 f4       	brne	.+12     	; 0x4d56 <Task_Manager+0x38>
    4d4a:	80 e3       	ldi	r24, 0x30	; 48
    4d4c:	91 e0       	ldi	r25, 0x01	; 1
    4d4e:	0e 94 3e 30 	call	0x607c	; 0x607c <MS_Device_USBTask>
    4d52:	0e 94 df 36 	call	0x6dbe	; 0x6dbe <USB_USBTask>
    4d56:	10 92 1f 06 	sts	0x061F, r1
    4d5a:	08 95       	ret

00004d5c <SetupHardware>:
/** Configures the board hardware and chip peripherals for functionality. */
void SetupHardware()
{

	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
    4d5c:	84 b7       	in	r24, 0x34	; 52
    4d5e:	87 7f       	andi	r24, 0xF7	; 247
    4d60:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    4d62:	0f b6       	in	r0, 0x3f	; 63
    4d64:	f8 94       	cli
    4d66:	a8 95       	wdr
    4d68:	80 91 60 00 	lds	r24, 0x0060
    4d6c:	88 61       	ori	r24, 0x18	; 24
    4d6e:	80 93 60 00 	sts	0x0060, r24
    4d72:	10 92 60 00 	sts	0x0060, r1
    4d76:	0f be       	out	0x3f, r0	; 63
	wdt_disable();
	
	/* Disable JTAG on PortF -- enables Port F pins to function normally.  Datasheet requires this pin to be written repeatedly in order for it to work. 
	("The application software must write this bit to the desired value twice within four cycles to change its value."*/
	MCUCR |= (1 << JTD); 
    4d78:	85 b7       	in	r24, 0x35	; 53
    4d7a:	80 68       	ori	r24, 0x80	; 128
    4d7c:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4d7e:	85 b7       	in	r24, 0x35	; 53
    4d80:	80 68       	ori	r24, 0x80	; 128
    4d82:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4d84:	85 b7       	in	r24, 0x35	; 53
    4d86:	80 68       	ori	r24, 0x80	; 128
    4d88:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4d8a:	85 b7       	in	r24, 0x35	; 53
    4d8c:	80 68       	ori	r24, 0x80	; 128
    4d8e:	85 bf       	out	0x35, r24	; 53
from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
    4d90:	90 e0       	ldi	r25, 0x00	; 0
    4d92:	80 e8       	ldi	r24, 0x80	; 128
    4d94:	0f b6       	in	r0, 0x3f	; 63
    4d96:	f8 94       	cli
    4d98:	80 93 61 00 	sts	0x0061, r24
    4d9c:	90 93 61 00 	sts	0x0061, r25
    4da0:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
	Config_Interrupts();
    4da2:	0e 94 6e 0c 	call	0x18dc	; 0x18dc <Config_Interrupts>
	
	/* Hardware Initialization */
	Config_IO();
    4da6:	0e 94 82 0c 	call	0x1904	; 0x1904 <Config_IO>
    4daa:	2f e7       	ldi	r18, 0x7F	; 127
    4dac:	88 e3       	ldi	r24, 0x38	; 56
    4dae:	91 e0       	ldi	r25, 0x01	; 1
    4db0:	21 50       	subi	r18, 0x01	; 1
    4db2:	80 40       	sbci	r24, 0x00	; 0
    4db4:	90 40       	sbci	r25, 0x00	; 0
    4db6:	e1 f7       	brne	.-8      	; 0x4db0 <SetupHardware+0x54>
    4db8:	00 c0       	rjmp	.+0      	; 0x4dba <SetupHardware+0x5e>
    4dba:	00 00       	nop
	Delay_MS(50); //DELAY 50ms after setting IO.
	
	Reed1Polarity = eeprom_read_byte((uint8_t *)REED_1_POLARITY_ADDR);
    4dbc:	86 e0       	ldi	r24, 0x06	; 6
    4dbe:	92 e0       	ldi	r25, 0x02	; 2
    4dc0:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    4dc4:	91 e0       	ldi	r25, 0x01	; 1
    4dc6:	81 11       	cpse	r24, r1
    4dc8:	01 c0       	rjmp	.+2      	; 0x4dcc <SetupHardware+0x70>
    4dca:	90 e0       	ldi	r25, 0x00	; 0
    4dcc:	90 93 6e 06 	sts	0x066E, r25
	Reed2Polarity= eeprom_read_byte((uint8_t *)REED_2_POLARITY_ADDR);
    4dd0:	87 e0       	ldi	r24, 0x07	; 7
    4dd2:	92 e0       	ldi	r25, 0x02	; 2
    4dd4:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    4dd8:	91 e0       	ldi	r25, 0x01	; 1
    4dda:	81 11       	cpse	r24, r1
    4ddc:	01 c0       	rjmp	.+2      	; 0x4de0 <SetupHardware+0x84>
    4dde:	90 e0       	ldi	r25, 0x00	; 0
    4de0:	90 93 1c 06 	sts	0x061C, r25
	Reed3Polarity = eeprom_read_byte((uint8_t *)REED_3_POLARITY_ADDR);
    4de4:	88 e0       	ldi	r24, 0x08	; 8
    4de6:	92 e0       	ldi	r25, 0x02	; 2
    4de8:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    4dec:	91 e0       	ldi	r25, 0x01	; 1
    4dee:	81 11       	cpse	r24, r1
    4df0:	01 c0       	rjmp	.+2      	; 0x4df4 <SetupHardware+0x98>
    4df2:	90 e0       	ldi	r25, 0x00	; 0
    4df4:	90 93 f0 06 	sts	0x06F0, r25
	Reed4Polarity = eeprom_read_byte((uint8_t *)REED_4_POLARITY_ADDR);
    4df8:	89 e0       	ldi	r24, 0x09	; 9
    4dfa:	92 e0       	ldi	r25, 0x02	; 2
    4dfc:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    4e00:	91 e0       	ldi	r25, 0x01	; 1
    4e02:	81 11       	cpse	r24, r1
    4e04:	01 c0       	rjmp	.+2      	; 0x4e08 <SetupHardware+0xac>
    4e06:	90 e0       	ldi	r25, 0x00	; 0
    4e08:	90 93 2e 07 	sts	0x072E, r25
    4e0c:	08 95       	ret

00004e0e <EVENT_USB_Device_Connect>:
	
}

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
    4e0e:	08 95       	ret

00004e10 <EVENT_USB_Device_Disconnect>:
}

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	if(SDCardManager_CheckSDCardOperation()){ //if there is an SD Card present, flip into sd mode if the computer is shut off.
    4e10:	95 de       	rcall	.-726    	; 0x4b3c <SDCardManager_CheckSDCardOperation>
    4e12:	88 23       	and	r24, r24
    4e14:	19 f0       	breq	.+6      	; 0x4e1c <EVENT_USB_Device_Disconnect+0xc>
		Typewriter_Mode = SD_MODE;
    4e16:	82 e0       	ldi	r24, 0x02	; 2
    4e18:	80 93 6f 07 	sts	0x076F, r24
    4e1c:	08 95       	ret

00004e1e <EVENT_USB_Device_Suspend>:
	}

}

void EVENT_USB_Device_Suspend(void){
    4e1e:	08 95       	ret

00004e20 <EVENT_USB_Device_WakeUp>:
	
}

void EVENT_USB_Device_WakeUp(void){
    4e20:	08 95       	ret

00004e22 <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= HID_Device_ConfigureEndpoints(&Keyboard_HID_Interface);
    4e22:	80 e2       	ldi	r24, 0x20	; 32
    4e24:	91 e0       	ldi	r25, 0x01	; 1
    4e26:	f3 d7       	rcall	.+4070   	; 0x5e0e <HID_Device_ConfigureEndpoints>
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
    4e28:	80 e3       	ldi	r24, 0x30	; 48
    4e2a:	91 e0       	ldi	r25, 0x01	; 1
    4e2c:	0e 94 21 30 	call	0x6042	; 0x6042 <MS_Device_ConfigureEndpoints>
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
    4e30:	e2 ee       	ldi	r30, 0xE2	; 226
    4e32:	f0 e0       	ldi	r31, 0x00	; 0
    4e34:	80 81       	ld	r24, Z
    4e36:	84 60       	ori	r24, 0x04	; 4
    4e38:	80 83       	st	Z, r24
    4e3a:	08 95       	ret

00004e3c <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	MS_Device_ProcessControlRequest(&Disk_MS_Interface);
    4e3c:	80 e3       	ldi	r24, 0x30	; 48
    4e3e:	91 e0       	ldi	r25, 0x01	; 1
    4e40:	0e 94 e0 2f 	call	0x5fc0	; 0x5fc0 <MS_Device_ProcessControlRequest>
	HID_Device_ProcessControlRequest(&Keyboard_HID_Interface);
    4e44:	80 e2       	ldi	r24, 0x20	; 32
    4e46:	91 e0       	ldi	r25, 0x01	; 1
    4e48:	a8 c6       	rjmp	.+3408   	; 0x5b9a <HID_Device_ProcessControlRequest>

00004e4a <EVENT_USB_Device_StartOfFrame>:
			 *  \param[in,out] HIDInterfaceInfo  Pointer to a structure containing a HID Class configuration and state.
			 */
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo) ATTR_ALWAYS_INLINE ATTR_NON_NULL_PTR_ARG(1);
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
			{
				if (HIDInterfaceInfo->State.IdleMSRemaining)
    4e4a:	80 91 2e 01 	lds	r24, 0x012E
    4e4e:	90 91 2f 01 	lds	r25, 0x012F
    4e52:	00 97       	sbiw	r24, 0x00	; 0
    4e54:	29 f0       	breq	.+10     	; 0x4e60 <EVENT_USB_Device_StartOfFrame+0x16>
				  HIDInterfaceInfo->State.IdleMSRemaining--;
    4e56:	01 97       	sbiw	r24, 0x01	; 1
    4e58:	90 93 2f 01 	sts	0x012F, r25
    4e5c:	80 93 2e 01 	sts	0x012E, r24
    4e60:	08 95       	ret

00004e62 <CALLBACK_MS_Device_SCSICommandReceived>:
 */
bool CALLBACK_MS_Device_SCSICommandReceived(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	bool CommandSuccess;

	CommandSuccess = SCSI_DecodeSCSICommand(MSInterfaceInfo);
    4e62:	bf cb       	rjmp	.-2178   	; 0x45e2 <SCSI_DecodeSCSICommand>

00004e64 <CALLBACK_HID_Device_CreateHIDReport>:
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
                                         uint8_t* const ReportID,
                                         const uint8_t ReportType,
                                         void* ReportData,
                                         uint16_t* const ReportSize)
{
    4e64:	0f 93       	push	r16
    4e66:	1f 93       	push	r17
    4e68:	f9 01       	movw	r30, r18
	USB_KeyboardReport_Data_t* KeyboardReport = (USB_KeyboardReport_Data_t*)ReportData;

//	memcpy((void*)KeyboardReport->KeyCode, (void*)KeyBuffer->KeyCode, 6); //copy the keybuffer into the keyboard report being sent to host.
	KeyboardReport->KeyCode[0] = KeyBuffer->KeyCode[0];
    4e6a:	a0 91 6a 06 	lds	r26, 0x066A
    4e6e:	b0 91 6b 06 	lds	r27, 0x066B
    4e72:	12 96       	adiw	r26, 0x02	; 2
    4e74:	8c 91       	ld	r24, X
    4e76:	82 83       	std	Z+2, r24	; 0x02

	if (Hold_Alt_Down) { //this flag instructs us to hold alt down continuously, so that numpad ascii can be sent.
    4e78:	90 91 6d 06 	lds	r25, 0x066D
    4e7c:	99 23       	and	r25, r25
    4e7e:	11 f0       	breq	.+4      	; 0x4e84 <CALLBACK_HID_Device_CreateHIDReport+0x20>
		KeyboardReport->Modifier = HID_KEYBOARD_MODIFIER_LEFTALT;
    4e80:	84 e0       	ldi	r24, 0x04	; 4
    4e82:	04 c0       	rjmp	.+8      	; 0x4e8c <CALLBACK_HID_Device_CreateHIDReport+0x28>
	}
	else if (KeyboardReport->KeyCode[0]){ //if there is a key waiting to be sent, then use the modifier that goes with that key.
    4e84:	88 23       	and	r24, r24
    4e86:	21 f0       	breq	.+8      	; 0x4e90 <CALLBACK_HID_Device_CreateHIDReport+0x2c>
		KeyboardReport->Modifier = KeyBufferMod;
    4e88:	80 91 21 06 	lds	r24, 0x0621
    4e8c:	80 83       	st	Z, r24
    4e8e:	01 c0       	rjmp	.+2      	; 0x4e92 <CALLBACK_HID_Device_CreateHIDReport+0x2e>
	}
	else{
		KeyboardReport->Modifier = 0; //otherwise, clear the modifiers so the host doesn't think we are holding down shift or alt or whatever for no reason.
    4e90:	10 82       	st	Z, r1
	}
	
//	memset((void*)KeyBuffer->KeyCode,0,6);  //clear keybuffer to clear room for the next key.  This indicates to other routines that the USB buffer is available for sending.
	KeyBuffer->KeyCode[0] = 0;
    4e92:	e0 91 6a 06 	lds	r30, 0x066A
    4e96:	f0 91 6b 06 	lds	r31, 0x066B
    4e9a:	12 82       	std	Z+2, r1	; 0x02
	KeyBufferMod= 0;
    4e9c:	10 92 21 06 	sts	0x0621, r1

	*ReportSize = sizeof(USB_KeyboardReport_Data_t);
    4ea0:	88 e0       	ldi	r24, 0x08	; 8
    4ea2:	90 e0       	ldi	r25, 0x00	; 0
    4ea4:	f8 01       	movw	r30, r16
    4ea6:	91 83       	std	Z+1, r25	; 0x01
    4ea8:	80 83       	st	Z, r24
	return false;
}
    4eaa:	80 e0       	ldi	r24, 0x00	; 0
    4eac:	1f 91       	pop	r17
    4eae:	0f 91       	pop	r16
    4eb0:	08 95       	ret

00004eb2 <CALLBACK_HID_Device_ProcessHIDReport>:
{
	uint8_t* LEDReport = (uint8_t*)ReportData;
	static bool NumLockActivated;
	static bool CapsLockDeactivated;

		if (!(*LEDReport & HID_KEYBOARD_LED_NUMLOCK) && !(NumLockActivated)){ //if numlock is somehow inactive, and numlock not already deactivated by code,
    4eb2:	f9 01       	movw	r30, r18
    4eb4:	80 81       	ld	r24, Z
    4eb6:	80 fd       	sbrc	r24, 0
    4eb8:	0e c0       	rjmp	.+28     	; 0x4ed6 <CALLBACK_HID_Device_ProcessHIDReport+0x24>
    4eba:	90 91 e3 05 	lds	r25, 0x05E3
    4ebe:	91 11       	cpse	r25, r1
    4ec0:	0a c0       	rjmp	.+20     	; 0x4ed6 <CALLBACK_HID_Device_ProcessHIDReport+0x24>
		  KeyBuffer->KeyCode[0] = HID_KEYBOARD_SC_NUM_LOCK; //press numlock key to activate it.  -- NumLockDeactivated flag makes sure this only happens once per session.
    4ec2:	e0 91 6a 06 	lds	r30, 0x066A
    4ec6:	f0 91 6b 06 	lds	r31, 0x066B
    4eca:	83 e5       	ldi	r24, 0x53	; 83
    4ecc:	82 83       	std	Z+2, r24	; 0x02
		  NumLockActivated = true;//only activate numlock once per session -- that way user can override
    4ece:	81 e0       	ldi	r24, 0x01	; 1
    4ed0:	80 93 e3 05 	sts	0x05E3, r24
    4ed4:	08 95       	ret
		}

		else if ((*LEDReport & HID_KEYBOARD_LED_CAPSLOCK) && !(CapsLockDeactivated)){ //if capslock is somehow active,
    4ed6:	81 ff       	sbrs	r24, 1
    4ed8:	0d c0       	rjmp	.+26     	; 0x4ef4 <CALLBACK_HID_Device_ProcessHIDReport+0x42>
    4eda:	80 91 e2 05 	lds	r24, 0x05E2
    4ede:	81 11       	cpse	r24, r1
    4ee0:	09 c0       	rjmp	.+18     	; 0x4ef4 <CALLBACK_HID_Device_ProcessHIDReport+0x42>
		 KeyBuffer ->KeyCode[0] = HID_KEYBOARD_SC_CAPS_LOCK; //press capslock key to deactivate it.
    4ee2:	e0 91 6a 06 	lds	r30, 0x066A
    4ee6:	f0 91 6b 06 	lds	r31, 0x066B
    4eea:	89 e3       	ldi	r24, 0x39	; 57
    4eec:	82 83       	std	Z+2, r24	; 0x02
		 CapsLockDeactivated = true; //only deactivate caps lock once per session -- that way user can override
    4eee:	81 e0       	ldi	r24, 0x01	; 1
    4ef0:	80 93 e2 05 	sts	0x05E2, r24
    4ef4:	08 95       	ret

00004ef6 <Init_Mode>:
	//	  KeyBuffer ->KeyCode[0] = HID_KEYBOARD_SC_SCROLL_LOCK; //press scrolllock key to deactivate it.
	
}


void Init_Mode(){
    4ef6:	cf 93       	push	r28
	uint8_t key;
	uint8_t code;
	uint8_t Default_Mode;
	
	Default_Mode = eeprom_read_byte((uint8_t*)DEFAULT_MODE_ADDR);
    4ef8:	8d e0       	ldi	r24, 0x0D	; 13
    4efa:	92 e0       	ldi	r25, 0x02	; 2
    4efc:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    4f00:	c8 2f       	mov	r28, r24

	key = GetKeySimple(); //read the key that is being held during startup (if any)
    4f02:	d3 d3       	rcall	.+1958   	; 0x56aa <GetKeySimple>
	code = GetASCIIKeyCode(key,UPPER);
    4f04:	62 e0       	ldi	r22, 0x02	; 2
    4f06:	55 d5       	rcall	.+2730   	; 0x59b2 <GetASCIIKeyCode>
	
	if (is_low(S1)&&is_low(S2)&&is_low(S3)){ //reset device to known state
    4f08:	7c 99       	sbic	0x0f, 4	; 15
    4f0a:	0c c0       	rjmp	.+24     	; 0x4f24 <Init_Mode+0x2e>
    4f0c:	7d 99       	sbic	0x0f, 5	; 15
    4f0e:	0a c0       	rjmp	.+20     	; 0x4f24 <Init_Mode+0x2e>
    4f10:	7e 99       	sbic	0x0f, 6	; 15
    4f12:	08 c0       	rjmp	.+16     	; 0x4f24 <Init_Mode+0x2e>
			Typewriter_Mode = USB_COMBO_MODE;
    4f14:	81 e0       	ldi	r24, 0x01	; 1
    4f16:	80 93 6f 07 	sts	0x076F, r24
			Default_Mode = USB_COMBO_MODE;
			GlowGreenLED(SLOW,GLOWING);
    4f1a:	60 e0       	ldi	r22, 0x00	; 0
    4f1c:	0e 94 b2 0c 	call	0x1964	; 0x1964 <GlowGreenLED>
			RestoreFactoryDefaults();			
    4f20:	e9 d5       	rcall	.+3026   	; 0x5af4 <RestoreFactoryDefaults>
    4f22:	1f c0       	rjmp	.+62     	; 0x4f62 <Init_Mode+0x6c>
	}
	else if(is_low(S2)&&is_low(S3)){ //configure bluetooth and test bluetooth -- reset bluetooth module  -- force initialization next time bluetooth is used.
    4f24:	7d 99       	sbic	0x0f, 5	; 15
    4f26:	10 c0       	rjmp	.+32     	; 0x4f48 <Init_Mode+0x52>
    4f28:	7e 99       	sbic	0x0f, 6	; 15
    4f2a:	0e c0       	rjmp	.+28     	; 0x4f48 <Init_Mode+0x52>
			if(Bluetooth_Configure()){
    4f2c:	0e 94 9f 04 	call	0x93e	; 0x93e <Bluetooth_Configure>
    4f30:	88 23       	and	r24, r24
    4f32:	31 f0       	breq	.+12     	; 0x4f40 <Init_Mode+0x4a>
					#ifndef BT_DEBUG
						USB_Disable(); //leave usb active if this is debug mode.
    4f34:	0e 94 4c 34 	call	0x6898	; 0x6898 <USB_Disable>
					#endif
					
					#if MODULE_NAME==EHONG //ehong module requires you to manually clear the pairing list to enter inquiry mode
					BluetoothInquire();//clear paired device list and try to pair.
    4f38:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <BluetoothInquire>
					#endif
					
					Typewriter_Mode = BLUETOOTH_MODE;
    4f3c:	89 e0       	ldi	r24, 0x09	; 9
    4f3e:	01 c0       	rjmp	.+2      	; 0x4f42 <Init_Mode+0x4c>
					//Default_Mode = BLUETOOTH_MODE;  //Do not set bluetooth mode as the default, since this mode only TESTS the bluetooth
			}
			else{ //if something goes wrong during configuration...
					Typewriter_Mode = PANIC_MODE; //don't change default mode
    4f40:	8a e0       	ldi	r24, 0x0A	; 10
    4f42:	80 93 6f 07 	sts	0x076F, r24
    4f46:	4d c0       	rjmp	.+154    	; 0x4fe2 <Init_Mode+0xec>
			}
	}
	else if(is_low(S1)&&is_low(S2)){
    4f48:	7c 99       	sbic	0x0f, 4	; 15
    4f4a:	04 c0       	rjmp	.+8      	; 0x4f54 <Init_Mode+0x5e>
    4f4c:	7d 99       	sbic	0x0f, 5	; 15
    4f4e:	02 c0       	rjmp	.+4      	; 0x4f54 <Init_Mode+0x5e>
			Typewriter_Mode = MANUAL_CAL_MODE;
    4f50:	8e e0       	ldi	r24, 0x0E	; 14
    4f52:	05 c0       	rjmp	.+10     	; 0x4f5e <Init_Mode+0x68>
			Default_Mode = USB_COMBO_MODE;
	}
	else if(is_low(S1)&&is_low(S3)){//quick calibration mode
    4f54:	7c 99       	sbic	0x0f, 4	; 15
    4f56:	07 c0       	rjmp	.+14     	; 0x4f66 <Init_Mode+0x70>
    4f58:	7e 99       	sbic	0x0f, 6	; 15
    4f5a:	05 c0       	rjmp	.+10     	; 0x4f66 <Init_Mode+0x70>
			Typewriter_Mode = QUICK_CAL_MODE;
    4f5c:	86 e0       	ldi	r24, 0x06	; 6
    4f5e:	80 93 6f 07 	sts	0x076F, r24
			Default_Mode = USB_COMBO_MODE;
    4f62:	c1 e0       	ldi	r28, 0x01	; 1
    4f64:	3e c0       	rjmp	.+124    	; 0x4fe2 <Init_Mode+0xec>
	}
	else if (is_low(S1)){ //hold down S1 during initialization to calibrate
    4f66:	7c 99       	sbic	0x0f, 4	; 15
    4f68:	02 c0       	rjmp	.+4      	; 0x4f6e <Init_Mode+0x78>
			Typewriter_Mode = CAL_MODE;
    4f6a:	85 e0       	ldi	r24, 0x05	; 5
    4f6c:	f8 cf       	rjmp	.-16     	; 0x4f5e <Init_Mode+0x68>
			Default_Mode = USB_COMBO_MODE;
	}
	else if(is_low(S2)){
    4f6e:	7d 99       	sbic	0x0f, 5	; 15
    4f70:	02 c0       	rjmp	.+4      	; 0x4f76 <Init_Mode+0x80>
		Typewriter_Mode = SENSITIVITY_MODE;
    4f72:	83 e0       	ldi	r24, 0x03	; 3
    4f74:	e6 cf       	rjmp	.-52     	; 0x4f42 <Init_Mode+0x4c>
	}
	else if (is_low(S3)){ //hold down S3 to enter LED indication mode to test reed switches.
    4f76:	7e 99       	sbic	0x0f, 6	; 15
    4f78:	02 c0       	rjmp	.+4      	; 0x4f7e <Init_Mode+0x88>
		Typewriter_Mode = TEST_MODE;
    4f7a:	84 e0       	ldi	r24, 0x04	; 4
    4f7c:	e2 cf       	rjmp	.-60     	; 0x4f42 <Init_Mode+0x4c>
	}
	else if(code == 'U'){ //if the letter U is being held by user
    4f7e:	85 35       	cpi	r24, 0x55	; 85
    4f80:	31 f4       	brne	.+12     	; 0x4f8e <Init_Mode+0x98>
		Typewriter_Mode = USB_COMBO_MODE;
    4f82:	81 e0       	ldi	r24, 0x01	; 1
    4f84:	80 93 6f 07 	sts	0x076F, r24
		Default_Mode = USB_COMBO_MODE;	
		Ignore_Flag = 1; //tell sensor routine to ignore this U.
    4f88:	80 93 69 06 	sts	0x0669, r24
    4f8c:	ea cf       	rjmp	.-44     	; 0x4f62 <Init_Mode+0x6c>
	}
	else if(code == 'S'){//if the letter S is being held by the user
    4f8e:	83 35       	cpi	r24, 0x53	; 83
    4f90:	79 f4       	brne	.+30     	; 0x4fb0 <Init_Mode+0xba>
		if(SDCardManager_CheckSDCardOperation()){ //if an sd card is present and working, put typewriter into sd mode
    4f92:	d4 dd       	rcall	.-1112   	; 0x4b3c <SDCardManager_CheckSDCardOperation>
    4f94:	88 23       	and	r24, r24
    4f96:	39 f0       	breq	.+14     	; 0x4fa6 <Init_Mode+0xb0>
			Typewriter_Mode = SD_MODE;
    4f98:	82 e0       	ldi	r24, 0x02	; 2
    4f9a:	80 93 6f 07 	sts	0x076F, r24
			Default_Mode = SD_MODE;
			Ignore_Flag = 1; //tell sensor routine to ignore this S.
    4f9e:	81 e0       	ldi	r24, 0x01	; 1
    4fa0:	80 93 69 06 	sts	0x0669, r24
    4fa4:	03 c0       	rjmp	.+6      	; 0x4fac <Init_Mode+0xb6>
		}
		else{
			Typewriter_Mode = PANIC_MODE; //otherwise, panic to indicate malfunction ... don't change default mode.
    4fa6:	8a e0       	ldi	r24, 0x0A	; 10
    4fa8:	80 93 6f 07 	sts	0x076F, r24
			Default_Mode = SD_MODE; //even so, sd mode next time you plug in.
    4fac:	c2 e0       	ldi	r28, 0x02	; 2
    4fae:	19 c0       	rjmp	.+50     	; 0x4fe2 <Init_Mode+0xec>
		}
	}
	else if(code == 'B'){ //if the letter B is being held by the user
    4fb0:	82 34       	cpi	r24, 0x42	; 66
    4fb2:	71 f4       	brne	.+28     	; 0x4fd0 <Init_Mode+0xda>
		#ifndef BT_DEBUG
			USB_Disable(); //if this is not debug mode, disable the usb port.
    4fb4:	0e 94 4c 34 	call	0x6898	; 0x6898 <USB_Disable>
		#endif
		if(Bluetooth_Configure()){ // attempt to configure. this erases rn42 paired device list, but not ehong's
    4fb8:	0e 94 9f 04 	call	0x93e	; 0x93e <Bluetooth_Configure>
    4fbc:	88 23       	and	r24, r24
    4fbe:	09 f4       	brne	.+2      	; 0x4fc2 <Init_Mode+0xcc>
    4fc0:	bf cf       	rjmp	.-130    	; 0x4f40 <Init_Mode+0x4a>
			#if MODULE_NAME==EHONG 
				BluetoothInquire(); //if configuration is successful, delete the paired device list so device can become discoverable.
    4fc2:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <BluetoothInquire>
			#endif
			
			Typewriter_Mode = BLUETOOTH_MODE;
    4fc6:	89 e0       	ldi	r24, 0x09	; 9
    4fc8:	80 93 6f 07 	sts	0x076F, r24
			Default_Mode = BLUETOOTH_MODE;
    4fcc:	c9 e0       	ldi	r28, 0x09	; 9
    4fce:	09 c0       	rjmp	.+18     	; 0x4fe2 <Init_Mode+0xec>
		}
		else{ //if something goes wrong during configuration...
			Typewriter_Mode = PANIC_MODE; //indicate error
		}
	}
	else if(code == 'L'){
    4fd0:	8c 34       	cpi	r24, 0x4C	; 76
    4fd2:	29 f4       	brne	.+10     	; 0x4fde <Init_Mode+0xe8>
			Typewriter_Mode = USB_LIGHT_MODE;
    4fd4:	8d e0       	ldi	r24, 0x0D	; 13
    4fd6:	80 93 6f 07 	sts	0x076F, r24
			Default_Mode = USB_LIGHT_MODE;
    4fda:	cd e0       	ldi	r28, 0x0D	; 13
    4fdc:	02 c0       	rjmp	.+4      	; 0x4fe2 <Init_Mode+0xec>
	}

	else{
		Typewriter_Mode = Default_Mode; //otherwise just go into the last mode selected by user.
    4fde:	c0 93 6f 07 	sts	0x076F, r28
	}
	
	eeprom_update_byte((uint8_t*)DEFAULT_MODE_ADDR,Default_Mode);  //Save the new default mode (if changed)
    4fe2:	6c 2f       	mov	r22, r28
    4fe4:	8d e0       	ldi	r24, 0x0D	; 13
    4fe6:	92 e0       	ldi	r25, 0x02	; 2
}
    4fe8:	cf 91       	pop	r28

	else{
		Typewriter_Mode = Default_Mode; //otherwise just go into the last mode selected by user.
	}
	
	eeprom_update_byte((uint8_t*)DEFAULT_MODE_ADDR,Default_Mode);  //Save the new default mode (if changed)
    4fea:	0c 94 d4 3a 	jmp	0x75a8	; 0x75a8 <eeprom_update_byte>

00004fee <main>:

/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{	
    4fee:	cf 93       	push	r28
    4ff0:	df 93       	push	r29
    4ff2:	1f 92       	push	r1
    4ff4:	cd b7       	in	r28, 0x3d	; 61
    4ff6:	de b7       	in	r29, 0x3e	; 62
	uint8_t key;
	uint8_t code;
	uint8_t modifier;
	uint8_t parity;
	
	Typewriter_Mode = INITIALIZING;
    4ff8:	8c e0       	ldi	r24, 0x0C	; 12
    4ffa:	80 93 6f 07 	sts	0x076F, r24

	SetupHardware();
    4ffe:	ae de       	rcall	.-676    	; 0x4d5c <SetupHardware>
	InitializeEeprom();//sets all EEPROM entries to zero if the checksum is incorrect
    5000:	a3 d5       	rcall	.+2886   	; 0x5b48 <InitializeEeprom>
	LoadEepromParameters();
    5002:	1b d5       	rcall	.+2614   	; 0x5a3a <LoadEepromParameters>
	LoadKeyCodeTables();
    5004:	f2 d4       	rcall	.+2532   	; 0x59ea <LoadKeyCodeTables>
	SDCardManager_Init(); 
    5006:	3f dc       	rcall	.-1922   	; 0x4886 <SDCardManager_Init>
	USB_Init();//DEBUG ONLY
    5008:	0e 94 a4 34 	call	0x6948	; 0x6948 <USB_Init>
	uart_init(UART_BAUD_SELECT(9600,F_CPU));//initialize the uart with a baud rate of x bps
    500c:	83 e3       	ldi	r24, 0x33	; 51
    500e:	90 e0       	ldi	r25, 0x00	; 0
    5010:	f0 dd       	rcall	.-1056   	; 0x4bf2 <uart_init>
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    5012:	78 94       	sei

	//USB_Init(); COMMENTED FOR DEBUGGING
	GlobalInterruptEnable();
	
	Init_Mode();
    5014:	70 df       	rcall	.-288    	; 0x4ef6 <Init_Mode>
				Calibrate();
				Typewriter_Mode = USB_LIGHT_MODE; //after calibrating, go to usb light mode.
			break;
			case QUICK_CAL_MODE:
				QuickCalibrate();
				Typewriter_Mode = USB_LIGHT_MODE;//after calibrating, go to usb light mode.
    5016:	1d e0       	ldi	r17, 0x0D	; 13
			case SENSITIVITY_MODE:
				Adjust_Sensitivity();
				Typewriter_Mode = USB_LIGHT_MODE;
			break;
			default:
				Typewriter_Mode = PANIC_MODE;
    5018:	0a e0       	ldi	r16, 0x0A	; 10
	
	Init_Mode();
//	Delay_MS(INIT_DELAY);
	
	while(1){
		switch (Typewriter_Mode){
    501a:	80 91 6f 07 	lds	r24, 0x076F
    501e:	86 30       	cpi	r24, 0x06	; 6
    5020:	09 f4       	brne	.+2      	; 0x5024 <main+0x36>
    5022:	84 c0       	rjmp	.+264    	; 0x512c <main+0x13e>
    5024:	9c f4       	brge	.+38     	; 0x504c <main+0x5e>
    5026:	83 30       	cpi	r24, 0x03	; 3
    5028:	09 f4       	brne	.+2      	; 0x502c <main+0x3e>
    502a:	d9 c0       	rjmp	.+434    	; 0x51de <main+0x1f0>
    502c:	34 f4       	brge	.+12     	; 0x503a <main+0x4c>
    502e:	81 30       	cpi	r24, 0x01	; 1
    5030:	11 f1       	breq	.+68     	; 0x5076 <main+0x88>
    5032:	82 30       	cpi	r24, 0x02	; 2
    5034:	09 f4       	brne	.+2      	; 0x5038 <main+0x4a>
    5036:	6f c0       	rjmp	.+222    	; 0x5116 <main+0x128>
    5038:	d7 c0       	rjmp	.+430    	; 0x51e8 <main+0x1fa>
    503a:	84 30       	cpi	r24, 0x04	; 4
    503c:	09 f4       	brne	.+2      	; 0x5040 <main+0x52>
    503e:	3d c0       	rjmp	.+122    	; 0x50ba <main+0xcc>
    5040:	85 30       	cpi	r24, 0x05	; 5
    5042:	09 f0       	breq	.+2      	; 0x5046 <main+0x58>
    5044:	d1 c0       	rjmp	.+418    	; 0x51e8 <main+0x1fa>
				if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
				USB_Disable(); //make sure no host is connected before accessing SD card.
				LogKeystrokes();
			break;
			case CAL_MODE:
				Calibrate();
    5046:	0e 94 1b 07 	call	0xe36	; 0xe36 <Calibrate>
    504a:	cb c0       	rjmp	.+406    	; 0x51e2 <main+0x1f4>
	
	Init_Mode();
//	Delay_MS(INIT_DELAY);
	
	while(1){
		switch (Typewriter_Mode){
    504c:	8b 30       	cpi	r24, 0x0B	; 11
    504e:	09 f4       	brne	.+2      	; 0x5052 <main+0x64>
    5050:	5e c0       	rjmp	.+188    	; 0x510e <main+0x120>
    5052:	4c f4       	brge	.+18     	; 0x5066 <main+0x78>
    5054:	89 30       	cpi	r24, 0x09	; 9
    5056:	09 f4       	brne	.+2      	; 0x505a <main+0x6c>
    5058:	6c c0       	rjmp	.+216    	; 0x5132 <main+0x144>
    505a:	8a 30       	cpi	r24, 0x0A	; 10
    505c:	09 f0       	breq	.+2      	; 0x5060 <main+0x72>
    505e:	c4 c0       	rjmp	.+392    	; 0x51e8 <main+0x1fa>
					
				}
			
			break;
			case PANIC_MODE:
				USB_Disable();
    5060:	0e 94 4c 34 	call	0x6898	; 0x6898 <USB_Disable>
    5064:	a5 c0       	rjmp	.+330    	; 0x51b0 <main+0x1c2>
	
	Init_Mode();
//	Delay_MS(INIT_DELAY);
	
	while(1){
		switch (Typewriter_Mode){
    5066:	8d 30       	cpi	r24, 0x0D	; 13
    5068:	31 f0       	breq	.+12     	; 0x5076 <main+0x88>
    506a:	8e 30       	cpi	r24, 0x0E	; 14
    506c:	09 f0       	breq	.+2      	; 0x5070 <main+0x82>
    506e:	bc c0       	rjmp	.+376    	; 0x51e8 <main+0x1fa>
			case QUICK_CAL_MODE:
				QuickCalibrate();
				Typewriter_Mode = USB_LIGHT_MODE;//after calibrating, go to usb light mode.
			break;
			case MANUAL_CAL_MODE:
				Calibrate_Manually();
    5070:	0e 94 02 0b 	call	0x1604	; 0x1604 <Calibrate_Manually>
    5074:	b6 c0       	rjmp	.+364    	; 0x51e2 <main+0x1f4>
	
	while(1){
		switch (Typewriter_Mode){
			case USB_LIGHT_MODE:
			case USB_COMBO_MODE:				
			MountFilesystem();//mount the filesystem so that we have info on it
    5076:	0e 94 98 0d 	call	0x1b30	; 0x1b30 <MountFilesystem>
			while(1){
				key = GetKey();
    507a:	3f d3       	rcall	.+1662   	; 0x56fa <GetKey>
    507c:	18 2f       	mov	r17, r24
				modifier = GetModifier(); 
    507e:	33 d2       	rcall	.+1126   	; 0x54e6 <GetModifier>
    5080:	89 83       	std	Y+1, r24	; 0x01
				code = GetHIDKeyCode(key, &modifier);
    5082:	be 01       	movw	r22, r28
    5084:	6f 5f       	subi	r22, 0xFF	; 255
    5086:	7f 4f       	sbci	r23, 0xFF	; 255
    5088:	81 2f       	mov	r24, r17
    508a:	75 d4       	rcall	.+2282   	; 0x5976 <GetHIDKeyCode>
					
				if(code){//if the code is valid, send it
    508c:	88 23       	and	r24, r24
    508e:	51 f0       	breq	.+20     	; 0x50a4 <main+0xb6>
						if ((code == KEY_U) && Ignore_Flag) code = 0; //if user is holding down U on startup, don't add this U to file.
    5090:	88 31       	cpi	r24, 0x18	; 24
    5092:	21 f4       	brne	.+8      	; 0x509c <main+0xae>
    5094:	90 91 69 06 	lds	r25, 0x0669
    5098:	91 11       	cpse	r25, r1
    509a:	80 e0       	ldi	r24, 0x00	; 0
						Ignore_Flag = 0;
    509c:	10 92 69 06 	sts	0x0669, r1
						USBSend(code,modifier);
    50a0:	69 81       	ldd	r22, Y+1	; 0x01
    50a2:	a5 d0       	rcall	.+330    	; 0x51ee <USBSend>
    50a4:	8f ec       	ldi	r24, 0xCF	; 207
    50a6:	97 e0       	ldi	r25, 0x07	; 7
    50a8:	01 97       	sbiw	r24, 0x01	; 1
    50aa:	f1 f7       	brne	.-4      	; 0x50a8 <main+0xba>
    50ac:	00 c0       	rjmp	.+0      	; 0x50ae <main+0xc0>
    50ae:	00 00       	nop
				}
				Delay_MS(SENSE_DELAY);//perform this loop every X ms.
				HID_Device_USBTask(&Keyboard_HID_Interface);
    50b0:	80 e2       	ldi	r24, 0x20	; 32
    50b2:	91 e0       	ldi	r25, 0x01	; 1
    50b4:	bf d6       	rcall	.+3454   	; 0x5e34 <HID_Device_USBTask>
				Task_Manager(); //do the required usb upkeep tasks, then update the list of scheduled tasks.
    50b6:	33 de       	rcall	.-922    	; 0x4d1e <Task_Manager>
				
			}
    50b8:	e0 cf       	rjmp	.-64     	; 0x507a <main+0x8c>
			break;
			case TEST_MODE:
				USB_Disable(); //USB not needed for testing
    50ba:	0e 94 4c 34 	call	0x6898	; 0x6898 <USB_Disable>
				while(1){
					UseHallSensor = HALL_NOT_PRESENT;//make sure hall sensor bit is not zeroed out by ReadSensor() as soon as it is read;
					parity = (uint8_t)is_low(REED_1) + (uint8_t)is_low(REED_2)+ (uint8_t)is_low(REED_3) + (uint8_t)is_low(REED_4) + (uint8_t)getHallState();
    50be:	01 e0       	ldi	r16, 0x01	; 1
			}
			break;
			case TEST_MODE:
				USB_Disable(); //USB not needed for testing
				while(1){
					UseHallSensor = HALL_NOT_PRESENT;//make sure hall sensor bit is not zeroed out by ReadSensor() as soon as it is read;
    50c0:	10 92 f1 06 	sts	0x06F1, r1
					parity = (uint8_t)is_low(REED_1) + (uint8_t)is_low(REED_2)+ (uint8_t)is_low(REED_3) + (uint8_t)is_low(REED_4) + (uint8_t)getHallState();
    50c4:	89 b1       	in	r24, 0x09	; 9
    50c6:	19 b1       	in	r17, 0x09	; 9
    50c8:	29 b1       	in	r18, 0x09	; 9
    50ca:	93 b1       	in	r25, 0x03	; 3
    50cc:	16 fb       	bst	r17, 6
    50ce:	11 27       	eor	r17, r17
    50d0:	10 f9       	bld	r17, 0
    50d2:	10 27       	eor	r17, r16
    50d4:	82 95       	swap	r24
    50d6:	81 70       	andi	r24, 0x01	; 1
    50d8:	80 27       	eor	r24, r16
    50da:	18 0f       	add	r17, r24
    50dc:	20 95       	com	r18
    50de:	22 1f       	adc	r18, r18
    50e0:	22 27       	eor	r18, r18
    50e2:	22 1f       	adc	r18, r18
    50e4:	12 0f       	add	r17, r18
    50e6:	92 95       	swap	r25
    50e8:	91 70       	andi	r25, 0x01	; 1
    50ea:	90 27       	eor	r25, r16
    50ec:	19 0f       	add	r17, r25
    50ee:	74 d4       	rcall	.+2280   	; 0x59d8 <getHallState>
    50f0:	81 0f       	add	r24, r17
				
					if (parity & 1){  //if first bit of parity is 1, then an odd number of sensors are active.
    50f2:	80 ff       	sbrs	r24, 0
    50f4:	03 c0       	rjmp	.+6      	; 0x50fc <main+0x10e>
						set_high(LED1);
    50f6:	46 9a       	sbi	0x08, 6	; 8
						set_low(LED2);
    50f8:	2e 98       	cbi	0x05, 6	; 5
    50fa:	02 c0       	rjmp	.+4      	; 0x5100 <main+0x112>
					}
					else{ //otherwise, an even number (or zero) are active.
						set_low(LED1);
    50fc:	46 98       	cbi	0x08, 6	; 8
						set_high(LED2);
    50fe:	2e 9a       	sbi	0x05, 6	; 5
    5100:	ef ec       	ldi	r30, 0xCF	; 207
    5102:	f7 e0       	ldi	r31, 0x07	; 7
    5104:	31 97       	sbiw	r30, 0x01	; 1
    5106:	f1 f7       	brne	.-4      	; 0x5104 <main+0x116>
    5108:	00 c0       	rjmp	.+0      	; 0x510a <main+0x11c>
    510a:	00 00       	nop
    510c:	d9 cf       	rjmp	.-78     	; 0x50c0 <main+0xd2>
					}
					Delay_MS(SENSE_DELAY);
				}
			break;
			case HARDWARE_TEST:				
				USB_Disable(); //make sure no host is connected before accessing SD card.
    510e:	0e 94 4c 34 	call	0x6898	; 0x6898 <USB_Disable>
				TestSDHardware();
    5112:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <TestSDHardware>
			case SD_MODE:
				if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
    5116:	80 91 1d 06 	lds	r24, 0x061D
    511a:	88 23       	and	r24, r24
    511c:	11 f0       	breq	.+4      	; 0x5122 <main+0x134>
    511e:	5d 98       	cbi	0x0b, 5	; 11
    5120:	55 9a       	sbi	0x0a, 5	; 10
				USB_Disable(); //make sure no host is connected before accessing SD card.
    5122:	0e 94 4c 34 	call	0x6898	; 0x6898 <USB_Disable>
				LogKeystrokes();
    5126:	0e 94 7d 0e 	call	0x1cfa	; 0x1cfa <LogKeystrokes>
			break;
    512a:	77 cf       	rjmp	.-274    	; 0x501a <main+0x2c>
			case CAL_MODE:
				Calibrate();
				Typewriter_Mode = USB_LIGHT_MODE; //after calibrating, go to usb light mode.
			break;
			case QUICK_CAL_MODE:
				QuickCalibrate();
    512c:	0e 94 b5 06 	call	0xd6a	; 0xd6a <QuickCalibrate>
    5130:	58 c0       	rjmp	.+176    	; 0x51e2 <main+0x1f4>
				Calibrate_Manually();
				Typewriter_Mode = USB_LIGHT_MODE;
			break;
			case BLUETOOTH_MODE:
				#ifndef BT_DEBUG
					USB_Disable();//don't disable usb if it is debug mode.
    5132:	0e 94 4c 34 	call	0x6898	; 0x6898 <USB_Disable>
				#endif
					
					if(Get_Bluetooth_State() != INITIALIZED){Bluetooth_Init();};//initialize bluetooth if it hasn't been already. this sets up proxy mode, too.
    5136:	0e 94 1b 05 	call	0xa36	; 0xa36 <Get_Bluetooth_State>
    513a:	81 30       	cpi	r24, 0x01	; 1
    513c:	11 f0       	breq	.+4      	; 0x5142 <main+0x154>
    513e:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <Bluetooth_Init>
					if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
    5142:	80 91 1d 06 	lds	r24, 0x061D
    5146:	88 23       	and	r24, r24
    5148:	69 f0       	breq	.+26     	; 0x5164 <main+0x176>
    514a:	5d 98       	cbi	0x0b, 5	; 11
    514c:	55 9a       	sbi	0x0a, 5	; 10
    514e:	0a c0       	rjmp	.+20     	; 0x5164 <main+0x176>
    5150:	01 97       	sbiw	r24, 0x01	; 1
					set_low(RED_LED);
					set_high(GREEN_LED);
					#if MODULE_NAME==EHONG
					
						Bluetooth_Connect();
						for (int i=0; i<=1000; i++){
    5152:	41 f0       	breq	.+16     	; 0x5164 <main+0x176>
    5154:	ef e1       	ldi	r30, 0x1F	; 31
    5156:	fe e4       	ldi	r31, 0x4E	; 78
    5158:	31 97       	sbiw	r30, 0x01	; 1
    515a:	f1 f7       	brne	.-4      	; 0x5158 <main+0x16a>
    515c:	00 c0       	rjmp	.+0      	; 0x515e <main+0x170>
    515e:	00 00       	nop
							Delay_MS(10); //10 seconds between connection attempts
							if (is_high(BT_CONNECTED)){break;} //break FOR loop
    5160:	79 9b       	sbis	0x0f, 1	; 15
    5162:	f6 cf       	rjmp	.-20     	; 0x5150 <main+0x162>
				#endif
					
					if(Get_Bluetooth_State() != INITIALIZED){Bluetooth_Init();};//initialize bluetooth if it hasn't been already. this sets up proxy mode, too.
					if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
				
				while(is_low(BT_CONNECTED)){
    5164:	79 99       	sbic	0x0f, 1	; 15
    5166:	07 c0       	rjmp	.+14     	; 0x5176 <main+0x188>
					set_low(RED_LED);
    5168:	2e 98       	cbi	0x05, 6	; 5
					set_high(GREEN_LED);
    516a:	46 9a       	sbi	0x08, 6	; 8
					#if MODULE_NAME==EHONG
					
						Bluetooth_Connect();
    516c:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <Bluetooth_Connect>
    5170:	89 ee       	ldi	r24, 0xE9	; 233
    5172:	93 e0       	ldi	r25, 0x03	; 3
    5174:	ef cf       	rjmp	.-34     	; 0x5154 <main+0x166>
						}
				
					#endif
				}//wait for connection to happen, glow red until then.
				
				set_high(RED_LED);//turn off red led if bt is connected.
    5176:	2e 9a       	sbi	0x05, 6	; 5
				set_low(GREEN_LED);
    5178:	46 98       	cbi	0x08, 6	; 8
				
				#if MODULE_NAME==EHONG
				Bluetooth_Send(0,0); //clear off keyboard report.
    517a:	60 e0       	ldi	r22, 0x00	; 0
    517c:	80 e0       	ldi	r24, 0x00	; 0
    517e:	0e 94 a1 03 	call	0x742	; 0x742 <Bluetooth_Send>
				#endif
				
				while(is_high(BT_CONNECTED)){
    5182:	79 9b       	sbis	0x0f, 1	; 15
    5184:	4a cf       	rjmp	.-364    	; 0x501a <main+0x2c>
					key = GetKey();
    5186:	b9 d2       	rcall	.+1394   	; 0x56fa <GetKey>
    5188:	f8 2e       	mov	r15, r24
					modifier = GetModifier();
    518a:	ad d1       	rcall	.+858    	; 0x54e6 <GetModifier>
    518c:	89 83       	std	Y+1, r24	; 0x01
									
					code = GetHIDKeyCode(key, &modifier);
    518e:	be 01       	movw	r22, r28
    5190:	6f 5f       	subi	r22, 0xFF	; 255
    5192:	7f 4f       	sbci	r23, 0xFF	; 255
    5194:	8f 2d       	mov	r24, r15
    5196:	ef d3       	rcall	.+2014   	; 0x5976 <GetHIDKeyCode>
					
					if(code){
    5198:	88 23       	and	r24, r24
    519a:	19 f0       	breq	.+6      	; 0x51a2 <main+0x1b4>
						Bluetooth_Send(code,modifier);
    519c:	69 81       	ldd	r22, Y+1	; 0x01
    519e:	0e 94 a1 03 	call	0x742	; 0x742 <Bluetooth_Send>
    51a2:	8f ec       	ldi	r24, 0xCF	; 207
    51a4:	97 e0       	ldi	r25, 0x07	; 7
    51a6:	01 97       	sbiw	r24, 0x01	; 1
    51a8:	f1 f7       	brne	.-4      	; 0x51a6 <main+0x1b8>
    51aa:	00 c0       	rjmp	.+0      	; 0x51ac <main+0x1be>
    51ac:	00 00       	nop
    51ae:	e9 cf       	rjmp	.-46     	; 0x5182 <main+0x194>
			
			break;
			case PANIC_MODE:
				USB_Disable();
				while(1){
					set_high(LED2);
    51b0:	2e 9a       	sbi	0x05, 6	; 5
					set_low(LED1);
    51b2:	46 98       	cbi	0x08, 6	; 8
    51b4:	9f ef       	ldi	r25, 0xFF	; 255
    51b6:	e1 ee       	ldi	r30, 0xE1	; 225
    51b8:	f4 e0       	ldi	r31, 0x04	; 4
    51ba:	91 50       	subi	r25, 0x01	; 1
    51bc:	e0 40       	sbci	r30, 0x00	; 0
    51be:	f0 40       	sbci	r31, 0x00	; 0
    51c0:	e1 f7       	brne	.-8      	; 0x51ba <main+0x1cc>
    51c2:	00 c0       	rjmp	.+0      	; 0x51c4 <main+0x1d6>
    51c4:	00 00       	nop
					Delay_MS(200);
					set_high(LED1);
    51c6:	46 9a       	sbi	0x08, 6	; 8
					set_low(LED2);
    51c8:	2e 98       	cbi	0x05, 6	; 5
    51ca:	2f ef       	ldi	r18, 0xFF	; 255
    51cc:	81 ee       	ldi	r24, 0xE1	; 225
    51ce:	94 e0       	ldi	r25, 0x04	; 4
    51d0:	21 50       	subi	r18, 0x01	; 1
    51d2:	80 40       	sbci	r24, 0x00	; 0
    51d4:	90 40       	sbci	r25, 0x00	; 0
    51d6:	e1 f7       	brne	.-8      	; 0x51d0 <main+0x1e2>
    51d8:	00 c0       	rjmp	.+0      	; 0x51da <main+0x1ec>
    51da:	00 00       	nop
    51dc:	e9 cf       	rjmp	.-46     	; 0x51b0 <main+0x1c2>
					Delay_MS(200);
				}		
			break;
			case SENSITIVITY_MODE:
				Adjust_Sensitivity();
    51de:	0e 94 f7 09 	call	0x13ee	; 0x13ee <Adjust_Sensitivity>
				Typewriter_Mode = USB_LIGHT_MODE;
    51e2:	10 93 6f 07 	sts	0x076F, r17
			break;
    51e6:	19 cf       	rjmp	.-462    	; 0x501a <main+0x2c>
			default:
				Typewriter_Mode = PANIC_MODE;
    51e8:	00 93 6f 07 	sts	0x076F, r16
			break;
    51ec:	16 cf       	rjmp	.-468    	; 0x501a <main+0x2c>

000051ee <USBSend>:
#include <ctype.h> // allows toupper()

extern USB_ClassInfo_HID_Device_t Keyboard_HID_Interface; //import the keyboard interface object from main routine so we can call usbtask on it.

/*Send a character over usb with a given modifier (shift, ctrl, etc)*/
void USBSend(uint8_t code,uint8_t mod){	
    51ee:	1f 93       	push	r17
    51f0:	cf 93       	push	r28
    51f2:	df 93       	push	r29
    51f4:	1f 92       	push	r1
    51f6:	cd b7       	in	r28, 0x3d	; 61
    51f8:	de b7       	in	r29, 0x3e	; 62
    51fa:	18 2f       	mov	r17, r24
	
	TMR1_Count = 0;
    51fc:	10 92 66 06 	sts	0x0666, r1
    5200:	10 92 65 06 	sts	0x0665, r1
	while (KeyBuffer->KeyCode[0] && TMR1_Count < USB_SEND_TIMEOUT) {
    5204:	e0 91 6a 06 	lds	r30, 0x066A
    5208:	f0 91 6b 06 	lds	r31, 0x066B
    520c:	82 81       	ldd	r24, Z+2	; 0x02
    520e:	88 23       	and	r24, r24
    5210:	a9 f0       	breq	.+42     	; 0x523c <USBSend+0x4e>
    5212:	80 91 65 06 	lds	r24, 0x0665
    5216:	90 91 66 06 	lds	r25, 0x0666
    521a:	84 36       	cpi	r24, 0x64	; 100
    521c:	91 05       	cpc	r25, r1
    521e:	70 f4       	brcc	.+28     	; 0x523c <USBSend+0x4e>
		if((Typewriter_Mode == USB_COMBO_MODE) || (Typewriter_Mode == USB_LIGHT_MODE)){ //interrupts do not handle keyboard stuff during this mode.
    5220:	80 91 6f 07 	lds	r24, 0x076F
    5224:	81 30       	cpi	r24, 0x01	; 1
    5226:	21 f0       	breq	.+8      	; 0x5230 <USBSend+0x42>
    5228:	80 91 6f 07 	lds	r24, 0x076F
    522c:	8d 30       	cpi	r24, 0x0D	; 13
    522e:	51 f7       	brne	.-44     	; 0x5204 <USBSend+0x16>
			HID_Device_USBTask(&Keyboard_HID_Interface);
    5230:	80 e2       	ldi	r24, 0x20	; 32
    5232:	91 e0       	ldi	r25, 0x01	; 1
    5234:	69 83       	std	Y+1, r22	; 0x01
    5236:	fe d5       	rcall	.+3068   	; 0x5e34 <HID_Device_USBTask>
    5238:	69 81       	ldd	r22, Y+1	; 0x01
    523a:	e4 cf       	rjmp	.-56     	; 0x5204 <USBSend+0x16>
		} //if buffer is full, wait.  If timeout expires, stop waiting.
	}
	
	if (code&FORCE_UPPER){ //in this program, we use the MSB of code to indicate that this key MUST be sent as upper case.
    523c:	17 ff       	sbrs	r17, 7
    523e:	02 c0       	rjmp	.+4      	; 0x5244 <USBSend+0x56>
		reg_clr(code,FORCE_UPPER); //clear the MSB,  
    5240:	1f 77       	andi	r17, 0x7F	; 127
		mod = UPPER; //and set the modifier to upper case.
    5242:	62 e0       	ldi	r22, 0x02	; 2
	}
	
	if(code == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
    5244:	14 37       	cpi	r17, 0x74	; 116
    5246:	11 f4       	brne	.+4      	; 0x524c <USBSend+0x5e>
		code = KEY_ENTER;
		mod = HID_KEYBOARD_MODIFIER_LEFTCTRL;
    5248:	61 e0       	ldi	r22, 0x01	; 1
		reg_clr(code,FORCE_UPPER); //clear the MSB,  
		mod = UPPER; //and set the modifier to upper case.
	}
	
	if(code == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
		code = KEY_ENTER;
    524a:	18 e2       	ldi	r17, 0x28	; 40
		mod = HID_KEYBOARD_MODIFIER_LEFTCTRL;
	}
	
	cli();//make sure there are no interrupts between setting code and setting the modifier that goes with it.
    524c:	f8 94       	cli
	KeyBuffer->KeyCode[0] = code; //cue up keycode to be sent during next LUFA HID callback function.
    524e:	e0 91 6a 06 	lds	r30, 0x066A
    5252:	f0 91 6b 06 	lds	r31, 0x066B
    5256:	12 83       	std	Z+2, r17	; 0x02
	KeyBufferMod = mod;
    5258:	60 93 21 06 	sts	0x0621, r22
	HID_Device_USBTask(&Keyboard_HID_Interface); //Dean Camera says to call this function regularly -- right after sending a character seems like an appropriate time.
    525c:	80 e2       	ldi	r24, 0x20	; 32
    525e:	91 e0       	ldi	r25, 0x01	; 1
    5260:	e9 d5       	rcall	.+3026   	; 0x5e34 <HID_Device_USBTask>
	sei();//re-enable the interrupts.
    5262:	78 94       	sei
    5264:	8f e3       	ldi	r24, 0x3F	; 63
    5266:	9c e9       	ldi	r25, 0x9C	; 156
    5268:	01 97       	sbiw	r24, 0x01	; 1
    526a:	f1 f7       	brne	.-4      	; 0x5268 <USBSend+0x7a>
    526c:	00 c0       	rjmp	.+0      	; 0x526e <USBSend+0x80>
    526e:	00 00       	nop
	
	Delay_MS(USB_SEND_DELAY);// wait X ms after sending each character.
	
	cli();//make sure no interrupts occur during the usb task.
    5270:	f8 94       	cli
	HID_Device_USBTask(&Keyboard_HID_Interface); //do LUFA hid usb tasks
    5272:	80 e2       	ldi	r24, 0x20	; 32
    5274:	91 e0       	ldi	r25, 0x01	; 1
    5276:	de d5       	rcall	.+3004   	; 0x5e34 <HID_Device_USBTask>
	sei();
    5278:	78 94       	sei
}
    527a:	0f 90       	pop	r0
    527c:	df 91       	pop	r29
    527e:	cf 91       	pop	r28
    5280:	1f 91       	pop	r17
    5282:	08 95       	ret

00005284 <USBSendString>:

/*Send a string over USB. Only supports some characters.*/
void USBSendString(char *str){
    5284:	ef 92       	push	r14
    5286:	ff 92       	push	r15
    5288:	0f 93       	push	r16
    528a:	1f 93       	push	r17
    528c:	cf 93       	push	r28
    528e:	df 93       	push	r29
    5290:	8c 01       	movw	r16, r24
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
    5292:	fc 01       	movw	r30, r24
    5294:	01 90       	ld	r0, Z+
    5296:	00 20       	and	r0, r0
    5298:	e9 f7       	brne	.-6      	; 0x5294 <USBSendString+0x10>
    529a:	31 97       	sbiw	r30, 0x01	; 1
    529c:	ef 01       	movw	r28, r30
    529e:	c8 1b       	sub	r28, r24
    52a0:	d9 0b       	sbc	r29, r25
	for (int i=0; i<length; i++){
    52a2:	7c 01       	movw	r14, r24
    52a4:	c7 01       	movw	r24, r14
    52a6:	80 1b       	sub	r24, r16
    52a8:	91 0b       	sbc	r25, r17
    52aa:	8c 17       	cp	r24, r28
    52ac:	9d 07       	cpc	r25, r29
    52ae:	0c f0       	brlt	.+2      	; 0x52b2 <USBSendString+0x2e>
    52b0:	61 c0       	rjmp	.+194    	; 0x5374 <USBSendString+0xf0>
		modifier = LOWER;
		if(str[i] == ' '){
    52b2:	f7 01       	movw	r30, r14
    52b4:	91 91       	ld	r25, Z+
    52b6:	7f 01       	movw	r14, r30
    52b8:	90 32       	cpi	r25, 0x20	; 32
    52ba:	59 f1       	breq	.+86     	; 0x5312 <USBSendString+0x8e>
			code = KEY_SPACE;
		}
		else if(str[i] == '('){
    52bc:	98 32       	cpi	r25, 0x28	; 40
    52be:	61 f1       	breq	.+88     	; 0x5318 <USBSendString+0x94>
			code = KEY_9;
			modifier = UPPER;
		}
		else if(str[i] == ')'){
    52c0:	99 32       	cpi	r25, 0x29	; 41
    52c2:	69 f1       	breq	.+90     	; 0x531e <USBSendString+0x9a>
			code = KEY_0;
			modifier = UPPER;
		}
		else if(str[i] == '/'){
    52c4:	9f 32       	cpi	r25, 0x2F	; 47
    52c6:	69 f1       	breq	.+90     	; 0x5322 <USBSendString+0x9e>
			code = KEY_SLASH;
		}
		else if(str[i] == '?'){
    52c8:	9f 33       	cpi	r25, 0x3F	; 63
    52ca:	69 f1       	breq	.+90     	; 0x5326 <USBSendString+0xa2>
			code = KEY_SLASH;
			modifier = UPPER;
		}
		else if(str[i] == ':'){
    52cc:	9a 33       	cpi	r25, 0x3A	; 58
    52ce:	71 f1       	breq	.+92     	; 0x532c <USBSendString+0xa8>
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
    52d0:	9d 30       	cpi	r25, 0x0D	; 13
    52d2:	79 f1       	breq	.+94     	; 0x5332 <USBSendString+0xae>
    52d4:	9a 30       	cpi	r25, 0x0A	; 10
    52d6:	69 f1       	breq	.+90     	; 0x5332 <USBSendString+0xae>
			code = KEY_ENTER;
		}
		else if(str[i] == '.'){
    52d8:	9e 32       	cpi	r25, 0x2E	; 46
    52da:	71 f1       	breq	.+92     	; 0x5338 <USBSendString+0xb4>
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if(str[i] == '='){
    52dc:	9d 33       	cpi	r25, 0x3D	; 61
    52de:	79 f1       	breq	.+94     	; 0x533e <USBSendString+0xba>
			code = KEY_EQ;
			modifier = LOWER;
		}
		else if(str[i] == '+'){
    52e0:	9b 32       	cpi	r25, 0x2B	; 43
    52e2:	79 f1       	breq	.+94     	; 0x5342 <USBSendString+0xbe>
			code = KEY_EQ;
			modifier = UPPER;
		}
		else if(str[i] == '\t'){
    52e4:	99 30       	cpi	r25, 0x09	; 9
    52e6:	81 f1       	breq	.+96     	; 0x5348 <USBSendString+0xc4>
			code = KEY_TAB;
			modifier = LOWER;
		}
		else if(str[i] == '#'){
    52e8:	93 32       	cpi	r25, 0x23	; 35
    52ea:	89 f1       	breq	.+98     	; 0x534e <USBSendString+0xca>
			code = KEY_1 +2;
			modifier = UPPER;
		}
		else if(str[i] == '!'){
    52ec:	91 32       	cpi	r25, 0x21	; 33
    52ee:	91 f1       	breq	.+100    	; 0x5354 <USBSendString+0xd0>
			code = KEY_1;
			modifier = UPPER;
		}
		else if(str[i] == '0'){
    52f0:	90 33       	cpi	r25, 0x30	; 48
    52f2:	99 f1       	breq	.+102    	; 0x535a <USBSendString+0xd6>
			code = KEY_0;
		}
		else if((str[i] >= ASCII_1 )&&(str[i] <= ASCII_9)){
    52f4:	8f ec       	ldi	r24, 0xCF	; 207
    52f6:	89 0f       	add	r24, r25
    52f8:	89 30       	cpi	r24, 0x09	; 9
    52fa:	20 f4       	brcc	.+8      	; 0x5304 <USBSendString+0x80>
			code = str[i] - ASCII_1 + KEY_1; //translate ascii to hid number code 
    52fc:	8d ee       	ldi	r24, 0xED	; 237
    52fe:	89 0f       	add	r24, r25
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5300:	60 e0       	ldi	r22, 0x00	; 0
    5302:	2d c0       	rjmp	.+90     	; 0x535e <USBSendString+0xda>
		}
		else if((str[i] >= ASCII_1 )&&(str[i] <= ASCII_9)){
			code = str[i] - ASCII_1 + KEY_1; //translate ascii to hid number code 
		}
		else{
			code = toupper(str[i]);//make sure code is uppercase.
    5304:	89 2f       	mov	r24, r25
    5306:	90 e0       	ldi	r25, 0x00	; 0
    5308:	0e 94 cb 37 	call	0x6f96	; 0x6f96 <toupper>
			code = code-ASCII_A+KEY_A;  //Convert the character (which is uppercase Ascii)  to an USB HID Keycode.
    530c:	8d 53       	subi	r24, 0x3D	; 61
			modifier = UPPER;
    530e:	62 e0       	ldi	r22, 0x02	; 2
    5310:	26 c0       	rjmp	.+76     	; 0x535e <USBSendString+0xda>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5312:	60 e0       	ldi	r22, 0x00	; 0
		if(str[i] == ' '){
			code = KEY_SPACE;
    5314:	8c e2       	ldi	r24, 0x2C	; 44
    5316:	23 c0       	rjmp	.+70     	; 0x535e <USBSendString+0xda>
		}
		else if(str[i] == '('){
			code = KEY_9;
			modifier = UPPER;
    5318:	62 e0       	ldi	r22, 0x02	; 2
		modifier = LOWER;
		if(str[i] == ' '){
			code = KEY_SPACE;
		}
		else if(str[i] == '('){
			code = KEY_9;
    531a:	86 e2       	ldi	r24, 0x26	; 38
    531c:	20 c0       	rjmp	.+64     	; 0x535e <USBSendString+0xda>
			modifier = UPPER;
		}
		else if(str[i] == ')'){
			code = KEY_0;
			modifier = UPPER;
    531e:	62 e0       	ldi	r22, 0x02	; 2
    5320:	1d c0       	rjmp	.+58     	; 0x535c <USBSendString+0xd8>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5322:	60 e0       	ldi	r22, 0x00	; 0
    5324:	01 c0       	rjmp	.+2      	; 0x5328 <USBSendString+0xa4>
		else if(str[i] == '/'){
			code = KEY_SLASH;
		}
		else if(str[i] == '?'){
			code = KEY_SLASH;
			modifier = UPPER;
    5326:	62 e0       	ldi	r22, 0x02	; 2
		}
		else if(str[i] == '/'){
			code = KEY_SLASH;
		}
		else if(str[i] == '?'){
			code = KEY_SLASH;
    5328:	88 e3       	ldi	r24, 0x38	; 56
    532a:	19 c0       	rjmp	.+50     	; 0x535e <USBSendString+0xda>
			modifier = UPPER;
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
    532c:	62 e0       	ldi	r22, 0x02	; 2
		else if(str[i] == '?'){
			code = KEY_SLASH;
			modifier = UPPER;
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
    532e:	83 e3       	ldi	r24, 0x33	; 51
    5330:	16 c0       	rjmp	.+44     	; 0x535e <USBSendString+0xda>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5332:	60 e0       	ldi	r22, 0x00	; 0
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
			code = KEY_ENTER;
    5334:	88 e2       	ldi	r24, 0x28	; 40
    5336:	13 c0       	rjmp	.+38     	; 0x535e <USBSendString+0xda>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5338:	60 e0       	ldi	r22, 0x00	; 0
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
			code = KEY_ENTER;
		}
		else if(str[i] == '.'){
			code = KEY_PERIOD;
    533a:	87 e3       	ldi	r24, 0x37	; 55
    533c:	10 c0       	rjmp	.+32     	; 0x535e <USBSendString+0xda>
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if(str[i] == '='){
			code = KEY_EQ;
			modifier = LOWER;
    533e:	60 e0       	ldi	r22, 0x00	; 0
    5340:	01 c0       	rjmp	.+2      	; 0x5344 <USBSendString+0xc0>
		}
		else if(str[i] == '+'){
			code = KEY_EQ;
			modifier = UPPER;
    5342:	62 e0       	ldi	r22, 0x02	; 2
		else if(str[i] == '='){
			code = KEY_EQ;
			modifier = LOWER;
		}
		else if(str[i] == '+'){
			code = KEY_EQ;
    5344:	8e e2       	ldi	r24, 0x2E	; 46
    5346:	0b c0       	rjmp	.+22     	; 0x535e <USBSendString+0xda>
			modifier = UPPER;
		}
		else if(str[i] == '\t'){
			code = KEY_TAB;
			modifier = LOWER;
    5348:	60 e0       	ldi	r22, 0x00	; 0
		else if(str[i] == '+'){
			code = KEY_EQ;
			modifier = UPPER;
		}
		else if(str[i] == '\t'){
			code = KEY_TAB;
    534a:	8b e2       	ldi	r24, 0x2B	; 43
    534c:	08 c0       	rjmp	.+16     	; 0x535e <USBSendString+0xda>
			modifier = LOWER;
		}
		else if(str[i] == '#'){
			code = KEY_1 +2;
			modifier = UPPER;
    534e:	62 e0       	ldi	r22, 0x02	; 2
		else if(str[i] == '\t'){
			code = KEY_TAB;
			modifier = LOWER;
		}
		else if(str[i] == '#'){
			code = KEY_1 +2;
    5350:	80 e2       	ldi	r24, 0x20	; 32
    5352:	05 c0       	rjmp	.+10     	; 0x535e <USBSendString+0xda>
			modifier = UPPER;
		}
		else if(str[i] == '!'){
			code = KEY_1;
			modifier = UPPER;
    5354:	62 e0       	ldi	r22, 0x02	; 2
		else if(str[i] == '#'){
			code = KEY_1 +2;
			modifier = UPPER;
		}
		else if(str[i] == '!'){
			code = KEY_1;
    5356:	8e e1       	ldi	r24, 0x1E	; 30
    5358:	02 c0       	rjmp	.+4      	; 0x535e <USBSendString+0xda>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    535a:	60 e0       	ldi	r22, 0x00	; 0
		else if(str[i] == '!'){
			code = KEY_1;
			modifier = UPPER;
		}
		else if(str[i] == '0'){
			code = KEY_0;
    535c:	87 e2       	ldi	r24, 0x27	; 39
		else{
			code = toupper(str[i]);//make sure code is uppercase.
			code = code-ASCII_A+KEY_A;  //Convert the character (which is uppercase Ascii)  to an USB HID Keycode.
			modifier = UPPER;
		}
		USBSend(code,modifier);
    535e:	47 df       	rcall	.-370    	; 0x51ee <USBSend>
    5360:	ff e7       	ldi	r31, 0x7F	; 127
    5362:	28 e3       	ldi	r18, 0x38	; 56
    5364:	81 e0       	ldi	r24, 0x01	; 1
    5366:	f1 50       	subi	r31, 0x01	; 1
    5368:	20 40       	sbci	r18, 0x00	; 0
    536a:	80 40       	sbci	r24, 0x00	; 0
    536c:	e1 f7       	brne	.-8      	; 0x5366 <USBSendString+0xe2>
    536e:	00 c0       	rjmp	.+0      	; 0x5370 <USBSendString+0xec>
    5370:	00 00       	nop
    5372:	98 cf       	rjmp	.-208    	; 0x52a4 <USBSendString+0x20>
		Delay_MS(STRING_SEND_DELAY);
	}
} 
    5374:	df 91       	pop	r29
    5376:	cf 91       	pop	r28
    5378:	1f 91       	pop	r17
    537a:	0f 91       	pop	r16
    537c:	ff 90       	pop	r15
    537e:	ef 90       	pop	r14
    5380:	08 95       	ret

00005382 <USBSendPROGString>:

/*Send a string literal to Bluetooth Module, using a string stored in program memory instead of data memory (this saves RAM)*/
void USBSendPROGString(const char*  ProgStr){
	strcpy_P(StringBuffer, (char*) ProgStr);
    5382:	bc 01       	movw	r22, r24
    5384:	82 ef       	ldi	r24, 0xF2	; 242
    5386:	96 e0       	ldi	r25, 0x06	; 6
    5388:	0e 94 d3 37 	call	0x6fa6	; 0x6fa6 <strcpy_P>
	USBSendString(StringBuffer);
    538c:	82 ef       	ldi	r24, 0xF2	; 242
    538e:	96 e0       	ldi	r25, 0x06	; 6
    5390:	79 cf       	rjmp	.-270    	; 0x5284 <USBSendString>

00005392 <USBSendNumber>:
}

/*Send a number between 0 and 255 over usb)*/
void USBSendNumber(uint8_t number){
    5392:	1f 93       	push	r17
    5394:	cf 93       	push	r28
    5396:	df 93       	push	r29
    5398:	28 2f       	mov	r18, r24
	uint8_t ones ;
	uint8_t tens;
	
	ones = number%10;
    539a:	6a e0       	ldi	r22, 0x0A	; 10
    539c:	0e 94 f9 36 	call	0x6df2	; 0x6df2 <__udivmodqi4>
    53a0:	c9 2f       	mov	r28, r25
	tens = ((number - ones)%100)/10;
    53a2:	82 2f       	mov	r24, r18
    53a4:	90 e0       	ldi	r25, 0x00	; 0
    53a6:	8c 1b       	sub	r24, r28
    53a8:	91 09       	sbc	r25, r1
    53aa:	64 e6       	ldi	r22, 0x64	; 100
    53ac:	70 e0       	ldi	r23, 0x00	; 0
    53ae:	0e 94 05 37 	call	0x6e0a	; 0x6e0a <__divmodhi4>
    53b2:	6a e0       	ldi	r22, 0x0A	; 10
    53b4:	70 e0       	ldi	r23, 0x00	; 0
    53b6:	0e 94 05 37 	call	0x6e0a	; 0x6e0a <__divmodhi4>
    53ba:	d6 2f       	mov	r29, r22
    53bc:	16 2f       	mov	r17, r22
	
	if (number >= 200){
    53be:	28 3c       	cpi	r18, 0xC8	; 200
    53c0:	18 f0       	brcs	.+6      	; 0x53c8 <USBSendNumber+0x36>
		USBSend(KEY_2,LOWER);
    53c2:	60 e0       	ldi	r22, 0x00	; 0
    53c4:	8f e1       	ldi	r24, 0x1F	; 31
    53c6:	04 c0       	rjmp	.+8      	; 0x53d0 <USBSendNumber+0x3e>
	}
	else if (number >= 100){
    53c8:	24 36       	cpi	r18, 0x64	; 100
    53ca:	18 f0       	brcs	.+6      	; 0x53d2 <USBSendNumber+0x40>
		USBSend(KEY_1,LOWER);
    53cc:	60 e0       	ldi	r22, 0x00	; 0
    53ce:	8e e1       	ldi	r24, 0x1E	; 30
    53d0:	0e df       	rcall	.-484    	; 0x51ee <USBSend>
	}
	
	if (tens != 0){
		USBSend(29+tens,LOWER);
    53d2:	60 e0       	ldi	r22, 0x00	; 0
	}
	else if (number >= 100){
		USBSend(KEY_1,LOWER);
	}
	
	if (tens != 0){
    53d4:	11 23       	and	r17, r17
    53d6:	19 f0       	breq	.+6      	; 0x53de <USBSendNumber+0x4c>
		USBSend(29+tens,LOWER);
    53d8:	8d e1       	ldi	r24, 0x1D	; 29
    53da:	8d 0f       	add	r24, r29
    53dc:	01 c0       	rjmp	.+2      	; 0x53e0 <USBSendNumber+0x4e>
	}
	else{
		USBSend(39,LOWER);
    53de:	87 e2       	ldi	r24, 0x27	; 39
    53e0:	06 df       	rcall	.-500    	; 0x51ee <USBSend>
    53e2:	2f ef       	ldi	r18, 0xFF	; 255
    53e4:	80 e7       	ldi	r24, 0x70	; 112
    53e6:	92 e0       	ldi	r25, 0x02	; 2
    53e8:	21 50       	subi	r18, 0x01	; 1
    53ea:	80 40       	sbci	r24, 0x00	; 0
    53ec:	90 40       	sbci	r25, 0x00	; 0
    53ee:	e1 f7       	brne	.-8      	; 0x53e8 <USBSendNumber+0x56>
    53f0:	00 c0       	rjmp	.+0      	; 0x53f2 <USBSendNumber+0x60>
    53f2:	00 00       	nop
	}

	Delay_MS(100);
	
	if (ones!=0){
		USBSend(29+ones,LOWER);
    53f4:	60 e0       	ldi	r22, 0x00	; 0
		USBSend(39,LOWER);
	}

	Delay_MS(100);
	
	if (ones!=0){
    53f6:	cc 23       	and	r28, r28
    53f8:	19 f0       	breq	.+6      	; 0x5400 <USBSendNumber+0x6e>
		USBSend(29+ones,LOWER);
    53fa:	8d e1       	ldi	r24, 0x1D	; 29
    53fc:	8c 0f       	add	r24, r28
    53fe:	01 c0       	rjmp	.+2      	; 0x5402 <USBSendNumber+0x70>
	}
	else{
		USBSend(39,LOWER);
    5400:	87 e2       	ldi	r24, 0x27	; 39
    5402:	f5 de       	rcall	.-534    	; 0x51ee <USBSend>
    5404:	2f ef       	ldi	r18, 0xFF	; 255
    5406:	80 e7       	ldi	r24, 0x70	; 112
    5408:	92 e0       	ldi	r25, 0x02	; 2
    540a:	21 50       	subi	r18, 0x01	; 1
    540c:	80 40       	sbci	r24, 0x00	; 0
    540e:	90 40       	sbci	r25, 0x00	; 0
    5410:	e1 f7       	brne	.-8      	; 0x540a <USBSendNumber+0x78>
    5412:	00 c0       	rjmp	.+0      	; 0x5414 <USBSendNumber+0x82>
    5414:	00 00       	nop
	}
	
	Delay_MS(100);

}
    5416:	df 91       	pop	r29
    5418:	cf 91       	pop	r28
    541a:	1f 91       	pop	r17
    541c:	08 95       	ret

0000541e <USBSendASCII>:

/*Send an ascii character between 0 and 255 over usb)*/
void USBSendASCII(uint8_t number){
    541e:	0f 93       	push	r16
    5420:	1f 93       	push	r17
    5422:	cf 93       	push	r28
    5424:	df 93       	push	r29
    5426:	c8 2f       	mov	r28, r24
	uint8_t ones ;
	uint8_t tens;
	
	ones = number%10;
    5428:	6a e0       	ldi	r22, 0x0A	; 10
    542a:	0e 94 f9 36 	call	0x6df2	; 0x6df2 <__udivmodqi4>
    542e:	d9 2f       	mov	r29, r25
	tens = ((number - ones)%100)/10;
    5430:	8c 2f       	mov	r24, r28
    5432:	90 e0       	ldi	r25, 0x00	; 0
    5434:	8d 1b       	sub	r24, r29
    5436:	91 09       	sbc	r25, r1
    5438:	64 e6       	ldi	r22, 0x64	; 100
    543a:	70 e0       	ldi	r23, 0x00	; 0
    543c:	0e 94 05 37 	call	0x6e0a	; 0x6e0a <__divmodhi4>
    5440:	6a e0       	ldi	r22, 0x0A	; 10
    5442:	70 e0       	ldi	r23, 0x00	; 0
    5444:	0e 94 05 37 	call	0x6e0a	; 0x6e0a <__divmodhi4>
    5448:	16 2f       	mov	r17, r22
    544a:	06 2f       	mov	r16, r22
	
	Hold_Alt_Down = true; //hold down the alt key
    544c:	81 e0       	ldi	r24, 0x01	; 1
    544e:	80 93 6d 06 	sts	0x066D, r24
    5452:	2f ef       	ldi	r18, 0xFF	; 255
    5454:	80 e7       	ldi	r24, 0x70	; 112
    5456:	92 e0       	ldi	r25, 0x02	; 2
    5458:	21 50       	subi	r18, 0x01	; 1
    545a:	80 40       	sbci	r24, 0x00	; 0
    545c:	90 40       	sbci	r25, 0x00	; 0
    545e:	e1 f7       	brne	.-8      	; 0x5458 <USBSendASCII+0x3a>
    5460:	00 c0       	rjmp	.+0      	; 0x5462 <USBSendASCII+0x44>
    5462:	00 00       	nop
	
	Delay_MS(100);
	
	if(number>=0x80){//leading zero indicates utf-8 instead of extended ascii format
    5464:	c7 ff       	sbrs	r28, 7
    5466:	08 c0       	rjmp	.+16     	; 0x5478 <USBSendASCII+0x5a>
		USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT, LOWER); //send a leading 0
    5468:	60 e0       	ldi	r22, 0x00	; 0
    546a:	82 e6       	ldi	r24, 0x62	; 98
    546c:	c0 de       	rcall	.-640    	; 0x51ee <USBSend>
	}
	
	//send hundreds digit
	if (number >= 200){  
    546e:	c8 3c       	cpi	r28, 0xC8	; 200
    5470:	28 f0       	brcs	.+10     	; 0x547c <USBSendASCII+0x5e>
		USBSend(HID_KEYBOARD_SC_KEYPAD_2_AND_DOWN_ARROW,LOWER);
    5472:	60 e0       	ldi	r22, 0x00	; 0
    5474:	8a e5       	ldi	r24, 0x5A	; 90
    5476:	04 c0       	rjmp	.+8      	; 0x5480 <USBSendASCII+0x62>
	}
	else if (number >= 100){
    5478:	c4 36       	cpi	r28, 0x64	; 100
    547a:	18 f0       	brcs	.+6      	; 0x5482 <USBSendASCII+0x64>
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END, LOWER);
    547c:	60 e0       	ldi	r22, 0x00	; 0
    547e:	89 e5       	ldi	r24, 0x59	; 89
    5480:	b6 de       	rcall	.-660    	; 0x51ee <USBSend>
    5482:	2f e7       	ldi	r18, 0x7F	; 127
    5484:	88 e3       	ldi	r24, 0x38	; 56
    5486:	91 e0       	ldi	r25, 0x01	; 1
    5488:	21 50       	subi	r18, 0x01	; 1
    548a:	80 40       	sbci	r24, 0x00	; 0
    548c:	90 40       	sbci	r25, 0x00	; 0
    548e:	e1 f7       	brne	.-8      	; 0x5488 <USBSendASCII+0x6a>
    5490:	00 c0       	rjmp	.+0      	; 0x5492 <USBSendASCII+0x74>
    5492:	00 00       	nop
	}
	Delay_MS(50);
	
	//send tens digit
	if (tens != 0){
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END + tens -1,LOWER); //send 1-9
    5494:	60 e0       	ldi	r22, 0x00	; 0
//		USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT, LOWER);
	}
	Delay_MS(50);
	
	//send tens digit
	if (tens != 0){
    5496:	00 23       	and	r16, r16
    5498:	19 f0       	breq	.+6      	; 0x54a0 <USBSendASCII+0x82>
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END + tens -1,LOWER); //send 1-9
    549a:	88 e5       	ldi	r24, 0x58	; 88
    549c:	81 0f       	add	r24, r17
    549e:	01 c0       	rjmp	.+2      	; 0x54a2 <USBSendASCII+0x84>
	}
	else{
		USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT,LOWER); //send 0
    54a0:	82 e6       	ldi	r24, 0x62	; 98
    54a2:	a5 de       	rcall	.-694    	; 0x51ee <USBSend>
    54a4:	2f e7       	ldi	r18, 0x7F	; 127
    54a6:	88 e3       	ldi	r24, 0x38	; 56
    54a8:	91 e0       	ldi	r25, 0x01	; 1
    54aa:	21 50       	subi	r18, 0x01	; 1
    54ac:	80 40       	sbci	r24, 0x00	; 0
    54ae:	90 40       	sbci	r25, 0x00	; 0
    54b0:	e1 f7       	brne	.-8      	; 0x54aa <USBSendASCII+0x8c>
    54b2:	00 c0       	rjmp	.+0      	; 0x54b4 <USBSendASCII+0x96>
    54b4:	00 00       	nop

	Delay_MS(50);
	
	//send ones digit
	if (ones!=0){
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END + ones -1,LOWER);
    54b6:	60 e0       	ldi	r22, 0x00	; 0
	}

	Delay_MS(50);
	
	//send ones digit
	if (ones!=0){
    54b8:	dd 23       	and	r29, r29
    54ba:	19 f0       	breq	.+6      	; 0x54c2 <USBSendASCII+0xa4>
		USBSend(HID_KEYBOARD_SC_KEYPAD_1_AND_END + ones -1,LOWER);
    54bc:	88 e5       	ldi	r24, 0x58	; 88
    54be:	8d 0f       	add	r24, r29
    54c0:	01 c0       	rjmp	.+2      	; 0x54c4 <USBSendASCII+0xa6>
	}
	else{
		USBSend(HID_KEYBOARD_SC_KEYPAD_0_AND_INSERT,LOWER);
    54c2:	82 e6       	ldi	r24, 0x62	; 98
    54c4:	94 de       	rcall	.-728    	; 0x51ee <USBSend>
    54c6:	2f ef       	ldi	r18, 0xFF	; 255
    54c8:	80 e7       	ldi	r24, 0x70	; 112
    54ca:	92 e0       	ldi	r25, 0x02	; 2
    54cc:	21 50       	subi	r18, 0x01	; 1
    54ce:	80 40       	sbci	r24, 0x00	; 0
    54d0:	90 40       	sbci	r25, 0x00	; 0
    54d2:	e1 f7       	brne	.-8      	; 0x54cc <USBSendASCII+0xae>
    54d4:	00 c0       	rjmp	.+0      	; 0x54d6 <USBSendASCII+0xb8>
    54d6:	00 00       	nop
	}
	
	Delay_MS(100);
	
	//release alt key
	Hold_Alt_Down = false;
    54d8:	10 92 6d 06 	sts	0x066D, r1

}
    54dc:	df 91       	pop	r29
    54de:	cf 91       	pop	r28
    54e0:	1f 91       	pop	r17
    54e2:	0f 91       	pop	r16
    54e4:	08 95       	ret

000054e6 <GetModifier>:

uint8_t GetModifier(){
	uint8_t Modifier = 0;
	bool ShiftIsPressed = false;
	
	switch (Shift_Reed){
    54e6:	80 91 64 06 	lds	r24, 0x0664
    54ea:	82 30       	cpi	r24, 0x02	; 2
    54ec:	99 f0       	breq	.+38     	; 0x5514 <GetModifier+0x2e>
    54ee:	40 f4       	brcc	.+16     	; 0x5500 <GetModifier+0x1a>
    54f0:	81 30       	cpi	r24, 0x01	; 1
    54f2:	09 f5       	brne	.+66     	; 0x5536 <GetModifier+0x50>
	case 0: ShiftIsPressed = false; break;// if shift reed is 0, no shift key has been programed;
	case 1: ShiftIsPressed = (is_high(REED_1) == Reed1Polarity); break; //test if reed_1 is at the active level (high/low) indicated by reed1polarity
    54f4:	89 b1       	in	r24, 0x09	; 9
    54f6:	82 95       	swap	r24
    54f8:	81 70       	andi	r24, 0x01	; 1
    54fa:	90 91 6e 06 	lds	r25, 0x066E
    54fe:	17 c0       	rjmp	.+46     	; 0x552e <GetModifier+0x48>

uint8_t GetModifier(){
	uint8_t Modifier = 0;
	bool ShiftIsPressed = false;
	
	switch (Shift_Reed){
    5500:	83 30       	cpi	r24, 0x03	; 3
    5502:	79 f0       	breq	.+30     	; 0x5522 <GetModifier+0x3c>
    5504:	84 30       	cpi	r24, 0x04	; 4
    5506:	b9 f4       	brne	.+46     	; 0x5536 <GetModifier+0x50>
	case 0: ShiftIsPressed = false; break;// if shift reed is 0, no shift key has been programed;
	case 1: ShiftIsPressed = (is_high(REED_1) == Reed1Polarity); break; //test if reed_1 is at the active level (high/low) indicated by reed1polarity
	case 2: ShiftIsPressed = (is_high(REED_2) == Reed2Polarity); break;
	case 3: ShiftIsPressed = (is_high(REED_3) == Reed3Polarity); break;
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
    5508:	83 b1       	in	r24, 0x03	; 3
    550a:	82 95       	swap	r24
    550c:	81 70       	andi	r24, 0x01	; 1
    550e:	90 91 2e 07 	lds	r25, 0x072E
    5512:	0d c0       	rjmp	.+26     	; 0x552e <GetModifier+0x48>
	bool ShiftIsPressed = false;
	
	switch (Shift_Reed){
	case 0: ShiftIsPressed = false; break;// if shift reed is 0, no shift key has been programed;
	case 1: ShiftIsPressed = (is_high(REED_1) == Reed1Polarity); break; //test if reed_1 is at the active level (high/low) indicated by reed1polarity
	case 2: ShiftIsPressed = (is_high(REED_2) == Reed2Polarity); break;
    5514:	89 b1       	in	r24, 0x09	; 9
    5516:	86 fb       	bst	r24, 6
    5518:	88 27       	eor	r24, r24
    551a:	80 f9       	bld	r24, 0
    551c:	90 91 1c 06 	lds	r25, 0x061C
    5520:	06 c0       	rjmp	.+12     	; 0x552e <GetModifier+0x48>
	case 3: ShiftIsPressed = (is_high(REED_3) == Reed3Polarity); break;
    5522:	89 b1       	in	r24, 0x09	; 9
    5524:	88 1f       	adc	r24, r24
    5526:	88 27       	eor	r24, r24
    5528:	88 1f       	adc	r24, r24
    552a:	90 91 f0 06 	lds	r25, 0x06F0
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
    552e:	89 13       	cpse	r24, r25
    5530:	02 c0       	rjmp	.+4      	; 0x5536 <GetModifier+0x50>
	default: ShiftIsPressed = false;
	}
	
	if(ShiftIsPressed) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTSHIFT;}
    5532:	82 e0       	ldi	r24, 0x02	; 2
    5534:	01 c0       	rjmp	.+2      	; 0x5538 <GetModifier+0x52>

const uint8_t REED_BITS[] = {62,61,60,59}; //these are the bits of the sensor array that represent the reed switches


uint8_t GetModifier(){
	uint8_t Modifier = 0;
    5536:	80 e0       	ldi	r24, 0x00	; 0
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
	default: ShiftIsPressed = false;
	}
	
	if(ShiftIsPressed) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTSHIFT;}
	if(is_low(CTRL_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTCTRL;}
    5538:	7c 9b       	sbis	0x0f, 4	; 15
    553a:	81 60       	ori	r24, 0x01	; 1
	if(is_low(ALT_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTALT;}
    553c:	7d 9b       	sbis	0x0f, 5	; 15
    553e:	84 60       	ori	r24, 0x04	; 4
	if(is_low(CMD_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTGUI;}
    5540:	7e 9b       	sbis	0x0f, 6	; 15
    5542:	88 60       	ori	r24, 0x08	; 8
	
	return Modifier;
}
    5544:	08 95       	ret

00005546 <ReadSensor>:
			return 0; //if no keys or reeds need sending, return 0
		}

}

unsigned long long ReadSensor(){
    5546:	7f 92       	push	r7
    5548:	8f 92       	push	r8
    554a:	9f 92       	push	r9
    554c:	af 92       	push	r10
    554e:	bf 92       	push	r11
    5550:	cf 92       	push	r12
    5552:	df 92       	push	r13
    5554:	ef 92       	push	r14
    5556:	ff 92       	push	r15
    5558:	0f 93       	push	r16
    555a:	1f 93       	push	r17
    555c:	cf 93       	push	r28
    555e:	df 93       	push	r29
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    5560:	f8 94       	cli
		unsigned long long Readout = 0;	
		bool HallReading;
		
		GlobalInterruptDisable();
		set_high(SENSE_CLK);
    5562:	72 9a       	sbi	0x0e, 2	; 14
    5564:	8f ec       	ldi	r24, 0xCF	; 207
    5566:	97 e0       	ldi	r25, 0x07	; 7
    5568:	01 97       	sbiw	r24, 0x01	; 1
    556a:	f1 f7       	brne	.-4      	; 0x5568 <ReadSensor+0x22>
    556c:	00 c0       	rjmp	.+0      	; 0x556e <ReadSensor+0x28>
    556e:	00 00       	nop
		Delay_MS(1); //Sensor board has an LP filter and an inverter on the _LOAD signal.  Wait X ms for the low-pass filter on the _LOAD signal to fire low. 
		set_low(SENSE_CLK);
    5570:	72 98       	cbi	0x0e, 2	; 14
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    5572:	78 94       	sei
    5574:	8f ec       	ldi	r24, 0xCF	; 207
    5576:	97 e0       	ldi	r25, 0x07	; 7
    5578:	01 97       	sbiw	r24, 0x01	; 1
    557a:	f1 f7       	brne	.-4      	; 0x5578 <ReadSensor+0x32>
    557c:	00 c0       	rjmp	.+0      	; 0x557e <ReadSensor+0x38>
    557e:	00 00       	nop
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
    5580:	e1 2c       	mov	r14, r1
    5582:	f1 2c       	mov	r15, r1
		}

}

unsigned long long ReadSensor(){
		unsigned long long Readout = 0;	
    5584:	71 2c       	mov	r7, r1
    5586:	10 e0       	ldi	r17, 0x00	; 0
    5588:	d0 e0       	ldi	r29, 0x00	; 0
    558a:	c0 e0       	ldi	r28, 0x00	; 0
    558c:	b0 e0       	ldi	r27, 0x00	; 0
    558e:	a0 e0       	ldi	r26, 0x00	; 0
    5590:	f0 e0       	ldi	r31, 0x00	; 0
    5592:	e0 e0       	ldi	r30, 0x00	; 0
		set_low(SENSE_CLK);
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
			if (is_low(SENSE_SER)) { 
    5594:	1d 99       	sbic	0x03, 5	; 3
    5596:	13 c0       	rjmp	.+38     	; 0x55be <ReadSensor+0x78>
				longlongbit_set(Readout,i);// if the readout for one of the sensor pins comes back low, that key has been pressed -- store it as a 1 in the readout.
    5598:	21 e0       	ldi	r18, 0x01	; 1
    559a:	30 e0       	ldi	r19, 0x00	; 0
    559c:	40 e0       	ldi	r20, 0x00	; 0
    559e:	50 e0       	ldi	r21, 0x00	; 0
    55a0:	60 e0       	ldi	r22, 0x00	; 0
    55a2:	70 e0       	ldi	r23, 0x00	; 0
    55a4:	80 e0       	ldi	r24, 0x00	; 0
    55a6:	90 e0       	ldi	r25, 0x00	; 0
    55a8:	0e 2d       	mov	r16, r14
    55aa:	0e 94 4c 37 	call	0x6e98	; 0x6e98 <__ashldi3>
    55ae:	72 2a       	or	r7, r18
    55b0:	13 2b       	or	r17, r19
    55b2:	d4 2b       	or	r29, r20
    55b4:	c5 2b       	or	r28, r21
    55b6:	b6 2b       	or	r27, r22
    55b8:	a7 2b       	or	r26, r23
    55ba:	f8 2b       	or	r31, r24
    55bc:	e9 2b       	or	r30, r25
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    55be:	f8 94       	cli
			}	
			
			GlobalInterruptDisable();//if sense clk stays high too long, it could falsely trigger _Load signal.
			set_high(SENSE_CLK);
    55c0:	72 9a       	sbi	0x0e, 2	; 14
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    55c2:	9a e1       	ldi	r25, 0x1A	; 26
    55c4:	9a 95       	dec	r25
    55c6:	f1 f7       	brne	.-4      	; 0x55c4 <ReadSensor+0x7e>
    55c8:	00 c0       	rjmp	.+0      	; 0x55ca <ReadSensor+0x84>
			_delay_us(CLK_POS_PULSE); //delay for the required pulsewidth
			set_low(SENSE_CLK);
    55ca:	72 98       	cbi	0x0e, 2	; 14
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    55cc:	78 94       	sei
    55ce:	8a e6       	ldi	r24, 0x6A	; 106
    55d0:	8a 95       	dec	r24
    55d2:	f1 f7       	brne	.-4      	; 0x55d0 <ReadSensor+0x8a>
    55d4:	00 c0       	rjmp	.+0      	; 0x55d6 <ReadSensor+0x90>
		Delay_MS(1); //Sensor board has an LP filter and an inverter on the _LOAD signal.  Wait X ms for the low-pass filter on the _LOAD signal to fire low. 
		set_low(SENSE_CLK);
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
    55d6:	9f ef       	ldi	r25, 0xFF	; 255
    55d8:	e9 1a       	sub	r14, r25
    55da:	f9 0a       	sbc	r15, r25
    55dc:	80 e3       	ldi	r24, 0x30	; 48
    55de:	e8 16       	cp	r14, r24
    55e0:	f1 04       	cpc	r15, r1
    55e2:	c1 f6       	brne	.-80     	; 0x5594 <ReadSensor+0x4e>

		}
		
		/*The hall effect sensor on the end of the sensor board is only installed in certain cases -
		- its job is to tell if the entire crossbar has moved(active), or if it is at rest (therefore no keys should be detected)*/
		if(UseHallSensor == HALL_ACTIVE){ //when the hall effect sensor is installed and activated
    55e4:	80 91 f1 06 	lds	r24, 0x06F1
    55e8:	82 30       	cpi	r24, 0x02	; 2
    55ea:	e9 f4       	brne	.+58     	; 0x5626 <ReadSensor+0xe0>
			HallReading = Readout & LONGLONGBIT(HALL_SENSOR_BIT); //one of the bits of the sensor readout gives the state of the hall sensor
    55ec:	27 2d       	mov	r18, r7
    55ee:	31 2f       	mov	r19, r17
    55f0:	4d 2f       	mov	r20, r29
    55f2:	5c 2f       	mov	r21, r28
    55f4:	6b 2f       	mov	r22, r27
    55f6:	7a 2f       	mov	r23, r26
    55f8:	8f 2f       	mov	r24, r31
    55fa:	9e 2f       	mov	r25, r30
    55fc:	0c e2       	ldi	r16, 0x2C	; 44
    55fe:	0e 94 67 37 	call	0x6ece	; 0x6ece <__lshrdi3>
    5602:	49 01       	movw	r8, r18
    5604:	91 e0       	ldi	r25, 0x01	; 1
    5606:	89 22       	and	r8, r25
    5608:	99 24       	eor	r9, r9
			if(HallReading != HallSensorPolarity){
    560a:	80 91 6c 06 	lds	r24, 0x066C
    560e:	90 e0       	ldi	r25, 0x00	; 0
    5610:	88 16       	cp	r8, r24
    5612:	99 06       	cpc	r9, r25
    5614:	41 f0       	breq	.+16     	; 0x5626 <ReadSensor+0xe0>
				Readout = 0; //then if the hall effect sensor is not triggered, readout of keys is invalid -- clear it (including the hall sensor bit). 
    5616:	71 2c       	mov	r7, r1
    5618:	10 e0       	ldi	r17, 0x00	; 0
    561a:	d0 e0       	ldi	r29, 0x00	; 0
    561c:	c0 e0       	ldi	r28, 0x00	; 0
    561e:	b0 e0       	ldi	r27, 0x00	; 0
    5620:	a0 e0       	ldi	r26, 0x00	; 0
    5622:	f0 e0       	ldi	r31, 0x00	; 0
    5624:	e0 e0       	ldi	r30, 0x00	; 0
			}
		}

		//add the reed switches to the last 4 bits of the readout array -- if the reed switch is for the shift key, ignore it!
		if (Shift_Reed != 1 && is_high(REED_1)==(bool)Reed1Polarity){ Readout |= LONGLONGBIT(REED_BITS[0]);} //63rd bit of readout (or something like that) represents Reed1
    5626:	80 91 64 06 	lds	r24, 0x0664
    562a:	81 30       	cpi	r24, 0x01	; 1
    562c:	51 f0       	breq	.+20     	; 0x5642 <ReadSensor+0xfc>
    562e:	99 b1       	in	r25, 0x09	; 9
    5630:	92 95       	swap	r25
    5632:	91 70       	andi	r25, 0x01	; 1
    5634:	20 91 6e 06 	lds	r18, 0x066E
    5638:	92 13       	cpse	r25, r18
    563a:	01 c0       	rjmp	.+2      	; 0x563e <ReadSensor+0xf8>
    563c:	e0 64       	ori	r30, 0x40	; 64
		if (Shift_Reed != 2 && is_high(REED_2)==(bool)Reed2Polarity){ Readout |= LONGLONGBIT(REED_BITS[1]);} //62nd bit of readout (or something like that) represents Reed2
    563e:	82 30       	cpi	r24, 0x02	; 2
    5640:	59 f0       	breq	.+22     	; 0x5658 <ReadSensor+0x112>
    5642:	99 b1       	in	r25, 0x09	; 9
    5644:	96 fb       	bst	r25, 6
    5646:	99 27       	eor	r25, r25
    5648:	90 f9       	bld	r25, 0
    564a:	20 91 1c 06 	lds	r18, 0x061C
    564e:	92 13       	cpse	r25, r18
    5650:	01 c0       	rjmp	.+2      	; 0x5654 <ReadSensor+0x10e>
    5652:	e0 62       	ori	r30, 0x20	; 32
		if (Shift_Reed != 3 && is_high(REED_3)==(bool)Reed3Polarity){ Readout |= LONGLONGBIT(REED_BITS[2]);} //61st bit of readout (or something like that) represents Reed3
    5654:	83 30       	cpi	r24, 0x03	; 3
    5656:	59 f0       	breq	.+22     	; 0x566e <ReadSensor+0x128>
    5658:	99 b1       	in	r25, 0x09	; 9
    565a:	99 1f       	adc	r25, r25
    565c:	99 27       	eor	r25, r25
    565e:	99 1f       	adc	r25, r25
    5660:	20 91 f0 06 	lds	r18, 0x06F0
    5664:	92 13       	cpse	r25, r18
    5666:	01 c0       	rjmp	.+2      	; 0x566a <ReadSensor+0x124>
    5668:	e0 61       	ori	r30, 0x10	; 16
		if (Shift_Reed != 4 && is_high(REED_4)==(bool)Reed4Polarity){ Readout |= LONGLONGBIT(REED_BITS[3]);} //60th bit of readout (or something like that) represents Reed4
    566a:	84 30       	cpi	r24, 0x04	; 4
    566c:	41 f0       	breq	.+16     	; 0x567e <ReadSensor+0x138>
    566e:	83 b1       	in	r24, 0x03	; 3
    5670:	82 95       	swap	r24
    5672:	81 70       	andi	r24, 0x01	; 1
    5674:	90 91 2e 07 	lds	r25, 0x072E
    5678:	89 13       	cpse	r24, r25
    567a:	01 c0       	rjmp	.+2      	; 0x567e <ReadSensor+0x138>
    567c:	e8 60       	ori	r30, 0x08	; 8
		
		return Readout;
}
    567e:	27 2d       	mov	r18, r7
    5680:	31 2f       	mov	r19, r17
    5682:	4d 2f       	mov	r20, r29
    5684:	5c 2f       	mov	r21, r28
    5686:	6b 2f       	mov	r22, r27
    5688:	7a 2f       	mov	r23, r26
    568a:	8f 2f       	mov	r24, r31
    568c:	9e 2f       	mov	r25, r30
    568e:	df 91       	pop	r29
    5690:	cf 91       	pop	r28
    5692:	1f 91       	pop	r17
    5694:	0f 91       	pop	r16
    5696:	ff 90       	pop	r15
    5698:	ef 90       	pop	r14
    569a:	df 90       	pop	r13
    569c:	cf 90       	pop	r12
    569e:	bf 90       	pop	r11
    56a0:	af 90       	pop	r10
    56a2:	9f 90       	pop	r9
    56a4:	8f 90       	pop	r8
    56a6:	7f 90       	pop	r7
    56a8:	08 95       	ret

000056aa <GetKeySimple>:
	if(is_low(CMD_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTGUI;}
	
	return Modifier;
}

uint8_t GetKeySimple(){
    56aa:	ff 92       	push	r15
    56ac:	0f 93       	push	r16
    56ae:	1f 93       	push	r17
    56b0:	cf 93       	push	r28
    56b2:	df 93       	push	r29
	unsigned long long SensorReadout; //create 64-bit "long long" binary variable and set it all to 0s.
	uint8_t Key;
	
	Key=0;//by default, there is no key to send, unless one is detected later.
	
	SensorReadout = ReadSensor();
    56b4:	48 df       	rcall	.-368    	; 0x5546 <ReadSensor>
    56b6:	f2 2e       	mov	r15, r18
    56b8:	03 2f       	mov	r16, r19
    56ba:	14 2f       	mov	r17, r20
    56bc:	d5 2f       	mov	r29, r21
    56be:	c6 2f       	mov	r28, r22
    56c0:	e7 2f       	mov	r30, r23
    56c2:	b8 2f       	mov	r27, r24
    56c4:	f9 2f       	mov	r31, r25
	if(UseHallSensor != HALL_NOT_PRESENT){
    56c6:	80 91 f1 06 	lds	r24, 0x06F1
    56ca:	81 11       	cpse	r24, r1
		SensorReadout &= ~LONGLONGBIT(HALL_SENSOR_BIT); //discard the hall effect bit of the array -- it is not an actual key, so don't report it as one.
    56cc:	ef 7e       	andi	r30, 0xEF	; 239
	}

	if(SensorReadout){
    56ce:	2f 2d       	mov	r18, r15
    56d0:	30 2f       	mov	r19, r16
    56d2:	41 2f       	mov	r20, r17
    56d4:	5d 2f       	mov	r21, r29
    56d6:	6c 2f       	mov	r22, r28
    56d8:	7e 2f       	mov	r23, r30
    56da:	8b 2f       	mov	r24, r27
    56dc:	9f 2f       	mov	r25, r31
    56de:	a0 e0       	ldi	r26, 0x00	; 0
    56e0:	0e 94 83 37 	call	0x6f06	; 0x6f06 <__cmpdi2_s8>
    56e4:	19 f0       	breq	.+6      	; 0x56ec <GetKeySimple+0x42>
		Key = (uint8_t) __builtin_clzll(SensorReadout); //this function finds the first nonzero bit in the bitfield SensorReadout (by counting leading zeros)
    56e6:	0e 94 44 37 	call	0x6e88	; 0x6e88 <__clzdi2>
    56ea:	01 c0       	rjmp	.+2      	; 0x56ee <GetKeySimple+0x44>
	}
	else{
		Key = 0;
    56ec:	80 e0       	ldi	r24, 0x00	; 0
	}
	return  Key;
	
}
    56ee:	df 91       	pop	r29
    56f0:	cf 91       	pop	r28
    56f2:	1f 91       	pop	r17
    56f4:	0f 91       	pop	r16
    56f6:	ff 90       	pop	r15
    56f8:	08 95       	ret

000056fa <GetKey>:
	
uint8_t GetKey(){
    56fa:	2f 92       	push	r2
    56fc:	3f 92       	push	r3
    56fe:	4f 92       	push	r4
    5700:	5f 92       	push	r5
    5702:	6f 92       	push	r6
    5704:	7f 92       	push	r7
    5706:	8f 92       	push	r8
    5708:	9f 92       	push	r9
    570a:	af 92       	push	r10
    570c:	bf 92       	push	r11
    570e:	cf 92       	push	r12
    5710:	df 92       	push	r13
    5712:	ef 92       	push	r14
    5714:	ff 92       	push	r15
    5716:	0f 93       	push	r16
    5718:	1f 93       	push	r17
    571a:	cf 93       	push	r28
    571c:	df 93       	push	r29
    571e:	00 d0       	rcall	.+0      	; 0x5720 <GetKey+0x26>
    5720:	1f 92       	push	r1
    5722:	cd b7       	in	r28, 0x3d	; 61
    5724:	de b7       	in	r29, 0x3e	; 62
		bool OKtoSendReed = false; //go ahead to send a reed switch
		
		uint8_t ReedToSend = 0;
	
/*READ INPUT FROM SENSOR STRIP*/	
		SensorReadout = ReadSensor();
    5726:	0f df       	rcall	.-482    	; 0x5546 <ReadSensor>
    5728:	49 01       	movw	r8, r18
    572a:	14 2f       	mov	r17, r20
    572c:	59 83       	std	Y+1, r21	; 0x01
    572e:	f6 2f       	mov	r31, r22
    5730:	e7 2f       	mov	r30, r23
    5732:	48 2e       	mov	r4, r24
    5734:	39 2e       	mov	r3, r25
		
		if (UseHallSensor != HALL_NOT_PRESENT){ //if the user has not installed the hall sensor, don't do this part.
    5736:	80 91 f1 06 	lds	r24, 0x06F1
    573a:	81 11       	cpse	r24, r1
			SensorReadout &= ~LONGLONGBIT(HALL_SENSOR_BIT); //after detecting it, discard the hall effect bit of the array -- it is not an actual key, so don't report it as one.
    573c:	ef 7e       	andi	r30, 0xEF	; 239
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
			int reednumber = i+1;
			int j;
			
			if (Reeds_Are_Independent) j = i; //
    573e:	50 90 1e 06 	lds	r5, 0x061E
			else j = 0; //setting j = 0 means "If any reed is active, all reeds are considered active also (and are therefore won't be sent when pressed)
			
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
				if (ReedDebounce[i] < ReedHoldTime){//increment the debounce entry if not already maxed out.
    5742:	20 90 62 06 	lds	r2, 0x0662
    5746:	85 ef       	ldi	r24, 0xF5	; 245
    5748:	e8 2e       	mov	r14, r24
    574a:	85 e0       	ldi	r24, 0x05	; 5
    574c:	f8 2e       	mov	r15, r24
    574e:	9d ef       	ldi	r25, 0xFD	; 253
    5750:	a9 2e       	mov	r10, r25
    5752:	92 e0       	ldi	r25, 0x02	; 2
    5754:	b9 2e       	mov	r11, r25
    5756:	c1 2c       	mov	r12, r1
    5758:	d1 2c       	mov	r13, r1
		static uint8_t ReedDebounce[4]; //array tracking the debounce times of all four reed switches.  
		
		bool OKtoSendKey = false; //non static bool that gives the go-ahead to send a key over the usb/bluetooth bus.  Indicates that the key has been pressed first time.
		bool OKtoSendReed = false; //go ahead to send a reed switch
		
		uint8_t ReedToSend = 0;
    575a:	71 2c       	mov	r7, r1
		static uint8_t KeyReleaseCounter;
		static bool ActiveReeds[4];//array showing all currently active reeds.
		static uint8_t ReedDebounce[4]; //array tracking the debounce times of all four reed switches.  
		
		bool OKtoSendKey = false; //non static bool that gives the go-ahead to send a key over the usb/bluetooth bus.  Indicates that the key has been pressed first time.
		bool OKtoSendReed = false; //go ahead to send a reed switch
    575c:	61 2c       	mov	r6, r1
/*READ AND DEBOUNCE REED SWITCH INPUTS*/

		/*Detect which reeds have been pressed, and if they have been sent to the host already or if they still need to be*/
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
			int reednumber = i+1;
    575e:	db 82       	std	Y+3, r13	; 0x03
    5760:	ca 82       	std	Y+2, r12	; 0x02
			int j;
			
			if (Reeds_Are_Independent) j = i; //
    5762:	51 10       	cpse	r5, r1
    5764:	02 c0       	rjmp	.+4      	; 0x576a <GetKey+0x70>
			else j = 0; //setting j = 0 means "If any reed is active, all reeds are considered active also (and are therefore won't be sent when pressed)
    5766:	1b 82       	std	Y+3, r1	; 0x03
    5768:	1a 82       	std	Y+2, r1	; 0x02
			
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
    576a:	d5 01       	movw	r26, r10
    576c:	0d 91       	ld	r16, X+
    576e:	5d 01       	movw	r10, r26
    5770:	bf ef       	ldi	r27, 0xFF	; 255
    5772:	cb 1a       	sub	r12, r27
    5774:	db 0a       	sbc	r13, r27
    5776:	94 01       	movw	r18, r8
    5778:	41 2f       	mov	r20, r17
    577a:	59 81       	ldd	r21, Y+1	; 0x01
    577c:	6f 2f       	mov	r22, r31
    577e:	7e 2f       	mov	r23, r30
    5780:	84 2d       	mov	r24, r4
    5782:	93 2d       	mov	r25, r3
    5784:	0e 94 67 37 	call	0x6ece	; 0x6ece <__lshrdi3>
    5788:	21 70       	andi	r18, 0x01	; 1
    578a:	30 e0       	ldi	r19, 0x00	; 0
    578c:	40 e0       	ldi	r20, 0x00	; 0
    578e:	50 e0       	ldi	r21, 0x00	; 0
    5790:	60 e0       	ldi	r22, 0x00	; 0
    5792:	70 e0       	ldi	r23, 0x00	; 0
    5794:	80 e0       	ldi	r24, 0x00	; 0
    5796:	90 e0       	ldi	r25, 0x00	; 0
    5798:	a0 e0       	ldi	r26, 0x00	; 0
    579a:	0e 94 83 37 	call	0x6f06	; 0x6f06 <__cmpdi2_s8>
    579e:	99 f0       	breq	.+38     	; 0x57c6 <GetKey+0xcc>
				if (ReedDebounce[i] < ReedHoldTime){//increment the debounce entry if not already maxed out.
    57a0:	d7 01       	movw	r26, r14
    57a2:	8c 91       	ld	r24, X
    57a4:	82 15       	cp	r24, r2
    57a6:	10 f4       	brcc	.+4      	; 0x57ac <GetKey+0xb2>
					ReedDebounce[i] ++;
    57a8:	8f 5f       	subi	r24, 0xFF	; 255
    57aa:	31 c0       	rjmp	.+98     	; 0x580e <GetKey+0x114>
				} 
				else if (!ActiveReeds[j]){ //if the debounce has reached KeyHoldTime, but the reed isn't already listed as active
    57ac:	aa 81       	ldd	r26, Y+2	; 0x02
    57ae:	bb 81       	ldd	r27, Y+3	; 0x03
    57b0:	af 50       	subi	r26, 0x0F	; 15
    57b2:	ba 4f       	sbci	r27, 0xFA	; 250
    57b4:	8c 91       	ld	r24, X
    57b6:	81 11       	cpse	r24, r1
    57b8:	2b c0       	rjmp	.+86     	; 0x5810 <GetKey+0x116>
						ActiveReeds[j] = true; //then list it as active.
    57ba:	81 e0       	ldi	r24, 0x01	; 1
    57bc:	8c 93       	st	X, r24
						ReedToSend = reednumber; //code 1,2,3, or 4 indicates which reed has been pressed
    57be:	7c 2c       	mov	r7, r12
						OKtoSendReed = true;//and tell the routine to send it
    57c0:	66 24       	eor	r6, r6
    57c2:	63 94       	inc	r6
    57c4:	25 c0       	rjmp	.+74     	; 0x5810 <GetKey+0x116>
				}
			} 
			else if (Reeds_Are_Independent){//if the reed is not detected, and we are tracking them separately.
    57c6:	55 20       	and	r5, r5
    57c8:	39 f0       	breq	.+14     	; 0x57d8 <GetKey+0xde>
				if(ReedDebounce[i] == 0) ActiveReeds[j] = false; //then if the debounce counter has run down, consider the reed to be released.
    57ca:	d7 01       	movw	r26, r14
    57cc:	8c 91       	ld	r24, X
    57ce:	88 23       	and	r24, r24
    57d0:	99 f0       	breq	.+38     	; 0x57f8 <GetKey+0xfe>
				else ReedDebounce[i]--; //if not already zero, decrement the counter
    57d2:	81 50       	subi	r24, 0x01	; 1
    57d4:	d7 01       	movw	r26, r14
    57d6:	1b c0       	rjmp	.+54     	; 0x580e <GetKey+0x114>
			}
			else if (!Reeds_Are_Independent){ //if reeds are not considered independent, all reeds must be released before another can fire.
				if((ReedDebounce[0] == 0)&&(ReedDebounce[1] == 0)&&(ReedDebounce[2]== 0)&&(ReedDebounce[3]==0)){ //so wait for all reeds to be released
    57d8:	80 91 f5 05 	lds	r24, 0x05F5
    57dc:	81 11       	cpse	r24, r1
    57de:	12 c0       	rjmp	.+36     	; 0x5804 <GetKey+0x10a>
    57e0:	80 91 f6 05 	lds	r24, 0x05F6
    57e4:	81 11       	cpse	r24, r1
    57e6:	0e c0       	rjmp	.+28     	; 0x5804 <GetKey+0x10a>
    57e8:	80 91 f7 05 	lds	r24, 0x05F7
    57ec:	81 11       	cpse	r24, r1
    57ee:	0a c0       	rjmp	.+20     	; 0x5804 <GetKey+0x10a>
    57f0:	80 91 f8 05 	lds	r24, 0x05F8
    57f4:	81 11       	cpse	r24, r1
    57f6:	06 c0       	rjmp	.+12     	; 0x5804 <GetKey+0x10a>
					ActiveReeds[j] = false; // only if all reeds are released do we allow a new reed to be pressed.
    57f8:	aa 81       	ldd	r26, Y+2	; 0x02
    57fa:	bb 81       	ldd	r27, Y+3	; 0x03
    57fc:	af 50       	subi	r26, 0x0F	; 15
    57fe:	ba 4f       	sbci	r27, 0xFA	; 250
    5800:	1c 92       	st	X, r1
    5802:	06 c0       	rjmp	.+12     	; 0x5810 <GetKey+0x116>
				}
				else if (ReedDebounce[i]) {ReedDebounce[i]--;} //decrement debounce counter for this reed.
    5804:	d7 01       	movw	r26, r14
    5806:	8c 91       	ld	r24, X
    5808:	88 23       	and	r24, r24
    580a:	11 f0       	breq	.+4      	; 0x5810 <GetKey+0x116>
    580c:	81 50       	subi	r24, 0x01	; 1
    580e:	8c 93       	st	X, r24
    5810:	bf ef       	ldi	r27, 0xFF	; 255
    5812:	eb 1a       	sub	r14, r27
    5814:	fb 0a       	sbc	r15, r27
		
/*READ AND DEBOUNCE REED SWITCH INPUTS*/

		/*Detect which reeds have been pressed, and if they have been sent to the host already or if they still need to be*/
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
    5816:	84 e0       	ldi	r24, 0x04	; 4
    5818:	c8 16       	cp	r12, r24
    581a:	d1 04       	cpc	r13, r1
    581c:	09 f0       	breq	.+2      	; 0x5820 <GetKey+0x126>
    581e:	9f cf       	rjmp	.-194    	; 0x575e <GetKey+0x64>
		

		

/*APPLY VARIOUS MASKS TO SIMPLIFY SENSOR READOUT*/	
		SensorReadout = SensorReadout & KEY_SENSOR_MASK;//discard the reed switch bits and the sensor bit -- look only at the key sensor contacts.
    5820:	f9 80       	ldd	r15, Y+1	; 0x01
		if (SensorReadout == KEY_SENSOR_MASK){
    5822:	94 01       	movw	r18, r8
    5824:	41 2f       	mov	r20, r17
    5826:	5f 2d       	mov	r21, r15
    5828:	6f 2f       	mov	r22, r31
    582a:	7e 2f       	mov	r23, r30
    582c:	80 e0       	ldi	r24, 0x00	; 0
    582e:	90 e0       	ldi	r25, 0x00	; 0
    5830:	2f 3f       	cpi	r18, 0xFF	; 255
    5832:	af ef       	ldi	r26, 0xFF	; 255
    5834:	3a 07       	cpc	r19, r26
    5836:	4a 07       	cpc	r20, r26
    5838:	5a 07       	cpc	r21, r26
    583a:	6a 07       	cpc	r22, r26
    583c:	7a 07       	cpc	r23, r26
    583e:	81 05       	cpc	r24, r1
    5840:	91 05       	cpc	r25, r1
    5842:	09 f4       	brne	.+2      	; 0x5846 <GetKey+0x14c>
    5844:	55 c0       	rjmp	.+170    	; 0x58f0 <GetKey+0x1f6>
			SensorReadout = 0;// if masked sensor readout is all ones, sensor is probably not plugged in -- discard.
		}
		else if(ActiveKey){
    5846:	80 91 f0 05 	lds	r24, 0x05F0
    584a:	88 23       	and	r24, r24
    584c:	79 f0       	breq	.+30     	; 0x586c <GetKey+0x172>
			SensorReadout = (SensorReadout & KEYMASK(ActiveKey)); //if a key was detected last time, mask all others -- only look at that key this time -- prevents confusion from multiple keys.
    584e:	af e3       	ldi	r26, 0x3F	; 63
    5850:	b0 e0       	ldi	r27, 0x00	; 0
    5852:	a8 1b       	sub	r26, r24
    5854:	b1 09       	sbc	r27, r1
    5856:	21 e0       	ldi	r18, 0x01	; 1
    5858:	30 e0       	ldi	r19, 0x00	; 0
    585a:	40 e0       	ldi	r20, 0x00	; 0
    585c:	50 e0       	ldi	r21, 0x00	; 0
    585e:	60 e0       	ldi	r22, 0x00	; 0
    5860:	70 e0       	ldi	r23, 0x00	; 0
    5862:	80 e0       	ldi	r24, 0x00	; 0
    5864:	0a 2f       	mov	r16, r26
    5866:	0e 94 4c 37 	call	0x6e98	; 0x6e98 <__ashldi3>
    586a:	27 c0       	rjmp	.+78     	; 0x58ba <GetKey+0x1c0>
		}
		else if(PreviousKey){ //if no key was detected, but a key was recently detected (maybe it was just released, or maybe it bounced off)
    586c:	90 91 ef 05 	lds	r25, 0x05EF
    5870:	99 23       	and	r25, r25
    5872:	49 f1       	breq	.+82     	; 0x58c6 <GetKey+0x1cc>
			DoubleTapCounter++;
    5874:	80 91 ee 05 	lds	r24, 0x05EE
    5878:	8f 5f       	subi	r24, 0xFF	; 255
    587a:	80 93 ee 05 	sts	0x05EE, r24
			if (DoubleTapCounter >= DoubleTapTime){ //once the double tap timer has expired, reset everything and stop ignoring previous key.
    587e:	20 91 63 06 	lds	r18, 0x0663
    5882:	82 17       	cp	r24, r18
    5884:	28 f0       	brcs	.+10     	; 0x5890 <GetKey+0x196>
				DoubleTapCounter = 0;
    5886:	10 92 ee 05 	sts	0x05EE, r1
				PreviousKey = 0; 
    588a:	10 92 ef 05 	sts	0x05EF, r1
    588e:	1b c0       	rjmp	.+54     	; 0x58c6 <GetKey+0x1cc>
			}		
			else{ //if timer has not expired yet, ignore the previous key pressed.
				SensorReadout = (SensorReadout & ~KEYMASK(PreviousKey)); //whatever the previous active key pressed was, ignore it.
    5890:	af e3       	ldi	r26, 0x3F	; 63
    5892:	b0 e0       	ldi	r27, 0x00	; 0
    5894:	a9 1b       	sub	r26, r25
    5896:	b1 09       	sbc	r27, r1
    5898:	21 e0       	ldi	r18, 0x01	; 1
    589a:	30 e0       	ldi	r19, 0x00	; 0
    589c:	40 e0       	ldi	r20, 0x00	; 0
    589e:	50 e0       	ldi	r21, 0x00	; 0
    58a0:	60 e0       	ldi	r22, 0x00	; 0
    58a2:	70 e0       	ldi	r23, 0x00	; 0
    58a4:	80 e0       	ldi	r24, 0x00	; 0
    58a6:	90 e0       	ldi	r25, 0x00	; 0
    58a8:	0a 2f       	mov	r16, r26
    58aa:	0e 94 4c 37 	call	0x6e98	; 0x6e98 <__ashldi3>
    58ae:	20 95       	com	r18
    58b0:	30 95       	com	r19
    58b2:	40 95       	com	r20
    58b4:	50 95       	com	r21
    58b6:	60 95       	com	r22
    58b8:	70 95       	com	r23
    58ba:	82 22       	and	r8, r18
    58bc:	93 22       	and	r9, r19
    58be:	14 23       	and	r17, r20
    58c0:	f5 22       	and	r15, r21
    58c2:	f6 23       	and	r31, r22
    58c4:	e7 23       	and	r30, r23
			}
		}
		
/*DETERMINE WHICH CONTACT, IF ANY, HAS DETECTED A KEY THIS ROUND*/	
		if(SensorReadout){ //if sensor readout is not all zeros
    58c6:	94 01       	movw	r18, r8
    58c8:	41 2f       	mov	r20, r17
    58ca:	5f 2d       	mov	r21, r15
    58cc:	6f 2f       	mov	r22, r31
    58ce:	7e 2f       	mov	r23, r30
    58d0:	80 e0       	ldi	r24, 0x00	; 0
    58d2:	90 e0       	ldi	r25, 0x00	; 0
    58d4:	a0 e0       	ldi	r26, 0x00	; 0
    58d6:	0e 94 83 37 	call	0x6f06	; 0x6f06 <__cmpdi2_s8>
    58da:	51 f0       	breq	.+20     	; 0x58f0 <GetKey+0x1f6>
			DetectedKey = (uint8_t) __builtin_clzll(SensorReadout); //get the position of the first "one" in the sparse key detection array 
    58dc:	0e 94 44 37 	call	0x6e88	; 0x6e88 <__clzdi2>
			DetectedKey = 0;
		}
		
/*DEBOUNCE KEY READING*/
		if(DetectedKey){//if there is a detected key this time,
			 KeyHoldCounter++;  
    58e0:	90 91 ed 05 	lds	r25, 0x05ED
    58e4:	9f 5f       	subi	r25, 0xFF	; 255
    58e6:	90 93 ed 05 	sts	0x05ED, r25
			 KeyReleaseCounter=0;		 
    58ea:	10 92 ec 05 	sts	0x05EC, r1
    58ee:	08 c0       	rjmp	.+16     	; 0x5900 <GetKey+0x206>
		}
		else {
			KeyReleaseCounter++; 
    58f0:	80 91 ec 05 	lds	r24, 0x05EC
    58f4:	8f 5f       	subi	r24, 0xFF	; 255
    58f6:	80 93 ec 05 	sts	0x05EC, r24
			KeyHoldCounter = 0;  
    58fa:	10 92 ed 05 	sts	0x05ED, r1
    58fe:	80 e0       	ldi	r24, 0x00	; 0
		}
		
		if (KeyHoldCounter >= KeyHoldTime){
    5900:	90 91 af 06 	lds	r25, 0x06AF
    5904:	20 91 ed 05 	lds	r18, 0x05ED
    5908:	29 17       	cp	r18, r25
    590a:	58 f0       	brcs	.+22     	; 0x5922 <GetKey+0x228>
			KeyHoldCounter = KeyHoldTime; // can't get higher than keyholdtime
    590c:	90 93 ed 05 	sts	0x05ED, r25
			if (DetectedKey != ActiveKey){ // if this is a new active key (just pressed) then set the active key to the new value, and give go-ahead to send it.
    5910:	90 91 f0 05 	lds	r25, 0x05F0
    5914:	89 17       	cp	r24, r25
    5916:	b1 f0       	breq	.+44     	; 0x5944 <GetKey+0x24a>
				ActiveKey = DetectedKey; //the current key is the new active key
    5918:	80 93 f0 05 	sts	0x05F0, r24
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
    591c:	66 20       	and	r6, r6
    591e:	a9 f0       	breq	.+42     	; 0x594a <GetKey+0x250>
    5920:	0f c0       	rjmp	.+30     	; 0x5940 <GetKey+0x246>
			if (DetectedKey != ActiveKey){ // if this is a new active key (just pressed) then set the active key to the new value, and give go-ahead to send it.
				ActiveKey = DetectedKey; //the current key is the new active key
				OKtoSendKey = true;
			}
		}
		else if (KeyReleaseCounter >= KeyReleaseTime){
    5922:	80 91 20 06 	lds	r24, 0x0620
    5926:	90 91 ec 05 	lds	r25, 0x05EC
    592a:	98 17       	cp	r25, r24
    592c:	58 f0       	brcs	.+22     	; 0x5944 <GetKey+0x24a>
			KeyReleaseCounter = KeyReleaseTime; //
    592e:	80 93 ec 05 	sts	0x05EC, r24
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
    5932:	80 91 f0 05 	lds	r24, 0x05F0
    5936:	80 93 ef 05 	sts	0x05EF, r24
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
    593a:	10 92 f0 05 	sts	0x05F0, r1
    593e:	02 c0       	rjmp	.+4      	; 0x5944 <GetKey+0x24a>
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
			return ReedToSend;
    5940:	87 2d       	mov	r24, r7
    5942:	03 c0       	rjmp	.+6      	; 0x594a <GetKey+0x250>
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
    5944:	61 10       	cpse	r6, r1
    5946:	fc cf       	rjmp	.-8      	; 0x5940 <GetKey+0x246>
		}
		else if(OKtoSendKey){ //otherwise, if there is a key to send, report it
			return ActiveKey; 
		}
		else{
			return 0; //if no keys or reeds need sending, return 0
    5948:	80 e0       	ldi	r24, 0x00	; 0
		}

}
    594a:	0f 90       	pop	r0
    594c:	0f 90       	pop	r0
    594e:	0f 90       	pop	r0
    5950:	df 91       	pop	r29
    5952:	cf 91       	pop	r28
    5954:	1f 91       	pop	r17
    5956:	0f 91       	pop	r16
    5958:	ff 90       	pop	r15
    595a:	ef 90       	pop	r14
    595c:	df 90       	pop	r13
    595e:	cf 90       	pop	r12
    5960:	bf 90       	pop	r11
    5962:	af 90       	pop	r10
    5964:	9f 90       	pop	r9
    5966:	8f 90       	pop	r8
    5968:	7f 90       	pop	r7
    596a:	6f 90       	pop	r6
    596c:	5f 90       	pop	r5
    596e:	4f 90       	pop	r4
    5970:	3f 90       	pop	r3
    5972:	2f 90       	pop	r2
    5974:	08 95       	ret

00005976 <GetHIDKeyCode>:
		if (Shift_Reed != 4 && is_high(REED_4)==(bool)Reed4Polarity){ Readout |= LONGLONGBIT(REED_BITS[3]);} //60th bit of readout (or something like that) represents Reed4
		
		return Readout;
}

uint8_t GetHIDKeyCode(uint8_t key, uint8_t* modifier){ 
    5976:	fb 01       	movw	r30, r22
	uint8_t code;

	if ((*modifier & HID_KEYBOARD_MODIFIER_LEFTALT) && FnKeyCodeLookUpTable[key]){ //if the FN key is held down, look up key in FN array.
    5978:	90 81       	ld	r25, Z
    597a:	28 2f       	mov	r18, r24
    597c:	30 e0       	ldi	r19, 0x00	; 0
    597e:	92 ff       	sbrs	r25, 2
    5980:	08 c0       	rjmp	.+16     	; 0x5992 <GetHIDKeyCode+0x1c>
    5982:	d9 01       	movw	r26, r18
    5984:	a0 59       	subi	r26, 0x90	; 144
    5986:	b6 4f       	sbci	r27, 0xF6	; 246
    5988:	8c 91       	ld	r24, X
    598a:	88 23       	and	r24, r24
    598c:	11 f0       	breq	.+4      	; 0x5992 <GetHIDKeyCode+0x1c>
		code = FnKeyCodeLookUpTable[key];
		*modifier &= ~HID_KEYBOARD_MODIFIER_LEFTALT;// if the key is in the function table, it is a special key.  The alt modifier should not be sent..
    598e:	9b 7f       	andi	r25, 0xFB	; 251
    5990:	09 c0       	rjmp	.+18     	; 0x59a4 <GetHIDKeyCode+0x2e>

	}
	else if ((*modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT) && ShiftKeyCodeLookUpTable[key]){
    5992:	91 ff       	sbrs	r25, 1
    5994:	09 c0       	rjmp	.+18     	; 0x59a8 <GetHIDKeyCode+0x32>
    5996:	d9 01       	movw	r26, r18
    5998:	a1 59       	subi	r26, 0x91	; 145
    599a:	b9 4f       	sbci	r27, 0xF9	; 249
    599c:	8c 91       	ld	r24, X
    599e:	88 23       	and	r24, r24
    59a0:	19 f0       	breq	.+6      	; 0x59a8 <GetHIDKeyCode+0x32>
		code = ShiftKeyCodeLookUpTable[key];
		*modifier &= ~HID_KEYBOARD_MODIFIER_LEFTSHIFT;// if the key is in the shift table, it is a special key.  The shift modifier should not be sent..
    59a2:	9d 7f       	andi	r25, 0xFD	; 253
    59a4:	90 83       	st	Z, r25
    59a6:	08 95       	ret
	}
	else {
		code = KeyCodeLookUpTable[key]; //otherwise, look up the key in the regular array.
    59a8:	f9 01       	movw	r30, r18
    59aa:	ee 5d       	subi	r30, 0xDE	; 222
    59ac:	f9 4f       	sbci	r31, 0xF9	; 249
    59ae:	80 81       	ld	r24, Z
	}
	return code;
}
    59b0:	08 95       	ret

000059b2 <GetASCIIKeyCode>:

uint8_t GetASCIIKeyCode(uint8_t key, uint8_t modifier){
	uint8_t code;
	
	if(key == 0){
    59b2:	88 23       	and	r24, r24
    59b4:	79 f0       	breq	.+30     	; 0x59d4 <GetASCIIKeyCode+0x22>
    59b6:	28 2f       	mov	r18, r24
    59b8:	30 e0       	ldi	r19, 0x00	; 0
		return 0;
	}
	
	if ((modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT) && ASCIIShiftLookUpTable[key]){
    59ba:	61 ff       	sbrs	r22, 1
    59bc:	06 c0       	rjmp	.+12     	; 0x59ca <GetASCIIKeyCode+0x18>
    59be:	f9 01       	movw	r30, r18
    59c0:	e0 55       	subi	r30, 0x50	; 80
    59c2:	f9 4f       	sbci	r31, 0xF9	; 249
    59c4:	80 81       	ld	r24, Z
    59c6:	81 11       	cpse	r24, r1
    59c8:	06 c0       	rjmp	.+12     	; 0x59d6 <GetASCIIKeyCode+0x24>
		code = ASCIIShiftLookUpTable[key];
		}
	else {
		code = ASCIILookUpTable[key];
    59ca:	f9 01       	movw	r30, r18
    59cc:	e1 5d       	subi	r30, 0xD1	; 209
    59ce:	f8 4f       	sbci	r31, 0xF8	; 248
    59d0:	80 81       	ld	r24, Z
    59d2:	08 95       	ret

uint8_t GetASCIIKeyCode(uint8_t key, uint8_t modifier){
	uint8_t code;
	
	if(key == 0){
		return 0;
    59d4:	80 e0       	ldi	r24, 0x00	; 0
		}
	else {
		code = ASCIILookUpTable[key];
	}
	return code;
}
    59d6:	08 95       	ret

000059d8 <getHallState>:

bool getHallState(){ //don't call this function from inside ReadSensor !  It will cause an infinite loop...
    59d8:	0f 93       	push	r16
	bool hallstate;
	hallstate = (ReadSensor() & LONGLONGBIT(HALL_SENSOR_BIT));
    59da:	b5 dd       	rcall	.-1174   	; 0x5546 <ReadSensor>
    59dc:	0c e2       	ldi	r16, 0x2C	; 44
    59de:	0e 94 67 37 	call	0x6ece	; 0x6ece <__lshrdi3>
	return hallstate;
}
    59e2:	82 2f       	mov	r24, r18
    59e4:	81 70       	andi	r24, 0x01	; 1
    59e6:	0f 91       	pop	r16
    59e8:	08 95       	ret

000059ea <LoadKeyCodeTables>:

	

void LoadKeyCodeTables(){
	 eeprom_read_block (( void *) KeyCodeLookUpTable, (void *) KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    59ea:	40 e4       	ldi	r20, 0x40	; 64
    59ec:	50 e0       	ldi	r21, 0x00	; 0
    59ee:	60 e0       	ldi	r22, 0x00	; 0
    59f0:	70 e0       	ldi	r23, 0x00	; 0
    59f2:	82 e2       	ldi	r24, 0x22	; 34
    59f4:	96 e0       	ldi	r25, 0x06	; 6
    59f6:	0e 94 b7 3a 	call	0x756e	; 0x756e <eeprom_read_block>
	 eeprom_read_block (( void *) FnKeyCodeLookUpTable, (void *) FN_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    59fa:	40 e4       	ldi	r20, 0x40	; 64
    59fc:	50 e0       	ldi	r21, 0x00	; 0
    59fe:	60 e4       	ldi	r22, 0x40	; 64
    5a00:	70 e0       	ldi	r23, 0x00	; 0
    5a02:	80 e7       	ldi	r24, 0x70	; 112
    5a04:	99 e0       	ldi	r25, 0x09	; 9
    5a06:	0e 94 b7 3a 	call	0x756e	; 0x756e <eeprom_read_block>
	 eeprom_read_block (( void *) ShiftKeyCodeLookUpTable, (void *) SHIFT_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    5a0a:	40 e4       	ldi	r20, 0x40	; 64
    5a0c:	50 e0       	ldi	r21, 0x00	; 0
    5a0e:	60 e8       	ldi	r22, 0x80	; 128
    5a10:	70 e0       	ldi	r23, 0x00	; 0
    5a12:	8f e6       	ldi	r24, 0x6F	; 111
    5a14:	96 e0       	ldi	r25, 0x06	; 6
    5a16:	0e 94 b7 3a 	call	0x756e	; 0x756e <eeprom_read_block>
	 eeprom_read_block (( void *) ASCIILookUpTable, (void *) ASCII_ADDR, KEYCODE_ARRAY_LENGTH);
    5a1a:	40 e4       	ldi	r20, 0x40	; 64
    5a1c:	50 e0       	ldi	r21, 0x00	; 0
    5a1e:	60 ec       	ldi	r22, 0xC0	; 192
    5a20:	70 e0       	ldi	r23, 0x00	; 0
    5a22:	8f e2       	ldi	r24, 0x2F	; 47
    5a24:	97 e0       	ldi	r25, 0x07	; 7
    5a26:	0e 94 b7 3a 	call	0x756e	; 0x756e <eeprom_read_block>
	 eeprom_read_block (( void *) ASCIIShiftLookUpTable, (void *) ASCII_SHIFT_ADDR, KEYCODE_ARRAY_LENGTH);
    5a2a:	40 e4       	ldi	r20, 0x40	; 64
    5a2c:	50 e0       	ldi	r21, 0x00	; 0
    5a2e:	60 e0       	ldi	r22, 0x00	; 0
    5a30:	71 e0       	ldi	r23, 0x01	; 1
    5a32:	80 eb       	ldi	r24, 0xB0	; 176
    5a34:	96 e0       	ldi	r25, 0x06	; 6
    5a36:	0c 94 b7 3a 	jmp	0x756e	; 0x756e <eeprom_read_block>

00005a3a <LoadEepromParameters>:

}

void LoadEepromParameters(){	
	 KeyReleaseTime = eeprom_read_byte((uint8_t *)RELEASE_TIME_ADDR);
    5a3a:	82 e0       	ldi	r24, 0x02	; 2
    5a3c:	92 e0       	ldi	r25, 0x02	; 2
    5a3e:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    5a42:	80 93 20 06 	sts	0x0620, r24
	 KeyHoldTime = eeprom_read_byte((uint8_t *)HOLD_TIME_ADDR);
    5a46:	81 e0       	ldi	r24, 0x01	; 1
    5a48:	92 e0       	ldi	r25, 0x02	; 2
    5a4a:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    5a4e:	80 93 af 06 	sts	0x06AF, r24
	 DoubleTapTime = eeprom_read_byte((uint8_t *)DOUBLE_TAP_ADDR);
    5a52:	80 e0       	ldi	r24, 0x00	; 0
    5a54:	92 e0       	ldi	r25, 0x02	; 2
    5a56:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    5a5a:	80 93 63 06 	sts	0x0663, r24
	 ReedHoldTime = eeprom_read_byte((uint8_t *)REED_HOLD_TIME_ADDR);
    5a5e:	8c e0       	ldi	r24, 0x0C	; 12
    5a60:	92 e0       	ldi	r25, 0x02	; 2
    5a62:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    5a66:	80 93 62 06 	sts	0x0662, r24
	 UseHallSensor = eeprom_read_byte((uint8_t *)USE_HALL_SENSOR_ADDR);
    5a6a:	83 e0       	ldi	r24, 0x03	; 3
    5a6c:	92 e0       	ldi	r25, 0x02	; 2
    5a6e:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    5a72:	80 93 f1 06 	sts	0x06F1, r24
	 HallSensorPolarity = eeprom_read_byte((uint8_t *)HALL_SENSOR_POLARITY_ADDR);
    5a76:	84 e0       	ldi	r24, 0x04	; 4
    5a78:	92 e0       	ldi	r25, 0x02	; 2
    5a7a:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    5a7e:	80 93 6c 06 	sts	0x066C, r24
	 Shift_Reed = eeprom_read_byte((uint8_t *)SHIFT_REED_ADDR);
    5a82:	85 e0       	ldi	r24, 0x05	; 5
    5a84:	92 e0       	ldi	r25, 0x02	; 2
    5a86:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    5a8a:	80 93 64 06 	sts	0x0664, r24
	 Reeds_Are_Independent = eeprom_read_byte((uint8_t *)REEDS_INDEPENDENT_ADDR);
    5a8e:	8e e0       	ldi	r24, 0x0E	; 14
    5a90:	92 e0       	ldi	r25, 0x02	; 2
    5a92:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    5a96:	80 93 1e 06 	sts	0x061E, r24
	 UseDummyLoad = eeprom_read_byte((uint8_t*)DUMMY_LOAD_ADDR);
    5a9a:	8f e0       	ldi	r24, 0x0F	; 15
    5a9c:	92 e0       	ldi	r25, 0x02	; 2
    5a9e:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    5aa2:	80 93 1d 06 	sts	0x061D, r24
    5aa6:	08 95       	ret

00005aa8 <ClearKeyCodeTables>:
//	 BluetoothConfigured = eeprom_read_byte((uint8_t*)BLUETOOTH_CONFIGURED_ADDR);
}

void ClearKeyCodeTables(){
	memset (&KeyCodeLookUpTable[0] , 0, KEYCODE_ARRAY_LENGTH);
    5aa8:	80 e4       	ldi	r24, 0x40	; 64
    5aaa:	e2 e2       	ldi	r30, 0x22	; 34
    5aac:	f6 e0       	ldi	r31, 0x06	; 6
    5aae:	df 01       	movw	r26, r30
    5ab0:	98 2f       	mov	r25, r24
    5ab2:	1d 92       	st	X+, r1
    5ab4:	9a 95       	dec	r25
    5ab6:	e9 f7       	brne	.-6      	; 0x5ab2 <ClearKeyCodeTables+0xa>
	memset (&FnKeyCodeLookUpTable[0] , 0, KEYCODE_ARRAY_LENGTH);
    5ab8:	e0 e7       	ldi	r30, 0x70	; 112
    5aba:	f9 e0       	ldi	r31, 0x09	; 9
    5abc:	df 01       	movw	r26, r30
    5abe:	98 2f       	mov	r25, r24
    5ac0:	1d 92       	st	X+, r1
    5ac2:	9a 95       	dec	r25
    5ac4:	e9 f7       	brne	.-6      	; 0x5ac0 <ClearKeyCodeTables+0x18>
	memset (&ShiftKeyCodeLookUpTable[0], 0, KEYCODE_ARRAY_LENGTH);
    5ac6:	ef e6       	ldi	r30, 0x6F	; 111
    5ac8:	f6 e0       	ldi	r31, 0x06	; 6
    5aca:	df 01       	movw	r26, r30
    5acc:	98 2f       	mov	r25, r24
    5ace:	1d 92       	st	X+, r1
    5ad0:	9a 95       	dec	r25
    5ad2:	e9 f7       	brne	.-6      	; 0x5ace <ClearKeyCodeTables+0x26>
	memset (&ASCIILookUpTable[0],0,KEYCODE_ARRAY_LENGTH);
    5ad4:	ef e2       	ldi	r30, 0x2F	; 47
    5ad6:	f7 e0       	ldi	r31, 0x07	; 7
    5ad8:	df 01       	movw	r26, r30
    5ada:	98 2f       	mov	r25, r24
    5adc:	1d 92       	st	X+, r1
    5ade:	9a 95       	dec	r25
    5ae0:	e9 f7       	brne	.-6      	; 0x5adc <ClearKeyCodeTables+0x34>
	memset (&ASCIIShiftLookUpTable[0],0,KEYCODE_ARRAY_LENGTH);
    5ae2:	e0 eb       	ldi	r30, 0xB0	; 176
    5ae4:	f6 e0       	ldi	r31, 0x06	; 6
    5ae6:	df 01       	movw	r26, r30
    5ae8:	1d 92       	st	X+, r1
    5aea:	8a 95       	dec	r24
    5aec:	e9 f7       	brne	.-6      	; 0x5ae8 <ClearKeyCodeTables+0x40>

	Shift_Reed = 0;
    5aee:	10 92 64 06 	sts	0x0664, r1
    5af2:	08 95       	ret

00005af4 <RestoreFactoryDefaults>:
		eeprom_write_byte((uint8_t*)EEP_CHECKSUM_ADDR, EEP_CHECKSUM);//write the checksum to the eeprom to indicate that eeprom has been properly initialized.
	}
}

void RestoreFactoryDefaults(){
			eeprom_update_byte((uint8_t*)DOUBLE_TAP_ADDR, DEFAULT_DOUBLE_TAP_TIME);
    5af4:	65 e0       	ldi	r22, 0x05	; 5
    5af6:	80 e0       	ldi	r24, 0x00	; 0
    5af8:	92 e0       	ldi	r25, 0x02	; 2
    5afa:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)HOLD_TIME_ADDR, DEFAULT_HOLD_TIME);
    5afe:	66 e0       	ldi	r22, 0x06	; 6
    5b00:	81 e0       	ldi	r24, 0x01	; 1
    5b02:	92 e0       	ldi	r25, 0x02	; 2
    5b04:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)RELEASE_TIME_ADDR, DEFAULT_RELEASE_TIME);
    5b08:	63 e0       	ldi	r22, 0x03	; 3
    5b0a:	82 e0       	ldi	r24, 0x02	; 2
    5b0c:	92 e0       	ldi	r25, 0x02	; 2
    5b0e:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)REED_HOLD_TIME_ADDR, DEFAULT_REED_HOLD_TIME);
    5b12:	63 e0       	ldi	r22, 0x03	; 3
    5b14:	8c e0       	ldi	r24, 0x0C	; 12
    5b16:	92 e0       	ldi	r25, 0x02	; 2
    5b18:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)REEDS_INDEPENDENT_ADDR,REEDS_ARE_INDEPENDENT_BY_DEFAULT);
    5b1c:	60 e0       	ldi	r22, 0x00	; 0
    5b1e:	8e e0       	ldi	r24, 0x0E	; 14
    5b20:	92 e0       	ldi	r25, 0x02	; 2
    5b22:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)DEFAULT_MODE_ADDR,USB_COMBO_MODE);
    5b26:	61 e0       	ldi	r22, 0x01	; 1
    5b28:	8d e0       	ldi	r24, 0x0D	; 13
    5b2a:	92 e0       	ldi	r25, 0x02	; 2
    5b2c:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)DUMMY_LOAD_ADDR,0); //do not use dummy load unless told to.
    5b30:	60 e0       	ldi	r22, 0x00	; 0
    5b32:	8f e0       	ldi	r24, 0x0F	; 15
    5b34:	92 e0       	ldi	r25, 0x02	; 2
    5b36:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
			eeprom_write_word((uint16_t *)FILENUM_ADDR,0);//reset sd card file number to zero.
    5b3a:	60 e0       	ldi	r22, 0x00	; 0
    5b3c:	70 e0       	ldi	r23, 0x00	; 0
    5b3e:	8a e0       	ldi	r24, 0x0A	; 10
    5b40:	92 e0       	ldi	r25, 0x02	; 2
    5b42:	0e 94 fd 3a 	call	0x75fa	; 0x75fa <eeprom_write_word>
//			eeprom_write_byte((uint8_t*)USE_HALL_SENSOR_ADDR,HALL_NOT_PRESENT); //dont change hall sensor when resetting defaults.
			
			LoadEepromParameters(); //load new defaults into RAM
    5b46:	79 cf       	rjmp	.-270    	; 0x5a3a <LoadEepromParameters>

00005b48 <InitializeEeprom>:

	Shift_Reed = 0;
//	UseHallSensor = HALL_NOT_PRESENT;	
}

void InitializeEeprom(){
    5b48:	cf 93       	push	r28
    5b4a:	df 93       	push	r29
	int i;
	if (eeprom_read_byte((uint8_t*)EEP_CHECKSUM_ADDR) != EEP_CHECKSUM){
    5b4c:	8f ef       	ldi	r24, 0xFF	; 255
    5b4e:	93 e0       	ldi	r25, 0x03	; 3
    5b50:	0e 94 c7 3a 	call	0x758e	; 0x758e <eeprom_read_byte>
    5b54:	87 34       	cpi	r24, 0x47	; 71
    5b56:	f1 f0       	breq	.+60     	; 0x5b94 <InitializeEeprom+0x4c>
    5b58:	c0 e0       	ldi	r28, 0x00	; 0
    5b5a:	d0 e0       	ldi	r29, 0x00	; 0
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
    5b5c:	60 e0       	ldi	r22, 0x00	; 0
    5b5e:	ce 01       	movw	r24, r28
    5b60:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>

void InitializeEeprom(){
	int i;
	if (eeprom_read_byte((uint8_t*)EEP_CHECKSUM_ADDR) != EEP_CHECKSUM){
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
    5b64:	21 96       	adiw	r28, 0x01	; 1
    5b66:	c1 35       	cpi	r28, 0x51	; 81
    5b68:	81 e0       	ldi	r24, 0x01	; 1
    5b6a:	d8 07       	cpc	r29, r24
    5b6c:	b9 f7       	brne	.-18     	; 0x5b5c <InitializeEeprom+0x14>
    5b6e:	c0 e0       	ldi	r28, 0x00	; 0
    5b70:	d2 e0       	ldi	r29, 0x02	; 2
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		for(i=EEP_BANK2; i<=EEP_BANK2_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
    5b72:	60 e0       	ldi	r22, 0x00	; 0
    5b74:	ce 01       	movw	r24, r28
    5b76:	0e 94 d4 3a 	call	0x75a8	; 0x75a8 <eeprom_update_byte>
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		for(i=EEP_BANK2; i<=EEP_BANK2_END; i++){
    5b7a:	21 96       	adiw	r28, 0x01	; 1
    5b7c:	c2 31       	cpi	r28, 0x12	; 18
    5b7e:	82 e0       	ldi	r24, 0x02	; 2
    5b80:	d8 07       	cpc	r29, r24
    5b82:	b9 f7       	brne	.-18     	; 0x5b72 <InitializeEeprom+0x2a>
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		RestoreFactoryDefaults();
    5b84:	b7 df       	rcall	.-146    	; 0x5af4 <RestoreFactoryDefaults>

		eeprom_write_byte((uint8_t*)EEP_CHECKSUM_ADDR, EEP_CHECKSUM);//write the checksum to the eeprom to indicate that eeprom has been properly initialized.
    5b86:	67 e4       	ldi	r22, 0x47	; 71
    5b88:	8f ef       	ldi	r24, 0xFF	; 255
    5b8a:	93 e0       	ldi	r25, 0x03	; 3
	}
}
    5b8c:	df 91       	pop	r29
    5b8e:	cf 91       	pop	r28
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		RestoreFactoryDefaults();

		eeprom_write_byte((uint8_t*)EEP_CHECKSUM_ADDR, EEP_CHECKSUM);//write the checksum to the eeprom to indicate that eeprom has been properly initialized.
    5b90:	0c 94 ef 3a 	jmp	0x75de	; 0x75de <eeprom_write_byte>
	}
}
    5b94:	df 91       	pop	r29
    5b96:	cf 91       	pop	r28
    5b98:	08 95       	ret

00005b9a <HID_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_HID_DRIVER
#define  __INCLUDE_FROM_HID_DEVICE_C
#include "HIDClassDevice.h"

void HID_Device_ProcessControlRequest(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
    5b9a:	6f 92       	push	r6
    5b9c:	7f 92       	push	r7
    5b9e:	8f 92       	push	r8
    5ba0:	9f 92       	push	r9
    5ba2:	af 92       	push	r10
    5ba4:	bf 92       	push	r11
    5ba6:	cf 92       	push	r12
    5ba8:	df 92       	push	r13
    5baa:	ef 92       	push	r14
    5bac:	ff 92       	push	r15
    5bae:	0f 93       	push	r16
    5bb0:	1f 93       	push	r17
    5bb2:	cf 93       	push	r28
    5bb4:	df 93       	push	r29
    5bb6:	00 d0       	rcall	.+0      	; 0x5bb8 <HID_Device_ProcessControlRequest+0x1e>
    5bb8:	1f 92       	push	r1
    5bba:	cd b7       	in	r28, 0x3d	; 61
    5bbc:	de b7       	in	r29, 0x3e	; 62
    5bbe:	7c 01       	movw	r14, r24
				Endpoint_ClearStatusStage();
			}

			break;
	}
}
    5bc0:	cd b6       	in	r12, 0x3d	; 61
    5bc2:	de b6       	in	r13, 0x3e	; 62
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5bc4:	80 91 e8 00 	lds	r24, 0x00E8
#define  __INCLUDE_FROM_HID_DEVICE_C
#include "HIDClassDevice.h"

void HID_Device_ProcessControlRequest(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	if (!(Endpoint_IsSETUPReceived()))
    5bc8:	83 ff       	sbrs	r24, 3
    5bca:	0a c1       	rjmp	.+532    	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
	  return;

	if (USB_ControlRequest.wIndex != HIDInterfaceInfo->Config.InterfaceNumber)
    5bcc:	f7 01       	movw	r30, r14
    5bce:	80 81       	ld	r24, Z
    5bd0:	90 e0       	ldi	r25, 0x00	; 0
    5bd2:	20 91 b9 09 	lds	r18, 0x09B9
    5bd6:	30 91 ba 09 	lds	r19, 0x09BA
    5bda:	28 17       	cp	r18, r24
    5bdc:	39 07       	cpc	r19, r25
    5bde:	09 f0       	breq	.+2      	; 0x5be2 <HID_Device_ProcessControlRequest+0x48>
    5be0:	ff c0       	rjmp	.+510    	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
	  return;

	switch (USB_ControlRequest.bRequest)
    5be2:	80 91 b6 09 	lds	r24, 0x09B6
    5be6:	83 30       	cpi	r24, 0x03	; 3
    5be8:	09 f4       	brne	.+2      	; 0x5bec <HID_Device_ProcessControlRequest+0x52>
    5bea:	a1 c0       	rjmp	.+322    	; 0x5d2e <HID_Device_ProcessControlRequest+0x194>
    5bec:	30 f4       	brcc	.+12     	; 0x5bfa <HID_Device_ProcessControlRequest+0x60>
    5bee:	81 30       	cpi	r24, 0x01	; 1
    5bf0:	71 f0       	breq	.+28     	; 0x5c0e <HID_Device_ProcessControlRequest+0x74>
    5bf2:	82 30       	cpi	r24, 0x02	; 2
    5bf4:	09 f4       	brne	.+2      	; 0x5bf8 <HID_Device_ProcessControlRequest+0x5e>
    5bf6:	d8 c0       	rjmp	.+432    	; 0x5da8 <HID_Device_ProcessControlRequest+0x20e>
    5bf8:	f3 c0       	rjmp	.+486    	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
    5bfa:	8a 30       	cpi	r24, 0x0A	; 10
    5bfc:	09 f4       	brne	.+2      	; 0x5c00 <HID_Device_ProcessControlRequest+0x66>
    5bfe:	bc c0       	rjmp	.+376    	; 0x5d78 <HID_Device_ProcessControlRequest+0x1de>
    5c00:	8b 30       	cpi	r24, 0x0B	; 11
    5c02:	09 f4       	brne	.+2      	; 0x5c06 <HID_Device_ProcessControlRequest+0x6c>
    5c04:	a5 c0       	rjmp	.+330    	; 0x5d50 <HID_Device_ProcessControlRequest+0x1b6>
    5c06:	89 30       	cpi	r24, 0x09	; 9
    5c08:	09 f0       	breq	.+2      	; 0x5c0c <HID_Device_ProcessControlRequest+0x72>
    5c0a:	ea c0       	rjmp	.+468    	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
    5c0c:	53 c0       	rjmp	.+166    	; 0x5cb4 <HID_Device_ProcessControlRequest+0x11a>
	{
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    5c0e:	80 91 b5 09 	lds	r24, 0x09B5
    5c12:	81 3a       	cpi	r24, 0xA1	; 161
    5c14:	09 f0       	breq	.+2      	; 0x5c18 <HID_Device_ProcessControlRequest+0x7e>
    5c16:	e4 c0       	rjmp	.+456    	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
    5c18:	8d b6       	in	r8, 0x3d	; 61
    5c1a:	9e b6       	in	r9, 0x3e	; 62
			{
				uint16_t ReportSize = 0;
    5c1c:	1a 82       	std	Y+2, r1	; 0x02
    5c1e:	19 82       	std	Y+1, r1	; 0x01
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
    5c20:	80 91 b7 09 	lds	r24, 0x09B7
    5c24:	10 91 b8 09 	lds	r17, 0x09B8
    5c28:	8b 83       	std	Y+3, r24	; 0x03
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
				uint8_t  ReportData[HIDInterfaceInfo->Config.PrevReportINBufferSize];
    5c2a:	f7 01       	movw	r30, r14
    5c2c:	80 85       	ldd	r24, Z+8	; 0x08
    5c2e:	48 2f       	mov	r20, r24
    5c30:	50 e0       	ldi	r21, 0x00	; 0
    5c32:	8d b7       	in	r24, 0x3d	; 61
    5c34:	9e b7       	in	r25, 0x3e	; 62
    5c36:	84 1b       	sub	r24, r20
    5c38:	95 0b       	sbc	r25, r21
    5c3a:	0f b6       	in	r0, 0x3f	; 63
    5c3c:	f8 94       	cli
    5c3e:	9e bf       	out	0x3e, r25	; 62
    5c40:	0f be       	out	0x3f, r0	; 63
    5c42:	8d bf       	out	0x3d, r24	; 61
    5c44:	ed b7       	in	r30, 0x3d	; 61
    5c46:	fe b7       	in	r31, 0x3e	; 62
    5c48:	31 96       	adiw	r30, 0x01	; 1
    5c4a:	5f 01       	movw	r10, r30

				memset(ReportData, 0, sizeof(ReportData));
    5c4c:	60 e0       	ldi	r22, 0x00	; 0
    5c4e:	70 e0       	ldi	r23, 0x00	; 0
    5c50:	cf 01       	movw	r24, r30
    5c52:	0e 94 f3 37 	call	0x6fe6	; 0x6fe6 <memset>
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				uint16_t ReportSize = 0;
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
    5c56:	4f ef       	ldi	r20, 0xFF	; 255
    5c58:	41 0f       	add	r20, r17
				uint8_t  ReportData[HIDInterfaceInfo->Config.PrevReportINBufferSize];

				memset(ReportData, 0, sizeof(ReportData));

				CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, ReportType, ReportData, &ReportSize);
    5c5a:	8e 01       	movw	r16, r28
    5c5c:	0f 5f       	subi	r16, 0xFF	; 255
    5c5e:	1f 4f       	sbci	r17, 0xFF	; 255
    5c60:	95 01       	movw	r18, r10
    5c62:	be 01       	movw	r22, r28
    5c64:	6d 5f       	subi	r22, 0xFD	; 253
    5c66:	7f 4f       	sbci	r23, 0xFF	; 255
    5c68:	c7 01       	movw	r24, r14
    5c6a:	fc d8       	rcall	.-3592   	; 0x4e64 <CALLBACK_HID_Device_CreateHIDReport>

				if (HIDInterfaceInfo->Config.PrevReportINBuffer != NULL)
    5c6c:	f7 01       	movw	r30, r14
    5c6e:	86 81       	ldd	r24, Z+6	; 0x06
    5c70:	97 81       	ldd	r25, Z+7	; 0x07
    5c72:	00 97       	sbiw	r24, 0x00	; 0
    5c74:	29 f0       	breq	.+10     	; 0x5c80 <HID_Device_ProcessControlRequest+0xe6>
				{
					memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportData,
    5c76:	40 85       	ldd	r20, Z+8	; 0x08
    5c78:	50 e0       	ldi	r21, 0x00	; 0
    5c7a:	b5 01       	movw	r22, r10
    5c7c:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <memcpy>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5c80:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5c84:	80 91 e8 00 	lds	r24, 0x00E8
    5c88:	87 7f       	andi	r24, 0xF7	; 247
    5c8a:	80 93 e8 00 	sts	0x00E8, r24

				Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

				Endpoint_ClearSETUP();

				if (ReportID)
    5c8e:	8b 81       	ldd	r24, Y+3	; 0x03
    5c90:	81 11       	cpse	r24, r1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5c92:	80 93 f1 00 	sts	0x00F1, r24
				  Endpoint_Write_8(ReportID);

				Endpoint_Write_Control_Stream_LE(ReportData, ReportSize);
    5c96:	69 81       	ldd	r22, Y+1	; 0x01
    5c98:	7a 81       	ldd	r23, Y+2	; 0x02
    5c9a:	c5 01       	movw	r24, r10
    5c9c:	2b d4       	rcall	.+2134   	; 0x64f4 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    5c9e:	80 91 e8 00 	lds	r24, 0x00E8
    5ca2:	8b 77       	andi	r24, 0x7B	; 123
    5ca4:	80 93 e8 00 	sts	0x00E8, r24
    5ca8:	0f b6       	in	r0, 0x3f	; 63
    5caa:	f8 94       	cli
    5cac:	9e be       	out	0x3e, r9	; 62
    5cae:	0f be       	out	0x3f, r0	; 63
    5cb0:	8d be       	out	0x3d, r8	; 61
    5cb2:	96 c0       	rjmp	.+300    	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
				Endpoint_ClearOUT();
			}

			break;
		case HID_REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5cb4:	80 91 b5 09 	lds	r24, 0x09B5
    5cb8:	81 32       	cpi	r24, 0x21	; 33
    5cba:	09 f0       	breq	.+2      	; 0x5cbe <HID_Device_ProcessControlRequest+0x124>
    5cbc:	91 c0       	rjmp	.+290    	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
    5cbe:	ad b6       	in	r10, 0x3d	; 61
    5cc0:	be b6       	in	r11, 0x3e	; 62
			{
				uint16_t ReportSize = USB_ControlRequest.wLength;
    5cc2:	00 91 bb 09 	lds	r16, 0x09BB
    5cc6:	10 91 bc 09 	lds	r17, 0x09BC
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
    5cca:	70 90 b7 09 	lds	r7, 0x09B7
    5cce:	60 90 b8 09 	lds	r6, 0x09B8
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
				uint8_t  ReportData[ReportSize];
    5cd2:	8d b7       	in	r24, 0x3d	; 61
    5cd4:	9e b7       	in	r25, 0x3e	; 62
    5cd6:	80 1b       	sub	r24, r16
    5cd8:	91 0b       	sbc	r25, r17
    5cda:	0f b6       	in	r0, 0x3f	; 63
    5cdc:	f8 94       	cli
    5cde:	9e bf       	out	0x3e, r25	; 62
    5ce0:	0f be       	out	0x3f, r0	; 63
    5ce2:	8d bf       	out	0x3d, r24	; 61
    5ce4:	ed b7       	in	r30, 0x3d	; 61
    5ce6:	fe b7       	in	r31, 0x3e	; 62
    5ce8:	31 96       	adiw	r30, 0x01	; 1
    5cea:	4f 01       	movw	r8, r30
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5cec:	80 91 e8 00 	lds	r24, 0x00E8
    5cf0:	87 7f       	andi	r24, 0xF7	; 247
    5cf2:	80 93 e8 00 	sts	0x00E8, r24

				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(ReportData, ReportSize);
    5cf6:	b8 01       	movw	r22, r16
    5cf8:	cf 01       	movw	r24, r30
    5cfa:	5f d4       	rcall	.+2238   	; 0x65ba <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5cfc:	80 91 e8 00 	lds	r24, 0x00E8
    5d00:	8e 77       	andi	r24, 0x7E	; 126
    5d02:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();

				CALLBACK_HID_Device_ProcessHIDReport(HIDInterfaceInfo, ReportID, ReportType,
    5d06:	21 e0       	ldi	r18, 0x01	; 1
    5d08:	71 10       	cpse	r7, r1
    5d0a:	01 c0       	rjmp	.+2      	; 0x5d0e <HID_Device_ProcessControlRequest+0x174>
    5d0c:	20 e0       	ldi	r18, 0x00	; 0
    5d0e:	30 e0       	ldi	r19, 0x00	; 0
    5d10:	02 1b       	sub	r16, r18
    5d12:	13 0b       	sbc	r17, r19
				                                     &ReportData[ReportID ? 1 : 0], ReportSize - (ReportID ? 1 : 0));
    5d14:	28 0d       	add	r18, r8
    5d16:	39 1d       	adc	r19, r9
		case HID_REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				uint16_t ReportSize = USB_ControlRequest.wLength;
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
    5d18:	4f ef       	ldi	r20, 0xFF	; 255
    5d1a:	46 0d       	add	r20, r6

				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(ReportData, ReportSize);
				Endpoint_ClearIN();

				CALLBACK_HID_Device_ProcessHIDReport(HIDInterfaceInfo, ReportID, ReportType,
    5d1c:	67 2d       	mov	r22, r7
    5d1e:	c7 01       	movw	r24, r14
    5d20:	c8 d8       	rcall	.-3696   	; 0x4eb2 <CALLBACK_HID_Device_ProcessHIDReport>
    5d22:	0f b6       	in	r0, 0x3f	; 63
    5d24:	f8 94       	cli
    5d26:	be be       	out	0x3e, r11	; 62
    5d28:	0f be       	out	0x3f, r0	; 63
    5d2a:	ad be       	out	0x3d, r10	; 61
    5d2c:	59 c0       	rjmp	.+178    	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
				                                     &ReportData[ReportID ? 1 : 0], ReportSize - (ReportID ? 1 : 0));
			}

			break;
		case HID_REQ_GetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    5d2e:	80 91 b5 09 	lds	r24, 0x09B5
    5d32:	81 3a       	cpi	r24, 0xA1	; 161
    5d34:	09 f0       	breq	.+2      	; 0x5d38 <HID_Device_ProcessControlRequest+0x19e>
    5d36:	54 c0       	rjmp	.+168    	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5d38:	80 91 e8 00 	lds	r24, 0x00E8
    5d3c:	87 7f       	andi	r24, 0xF7	; 247
    5d3e:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5d42:	80 91 e8 00 	lds	r24, 0x00E8
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    5d46:	80 ff       	sbrs	r24, 0
    5d48:	fc cf       	rjmp	.-8      	; 0x5d42 <HID_Device_ProcessControlRequest+0x1a8>
				Endpoint_Write_8(HIDInterfaceInfo->State.UsingReportProtocol);
    5d4a:	f7 01       	movw	r30, r14
    5d4c:	81 85       	ldd	r24, Z+9	; 0x09
    5d4e:	40 c0       	rjmp	.+128    	; 0x5dd0 <HID_Device_ProcessControlRequest+0x236>
				Endpoint_ClearStatusStage();
			}

			break;
		case HID_REQ_SetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5d50:	80 91 b5 09 	lds	r24, 0x09B5
    5d54:	81 32       	cpi	r24, 0x21	; 33
    5d56:	09 f0       	breq	.+2      	; 0x5d5a <HID_Device_ProcessControlRequest+0x1c0>
    5d58:	43 c0       	rjmp	.+134    	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5d5a:	80 91 e8 00 	lds	r24, 0x00E8
    5d5e:	87 7f       	andi	r24, 0xF7	; 247
    5d60:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    5d64:	48 d5       	rcall	.+2704   	; 0x67f6 <Endpoint_ClearStatusStage>

				HIDInterfaceInfo->State.UsingReportProtocol = ((USB_ControlRequest.wValue & 0xFF) != 0x00);
    5d66:	90 91 b7 09 	lds	r25, 0x09B7
    5d6a:	81 e0       	ldi	r24, 0x01	; 1
    5d6c:	91 11       	cpse	r25, r1
    5d6e:	01 c0       	rjmp	.+2      	; 0x5d72 <HID_Device_ProcessControlRequest+0x1d8>
    5d70:	80 e0       	ldi	r24, 0x00	; 0
    5d72:	f7 01       	movw	r30, r14
    5d74:	81 87       	std	Z+9, r24	; 0x09
    5d76:	34 c0       	rjmp	.+104    	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
			}

			break;
		case HID_REQ_SetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5d78:	80 91 b5 09 	lds	r24, 0x09B5
    5d7c:	81 32       	cpi	r24, 0x21	; 33
    5d7e:	81 f5       	brne	.+96     	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
    5d80:	80 91 e8 00 	lds	r24, 0x00E8
    5d84:	87 7f       	andi	r24, 0xF7	; 247
    5d86:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    5d8a:	35 d5       	rcall	.+2666   	; 0x67f6 <Endpoint_ClearStatusStage>

				HIDInterfaceInfo->State.IdleCount = ((USB_ControlRequest.wValue & 0xFF00) >> 6);
    5d8c:	80 91 b7 09 	lds	r24, 0x09B7
    5d90:	90 91 b8 09 	lds	r25, 0x09B8
    5d94:	88 27       	eor	r24, r24
    5d96:	36 e0       	ldi	r19, 0x06	; 6
    5d98:	96 95       	lsr	r25
    5d9a:	87 95       	ror	r24
    5d9c:	3a 95       	dec	r19
    5d9e:	e1 f7       	brne	.-8      	; 0x5d98 <HID_Device_ProcessControlRequest+0x1fe>
    5da0:	f7 01       	movw	r30, r14
    5da2:	95 87       	std	Z+13, r25	; 0x0d
    5da4:	84 87       	std	Z+12, r24	; 0x0c
    5da6:	1c c0       	rjmp	.+56     	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
			}

			break;
		case HID_REQ_GetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    5da8:	80 91 b5 09 	lds	r24, 0x09B5
    5dac:	81 3a       	cpi	r24, 0xA1	; 161
    5dae:	c1 f4       	brne	.+48     	; 0x5de0 <HID_Device_ProcessControlRequest+0x246>
    5db0:	80 91 e8 00 	lds	r24, 0x00E8
    5db4:	87 7f       	andi	r24, 0xF7	; 247
    5db6:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5dba:	80 91 e8 00 	lds	r24, 0x00E8
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    5dbe:	80 ff       	sbrs	r24, 0
    5dc0:	fc cf       	rjmp	.-8      	; 0x5dba <HID_Device_ProcessControlRequest+0x220>
				Endpoint_Write_8(HIDInterfaceInfo->State.IdleCount >> 2);
    5dc2:	f7 01       	movw	r30, r14
    5dc4:	84 85       	ldd	r24, Z+12	; 0x0c
    5dc6:	95 85       	ldd	r25, Z+13	; 0x0d
    5dc8:	96 95       	lsr	r25
    5dca:	87 95       	ror	r24
    5dcc:	96 95       	lsr	r25
    5dce:	87 95       	ror	r24
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5dd0:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5dd4:	80 91 e8 00 	lds	r24, 0x00E8
    5dd8:	8e 77       	andi	r24, 0x7E	; 126
    5dda:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    5dde:	0b d5       	rcall	.+2582   	; 0x67f6 <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    5de0:	0f b6       	in	r0, 0x3f	; 63
    5de2:	f8 94       	cli
    5de4:	de be       	out	0x3e, r13	; 62
    5de6:	0f be       	out	0x3f, r0	; 63
    5de8:	cd be       	out	0x3d, r12	; 61
    5dea:	0f 90       	pop	r0
    5dec:	0f 90       	pop	r0
    5dee:	0f 90       	pop	r0
    5df0:	df 91       	pop	r29
    5df2:	cf 91       	pop	r28
    5df4:	1f 91       	pop	r17
    5df6:	0f 91       	pop	r16
    5df8:	ff 90       	pop	r15
    5dfa:	ef 90       	pop	r14
    5dfc:	df 90       	pop	r13
    5dfe:	cf 90       	pop	r12
    5e00:	bf 90       	pop	r11
    5e02:	af 90       	pop	r10
    5e04:	9f 90       	pop	r9
    5e06:	8f 90       	pop	r8
    5e08:	7f 90       	pop	r7
    5e0a:	6f 90       	pop	r6
    5e0c:	08 95       	ret

00005e0e <HID_Device_ConfigureEndpoints>:

bool HID_Device_ConfigureEndpoints(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	memset(&HIDInterfaceInfo->State, 0x00, sizeof(HIDInterfaceInfo->State));
    5e0e:	fc 01       	movw	r30, r24
    5e10:	39 96       	adiw	r30, 0x09	; 9
    5e12:	27 e0       	ldi	r18, 0x07	; 7
    5e14:	df 01       	movw	r26, r30
    5e16:	1d 92       	st	X+, r1
    5e18:	2a 95       	dec	r18
    5e1a:	e9 f7       	brne	.-6      	; 0x5e16 <HID_Device_ConfigureEndpoints+0x8>
	HIDInterfaceInfo->State.UsingReportProtocol = true;
    5e1c:	21 e0       	ldi	r18, 0x01	; 1
    5e1e:	fc 01       	movw	r30, r24
    5e20:	21 87       	std	Z+9, r18	; 0x09
	HIDInterfaceInfo->State.IdleCount           = 500;
    5e22:	24 ef       	ldi	r18, 0xF4	; 244
    5e24:	31 e0       	ldi	r19, 0x01	; 1
    5e26:	35 87       	std	Z+13, r19	; 0x0d
    5e28:	24 87       	std	Z+12, r18	; 0x0c

	HIDInterfaceInfo->Config.ReportINEndpoint.Type = EP_TYPE_INTERRUPT;
    5e2a:	23 e0       	ldi	r18, 0x03	; 3
    5e2c:	24 83       	std	Z+4, r18	; 0x04

	if (!(Endpoint_ConfigureEndpointTable(&HIDInterfaceInfo->Config.ReportINEndpoint, 1)))
    5e2e:	61 e0       	ldi	r22, 0x01	; 1
    5e30:	01 96       	adiw	r24, 0x01	; 1
    5e32:	99 c4       	rjmp	.+2354   	; 0x6766 <Endpoint_ConfigureEndpointTable>

00005e34 <HID_Device_USBTask>:

	return true;
}

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
    5e34:	4f 92       	push	r4
    5e36:	5f 92       	push	r5
    5e38:	6f 92       	push	r6
    5e3a:	7f 92       	push	r7
    5e3c:	8f 92       	push	r8
    5e3e:	9f 92       	push	r9
    5e40:	af 92       	push	r10
    5e42:	bf 92       	push	r11
    5e44:	cf 92       	push	r12
    5e46:	df 92       	push	r13
    5e48:	ef 92       	push	r14
    5e4a:	ff 92       	push	r15
    5e4c:	0f 93       	push	r16
    5e4e:	1f 93       	push	r17
    5e50:	cf 93       	push	r28
    5e52:	df 93       	push	r29
    5e54:	00 d0       	rcall	.+0      	; 0x5e56 <HID_Device_USBTask+0x22>
    5e56:	1f 92       	push	r1
    5e58:	cd b7       	in	r28, 0x3d	; 61
    5e5a:	de b7       	in	r29, 0x3e	; 62
    5e5c:	7c 01       	movw	r14, r24
			Endpoint_ClearIN();
		}

		HIDInterfaceInfo->State.PrevFrameNum = USB_Device_GetFrameNumber();
	}
}
    5e5e:	ad b6       	in	r10, 0x3d	; 61
    5e60:	be b6       	in	r11, 0x3e	; 62
	return true;
}

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	if (USB_DeviceState != DEVICE_STATE_Configured)
    5e62:	80 91 b4 09 	lds	r24, 0x09B4
    5e66:	84 30       	cpi	r24, 0x04	; 4
    5e68:	09 f0       	breq	.+2      	; 0x5e6c <HID_Device_USBTask+0x38>
    5e6a:	91 c0       	rjmp	.+290    	; 0x5f8e <HID_Device_USBTask+0x15a>
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    5e6c:	80 91 e4 00 	lds	r24, 0x00E4
    5e70:	90 91 e5 00 	lds	r25, 0x00E5
	  return;

	if (HIDInterfaceInfo->State.PrevFrameNum == USB_Device_GetFrameNumber())
    5e74:	f7 01       	movw	r30, r14
    5e76:	22 85       	ldd	r18, Z+10	; 0x0a
    5e78:	33 85       	ldd	r19, Z+11	; 0x0b
    5e7a:	28 17       	cp	r18, r24
    5e7c:	39 07       	cpc	r19, r25
    5e7e:	09 f4       	brne	.+2      	; 0x5e82 <HID_Device_USBTask+0x4e>
    5e80:	86 c0       	rjmp	.+268    	; 0x5f8e <HID_Device_USBTask+0x15a>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5e82:	81 81       	ldd	r24, Z+1	; 0x01
    5e84:	8f 70       	andi	r24, 0x0F	; 15
    5e86:	80 93 e9 00 	sts	0x00E9, r24
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    5e8a:	80 91 e8 00 	lds	r24, 0x00E8
		#endif
	}

	Endpoint_SelectEndpoint(HIDInterfaceInfo->Config.ReportINEndpoint.Address);

	if (Endpoint_IsReadWriteAllowed())
    5e8e:	85 ff       	sbrs	r24, 5
    5e90:	7e c0       	rjmp	.+252    	; 0x5f8e <HID_Device_USBTask+0x15a>
    5e92:	8d b6       	in	r8, 0x3d	; 61
    5e94:	9e b6       	in	r9, 0x3e	; 62
	{
		uint8_t  ReportINData[HIDInterfaceInfo->Config.PrevReportINBufferSize];
    5e96:	40 85       	ldd	r20, Z+8	; 0x08
    5e98:	50 e0       	ldi	r21, 0x00	; 0
    5e9a:	8d b7       	in	r24, 0x3d	; 61
    5e9c:	9e b7       	in	r25, 0x3e	; 62
    5e9e:	84 1b       	sub	r24, r20
    5ea0:	95 0b       	sbc	r25, r21
    5ea2:	0f b6       	in	r0, 0x3f	; 63
    5ea4:	f8 94       	cli
    5ea6:	9e bf       	out	0x3e, r25	; 62
    5ea8:	0f be       	out	0x3f, r0	; 63
    5eaa:	8d bf       	out	0x3d, r24	; 61
    5eac:	ed b7       	in	r30, 0x3d	; 61
    5eae:	fe b7       	in	r31, 0x3e	; 62
    5eb0:	31 96       	adiw	r30, 0x01	; 1
    5eb2:	6f 01       	movw	r12, r30
		uint8_t  ReportID     = 0;
    5eb4:	1b 82       	std	Y+3, r1	; 0x03
		uint16_t ReportINSize = 0;
    5eb6:	1a 82       	std	Y+2, r1	; 0x02
    5eb8:	19 82       	std	Y+1, r1	; 0x01

		memset(ReportINData, 0, sizeof(ReportINData));
    5eba:	60 e0       	ldi	r22, 0x00	; 0
    5ebc:	70 e0       	ldi	r23, 0x00	; 0
    5ebe:	cf 01       	movw	r24, r30
    5ec0:	0e 94 f3 37 	call	0x6fe6	; 0x6fe6 <memset>

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
    5ec4:	8e 01       	movw	r16, r28
    5ec6:	0f 5f       	subi	r16, 0xFF	; 255
    5ec8:	1f 4f       	sbci	r17, 0xFF	; 255
    5eca:	96 01       	movw	r18, r12
    5ecc:	40 e0       	ldi	r20, 0x00	; 0
    5ece:	be 01       	movw	r22, r28
    5ed0:	6d 5f       	subi	r22, 0xFD	; 253
    5ed2:	7f 4f       	sbci	r23, 0xFF	; 255
    5ed4:	c7 01       	movw	r24, r14
    5ed6:	0e 94 32 27 	call	0x4e64	; 0x4e64 <CALLBACK_HID_Device_CreateHIDReport>
    5eda:	48 2e       	mov	r4, r24
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
		bool IdlePeriodElapsed = (HIDInterfaceInfo->State.IdleCount && !(HIDInterfaceInfo->State.IdleMSRemaining));
    5edc:	f7 01       	movw	r30, r14
    5ede:	84 85       	ldd	r24, Z+12	; 0x0c
    5ee0:	95 85       	ldd	r25, Z+13	; 0x0d
    5ee2:	89 2b       	or	r24, r25
    5ee4:	51 f0       	breq	.+20     	; 0x5efa <HID_Device_USBTask+0xc6>
    5ee6:	91 e0       	ldi	r25, 0x01	; 1
    5ee8:	80 e0       	ldi	r24, 0x00	; 0
    5eea:	26 85       	ldd	r18, Z+14	; 0x0e
    5eec:	37 85       	ldd	r19, Z+15	; 0x0f
    5eee:	23 2b       	or	r18, r19
    5ef0:	09 f0       	breq	.+2      	; 0x5ef4 <HID_Device_USBTask+0xc0>
    5ef2:	90 e0       	ldi	r25, 0x00	; 0
    5ef4:	09 2f       	mov	r16, r25
    5ef6:	18 2f       	mov	r17, r24
    5ef8:	02 c0       	rjmp	.+4      	; 0x5efe <HID_Device_USBTask+0xca>
    5efa:	00 e0       	ldi	r16, 0x00	; 0
    5efc:	10 e0       	ldi	r17, 0x00	; 0

		if (HIDInterfaceInfo->Config.PrevReportINBuffer != NULL)
    5efe:	f7 01       	movw	r30, r14
    5f00:	66 80       	ldd	r6, Z+6	; 0x06
    5f02:	77 80       	ldd	r7, Z+7	; 0x07
    5f04:	61 14       	cp	r6, r1
    5f06:	71 04       	cpc	r7, r1
    5f08:	99 f0       	breq	.+38     	; 0x5f30 <HID_Device_USBTask+0xfc>
		{
			StatesChanged = (memcmp(ReportINData, HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINSize) != 0);
    5f0a:	49 81       	ldd	r20, Y+1	; 0x01
    5f0c:	5a 81       	ldd	r21, Y+2	; 0x02
    5f0e:	b3 01       	movw	r22, r6
    5f10:	c6 01       	movw	r24, r12
    5f12:	0e 94 dd 37 	call	0x6fba	; 0x6fba <memcmp>
    5f16:	55 24       	eor	r5, r5
    5f18:	53 94       	inc	r5
    5f1a:	89 2b       	or	r24, r25
    5f1c:	09 f4       	brne	.+2      	; 0x5f20 <HID_Device_USBTask+0xec>
    5f1e:	51 2c       	mov	r5, r1
			memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINData, HIDInterfaceInfo->Config.PrevReportINBufferSize);
    5f20:	f7 01       	movw	r30, r14
    5f22:	40 85       	ldd	r20, Z+8	; 0x08
    5f24:	50 e0       	ldi	r21, 0x00	; 0
    5f26:	b6 01       	movw	r22, r12
    5f28:	c3 01       	movw	r24, r6
    5f2a:	0e 94 ea 37 	call	0x6fd4	; 0x6fd4 <memcpy>
    5f2e:	01 c0       	rjmp	.+2      	; 0x5f32 <HID_Device_USBTask+0xfe>

		memset(ReportINData, 0, sizeof(ReportINData));

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
    5f30:	51 2c       	mov	r5, r1
		{
			StatesChanged = (memcmp(ReportINData, HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINSize) != 0);
			memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINData, HIDInterfaceInfo->Config.PrevReportINBufferSize);
		}

		if (ReportINSize && (ForceSend || StatesChanged || IdlePeriodElapsed))
    5f32:	89 81       	ldd	r24, Y+1	; 0x01
    5f34:	9a 81       	ldd	r25, Y+2	; 0x02
    5f36:	89 2b       	or	r24, r25
    5f38:	f1 f0       	breq	.+60     	; 0x5f76 <HID_Device_USBTask+0x142>
    5f3a:	41 10       	cpse	r4, r1
    5f3c:	04 c0       	rjmp	.+8      	; 0x5f46 <HID_Device_USBTask+0x112>
    5f3e:	51 10       	cpse	r5, r1
    5f40:	02 c0       	rjmp	.+4      	; 0x5f46 <HID_Device_USBTask+0x112>
    5f42:	01 2b       	or	r16, r17
    5f44:	c1 f0       	breq	.+48     	; 0x5f76 <HID_Device_USBTask+0x142>
		{
			HIDInterfaceInfo->State.IdleMSRemaining = HIDInterfaceInfo->State.IdleCount;
    5f46:	f7 01       	movw	r30, r14
    5f48:	84 85       	ldd	r24, Z+12	; 0x0c
    5f4a:	95 85       	ldd	r25, Z+13	; 0x0d
    5f4c:	97 87       	std	Z+15, r25	; 0x0f
    5f4e:	86 87       	std	Z+14, r24	; 0x0e
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5f50:	81 81       	ldd	r24, Z+1	; 0x01
    5f52:	8f 70       	andi	r24, 0x0F	; 15
    5f54:	80 93 e9 00 	sts	0x00E9, r24

			Endpoint_SelectEndpoint(HIDInterfaceInfo->Config.ReportINEndpoint.Address);

			if (ReportID)
    5f58:	8b 81       	ldd	r24, Y+3	; 0x03
    5f5a:	81 11       	cpse	r24, r1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5f5c:	80 93 f1 00 	sts	0x00F1, r24
			  Endpoint_Write_8(ReportID);

			Endpoint_Write_Stream_LE(ReportINData, ReportINSize, NULL);
    5f60:	69 81       	ldd	r22, Y+1	; 0x01
    5f62:	7a 81       	ldd	r23, Y+2	; 0x02
    5f64:	40 e0       	ldi	r20, 0x00	; 0
    5f66:	50 e0       	ldi	r21, 0x00	; 0
    5f68:	c6 01       	movw	r24, r12
    5f6a:	e0 d1       	rcall	.+960    	; 0x632c <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5f6c:	80 91 e8 00 	lds	r24, 0x00E8
    5f70:	8e 77       	andi	r24, 0x7E	; 126
    5f72:	80 93 e8 00 	sts	0x00E8, r24
    5f76:	80 91 e4 00 	lds	r24, 0x00E4
    5f7a:	90 91 e5 00 	lds	r25, 0x00E5

			Endpoint_ClearIN();
		}

		HIDInterfaceInfo->State.PrevFrameNum = USB_Device_GetFrameNumber();
    5f7e:	f7 01       	movw	r30, r14
    5f80:	93 87       	std	Z+11, r25	; 0x0b
    5f82:	82 87       	std	Z+10, r24	; 0x0a
    5f84:	0f b6       	in	r0, 0x3f	; 63
    5f86:	f8 94       	cli
    5f88:	9e be       	out	0x3e, r9	; 62
    5f8a:	0f be       	out	0x3f, r0	; 63
    5f8c:	8d be       	out	0x3d, r8	; 61
	}
}
    5f8e:	0f b6       	in	r0, 0x3f	; 63
    5f90:	f8 94       	cli
    5f92:	be be       	out	0x3e, r11	; 62
    5f94:	0f be       	out	0x3f, r0	; 63
    5f96:	ad be       	out	0x3d, r10	; 61
    5f98:	0f 90       	pop	r0
    5f9a:	0f 90       	pop	r0
    5f9c:	0f 90       	pop	r0
    5f9e:	df 91       	pop	r29
    5fa0:	cf 91       	pop	r28
    5fa2:	1f 91       	pop	r17
    5fa4:	0f 91       	pop	r16
    5fa6:	ff 90       	pop	r15
    5fa8:	ef 90       	pop	r14
    5faa:	df 90       	pop	r13
    5fac:	cf 90       	pop	r12
    5fae:	bf 90       	pop	r11
    5fb0:	af 90       	pop	r10
    5fb2:	9f 90       	pop	r9
    5fb4:	8f 90       	pop	r8
    5fb6:	7f 90       	pop	r7
    5fb8:	6f 90       	pop	r6
    5fba:	5f 90       	pop	r5
    5fbc:	4f 90       	pop	r4
    5fbe:	08 95       	ret

00005fc0 <MS_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_MS_DRIVER
#define  __INCLUDE_FROM_MASSSTORAGE_DEVICE_C
#include "MassStorageClassDevice.h"

void MS_Device_ProcessControlRequest(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    5fc0:	cf 93       	push	r28
    5fc2:	df 93       	push	r29
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5fc4:	20 91 e8 00 	lds	r18, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    5fc8:	23 ff       	sbrs	r18, 3
    5fca:	38 c0       	rjmp	.+112    	; 0x603c <MS_Device_ProcessControlRequest+0x7c>
	  return;

	if (USB_ControlRequest.wIndex != MSInterfaceInfo->Config.InterfaceNumber)
    5fcc:	fc 01       	movw	r30, r24
    5fce:	20 81       	ld	r18, Z
    5fd0:	30 e0       	ldi	r19, 0x00	; 0
    5fd2:	40 91 b9 09 	lds	r20, 0x09B9
    5fd6:	50 91 ba 09 	lds	r21, 0x09BA
    5fda:	42 17       	cp	r20, r18
    5fdc:	53 07       	cpc	r21, r19
    5fde:	71 f5       	brne	.+92     	; 0x603c <MS_Device_ProcessControlRequest+0x7c>
	  return;

	switch (USB_ControlRequest.bRequest)
    5fe0:	20 91 b6 09 	lds	r18, 0x09B6
    5fe4:	2e 3f       	cpi	r18, 0xFE	; 254
    5fe6:	81 f0       	breq	.+32     	; 0x6008 <MS_Device_ProcessControlRequest+0x48>
    5fe8:	2f 3f       	cpi	r18, 0xFF	; 255
    5fea:	41 f5       	brne	.+80     	; 0x603c <MS_Device_ProcessControlRequest+0x7c>
	{
		case MS_REQ_MassStorageReset:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5fec:	20 91 b5 09 	lds	r18, 0x09B5
    5ff0:	21 32       	cpi	r18, 0x21	; 33
    5ff2:	21 f5       	brne	.+72     	; 0x603c <MS_Device_ProcessControlRequest+0x7c>
    5ff4:	ec 01       	movw	r28, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5ff6:	80 91 e8 00 	lds	r24, 0x00E8
    5ffa:	87 7f       	andi	r24, 0xF7	; 247
    5ffc:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    6000:	fa d3       	rcall	.+2036   	; 0x67f6 <Endpoint_ClearStatusStage>

				MSInterfaceInfo->State.IsMassStoreReset = true;
    6002:	81 e0       	ldi	r24, 0x01	; 1
    6004:	88 af       	std	Y+56, r24	; 0x38
    6006:	1a c0       	rjmp	.+52     	; 0x603c <MS_Device_ProcessControlRequest+0x7c>
			}

			break;
		case MS_REQ_GetMaxLUN:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    6008:	20 91 b5 09 	lds	r18, 0x09B5
    600c:	21 3a       	cpi	r18, 0xA1	; 161
    600e:	b1 f4       	brne	.+44     	; 0x603c <MS_Device_ProcessControlRequest+0x7c>
    6010:	20 91 e8 00 	lds	r18, 0x00E8
    6014:	27 7f       	andi	r18, 0xF7	; 247
    6016:	20 93 e8 00 	sts	0x00E8, r18
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    601a:	20 91 e8 00 	lds	r18, 0x00E8
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    601e:	20 ff       	sbrs	r18, 0
    6020:	fc cf       	rjmp	.-8      	; 0x601a <MS_Device_ProcessControlRequest+0x5a>
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
    6022:	fc 01       	movw	r30, r24
    6024:	83 85       	ldd	r24, Z+11	; 0x0b
    6026:	81 50       	subi	r24, 0x01	; 1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    6028:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    602c:	80 91 e8 00 	lds	r24, 0x00E8
    6030:	8e 77       	andi	r24, 0x7E	; 126
    6032:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearStatusStage();
			}

			break;
	}
}
    6036:	df 91       	pop	r29
    6038:	cf 91       	pop	r28
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    603a:	dd c3       	rjmp	.+1978   	; 0x67f6 <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    603c:	df 91       	pop	r29
    603e:	cf 91       	pop	r28
    6040:	08 95       	ret

00006042 <MS_Device_ConfigureEndpoints>:

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    6042:	cf 93       	push	r28
    6044:	df 93       	push	r29
    6046:	ec 01       	movw	r28, r24
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));
    6048:	fc 01       	movw	r30, r24
    604a:	3c 96       	adiw	r30, 0x0c	; 12
    604c:	8d e2       	ldi	r24, 0x2D	; 45
    604e:	df 01       	movw	r26, r30
    6050:	1d 92       	st	X+, r1
    6052:	8a 95       	dec	r24
    6054:	e9 f7       	brne	.-6      	; 0x6050 <MS_Device_ConfigureEndpoints+0xe>

	MSInterfaceInfo->Config.DataINEndpoint.Type  = EP_TYPE_BULK;
    6056:	82 e0       	ldi	r24, 0x02	; 2
    6058:	8c 83       	std	Y+4, r24	; 0x04
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;
    605a:	89 87       	std	Y+9, r24	; 0x09

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
    605c:	61 e0       	ldi	r22, 0x01	; 1
    605e:	ce 01       	movw	r24, r28
    6060:	01 96       	adiw	r24, 0x01	; 1
    6062:	81 d3       	rcall	.+1794   	; 0x6766 <Endpoint_ConfigureEndpointTable>
    6064:	88 23       	and	r24, r24
    6066:	31 f0       	breq	.+12     	; 0x6074 <MS_Device_ConfigureEndpoints+0x32>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
    6068:	61 e0       	ldi	r22, 0x01	; 1
    606a:	ce 01       	movw	r24, r28
    606c:	06 96       	adiw	r24, 0x06	; 6
	  return false;

	return true;
}
    606e:	df 91       	pop	r29
    6070:	cf 91       	pop	r28
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
    6072:	79 c3       	rjmp	.+1778   	; 0x6766 <Endpoint_ConfigureEndpointTable>
	  return false;

	return true;
}
    6074:	80 e0       	ldi	r24, 0x00	; 0
    6076:	df 91       	pop	r29
    6078:	cf 91       	pop	r28
    607a:	08 95       	ret

0000607c <MS_Device_USBTask>:

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    607c:	ef 92       	push	r14
    607e:	ff 92       	push	r15
    6080:	0f 93       	push	r16
    6082:	1f 93       	push	r17
    6084:	cf 93       	push	r28
    6086:	df 93       	push	r29
    6088:	00 d0       	rcall	.+0      	; 0x608a <MS_Device_USBTask+0xe>
    608a:	cd b7       	in	r28, 0x3d	; 61
    608c:	de b7       	in	r29, 0x3e	; 62
	if (USB_DeviceState != DEVICE_STATE_Configured)
    608e:	20 91 b4 09 	lds	r18, 0x09B4
    6092:	24 30       	cpi	r18, 0x04	; 4
    6094:	09 f0       	breq	.+2      	; 0x6098 <MS_Device_USBTask+0x1c>
    6096:	03 c1       	rjmp	.+518    	; 0x629e <MS_Device_USBTask+0x222>
    6098:	8c 01       	movw	r16, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    609a:	fc 01       	movw	r30, r24
    609c:	86 81       	ldd	r24, Z+6	; 0x06
    609e:	8f 70       	andi	r24, 0x0F	; 15
    60a0:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    60a4:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	if (Endpoint_IsOUTReceived())
    60a8:	82 ff       	sbrs	r24, 2
    60aa:	c0 c0       	rjmp	.+384    	; 0x622c <MS_Device_USBTask+0x1b0>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    60ac:	86 81       	ldd	r24, Z+6	; 0x06
    60ae:	8f 70       	andi	r24, 0x0F	; 15
    60b0:	80 93 e9 00 	sts	0x00E9, r24
{
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	BytesProcessed = 0;
    60b4:	1a 82       	std	Y+2, r1	; 0x02
    60b6:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    60b8:	78 01       	movw	r14, r16
    60ba:	fc e0       	ldi	r31, 0x0C	; 12
    60bc:	ef 0e       	add	r14, r31
    60be:	f1 1c       	adc	r15, r1
    60c0:	ae 01       	movw	r20, r28
    60c2:	4f 5f       	subi	r20, 0xFF	; 255
    60c4:	5f 4f       	sbci	r21, 0xFF	; 255
    60c6:	6f e0       	ldi	r22, 0x0F	; 15
    60c8:	70 e0       	ldi	r23, 0x00	; 0
    60ca:	c7 01       	movw	r24, r14
    60cc:	c9 d1       	rcall	.+914    	; 0x6460 <Endpoint_Read_Stream_LE>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    60ce:	f8 01       	movw	r30, r16
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    60d0:	85 30       	cpi	r24, 0x05	; 5
    60d2:	21 f4       	brne	.+8      	; 0x60dc <MS_Device_USBTask+0x60>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    60d4:	80 ad       	ldd	r24, Z+56	; 0x38
    60d6:	88 23       	and	r24, r24
    60d8:	99 f3       	breq	.-26     	; 0x60c0 <MS_Device_USBTask+0x44>
    60da:	a8 c0       	rjmp	.+336    	; 0x622c <MS_Device_USBTask+0x1b0>
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
    60dc:	84 85       	ldd	r24, Z+12	; 0x0c
    60de:	95 85       	ldd	r25, Z+13	; 0x0d
    60e0:	a6 85       	ldd	r26, Z+14	; 0x0e
    60e2:	b7 85       	ldd	r27, Z+15	; 0x0f
    60e4:	85 35       	cpi	r24, 0x55	; 85
    60e6:	93 45       	sbci	r25, 0x53	; 83
    60e8:	a2 44       	sbci	r26, 0x42	; 66
    60ea:	b3 44       	sbci	r27, 0x43	; 67
    60ec:	61 f4       	brne	.+24     	; 0x6106 <MS_Device_USBTask+0x8a>
    60ee:	f8 01       	movw	r30, r16
    60f0:	91 8d       	ldd	r25, Z+25	; 0x19
    60f2:	83 85       	ldd	r24, Z+11	; 0x0b
    60f4:	98 17       	cp	r25, r24
    60f6:	38 f4       	brcc	.+14     	; 0x6106 <MS_Device_USBTask+0x8a>
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    60f8:	80 8d       	ldd	r24, Z+24	; 0x18
    60fa:	8f 71       	andi	r24, 0x1F	; 31
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
    60fc:	21 f4       	brne	.+8      	; 0x6106 <MS_Device_USBTask+0x8a>
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    60fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    6100:	81 50       	subi	r24, 0x01	; 1
    6102:	80 31       	cpi	r24, 0x10	; 16
    6104:	80 f0       	brcs	.+32     	; 0x6126 <MS_Device_USBTask+0xaa>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6106:	80 91 eb 00 	lds	r24, 0x00EB
    610a:	80 62       	ori	r24, 0x20	; 32
    610c:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6110:	f8 01       	movw	r30, r16
    6112:	81 81       	ldd	r24, Z+1	; 0x01
    6114:	8f 70       	andi	r24, 0x0F	; 15
    6116:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    611a:	80 91 eb 00 	lds	r24, 0x00EB
    611e:	80 62       	ori	r24, 0x20	; 32
    6120:	80 93 eb 00 	sts	0x00EB, r24
    6124:	83 c0       	rjmp	.+262    	; 0x622c <MS_Device_USBTask+0x1b0>
		Endpoint_StallTransaction();

		return false;
	}

	BytesProcessed = 0;
    6126:	1a 82       	std	Y+2, r1	; 0x02
    6128:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    612a:	78 01       	movw	r14, r16
    612c:	fb e1       	ldi	r31, 0x1B	; 27
    612e:	ef 0e       	add	r14, r31
    6130:	f1 1c       	adc	r15, r1
    6132:	f8 01       	movw	r30, r16
    6134:	62 8d       	ldd	r22, Z+26	; 0x1a
    6136:	70 e0       	ldi	r23, 0x00	; 0
    6138:	ae 01       	movw	r20, r28
    613a:	4f 5f       	subi	r20, 0xFF	; 255
    613c:	5f 4f       	sbci	r21, 0xFF	; 255
    613e:	c7 01       	movw	r24, r14
    6140:	8f d1       	rcall	.+798    	; 0x6460 <Endpoint_Read_Stream_LE>
    6142:	85 30       	cpi	r24, 0x05	; 5
    6144:	29 f4       	brne	.+10     	; 0x6150 <MS_Device_USBTask+0xd4>
	                                MSInterfaceInfo->State.CommandBlock.SCSICommandLength, &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    6146:	f8 01       	movw	r30, r16
    6148:	80 ad       	ldd	r24, Z+56	; 0x38
    614a:	88 23       	and	r24, r24
    614c:	91 f3       	breq	.-28     	; 0x6132 <MS_Device_USBTask+0xb6>
    614e:	6e c0       	rjmp	.+220    	; 0x622c <MS_Device_USBTask+0x1b0>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6150:	80 91 e8 00 	lds	r24, 0x00E8
    6154:	8b 77       	andi	r24, 0x7B	; 123
    6156:	80 93 e8 00 	sts	0x00E8, r24

	if (Endpoint_IsOUTReceived())
	{
		if (MS_Device_ReadInCommandBlock(MSInterfaceInfo))
		{
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
    615a:	f8 01       	movw	r30, r16
    615c:	80 8d       	ldd	r24, Z+24	; 0x18
    615e:	87 ff       	sbrs	r24, 7
    6160:	04 c0       	rjmp	.+8      	; 0x616a <MS_Device_USBTask+0xee>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6162:	81 81       	ldd	r24, Z+1	; 0x01
    6164:	8f 70       	andi	r24, 0x0F	; 15
    6166:	80 93 e9 00 	sts	0x00E9, r24
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

			bool SCSICommandResult = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo);
    616a:	c8 01       	movw	r24, r16
    616c:	0e 94 31 27 	call	0x4e62	; 0x4e62 <CALLBACK_MS_Device_SCSICommandReceived>

			MSInterfaceInfo->State.CommandStatus.Status              = (SCSICommandResult) ? MS_SCSI_COMMAND_Pass : MS_SCSI_COMMAND_Fail;
    6170:	91 e0       	ldi	r25, 0x01	; 1
    6172:	98 27       	eor	r25, r24
    6174:	f8 01       	movw	r30, r16
    6176:	97 ab       	std	Z+55, r25	; 0x37
			MSInterfaceInfo->State.CommandStatus.Signature           = CPU_TO_LE32(MS_CSW_SIGNATURE);
    6178:	45 e5       	ldi	r20, 0x55	; 85
    617a:	53 e5       	ldi	r21, 0x53	; 83
    617c:	62 e4       	ldi	r22, 0x42	; 66
    617e:	73 e5       	ldi	r23, 0x53	; 83
    6180:	43 a7       	std	Z+43, r20	; 0x2b
    6182:	54 a7       	std	Z+44, r21	; 0x2c
    6184:	65 a7       	std	Z+45, r22	; 0x2d
    6186:	76 a7       	std	Z+46, r23	; 0x2e
			MSInterfaceInfo->State.CommandStatus.Tag                 = MSInterfaceInfo->State.CommandBlock.Tag;
    6188:	40 89       	ldd	r20, Z+16	; 0x10
    618a:	51 89       	ldd	r21, Z+17	; 0x11
    618c:	62 89       	ldd	r22, Z+18	; 0x12
    618e:	73 89       	ldd	r23, Z+19	; 0x13
    6190:	47 a7       	std	Z+47, r20	; 0x2f
    6192:	50 ab       	std	Z+48, r21	; 0x30
    6194:	61 ab       	std	Z+49, r22	; 0x31
    6196:	72 ab       	std	Z+50, r23	; 0x32
			MSInterfaceInfo->State.CommandStatus.DataTransferResidue = MSInterfaceInfo->State.CommandBlock.DataTransferLength;
    6198:	44 89       	ldd	r20, Z+20	; 0x14
    619a:	55 89       	ldd	r21, Z+21	; 0x15
    619c:	66 89       	ldd	r22, Z+22	; 0x16
    619e:	77 89       	ldd	r23, Z+23	; 0x17
    61a0:	43 ab       	std	Z+51, r20	; 0x33
    61a2:	54 ab       	std	Z+52, r21	; 0x34
    61a4:	65 ab       	std	Z+53, r22	; 0x35
    61a6:	76 ab       	std	Z+54, r23	; 0x36

			if (!(SCSICommandResult) && (le32_to_cpu(MSInterfaceInfo->State.CommandStatus.DataTransferResidue)))
    61a8:	81 11       	cpse	r24, r1
    61aa:	09 c0       	rjmp	.+18     	; 0x61be <MS_Device_USBTask+0x142>
    61ac:	45 2b       	or	r20, r21
    61ae:	46 2b       	or	r20, r22
    61b0:	47 2b       	or	r20, r23
    61b2:	29 f0       	breq	.+10     	; 0x61be <MS_Device_USBTask+0x142>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    61b4:	80 91 eb 00 	lds	r24, 0x00EB
    61b8:	80 62       	ori	r24, 0x20	; 32
    61ba:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    61be:	f8 01       	movw	r30, r16
    61c0:	86 81       	ldd	r24, Z+6	; 0x06
    61c2:	8f 70       	andi	r24, 0x0F	; 15
    61c4:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    61c8:	80 91 eb 00 	lds	r24, 0x00EB

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	while (Endpoint_IsStalled())
    61cc:	85 ff       	sbrs	r24, 5
    61ce:	06 c0       	rjmp	.+12     	; 0x61dc <MS_Device_USBTask+0x160>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
    61d0:	f6 d5       	rcall	.+3052   	; 0x6dbe <USB_USBTask>
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    61d2:	f8 01       	movw	r30, r16
    61d4:	80 ad       	ldd	r24, Z+56	; 0x38
    61d6:	88 23       	and	r24, r24
    61d8:	b9 f3       	breq	.-18     	; 0x61c8 <MS_Device_USBTask+0x14c>
    61da:	28 c0       	rjmp	.+80     	; 0x622c <MS_Device_USBTask+0x1b0>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    61dc:	f8 01       	movw	r30, r16
    61de:	81 81       	ldd	r24, Z+1	; 0x01
    61e0:	8f 70       	andi	r24, 0x0F	; 15
    61e2:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    61e6:	80 91 eb 00 	lds	r24, 0x00EB
		  return;
	}

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

	while (Endpoint_IsStalled())
    61ea:	85 ff       	sbrs	r24, 5
    61ec:	06 c0       	rjmp	.+12     	; 0x61fa <MS_Device_USBTask+0x17e>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
    61ee:	e7 d5       	rcall	.+3022   	; 0x6dbe <USB_USBTask>
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    61f0:	f8 01       	movw	r30, r16
    61f2:	80 ad       	ldd	r24, Z+56	; 0x38
    61f4:	88 23       	and	r24, r24
    61f6:	b9 f3       	breq	.-18     	; 0x61e6 <MS_Device_USBTask+0x16a>
    61f8:	19 c0       	rjmp	.+50     	; 0x622c <MS_Device_USBTask+0x1b0>
		  return;
	}

	uint16_t BytesProcessed = 0;
    61fa:	1a 82       	std	Y+2, r1	; 0x02
    61fc:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    61fe:	78 01       	movw	r14, r16
    6200:	fb e2       	ldi	r31, 0x2B	; 43
    6202:	ef 0e       	add	r14, r31
    6204:	f1 1c       	adc	r15, r1
    6206:	ae 01       	movw	r20, r28
    6208:	4f 5f       	subi	r20, 0xFF	; 255
    620a:	5f 4f       	sbci	r21, 0xFF	; 255
    620c:	6d e0       	ldi	r22, 0x0D	; 13
    620e:	70 e0       	ldi	r23, 0x00	; 0
    6210:	c7 01       	movw	r24, r14
    6212:	8c d0       	rcall	.+280    	; 0x632c <Endpoint_Write_Stream_LE>
    6214:	85 30       	cpi	r24, 0x05	; 5
    6216:	29 f4       	brne	.+10     	; 0x6222 <MS_Device_USBTask+0x1a6>
	                                sizeof(MS_CommandStatusWrapper_t), &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    6218:	f8 01       	movw	r30, r16
    621a:	80 ad       	ldd	r24, Z+56	; 0x38
    621c:	88 23       	and	r24, r24
    621e:	99 f3       	breq	.-26     	; 0x6206 <MS_Device_USBTask+0x18a>
    6220:	05 c0       	rjmp	.+10     	; 0x622c <MS_Device_USBTask+0x1b0>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6222:	80 91 e8 00 	lds	r24, 0x00E8
    6226:	8e 77       	andi	r24, 0x7E	; 126
    6228:	80 93 e8 00 	sts	0x00E8, r24

			MS_Device_ReturnCommandStatus(MSInterfaceInfo);
		}
	}

	if (MSInterfaceInfo->State.IsMassStoreReset)
    622c:	f8 01       	movw	r30, r16
    622e:	80 ad       	ldd	r24, Z+56	; 0x38
    6230:	88 23       	and	r24, r24
    6232:	a9 f1       	breq	.+106    	; 0x629e <MS_Device_USBTask+0x222>
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    6234:	26 81       	ldd	r18, Z+6	; 0x06
    6236:	2f 70       	andi	r18, 0x0F	; 15
    6238:	81 e0       	ldi	r24, 0x01	; 1
    623a:	90 e0       	ldi	r25, 0x00	; 0
    623c:	ac 01       	movw	r20, r24
    623e:	02 c0       	rjmp	.+4      	; 0x6244 <MS_Device_USBTask+0x1c8>
    6240:	44 0f       	add	r20, r20
    6242:	55 1f       	adc	r21, r21
    6244:	2a 95       	dec	r18
    6246:	e2 f7       	brpl	.-8      	; 0x6240 <MS_Device_USBTask+0x1c4>
    6248:	40 93 ea 00 	sts	0x00EA, r20
				UERST = 0;
    624c:	10 92 ea 00 	sts	0x00EA, r1
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    6250:	21 81       	ldd	r18, Z+1	; 0x01
    6252:	2f 70       	andi	r18, 0x0F	; 15
    6254:	01 c0       	rjmp	.+2      	; 0x6258 <MS_Device_USBTask+0x1dc>
    6256:	88 0f       	add	r24, r24
    6258:	2a 95       	dec	r18
    625a:	ea f7       	brpl	.-6      	; 0x6256 <MS_Device_USBTask+0x1da>
    625c:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    6260:	10 92 ea 00 	sts	0x00EA, r1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6264:	86 81       	ldd	r24, Z+6	; 0x06
    6266:	8f 70       	andi	r24, 0x0F	; 15
    6268:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    626c:	80 91 eb 00 	lds	r24, 0x00EB
    6270:	80 61       	ori	r24, 0x10	; 16
    6272:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    6276:	80 91 eb 00 	lds	r24, 0x00EB
    627a:	88 60       	ori	r24, 0x08	; 8
    627c:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6280:	81 81       	ldd	r24, Z+1	; 0x01
    6282:	8f 70       	andi	r24, 0x0F	; 15
    6284:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6288:	80 91 eb 00 	lds	r24, 0x00EB
    628c:	80 61       	ori	r24, 0x10	; 16
    628e:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    6292:	80 91 eb 00 	lds	r24, 0x00EB
    6296:	88 60       	ori	r24, 0x08	; 8
    6298:	80 93 eb 00 	sts	0x00EB, r24
		Endpoint_ResetDataToggle();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);
		Endpoint_ClearStall();
		Endpoint_ResetDataToggle();

		MSInterfaceInfo->State.IsMassStoreReset = false;
    629c:	10 ae       	std	Z+56, r1	; 0x38
	}
}
    629e:	0f 90       	pop	r0
    62a0:	0f 90       	pop	r0
    62a2:	df 91       	pop	r29
    62a4:	cf 91       	pop	r28
    62a6:	1f 91       	pop	r17
    62a8:	0f 91       	pop	r16
    62aa:	ff 90       	pop	r15
    62ac:	ef 90       	pop	r14
    62ae:	08 95       	ret

000062b0 <Endpoint_Null_Stream>:
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    62b0:	ef 92       	push	r14
    62b2:	ff 92       	push	r15
    62b4:	0f 93       	push	r16
    62b6:	1f 93       	push	r17
    62b8:	cf 93       	push	r28
    62ba:	df 93       	push	r29
    62bc:	ec 01       	movw	r28, r24
    62be:	7b 01       	movw	r14, r22
    62c0:	b9 d2       	rcall	.+1394   	; 0x6834 <Endpoint_WaitUntilReady>
    62c2:	81 11       	cpse	r24, r1
    62c4:	2c c0       	rjmp	.+88     	; 0x631e <Endpoint_Null_Stream+0x6e>
    62c6:	e1 14       	cp	r14, r1
    62c8:	f1 04       	cpc	r15, r1
    62ca:	29 f0       	breq	.+10     	; 0x62d6 <Endpoint_Null_Stream+0x26>
    62cc:	f7 01       	movw	r30, r14
    62ce:	80 81       	ld	r24, Z
    62d0:	91 81       	ldd	r25, Z+1	; 0x01
    62d2:	c8 1b       	sub	r28, r24
    62d4:	d9 0b       	sbc	r29, r25
    62d6:	00 e0       	ldi	r16, 0x00	; 0
    62d8:	10 e0       	ldi	r17, 0x00	; 0
    62da:	20 97       	sbiw	r28, 0x00	; 0
    62dc:	f9 f0       	breq	.+62     	; 0x631c <Endpoint_Null_Stream+0x6c>
    62de:	80 91 e8 00 	lds	r24, 0x00E8
    62e2:	85 fd       	sbrc	r24, 5
    62e4:	15 c0       	rjmp	.+42     	; 0x6310 <Endpoint_Null_Stream+0x60>
    62e6:	80 91 e8 00 	lds	r24, 0x00E8
    62ea:	8e 77       	andi	r24, 0x7E	; 126
    62ec:	80 93 e8 00 	sts	0x00E8, r24
    62f0:	e1 14       	cp	r14, r1
    62f2:	f1 04       	cpc	r15, r1
    62f4:	49 f0       	breq	.+18     	; 0x6308 <Endpoint_Null_Stream+0x58>
    62f6:	f7 01       	movw	r30, r14
    62f8:	80 81       	ld	r24, Z
    62fa:	91 81       	ldd	r25, Z+1	; 0x01
    62fc:	08 0f       	add	r16, r24
    62fe:	19 1f       	adc	r17, r25
    6300:	11 83       	std	Z+1, r17	; 0x01
    6302:	00 83       	st	Z, r16
    6304:	85 e0       	ldi	r24, 0x05	; 5
    6306:	0b c0       	rjmp	.+22     	; 0x631e <Endpoint_Null_Stream+0x6e>
    6308:	95 d2       	rcall	.+1322   	; 0x6834 <Endpoint_WaitUntilReady>
    630a:	88 23       	and	r24, r24
    630c:	31 f3       	breq	.-52     	; 0x62da <Endpoint_Null_Stream+0x2a>
    630e:	07 c0       	rjmp	.+14     	; 0x631e <Endpoint_Null_Stream+0x6e>
    6310:	10 92 f1 00 	sts	0x00F1, r1
    6314:	21 97       	sbiw	r28, 0x01	; 1
    6316:	0f 5f       	subi	r16, 0xFF	; 255
    6318:	1f 4f       	sbci	r17, 0xFF	; 255
    631a:	df cf       	rjmp	.-66     	; 0x62da <Endpoint_Null_Stream+0x2a>
    631c:	80 e0       	ldi	r24, 0x00	; 0
    631e:	df 91       	pop	r29
    6320:	cf 91       	pop	r28
    6322:	1f 91       	pop	r17
    6324:	0f 91       	pop	r16
    6326:	ff 90       	pop	r15
    6328:	ef 90       	pop	r14
    632a:	08 95       	ret

0000632c <Endpoint_Write_Stream_LE>:
    632c:	cf 92       	push	r12
    632e:	df 92       	push	r13
    6330:	ef 92       	push	r14
    6332:	ff 92       	push	r15
    6334:	0f 93       	push	r16
    6336:	1f 93       	push	r17
    6338:	cf 93       	push	r28
    633a:	df 93       	push	r29
    633c:	ec 01       	movw	r28, r24
    633e:	8b 01       	movw	r16, r22
    6340:	7a 01       	movw	r14, r20
    6342:	78 d2       	rcall	.+1264   	; 0x6834 <Endpoint_WaitUntilReady>
    6344:	81 11       	cpse	r24, r1
    6346:	33 c0       	rjmp	.+102    	; 0x63ae <Endpoint_Write_Stream_LE+0x82>
    6348:	e1 14       	cp	r14, r1
    634a:	f1 04       	cpc	r15, r1
    634c:	39 f0       	breq	.+14     	; 0x635c <Endpoint_Write_Stream_LE+0x30>
    634e:	f7 01       	movw	r30, r14
    6350:	80 81       	ld	r24, Z
    6352:	91 81       	ldd	r25, Z+1	; 0x01
    6354:	08 1b       	sub	r16, r24
    6356:	19 0b       	sbc	r17, r25
    6358:	c8 0f       	add	r28, r24
    635a:	d9 1f       	adc	r29, r25
    635c:	c1 2c       	mov	r12, r1
    635e:	d1 2c       	mov	r13, r1
    6360:	01 15       	cp	r16, r1
    6362:	11 05       	cpc	r17, r1
    6364:	19 f1       	breq	.+70     	; 0x63ac <Endpoint_Write_Stream_LE+0x80>
    6366:	80 91 e8 00 	lds	r24, 0x00E8
    636a:	85 fd       	sbrc	r24, 5
    636c:	16 c0       	rjmp	.+44     	; 0x639a <Endpoint_Write_Stream_LE+0x6e>
    636e:	80 91 e8 00 	lds	r24, 0x00E8
    6372:	8e 77       	andi	r24, 0x7E	; 126
    6374:	80 93 e8 00 	sts	0x00E8, r24
    6378:	22 d5       	rcall	.+2628   	; 0x6dbe <USB_USBTask>
    637a:	e1 14       	cp	r14, r1
    637c:	f1 04       	cpc	r15, r1
    637e:	49 f0       	breq	.+18     	; 0x6392 <Endpoint_Write_Stream_LE+0x66>
    6380:	f7 01       	movw	r30, r14
    6382:	80 81       	ld	r24, Z
    6384:	91 81       	ldd	r25, Z+1	; 0x01
    6386:	c8 0e       	add	r12, r24
    6388:	d9 1e       	adc	r13, r25
    638a:	d1 82       	std	Z+1, r13	; 0x01
    638c:	c0 82       	st	Z, r12
    638e:	85 e0       	ldi	r24, 0x05	; 5
    6390:	0e c0       	rjmp	.+28     	; 0x63ae <Endpoint_Write_Stream_LE+0x82>
    6392:	50 d2       	rcall	.+1184   	; 0x6834 <Endpoint_WaitUntilReady>
    6394:	88 23       	and	r24, r24
    6396:	21 f3       	breq	.-56     	; 0x6360 <Endpoint_Write_Stream_LE+0x34>
    6398:	0a c0       	rjmp	.+20     	; 0x63ae <Endpoint_Write_Stream_LE+0x82>
    639a:	89 91       	ld	r24, Y+
    639c:	80 93 f1 00 	sts	0x00F1, r24
    63a0:	01 50       	subi	r16, 0x01	; 1
    63a2:	11 09       	sbc	r17, r1
    63a4:	ff ef       	ldi	r31, 0xFF	; 255
    63a6:	cf 1a       	sub	r12, r31
    63a8:	df 0a       	sbc	r13, r31
    63aa:	da cf       	rjmp	.-76     	; 0x6360 <Endpoint_Write_Stream_LE+0x34>
    63ac:	80 e0       	ldi	r24, 0x00	; 0
    63ae:	df 91       	pop	r29
    63b0:	cf 91       	pop	r28
    63b2:	1f 91       	pop	r17
    63b4:	0f 91       	pop	r16
    63b6:	ff 90       	pop	r15
    63b8:	ef 90       	pop	r14
    63ba:	df 90       	pop	r13
    63bc:	cf 90       	pop	r12
    63be:	08 95       	ret

000063c0 <Endpoint_Write_Stream_BE>:
    63c0:	cf 92       	push	r12
    63c2:	df 92       	push	r13
    63c4:	ef 92       	push	r14
    63c6:	ff 92       	push	r15
    63c8:	0f 93       	push	r16
    63ca:	1f 93       	push	r17
    63cc:	cf 93       	push	r28
    63ce:	df 93       	push	r29
    63d0:	ec 01       	movw	r28, r24
    63d2:	8b 01       	movw	r16, r22
    63d4:	7a 01       	movw	r14, r20
    63d6:	2e d2       	rcall	.+1116   	; 0x6834 <Endpoint_WaitUntilReady>
    63d8:	81 11       	cpse	r24, r1
    63da:	39 c0       	rjmp	.+114    	; 0x644e <Endpoint_Write_Stream_BE+0x8e>
    63dc:	98 01       	movw	r18, r16
    63de:	21 50       	subi	r18, 0x01	; 1
    63e0:	31 09       	sbc	r19, r1
    63e2:	c2 0f       	add	r28, r18
    63e4:	d3 1f       	adc	r29, r19
    63e6:	e1 14       	cp	r14, r1
    63e8:	f1 04       	cpc	r15, r1
    63ea:	39 f0       	breq	.+14     	; 0x63fa <Endpoint_Write_Stream_BE+0x3a>
    63ec:	f7 01       	movw	r30, r14
    63ee:	80 81       	ld	r24, Z
    63f0:	91 81       	ldd	r25, Z+1	; 0x01
    63f2:	08 1b       	sub	r16, r24
    63f4:	19 0b       	sbc	r17, r25
    63f6:	c8 1b       	sub	r28, r24
    63f8:	d9 0b       	sbc	r29, r25
    63fa:	c1 2c       	mov	r12, r1
    63fc:	d1 2c       	mov	r13, r1
    63fe:	01 15       	cp	r16, r1
    6400:	11 05       	cpc	r17, r1
    6402:	21 f1       	breq	.+72     	; 0x644c <Endpoint_Write_Stream_BE+0x8c>
    6404:	80 91 e8 00 	lds	r24, 0x00E8
    6408:	85 fd       	sbrc	r24, 5
    640a:	16 c0       	rjmp	.+44     	; 0x6438 <Endpoint_Write_Stream_BE+0x78>
    640c:	80 91 e8 00 	lds	r24, 0x00E8
    6410:	8e 77       	andi	r24, 0x7E	; 126
    6412:	80 93 e8 00 	sts	0x00E8, r24
    6416:	d3 d4       	rcall	.+2470   	; 0x6dbe <USB_USBTask>
    6418:	e1 14       	cp	r14, r1
    641a:	f1 04       	cpc	r15, r1
    641c:	49 f0       	breq	.+18     	; 0x6430 <Endpoint_Write_Stream_BE+0x70>
    641e:	f7 01       	movw	r30, r14
    6420:	80 81       	ld	r24, Z
    6422:	91 81       	ldd	r25, Z+1	; 0x01
    6424:	c8 0e       	add	r12, r24
    6426:	d9 1e       	adc	r13, r25
    6428:	d1 82       	std	Z+1, r13	; 0x01
    642a:	c0 82       	st	Z, r12
    642c:	85 e0       	ldi	r24, 0x05	; 5
    642e:	0f c0       	rjmp	.+30     	; 0x644e <Endpoint_Write_Stream_BE+0x8e>
    6430:	01 d2       	rcall	.+1026   	; 0x6834 <Endpoint_WaitUntilReady>
    6432:	88 23       	and	r24, r24
    6434:	21 f3       	breq	.-56     	; 0x63fe <Endpoint_Write_Stream_BE+0x3e>
    6436:	0b c0       	rjmp	.+22     	; 0x644e <Endpoint_Write_Stream_BE+0x8e>
    6438:	88 81       	ld	r24, Y
    643a:	80 93 f1 00 	sts	0x00F1, r24
    643e:	21 97       	sbiw	r28, 0x01	; 1
    6440:	01 50       	subi	r16, 0x01	; 1
    6442:	11 09       	sbc	r17, r1
    6444:	ff ef       	ldi	r31, 0xFF	; 255
    6446:	cf 1a       	sub	r12, r31
    6448:	df 0a       	sbc	r13, r31
    644a:	d9 cf       	rjmp	.-78     	; 0x63fe <Endpoint_Write_Stream_BE+0x3e>
    644c:	80 e0       	ldi	r24, 0x00	; 0
    644e:	df 91       	pop	r29
    6450:	cf 91       	pop	r28
    6452:	1f 91       	pop	r17
    6454:	0f 91       	pop	r16
    6456:	ff 90       	pop	r15
    6458:	ef 90       	pop	r14
    645a:	df 90       	pop	r13
    645c:	cf 90       	pop	r12
    645e:	08 95       	ret

00006460 <Endpoint_Read_Stream_LE>:
    6460:	cf 92       	push	r12
    6462:	df 92       	push	r13
    6464:	ef 92       	push	r14
    6466:	ff 92       	push	r15
    6468:	0f 93       	push	r16
    646a:	1f 93       	push	r17
    646c:	cf 93       	push	r28
    646e:	df 93       	push	r29
    6470:	ec 01       	movw	r28, r24
    6472:	8b 01       	movw	r16, r22
    6474:	7a 01       	movw	r14, r20
    6476:	de d1       	rcall	.+956    	; 0x6834 <Endpoint_WaitUntilReady>
    6478:	81 11       	cpse	r24, r1
    647a:	33 c0       	rjmp	.+102    	; 0x64e2 <Endpoint_Read_Stream_LE+0x82>
    647c:	e1 14       	cp	r14, r1
    647e:	f1 04       	cpc	r15, r1
    6480:	39 f0       	breq	.+14     	; 0x6490 <Endpoint_Read_Stream_LE+0x30>
    6482:	f7 01       	movw	r30, r14
    6484:	80 81       	ld	r24, Z
    6486:	91 81       	ldd	r25, Z+1	; 0x01
    6488:	08 1b       	sub	r16, r24
    648a:	19 0b       	sbc	r17, r25
    648c:	c8 0f       	add	r28, r24
    648e:	d9 1f       	adc	r29, r25
    6490:	c1 2c       	mov	r12, r1
    6492:	d1 2c       	mov	r13, r1
    6494:	01 15       	cp	r16, r1
    6496:	11 05       	cpc	r17, r1
    6498:	19 f1       	breq	.+70     	; 0x64e0 <Endpoint_Read_Stream_LE+0x80>
    649a:	80 91 e8 00 	lds	r24, 0x00E8
    649e:	85 fd       	sbrc	r24, 5
    64a0:	16 c0       	rjmp	.+44     	; 0x64ce <Endpoint_Read_Stream_LE+0x6e>
    64a2:	80 91 e8 00 	lds	r24, 0x00E8
    64a6:	8b 77       	andi	r24, 0x7B	; 123
    64a8:	80 93 e8 00 	sts	0x00E8, r24
    64ac:	88 d4       	rcall	.+2320   	; 0x6dbe <USB_USBTask>
    64ae:	e1 14       	cp	r14, r1
    64b0:	f1 04       	cpc	r15, r1
    64b2:	49 f0       	breq	.+18     	; 0x64c6 <Endpoint_Read_Stream_LE+0x66>
    64b4:	f7 01       	movw	r30, r14
    64b6:	80 81       	ld	r24, Z
    64b8:	91 81       	ldd	r25, Z+1	; 0x01
    64ba:	c8 0e       	add	r12, r24
    64bc:	d9 1e       	adc	r13, r25
    64be:	d1 82       	std	Z+1, r13	; 0x01
    64c0:	c0 82       	st	Z, r12
    64c2:	85 e0       	ldi	r24, 0x05	; 5
    64c4:	0e c0       	rjmp	.+28     	; 0x64e2 <Endpoint_Read_Stream_LE+0x82>
    64c6:	b6 d1       	rcall	.+876    	; 0x6834 <Endpoint_WaitUntilReady>
    64c8:	88 23       	and	r24, r24
    64ca:	21 f3       	breq	.-56     	; 0x6494 <Endpoint_Read_Stream_LE+0x34>
    64cc:	0a c0       	rjmp	.+20     	; 0x64e2 <Endpoint_Read_Stream_LE+0x82>
    64ce:	80 91 f1 00 	lds	r24, 0x00F1
    64d2:	89 93       	st	Y+, r24
    64d4:	01 50       	subi	r16, 0x01	; 1
    64d6:	11 09       	sbc	r17, r1
    64d8:	ff ef       	ldi	r31, 0xFF	; 255
    64da:	cf 1a       	sub	r12, r31
    64dc:	df 0a       	sbc	r13, r31
    64de:	da cf       	rjmp	.-76     	; 0x6494 <Endpoint_Read_Stream_LE+0x34>
    64e0:	80 e0       	ldi	r24, 0x00	; 0
    64e2:	df 91       	pop	r29
    64e4:	cf 91       	pop	r28
    64e6:	1f 91       	pop	r17
    64e8:	0f 91       	pop	r16
    64ea:	ff 90       	pop	r15
    64ec:	ef 90       	pop	r14
    64ee:	df 90       	pop	r13
    64f0:	cf 90       	pop	r12
    64f2:	08 95       	ret

000064f4 <Endpoint_Write_Control_Stream_LE>:
    64f4:	20 91 bb 09 	lds	r18, 0x09BB
    64f8:	30 91 bc 09 	lds	r19, 0x09BC
    64fc:	26 17       	cp	r18, r22
    64fe:	37 07       	cpc	r19, r23
    6500:	48 f0       	brcs	.+18     	; 0x6514 <Endpoint_Write_Control_Stream_LE+0x20>
    6502:	61 15       	cp	r22, r1
    6504:	71 05       	cpc	r23, r1
    6506:	39 f4       	brne	.+14     	; 0x6516 <Endpoint_Write_Control_Stream_LE+0x22>
    6508:	20 91 e8 00 	lds	r18, 0x00E8
    650c:	2e 77       	andi	r18, 0x7E	; 126
    650e:	20 93 e8 00 	sts	0x00E8, r18
    6512:	01 c0       	rjmp	.+2      	; 0x6516 <Endpoint_Write_Control_Stream_LE+0x22>
    6514:	b9 01       	movw	r22, r18
    6516:	40 e0       	ldi	r20, 0x00	; 0
    6518:	61 15       	cp	r22, r1
    651a:	71 05       	cpc	r23, r1
    651c:	a9 f1       	breq	.+106    	; 0x6588 <Endpoint_Write_Control_Stream_LE+0x94>
    651e:	20 91 b4 09 	lds	r18, 0x09B4
    6522:	22 23       	and	r18, r18
    6524:	09 f4       	brne	.+2      	; 0x6528 <Endpoint_Write_Control_Stream_LE+0x34>
    6526:	43 c0       	rjmp	.+134    	; 0x65ae <Endpoint_Write_Control_Stream_LE+0xba>
    6528:	25 30       	cpi	r18, 0x05	; 5
    652a:	09 f4       	brne	.+2      	; 0x652e <Endpoint_Write_Control_Stream_LE+0x3a>
    652c:	42 c0       	rjmp	.+132    	; 0x65b2 <Endpoint_Write_Control_Stream_LE+0xbe>
    652e:	20 91 e8 00 	lds	r18, 0x00E8
    6532:	23 fd       	sbrc	r18, 3
    6534:	40 c0       	rjmp	.+128    	; 0x65b6 <Endpoint_Write_Control_Stream_LE+0xc2>
    6536:	20 91 e8 00 	lds	r18, 0x00E8
    653a:	22 fd       	sbrc	r18, 2
    653c:	32 c0       	rjmp	.+100    	; 0x65a2 <Endpoint_Write_Control_Stream_LE+0xae>
    653e:	20 91 e8 00 	lds	r18, 0x00E8
    6542:	20 ff       	sbrs	r18, 0
    6544:	e9 cf       	rjmp	.-46     	; 0x6518 <Endpoint_Write_Control_Stream_LE+0x24>
    6546:	40 91 f3 00 	lds	r20, 0x00F3
    654a:	20 91 f2 00 	lds	r18, 0x00F2
    654e:	30 e0       	ldi	r19, 0x00	; 0
    6550:	34 2b       	or	r19, r20
    6552:	fc 01       	movw	r30, r24
    6554:	cf 01       	movw	r24, r30
    6556:	61 15       	cp	r22, r1
    6558:	71 05       	cpc	r23, r1
    655a:	59 f0       	breq	.+22     	; 0x6572 <Endpoint_Write_Control_Stream_LE+0x7e>
    655c:	28 30       	cpi	r18, 0x08	; 8
    655e:	31 05       	cpc	r19, r1
    6560:	40 f4       	brcc	.+16     	; 0x6572 <Endpoint_Write_Control_Stream_LE+0x7e>
    6562:	81 91       	ld	r24, Z+
    6564:	80 93 f1 00 	sts	0x00F1, r24
    6568:	61 50       	subi	r22, 0x01	; 1
    656a:	71 09       	sbc	r23, r1
    656c:	2f 5f       	subi	r18, 0xFF	; 255
    656e:	3f 4f       	sbci	r19, 0xFF	; 255
    6570:	f1 cf       	rjmp	.-30     	; 0x6554 <Endpoint_Write_Control_Stream_LE+0x60>
    6572:	41 e0       	ldi	r20, 0x01	; 1
    6574:	28 30       	cpi	r18, 0x08	; 8
    6576:	31 05       	cpc	r19, r1
    6578:	09 f0       	breq	.+2      	; 0x657c <Endpoint_Write_Control_Stream_LE+0x88>
    657a:	40 e0       	ldi	r20, 0x00	; 0
    657c:	20 91 e8 00 	lds	r18, 0x00E8
    6580:	2e 77       	andi	r18, 0x7E	; 126
    6582:	20 93 e8 00 	sts	0x00E8, r18
    6586:	c8 cf       	rjmp	.-112    	; 0x6518 <Endpoint_Write_Control_Stream_LE+0x24>
    6588:	41 11       	cpse	r20, r1
    658a:	c9 cf       	rjmp	.-110    	; 0x651e <Endpoint_Write_Control_Stream_LE+0x2a>
    658c:	0a c0       	rjmp	.+20     	; 0x65a2 <Endpoint_Write_Control_Stream_LE+0xae>
    658e:	80 91 b4 09 	lds	r24, 0x09B4
    6592:	88 23       	and	r24, r24
    6594:	61 f0       	breq	.+24     	; 0x65ae <Endpoint_Write_Control_Stream_LE+0xba>
    6596:	85 30       	cpi	r24, 0x05	; 5
    6598:	61 f0       	breq	.+24     	; 0x65b2 <Endpoint_Write_Control_Stream_LE+0xbe>
    659a:	80 91 e8 00 	lds	r24, 0x00E8
    659e:	83 fd       	sbrc	r24, 3
    65a0:	0a c0       	rjmp	.+20     	; 0x65b6 <Endpoint_Write_Control_Stream_LE+0xc2>
    65a2:	80 91 e8 00 	lds	r24, 0x00E8
    65a6:	82 ff       	sbrs	r24, 2
    65a8:	f2 cf       	rjmp	.-28     	; 0x658e <Endpoint_Write_Control_Stream_LE+0x9a>
    65aa:	80 e0       	ldi	r24, 0x00	; 0
    65ac:	08 95       	ret
    65ae:	82 e0       	ldi	r24, 0x02	; 2
    65b0:	08 95       	ret
    65b2:	83 e0       	ldi	r24, 0x03	; 3
    65b4:	08 95       	ret
    65b6:	81 e0       	ldi	r24, 0x01	; 1
    65b8:	08 95       	ret

000065ba <Endpoint_Read_Control_Stream_LE>:
    65ba:	61 15       	cp	r22, r1
    65bc:	71 05       	cpc	r23, r1
    65be:	29 f4       	brne	.+10     	; 0x65ca <Endpoint_Read_Control_Stream_LE+0x10>
    65c0:	20 91 e8 00 	lds	r18, 0x00E8
    65c4:	2b 77       	andi	r18, 0x7B	; 123
    65c6:	20 93 e8 00 	sts	0x00E8, r18
    65ca:	fc 01       	movw	r30, r24
    65cc:	61 15       	cp	r22, r1
    65ce:	71 05       	cpc	r23, r1
    65d0:	41 f1       	breq	.+80     	; 0x6622 <Endpoint_Read_Control_Stream_LE+0x68>
    65d2:	80 91 b4 09 	lds	r24, 0x09B4
    65d6:	88 23       	and	r24, r24
    65d8:	61 f1       	breq	.+88     	; 0x6632 <Endpoint_Read_Control_Stream_LE+0x78>
    65da:	85 30       	cpi	r24, 0x05	; 5
    65dc:	61 f1       	breq	.+88     	; 0x6636 <Endpoint_Read_Control_Stream_LE+0x7c>
    65de:	80 91 e8 00 	lds	r24, 0x00E8
    65e2:	83 fd       	sbrc	r24, 3
    65e4:	24 c0       	rjmp	.+72     	; 0x662e <Endpoint_Read_Control_Stream_LE+0x74>
    65e6:	80 91 e8 00 	lds	r24, 0x00E8
    65ea:	82 ff       	sbrs	r24, 2
    65ec:	ef cf       	rjmp	.-34     	; 0x65cc <Endpoint_Read_Control_Stream_LE+0x12>
    65ee:	20 91 f3 00 	lds	r18, 0x00F3
    65f2:	80 91 f2 00 	lds	r24, 0x00F2
    65f6:	90 e0       	ldi	r25, 0x00	; 0
    65f8:	92 2b       	or	r25, r18
    65fa:	89 2b       	or	r24, r25
    65fc:	31 f0       	breq	.+12     	; 0x660a <Endpoint_Read_Control_Stream_LE+0x50>
    65fe:	80 91 f1 00 	lds	r24, 0x00F1
    6602:	81 93       	st	Z+, r24
    6604:	61 50       	subi	r22, 0x01	; 1
    6606:	71 09       	sbc	r23, r1
    6608:	91 f7       	brne	.-28     	; 0x65ee <Endpoint_Read_Control_Stream_LE+0x34>
    660a:	80 91 e8 00 	lds	r24, 0x00E8
    660e:	8b 77       	andi	r24, 0x7B	; 123
    6610:	80 93 e8 00 	sts	0x00E8, r24
    6614:	db cf       	rjmp	.-74     	; 0x65cc <Endpoint_Read_Control_Stream_LE+0x12>
    6616:	80 91 b4 09 	lds	r24, 0x09B4
    661a:	88 23       	and	r24, r24
    661c:	51 f0       	breq	.+20     	; 0x6632 <Endpoint_Read_Control_Stream_LE+0x78>
    661e:	85 30       	cpi	r24, 0x05	; 5
    6620:	51 f0       	breq	.+20     	; 0x6636 <Endpoint_Read_Control_Stream_LE+0x7c>
    6622:	80 91 e8 00 	lds	r24, 0x00E8
    6626:	80 ff       	sbrs	r24, 0
    6628:	f6 cf       	rjmp	.-20     	; 0x6616 <Endpoint_Read_Control_Stream_LE+0x5c>
    662a:	80 e0       	ldi	r24, 0x00	; 0
    662c:	08 95       	ret
    662e:	81 e0       	ldi	r24, 0x01	; 1
    6630:	08 95       	ret
    6632:	82 e0       	ldi	r24, 0x02	; 2
    6634:	08 95       	ret
    6636:	83 e0       	ldi	r24, 0x03	; 3
    6638:	08 95       	ret

0000663a <Endpoint_Write_Control_PStream_LE>:
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    663a:	20 91 bb 09 	lds	r18, 0x09BB
    663e:	30 91 bc 09 	lds	r19, 0x09BC
    6642:	26 17       	cp	r18, r22
    6644:	37 07       	cpc	r19, r23
    6646:	48 f0       	brcs	.+18     	; 0x665a <Endpoint_Write_Control_PStream_LE+0x20>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    6648:	61 15       	cp	r22, r1
    664a:	71 05       	cpc	r23, r1
    664c:	39 f4       	brne	.+14     	; 0x665c <Endpoint_Write_Control_PStream_LE+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    664e:	20 91 e8 00 	lds	r18, 0x00E8
    6652:	2e 77       	andi	r18, 0x7E	; 126
    6654:	20 93 e8 00 	sts	0x00E8, r18
    6658:	01 c0       	rjmp	.+2      	; 0x665c <Endpoint_Write_Control_PStream_LE+0x22>
    665a:	b9 01       	movw	r22, r18
    665c:	fc 01       	movw	r30, r24
    665e:	20 e0       	ldi	r18, 0x00	; 0
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    6660:	61 15       	cp	r22, r1
    6662:	71 05       	cpc	r23, r1
    6664:	91 f1       	breq	.+100    	; 0x66ca <Endpoint_Write_Control_PStream_LE+0x90>
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    6666:	80 91 b4 09 	lds	r24, 0x09B4

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    666a:	88 23       	and	r24, r24
    666c:	09 f4       	brne	.+2      	; 0x6670 <Endpoint_Write_Control_PStream_LE+0x36>
    666e:	40 c0       	rjmp	.+128    	; 0x66f0 <Endpoint_Write_Control_PStream_LE+0xb6>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    6670:	85 30       	cpi	r24, 0x05	; 5
    6672:	09 f4       	brne	.+2      	; 0x6676 <Endpoint_Write_Control_PStream_LE+0x3c>
    6674:	3f c0       	rjmp	.+126    	; 0x66f4 <Endpoint_Write_Control_PStream_LE+0xba>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6676:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    667a:	83 fd       	sbrc	r24, 3
    667c:	3d c0       	rjmp	.+122    	; 0x66f8 <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    667e:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    6682:	82 fd       	sbrc	r24, 2
    6684:	2f c0       	rjmp	.+94     	; 0x66e4 <Endpoint_Write_Control_PStream_LE+0xaa>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6686:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    668a:	80 ff       	sbrs	r24, 0
    668c:	e9 cf       	rjmp	.-46     	; 0x6660 <Endpoint_Write_Control_PStream_LE+0x26>
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
    668e:	20 91 f3 00 	lds	r18, 0x00F3
    6692:	80 91 f2 00 	lds	r24, 0x00F2
    6696:	90 e0       	ldi	r25, 0x00	; 0
    6698:	92 2b       	or	r25, r18
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    669a:	61 15       	cp	r22, r1
    669c:	71 05       	cpc	r23, r1
    669e:	59 f0       	breq	.+22     	; 0x66b6 <Endpoint_Write_Control_PStream_LE+0x7c>
    66a0:	88 30       	cpi	r24, 0x08	; 8
    66a2:	91 05       	cpc	r25, r1
    66a4:	40 f4       	brcc	.+16     	; 0x66b6 <Endpoint_Write_Control_PStream_LE+0x7c>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    66a6:	24 91       	lpm	r18, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    66a8:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    66ac:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    66ae:	61 50       	subi	r22, 0x01	; 1
    66b0:	71 09       	sbc	r23, r1
				BytesInEndpoint++;
    66b2:	01 96       	adiw	r24, 0x01	; 1
    66b4:	f2 cf       	rjmp	.-28     	; 0x669a <Endpoint_Write_Control_PStream_LE+0x60>
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    66b6:	21 e0       	ldi	r18, 0x01	; 1
    66b8:	08 97       	sbiw	r24, 0x08	; 8
    66ba:	09 f0       	breq	.+2      	; 0x66be <Endpoint_Write_Control_PStream_LE+0x84>
    66bc:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    66be:	80 91 e8 00 	lds	r24, 0x00E8
    66c2:	8e 77       	andi	r24, 0x7E	; 126
    66c4:	80 93 e8 00 	sts	0x00E8, r24
    66c8:	cb cf       	rjmp	.-106    	; 0x6660 <Endpoint_Write_Control_PStream_LE+0x26>
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    66ca:	21 11       	cpse	r18, r1
    66cc:	cc cf       	rjmp	.-104    	; 0x6666 <Endpoint_Write_Control_PStream_LE+0x2c>
    66ce:	0a c0       	rjmp	.+20     	; 0x66e4 <Endpoint_Write_Control_PStream_LE+0xaa>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    66d0:	80 91 b4 09 	lds	r24, 0x09B4

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    66d4:	88 23       	and	r24, r24
    66d6:	61 f0       	breq	.+24     	; 0x66f0 <Endpoint_Write_Control_PStream_LE+0xb6>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    66d8:	85 30       	cpi	r24, 0x05	; 5
    66da:	61 f0       	breq	.+24     	; 0x66f4 <Endpoint_Write_Control_PStream_LE+0xba>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    66dc:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    66e0:	83 fd       	sbrc	r24, 3
    66e2:	0a c0       	rjmp	.+20     	; 0x66f8 <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    66e4:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    66e8:	82 ff       	sbrs	r24, 2
    66ea:	f2 cf       	rjmp	.-28     	; 0x66d0 <Endpoint_Write_Control_PStream_LE+0x96>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    66ec:	80 e0       	ldi	r24, 0x00	; 0
    66ee:	08 95       	ret
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    66f0:	82 e0       	ldi	r24, 0x02	; 2
    66f2:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    66f4:	83 e0       	ldi	r24, 0x03	; 3
    66f6:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    66f8:	81 e0       	ldi	r24, 0x01	; 1
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    66fa:	08 95       	ret

000066fc <Endpoint_ConfigureEndpoint_Prv>:
		UEIENX  = 0;
		UEINTX  = 0;
		UECFG1X = 0;
		Endpoint_DisableEndpoint();
	}
}
    66fc:	98 2f       	mov	r25, r24
    66fe:	97 30       	cpi	r25, 0x07	; 7
    6700:	58 f5       	brcc	.+86     	; 0x6758 <Endpoint_ConfigureEndpoint_Prv+0x5c>
    6702:	90 93 e9 00 	sts	0x00E9, r25
    6706:	98 17       	cp	r25, r24
    6708:	39 f0       	breq	.+14     	; 0x6718 <Endpoint_ConfigureEndpoint_Prv+0x1c>
    670a:	70 91 ec 00 	lds	r23, 0x00EC
    670e:	20 91 ed 00 	lds	r18, 0x00ED
    6712:	50 91 f0 00 	lds	r21, 0x00F0
    6716:	03 c0       	rjmp	.+6      	; 0x671e <Endpoint_ConfigureEndpoint_Prv+0x22>
    6718:	24 2f       	mov	r18, r20
    671a:	76 2f       	mov	r23, r22
    671c:	50 e0       	ldi	r21, 0x00	; 0
    671e:	21 ff       	sbrs	r18, 1
    6720:	19 c0       	rjmp	.+50     	; 0x6754 <Endpoint_ConfigureEndpoint_Prv+0x58>
    6722:	30 91 eb 00 	lds	r19, 0x00EB
    6726:	3e 7f       	andi	r19, 0xFE	; 254
    6728:	30 93 eb 00 	sts	0x00EB, r19
    672c:	30 91 ed 00 	lds	r19, 0x00ED
    6730:	3d 7f       	andi	r19, 0xFD	; 253
    6732:	30 93 ed 00 	sts	0x00ED, r19
    6736:	30 91 eb 00 	lds	r19, 0x00EB
    673a:	31 60       	ori	r19, 0x01	; 1
    673c:	30 93 eb 00 	sts	0x00EB, r19
    6740:	70 93 ec 00 	sts	0x00EC, r23
    6744:	20 93 ed 00 	sts	0x00ED, r18
    6748:	50 93 f0 00 	sts	0x00F0, r21
    674c:	20 91 ee 00 	lds	r18, 0x00EE
    6750:	27 ff       	sbrs	r18, 7
    6752:	07 c0       	rjmp	.+14     	; 0x6762 <Endpoint_ConfigureEndpoint_Prv+0x66>
    6754:	9f 5f       	subi	r25, 0xFF	; 255
    6756:	d3 cf       	rjmp	.-90     	; 0x66fe <Endpoint_ConfigureEndpoint_Prv+0x2>
    6758:	8f 70       	andi	r24, 0x0F	; 15
    675a:	80 93 e9 00 	sts	0x00E9, r24
    675e:	81 e0       	ldi	r24, 0x01	; 1
    6760:	08 95       	ret
    6762:	80 e0       	ldi	r24, 0x00	; 0
    6764:	08 95       	ret

00006766 <Endpoint_ConfigureEndpointTable>:
    6766:	ef 92       	push	r14
    6768:	ff 92       	push	r15
    676a:	0f 93       	push	r16
    676c:	1f 93       	push	r17
    676e:	cf 93       	push	r28
    6770:	df 93       	push	r29
    6772:	e6 2e       	mov	r14, r22
    6774:	ec 01       	movw	r28, r24
    6776:	8c 01       	movw	r16, r24
    6778:	0c 5f       	subi	r16, 0xFC	; 252
    677a:	1f 4f       	sbci	r17, 0xFF	; 255
    677c:	f1 2c       	mov	r15, r1
    677e:	fe 14       	cp	r15, r14
    6780:	91 f1       	breq	.+100    	; 0x67e6 <Endpoint_ConfigureEndpointTable+0x80>
    6782:	58 81       	ld	r21, Y
    6784:	55 23       	and	r21, r21
    6786:	51 f1       	breq	.+84     	; 0x67dc <Endpoint_ConfigureEndpointTable+0x76>
    6788:	f8 01       	movw	r30, r16
    678a:	20 81       	ld	r18, Z
    678c:	69 81       	ldd	r22, Y+1	; 0x01
    678e:	7a 81       	ldd	r23, Y+2	; 0x02
    6790:	31 97       	sbiw	r30, 0x01	; 1
    6792:	90 81       	ld	r25, Z
    6794:	85 2f       	mov	r24, r21
    6796:	8f 70       	andi	r24, 0x0F	; 15
    6798:	87 30       	cpi	r24, 0x07	; 7
    679a:	10 f0       	brcs	.+4      	; 0x67a0 <Endpoint_ConfigureEndpointTable+0x3a>
    679c:	80 e0       	ldi	r24, 0x00	; 0
    679e:	24 c0       	rjmp	.+72     	; 0x67e8 <Endpoint_ConfigureEndpointTable+0x82>
    67a0:	22 30       	cpi	r18, 0x02	; 2
    67a2:	10 f4       	brcc	.+4      	; 0x67a8 <Endpoint_ConfigureEndpointTable+0x42>
    67a4:	42 e0       	ldi	r20, 0x02	; 2
    67a6:	01 c0       	rjmp	.+2      	; 0x67aa <Endpoint_ConfigureEndpointTable+0x44>
    67a8:	46 e0       	ldi	r20, 0x06	; 6
    67aa:	e8 e0       	ldi	r30, 0x08	; 8
    67ac:	f0 e0       	ldi	r31, 0x00	; 0
    67ae:	20 e0       	ldi	r18, 0x00	; 0
    67b0:	e6 17       	cp	r30, r22
    67b2:	f7 07       	cpc	r31, r23
    67b4:	20 f4       	brcc	.+8      	; 0x67be <Endpoint_ConfigureEndpointTable+0x58>
    67b6:	2f 5f       	subi	r18, 0xFF	; 255
    67b8:	ee 0f       	add	r30, r30
    67ba:	ff 1f       	adc	r31, r31
    67bc:	f9 cf       	rjmp	.-14     	; 0x67b0 <Endpoint_ConfigureEndpointTable+0x4a>
    67be:	22 95       	swap	r18
    67c0:	20 7f       	andi	r18, 0xF0	; 240
    67c2:	42 2b       	or	r20, r18
    67c4:	f0 e4       	ldi	r31, 0x40	; 64
    67c6:	9f 9f       	mul	r25, r31
    67c8:	90 01       	movw	r18, r0
    67ca:	11 24       	eor	r1, r1
    67cc:	55 1f       	adc	r21, r21
    67ce:	55 27       	eor	r21, r21
    67d0:	55 1f       	adc	r21, r21
    67d2:	65 2f       	mov	r22, r21
    67d4:	62 2b       	or	r22, r18
    67d6:	92 df       	rcall	.-220    	; 0x66fc <Endpoint_ConfigureEndpoint_Prv>
    67d8:	88 23       	and	r24, r24
    67da:	01 f3       	breq	.-64     	; 0x679c <Endpoint_ConfigureEndpointTable+0x36>
    67dc:	f3 94       	inc	r15
    67de:	25 96       	adiw	r28, 0x05	; 5
    67e0:	0b 5f       	subi	r16, 0xFB	; 251
    67e2:	1f 4f       	sbci	r17, 0xFF	; 255
    67e4:	cc cf       	rjmp	.-104    	; 0x677e <Endpoint_ConfigureEndpointTable+0x18>
    67e6:	81 e0       	ldi	r24, 0x01	; 1
    67e8:	df 91       	pop	r29
    67ea:	cf 91       	pop	r28
    67ec:	1f 91       	pop	r17
    67ee:	0f 91       	pop	r16
    67f0:	ff 90       	pop	r15
    67f2:	ef 90       	pop	r14
    67f4:	08 95       	ret

000067f6 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    67f6:	80 91 b5 09 	lds	r24, 0x09B5
    67fa:	87 ff       	sbrs	r24, 7
    67fc:	11 c0       	rjmp	.+34     	; 0x6820 <Endpoint_ClearStatusStage+0x2a>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    67fe:	80 91 e8 00 	lds	r24, 0x00E8
	{
		while (!(Endpoint_IsOUTReceived()))
    6802:	82 fd       	sbrc	r24, 2
    6804:	05 c0       	rjmp	.+10     	; 0x6810 <Endpoint_ClearStatusStage+0x1a>
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    6806:	80 91 b4 09 	lds	r24, 0x09B4
    680a:	81 11       	cpse	r24, r1
    680c:	f8 cf       	rjmp	.-16     	; 0x67fe <Endpoint_ClearStatusStage+0x8>
    680e:	11 c0       	rjmp	.+34     	; 0x6832 <Endpoint_ClearStatusStage+0x3c>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6810:	80 91 e8 00 	lds	r24, 0x00E8
    6814:	8b 77       	andi	r24, 0x7B	; 123
    6816:	0b c0       	rjmp	.+22     	; 0x682e <Endpoint_ClearStatusStage+0x38>
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    6818:	80 91 b4 09 	lds	r24, 0x09B4
    681c:	88 23       	and	r24, r24
    681e:	49 f0       	breq	.+18     	; 0x6832 <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6820:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    6824:	80 ff       	sbrs	r24, 0
    6826:	f8 cf       	rjmp	.-16     	; 0x6818 <Endpoint_ClearStatusStage+0x22>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6828:	80 91 e8 00 	lds	r24, 0x00E8
    682c:	8e 77       	andi	r24, 0x7E	; 126
    682e:	80 93 e8 00 	sts	0x00E8, r24
    6832:	08 95       	ret

00006834 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    6834:	20 91 e4 00 	lds	r18, 0x00E4
    6838:	30 91 e5 00 	lds	r19, 0x00E5
    683c:	95 e6       	ldi	r25, 0x65	; 101
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    683e:	40 91 ec 00 	lds	r20, 0x00EC
    6842:	84 2f       	mov	r24, r20
    6844:	81 70       	andi	r24, 0x01	; 1
    6846:	40 ff       	sbrs	r20, 0
    6848:	22 c0       	rjmp	.+68     	; 0x688e <Endpoint_WaitUntilReady+0x5a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    684a:	80 91 e8 00 	lds	r24, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    684e:	80 fd       	sbrc	r24, 0
    6850:	1c c0       	rjmp	.+56     	; 0x688a <Endpoint_WaitUntilReady+0x56>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    6852:	80 91 b4 09 	lds	r24, 0x09B4

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    6856:	88 23       	and	r24, r24
    6858:	91 f0       	breq	.+36     	; 0x687e <Endpoint_WaitUntilReady+0x4a>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    685a:	85 30       	cpi	r24, 0x05	; 5
    685c:	91 f0       	breq	.+36     	; 0x6882 <Endpoint_WaitUntilReady+0x4e>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    685e:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    6862:	85 fd       	sbrc	r24, 5
    6864:	10 c0       	rjmp	.+32     	; 0x6886 <Endpoint_WaitUntilReady+0x52>
    6866:	40 91 e4 00 	lds	r20, 0x00E4
    686a:	50 91 e5 00 	lds	r21, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    686e:	42 17       	cp	r20, r18
    6870:	53 07       	cpc	r21, r19
    6872:	29 f3       	breq	.-54     	; 0x683e <Endpoint_WaitUntilReady+0xa>
    6874:	9a 01       	movw	r18, r20
    6876:	91 50       	subi	r25, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    6878:	11 f7       	brne	.-60     	; 0x683e <Endpoint_WaitUntilReady+0xa>
			  return ENDPOINT_READYWAIT_Timeout;
    687a:	84 e0       	ldi	r24, 0x04	; 4
    687c:	08 95       	ret
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    687e:	82 e0       	ldi	r24, 0x02	; 2
    6880:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    6882:	83 e0       	ldi	r24, 0x03	; 3
    6884:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    6886:	81 e0       	ldi	r24, 0x01	; 1
    6888:	08 95       	ret
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    688a:	80 e0       	ldi	r24, 0x00	; 0
    688c:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    688e:	40 91 e8 00 	lds	r20, 0x00E8
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    6892:	42 ff       	sbrs	r20, 2
    6894:	de cf       	rjmp	.-68     	; 0x6852 <Endpoint_WaitUntilReady+0x1e>

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    6896:	08 95       	ret

00006898 <USB_Disable>:
	USB_ResetInterface();
}

void USB_Disable(void)
{
	USB_INT_DisableAllInterrupts();
    6898:	67 d0       	rcall	.+206    	; 0x6968 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    689a:	6e d0       	rcall	.+220    	; 0x6978 <USB_INT_ClearAllInterrupts>
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    689c:	e0 ee       	ldi	r30, 0xE0	; 224
    689e:	f0 e0       	ldi	r31, 0x00	; 0
    68a0:	80 81       	ld	r24, Z
    68a2:	81 60       	ori	r24, 0x01	; 1
    68a4:	80 83       	st	Z, r24
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USBCON &= ~(1 << USBE);
    68a6:	e8 ed       	ldi	r30, 0xD8	; 216
    68a8:	f0 e0       	ldi	r31, 0x00	; 0
    68aa:	80 81       	ld	r24, Z
    68ac:	8f 77       	andi	r24, 0x7F	; 127
    68ae:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    68b0:	19 bc       	out	0x29, r1	; 41

			static inline void USB_REG_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_Off(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON &= ~(1 << UVREGE);
    68b2:	a7 ed       	ldi	r26, 0xD7	; 215
    68b4:	b0 e0       	ldi	r27, 0x00	; 0
    68b6:	8c 91       	ld	r24, X
    68b8:	8e 7f       	andi	r24, 0xFE	; 254
    68ba:	8c 93       	st	X, r24
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    68bc:	80 81       	ld	r24, Z
    68be:	8f 7e       	andi	r24, 0xEF	; 239
    68c0:	80 83       	st	Z, r24

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
    68c2:	10 92 b3 09 	sts	0x09B3, r1
    68c6:	08 95       	ret

000068c8 <USB_ResetInterface>:
}

void USB_ResetInterface(void)
{
    68c8:	0f 93       	push	r16
    68ca:	1f 93       	push	r17
    68cc:	cf 93       	push	r28
    68ce:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    68d0:	4b d0       	rcall	.+150    	; 0x6968 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    68d2:	52 d0       	rcall	.+164    	; 0x6978 <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    68d4:	c8 ed       	ldi	r28, 0xD8	; 216
    68d6:	d0 e0       	ldi	r29, 0x00	; 0
    68d8:	88 81       	ld	r24, Y
    68da:	8f 77       	andi	r24, 0x7F	; 127
    68dc:	88 83       	st	Y, r24
				USBCON |=  (1 << USBE);
    68de:	88 81       	ld	r24, Y
    68e0:	80 68       	ori	r24, 0x80	; 128
    68e2:	88 83       	st	Y, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    68e4:	88 81       	ld	r24, Y
    68e6:	8f 7d       	andi	r24, 0xDF	; 223
    68e8:	88 83       	st	Y, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    68ea:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    68ec:	10 92 b4 09 	sts	0x09B4, r1
	USB_Device_ConfigurationNumber  = 0;
    68f0:	10 92 b0 09 	sts	0x09B0, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    68f4:	10 92 b2 09 	sts	0x09B2, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    68f8:	10 92 b1 09 	sts	0x09B1, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    68fc:	00 ee       	ldi	r16, 0xE0	; 224
    68fe:	10 e0       	ldi	r17, 0x00	; 0
    6900:	f8 01       	movw	r30, r16
    6902:	80 81       	ld	r24, Z
    6904:	8b 7f       	andi	r24, 0xFB	; 251
    6906:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    6908:	88 81       	ld	r24, Y
    690a:	81 60       	ori	r24, 0x01	; 1
    690c:	88 83       	st	Y, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    690e:	42 e0       	ldi	r20, 0x02	; 2
    6910:	60 e0       	ldi	r22, 0x00	; 0
    6912:	80 e0       	ldi	r24, 0x00	; 0
    6914:	f3 de       	rcall	.-538    	; 0x66fc <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    6916:	e1 ee       	ldi	r30, 0xE1	; 225
    6918:	f0 e0       	ldi	r31, 0x00	; 0
    691a:	80 81       	ld	r24, Z
    691c:	8e 7f       	andi	r24, 0xFE	; 254
    691e:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    6920:	e2 ee       	ldi	r30, 0xE2	; 226
    6922:	f0 e0       	ldi	r31, 0x00	; 0
    6924:	80 81       	ld	r24, Z
    6926:	81 60       	ori	r24, 0x01	; 1
    6928:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    692a:	80 81       	ld	r24, Z
    692c:	88 60       	ori	r24, 0x08	; 8
    692e:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    6930:	f8 01       	movw	r30, r16
    6932:	80 81       	ld	r24, Z
    6934:	8e 7f       	andi	r24, 0xFE	; 254
    6936:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    6938:	88 81       	ld	r24, Y
    693a:	80 61       	ori	r24, 0x10	; 16
    693c:	88 83       	st	Y, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    693e:	df 91       	pop	r29
    6940:	cf 91       	pop	r28
    6942:	1f 91       	pop	r17
    6944:	0f 91       	pop	r16
    6946:	08 95       	ret

00006948 <USB_Init>:
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    6948:	e8 ed       	ldi	r30, 0xD8	; 216
    694a:	f0 e0       	ldi	r31, 0x00	; 0
    694c:	80 81       	ld	r24, Z
    694e:	8f 7e       	andi	r24, 0xEF	; 239
    6950:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    6952:	e7 ed       	ldi	r30, 0xD7	; 215
    6954:	f0 e0       	ldi	r31, 0x00	; 0
    6956:	80 81       	ld	r24, Z
    6958:	81 60       	ori	r24, 0x01	; 1
    695a:	80 83       	st	Z, r24
	  USB_REG_Off();

	if (!(USB_Options & USB_OPT_MANUAL_PLL))
	{
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = (1 << PDIV2);
    695c:	84 e0       	ldi	r24, 0x04	; 4
    695e:	82 bf       	out	0x32, r24	; 50
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    6960:	81 e0       	ldi	r24, 0x01	; 1
    6962:	80 93 b3 09 	sts	0x09B3, r24

	USB_ResetInterface();
    6966:	b0 cf       	rjmp	.-160    	; 0x68c8 <USB_ResetInterface>

00006968 <USB_INT_DisableAllInterrupts>:
void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
    6968:	e8 ed       	ldi	r30, 0xD8	; 216
    696a:	f0 e0       	ldi	r31, 0x00	; 0
    696c:	80 81       	ld	r24, Z
    696e:	8e 7f       	andi	r24, 0xFE	; 254
    6970:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    6972:	10 92 e2 00 	sts	0x00E2, r1
    6976:	08 95       	ret

00006978 <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    6978:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    697c:	10 92 e1 00 	sts	0x00E1, r1
    6980:	08 95       	ret

00006982 <__vector_10>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    6982:	1f 92       	push	r1
    6984:	0f 92       	push	r0
    6986:	0f b6       	in	r0, 0x3f	; 63
    6988:	0f 92       	push	r0
    698a:	11 24       	eor	r1, r1
    698c:	2f 93       	push	r18
    698e:	3f 93       	push	r19
    6990:	4f 93       	push	r20
    6992:	5f 93       	push	r21
    6994:	6f 93       	push	r22
    6996:	7f 93       	push	r23
    6998:	8f 93       	push	r24
    699a:	9f 93       	push	r25
    699c:	af 93       	push	r26
    699e:	bf 93       	push	r27
    69a0:	ef 93       	push	r30
    69a2:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    69a4:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    69a8:	82 ff       	sbrs	r24, 2
    69aa:	0b c0       	rjmp	.+22     	; 0x69c2 <__vector_10+0x40>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    69ac:	80 91 e2 00 	lds	r24, 0x00E2
    69b0:	82 ff       	sbrs	r24, 2
    69b2:	07 c0       	rjmp	.+14     	; 0x69c2 <__vector_10+0x40>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    69b4:	80 91 e1 00 	lds	r24, 0x00E1
    69b8:	8b 7f       	andi	r24, 0xFB	; 251
    69ba:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    69be:	0e 94 25 27 	call	0x4e4a	; 0x4e4a <EVENT_USB_Device_StartOfFrame>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    69c2:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    69c6:	80 ff       	sbrs	r24, 0
    69c8:	1d c0       	rjmp	.+58     	; 0x6a04 <__vector_10+0x82>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    69ca:	80 91 d8 00 	lds	r24, 0x00D8
    69ce:	80 ff       	sbrs	r24, 0
    69d0:	19 c0       	rjmp	.+50     	; 0x6a04 <__vector_10+0x82>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    69d2:	80 91 da 00 	lds	r24, 0x00DA
    69d6:	8e 7f       	andi	r24, 0xFE	; 254
    69d8:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    69dc:	80 91 d9 00 	lds	r24, 0x00D9

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    69e0:	19 bc       	out	0x29, r1	; 41
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    69e2:	80 ff       	sbrs	r24, 0
    69e4:	0b c0       	rjmp	.+22     	; 0x69fc <__vector_10+0x7a>
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    69e6:	82 e0       	ldi	r24, 0x02	; 2
    69e8:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    69ea:	09 b4       	in	r0, 0x29	; 41
    69ec:	00 fe       	sbrs	r0, 0
    69ee:	fd cf       	rjmp	.-6      	; 0x69ea <__vector_10+0x68>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    69f0:	81 e0       	ldi	r24, 0x01	; 1
    69f2:	80 93 b4 09 	sts	0x09B4, r24
			EVENT_USB_Device_Connect();
    69f6:	0e 94 07 27 	call	0x4e0e	; 0x4e0e <EVENT_USB_Device_Connect>
    69fa:	04 c0       	rjmp	.+8      	; 0x6a04 <__vector_10+0x82>
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    69fc:	10 92 b4 09 	sts	0x09B4, r1
			EVENT_USB_Device_Disconnect();
    6a00:	0e 94 08 27 	call	0x4e10	; 0x4e10 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    6a04:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    6a08:	80 ff       	sbrs	r24, 0
    6a0a:	19 c0       	rjmp	.+50     	; 0x6a3e <__vector_10+0xbc>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    6a0c:	80 91 e2 00 	lds	r24, 0x00E2
    6a10:	80 ff       	sbrs	r24, 0
    6a12:	15 c0       	rjmp	.+42     	; 0x6a3e <__vector_10+0xbc>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    6a14:	80 91 e2 00 	lds	r24, 0x00E2
    6a18:	8e 7f       	andi	r24, 0xFE	; 254
    6a1a:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    6a1e:	80 91 e2 00 	lds	r24, 0x00E2
    6a22:	80 61       	ori	r24, 0x10	; 16
    6a24:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    6a28:	80 91 d8 00 	lds	r24, 0x00D8
    6a2c:	80 62       	ori	r24, 0x20	; 32
    6a2e:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    6a32:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    6a34:	85 e0       	ldi	r24, 0x05	; 5
    6a36:	80 93 b4 09 	sts	0x09B4, r24
		EVENT_USB_Device_Suspend();
    6a3a:	0e 94 0f 27 	call	0x4e1e	; 0x4e1e <EVENT_USB_Device_Suspend>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    6a3e:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    6a42:	84 ff       	sbrs	r24, 4
    6a44:	2f c0       	rjmp	.+94     	; 0x6aa4 <__vector_10+0x122>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    6a46:	80 91 e2 00 	lds	r24, 0x00E2
    6a4a:	84 ff       	sbrs	r24, 4
    6a4c:	2b c0       	rjmp	.+86     	; 0x6aa4 <__vector_10+0x122>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    6a4e:	19 bc       	out	0x29, r1	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    6a50:	82 e0       	ldi	r24, 0x02	; 2
    6a52:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    6a54:	09 b4       	in	r0, 0x29	; 41
    6a56:	00 fe       	sbrs	r0, 0
    6a58:	fd cf       	rjmp	.-6      	; 0x6a54 <__vector_10+0xd2>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    6a5a:	80 91 d8 00 	lds	r24, 0x00D8
    6a5e:	8f 7d       	andi	r24, 0xDF	; 223
    6a60:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    6a64:	80 91 e1 00 	lds	r24, 0x00E1
    6a68:	8f 7e       	andi	r24, 0xEF	; 239
    6a6a:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    6a6e:	80 91 e2 00 	lds	r24, 0x00E2
    6a72:	8f 7e       	andi	r24, 0xEF	; 239
    6a74:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    6a78:	80 91 e2 00 	lds	r24, 0x00E2
    6a7c:	81 60       	ori	r24, 0x01	; 1
    6a7e:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    6a82:	80 91 b0 09 	lds	r24, 0x09B0
    6a86:	88 23       	and	r24, r24
    6a88:	11 f0       	breq	.+4      	; 0x6a8e <__vector_10+0x10c>
		  USB_DeviceState = DEVICE_STATE_Configured;
    6a8a:	84 e0       	ldi	r24, 0x04	; 4
    6a8c:	07 c0       	rjmp	.+14     	; 0x6a9c <__vector_10+0x11a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    6a8e:	80 91 e3 00 	lds	r24, 0x00E3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    6a92:	87 fd       	sbrc	r24, 7
    6a94:	02 c0       	rjmp	.+4      	; 0x6a9a <__vector_10+0x118>
    6a96:	81 e0       	ldi	r24, 0x01	; 1
    6a98:	01 c0       	rjmp	.+2      	; 0x6a9c <__vector_10+0x11a>
    6a9a:	83 e0       	ldi	r24, 0x03	; 3
    6a9c:	80 93 b4 09 	sts	0x09B4, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    6aa0:	0e 94 10 27 	call	0x4e20	; 0x4e20 <EVENT_USB_Device_WakeUp>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    6aa4:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    6aa8:	83 ff       	sbrs	r24, 3
    6aaa:	22 c0       	rjmp	.+68     	; 0x6af0 <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    6aac:	80 91 e2 00 	lds	r24, 0x00E2
    6ab0:	83 ff       	sbrs	r24, 3
    6ab2:	1e c0       	rjmp	.+60     	; 0x6af0 <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    6ab4:	80 91 e1 00 	lds	r24, 0x00E1
    6ab8:	87 7f       	andi	r24, 0xF7	; 247
    6aba:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    6abe:	82 e0       	ldi	r24, 0x02	; 2
    6ac0:	80 93 b4 09 	sts	0x09B4, r24
		USB_Device_ConfigurationNumber = 0;
    6ac4:	10 92 b0 09 	sts	0x09B0, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    6ac8:	80 91 e1 00 	lds	r24, 0x00E1
    6acc:	8e 7f       	andi	r24, 0xFE	; 254
    6ace:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    6ad2:	80 91 e2 00 	lds	r24, 0x00E2
    6ad6:	8e 7f       	andi	r24, 0xFE	; 254
    6ad8:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    6adc:	80 91 e2 00 	lds	r24, 0x00E2
    6ae0:	80 61       	ori	r24, 0x10	; 16
    6ae2:	80 93 e2 00 	sts	0x00E2, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    6ae6:	42 e0       	ldi	r20, 0x02	; 2
    6ae8:	60 e0       	ldi	r22, 0x00	; 0
    6aea:	80 e0       	ldi	r24, 0x00	; 0
    6aec:	07 de       	rcall	.-1010   	; 0x66fc <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    6aee:	66 d1       	rcall	.+716    	; 0x6dbc <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    6af0:	ff 91       	pop	r31
    6af2:	ef 91       	pop	r30
    6af4:	bf 91       	pop	r27
    6af6:	af 91       	pop	r26
    6af8:	9f 91       	pop	r25
    6afa:	8f 91       	pop	r24
    6afc:	7f 91       	pop	r23
    6afe:	6f 91       	pop	r22
    6b00:	5f 91       	pop	r21
    6b02:	4f 91       	pop	r20
    6b04:	3f 91       	pop	r19
    6b06:	2f 91       	pop	r18
    6b08:	0f 90       	pop	r0
    6b0a:	0f be       	out	0x3f, r0	; 63
    6b0c:	0f 90       	pop	r0
    6b0e:	1f 90       	pop	r1
    6b10:	18 95       	reti

00006b12 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    6b12:	1f 93       	push	r17
    6b14:	cf 93       	push	r28
    6b16:	df 93       	push	r29
    6b18:	cd b7       	in	r28, 0x3d	; 61
    6b1a:	de b7       	in	r29, 0x3e	; 62
    6b1c:	aa 97       	sbiw	r28, 0x2a	; 42
    6b1e:	0f b6       	in	r0, 0x3f	; 63
    6b20:	f8 94       	cli
    6b22:	de bf       	out	0x3e, r29	; 62
    6b24:	0f be       	out	0x3f, r0	; 63
    6b26:	cd bf       	out	0x3d, r28	; 61
    6b28:	e5 eb       	ldi	r30, 0xB5	; 181
    6b2a:	f9 e0       	ldi	r31, 0x09	; 9
    6b2c:	88 e0       	ldi	r24, 0x08	; 8
    6b2e:	8e 0f       	add	r24, r30
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    6b30:	90 91 f1 00 	lds	r25, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    6b34:	91 93       	st	Z+, r25
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    6b36:	8e 13       	cpse	r24, r30
    6b38:	fb cf       	rjmp	.-10     	; 0x6b30 <USB_Device_ProcessControlRequest+0x1e>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    6b3a:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6b3e:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    6b42:	83 ff       	sbrs	r24, 3
    6b44:	23 c1       	rjmp	.+582    	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    6b46:	80 91 b5 09 	lds	r24, 0x09B5

		switch (USB_ControlRequest.bRequest)
    6b4a:	90 91 b6 09 	lds	r25, 0x09B6
    6b4e:	95 30       	cpi	r25, 0x05	; 5
    6b50:	09 f4       	brne	.+2      	; 0x6b54 <USB_Device_ProcessControlRequest+0x42>
    6b52:	78 c0       	rjmp	.+240    	; 0x6c44 <USB_Device_ProcessControlRequest+0x132>
    6b54:	30 f4       	brcc	.+12     	; 0x6b62 <USB_Device_ProcessControlRequest+0x50>
    6b56:	91 30       	cpi	r25, 0x01	; 1
    6b58:	81 f1       	breq	.+96     	; 0x6bba <USB_Device_ProcessControlRequest+0xa8>
    6b5a:	68 f0       	brcs	.+26     	; 0x6b76 <USB_Device_ProcessControlRequest+0x64>
    6b5c:	93 30       	cpi	r25, 0x03	; 3
    6b5e:	69 f1       	breq	.+90     	; 0x6bba <USB_Device_ProcessControlRequest+0xa8>
    6b60:	15 c1       	rjmp	.+554    	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
    6b62:	98 30       	cpi	r25, 0x08	; 8
    6b64:	09 f4       	brne	.+2      	; 0x6b68 <USB_Device_ProcessControlRequest+0x56>
    6b66:	e3 c0       	rjmp	.+454    	; 0x6d2e <USB_Device_ProcessControlRequest+0x21c>
    6b68:	99 30       	cpi	r25, 0x09	; 9
    6b6a:	09 f4       	brne	.+2      	; 0x6b6e <USB_Device_ProcessControlRequest+0x5c>
    6b6c:	f2 c0       	rjmp	.+484    	; 0x6d52 <USB_Device_ProcessControlRequest+0x240>
    6b6e:	96 30       	cpi	r25, 0x06	; 6
    6b70:	09 f0       	breq	.+2      	; 0x6b74 <USB_Device_ProcessControlRequest+0x62>
    6b72:	0c c1       	rjmp	.+536    	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
    6b74:	89 c0       	rjmp	.+274    	; 0x6c88 <USB_Device_ProcessControlRequest+0x176>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    6b76:	80 38       	cpi	r24, 0x80	; 128
    6b78:	81 f0       	breq	.+32     	; 0x6b9a <USB_Device_ProcessControlRequest+0x88>
    6b7a:	82 38       	cpi	r24, 0x82	; 130
    6b7c:	09 f0       	breq	.+2      	; 0x6b80 <USB_Device_ProcessControlRequest+0x6e>
    6b7e:	06 c1       	rjmp	.+524    	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6b80:	80 91 b9 09 	lds	r24, 0x09B9
    6b84:	8f 70       	andi	r24, 0x0F	; 15
    6b86:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    6b8a:	80 91 eb 00 	lds	r24, 0x00EB
    6b8e:	85 fb       	bst	r24, 5
    6b90:	88 27       	eor	r24, r24
    6b92:	80 f9       	bld	r24, 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6b94:	10 92 e9 00 	sts	0x00E9, r1
    6b98:	06 c0       	rjmp	.+12     	; 0x6ba6 <USB_Device_ProcessControlRequest+0x94>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    6b9a:	80 91 b1 09 	lds	r24, 0x09B1
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    6b9e:	90 91 b2 09 	lds	r25, 0x09B2
    6ba2:	91 11       	cpse	r25, r1
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    6ba4:	82 60       	ori	r24, 0x02	; 2
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6ba6:	90 91 e8 00 	lds	r25, 0x00E8
    6baa:	97 7f       	andi	r25, 0xF7	; 247
    6bac:	90 93 e8 00 	sts	0x00E8, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    6bb0:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
    6bb4:	10 92 f1 00 	sts	0x00F1, r1
    6bb8:	c5 c0       	rjmp	.+394    	; 0x6d44 <USB_Device_ProcessControlRequest+0x232>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    6bba:	28 2f       	mov	r18, r24
    6bbc:	2d 7f       	andi	r18, 0xFD	; 253
    6bbe:	09 f0       	breq	.+2      	; 0x6bc2 <USB_Device_ProcessControlRequest+0xb0>
    6bc0:	e5 c0       	rjmp	.+458    	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    6bc2:	88 23       	and	r24, r24
    6bc4:	19 f0       	breq	.+6      	; 0x6bcc <USB_Device_ProcessControlRequest+0xba>
    6bc6:	82 30       	cpi	r24, 0x02	; 2
    6bc8:	61 f0       	breq	.+24     	; 0x6be2 <USB_Device_ProcessControlRequest+0xd0>
    6bca:	e0 c0       	rjmp	.+448    	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    6bcc:	80 91 b7 09 	lds	r24, 0x09B7
    6bd0:	81 30       	cpi	r24, 0x01	; 1
    6bd2:	09 f0       	breq	.+2      	; 0x6bd6 <USB_Device_ProcessControlRequest+0xc4>
    6bd4:	db c0       	rjmp	.+438    	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    6bd6:	93 30       	cpi	r25, 0x03	; 3
    6bd8:	09 f0       	breq	.+2      	; 0x6bdc <USB_Device_ProcessControlRequest+0xca>
    6bda:	80 e0       	ldi	r24, 0x00	; 0
    6bdc:	80 93 b2 09 	sts	0x09B2, r24
    6be0:	2b c0       	rjmp	.+86     	; 0x6c38 <USB_Device_ProcessControlRequest+0x126>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    6be2:	80 91 b7 09 	lds	r24, 0x09B7
    6be6:	81 11       	cpse	r24, r1
    6be8:	27 c0       	rjmp	.+78     	; 0x6c38 <USB_Device_ProcessControlRequest+0x126>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    6bea:	80 91 b9 09 	lds	r24, 0x09B9
    6bee:	8f 70       	andi	r24, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    6bf0:	09 f4       	brne	.+2      	; 0x6bf4 <USB_Device_ProcessControlRequest+0xe2>
    6bf2:	cc c0       	rjmp	.+408    	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6bf4:	80 93 e9 00 	sts	0x00E9, r24
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    6bf8:	20 91 eb 00 	lds	r18, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    6bfc:	20 ff       	sbrs	r18, 0
    6bfe:	1c c0       	rjmp	.+56     	; 0x6c38 <USB_Device_ProcessControlRequest+0x126>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    6c00:	93 30       	cpi	r25, 0x03	; 3
    6c02:	21 f4       	brne	.+8      	; 0x6c0c <USB_Device_ProcessControlRequest+0xfa>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6c04:	80 91 eb 00 	lds	r24, 0x00EB
    6c08:	80 62       	ori	r24, 0x20	; 32
    6c0a:	14 c0       	rjmp	.+40     	; 0x6c34 <USB_Device_ProcessControlRequest+0x122>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6c0c:	90 91 eb 00 	lds	r25, 0x00EB
    6c10:	90 61       	ori	r25, 0x10	; 16
    6c12:	90 93 eb 00 	sts	0x00EB, r25
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    6c16:	21 e0       	ldi	r18, 0x01	; 1
    6c18:	30 e0       	ldi	r19, 0x00	; 0
    6c1a:	a9 01       	movw	r20, r18
    6c1c:	02 c0       	rjmp	.+4      	; 0x6c22 <USB_Device_ProcessControlRequest+0x110>
    6c1e:	44 0f       	add	r20, r20
    6c20:	55 1f       	adc	r21, r21
    6c22:	8a 95       	dec	r24
    6c24:	e2 f7       	brpl	.-8      	; 0x6c1e <USB_Device_ProcessControlRequest+0x10c>
    6c26:	40 93 ea 00 	sts	0x00EA, r20
				UERST = 0;
    6c2a:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    6c2e:	80 91 eb 00 	lds	r24, 0x00EB
    6c32:	88 60       	ori	r24, 0x08	; 8
    6c34:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6c38:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6c3c:	80 91 e8 00 	lds	r24, 0x00E8
    6c40:	87 7f       	andi	r24, 0xF7	; 247
    6c42:	83 c0       	rjmp	.+262    	; 0x6d4a <USB_Device_ProcessControlRequest+0x238>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    6c44:	81 11       	cpse	r24, r1
    6c46:	a2 c0       	rjmp	.+324    	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    6c48:	10 91 b7 09 	lds	r17, 0x09B7
    6c4c:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    6c4e:	80 91 e3 00 	lds	r24, 0x00E3
    6c52:	80 78       	andi	r24, 0x80	; 128
    6c54:	81 2b       	or	r24, r17
    6c56:	80 93 e3 00 	sts	0x00E3, r24
    6c5a:	80 91 e8 00 	lds	r24, 0x00E8
    6c5e:	87 7f       	andi	r24, 0xF7	; 247
    6c60:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    6c64:	c8 dd       	rcall	.-1136   	; 0x67f6 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6c66:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    6c6a:	80 ff       	sbrs	r24, 0
    6c6c:	fc cf       	rjmp	.-8      	; 0x6c66 <USB_Device_ProcessControlRequest+0x154>
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;

				UDADDR |= (1 << ADDEN);
    6c6e:	80 91 e3 00 	lds	r24, 0x00E3
    6c72:	80 68       	ori	r24, 0x80	; 128
    6c74:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    6c78:	11 11       	cpse	r17, r1
    6c7a:	02 c0       	rjmp	.+4      	; 0x6c80 <USB_Device_ProcessControlRequest+0x16e>
    6c7c:	82 e0       	ldi	r24, 0x02	; 2
    6c7e:	01 c0       	rjmp	.+2      	; 0x6c82 <USB_Device_ProcessControlRequest+0x170>
    6c80:	83 e0       	ldi	r24, 0x03	; 3
    6c82:	80 93 b4 09 	sts	0x09B4, r24
    6c86:	82 c0       	rjmp	.+260    	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    6c88:	80 58       	subi	r24, 0x80	; 128
    6c8a:	82 30       	cpi	r24, 0x02	; 2
    6c8c:	08 f0       	brcs	.+2      	; 0x6c90 <USB_Device_ProcessControlRequest+0x17e>
    6c8e:	7e c0       	rjmp	.+252    	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    6c90:	80 91 b7 09 	lds	r24, 0x09B7
    6c94:	90 91 b8 09 	lds	r25, 0x09B8
    6c98:	8c 3d       	cpi	r24, 0xDC	; 220
    6c9a:	53 e0       	ldi	r21, 0x03	; 3
    6c9c:	95 07       	cpc	r25, r21
    6c9e:	71 f5       	brne	.+92     	; 0x6cfc <USB_Device_ProcessControlRequest+0x1ea>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    6ca0:	83 e0       	ldi	r24, 0x03	; 3
    6ca2:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    6ca4:	8a e2       	ldi	r24, 0x2A	; 42
    6ca6:	89 83       	std	Y+1, r24	; 0x01
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    6ca8:	4f b7       	in	r20, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    6caa:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    6cac:	de 01       	movw	r26, r28
    6cae:	13 96       	adiw	r26, 0x03	; 3
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    6cb0:	20 e0       	ldi	r18, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    6cb2:	3e e0       	ldi	r19, 0x0E	; 14

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    6cb4:	51 e2       	ldi	r21, 0x21	; 33
    6cb6:	e3 2f       	mov	r30, r19
    6cb8:	f0 e0       	ldi	r31, 0x00	; 0
    6cba:	50 93 57 00 	sts	0x0057, r21
    6cbe:	e4 91       	lpm	r30, Z

					if (SerialCharNum & 0x01)
    6cc0:	20 ff       	sbrs	r18, 0
    6cc2:	03 c0       	rjmp	.+6      	; 0x6cca <USB_Device_ProcessControlRequest+0x1b8>
					{
						SerialByte >>= 4;
    6cc4:	e2 95       	swap	r30
    6cc6:	ef 70       	andi	r30, 0x0F	; 15
						SigReadAddress++;
    6cc8:	3f 5f       	subi	r19, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    6cca:	ef 70       	andi	r30, 0x0F	; 15
    6ccc:	8e 2f       	mov	r24, r30
    6cce:	90 e0       	ldi	r25, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    6cd0:	ea 30       	cpi	r30, 0x0A	; 10
    6cd2:	10 f0       	brcs	.+4      	; 0x6cd8 <USB_Device_ProcessControlRequest+0x1c6>
    6cd4:	c7 96       	adiw	r24, 0x37	; 55
    6cd6:	01 c0       	rjmp	.+2      	; 0x6cda <USB_Device_ProcessControlRequest+0x1c8>
    6cd8:	c0 96       	adiw	r24, 0x30	; 48
    6cda:	8d 93       	st	X+, r24
    6cdc:	9d 93       	st	X+, r25
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    6cde:	2f 5f       	subi	r18, 0xFF	; 255
    6ce0:	24 31       	cpi	r18, 0x14	; 20
    6ce2:	49 f7       	brne	.-46     	; 0x6cb6 <USB_Device_ProcessControlRequest+0x1a4>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    6ce4:	4f bf       	out	0x3f, r20	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6ce6:	80 91 e8 00 	lds	r24, 0x00E8
    6cea:	87 7f       	andi	r24, 0xF7	; 247
    6cec:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    6cf0:	6a e2       	ldi	r22, 0x2A	; 42
    6cf2:	70 e0       	ldi	r23, 0x00	; 0
    6cf4:	ce 01       	movw	r24, r28
    6cf6:	01 96       	adiw	r24, 0x01	; 1
    6cf8:	fd db       	rcall	.-2054   	; 0x64f4 <Endpoint_Write_Control_Stream_LE>
    6cfa:	13 c0       	rjmp	.+38     	; 0x6d22 <USB_Device_ProcessControlRequest+0x210>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    6cfc:	ae 01       	movw	r20, r28
    6cfe:	4f 5f       	subi	r20, 0xFF	; 255
    6d00:	5f 4f       	sbci	r21, 0xFF	; 255
    6d02:	60 91 b9 09 	lds	r22, 0x09B9
    6d06:	0e 94 26 0d 	call	0x1a4c	; 0x1a4c <CALLBACK_USB_GetDescriptor>
    6d0a:	bc 01       	movw	r22, r24
    6d0c:	89 2b       	or	r24, r25
    6d0e:	09 f4       	brne	.+2      	; 0x6d12 <USB_Device_ProcessControlRequest+0x200>
    6d10:	3d c0       	rjmp	.+122    	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
    6d12:	90 91 e8 00 	lds	r25, 0x00E8
    6d16:	97 7f       	andi	r25, 0xF7	; 247
    6d18:	90 93 e8 00 	sts	0x00E8, r25
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    6d1c:	89 81       	ldd	r24, Y+1	; 0x01
    6d1e:	9a 81       	ldd	r25, Y+2	; 0x02
    6d20:	8c dc       	rcall	.-1768   	; 0x663a <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6d22:	80 91 e8 00 	lds	r24, 0x00E8
    6d26:	8b 77       	andi	r24, 0x7B	; 123
    6d28:	80 93 e8 00 	sts	0x00E8, r24
    6d2c:	2f c0       	rjmp	.+94     	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    6d2e:	80 38       	cpi	r24, 0x80	; 128
    6d30:	69 f5       	brne	.+90     	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6d32:	80 91 e8 00 	lds	r24, 0x00E8
    6d36:	87 7f       	andi	r24, 0xF7	; 247
    6d38:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    6d3c:	80 91 b0 09 	lds	r24, 0x09B0
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    6d40:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6d44:	80 91 e8 00 	lds	r24, 0x00E8
    6d48:	8e 77       	andi	r24, 0x7E	; 126
    6d4a:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    6d4e:	53 dd       	rcall	.-1370   	; 0x67f6 <Endpoint_ClearStatusStage>
    6d50:	1d c0       	rjmp	.+58     	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    6d52:	81 11       	cpse	r24, r1
    6d54:	1b c0       	rjmp	.+54     	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    6d56:	90 91 b7 09 	lds	r25, 0x09B7
    6d5a:	92 30       	cpi	r25, 0x02	; 2
    6d5c:	b8 f4       	brcc	.+46     	; 0x6d8c <USB_Device_ProcessControlRequest+0x27a>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6d5e:	80 91 e8 00 	lds	r24, 0x00E8
    6d62:	87 7f       	andi	r24, 0xF7	; 247
    6d64:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    6d68:	90 93 b0 09 	sts	0x09B0, r25

	Endpoint_ClearStatusStage();
    6d6c:	44 dd       	rcall	.-1400   	; 0x67f6 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    6d6e:	80 91 b0 09 	lds	r24, 0x09B0
    6d72:	81 11       	cpse	r24, r1
    6d74:	06 c0       	rjmp	.+12     	; 0x6d82 <USB_Device_ProcessControlRequest+0x270>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    6d76:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    6d7a:	87 fd       	sbrc	r24, 7
    6d7c:	02 c0       	rjmp	.+4      	; 0x6d82 <USB_Device_ProcessControlRequest+0x270>
    6d7e:	81 e0       	ldi	r24, 0x01	; 1
    6d80:	01 c0       	rjmp	.+2      	; 0x6d84 <USB_Device_ProcessControlRequest+0x272>
    6d82:	84 e0       	ldi	r24, 0x04	; 4
    6d84:	80 93 b4 09 	sts	0x09B4, r24

	EVENT_USB_Device_ConfigurationChanged();
    6d88:	0e 94 11 27 	call	0x4e22	; 0x4e22 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6d8c:	80 91 e8 00 	lds	r24, 0x00E8
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    6d90:	83 ff       	sbrs	r24, 3
    6d92:	0a c0       	rjmp	.+20     	; 0x6da8 <USB_Device_ProcessControlRequest+0x296>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6d94:	80 91 e8 00 	lds	r24, 0x00E8
    6d98:	87 7f       	andi	r24, 0xF7	; 247
    6d9a:	80 93 e8 00 	sts	0x00E8, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6d9e:	80 91 eb 00 	lds	r24, 0x00EB
    6da2:	80 62       	ori	r24, 0x20	; 32
    6da4:	80 93 eb 00 	sts	0x00EB, r24
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    6da8:	aa 96       	adiw	r28, 0x2a	; 42
    6daa:	0f b6       	in	r0, 0x3f	; 63
    6dac:	f8 94       	cli
    6dae:	de bf       	out	0x3e, r29	; 62
    6db0:	0f be       	out	0x3f, r0	; 63
    6db2:	cd bf       	out	0x3d, r28	; 61
    6db4:	df 91       	pop	r29
    6db6:	cf 91       	pop	r28
    6db8:	1f 91       	pop	r17
    6dba:	08 95       	ret

00006dbc <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    6dbc:	08 95       	ret

00006dbe <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    6dbe:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    6dc0:	80 91 b4 09 	lds	r24, 0x09B4
    6dc4:	88 23       	and	r24, r24
    6dc6:	99 f0       	breq	.+38     	; 0x6dee <USB_USBTask+0x30>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    6dc8:	c0 91 e9 00 	lds	r28, 0x00E9
    6dcc:	cf 70       	andi	r28, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    6dce:	90 91 ec 00 	lds	r25, 0x00EC
    6dd2:	89 2f       	mov	r24, r25
    6dd4:	81 70       	andi	r24, 0x01	; 1
    6dd6:	90 fd       	sbrc	r25, 0
    6dd8:	80 e8       	ldi	r24, 0x80	; 128
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    6dda:	c8 2b       	or	r28, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6ddc:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6de0:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    6de4:	83 fd       	sbrc	r24, 3
	  USB_Device_ProcessControlRequest();
    6de6:	95 de       	rcall	.-726    	; 0x6b12 <USB_Device_ProcessControlRequest>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6de8:	cf 70       	andi	r28, 0x0F	; 15
    6dea:	c0 93 e9 00 	sts	0x00E9, r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    6dee:	cf 91       	pop	r28
    6df0:	08 95       	ret

00006df2 <__udivmodqi4>:
    6df2:	99 1b       	sub	r25, r25
    6df4:	79 e0       	ldi	r23, 0x09	; 9
    6df6:	04 c0       	rjmp	.+8      	; 0x6e00 <__udivmodqi4_ep>

00006df8 <__udivmodqi4_loop>:
    6df8:	99 1f       	adc	r25, r25
    6dfa:	96 17       	cp	r25, r22
    6dfc:	08 f0       	brcs	.+2      	; 0x6e00 <__udivmodqi4_ep>
    6dfe:	96 1b       	sub	r25, r22

00006e00 <__udivmodqi4_ep>:
    6e00:	88 1f       	adc	r24, r24
    6e02:	7a 95       	dec	r23
    6e04:	c9 f7       	brne	.-14     	; 0x6df8 <__udivmodqi4_loop>
    6e06:	80 95       	com	r24
    6e08:	08 95       	ret

00006e0a <__divmodhi4>:
    6e0a:	97 fb       	bst	r25, 7
    6e0c:	07 2e       	mov	r0, r23
    6e0e:	16 f4       	brtc	.+4      	; 0x6e14 <__divmodhi4+0xa>
    6e10:	00 94       	com	r0
    6e12:	06 d0       	rcall	.+12     	; 0x6e20 <__divmodhi4_neg1>
    6e14:	77 fd       	sbrc	r23, 7
    6e16:	08 d0       	rcall	.+16     	; 0x6e28 <__divmodhi4_neg2>
    6e18:	82 d0       	rcall	.+260    	; 0x6f1e <__udivmodhi4>
    6e1a:	07 fc       	sbrc	r0, 7
    6e1c:	05 d0       	rcall	.+10     	; 0x6e28 <__divmodhi4_neg2>
    6e1e:	3e f4       	brtc	.+14     	; 0x6e2e <__divmodhi4_exit>

00006e20 <__divmodhi4_neg1>:
    6e20:	90 95       	com	r25
    6e22:	81 95       	neg	r24
    6e24:	9f 4f       	sbci	r25, 0xFF	; 255
    6e26:	08 95       	ret

00006e28 <__divmodhi4_neg2>:
    6e28:	70 95       	com	r23
    6e2a:	61 95       	neg	r22
    6e2c:	7f 4f       	sbci	r23, 0xFF	; 255

00006e2e <__divmodhi4_exit>:
    6e2e:	08 95       	ret

00006e30 <__udivmodsi4>:
    6e30:	a1 e2       	ldi	r26, 0x21	; 33
    6e32:	1a 2e       	mov	r1, r26
    6e34:	aa 1b       	sub	r26, r26
    6e36:	bb 1b       	sub	r27, r27
    6e38:	fd 01       	movw	r30, r26
    6e3a:	0d c0       	rjmp	.+26     	; 0x6e56 <__udivmodsi4_ep>

00006e3c <__udivmodsi4_loop>:
    6e3c:	aa 1f       	adc	r26, r26
    6e3e:	bb 1f       	adc	r27, r27
    6e40:	ee 1f       	adc	r30, r30
    6e42:	ff 1f       	adc	r31, r31
    6e44:	a2 17       	cp	r26, r18
    6e46:	b3 07       	cpc	r27, r19
    6e48:	e4 07       	cpc	r30, r20
    6e4a:	f5 07       	cpc	r31, r21
    6e4c:	20 f0       	brcs	.+8      	; 0x6e56 <__udivmodsi4_ep>
    6e4e:	a2 1b       	sub	r26, r18
    6e50:	b3 0b       	sbc	r27, r19
    6e52:	e4 0b       	sbc	r30, r20
    6e54:	f5 0b       	sbc	r31, r21

00006e56 <__udivmodsi4_ep>:
    6e56:	66 1f       	adc	r22, r22
    6e58:	77 1f       	adc	r23, r23
    6e5a:	88 1f       	adc	r24, r24
    6e5c:	99 1f       	adc	r25, r25
    6e5e:	1a 94       	dec	r1
    6e60:	69 f7       	brne	.-38     	; 0x6e3c <__udivmodsi4_loop>
    6e62:	60 95       	com	r22
    6e64:	70 95       	com	r23
    6e66:	80 95       	com	r24
    6e68:	90 95       	com	r25
    6e6a:	9b 01       	movw	r18, r22
    6e6c:	ac 01       	movw	r20, r24
    6e6e:	bd 01       	movw	r22, r26
    6e70:	cf 01       	movw	r24, r30
    6e72:	08 95       	ret

00006e74 <__muluhisi3>:
    6e74:	81 d0       	rcall	.+258    	; 0x6f78 <__umulhisi3>
    6e76:	a5 9f       	mul	r26, r21
    6e78:	90 0d       	add	r25, r0
    6e7a:	b4 9f       	mul	r27, r20
    6e7c:	90 0d       	add	r25, r0
    6e7e:	a4 9f       	mul	r26, r20
    6e80:	80 0d       	add	r24, r0
    6e82:	91 1d       	adc	r25, r1
    6e84:	11 24       	eor	r1, r1
    6e86:	08 95       	ret

00006e88 <__clzdi2>:
    6e88:	5e d0       	rcall	.+188    	; 0x6f46 <__clzsi2>
    6e8a:	85 ff       	sbrs	r24, 5
    6e8c:	08 95       	ret
    6e8e:	b9 01       	movw	r22, r18
    6e90:	ca 01       	movw	r24, r20
    6e92:	59 d0       	rcall	.+178    	; 0x6f46 <__clzsi2>
    6e94:	80 5e       	subi	r24, 0xE0	; 224
    6e96:	08 95       	ret

00006e98 <__ashldi3>:
    6e98:	0f 93       	push	r16
    6e9a:	08 30       	cpi	r16, 0x08	; 8
    6e9c:	90 f0       	brcs	.+36     	; 0x6ec2 <__ashldi3+0x2a>
    6e9e:	98 2f       	mov	r25, r24
    6ea0:	87 2f       	mov	r24, r23
    6ea2:	76 2f       	mov	r23, r22
    6ea4:	65 2f       	mov	r22, r21
    6ea6:	54 2f       	mov	r21, r20
    6ea8:	43 2f       	mov	r20, r19
    6eaa:	32 2f       	mov	r19, r18
    6eac:	22 27       	eor	r18, r18
    6eae:	08 50       	subi	r16, 0x08	; 8
    6eb0:	f4 cf       	rjmp	.-24     	; 0x6e9a <__ashldi3+0x2>
    6eb2:	22 0f       	add	r18, r18
    6eb4:	33 1f       	adc	r19, r19
    6eb6:	44 1f       	adc	r20, r20
    6eb8:	55 1f       	adc	r21, r21
    6eba:	66 1f       	adc	r22, r22
    6ebc:	77 1f       	adc	r23, r23
    6ebe:	88 1f       	adc	r24, r24
    6ec0:	99 1f       	adc	r25, r25
    6ec2:	0a 95       	dec	r16
    6ec4:	b2 f7       	brpl	.-20     	; 0x6eb2 <__ashldi3+0x1a>
    6ec6:	0f 91       	pop	r16
    6ec8:	08 95       	ret

00006eca <__ashrdi3>:
    6eca:	97 fb       	bst	r25, 7
    6ecc:	10 f8       	bld	r1, 0

00006ece <__lshrdi3>:
    6ece:	16 94       	lsr	r1
    6ed0:	00 08       	sbc	r0, r0
    6ed2:	0f 93       	push	r16
    6ed4:	08 30       	cpi	r16, 0x08	; 8
    6ed6:	98 f0       	brcs	.+38     	; 0x6efe <__lshrdi3+0x30>
    6ed8:	08 50       	subi	r16, 0x08	; 8
    6eda:	23 2f       	mov	r18, r19
    6edc:	34 2f       	mov	r19, r20
    6ede:	45 2f       	mov	r20, r21
    6ee0:	56 2f       	mov	r21, r22
    6ee2:	67 2f       	mov	r22, r23
    6ee4:	78 2f       	mov	r23, r24
    6ee6:	89 2f       	mov	r24, r25
    6ee8:	90 2d       	mov	r25, r0
    6eea:	f4 cf       	rjmp	.-24     	; 0x6ed4 <__lshrdi3+0x6>
    6eec:	05 94       	asr	r0
    6eee:	97 95       	ror	r25
    6ef0:	87 95       	ror	r24
    6ef2:	77 95       	ror	r23
    6ef4:	67 95       	ror	r22
    6ef6:	57 95       	ror	r21
    6ef8:	47 95       	ror	r20
    6efa:	37 95       	ror	r19
    6efc:	27 95       	ror	r18
    6efe:	0a 95       	dec	r16
    6f00:	aa f7       	brpl	.-22     	; 0x6eec <__lshrdi3+0x1e>
    6f02:	0f 91       	pop	r16
    6f04:	08 95       	ret

00006f06 <__cmpdi2_s8>:
    6f06:	00 24       	eor	r0, r0
    6f08:	a7 fd       	sbrc	r26, 7
    6f0a:	00 94       	com	r0
    6f0c:	2a 17       	cp	r18, r26
    6f0e:	30 05       	cpc	r19, r0
    6f10:	40 05       	cpc	r20, r0
    6f12:	50 05       	cpc	r21, r0
    6f14:	60 05       	cpc	r22, r0
    6f16:	70 05       	cpc	r23, r0
    6f18:	80 05       	cpc	r24, r0
    6f1a:	90 05       	cpc	r25, r0
    6f1c:	08 95       	ret

00006f1e <__udivmodhi4>:
    6f1e:	aa 1b       	sub	r26, r26
    6f20:	bb 1b       	sub	r27, r27
    6f22:	51 e1       	ldi	r21, 0x11	; 17
    6f24:	07 c0       	rjmp	.+14     	; 0x6f34 <__udivmodhi4_ep>

00006f26 <__udivmodhi4_loop>:
    6f26:	aa 1f       	adc	r26, r26
    6f28:	bb 1f       	adc	r27, r27
    6f2a:	a6 17       	cp	r26, r22
    6f2c:	b7 07       	cpc	r27, r23
    6f2e:	10 f0       	brcs	.+4      	; 0x6f34 <__udivmodhi4_ep>
    6f30:	a6 1b       	sub	r26, r22
    6f32:	b7 0b       	sbc	r27, r23

00006f34 <__udivmodhi4_ep>:
    6f34:	88 1f       	adc	r24, r24
    6f36:	99 1f       	adc	r25, r25
    6f38:	5a 95       	dec	r21
    6f3a:	a9 f7       	brne	.-22     	; 0x6f26 <__udivmodhi4_loop>
    6f3c:	80 95       	com	r24
    6f3e:	90 95       	com	r25
    6f40:	bc 01       	movw	r22, r24
    6f42:	cd 01       	movw	r24, r26
    6f44:	08 95       	ret

00006f46 <__clzsi2>:
    6f46:	06 d0       	rcall	.+12     	; 0x6f54 <__clzhi2>
    6f48:	84 ff       	sbrs	r24, 4
    6f4a:	08 95       	ret
    6f4c:	cb 01       	movw	r24, r22
    6f4e:	02 d0       	rcall	.+4      	; 0x6f54 <__clzhi2>
    6f50:	80 5f       	subi	r24, 0xF0	; 240
    6f52:	08 95       	ret

00006f54 <__clzhi2>:
    6f54:	aa 27       	eor	r26, r26
    6f56:	99 23       	and	r25, r25
    6f58:	29 f4       	brne	.+10     	; 0x6f64 <__clzhi2+0x10>
    6f5a:	a8 5f       	subi	r26, 0xF8	; 248
    6f5c:	98 2b       	or	r25, r24
    6f5e:	11 f4       	brne	.+4      	; 0x6f64 <__clzhi2+0x10>
    6f60:	80 e1       	ldi	r24, 0x10	; 16
    6f62:	08 95       	ret
    6f64:	90 31       	cpi	r25, 0x10	; 16
    6f66:	18 f4       	brcc	.+6      	; 0x6f6e <__clzhi2+0x1a>
    6f68:	ad 5f       	subi	r26, 0xFD	; 253
    6f6a:	92 95       	swap	r25
    6f6c:	a3 95       	inc	r26
    6f6e:	99 0f       	add	r25, r25
    6f70:	e8 f7       	brcc	.-6      	; 0x6f6c <__clzhi2+0x18>
    6f72:	8a 2f       	mov	r24, r26
    6f74:	99 27       	eor	r25, r25
    6f76:	08 95       	ret

00006f78 <__umulhisi3>:
    6f78:	a2 9f       	mul	r26, r18
    6f7a:	b0 01       	movw	r22, r0
    6f7c:	b3 9f       	mul	r27, r19
    6f7e:	c0 01       	movw	r24, r0
    6f80:	a3 9f       	mul	r26, r19
    6f82:	70 0d       	add	r23, r0
    6f84:	81 1d       	adc	r24, r1
    6f86:	11 24       	eor	r1, r1
    6f88:	91 1d       	adc	r25, r1
    6f8a:	b2 9f       	mul	r27, r18
    6f8c:	70 0d       	add	r23, r0
    6f8e:	81 1d       	adc	r24, r1
    6f90:	11 24       	eor	r1, r1
    6f92:	91 1d       	adc	r25, r1
    6f94:	08 95       	ret

00006f96 <toupper>:
    6f96:	91 11       	cpse	r25, r1
    6f98:	08 95       	ret
    6f9a:	81 56       	subi	r24, 0x61	; 97
    6f9c:	8a 51       	subi	r24, 0x1A	; 26
    6f9e:	08 f4       	brcc	.+2      	; 0x6fa2 <toupper+0xc>
    6fa0:	80 52       	subi	r24, 0x20	; 32
    6fa2:	85 58       	subi	r24, 0x85	; 133
    6fa4:	08 95       	ret

00006fa6 <strcpy_P>:
    6fa6:	fb 01       	movw	r30, r22
    6fa8:	dc 01       	movw	r26, r24
    6faa:	05 90       	lpm	r0, Z+
    6fac:	0d 92       	st	X+, r0
    6fae:	00 20       	and	r0, r0
    6fb0:	e1 f7       	brne	.-8      	; 0x6faa <strcpy_P+0x4>
    6fb2:	08 95       	ret

00006fb4 <strtok>:
    6fb4:	42 e0       	ldi	r20, 0x02	; 2
    6fb6:	53 e0       	ldi	r21, 0x03	; 3
    6fb8:	24 c0       	rjmp	.+72     	; 0x7002 <strtok_r>

00006fba <memcmp>:
    6fba:	fb 01       	movw	r30, r22
    6fbc:	dc 01       	movw	r26, r24
    6fbe:	04 c0       	rjmp	.+8      	; 0x6fc8 <memcmp+0xe>
    6fc0:	8d 91       	ld	r24, X+
    6fc2:	01 90       	ld	r0, Z+
    6fc4:	80 19       	sub	r24, r0
    6fc6:	21 f4       	brne	.+8      	; 0x6fd0 <memcmp+0x16>
    6fc8:	41 50       	subi	r20, 0x01	; 1
    6fca:	50 40       	sbci	r21, 0x00	; 0
    6fcc:	c8 f7       	brcc	.-14     	; 0x6fc0 <memcmp+0x6>
    6fce:	88 1b       	sub	r24, r24
    6fd0:	99 0b       	sbc	r25, r25
    6fd2:	08 95       	ret

00006fd4 <memcpy>:
    6fd4:	fb 01       	movw	r30, r22
    6fd6:	dc 01       	movw	r26, r24
    6fd8:	02 c0       	rjmp	.+4      	; 0x6fde <memcpy+0xa>
    6fda:	01 90       	ld	r0, Z+
    6fdc:	0d 92       	st	X+, r0
    6fde:	41 50       	subi	r20, 0x01	; 1
    6fe0:	50 40       	sbci	r21, 0x00	; 0
    6fe2:	d8 f7       	brcc	.-10     	; 0x6fda <memcpy+0x6>
    6fe4:	08 95       	ret

00006fe6 <memset>:
    6fe6:	dc 01       	movw	r26, r24
    6fe8:	01 c0       	rjmp	.+2      	; 0x6fec <memset+0x6>
    6fea:	6d 93       	st	X+, r22
    6fec:	41 50       	subi	r20, 0x01	; 1
    6fee:	50 40       	sbci	r21, 0x00	; 0
    6ff0:	e0 f7       	brcc	.-8      	; 0x6fea <memset+0x4>
    6ff2:	08 95       	ret

00006ff4 <strcpy>:
    6ff4:	fb 01       	movw	r30, r22
    6ff6:	dc 01       	movw	r26, r24
    6ff8:	01 90       	ld	r0, Z+
    6ffa:	0d 92       	st	X+, r0
    6ffc:	00 20       	and	r0, r0
    6ffe:	e1 f7       	brne	.-8      	; 0x6ff8 <strcpy+0x4>
    7000:	08 95       	ret

00007002 <strtok_r>:
    7002:	fa 01       	movw	r30, r20
    7004:	a1 91       	ld	r26, Z+
    7006:	b0 81       	ld	r27, Z
    7008:	00 97       	sbiw	r24, 0x00	; 0
    700a:	19 f4       	brne	.+6      	; 0x7012 <strtok_r+0x10>
    700c:	10 97       	sbiw	r26, 0x00	; 0
    700e:	e1 f0       	breq	.+56     	; 0x7048 <strtok_r+0x46>
    7010:	cd 01       	movw	r24, r26
    7012:	dc 01       	movw	r26, r24
    7014:	cd 01       	movw	r24, r26
    7016:	0d 90       	ld	r0, X+
    7018:	00 20       	and	r0, r0
    701a:	11 f4       	brne	.+4      	; 0x7020 <strtok_r+0x1e>
    701c:	c0 01       	movw	r24, r0
    701e:	13 c0       	rjmp	.+38     	; 0x7046 <strtok_r+0x44>
    7020:	fb 01       	movw	r30, r22
    7022:	21 91       	ld	r18, Z+
    7024:	22 23       	and	r18, r18
    7026:	19 f0       	breq	.+6      	; 0x702e <strtok_r+0x2c>
    7028:	20 15       	cp	r18, r0
    702a:	d9 f7       	brne	.-10     	; 0x7022 <strtok_r+0x20>
    702c:	f3 cf       	rjmp	.-26     	; 0x7014 <strtok_r+0x12>
    702e:	fb 01       	movw	r30, r22
    7030:	21 91       	ld	r18, Z+
    7032:	20 15       	cp	r18, r0
    7034:	19 f4       	brne	.+6      	; 0x703c <strtok_r+0x3a>
    7036:	1e 92       	st	-X, r1
    7038:	11 96       	adiw	r26, 0x01	; 1
    703a:	06 c0       	rjmp	.+12     	; 0x7048 <strtok_r+0x46>
    703c:	22 23       	and	r18, r18
    703e:	c1 f7       	brne	.-16     	; 0x7030 <strtok_r+0x2e>
    7040:	0d 90       	ld	r0, X+
    7042:	00 20       	and	r0, r0
    7044:	a1 f7       	brne	.-24     	; 0x702e <strtok_r+0x2c>
    7046:	d0 01       	movw	r26, r0
    7048:	fa 01       	movw	r30, r20
    704a:	a1 93       	st	Z+, r26
    704c:	b0 83       	st	Z, r27
    704e:	08 95       	ret

00007050 <sprintf>:
    7050:	ae e0       	ldi	r26, 0x0E	; 14
    7052:	b0 e0       	ldi	r27, 0x00	; 0
    7054:	ed e2       	ldi	r30, 0x2D	; 45
    7056:	f8 e3       	ldi	r31, 0x38	; 56
    7058:	e1 c2       	rjmp	.+1474   	; 0x761c <__prologue_saves__+0x1c>
    705a:	0d 89       	ldd	r16, Y+21	; 0x15
    705c:	1e 89       	ldd	r17, Y+22	; 0x16
    705e:	86 e0       	ldi	r24, 0x06	; 6
    7060:	8c 83       	std	Y+4, r24	; 0x04
    7062:	1a 83       	std	Y+2, r17	; 0x02
    7064:	09 83       	std	Y+1, r16	; 0x01
    7066:	8f ef       	ldi	r24, 0xFF	; 255
    7068:	9f e7       	ldi	r25, 0x7F	; 127
    706a:	9e 83       	std	Y+6, r25	; 0x06
    706c:	8d 83       	std	Y+5, r24	; 0x05
    706e:	ae 01       	movw	r20, r28
    7070:	47 5e       	subi	r20, 0xE7	; 231
    7072:	5f 4f       	sbci	r21, 0xFF	; 255
    7074:	6f 89       	ldd	r22, Y+23	; 0x17
    7076:	78 8d       	ldd	r23, Y+24	; 0x18
    7078:	ce 01       	movw	r24, r28
    707a:	01 96       	adiw	r24, 0x01	; 1
    707c:	09 d0       	rcall	.+18     	; 0x7090 <vfprintf>
    707e:	2f 81       	ldd	r18, Y+7	; 0x07
    7080:	38 85       	ldd	r19, Y+8	; 0x08
    7082:	f8 01       	movw	r30, r16
    7084:	e2 0f       	add	r30, r18
    7086:	f3 1f       	adc	r31, r19
    7088:	10 82       	st	Z, r1
    708a:	2e 96       	adiw	r28, 0x0e	; 14
    708c:	e4 e0       	ldi	r30, 0x04	; 4
    708e:	e2 c2       	rjmp	.+1476   	; 0x7654 <__epilogue_restores__+0x1c>

00007090 <vfprintf>:
    7090:	ac e0       	ldi	r26, 0x0C	; 12
    7092:	b0 e0       	ldi	r27, 0x00	; 0
    7094:	ed e4       	ldi	r30, 0x4D	; 77
    7096:	f8 e3       	ldi	r31, 0x38	; 56
    7098:	b3 c2       	rjmp	.+1382   	; 0x7600 <__prologue_saves__>
    709a:	7c 01       	movw	r14, r24
    709c:	6b 01       	movw	r12, r22
    709e:	8a 01       	movw	r16, r20
    70a0:	fc 01       	movw	r30, r24
    70a2:	17 82       	std	Z+7, r1	; 0x07
    70a4:	16 82       	std	Z+6, r1	; 0x06
    70a6:	83 81       	ldd	r24, Z+3	; 0x03
    70a8:	81 ff       	sbrs	r24, 1
    70aa:	b0 c1       	rjmp	.+864    	; 0x740c <vfprintf+0x37c>
    70ac:	ce 01       	movw	r24, r28
    70ae:	01 96       	adiw	r24, 0x01	; 1
    70b0:	4c 01       	movw	r8, r24
    70b2:	f7 01       	movw	r30, r14
    70b4:	93 81       	ldd	r25, Z+3	; 0x03
    70b6:	f6 01       	movw	r30, r12
    70b8:	93 fd       	sbrc	r25, 3
    70ba:	85 91       	lpm	r24, Z+
    70bc:	93 ff       	sbrs	r25, 3
    70be:	81 91       	ld	r24, Z+
    70c0:	6f 01       	movw	r12, r30
    70c2:	88 23       	and	r24, r24
    70c4:	09 f4       	brne	.+2      	; 0x70c8 <vfprintf+0x38>
    70c6:	9e c1       	rjmp	.+828    	; 0x7404 <vfprintf+0x374>
    70c8:	85 32       	cpi	r24, 0x25	; 37
    70ca:	39 f4       	brne	.+14     	; 0x70da <vfprintf+0x4a>
    70cc:	93 fd       	sbrc	r25, 3
    70ce:	85 91       	lpm	r24, Z+
    70d0:	93 ff       	sbrs	r25, 3
    70d2:	81 91       	ld	r24, Z+
    70d4:	6f 01       	movw	r12, r30
    70d6:	85 32       	cpi	r24, 0x25	; 37
    70d8:	21 f4       	brne	.+8      	; 0x70e2 <vfprintf+0x52>
    70da:	b7 01       	movw	r22, r14
    70dc:	90 e0       	ldi	r25, 0x00	; 0
    70de:	b1 d1       	rcall	.+866    	; 0x7442 <fputc>
    70e0:	e8 cf       	rjmp	.-48     	; 0x70b2 <vfprintf+0x22>
    70e2:	51 2c       	mov	r5, r1
    70e4:	31 2c       	mov	r3, r1
    70e6:	20 e0       	ldi	r18, 0x00	; 0
    70e8:	20 32       	cpi	r18, 0x20	; 32
    70ea:	a0 f4       	brcc	.+40     	; 0x7114 <vfprintf+0x84>
    70ec:	8b 32       	cpi	r24, 0x2B	; 43
    70ee:	69 f0       	breq	.+26     	; 0x710a <vfprintf+0x7a>
    70f0:	30 f4       	brcc	.+12     	; 0x70fe <vfprintf+0x6e>
    70f2:	80 32       	cpi	r24, 0x20	; 32
    70f4:	59 f0       	breq	.+22     	; 0x710c <vfprintf+0x7c>
    70f6:	83 32       	cpi	r24, 0x23	; 35
    70f8:	69 f4       	brne	.+26     	; 0x7114 <vfprintf+0x84>
    70fa:	20 61       	ori	r18, 0x10	; 16
    70fc:	2c c0       	rjmp	.+88     	; 0x7156 <vfprintf+0xc6>
    70fe:	8d 32       	cpi	r24, 0x2D	; 45
    7100:	39 f0       	breq	.+14     	; 0x7110 <vfprintf+0x80>
    7102:	80 33       	cpi	r24, 0x30	; 48
    7104:	39 f4       	brne	.+14     	; 0x7114 <vfprintf+0x84>
    7106:	21 60       	ori	r18, 0x01	; 1
    7108:	26 c0       	rjmp	.+76     	; 0x7156 <vfprintf+0xc6>
    710a:	22 60       	ori	r18, 0x02	; 2
    710c:	24 60       	ori	r18, 0x04	; 4
    710e:	23 c0       	rjmp	.+70     	; 0x7156 <vfprintf+0xc6>
    7110:	28 60       	ori	r18, 0x08	; 8
    7112:	21 c0       	rjmp	.+66     	; 0x7156 <vfprintf+0xc6>
    7114:	27 fd       	sbrc	r18, 7
    7116:	27 c0       	rjmp	.+78     	; 0x7166 <vfprintf+0xd6>
    7118:	30 ed       	ldi	r19, 0xD0	; 208
    711a:	38 0f       	add	r19, r24
    711c:	3a 30       	cpi	r19, 0x0A	; 10
    711e:	78 f4       	brcc	.+30     	; 0x713e <vfprintf+0xae>
    7120:	26 ff       	sbrs	r18, 6
    7122:	06 c0       	rjmp	.+12     	; 0x7130 <vfprintf+0xa0>
    7124:	fa e0       	ldi	r31, 0x0A	; 10
    7126:	5f 9e       	mul	r5, r31
    7128:	30 0d       	add	r19, r0
    712a:	11 24       	eor	r1, r1
    712c:	53 2e       	mov	r5, r19
    712e:	13 c0       	rjmp	.+38     	; 0x7156 <vfprintf+0xc6>
    7130:	8a e0       	ldi	r24, 0x0A	; 10
    7132:	38 9e       	mul	r3, r24
    7134:	30 0d       	add	r19, r0
    7136:	11 24       	eor	r1, r1
    7138:	33 2e       	mov	r3, r19
    713a:	20 62       	ori	r18, 0x20	; 32
    713c:	0c c0       	rjmp	.+24     	; 0x7156 <vfprintf+0xc6>
    713e:	8e 32       	cpi	r24, 0x2E	; 46
    7140:	21 f4       	brne	.+8      	; 0x714a <vfprintf+0xba>
    7142:	26 fd       	sbrc	r18, 6
    7144:	5f c1       	rjmp	.+702    	; 0x7404 <vfprintf+0x374>
    7146:	20 64       	ori	r18, 0x40	; 64
    7148:	06 c0       	rjmp	.+12     	; 0x7156 <vfprintf+0xc6>
    714a:	8c 36       	cpi	r24, 0x6C	; 108
    714c:	11 f4       	brne	.+4      	; 0x7152 <vfprintf+0xc2>
    714e:	20 68       	ori	r18, 0x80	; 128
    7150:	02 c0       	rjmp	.+4      	; 0x7156 <vfprintf+0xc6>
    7152:	88 36       	cpi	r24, 0x68	; 104
    7154:	41 f4       	brne	.+16     	; 0x7166 <vfprintf+0xd6>
    7156:	f6 01       	movw	r30, r12
    7158:	93 fd       	sbrc	r25, 3
    715a:	85 91       	lpm	r24, Z+
    715c:	93 ff       	sbrs	r25, 3
    715e:	81 91       	ld	r24, Z+
    7160:	6f 01       	movw	r12, r30
    7162:	81 11       	cpse	r24, r1
    7164:	c1 cf       	rjmp	.-126    	; 0x70e8 <vfprintf+0x58>
    7166:	98 2f       	mov	r25, r24
    7168:	9f 7d       	andi	r25, 0xDF	; 223
    716a:	95 54       	subi	r25, 0x45	; 69
    716c:	93 30       	cpi	r25, 0x03	; 3
    716e:	28 f4       	brcc	.+10     	; 0x717a <vfprintf+0xea>
    7170:	0c 5f       	subi	r16, 0xFC	; 252
    7172:	1f 4f       	sbci	r17, 0xFF	; 255
    7174:	ff e3       	ldi	r31, 0x3F	; 63
    7176:	f9 83       	std	Y+1, r31	; 0x01
    7178:	0d c0       	rjmp	.+26     	; 0x7194 <vfprintf+0x104>
    717a:	83 36       	cpi	r24, 0x63	; 99
    717c:	31 f0       	breq	.+12     	; 0x718a <vfprintf+0xfa>
    717e:	83 37       	cpi	r24, 0x73	; 115
    7180:	71 f0       	breq	.+28     	; 0x719e <vfprintf+0x10e>
    7182:	83 35       	cpi	r24, 0x53	; 83
    7184:	09 f0       	breq	.+2      	; 0x7188 <vfprintf+0xf8>
    7186:	57 c0       	rjmp	.+174    	; 0x7236 <vfprintf+0x1a6>
    7188:	21 c0       	rjmp	.+66     	; 0x71cc <vfprintf+0x13c>
    718a:	f8 01       	movw	r30, r16
    718c:	80 81       	ld	r24, Z
    718e:	89 83       	std	Y+1, r24	; 0x01
    7190:	0e 5f       	subi	r16, 0xFE	; 254
    7192:	1f 4f       	sbci	r17, 0xFF	; 255
    7194:	44 24       	eor	r4, r4
    7196:	43 94       	inc	r4
    7198:	51 2c       	mov	r5, r1
    719a:	54 01       	movw	r10, r8
    719c:	14 c0       	rjmp	.+40     	; 0x71c6 <vfprintf+0x136>
    719e:	38 01       	movw	r6, r16
    71a0:	f2 e0       	ldi	r31, 0x02	; 2
    71a2:	6f 0e       	add	r6, r31
    71a4:	71 1c       	adc	r7, r1
    71a6:	f8 01       	movw	r30, r16
    71a8:	a0 80       	ld	r10, Z
    71aa:	b1 80       	ldd	r11, Z+1	; 0x01
    71ac:	26 ff       	sbrs	r18, 6
    71ae:	03 c0       	rjmp	.+6      	; 0x71b6 <vfprintf+0x126>
    71b0:	65 2d       	mov	r22, r5
    71b2:	70 e0       	ldi	r23, 0x00	; 0
    71b4:	02 c0       	rjmp	.+4      	; 0x71ba <vfprintf+0x12a>
    71b6:	6f ef       	ldi	r22, 0xFF	; 255
    71b8:	7f ef       	ldi	r23, 0xFF	; 255
    71ba:	c5 01       	movw	r24, r10
    71bc:	2c 87       	std	Y+12, r18	; 0x0c
    71be:	36 d1       	rcall	.+620    	; 0x742c <strnlen>
    71c0:	2c 01       	movw	r4, r24
    71c2:	83 01       	movw	r16, r6
    71c4:	2c 85       	ldd	r18, Y+12	; 0x0c
    71c6:	2f 77       	andi	r18, 0x7F	; 127
    71c8:	22 2e       	mov	r2, r18
    71ca:	16 c0       	rjmp	.+44     	; 0x71f8 <vfprintf+0x168>
    71cc:	38 01       	movw	r6, r16
    71ce:	f2 e0       	ldi	r31, 0x02	; 2
    71d0:	6f 0e       	add	r6, r31
    71d2:	71 1c       	adc	r7, r1
    71d4:	f8 01       	movw	r30, r16
    71d6:	a0 80       	ld	r10, Z
    71d8:	b1 80       	ldd	r11, Z+1	; 0x01
    71da:	26 ff       	sbrs	r18, 6
    71dc:	03 c0       	rjmp	.+6      	; 0x71e4 <vfprintf+0x154>
    71de:	65 2d       	mov	r22, r5
    71e0:	70 e0       	ldi	r23, 0x00	; 0
    71e2:	02 c0       	rjmp	.+4      	; 0x71e8 <vfprintf+0x158>
    71e4:	6f ef       	ldi	r22, 0xFF	; 255
    71e6:	7f ef       	ldi	r23, 0xFF	; 255
    71e8:	c5 01       	movw	r24, r10
    71ea:	2c 87       	std	Y+12, r18	; 0x0c
    71ec:	14 d1       	rcall	.+552    	; 0x7416 <strnlen_P>
    71ee:	2c 01       	movw	r4, r24
    71f0:	2c 85       	ldd	r18, Y+12	; 0x0c
    71f2:	20 68       	ori	r18, 0x80	; 128
    71f4:	22 2e       	mov	r2, r18
    71f6:	83 01       	movw	r16, r6
    71f8:	23 fc       	sbrc	r2, 3
    71fa:	19 c0       	rjmp	.+50     	; 0x722e <vfprintf+0x19e>
    71fc:	83 2d       	mov	r24, r3
    71fe:	90 e0       	ldi	r25, 0x00	; 0
    7200:	48 16       	cp	r4, r24
    7202:	59 06       	cpc	r5, r25
    7204:	a0 f4       	brcc	.+40     	; 0x722e <vfprintf+0x19e>
    7206:	b7 01       	movw	r22, r14
    7208:	80 e2       	ldi	r24, 0x20	; 32
    720a:	90 e0       	ldi	r25, 0x00	; 0
    720c:	1a d1       	rcall	.+564    	; 0x7442 <fputc>
    720e:	3a 94       	dec	r3
    7210:	f5 cf       	rjmp	.-22     	; 0x71fc <vfprintf+0x16c>
    7212:	f5 01       	movw	r30, r10
    7214:	27 fc       	sbrc	r2, 7
    7216:	85 91       	lpm	r24, Z+
    7218:	27 fe       	sbrs	r2, 7
    721a:	81 91       	ld	r24, Z+
    721c:	5f 01       	movw	r10, r30
    721e:	b7 01       	movw	r22, r14
    7220:	90 e0       	ldi	r25, 0x00	; 0
    7222:	0f d1       	rcall	.+542    	; 0x7442 <fputc>
    7224:	31 10       	cpse	r3, r1
    7226:	3a 94       	dec	r3
    7228:	f1 e0       	ldi	r31, 0x01	; 1
    722a:	4f 1a       	sub	r4, r31
    722c:	51 08       	sbc	r5, r1
    722e:	41 14       	cp	r4, r1
    7230:	51 04       	cpc	r5, r1
    7232:	79 f7       	brne	.-34     	; 0x7212 <vfprintf+0x182>
    7234:	de c0       	rjmp	.+444    	; 0x73f2 <vfprintf+0x362>
    7236:	84 36       	cpi	r24, 0x64	; 100
    7238:	11 f0       	breq	.+4      	; 0x723e <vfprintf+0x1ae>
    723a:	89 36       	cpi	r24, 0x69	; 105
    723c:	31 f5       	brne	.+76     	; 0x728a <vfprintf+0x1fa>
    723e:	f8 01       	movw	r30, r16
    7240:	27 ff       	sbrs	r18, 7
    7242:	07 c0       	rjmp	.+14     	; 0x7252 <vfprintf+0x1c2>
    7244:	60 81       	ld	r22, Z
    7246:	71 81       	ldd	r23, Z+1	; 0x01
    7248:	82 81       	ldd	r24, Z+2	; 0x02
    724a:	93 81       	ldd	r25, Z+3	; 0x03
    724c:	0c 5f       	subi	r16, 0xFC	; 252
    724e:	1f 4f       	sbci	r17, 0xFF	; 255
    7250:	08 c0       	rjmp	.+16     	; 0x7262 <vfprintf+0x1d2>
    7252:	60 81       	ld	r22, Z
    7254:	71 81       	ldd	r23, Z+1	; 0x01
    7256:	07 2e       	mov	r0, r23
    7258:	00 0c       	add	r0, r0
    725a:	88 0b       	sbc	r24, r24
    725c:	99 0b       	sbc	r25, r25
    725e:	0e 5f       	subi	r16, 0xFE	; 254
    7260:	1f 4f       	sbci	r17, 0xFF	; 255
    7262:	2f 76       	andi	r18, 0x6F	; 111
    7264:	72 2e       	mov	r7, r18
    7266:	97 ff       	sbrs	r25, 7
    7268:	09 c0       	rjmp	.+18     	; 0x727c <vfprintf+0x1ec>
    726a:	90 95       	com	r25
    726c:	80 95       	com	r24
    726e:	70 95       	com	r23
    7270:	61 95       	neg	r22
    7272:	7f 4f       	sbci	r23, 0xFF	; 255
    7274:	8f 4f       	sbci	r24, 0xFF	; 255
    7276:	9f 4f       	sbci	r25, 0xFF	; 255
    7278:	20 68       	ori	r18, 0x80	; 128
    727a:	72 2e       	mov	r7, r18
    727c:	2a e0       	ldi	r18, 0x0A	; 10
    727e:	30 e0       	ldi	r19, 0x00	; 0
    7280:	a4 01       	movw	r20, r8
    7282:	17 d1       	rcall	.+558    	; 0x74b2 <__ultoa_invert>
    7284:	a8 2e       	mov	r10, r24
    7286:	a8 18       	sub	r10, r8
    7288:	43 c0       	rjmp	.+134    	; 0x7310 <vfprintf+0x280>
    728a:	85 37       	cpi	r24, 0x75	; 117
    728c:	29 f4       	brne	.+10     	; 0x7298 <vfprintf+0x208>
    728e:	2f 7e       	andi	r18, 0xEF	; 239
    7290:	b2 2e       	mov	r11, r18
    7292:	2a e0       	ldi	r18, 0x0A	; 10
    7294:	30 e0       	ldi	r19, 0x00	; 0
    7296:	25 c0       	rjmp	.+74     	; 0x72e2 <vfprintf+0x252>
    7298:	f2 2f       	mov	r31, r18
    729a:	f9 7f       	andi	r31, 0xF9	; 249
    729c:	bf 2e       	mov	r11, r31
    729e:	8f 36       	cpi	r24, 0x6F	; 111
    72a0:	c1 f0       	breq	.+48     	; 0x72d2 <vfprintf+0x242>
    72a2:	18 f4       	brcc	.+6      	; 0x72aa <vfprintf+0x21a>
    72a4:	88 35       	cpi	r24, 0x58	; 88
    72a6:	79 f0       	breq	.+30     	; 0x72c6 <vfprintf+0x236>
    72a8:	ad c0       	rjmp	.+346    	; 0x7404 <vfprintf+0x374>
    72aa:	80 37       	cpi	r24, 0x70	; 112
    72ac:	19 f0       	breq	.+6      	; 0x72b4 <vfprintf+0x224>
    72ae:	88 37       	cpi	r24, 0x78	; 120
    72b0:	21 f0       	breq	.+8      	; 0x72ba <vfprintf+0x22a>
    72b2:	a8 c0       	rjmp	.+336    	; 0x7404 <vfprintf+0x374>
    72b4:	2f 2f       	mov	r18, r31
    72b6:	20 61       	ori	r18, 0x10	; 16
    72b8:	b2 2e       	mov	r11, r18
    72ba:	b4 fe       	sbrs	r11, 4
    72bc:	0d c0       	rjmp	.+26     	; 0x72d8 <vfprintf+0x248>
    72be:	8b 2d       	mov	r24, r11
    72c0:	84 60       	ori	r24, 0x04	; 4
    72c2:	b8 2e       	mov	r11, r24
    72c4:	09 c0       	rjmp	.+18     	; 0x72d8 <vfprintf+0x248>
    72c6:	24 ff       	sbrs	r18, 4
    72c8:	0a c0       	rjmp	.+20     	; 0x72de <vfprintf+0x24e>
    72ca:	9f 2f       	mov	r25, r31
    72cc:	96 60       	ori	r25, 0x06	; 6
    72ce:	b9 2e       	mov	r11, r25
    72d0:	06 c0       	rjmp	.+12     	; 0x72de <vfprintf+0x24e>
    72d2:	28 e0       	ldi	r18, 0x08	; 8
    72d4:	30 e0       	ldi	r19, 0x00	; 0
    72d6:	05 c0       	rjmp	.+10     	; 0x72e2 <vfprintf+0x252>
    72d8:	20 e1       	ldi	r18, 0x10	; 16
    72da:	30 e0       	ldi	r19, 0x00	; 0
    72dc:	02 c0       	rjmp	.+4      	; 0x72e2 <vfprintf+0x252>
    72de:	20 e1       	ldi	r18, 0x10	; 16
    72e0:	32 e0       	ldi	r19, 0x02	; 2
    72e2:	f8 01       	movw	r30, r16
    72e4:	b7 fe       	sbrs	r11, 7
    72e6:	07 c0       	rjmp	.+14     	; 0x72f6 <vfprintf+0x266>
    72e8:	60 81       	ld	r22, Z
    72ea:	71 81       	ldd	r23, Z+1	; 0x01
    72ec:	82 81       	ldd	r24, Z+2	; 0x02
    72ee:	93 81       	ldd	r25, Z+3	; 0x03
    72f0:	0c 5f       	subi	r16, 0xFC	; 252
    72f2:	1f 4f       	sbci	r17, 0xFF	; 255
    72f4:	06 c0       	rjmp	.+12     	; 0x7302 <vfprintf+0x272>
    72f6:	60 81       	ld	r22, Z
    72f8:	71 81       	ldd	r23, Z+1	; 0x01
    72fa:	80 e0       	ldi	r24, 0x00	; 0
    72fc:	90 e0       	ldi	r25, 0x00	; 0
    72fe:	0e 5f       	subi	r16, 0xFE	; 254
    7300:	1f 4f       	sbci	r17, 0xFF	; 255
    7302:	a4 01       	movw	r20, r8
    7304:	d6 d0       	rcall	.+428    	; 0x74b2 <__ultoa_invert>
    7306:	a8 2e       	mov	r10, r24
    7308:	a8 18       	sub	r10, r8
    730a:	fb 2d       	mov	r31, r11
    730c:	ff 77       	andi	r31, 0x7F	; 127
    730e:	7f 2e       	mov	r7, r31
    7310:	76 fe       	sbrs	r7, 6
    7312:	0b c0       	rjmp	.+22     	; 0x732a <vfprintf+0x29a>
    7314:	37 2d       	mov	r19, r7
    7316:	3e 7f       	andi	r19, 0xFE	; 254
    7318:	a5 14       	cp	r10, r5
    731a:	50 f4       	brcc	.+20     	; 0x7330 <vfprintf+0x2a0>
    731c:	74 fe       	sbrs	r7, 4
    731e:	0a c0       	rjmp	.+20     	; 0x7334 <vfprintf+0x2a4>
    7320:	72 fc       	sbrc	r7, 2
    7322:	08 c0       	rjmp	.+16     	; 0x7334 <vfprintf+0x2a4>
    7324:	37 2d       	mov	r19, r7
    7326:	3e 7e       	andi	r19, 0xEE	; 238
    7328:	05 c0       	rjmp	.+10     	; 0x7334 <vfprintf+0x2a4>
    732a:	ba 2c       	mov	r11, r10
    732c:	37 2d       	mov	r19, r7
    732e:	03 c0       	rjmp	.+6      	; 0x7336 <vfprintf+0x2a6>
    7330:	ba 2c       	mov	r11, r10
    7332:	01 c0       	rjmp	.+2      	; 0x7336 <vfprintf+0x2a6>
    7334:	b5 2c       	mov	r11, r5
    7336:	34 ff       	sbrs	r19, 4
    7338:	0d c0       	rjmp	.+26     	; 0x7354 <vfprintf+0x2c4>
    733a:	fe 01       	movw	r30, r28
    733c:	ea 0d       	add	r30, r10
    733e:	f1 1d       	adc	r31, r1
    7340:	80 81       	ld	r24, Z
    7342:	80 33       	cpi	r24, 0x30	; 48
    7344:	11 f4       	brne	.+4      	; 0x734a <vfprintf+0x2ba>
    7346:	39 7e       	andi	r19, 0xE9	; 233
    7348:	09 c0       	rjmp	.+18     	; 0x735c <vfprintf+0x2cc>
    734a:	32 ff       	sbrs	r19, 2
    734c:	06 c0       	rjmp	.+12     	; 0x735a <vfprintf+0x2ca>
    734e:	b3 94       	inc	r11
    7350:	b3 94       	inc	r11
    7352:	04 c0       	rjmp	.+8      	; 0x735c <vfprintf+0x2cc>
    7354:	83 2f       	mov	r24, r19
    7356:	86 78       	andi	r24, 0x86	; 134
    7358:	09 f0       	breq	.+2      	; 0x735c <vfprintf+0x2cc>
    735a:	b3 94       	inc	r11
    735c:	33 fd       	sbrc	r19, 3
    735e:	12 c0       	rjmp	.+36     	; 0x7384 <vfprintf+0x2f4>
    7360:	30 ff       	sbrs	r19, 0
    7362:	06 c0       	rjmp	.+12     	; 0x7370 <vfprintf+0x2e0>
    7364:	5a 2c       	mov	r5, r10
    7366:	b3 14       	cp	r11, r3
    7368:	18 f4       	brcc	.+6      	; 0x7370 <vfprintf+0x2e0>
    736a:	53 0c       	add	r5, r3
    736c:	5b 18       	sub	r5, r11
    736e:	b3 2c       	mov	r11, r3
    7370:	b3 14       	cp	r11, r3
    7372:	60 f4       	brcc	.+24     	; 0x738c <vfprintf+0x2fc>
    7374:	b7 01       	movw	r22, r14
    7376:	80 e2       	ldi	r24, 0x20	; 32
    7378:	90 e0       	ldi	r25, 0x00	; 0
    737a:	3c 87       	std	Y+12, r19	; 0x0c
    737c:	62 d0       	rcall	.+196    	; 0x7442 <fputc>
    737e:	b3 94       	inc	r11
    7380:	3c 85       	ldd	r19, Y+12	; 0x0c
    7382:	f6 cf       	rjmp	.-20     	; 0x7370 <vfprintf+0x2e0>
    7384:	b3 14       	cp	r11, r3
    7386:	10 f4       	brcc	.+4      	; 0x738c <vfprintf+0x2fc>
    7388:	3b 18       	sub	r3, r11
    738a:	01 c0       	rjmp	.+2      	; 0x738e <vfprintf+0x2fe>
    738c:	31 2c       	mov	r3, r1
    738e:	34 ff       	sbrs	r19, 4
    7390:	11 c0       	rjmp	.+34     	; 0x73b4 <vfprintf+0x324>
    7392:	b7 01       	movw	r22, r14
    7394:	80 e3       	ldi	r24, 0x30	; 48
    7396:	90 e0       	ldi	r25, 0x00	; 0
    7398:	3c 87       	std	Y+12, r19	; 0x0c
    739a:	53 d0       	rcall	.+166    	; 0x7442 <fputc>
    739c:	3c 85       	ldd	r19, Y+12	; 0x0c
    739e:	32 ff       	sbrs	r19, 2
    73a0:	16 c0       	rjmp	.+44     	; 0x73ce <vfprintf+0x33e>
    73a2:	31 fd       	sbrc	r19, 1
    73a4:	03 c0       	rjmp	.+6      	; 0x73ac <vfprintf+0x31c>
    73a6:	88 e7       	ldi	r24, 0x78	; 120
    73a8:	90 e0       	ldi	r25, 0x00	; 0
    73aa:	02 c0       	rjmp	.+4      	; 0x73b0 <vfprintf+0x320>
    73ac:	88 e5       	ldi	r24, 0x58	; 88
    73ae:	90 e0       	ldi	r25, 0x00	; 0
    73b0:	b7 01       	movw	r22, r14
    73b2:	0c c0       	rjmp	.+24     	; 0x73cc <vfprintf+0x33c>
    73b4:	83 2f       	mov	r24, r19
    73b6:	86 78       	andi	r24, 0x86	; 134
    73b8:	51 f0       	breq	.+20     	; 0x73ce <vfprintf+0x33e>
    73ba:	31 ff       	sbrs	r19, 1
    73bc:	02 c0       	rjmp	.+4      	; 0x73c2 <vfprintf+0x332>
    73be:	8b e2       	ldi	r24, 0x2B	; 43
    73c0:	01 c0       	rjmp	.+2      	; 0x73c4 <vfprintf+0x334>
    73c2:	80 e2       	ldi	r24, 0x20	; 32
    73c4:	37 fd       	sbrc	r19, 7
    73c6:	8d e2       	ldi	r24, 0x2D	; 45
    73c8:	b7 01       	movw	r22, r14
    73ca:	90 e0       	ldi	r25, 0x00	; 0
    73cc:	3a d0       	rcall	.+116    	; 0x7442 <fputc>
    73ce:	a5 14       	cp	r10, r5
    73d0:	30 f4       	brcc	.+12     	; 0x73de <vfprintf+0x34e>
    73d2:	b7 01       	movw	r22, r14
    73d4:	80 e3       	ldi	r24, 0x30	; 48
    73d6:	90 e0       	ldi	r25, 0x00	; 0
    73d8:	34 d0       	rcall	.+104    	; 0x7442 <fputc>
    73da:	5a 94       	dec	r5
    73dc:	f8 cf       	rjmp	.-16     	; 0x73ce <vfprintf+0x33e>
    73de:	aa 94       	dec	r10
    73e0:	f4 01       	movw	r30, r8
    73e2:	ea 0d       	add	r30, r10
    73e4:	f1 1d       	adc	r31, r1
    73e6:	80 81       	ld	r24, Z
    73e8:	b7 01       	movw	r22, r14
    73ea:	90 e0       	ldi	r25, 0x00	; 0
    73ec:	2a d0       	rcall	.+84     	; 0x7442 <fputc>
    73ee:	a1 10       	cpse	r10, r1
    73f0:	f6 cf       	rjmp	.-20     	; 0x73de <vfprintf+0x34e>
    73f2:	33 20       	and	r3, r3
    73f4:	09 f4       	brne	.+2      	; 0x73f8 <vfprintf+0x368>
    73f6:	5d ce       	rjmp	.-838    	; 0x70b2 <vfprintf+0x22>
    73f8:	b7 01       	movw	r22, r14
    73fa:	80 e2       	ldi	r24, 0x20	; 32
    73fc:	90 e0       	ldi	r25, 0x00	; 0
    73fe:	21 d0       	rcall	.+66     	; 0x7442 <fputc>
    7400:	3a 94       	dec	r3
    7402:	f7 cf       	rjmp	.-18     	; 0x73f2 <vfprintf+0x362>
    7404:	f7 01       	movw	r30, r14
    7406:	86 81       	ldd	r24, Z+6	; 0x06
    7408:	97 81       	ldd	r25, Z+7	; 0x07
    740a:	02 c0       	rjmp	.+4      	; 0x7410 <vfprintf+0x380>
    740c:	8f ef       	ldi	r24, 0xFF	; 255
    740e:	9f ef       	ldi	r25, 0xFF	; 255
    7410:	2c 96       	adiw	r28, 0x0c	; 12
    7412:	e2 e1       	ldi	r30, 0x12	; 18
    7414:	11 c1       	rjmp	.+546    	; 0x7638 <__epilogue_restores__>

00007416 <strnlen_P>:
    7416:	fc 01       	movw	r30, r24
    7418:	05 90       	lpm	r0, Z+
    741a:	61 50       	subi	r22, 0x01	; 1
    741c:	70 40       	sbci	r23, 0x00	; 0
    741e:	01 10       	cpse	r0, r1
    7420:	d8 f7       	brcc	.-10     	; 0x7418 <strnlen_P+0x2>
    7422:	80 95       	com	r24
    7424:	90 95       	com	r25
    7426:	8e 0f       	add	r24, r30
    7428:	9f 1f       	adc	r25, r31
    742a:	08 95       	ret

0000742c <strnlen>:
    742c:	fc 01       	movw	r30, r24
    742e:	61 50       	subi	r22, 0x01	; 1
    7430:	70 40       	sbci	r23, 0x00	; 0
    7432:	01 90       	ld	r0, Z+
    7434:	01 10       	cpse	r0, r1
    7436:	d8 f7       	brcc	.-10     	; 0x742e <strnlen+0x2>
    7438:	80 95       	com	r24
    743a:	90 95       	com	r25
    743c:	8e 0f       	add	r24, r30
    743e:	9f 1f       	adc	r25, r31
    7440:	08 95       	ret

00007442 <fputc>:
    7442:	0f 93       	push	r16
    7444:	1f 93       	push	r17
    7446:	cf 93       	push	r28
    7448:	df 93       	push	r29
    744a:	fb 01       	movw	r30, r22
    744c:	23 81       	ldd	r18, Z+3	; 0x03
    744e:	21 fd       	sbrc	r18, 1
    7450:	03 c0       	rjmp	.+6      	; 0x7458 <fputc+0x16>
    7452:	8f ef       	ldi	r24, 0xFF	; 255
    7454:	9f ef       	ldi	r25, 0xFF	; 255
    7456:	28 c0       	rjmp	.+80     	; 0x74a8 <fputc+0x66>
    7458:	22 ff       	sbrs	r18, 2
    745a:	16 c0       	rjmp	.+44     	; 0x7488 <fputc+0x46>
    745c:	46 81       	ldd	r20, Z+6	; 0x06
    745e:	57 81       	ldd	r21, Z+7	; 0x07
    7460:	24 81       	ldd	r18, Z+4	; 0x04
    7462:	35 81       	ldd	r19, Z+5	; 0x05
    7464:	42 17       	cp	r20, r18
    7466:	53 07       	cpc	r21, r19
    7468:	44 f4       	brge	.+16     	; 0x747a <fputc+0x38>
    746a:	a0 81       	ld	r26, Z
    746c:	b1 81       	ldd	r27, Z+1	; 0x01
    746e:	9d 01       	movw	r18, r26
    7470:	2f 5f       	subi	r18, 0xFF	; 255
    7472:	3f 4f       	sbci	r19, 0xFF	; 255
    7474:	31 83       	std	Z+1, r19	; 0x01
    7476:	20 83       	st	Z, r18
    7478:	8c 93       	st	X, r24
    747a:	26 81       	ldd	r18, Z+6	; 0x06
    747c:	37 81       	ldd	r19, Z+7	; 0x07
    747e:	2f 5f       	subi	r18, 0xFF	; 255
    7480:	3f 4f       	sbci	r19, 0xFF	; 255
    7482:	37 83       	std	Z+7, r19	; 0x07
    7484:	26 83       	std	Z+6, r18	; 0x06
    7486:	10 c0       	rjmp	.+32     	; 0x74a8 <fputc+0x66>
    7488:	eb 01       	movw	r28, r22
    748a:	09 2f       	mov	r16, r25
    748c:	18 2f       	mov	r17, r24
    748e:	00 84       	ldd	r0, Z+8	; 0x08
    7490:	f1 85       	ldd	r31, Z+9	; 0x09
    7492:	e0 2d       	mov	r30, r0
    7494:	09 95       	icall
    7496:	89 2b       	or	r24, r25
    7498:	e1 f6       	brne	.-72     	; 0x7452 <fputc+0x10>
    749a:	8e 81       	ldd	r24, Y+6	; 0x06
    749c:	9f 81       	ldd	r25, Y+7	; 0x07
    749e:	01 96       	adiw	r24, 0x01	; 1
    74a0:	9f 83       	std	Y+7, r25	; 0x07
    74a2:	8e 83       	std	Y+6, r24	; 0x06
    74a4:	81 2f       	mov	r24, r17
    74a6:	90 2f       	mov	r25, r16
    74a8:	df 91       	pop	r29
    74aa:	cf 91       	pop	r28
    74ac:	1f 91       	pop	r17
    74ae:	0f 91       	pop	r16
    74b0:	08 95       	ret

000074b2 <__ultoa_invert>:
    74b2:	fa 01       	movw	r30, r20
    74b4:	aa 27       	eor	r26, r26
    74b6:	28 30       	cpi	r18, 0x08	; 8
    74b8:	51 f1       	breq	.+84     	; 0x750e <__ultoa_invert+0x5c>
    74ba:	20 31       	cpi	r18, 0x10	; 16
    74bc:	81 f1       	breq	.+96     	; 0x751e <__ultoa_invert+0x6c>
    74be:	e8 94       	clt
    74c0:	6f 93       	push	r22
    74c2:	6e 7f       	andi	r22, 0xFE	; 254
    74c4:	6e 5f       	subi	r22, 0xFE	; 254
    74c6:	7f 4f       	sbci	r23, 0xFF	; 255
    74c8:	8f 4f       	sbci	r24, 0xFF	; 255
    74ca:	9f 4f       	sbci	r25, 0xFF	; 255
    74cc:	af 4f       	sbci	r26, 0xFF	; 255
    74ce:	b1 e0       	ldi	r27, 0x01	; 1
    74d0:	3e d0       	rcall	.+124    	; 0x754e <__ultoa_invert+0x9c>
    74d2:	b4 e0       	ldi	r27, 0x04	; 4
    74d4:	3c d0       	rcall	.+120    	; 0x754e <__ultoa_invert+0x9c>
    74d6:	67 0f       	add	r22, r23
    74d8:	78 1f       	adc	r23, r24
    74da:	89 1f       	adc	r24, r25
    74dc:	9a 1f       	adc	r25, r26
    74de:	a1 1d       	adc	r26, r1
    74e0:	68 0f       	add	r22, r24
    74e2:	79 1f       	adc	r23, r25
    74e4:	8a 1f       	adc	r24, r26
    74e6:	91 1d       	adc	r25, r1
    74e8:	a1 1d       	adc	r26, r1
    74ea:	6a 0f       	add	r22, r26
    74ec:	71 1d       	adc	r23, r1
    74ee:	81 1d       	adc	r24, r1
    74f0:	91 1d       	adc	r25, r1
    74f2:	a1 1d       	adc	r26, r1
    74f4:	20 d0       	rcall	.+64     	; 0x7536 <__ultoa_invert+0x84>
    74f6:	09 f4       	brne	.+2      	; 0x74fa <__ultoa_invert+0x48>
    74f8:	68 94       	set
    74fa:	3f 91       	pop	r19
    74fc:	2a e0       	ldi	r18, 0x0A	; 10
    74fe:	26 9f       	mul	r18, r22
    7500:	11 24       	eor	r1, r1
    7502:	30 19       	sub	r19, r0
    7504:	30 5d       	subi	r19, 0xD0	; 208
    7506:	31 93       	st	Z+, r19
    7508:	de f6       	brtc	.-74     	; 0x74c0 <__ultoa_invert+0xe>
    750a:	cf 01       	movw	r24, r30
    750c:	08 95       	ret
    750e:	46 2f       	mov	r20, r22
    7510:	47 70       	andi	r20, 0x07	; 7
    7512:	40 5d       	subi	r20, 0xD0	; 208
    7514:	41 93       	st	Z+, r20
    7516:	b3 e0       	ldi	r27, 0x03	; 3
    7518:	0f d0       	rcall	.+30     	; 0x7538 <__ultoa_invert+0x86>
    751a:	c9 f7       	brne	.-14     	; 0x750e <__ultoa_invert+0x5c>
    751c:	f6 cf       	rjmp	.-20     	; 0x750a <__ultoa_invert+0x58>
    751e:	46 2f       	mov	r20, r22
    7520:	4f 70       	andi	r20, 0x0F	; 15
    7522:	40 5d       	subi	r20, 0xD0	; 208
    7524:	4a 33       	cpi	r20, 0x3A	; 58
    7526:	18 f0       	brcs	.+6      	; 0x752e <__ultoa_invert+0x7c>
    7528:	49 5d       	subi	r20, 0xD9	; 217
    752a:	31 fd       	sbrc	r19, 1
    752c:	40 52       	subi	r20, 0x20	; 32
    752e:	41 93       	st	Z+, r20
    7530:	02 d0       	rcall	.+4      	; 0x7536 <__ultoa_invert+0x84>
    7532:	a9 f7       	brne	.-22     	; 0x751e <__ultoa_invert+0x6c>
    7534:	ea cf       	rjmp	.-44     	; 0x750a <__ultoa_invert+0x58>
    7536:	b4 e0       	ldi	r27, 0x04	; 4
    7538:	a6 95       	lsr	r26
    753a:	97 95       	ror	r25
    753c:	87 95       	ror	r24
    753e:	77 95       	ror	r23
    7540:	67 95       	ror	r22
    7542:	ba 95       	dec	r27
    7544:	c9 f7       	brne	.-14     	; 0x7538 <__ultoa_invert+0x86>
    7546:	00 97       	sbiw	r24, 0x00	; 0
    7548:	61 05       	cpc	r22, r1
    754a:	71 05       	cpc	r23, r1
    754c:	08 95       	ret
    754e:	9b 01       	movw	r18, r22
    7550:	ac 01       	movw	r20, r24
    7552:	0a 2e       	mov	r0, r26
    7554:	06 94       	lsr	r0
    7556:	57 95       	ror	r21
    7558:	47 95       	ror	r20
    755a:	37 95       	ror	r19
    755c:	27 95       	ror	r18
    755e:	ba 95       	dec	r27
    7560:	c9 f7       	brne	.-14     	; 0x7554 <__ultoa_invert+0xa2>
    7562:	62 0f       	add	r22, r18
    7564:	73 1f       	adc	r23, r19
    7566:	84 1f       	adc	r24, r20
    7568:	95 1f       	adc	r25, r21
    756a:	a0 1d       	adc	r26, r0
    756c:	08 95       	ret

0000756e <eeprom_read_block>:
    756e:	dc 01       	movw	r26, r24
    7570:	cb 01       	movw	r24, r22

00007572 <eeprom_read_blraw>:
    7572:	fc 01       	movw	r30, r24
    7574:	f9 99       	sbic	0x1f, 1	; 31
    7576:	fe cf       	rjmp	.-4      	; 0x7574 <eeprom_read_blraw+0x2>
    7578:	06 c0       	rjmp	.+12     	; 0x7586 <eeprom_read_blraw+0x14>
    757a:	f2 bd       	out	0x22, r31	; 34
    757c:	e1 bd       	out	0x21, r30	; 33
    757e:	f8 9a       	sbi	0x1f, 0	; 31
    7580:	31 96       	adiw	r30, 0x01	; 1
    7582:	00 b4       	in	r0, 0x20	; 32
    7584:	0d 92       	st	X+, r0
    7586:	41 50       	subi	r20, 0x01	; 1
    7588:	50 40       	sbci	r21, 0x00	; 0
    758a:	b8 f7       	brcc	.-18     	; 0x757a <eeprom_read_blraw+0x8>
    758c:	08 95       	ret

0000758e <eeprom_read_byte>:
    758e:	f9 99       	sbic	0x1f, 1	; 31
    7590:	fe cf       	rjmp	.-4      	; 0x758e <eeprom_read_byte>
    7592:	92 bd       	out	0x22, r25	; 34
    7594:	81 bd       	out	0x21, r24	; 33
    7596:	f8 9a       	sbi	0x1f, 0	; 31
    7598:	99 27       	eor	r25, r25
    759a:	80 b5       	in	r24, 0x20	; 32
    759c:	08 95       	ret

0000759e <eeprom_read_word>:
    759e:	a8 e1       	ldi	r26, 0x18	; 24
    75a0:	b0 e0       	ldi	r27, 0x00	; 0
    75a2:	42 e0       	ldi	r20, 0x02	; 2
    75a4:	50 e0       	ldi	r21, 0x00	; 0
    75a6:	e5 cf       	rjmp	.-54     	; 0x7572 <eeprom_read_blraw>

000075a8 <eeprom_update_byte>:
    75a8:	26 2f       	mov	r18, r22

000075aa <eeprom_update_r18>:
    75aa:	f9 99       	sbic	0x1f, 1	; 31
    75ac:	fe cf       	rjmp	.-4      	; 0x75aa <eeprom_update_r18>
    75ae:	92 bd       	out	0x22, r25	; 34
    75b0:	81 bd       	out	0x21, r24	; 33
    75b2:	f8 9a       	sbi	0x1f, 0	; 31
    75b4:	01 97       	sbiw	r24, 0x01	; 1
    75b6:	00 b4       	in	r0, 0x20	; 32
    75b8:	02 16       	cp	r0, r18
    75ba:	39 f0       	breq	.+14     	; 0x75ca <eeprom_update_r18+0x20>
    75bc:	1f ba       	out	0x1f, r1	; 31
    75be:	20 bd       	out	0x20, r18	; 32
    75c0:	0f b6       	in	r0, 0x3f	; 63
    75c2:	f8 94       	cli
    75c4:	fa 9a       	sbi	0x1f, 2	; 31
    75c6:	f9 9a       	sbi	0x1f, 1	; 31
    75c8:	0f be       	out	0x3f, r0	; 63
    75ca:	08 95       	ret

000075cc <eeprom_write_block>:
    75cc:	dc 01       	movw	r26, r24
    75ce:	cb 01       	movw	r24, r22
    75d0:	02 c0       	rjmp	.+4      	; 0x75d6 <eeprom_write_block+0xa>
    75d2:	2d 91       	ld	r18, X+
    75d4:	05 d0       	rcall	.+10     	; 0x75e0 <eeprom_write_r18>
    75d6:	41 50       	subi	r20, 0x01	; 1
    75d8:	50 40       	sbci	r21, 0x00	; 0
    75da:	d8 f7       	brcc	.-10     	; 0x75d2 <eeprom_write_block+0x6>
    75dc:	08 95       	ret

000075de <eeprom_write_byte>:
    75de:	26 2f       	mov	r18, r22

000075e0 <eeprom_write_r18>:
    75e0:	f9 99       	sbic	0x1f, 1	; 31
    75e2:	fe cf       	rjmp	.-4      	; 0x75e0 <eeprom_write_r18>
    75e4:	1f ba       	out	0x1f, r1	; 31
    75e6:	92 bd       	out	0x22, r25	; 34
    75e8:	81 bd       	out	0x21, r24	; 33
    75ea:	20 bd       	out	0x20, r18	; 32
    75ec:	0f b6       	in	r0, 0x3f	; 63
    75ee:	f8 94       	cli
    75f0:	fa 9a       	sbi	0x1f, 2	; 31
    75f2:	f9 9a       	sbi	0x1f, 1	; 31
    75f4:	0f be       	out	0x3f, r0	; 63
    75f6:	01 96       	adiw	r24, 0x01	; 1
    75f8:	08 95       	ret

000075fa <eeprom_write_word>:
    75fa:	f1 df       	rcall	.-30     	; 0x75de <eeprom_write_byte>
    75fc:	27 2f       	mov	r18, r23
    75fe:	f0 cf       	rjmp	.-32     	; 0x75e0 <eeprom_write_r18>

00007600 <__prologue_saves__>:
    7600:	2f 92       	push	r2
    7602:	3f 92       	push	r3
    7604:	4f 92       	push	r4
    7606:	5f 92       	push	r5
    7608:	6f 92       	push	r6
    760a:	7f 92       	push	r7
    760c:	8f 92       	push	r8
    760e:	9f 92       	push	r9
    7610:	af 92       	push	r10
    7612:	bf 92       	push	r11
    7614:	cf 92       	push	r12
    7616:	df 92       	push	r13
    7618:	ef 92       	push	r14
    761a:	ff 92       	push	r15
    761c:	0f 93       	push	r16
    761e:	1f 93       	push	r17
    7620:	cf 93       	push	r28
    7622:	df 93       	push	r29
    7624:	cd b7       	in	r28, 0x3d	; 61
    7626:	de b7       	in	r29, 0x3e	; 62
    7628:	ca 1b       	sub	r28, r26
    762a:	db 0b       	sbc	r29, r27
    762c:	0f b6       	in	r0, 0x3f	; 63
    762e:	f8 94       	cli
    7630:	de bf       	out	0x3e, r29	; 62
    7632:	0f be       	out	0x3f, r0	; 63
    7634:	cd bf       	out	0x3d, r28	; 61
    7636:	09 94       	ijmp

00007638 <__epilogue_restores__>:
    7638:	2a 88       	ldd	r2, Y+18	; 0x12
    763a:	39 88       	ldd	r3, Y+17	; 0x11
    763c:	48 88       	ldd	r4, Y+16	; 0x10
    763e:	5f 84       	ldd	r5, Y+15	; 0x0f
    7640:	6e 84       	ldd	r6, Y+14	; 0x0e
    7642:	7d 84       	ldd	r7, Y+13	; 0x0d
    7644:	8c 84       	ldd	r8, Y+12	; 0x0c
    7646:	9b 84       	ldd	r9, Y+11	; 0x0b
    7648:	aa 84       	ldd	r10, Y+10	; 0x0a
    764a:	b9 84       	ldd	r11, Y+9	; 0x09
    764c:	c8 84       	ldd	r12, Y+8	; 0x08
    764e:	df 80       	ldd	r13, Y+7	; 0x07
    7650:	ee 80       	ldd	r14, Y+6	; 0x06
    7652:	fd 80       	ldd	r15, Y+5	; 0x05
    7654:	0c 81       	ldd	r16, Y+4	; 0x04
    7656:	1b 81       	ldd	r17, Y+3	; 0x03
    7658:	aa 81       	ldd	r26, Y+2	; 0x02
    765a:	b9 81       	ldd	r27, Y+1	; 0x01
    765c:	ce 0f       	add	r28, r30
    765e:	d1 1d       	adc	r29, r1
    7660:	0f b6       	in	r0, 0x3f	; 63
    7662:	f8 94       	cli
    7664:	de bf       	out	0x3e, r29	; 62
    7666:	0f be       	out	0x3f, r0	; 63
    7668:	cd bf       	out	0x3d, r28	; 61
    766a:	ed 01       	movw	r28, r26
    766c:	08 95       	ret

0000766e <_exit>:
    766e:	f8 94       	cli

00007670 <__stop_program>:
    7670:	ff cf       	rjmp	.-2      	; 0x7670 <__stop_program>
