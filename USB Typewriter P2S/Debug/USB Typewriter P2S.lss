
USB Typewriter P2S.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000002b0  00800100  00007a4e  00007ae2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007a4e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006a7  008003b0  008003b0  00007d92  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00007d92  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00007df0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000798  00000000  00000000  00007e30  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00010a8e  00000000  00000000  000085c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000031f8  00000000  00000000  00019056  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00015df2  00000000  00000000  0001c24e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001ff0  00000000  00000000  00032040  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0001b79f  00000000  00000000  00034030  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000dcf0  00000000  00000000  0004f7cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001310  00000000  00000000  0005d4bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000b9ce  00000000  00000000  0005e7cf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	4c c2       	rjmp	.+1176   	; 0x49a <__ctors_end>
       2:	00 00       	nop
       4:	67 c2       	rjmp	.+1230   	; 0x4d4 <__bad_interrupt>
       6:	00 00       	nop
       8:	65 c2       	rjmp	.+1226   	; 0x4d4 <__bad_interrupt>
       a:	00 00       	nop
       c:	63 c2       	rjmp	.+1222   	; 0x4d4 <__bad_interrupt>
       e:	00 00       	nop
      10:	61 c2       	rjmp	.+1218   	; 0x4d4 <__bad_interrupt>
      12:	00 00       	nop
      14:	5f c2       	rjmp	.+1214   	; 0x4d4 <__bad_interrupt>
      16:	00 00       	nop
      18:	5d c2       	rjmp	.+1210   	; 0x4d4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	5b c2       	rjmp	.+1206   	; 0x4d4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	59 c2       	rjmp	.+1202   	; 0x4d4 <__bad_interrupt>
      22:	00 00       	nop
      24:	57 c2       	rjmp	.+1198   	; 0x4d4 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 ac 36 	jmp	0x6d58	; 0x6d58 <__vector_10>
      2c:	53 c2       	rjmp	.+1190   	; 0x4d4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	51 c2       	rjmp	.+1186   	; 0x4d4 <__bad_interrupt>
      32:	00 00       	nop
      34:	4f c2       	rjmp	.+1182   	; 0x4d4 <__bad_interrupt>
      36:	00 00       	nop
      38:	4d c2       	rjmp	.+1178   	; 0x4d4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	4b c2       	rjmp	.+1174   	; 0x4d4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	49 c2       	rjmp	.+1170   	; 0x4d4 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 85 26 	jmp	0x4d0a	; 0x4d0a <__vector_17>
      48:	45 c2       	rjmp	.+1162   	; 0x4d4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	43 c2       	rjmp	.+1158   	; 0x4d4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	41 c2       	rjmp	.+1154   	; 0x4d4 <__bad_interrupt>
      52:	00 00       	nop
      54:	3f c2       	rjmp	.+1150   	; 0x4d4 <__bad_interrupt>
      56:	00 00       	nop
      58:	3d c2       	rjmp	.+1146   	; 0x4d4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	3b c2       	rjmp	.+1142   	; 0x4d4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	39 c2       	rjmp	.+1138   	; 0x4d4 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 e1 25 	jmp	0x4bc2	; 0x4bc2 <__vector_25>
      68:	0c 94 0f 26 	jmp	0x4c1e	; 0x4c1e <__vector_26>
      6c:	33 c2       	rjmp	.+1126   	; 0x4d4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	31 c2       	rjmp	.+1122   	; 0x4d4 <__bad_interrupt>
      72:	00 00       	nop
      74:	2f c2       	rjmp	.+1118   	; 0x4d4 <__bad_interrupt>
      76:	00 00       	nop
      78:	2d c2       	rjmp	.+1114   	; 0x4d4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	2b c2       	rjmp	.+1110   	; 0x4d4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	29 c2       	rjmp	.+1106   	; 0x4d4 <__bad_interrupt>
      82:	00 00       	nop
      84:	27 c2       	rjmp	.+1102   	; 0x4d4 <__bad_interrupt>
      86:	00 00       	nop
      88:	25 c2       	rjmp	.+1098   	; 0x4d4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	23 c2       	rjmp	.+1094   	; 0x4d4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	21 c2       	rjmp	.+1090   	; 0x4d4 <__bad_interrupt>
      92:	00 00       	nop
      94:	1f c2       	rjmp	.+1086   	; 0x4d4 <__bad_interrupt>
      96:	00 00       	nop
      98:	1d c2       	rjmp	.+1082   	; 0x4d4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	1b c2       	rjmp	.+1078   	; 0x4d4 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	19 c2       	rjmp	.+1074   	; 0x4d4 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	0c 94 44 0a 	jmp	0x1488	; 0x1488 <__vector_41>
      a8:	15 c2       	rjmp	.+1066   	; 0x4d4 <__bad_interrupt>
	...

000000ac <Str_Settings_Saved>:
      ac:	53 45 54 54 49 4e 47 53 20 53 41 56 45 44 21 0d     SETTINGS SAVED!.
	...

000000bd <Str_Spacebar_Blocks_Enter>:
      bd:	0d 49 47 4e 4f 52 45 20 45 4e 54 45 52 20 4b 45     .IGNORE ENTER KE
      cd:	59 20 57 48 45 4e 20 53 50 41 43 45 42 41 52 20     Y WHEN SPACEBAR 
      dd:	49 53 20 48 45 4c 44 3f 0d 00                       IS HELD?..

000000e7 <Str_Set_Reed_Time>:
      e7:	0d 4e 4f 57 20 53 45 54 20 52 45 45 44 20 52 45     .NOW SET REED RE
      f7:	41 43 54 49 4f 4e 20 54 49 4d 45 2e 2e 2e 0d 00     ACTION TIME.....

00000107 <Str_Set_Double_Time>:
     107:	0d 4e 4f 57 20 53 45 54 20 44 45 4c 41 59 20 42     .NOW SET DELAY B
     117:	45 54 57 45 45 4e 20 44 4f 55 42 4c 45 20 4b 45     ETWEEN DOUBLE KE
     127:	59 20 50 52 45 53 53 45 53 2e 2e 2e 0d 00           Y PRESSES.....

00000135 <Str_Set_Release_Time>:
     135:	0d 4e 4f 57 20 53 45 54 20 4b 45 59 20 52 45 4c     .NOW SET KEY REL
     145:	45 41 53 45 20 54 49 4d 45 2e 2e 2e 0d 00           EASE TIME.....

00000153 <Str_Set_Reaction_Time>:
     153:	50 52 45 53 53 20 43 54 52 4c 20 41 4e 44 20 41     PRESS CTRL AND A
     163:	4c 54 20 54 4f 20 53 45 54 20 4b 45 59 20 52 45     LT TO SET KEY RE
     173:	41 43 54 49 4f 4e 20 54 49 4d 45 2e 2e 2e 0d 00     ACTION TIME.....

00000183 <Str_Press_CMD>:
     183:	50 52 45 53 53 20 43 4d 44 20 4b 45 59 20 54 4f     PRESS CMD KEY TO
     193:	20 43 4f 4e 54 49 4e 55 45 2e 2e 2e 0d 00            CONTINUE.....

000001a1 <Str_Adj_Sensitivity>:
     1a1:	41 44 4a 55 53 54 49 4e 47 20 4b 45 59 20 53 45     ADJUSTING KEY SE
     1b1:	4e 53 49 54 49 56 49 54 59 2e 0d 00                 NSITIVITY...

000001bd <Str_No_Hall>:
     1bd:	4e 4f 20 48 41 4c 4c 20 45 46 46 45 43 54 20 53     NO HALL EFFECT S
     1cd:	45 4e 53 4f 52 20 44 45 54 45 43 54 45 44 2e 20     ENSOR DETECTED. 
     1dd:	28 4e 4f 54 20 41 20 50 52 4f 42 4c 45 4d 29 0d     (NOT A PROBLEM).
	...

000001ee <Str_Calibrate_Hall>:
     1ee:	48 4f 4c 44 20 44 4f 57 4e 20 41 4e 59 20 4b 45     HOLD DOWN ANY KE
     1fe:	59 20 54 4f 20 43 41 4c 49 42 52 41 54 45 20 48     Y TO CALIBRATE H
     20e:	41 4c 4c 20 45 46 46 45 43 54 20 53 45 4e 53 4f     ALL EFFECT SENSO
     21e:	52 2e 2e 2e 0d 00                                   R.....

00000224 <Str_Backspace>:
     224:	42 41 43 4b 53 50 41 43 45 00                       BACKSPACE.

0000022e <Str_Post>:
     22e:	53 45 4e 44 00                                      SEND.

00000233 <Str_Second_Enter>:
     233:	53 45 43 4f 4e 44 41 52 59 20 45 4e 54 45 52 00     SECONDARY ENTER.

00000243 <Str_Enter>:
     243:	45 4e 54 45 52 00                                   ENTER.

00000249 <Str_Spacebar>:
     249:	53 50 41 43 45 42 41 52 00                          SPACEBAR.

00000252 <Str_Quick_Calibrate>:
     252:	51 55 49 43 4b 20 43 41 4c 49 42 52 41 54 49 4f     QUICK CALIBRATIO
     262:	4e 20 4d 4f 44 45 2e 2e 2e 0d 00                    N MODE.....

0000026d <Str_No_Dummy_Load>:
     26d:	44 55 4d 4d 59 20 4c 4f 41 44 20 44 45 41 43 54     DUMMY LOAD DEACT
     27d:	49 56 41 54 45 44 0d 00                             IVATED..

00000285 <Str_Dummy_Load>:
     285:	44 55 4d 4d 59 20 4c 4f 41 44 20 41 43 54 49 56     DUMMY LOAD ACTIV
     295:	41 54 45 44 0d 00                                   ATED..

0000029b <Str_Shift_Error>:
     29b:	45 52 52 4f 52 2e 2e 2e 53 48 49 46 54 20 4d 55     ERROR...SHIFT MU
     2ab:	53 54 20 42 45 20 41 20 52 45 45 44 20 53 57 49     ST BE A REED SWI
     2bb:	54 43 48 2e 0d 00                                   TCH...

000002c1 <Str_Type_The_Following>:
     2c1:	54 59 50 45 20 54 48 45 20 46 4f 4c 4c 4f 57 49     TYPE THE FOLLOWI
     2d1:	4e 47 20 4b 45 59 53 20 28 50 52 45 53 53 20 53     NG KEYS (PRESS S
     2e1:	50 41 43 45 20 54 4f 20 53 4b 49 50 29 2e 2e 2e     PACE TO SKIP)...
     2f1:	0d 00                                               ..

000002f3 <Str_Calibrating>:
     2f3:	43 41 4c 49 42 52 41 54 49 4e 47 2e 2e 2e 0d 00     CALIBRATING.....

00000303 <Str_SD_Mode>:
     303:	53 44 20 43 41 52 44 20 53 54 4f 52 41 47 45 20     SD CARD STORAGE 
     313:	4d 4f 44 45 0d 00                                   MODE..

00000319 <Str_Combo_Mode>:
     319:	55 53 42 20 4b 45 59 42 4f 41 52 44 2f 43 41 52     USB KEYBOARD/CAR
     329:	44 20 52 45 41 44 45 52 20 4d 4f 44 45 0d 00        D READER MODE..

00000338 <Str_Light_Mode>:
     338:	4c 49 47 48 54 20 4d 4f 44 45 20 28 53 44 20 43     LIGHT MODE (SD C
     348:	41 52 44 20 52 45 41 44 45 52 20 44 49 53 41 42     ARD READER DISAB
     358:	4c 45 44 29 0d 00                                   LED)..

0000035e <Str_BT_Mode>:
     35e:	42 4c 55 45 54 4f 4f 54 48 20 4b 45 59 42 4f 41     BLUETOOTH KEYBOA
     36e:	52 44 20 4d 4f 44 45 0d 00                          RD MODE..

00000377 <Str_Typewriter_Mode>:
     377:	44 45 46 41 55 4c 54 20 53 45 54 54 49 4e 47 3a     DEFAULT SETTING:
     387:	20 00                                                .

00000389 <Str_Firmware_Ver>:
     389:	46 49 52 4d 57 41 52 45 20 56 45 52 20 35 2e 32     FIRMWARE VER 5.2
     399:	2e 31 33 00                                         .13.

0000039d <Str_USB_Typewriter>:
     39d:	55 53 42 20 54 59 50 45 57 52 49 54 45 52 20 28     USB TYPEWRITER (
     3ad:	54 4d 29 0d 00                                      TM)..

000003b2 <ProductString>:
     3b2:	30 03 55 00 53 00 42 00 20 00 54 00 79 00 70 00     0.U.S.B. .T.y.p.
     3c2:	65 00 77 00 72 00 69 00 74 00 65 00 72 00 20 00     e.w.r.i.t.e.r. .
     3d2:	4b 00 65 00 79 00 62 00 6f 00 61 00 72 00 64 00     K.e.y.b.o.a.r.d.
	...

000003e4 <ManufacturerString>:
     3e4:	26 03 55 00 53 00 42 00 20 00 54 00 59 00 50 00     &.U.S.B. .T.Y.P.
     3f4:	45 00 57 00 52 00 49 00 54 00 45 00 52 00 20 00     E.W.R.I.T.E.R. .
     404:	4c 00 4c 00 43 00 00 00                             L.L.C...

0000040c <LanguageString>:
     40c:	04 03 09 04                                         ....

00000410 <ConfigurationDescriptor>:
     410:	09 02 39 00 02 01 00 80 07 09 04 00 00 02 08 06     ..9.............
     420:	50 00 07 05 83 02 40 00 05 07 05 04 02 40 00 05     P.....@......@..
     430:	09 04 01 00 01 03 01 01 00 09 21 11 01 00 01 22     ..........!...."
     440:	3f 00 07 05 81 03 08 00 05                          ?........

00000449 <DeviceDescriptor>:
     449:	12 01 10 01 00 00 00 08 eb 03 61 20 86 00 01 02     ..........a ....
     459:	dc 01                                               ..

0000045b <KeyboardReport>:
     45b:	05 01 09 06 a1 01 05 07 19 e0 29 e7 15 00 25 01     ..........)...%.
     46b:	75 01 95 08 81 02 95 01 75 08 81 01 05 08 19 01     u.......u.......
     47b:	29 05 95 05 75 01 91 02 95 01 75 03 91 01 15 00     )...u.....u.....
     48b:	25 ff 05 07 19 00 29 ff 95 06 75 08 81 00 c0        %.....)...u....

0000049a <__ctors_end>:
     49a:	11 24       	eor	r1, r1
     49c:	1f be       	out	0x3f, r1	; 63
     49e:	cf ef       	ldi	r28, 0xFF	; 255
     4a0:	da e0       	ldi	r29, 0x0A	; 10
     4a2:	de bf       	out	0x3e, r29	; 62
     4a4:	cd bf       	out	0x3d, r28	; 61

000004a6 <__do_copy_data>:
     4a6:	13 e0       	ldi	r17, 0x03	; 3
     4a8:	a0 e0       	ldi	r26, 0x00	; 0
     4aa:	b1 e0       	ldi	r27, 0x01	; 1
     4ac:	ee e4       	ldi	r30, 0x4E	; 78
     4ae:	fa e7       	ldi	r31, 0x7A	; 122
     4b0:	02 c0       	rjmp	.+4      	; 0x4b6 <__do_copy_data+0x10>
     4b2:	05 90       	lpm	r0, Z+
     4b4:	0d 92       	st	X+, r0
     4b6:	a0 3b       	cpi	r26, 0xB0	; 176
     4b8:	b1 07       	cpc	r27, r17
     4ba:	d9 f7       	brne	.-10     	; 0x4b2 <__do_copy_data+0xc>

000004bc <__do_clear_bss>:
     4bc:	2a e0       	ldi	r18, 0x0A	; 10
     4be:	a0 eb       	ldi	r26, 0xB0	; 176
     4c0:	b3 e0       	ldi	r27, 0x03	; 3
     4c2:	01 c0       	rjmp	.+2      	; 0x4c6 <.do_clear_bss_start>

000004c4 <.do_clear_bss_loop>:
     4c4:	1d 92       	st	X+, r1

000004c6 <.do_clear_bss_start>:
     4c6:	a7 35       	cpi	r26, 0x57	; 87
     4c8:	b2 07       	cpc	r27, r18
     4ca:	e1 f7       	brne	.-8      	; 0x4c4 <.do_clear_bss_loop>
     4cc:	0e 94 6f 28 	call	0x50de	; 0x50de <main>
     4d0:	0c 94 25 3d 	jmp	0x7a4a	; 0x7a4a <_exit>

000004d4 <__bad_interrupt>:
     4d4:	95 cd       	rjmp	.-1238   	; 0x0 <__vectors>

000004d6 <Bluetooth_Reset>:
	return Get_Response(verbose);
}

	
void Bluetooth_Reset(){
	set_low(BT_RESET);//reset the bluetooth module
     4d6:	8f 98       	cbi	0x11, 7	; 17
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     4d8:	2f e7       	ldi	r18, 0x7F	; 127
     4da:	88 e3       	ldi	r24, 0x38	; 56
     4dc:	91 e0       	ldi	r25, 0x01	; 1
     4de:	21 50       	subi	r18, 0x01	; 1
     4e0:	80 40       	sbci	r24, 0x00	; 0
     4e2:	90 40       	sbci	r25, 0x00	; 0
     4e4:	e1 f7       	brne	.-8      	; 0x4de <Bluetooth_Reset+0x8>
     4e6:	00 c0       	rjmp	.+0      	; 0x4e8 <Bluetooth_Reset+0x12>
     4e8:	00 00       	nop
	Delay_MS(50); //hold in reset for 50ms
	set_high(BT_RESET); //reactivate bluetooth module
     4ea:	8f 9a       	sbi	0x11, 7	; 17
     4ec:	2f ef       	ldi	r18, 0xFF	; 255
     4ee:	86 e1       	ldi	r24, 0x16	; 22
     4f0:	91 e1       	ldi	r25, 0x11	; 17
     4f2:	21 50       	subi	r18, 0x01	; 1
     4f4:	80 40       	sbci	r24, 0x00	; 0
     4f6:	90 40       	sbci	r25, 0x00	; 0
     4f8:	e1 f7       	brne	.-8      	; 0x4f2 <Bluetooth_Reset+0x1c>
     4fa:	00 c0       	rjmp	.+0      	; 0x4fc <Bluetooth_Reset+0x26>
     4fc:	00 00       	nop
	Delay_MS(BLUETOOTH_RESET_DELAY);//takes 500ms from power on for module to be able to receive commands.
	
	set_low(BT_CTS);//this wakes the buetooth module
     4fe:	76 98       	cbi	0x0e, 6	; 14
     500:	8f e0       	ldi	r24, 0x0F	; 15
     502:	97 e2       	ldi	r25, 0x27	; 39
     504:	01 97       	sbiw	r24, 0x01	; 1
     506:	f1 f7       	brne	.-4      	; 0x504 <Bluetooth_Reset+0x2e>
     508:	00 c0       	rjmp	.+0      	; 0x50a <Bluetooth_Reset+0x34>
     50a:	00 00       	nop
     50c:	08 95       	ret

0000050e <Get_Response>:
	Delay_MS(5);//it takes 5ms to wake up from low-power state
	
}


bool Get_Response(bool verbose){
     50e:	cf 92       	push	r12
     510:	df 92       	push	r13
     512:	ef 92       	push	r14
     514:	ff 92       	push	r15
     516:	1f 93       	push	r17
     518:	cf 93       	push	r28
     51a:	df 93       	push	r29
	uint16_t tmpchar;
	if(verbose){
     51c:	88 23       	and	r24, r24
     51e:	a1 f1       	breq	.+104    	; 0x588 <Get_Response+0x7a>
     520:	2f ef       	ldi	r18, 0xFF	; 255
     522:	80 e7       	ldi	r24, 0x70	; 112
     524:	92 e0       	ldi	r25, 0x02	; 2
     526:	21 50       	subi	r18, 0x01	; 1
     528:	80 40       	sbci	r24, 0x00	; 0
     52a:	90 40       	sbci	r25, 0x00	; 0
     52c:	e1 f7       	brne	.-8      	; 0x526 <Get_Response+0x18>
     52e:	00 c0       	rjmp	.+0      	; 0x530 <Get_Response+0x22>
     530:	00 00       	nop
		Delay_MS(BLUETOOTH_RESPONSE_DELAY); //wait for the response to be sent.
		response[0] = '\0'; //clear response string
     532:	e5 e7       	ldi	r30, 0x75	; 117
     534:	f6 e0       	ldi	r31, 0x06	; 6
     536:	10 82       	st	Z, r1
		response[1] = '\0';
     538:	11 82       	std	Z+1, r1	; 0x01
		response[2] = '\0';
     53a:	12 82       	std	Z+2, r1	; 0x02
		response[4] = '\0';
     53c:	14 82       	std	Z+4, r1	; 0x04
     53e:	7f 01       	movw	r14, r30
     540:	0f 2e       	mov	r0, r31
     542:	f5 eb       	ldi	r31, 0xB5	; 181
     544:	cf 2e       	mov	r12, r31
     546:	f6 e0       	ldi	r31, 0x06	; 6
     548:	df 2e       	mov	r13, r31
     54a:	f0 2d       	mov	r31, r0
     54c:	ef 01       	movw	r28, r30
     54e:	1c 2f       	mov	r17, r28
     550:	1e 19       	sub	r17, r14
	
		for(uint8_t i=0; i<response_buffer_len; i++){
			tmpchar = uart_getc();
     552:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <uart_getc>
			if ((tmpchar & 0xFF00) != 0){ //check upper byte of getc for error code -- most commonly this would be "buffer empty"
     556:	9c 01       	movw	r18, r24
     558:	22 27       	eor	r18, r18
     55a:	23 2b       	or	r18, r19
     55c:	31 f0       	breq	.+12     	; 0x56a <Get_Response+0x5c>
				response[i]='\0'; //mark the string as having ended.
     55e:	e1 2f       	mov	r30, r17
     560:	f0 e0       	ldi	r31, 0x00	; 0
     562:	eb 58       	subi	r30, 0x8B	; 139
     564:	f9 4f       	sbci	r31, 0xF9	; 249
     566:	10 82       	st	Z, r1
				break; // reception is complete -- no more characters to retrieve.
     568:	04 c0       	rjmp	.+8      	; 0x572 <Get_Response+0x64>
			}
			
			response[i] = tmpchar & 0xFF; //store lower byte of getc as a uart character received
     56a:	89 93       	st	Y+, r24
		response[0] = '\0'; //clear response string
		response[1] = '\0';
		response[2] = '\0';
		response[4] = '\0';
	
		for(uint8_t i=0; i<response_buffer_len; i++){
     56c:	cc 15       	cp	r28, r12
     56e:	dd 05       	cpc	r29, r13
     570:	71 f7       	brne	.-36     	; 0x54e <Get_Response+0x40>
		}
		#ifdef _DEBUG
			USBSendString(response);
		#endif
		
		if ((response[0] == 'O')||(response[2] == '=')){  //if response is "OK" or "XX=...", bt module has received command successfully
     572:	80 91 75 06 	lds	r24, 0x0675
     576:	8f 34       	cpi	r24, 0x4F	; 79
     578:	49 f0       	breq	.+18     	; 0x58c <Get_Response+0x7e>
     57a:	81 e0       	ldi	r24, 0x01	; 1
     57c:	90 91 77 06 	lds	r25, 0x0677
     580:	9d 33       	cpi	r25, 0x3D	; 61
     582:	29 f0       	breq	.+10     	; 0x58e <Get_Response+0x80>
     584:	80 e0       	ldi	r24, 0x00	; 0
     586:	03 c0       	rjmp	.+6      	; 0x58e <Get_Response+0x80>
		else{
			return false;
		}
	}
	else{
		return true;
     588:	81 e0       	ldi	r24, 0x01	; 1
     58a:	01 c0       	rjmp	.+2      	; 0x58e <Get_Response+0x80>
		#ifdef _DEBUG
			USBSendString(response);
		#endif
		
		if ((response[0] == 'O')||(response[2] == '=')){  //if response is "OK" or "XX=...", bt module has received command successfully
			return true;
     58c:	81 e0       	ldi	r24, 0x01	; 1
	else{
		return true;
	}

		
}
     58e:	df 91       	pop	r29
     590:	cf 91       	pop	r28
     592:	1f 91       	pop	r17
     594:	ff 90       	pop	r15
     596:	ef 90       	pop	r14
     598:	df 90       	pop	r13
     59a:	cf 90       	pop	r12
     59c:	08 95       	ret

0000059e <Bluetooth_Send_CMD>:
 * 
 * \param command -- string containing formatted command to send to bluetooth module
 * 
 * \return void
 */
bool Bluetooth_Send_CMD(char* command, bool verbose){
     59e:	1f 93       	push	r17
     5a0:	cf 93       	push	r28
     5a2:	df 93       	push	r29
     5a4:	ec 01       	movw	r28, r24
     5a6:	16 2f       	mov	r17, r22
	
	int i = 0;
	
	uart_clear_rx_buffer();
     5a8:	0e 94 6b 26 	call	0x4cd6	; 0x4cd6 <uart_clear_rx_buffer>
	#ifdef _DEBUG
	if(verbose){USBSendString("sending command\n");}
	#endif
	
	while (command[i] != '\0'){//loop until end of string
     5ac:	88 81       	ld	r24, Y
     5ae:	88 23       	and	r24, r24
     5b0:	31 f0       	breq	.+12     	; 0x5be <Bluetooth_Send_CMD+0x20>
     5b2:	21 96       	adiw	r28, 0x01	; 1
		uart_putc(command[i]); //send first character of command
     5b4:	0e 94 70 26 	call	0x4ce0	; 0x4ce0 <uart_putc>
	uart_clear_rx_buffer();
	#ifdef _DEBUG
	if(verbose){USBSendString("sending command\n");}
	#endif
	
	while (command[i] != '\0'){//loop until end of string
     5b8:	89 91       	ld	r24, Y+
     5ba:	81 11       	cpse	r24, r1
     5bc:	fb cf       	rjmp	.-10     	; 0x5b4 <Bluetooth_Send_CMD+0x16>
		uart_putc(command[i]); //send first character of command
		i++;
	}
	uart_putc('\r');
     5be:	8d e0       	ldi	r24, 0x0D	; 13
     5c0:	0e 94 70 26 	call	0x4ce0	; 0x4ce0 <uart_putc>
	uart_putc('\n'); //send return carriage
     5c4:	8a e0       	ldi	r24, 0x0A	; 10
     5c6:	0e 94 70 26 	call	0x4ce0	; 0x4ce0 <uart_putc>

	return Get_Response(verbose);
     5ca:	81 2f       	mov	r24, r17
     5cc:	a0 df       	rcall	.-192    	; 0x50e <Get_Response>
}
     5ce:	df 91       	pop	r29
     5d0:	cf 91       	pop	r28
     5d2:	1f 91       	pop	r17
     5d4:	08 95       	ret

000005d6 <Bluetooth_Send>:
 * \param key 
 * \param modifier
 * 
 * \return void
 */
void Bluetooth_Send(uint8_t key, uint8_t modifier){
     5d6:	ef 92       	push	r14
     5d8:	ff 92       	push	r15
     5da:	0f 93       	push	r16
     5dc:	1f 93       	push	r17
     5de:	cf 93       	push	r28
     5e0:	df 93       	push	r29
     5e2:	cd b7       	in	r28, 0x3d	; 61
     5e4:	de b7       	in	r29, 0x3e	; 62
     5e6:	a4 97       	sbiw	r28, 0x24	; 36
     5e8:	0f b6       	in	r0, 0x3f	; 63
     5ea:	f8 94       	cli
     5ec:	de bf       	out	0x3e, r29	; 62
     5ee:	0f be       	out	0x3f, r0	; 63
     5f0:	cd bf       	out	0x3d, r28	; 61
     5f2:	18 2f       	mov	r17, r24
     5f4:	06 2f       	mov	r16, r22
	char cmd_buffer[] = "AT+KR=A1,01,00,00,00,00,00,00,00,00";
     5f6:	84 e2       	ldi	r24, 0x24	; 36
     5f8:	ea e9       	ldi	r30, 0x9A	; 154
     5fa:	f1 e0       	ldi	r31, 0x01	; 1
     5fc:	de 01       	movw	r26, r28
     5fe:	11 96       	adiw	r26, 0x01	; 1
     600:	01 90       	ld	r0, Z+
     602:	0d 92       	st	X+, r0
     604:	8a 95       	dec	r24
     606:	e1 f7       	brne	.-8      	; 0x600 <Bluetooth_Send+0x2a>
//	set_high(BT_CTS);//toggle cts to wake module from deep sleep.
//	_delay_us(100);

	Bluetooth_Send_CMD("AT+UI=01",false);
     608:	60 e0       	ldi	r22, 0x00	; 0
     60a:	89 e6       	ldi	r24, 0x69	; 105
     60c:	91 e0       	ldi	r25, 0x01	; 1
     60e:	c7 df       	rcall	.-114    	; 0x59e <Bluetooth_Send_CMD>
     610:	8f ec       	ldi	r24, 0xCF	; 207
     612:	97 e0       	ldi	r25, 0x07	; 7
     614:	01 97       	sbiw	r24, 0x01	; 1
     616:	f1 f7       	brne	.-4      	; 0x614 <Bluetooth_Send+0x3e>
     618:	00 c0       	rjmp	.+0      	; 0x61a <Bluetooth_Send+0x44>
     61a:	00 00       	nop
	Delay_MS(1);
		if (key&FORCE_UPPER){ //in this program, we use the MSB of code to indicate that this key MUST be sent as upper case.
     61c:	11 23       	and	r17, r17
     61e:	14 f4       	brge	.+4      	; 0x624 <Bluetooth_Send+0x4e>
			reg_clr(key,FORCE_UPPER); //clear the MSB,
     620:	1f 77       	andi	r17, 0x7F	; 127
			modifier = UPPER; //and set the modifier to upper case.
     622:	02 e0       	ldi	r16, 0x02	; 2
		}
		
		if(key == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
     624:	14 37       	cpi	r17, 0x74	; 116
     626:	11 f4       	brne	.+4      	; 0x62c <Bluetooth_Send+0x56>
			key = KEY_ENTER;
			modifier = HID_KEYBOARD_MODIFIER_LEFTCTRL;
     628:	01 e0       	ldi	r16, 0x01	; 1
			reg_clr(key,FORCE_UPPER); //clear the MSB,
			modifier = UPPER; //and set the modifier to upper case.
		}
		
		if(key == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
			key = KEY_ENTER;
     62a:	18 e2       	ldi	r17, 0x28	; 40
			modifier = HID_KEYBOARD_MODIFIER_LEFTCTRL;
		}
		sprintf(cmd_buffer,"AT+KR=A1,01,%02x,00,%02x,00,00,00,00,00",modifier,key);
     62c:	1f 92       	push	r1
     62e:	1f 93       	push	r17
     630:	1f 92       	push	r1
     632:	0f 93       	push	r16
     634:	0f 2e       	mov	r0, r31
     636:	f2 e7       	ldi	r31, 0x72	; 114
     638:	ef 2e       	mov	r14, r31
     63a:	f1 e0       	ldi	r31, 0x01	; 1
     63c:	ff 2e       	mov	r15, r31
     63e:	f0 2d       	mov	r31, r0
     640:	ff 92       	push	r15
     642:	ef 92       	push	r14
     644:	8e 01       	movw	r16, r28
     646:	0f 5f       	subi	r16, 0xFF	; 255
     648:	1f 4f       	sbci	r17, 0xFF	; 255
     64a:	1f 93       	push	r17
     64c:	0f 93       	push	r16
     64e:	0e 94 16 3a 	call	0x742c	; 0x742c <sprintf>
		Bluetooth_Send_CMD(cmd_buffer, false);
     652:	60 e0       	ldi	r22, 0x00	; 0
     654:	c8 01       	movw	r24, r16
     656:	a3 df       	rcall	.-186    	; 0x59e <Bluetooth_Send_CMD>
     658:	8f ec       	ldi	r24, 0xCF	; 207
     65a:	97 e0       	ldi	r25, 0x07	; 7
     65c:	01 97       	sbiw	r24, 0x01	; 1
     65e:	f1 f7       	brne	.-4      	; 0x65c <Bluetooth_Send+0x86>
     660:	00 c0       	rjmp	.+0      	; 0x662 <Bluetooth_Send+0x8c>
     662:	00 00       	nop
			//clear the keystroke
		Delay_MS(1);
		sprintf(cmd_buffer,"AT+KR=A1,01,%02x,00,%02x,00,00,00,00,00",0,0);
     664:	1f 92       	push	r1
     666:	1f 92       	push	r1
     668:	1f 92       	push	r1
     66a:	1f 92       	push	r1
     66c:	ff 92       	push	r15
     66e:	ef 92       	push	r14
     670:	1f 93       	push	r17
     672:	0f 93       	push	r16
     674:	0e 94 16 3a 	call	0x742c	; 0x742c <sprintf>
		Bluetooth_Send_CMD(cmd_buffer, false);
     678:	60 e0       	ldi	r22, 0x00	; 0
     67a:	c8 01       	movw	r24, r16
     67c:	90 df       	rcall	.-224    	; 0x59e <Bluetooth_Send_CMD>
     67e:	0f b6       	in	r0, 0x3f	; 63
     680:	f8 94       	cli
     682:	de bf       	out	0x3e, r29	; 62
     684:	0f be       	out	0x3f, r0	; 63
     686:	cd bf       	out	0x3d, r28	; 61

}
     688:	a4 96       	adiw	r28, 0x24	; 36
     68a:	0f b6       	in	r0, 0x3f	; 63
     68c:	f8 94       	cli
     68e:	de bf       	out	0x3e, r29	; 62
     690:	0f be       	out	0x3f, r0	; 63
     692:	cd bf       	out	0x3d, r28	; 61
     694:	df 91       	pop	r29
     696:	cf 91       	pop	r28
     698:	1f 91       	pop	r17
     69a:	0f 91       	pop	r16
     69c:	ff 90       	pop	r15
     69e:	ef 90       	pop	r14
     6a0:	08 95       	ret

000006a2 <Bluetooth_Init>:
 * reset, enter command mode, set parameters, reset again to lock in parameters.
 * 
 * \return void
 */
void Bluetooth_Init(){
	Bluetooth_Reset(); //reset the module
     6a2:	19 df       	rcall	.-462    	; 0x4d6 <Bluetooth_Reset>
     6a4:	2f ef       	ldi	r18, 0xFF	; 255
     6a6:	89 e6       	ldi	r24, 0x69	; 105
     6a8:	98 e1       	ldi	r25, 0x18	; 24
     6aa:	21 50       	subi	r18, 0x01	; 1
     6ac:	80 40       	sbci	r24, 0x00	; 0
     6ae:	90 40       	sbci	r25, 0x00	; 0
     6b0:	e1 f7       	brne	.-8      	; 0x6aa <Bluetooth_Init+0x8>
     6b2:	00 c0       	rjmp	.+0      	; 0x6b4 <Bluetooth_Init+0x12>
     6b4:	00 00       	nop
	Delay_MS(1000);
	Get_Response(true);
     6b6:	81 e0       	ldi	r24, 0x01	; 1
     6b8:	2a df       	rcall	.-428    	; 0x50e <Get_Response>
	Bluetooth_Send_CMD("AT+BP=00,00", true); //get into proxy mode so that commands work correctly.
     6ba:	61 e0       	ldi	r22, 0x01	; 1
     6bc:	8e eb       	ldi	r24, 0xBE	; 190
     6be:	91 e0       	ldi	r25, 0x01	; 1
     6c0:	6e df       	rcall	.-292    	; 0x59e <Bluetooth_Send_CMD>
     6c2:	2f ef       	ldi	r18, 0xFF	; 255
     6c4:	89 e6       	ldi	r24, 0x69	; 105
     6c6:	98 e1       	ldi	r25, 0x18	; 24
     6c8:	21 50       	subi	r18, 0x01	; 1
     6ca:	80 40       	sbci	r24, 0x00	; 0
     6cc:	90 40       	sbci	r25, 0x00	; 0
     6ce:	e1 f7       	brne	.-8      	; 0x6c8 <Bluetooth_Init+0x26>
     6d0:	00 c0       	rjmp	.+0      	; 0x6d2 <Bluetooth_Init+0x30>
     6d2:	00 00       	nop
     6d4:	08 95       	ret

000006d6 <Bluetooth_Configure>:
	Delay_MS(1000);
	
}

bool Bluetooth_Configure(){
     6d6:	cf 93       	push	r28
	bool success;
	success = true;
	
	while(USB_DeviceState != DEVICE_STATE_Configured){;}
     6d8:	80 91 4e 0a 	lds	r24, 0x0A4E
     6dc:	84 30       	cpi	r24, 0x04	; 4
     6de:	e1 f7       	brne	.-8      	; 0x6d8 <Bluetooth_Configure+0x2>
     6e0:	2f ef       	ldi	r18, 0xFF	; 255
     6e2:	84 e3       	ldi	r24, 0x34	; 52
     6e4:	9c e0       	ldi	r25, 0x0C	; 12
     6e6:	21 50       	subi	r18, 0x01	; 1
     6e8:	80 40       	sbci	r24, 0x00	; 0
     6ea:	90 40       	sbci	r25, 0x00	; 0
     6ec:	e1 f7       	brne	.-8      	; 0x6e6 <Bluetooth_Configure+0x10>
     6ee:	00 c0       	rjmp	.+0      	; 0x6f0 <Bluetooth_Configure+0x1a>
     6f0:	00 00       	nop
	Delay_MS(500);
	#ifdef _DEBUG
		USBSendString("BT DEBUG MODE");
	#endif
	
	Bluetooth_Reset();
     6f2:	f1 de       	rcall	.-542    	; 0x4d6 <Bluetooth_Reset>
     6f4:	2f ef       	ldi	r18, 0xFF	; 255
     6f6:	8d e3       	ldi	r24, 0x3D	; 61
     6f8:	99 e4       	ldi	r25, 0x49	; 73
     6fa:	21 50       	subi	r18, 0x01	; 1
     6fc:	80 40       	sbci	r24, 0x00	; 0
     6fe:	90 40       	sbci	r25, 0x00	; 0
     700:	e1 f7       	brne	.-8      	; 0x6fa <Bluetooth_Configure+0x24>
     702:	00 c0       	rjmp	.+0      	; 0x704 <Bluetooth_Configure+0x2e>
     704:	00 00       	nop
	Delay_MS(3000);
	
	Get_Response(true);
     706:	81 e0       	ldi	r24, 0x01	; 1
     708:	02 df       	rcall	.-508    	; 0x50e <Get_Response>
	
	success &= Bluetooth_Send_CMD("AT+UI=01",true); //enable responses from bluetooth module -- if response is "OK" then bluetooth module is present and responsive.		
     70a:	61 e0       	ldi	r22, 0x01	; 1
     70c:	89 e6       	ldi	r24, 0x69	; 105
     70e:	91 e0       	ldi	r25, 0x01	; 1
     710:	46 df       	rcall	.-372    	; 0x59e <Bluetooth_Send_CMD>
     712:	c8 2f       	mov	r28, r24
	Bluetooth_Send_CMD("AT+NM=USBTYPE",true); //set friendly name
     714:	61 e0       	ldi	r22, 0x01	; 1
     716:	8a ec       	ldi	r24, 0xCA	; 202
     718:	91 e0       	ldi	r25, 0x01	; 1
     71a:	41 df       	rcall	.-382    	; 0x59e <Bluetooth_Send_CMD>
	Bluetooth_Send_CMD("AT+BP=00,00",true); //bypass channel is proxy
     71c:	61 e0       	ldi	r22, 0x01	; 1
     71e:	8e eb       	ldi	r24, 0xBE	; 190
     720:	91 e0       	ldi	r25, 0x01	; 1
     722:	3d df       	rcall	.-390    	; 0x59e <Bluetooth_Send_CMD>
	Bluetooth_Send_CMD("AT+PF=00,01,00,00,00",true);//set hid parameters
     724:	61 e0       	ldi	r22, 0x01	; 1
     726:	88 ed       	ldi	r24, 0xD8	; 216
     728:	91 e0       	ldi	r25, 0x01	; 1
     72a:	39 df       	rcall	.-398    	; 0x59e <Bluetooth_Send_CMD>
     72c:	2f ef       	ldi	r18, 0xFF	; 255
     72e:	84 e3       	ldi	r24, 0x34	; 52
     730:	9c e0       	ldi	r25, 0x0C	; 12
     732:	21 50       	subi	r18, 0x01	; 1
     734:	80 40       	sbci	r24, 0x00	; 0
     736:	90 40       	sbci	r25, 0x00	; 0
     738:	e1 f7       	brne	.-8      	; 0x732 <Bluetooth_Configure+0x5c>
     73a:	00 c0       	rjmp	.+0      	; 0x73c <Bluetooth_Configure+0x66>
     73c:	00 00       	nop
	Delay_MS(500);
	Bluetooth_Send_CMD("AT+FT=00,01,FF,05,01,0258",true); //configure module features (see manual):
     73e:	61 e0       	ldi	r22, 0x01	; 1
     740:	8d ee       	ldi	r24, 0xED	; 237
     742:	91 e0       	ldi	r25, 0x01	; 1
     744:	2c df       	rcall	.-424    	; 0x59e <Bluetooth_Send_CMD>
	set the interval of auto reconnect to 5s.
	configure the discover mode as 01: auto discoverable when empty.
	configure the timeout of discoverable as 600 seconds (10 min).
	This command is only needed when the first time use this Bluetooth module.*/
	
	Bluetooth_Send_CMD("AT+CP",true); //clear paired device list, which forces the device to go into discovery mode.
     746:	61 e0       	ldi	r22, 0x01	; 1
     748:	87 e0       	ldi	r24, 0x07	; 7
     74a:	92 e0       	ldi	r25, 0x02	; 2
     74c:	28 df       	rcall	.-432    	; 0x59e <Bluetooth_Send_CMD>
	
	return success; //if any of the commands failed, success will be false.
}
     74e:	8c 2f       	mov	r24, r28
     750:	cf 91       	pop	r28
     752:	08 95       	ret

00000754 <BluetoothInquire>:
		
}

bool BluetoothInquire(){
	bool success = true;
	success &= Bluetooth_Send_CMD("AT+CP",true); //clear the paired device list.  This makes bluetooth enter discoverable state by default.
     754:	61 e0       	ldi	r22, 0x01	; 1
     756:	87 e0       	ldi	r24, 0x07	; 7
     758:	92 e0       	ldi	r25, 0x02	; 2
     75a:	21 cf       	rjmp	.-446    	; 0x59e <Bluetooth_Send_CMD>
	return success;
}
     75c:	08 95       	ret

0000075e <Bluetooth_Connect>:

bool Bluetooth_Connect(){
     75e:	cf 93       	push	r28
     760:	df 93       	push	r29
     762:	00 d0       	rcall	.+0      	; 0x764 <Bluetooth_Connect+0x6>
     764:	00 d0       	rcall	.+0      	; 0x766 <Bluetooth_Connect+0x8>
     766:	cd b7       	in	r28, 0x3d	; 61
     768:	de b7       	in	r29, 0x3e	; 62
//	if (is_low(BT_CONNECTED)) // if bluetooth is not already connected:
	const char s[4] = "MD=";
     76a:	8d e4       	ldi	r24, 0x4D	; 77
     76c:	94 e4       	ldi	r25, 0x44	; 68
     76e:	ad e3       	ldi	r26, 0x3D	; 61
     770:	b0 e0       	ldi	r27, 0x00	; 0
     772:	89 83       	std	Y+1, r24	; 0x01
     774:	9a 83       	std	Y+2, r25	; 0x02
     776:	ab 83       	std	Y+3, r26	; 0x03
     778:	bc 83       	std	Y+4, r27	; 0x04
	USBSendString("connect\n");
     77a:	8d e0       	ldi	r24, 0x0D	; 13
     77c:	92 e0       	ldi	r25, 0x02	; 2
     77e:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     782:	2f ef       	ldi	r18, 0xFF	; 255
     784:	89 e6       	ldi	r24, 0x69	; 105
     786:	98 e1       	ldi	r25, 0x18	; 24
     788:	21 50       	subi	r18, 0x01	; 1
     78a:	80 40       	sbci	r24, 0x00	; 0
     78c:	90 40       	sbci	r25, 0x00	; 0
     78e:	e1 f7       	brne	.-8      	; 0x788 <Bluetooth_Connect+0x2a>
     790:	00 c0       	rjmp	.+0      	; 0x792 <Bluetooth_Connect+0x34>
     792:	00 00       	nop
	Delay_MS(1000);
	Bluetooth_Send_CMD("AT+UI=01",false); //enable ui
     794:	60 e0       	ldi	r22, 0x00	; 0
     796:	89 e6       	ldi	r24, 0x69	; 105
     798:	91 e0       	ldi	r25, 0x01	; 1
     79a:	01 df       	rcall	.-510    	; 0x59e <Bluetooth_Send_CMD>
	Bluetooth_Send_CMD("AT+MD",true);
     79c:	61 e0       	ldi	r22, 0x01	; 1
     79e:	86 e1       	ldi	r24, 0x16	; 22
     7a0:	92 e0       	ldi	r25, 0x02	; 2
     7a2:	fd de       	rcall	.-518    	; 0x59e <Bluetooth_Send_CMD>
	char* numericalresponse = strtok(response,s); //parse result so we only get the part after MD=
     7a4:	be 01       	movw	r22, r28
     7a6:	6f 5f       	subi	r22, 0xFF	; 255
     7a8:	7f 4f       	sbci	r23, 0xFF	; 255
     7aa:	85 e7       	ldi	r24, 0x75	; 117
     7ac:	96 e0       	ldi	r25, 0x06	; 6
     7ae:	0e 94 cf 39 	call	0x739e	; 0x739e <strtok>
	numericalresponse = strtok(NULL, s); // calling function again accesses everything after the delimiter
     7b2:	be 01       	movw	r22, r28
     7b4:	6f 5f       	subi	r22, 0xFF	; 255
     7b6:	7f 4f       	sbci	r23, 0xFF	; 255
     7b8:	80 e0       	ldi	r24, 0x00	; 0
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	0e 94 cf 39 	call	0x739e	; 0x739e <strtok>
	if (numericalresponse != NULL){ //if there is anything to report.
     7c0:	00 97       	sbiw	r24, 0x00	; 0
     7c2:	41 f0       	breq	.+16     	; 0x7d4 <Bluetooth_Connect+0x76>
		if((numericalresponse[1] == '0')){ //if this is not discoverable mode...
     7c4:	fc 01       	movw	r30, r24
     7c6:	81 81       	ldd	r24, Z+1	; 0x01
     7c8:	80 33       	cpi	r24, 0x30	; 48
     7ca:	21 f4       	brne	.+8      	; 0x7d4 <Bluetooth_Connect+0x76>
			Bluetooth_Send_CMD("AT+CI",true); //then attempt a new connection.
     7cc:	61 e0       	ldi	r22, 0x01	; 1
     7ce:	8c e1       	ldi	r24, 0x1C	; 28
     7d0:	92 e0       	ldi	r25, 0x02	; 2
     7d2:	e5 de       	rcall	.-566    	; 0x59e <Bluetooth_Send_CMD>
		}
	}
	return true;
}
     7d4:	81 e0       	ldi	r24, 0x01	; 1
     7d6:	0f 90       	pop	r0
     7d8:	0f 90       	pop	r0
     7da:	0f 90       	pop	r0
     7dc:	0f 90       	pop	r0
     7de:	df 91       	pop	r29
     7e0:	cf 91       	pop	r28
     7e2:	08 95       	ret

000007e4 <SaveCalibration>:
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     7e4:	82 e2       	ldi	r24, 0x22	; 34
     7e6:	92 e0       	ldi	r25, 0x02	; 2
     7e8:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     7ec:	40 e4       	ldi	r20, 0x40	; 64
     7ee:	50 e0       	ldi	r21, 0x00	; 0
     7f0:	60 e0       	ldi	r22, 0x00	; 0
     7f2:	70 e0       	ldi	r23, 0x00	; 0
     7f4:	8c eb       	ldi	r24, 0xBC	; 188
     7f6:	96 e0       	ldi	r25, 0x06	; 6
     7f8:	0e 94 d4 3c 	call	0x79a8	; 0x79a8 <eeprom_write_block>
     7fc:	40 e4       	ldi	r20, 0x40	; 64
     7fe:	50 e0       	ldi	r21, 0x00	; 0
     800:	60 e4       	ldi	r22, 0x40	; 64
     802:	70 e0       	ldi	r23, 0x00	; 0
     804:	8a e0       	ldi	r24, 0x0A	; 10
     806:	9a e0       	ldi	r25, 0x0A	; 10
     808:	0e 94 d4 3c 	call	0x79a8	; 0x79a8 <eeprom_write_block>
     80c:	40 e4       	ldi	r20, 0x40	; 64
     80e:	50 e0       	ldi	r21, 0x00	; 0
     810:	60 e8       	ldi	r22, 0x80	; 128
     812:	70 e0       	ldi	r23, 0x00	; 0
     814:	87 e0       	ldi	r24, 0x07	; 7
     816:	97 e0       	ldi	r25, 0x07	; 7
     818:	0e 94 d4 3c 	call	0x79a8	; 0x79a8 <eeprom_write_block>
     81c:	40 e4       	ldi	r20, 0x40	; 64
     81e:	50 e0       	ldi	r21, 0x00	; 0
     820:	60 ec       	ldi	r22, 0xC0	; 192
     822:	70 e0       	ldi	r23, 0x00	; 0
     824:	87 ec       	ldi	r24, 0xC7	; 199
     826:	97 e0       	ldi	r25, 0x07	; 7
     828:	0e 94 d4 3c 	call	0x79a8	; 0x79a8 <eeprom_write_block>
     82c:	40 e4       	ldi	r20, 0x40	; 64
     82e:	50 e0       	ldi	r21, 0x00	; 0
     830:	60 e0       	ldi	r22, 0x00	; 0
     832:	71 e0       	ldi	r23, 0x01	; 1
     834:	88 e4       	ldi	r24, 0x48	; 72
     836:	97 e0       	ldi	r25, 0x07	; 7
     838:	0e 94 d4 3c 	call	0x79a8	; 0x79a8 <eeprom_write_block>
     83c:	60 91 ff 06 	lds	r22, 0x06FF
     840:	85 e0       	ldi	r24, 0x05	; 5
     842:	92 e0       	ldi	r25, 0x02	; 2
     844:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
     848:	60 91 06 07 	lds	r22, 0x0706
     84c:	86 e0       	ldi	r24, 0x06	; 6
     84e:	92 e0       	ldi	r25, 0x02	; 2
     850:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
     854:	60 91 b6 06 	lds	r22, 0x06B6
     858:	87 e0       	ldi	r24, 0x07	; 7
     85a:	92 e0       	ldi	r25, 0x02	; 2
     85c:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
     860:	60 91 88 07 	lds	r22, 0x0788
     864:	88 e0       	ldi	r24, 0x08	; 8
     866:	92 e0       	ldi	r25, 0x02	; 2
     868:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
     86c:	60 91 c6 07 	lds	r22, 0x07C6
     870:	89 e0       	ldi	r24, 0x09	; 9
     872:	92 e0       	ldi	r25, 0x02	; 2
     874:	0c 94 c2 3c 	jmp	0x7984	; 0x7984 <eeprom_update_byte>
     878:	08 95       	ret

0000087a <DetectHallSensor>:
     87a:	cf 93       	push	r28
     87c:	df 93       	push	r29
     87e:	10 92 89 07 	sts	0x0789, r1
     882:	0e 94 7c 2d 	call	0x5af8	; 0x5af8 <getHallState>
     886:	d8 2f       	mov	r29, r24
     888:	8e ee       	ldi	r24, 0xEE	; 238
     88a:	91 e0       	ldi	r25, 0x01	; 1
     88c:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     890:	2f ef       	ldi	r18, 0xFF	; 255
     892:	87 ea       	ldi	r24, 0xA7	; 167
     894:	91 e6       	ldi	r25, 0x61	; 97
     896:	21 50       	subi	r18, 0x01	; 1
     898:	80 40       	sbci	r24, 0x00	; 0
     89a:	90 40       	sbci	r25, 0x00	; 0
     89c:	e1 f7       	brne	.-8      	; 0x896 <DetectHallSensor+0x1c>
     89e:	00 c0       	rjmp	.+0      	; 0x8a0 <DetectHallSensor+0x26>
     8a0:	00 00       	nop
     8a2:	0e 94 7c 2d 	call	0x5af8	; 0x5af8 <getHallState>
     8a6:	c8 2f       	mov	r28, r24
     8a8:	d8 13       	cpse	r29, r24
     8aa:	07 c0       	rjmp	.+14     	; 0x8ba <DetectHallSensor+0x40>
     8ac:	8d eb       	ldi	r24, 0xBD	; 189
     8ae:	91 e0       	ldi	r25, 0x01	; 1
     8b0:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     8b4:	10 92 89 07 	sts	0x0789, r1
     8b8:	23 c0       	rjmp	.+70     	; 0x900 <DetectHallSensor+0x86>
     8ba:	8d e2       	ldi	r24, 0x2D	; 45
     8bc:	92 e0       	ldi	r25, 0x02	; 2
     8be:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     8c2:	81 e0       	ldi	r24, 0x01	; 1
     8c4:	80 93 89 07 	sts	0x0789, r24
     8c8:	c0 93 05 07 	sts	0x0705, r28
     8cc:	84 e4       	ldi	r24, 0x44	; 68
     8ce:	92 e0       	ldi	r25, 0x02	; 2
     8d0:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     8d4:	83 e6       	ldi	r24, 0x63	; 99
     8d6:	90 e0       	ldi	r25, 0x00	; 0
     8d8:	22 e0       	ldi	r18, 0x02	; 2
     8da:	7c 9b       	sbis	0x0f, 4	; 15
     8dc:	20 93 89 07 	sts	0x0789, r18
     8e0:	ef e5       	ldi	r30, 0x5F	; 95
     8e2:	fa ee       	ldi	r31, 0xEA	; 234
     8e4:	31 97       	sbiw	r30, 0x01	; 1
     8e6:	f1 f7       	brne	.-4      	; 0x8e4 <DetectHallSensor+0x6a>
     8e8:	00 c0       	rjmp	.+0      	; 0x8ea <DetectHallSensor+0x70>
     8ea:	00 00       	nop
     8ec:	01 97       	sbiw	r24, 0x01	; 1
     8ee:	a9 f7       	brne	.-22     	; 0x8da <DetectHallSensor+0x60>
     8f0:	80 91 89 07 	lds	r24, 0x0789
     8f4:	82 30       	cpi	r24, 0x02	; 2
     8f6:	21 f4       	brne	.+8      	; 0x900 <DetectHallSensor+0x86>
     8f8:	82 e7       	ldi	r24, 0x72	; 114
     8fa:	92 e0       	ldi	r25, 0x02	; 2
     8fc:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     900:	7e 99       	sbic	0x0f, 6	; 15
     902:	03 c0       	rjmp	.+6      	; 0x90a <DetectHallSensor+0x90>
     904:	81 e0       	ldi	r24, 0x01	; 1
     906:	80 93 89 07 	sts	0x0789, r24
     90a:	60 91 89 07 	lds	r22, 0x0789
     90e:	83 e0       	ldi	r24, 0x03	; 3
     910:	92 e0       	ldi	r25, 0x02	; 2
     912:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
     916:	60 91 05 07 	lds	r22, 0x0705
     91a:	84 e0       	ldi	r24, 0x04	; 4
     91c:	92 e0       	ldi	r25, 0x02	; 2
     91e:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
     922:	81 e0       	ldi	r24, 0x01	; 1
     924:	90 91 89 07 	lds	r25, 0x0789
     928:	91 11       	cpse	r25, r1
     92a:	01 c0       	rjmp	.+2      	; 0x92e <DetectHallSensor+0xb4>
     92c:	80 e0       	ldi	r24, 0x00	; 0
     92e:	df 91       	pop	r29
     930:	cf 91       	pop	r28
     932:	08 95       	ret

00000934 <WaitForKeypress>:
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	81 ee       	ldi	r24, 0xE1	; 225
     938:	94 e0       	ldi	r25, 0x04	; 4
     93a:	21 50       	subi	r18, 0x01	; 1
     93c:	80 40       	sbci	r24, 0x00	; 0
     93e:	90 40       	sbci	r25, 0x00	; 0
     940:	e1 f7       	brne	.-8      	; 0x93a <WaitForKeypress+0x6>
     942:	00 c0       	rjmp	.+0      	; 0x944 <WaitForKeypress+0x10>
     944:	00 00       	nop
     946:	0e 94 a9 2b 	call	0x5752	; 0x5752 <GetKeySimple>
     94a:	90 e0       	ldi	r25, 0x00	; 0
     94c:	00 97       	sbiw	r24, 0x00	; 0
     94e:	d9 f3       	breq	.-10     	; 0x946 <WaitForKeypress+0x12>
     950:	08 95       	ret

00000952 <TeachHIDKey>:
     952:	cf 93       	push	r28
     954:	df 93       	push	r29
     956:	eb 01       	movw	r28, r22
     958:	42 30       	cpi	r20, 0x02	; 2
     95a:	81 f4       	brne	.+32     	; 0x97c <TeachHIDKey+0x2a>
     95c:	fb 01       	movw	r30, r22
     95e:	e9 5f       	subi	r30, 0xF9	; 249
     960:	f8 4f       	sbci	r31, 0xF8	; 248
     962:	80 83       	st	Z, r24
     964:	8b e8       	ldi	r24, 0x8B	; 139
     966:	92 e0       	ldi	r25, 0x02	; 2
     968:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     96c:	62 e0       	ldi	r22, 0x02	; 2
     96e:	8e e2       	ldi	r24, 0x2E	; 46
     970:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     974:	8c 2f       	mov	r24, r28
     976:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
     97a:	19 c0       	rjmp	.+50     	; 0x9ae <TeachHIDKey+0x5c>
     97c:	44 30       	cpi	r20, 0x04	; 4
     97e:	81 f4       	brne	.+32     	; 0x9a0 <TeachHIDKey+0x4e>
     980:	fb 01       	movw	r30, r22
     982:	e6 5f       	subi	r30, 0xF6	; 246
     984:	f5 4f       	sbci	r31, 0xF5	; 245
     986:	80 83       	st	Z, r24
     988:	81 e9       	ldi	r24, 0x91	; 145
     98a:	92 e0       	ldi	r25, 0x02	; 2
     98c:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     990:	62 e0       	ldi	r22, 0x02	; 2
     992:	8e e2       	ldi	r24, 0x2E	; 46
     994:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     998:	8c 2f       	mov	r24, r28
     99a:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
     99e:	07 c0       	rjmp	.+14     	; 0x9ae <TeachHIDKey+0x5c>
     9a0:	fb 01       	movw	r30, r22
     9a2:	e4 54       	subi	r30, 0x44	; 68
     9a4:	f9 4f       	sbci	r31, 0xF9	; 249
     9a6:	80 83       	st	Z, r24
     9a8:	86 2f       	mov	r24, r22
     9aa:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
     9ae:	2f ef       	ldi	r18, 0xFF	; 255
     9b0:	84 e3       	ldi	r24, 0x34	; 52
     9b2:	9c e0       	ldi	r25, 0x0C	; 12
     9b4:	21 50       	subi	r18, 0x01	; 1
     9b6:	80 40       	sbci	r24, 0x00	; 0
     9b8:	90 40       	sbci	r25, 0x00	; 0
     9ba:	e1 f7       	brne	.-8      	; 0x9b4 <TeachHIDKey+0x62>
     9bc:	00 c0       	rjmp	.+0      	; 0x9be <TeachHIDKey+0x6c>
     9be:	00 00       	nop
     9c0:	df 91       	pop	r29
     9c2:	cf 91       	pop	r28
     9c4:	08 95       	ret

000009c6 <CalibrateReeds>:
     9c6:	1f 93       	push	r17
     9c8:	cf 93       	push	r28
     9ca:	df 93       	push	r29
     9cc:	84 e2       	ldi	r24, 0x24	; 36
     9ce:	92 e0       	ldi	r25, 0x02	; 2
     9d0:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     9d4:	60 e0       	ldi	r22, 0x00	; 0
     9d6:	8c e2       	ldi	r24, 0x2C	; 44
     9d8:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     9dc:	ab df       	rcall	.-170    	; 0x934 <WaitForKeypress>
     9de:	ec 01       	movw	r28, r24
     9e0:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
     9e4:	18 2f       	mov	r17, r24
     9e6:	dd 27       	eor	r29, r29
     9e8:	48 2f       	mov	r20, r24
     9ea:	be 01       	movw	r22, r28
     9ec:	8a e2       	ldi	r24, 0x2A	; 42
     9ee:	b1 df       	rcall	.-158    	; 0x952 <TeachHIDKey>
     9f0:	12 fd       	sbrc	r17, 2
     9f2:	04 c0       	rjmp	.+8      	; 0x9fc <CalibrateReeds+0x36>
     9f4:	c9 53       	subi	r28, 0x39	; 57
     9f6:	d8 4f       	sbci	r29, 0xF8	; 248
     9f8:	88 e0       	ldi	r24, 0x08	; 8
     9fa:	88 83       	st	Y, r24
     9fc:	60 e0       	ldi	r22, 0x00	; 0
     9fe:	88 e2       	ldi	r24, 0x28	; 40
     a00:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     a04:	84 e9       	ldi	r24, 0x94	; 148
     a06:	92 e0       	ldi	r25, 0x02	; 2
     a08:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     a0c:	60 e0       	ldi	r22, 0x00	; 0
     a0e:	8c e2       	ldi	r24, 0x2C	; 44
     a10:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     a14:	8f df       	rcall	.-226    	; 0x934 <WaitForKeypress>
     a16:	ec 01       	movw	r28, r24
     a18:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
     a1c:	be 01       	movw	r22, r28
     a1e:	77 27       	eor	r23, r23
     a20:	48 2f       	mov	r20, r24
     a22:	89 e2       	ldi	r24, 0x29	; 41
     a24:	96 df       	rcall	.-212    	; 0x952 <TeachHIDKey>
     a26:	60 e0       	ldi	r22, 0x00	; 0
     a28:	88 e2       	ldi	r24, 0x28	; 40
     a2a:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     a2e:	88 e9       	ldi	r24, 0x98	; 152
     a30:	92 e0       	ldi	r25, 0x02	; 2
     a32:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	8c e2       	ldi	r24, 0x2C	; 44
     a3a:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     a3e:	7a df       	rcall	.-268    	; 0x934 <WaitForKeypress>
     a40:	ec 01       	movw	r28, r24
     a42:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
     a46:	18 2f       	mov	r17, r24
     a48:	dd 27       	eor	r29, r29
     a4a:	48 2f       	mov	r20, r24
     a4c:	be 01       	movw	r22, r28
     a4e:	8b e2       	ldi	r24, 0x2B	; 43
     a50:	80 df       	rcall	.-256    	; 0x952 <TeachHIDKey>
     a52:	12 fd       	sbrc	r17, 2
     a54:	09 c0       	rjmp	.+18     	; 0xa68 <CalibrateReeds+0xa2>
     a56:	fe 01       	movw	r30, r28
     a58:	e9 53       	subi	r30, 0x39	; 57
     a5a:	f8 4f       	sbci	r31, 0xF8	; 248
     a5c:	89 e0       	ldi	r24, 0x09	; 9
     a5e:	80 83       	st	Z, r24
     a60:	c8 5b       	subi	r28, 0xB8	; 184
     a62:	d8 4f       	sbci	r29, 0xF8	; 248
     a64:	84 e7       	ldi	r24, 0x74	; 116
     a66:	88 83       	st	Y, r24
     a68:	60 e0       	ldi	r22, 0x00	; 0
     a6a:	88 e2       	ldi	r24, 0x28	; 40
     a6c:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     a70:	83 e4       	ldi	r24, 0x43	; 67
     a72:	92 e0       	ldi	r25, 0x02	; 2
     a74:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     a78:	60 e0       	ldi	r22, 0x00	; 0
     a7a:	8c e2       	ldi	r24, 0x2C	; 44
     a7c:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     a80:	59 df       	rcall	.-334    	; 0x934 <WaitForKeypress>
     a82:	ec 01       	movw	r28, r24
     a84:	dd 27       	eor	r29, r29
     a86:	40 e0       	ldi	r20, 0x00	; 0
     a88:	be 01       	movw	r22, r28
     a8a:	88 e2       	ldi	r24, 0x28	; 40
     a8c:	62 df       	rcall	.-316    	; 0x952 <TeachHIDKey>
     a8e:	c9 53       	subi	r28, 0x39	; 57
     a90:	d8 4f       	sbci	r29, 0xF8	; 248
     a92:	8d e0       	ldi	r24, 0x0D	; 13
     a94:	88 83       	st	Y, r24
     a96:	60 e0       	ldi	r22, 0x00	; 0
     a98:	88 e2       	ldi	r24, 0x28	; 40
     a9a:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     a9e:	83 e3       	ldi	r24, 0x33	; 51
     aa0:	92 e0       	ldi	r25, 0x02	; 2
     aa2:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     aa6:	60 e0       	ldi	r22, 0x00	; 0
     aa8:	8c e2       	ldi	r24, 0x2C	; 44
     aaa:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     aae:	84 e7       	ldi	r24, 0x74	; 116
     ab0:	90 e0       	ldi	r25, 0x00	; 0
     ab2:	40 df       	rcall	.-384    	; 0x934 <WaitForKeypress>
     ab4:	bc 01       	movw	r22, r24
     ab6:	77 27       	eor	r23, r23
     ab8:	40 e0       	ldi	r20, 0x00	; 0
     aba:	88 e2       	ldi	r24, 0x28	; 40
     abc:	4a df       	rcall	.-364    	; 0x952 <TeachHIDKey>
     abe:	60 e0       	ldi	r22, 0x00	; 0
     ac0:	88 e2       	ldi	r24, 0x28	; 40
     ac2:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     ac6:	8e e2       	ldi	r24, 0x2E	; 46
     ac8:	92 e0       	ldi	r25, 0x02	; 2
     aca:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     ace:	60 e0       	ldi	r22, 0x00	; 0
     ad0:	8c e2       	ldi	r24, 0x2C	; 44
     ad2:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     ad6:	2e df       	rcall	.-420    	; 0x934 <WaitForKeypress>
     ad8:	bc 01       	movw	r22, r24
     ada:	77 27       	eor	r23, r23
     adc:	40 e0       	ldi	r20, 0x00	; 0
     ade:	84 e7       	ldi	r24, 0x74	; 116
     ae0:	38 df       	rcall	.-400    	; 0x952 <TeachHIDKey>
     ae2:	60 e0       	ldi	r22, 0x00	; 0
     ae4:	88 e2       	ldi	r24, 0x28	; 40
     ae6:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     aea:	89 e4       	ldi	r24, 0x49	; 73
     aec:	92 e0       	ldi	r25, 0x02	; 2
     aee:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     af2:	60 e0       	ldi	r22, 0x00	; 0
     af4:	8c e2       	ldi	r24, 0x2C	; 44
     af6:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     afa:	1c df       	rcall	.-456    	; 0x934 <WaitForKeypress>
     afc:	ec 01       	movw	r28, r24
     afe:	dd 27       	eor	r29, r29
     b00:	40 e0       	ldi	r20, 0x00	; 0
     b02:	be 01       	movw	r22, r28
     b04:	8c e2       	ldi	r24, 0x2C	; 44
     b06:	25 df       	rcall	.-438    	; 0x952 <TeachHIDKey>
     b08:	c9 53       	subi	r28, 0x39	; 57
     b0a:	d8 4f       	sbci	r29, 0xF8	; 248
     b0c:	80 e2       	ldi	r24, 0x20	; 32
     b0e:	88 83       	st	Y, r24
     b10:	60 e0       	ldi	r22, 0x00	; 0
     b12:	88 e2       	ldi	r24, 0x28	; 40
     b14:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     b18:	df 91       	pop	r29
     b1a:	cf 91       	pop	r28
     b1c:	1f 91       	pop	r17
     b1e:	08 95       	ret

00000b20 <QuickCalibrate>:
     b20:	80 91 4e 0a 	lds	r24, 0x0A4E
     b24:	84 30       	cpi	r24, 0x04	; 4
     b26:	e1 f7       	brne	.-8      	; 0xb20 <QuickCalibrate>
     b28:	2f ef       	ldi	r18, 0xFF	; 255
     b2a:	89 e6       	ldi	r24, 0x69	; 105
     b2c:	98 e1       	ldi	r25, 0x18	; 24
     b2e:	21 50       	subi	r18, 0x01	; 1
     b30:	80 40       	sbci	r24, 0x00	; 0
     b32:	90 40       	sbci	r25, 0x00	; 0
     b34:	e1 f7       	brne	.-8      	; 0xb2e <QuickCalibrate+0xe>
     b36:	00 c0       	rjmp	.+0      	; 0xb38 <QuickCalibrate+0x18>
     b38:	00 00       	nop
     b3a:	82 e5       	ldi	r24, 0x52	; 82
     b3c:	92 e0       	ldi	r25, 0x02	; 2
     b3e:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     b42:	99 b1       	in	r25, 0x09	; 9
     b44:	81 e0       	ldi	r24, 0x01	; 1
     b46:	92 95       	swap	r25
     b48:	91 70       	andi	r25, 0x01	; 1
     b4a:	98 27       	eor	r25, r24
     b4c:	90 93 06 07 	sts	0x0706, r25
     b50:	99 b1       	in	r25, 0x09	; 9
     b52:	96 fb       	bst	r25, 6
     b54:	99 27       	eor	r25, r25
     b56:	90 f9       	bld	r25, 0
     b58:	98 27       	eor	r25, r24
     b5a:	90 93 b6 06 	sts	0x06B6, r25
     b5e:	99 b1       	in	r25, 0x09	; 9
     b60:	90 95       	com	r25
     b62:	99 1f       	adc	r25, r25
     b64:	99 27       	eor	r25, r25
     b66:	99 1f       	adc	r25, r25
     b68:	90 93 88 07 	sts	0x0788, r25
     b6c:	93 b1       	in	r25, 0x03	; 3
     b6e:	92 95       	swap	r25
     b70:	91 70       	andi	r25, 0x01	; 1
     b72:	89 27       	eor	r24, r25
     b74:	80 93 c6 07 	sts	0x07C6, r24
     b78:	80 de       	rcall	.-768    	; 0x87a <DetectHallSensor>
     b7a:	81 ec       	ldi	r24, 0xC1	; 193
     b7c:	92 e0       	ldi	r25, 0x02	; 2
     b7e:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     b82:	8b e8       	ldi	r24, 0x8B	; 139
     b84:	92 e0       	ldi	r25, 0x02	; 2
     b86:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     b8a:	10 92 ff 06 	sts	0x06FF, r1
     b8e:	60 e0       	ldi	r22, 0x00	; 0
     b90:	8c e2       	ldi	r24, 0x2C	; 44
     b92:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     b96:	ce de       	rcall	.-612    	; 0x934 <WaitForKeypress>
     b98:	9f ef       	ldi	r25, 0xFF	; 255
     b9a:	98 0f       	add	r25, r24
     b9c:	98 30       	cpi	r25, 0x08	; 8
     b9e:	28 f4       	brcc	.+10     	; 0xbaa <QuickCalibrate+0x8a>
     ba0:	80 93 ff 06 	sts	0x06FF, r24
     ba4:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
     ba8:	04 c0       	rjmp	.+8      	; 0xbb2 <QuickCalibrate+0x92>
     baa:	8b e9       	ldi	r24, 0x9B	; 155
     bac:	92 e0       	ldi	r25, 0x02	; 2
     bae:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     bb2:	60 e0       	ldi	r22, 0x00	; 0
     bb4:	88 e2       	ldi	r24, 0x28	; 40
     bb6:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     bba:	05 df       	rcall	.-502    	; 0x9c6 <CalibrateReeds>
     bbc:	13 de       	rcall	.-986    	; 0x7e4 <SaveCalibration>
     bbe:	8c ea       	ldi	r24, 0xAC	; 172
     bc0:	90 e0       	ldi	r25, 0x00	; 0
     bc2:	0c 94 3f 2a 	jmp	0x547e	; 0x547e <USBSendPROGString>
     bc6:	08 95       	ret

00000bc8 <Calibrate>:
     bc8:	4f 92       	push	r4
     bca:	5f 92       	push	r5
     bcc:	6f 92       	push	r6
     bce:	7f 92       	push	r7
     bd0:	8f 92       	push	r8
     bd2:	9f 92       	push	r9
     bd4:	af 92       	push	r10
     bd6:	bf 92       	push	r11
     bd8:	cf 92       	push	r12
     bda:	df 92       	push	r13
     bdc:	ef 92       	push	r14
     bde:	ff 92       	push	r15
     be0:	0f 93       	push	r16
     be2:	1f 93       	push	r17
     be4:	cf 93       	push	r28
     be6:	df 93       	push	r29
     be8:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <ClearKeyCodeTables>
     bec:	c0 91 4e 0a 	lds	r28, 0x0A4E
     bf0:	c4 30       	cpi	r28, 0x04	; 4
     bf2:	e1 f7       	brne	.-8      	; 0xbec <Calibrate+0x24>
     bf4:	2f ef       	ldi	r18, 0xFF	; 255
     bf6:	89 e6       	ldi	r24, 0x69	; 105
     bf8:	98 e1       	ldi	r25, 0x18	; 24
     bfa:	21 50       	subi	r18, 0x01	; 1
     bfc:	80 40       	sbci	r24, 0x00	; 0
     bfe:	90 40       	sbci	r25, 0x00	; 0
     c00:	e1 f7       	brne	.-8      	; 0xbfa <Calibrate+0x32>
     c02:	00 c0       	rjmp	.+0      	; 0xc04 <Calibrate+0x3c>
     c04:	00 00       	nop
     c06:	8d e9       	ldi	r24, 0x9D	; 157
     c08:	93 e0       	ldi	r25, 0x03	; 3
     c0a:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     c0e:	89 e8       	ldi	r24, 0x89	; 137
     c10:	93 e0       	ldi	r25, 0x03	; 3
     c12:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     c16:	60 e0       	ldi	r22, 0x00	; 0
     c18:	88 e2       	ldi	r24, 0x28	; 40
     c1a:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     c1e:	8d e0       	ldi	r24, 0x0D	; 13
     c20:	92 e0       	ldi	r25, 0x02	; 2
     c22:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
     c26:	d8 2f       	mov	r29, r24
     c28:	87 e7       	ldi	r24, 0x77	; 119
     c2a:	93 e0       	ldi	r25, 0x03	; 3
     c2c:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     c30:	d2 30       	cpi	r29, 0x02	; 2
     c32:	99 f0       	breq	.+38     	; 0xc5a <Calibrate+0x92>
     c34:	18 f4       	brcc	.+6      	; 0xc3c <Calibrate+0x74>
     c36:	d1 30       	cpi	r29, 0x01	; 1
     c38:	31 f0       	breq	.+12     	; 0xc46 <Calibrate+0x7e>
     c3a:	19 c0       	rjmp	.+50     	; 0xc6e <Calibrate+0xa6>
     c3c:	d9 30       	cpi	r29, 0x09	; 9
     c3e:	41 f0       	breq	.+16     	; 0xc50 <Calibrate+0x88>
     c40:	dd 30       	cpi	r29, 0x0D	; 13
     c42:	81 f0       	breq	.+32     	; 0xc64 <Calibrate+0x9c>
     c44:	14 c0       	rjmp	.+40     	; 0xc6e <Calibrate+0xa6>
     c46:	89 e1       	ldi	r24, 0x19	; 25
     c48:	93 e0       	ldi	r25, 0x03	; 3
     c4a:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     c4e:	13 c0       	rjmp	.+38     	; 0xc76 <Calibrate+0xae>
     c50:	8e e5       	ldi	r24, 0x5E	; 94
     c52:	93 e0       	ldi	r25, 0x03	; 3
     c54:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     c58:	0e c0       	rjmp	.+28     	; 0xc76 <Calibrate+0xae>
     c5a:	83 e0       	ldi	r24, 0x03	; 3
     c5c:	93 e0       	ldi	r25, 0x03	; 3
     c5e:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     c62:	09 c0       	rjmp	.+18     	; 0xc76 <Calibrate+0xae>
     c64:	88 e3       	ldi	r24, 0x38	; 56
     c66:	93 e0       	ldi	r25, 0x03	; 3
     c68:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     c6c:	04 c0       	rjmp	.+8      	; 0xc76 <Calibrate+0xae>
     c6e:	8c e9       	ldi	r24, 0x9C	; 156
     c70:	92 e0       	ldi	r25, 0x02	; 2
     c72:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     c76:	83 ef       	ldi	r24, 0xF3	; 243
     c78:	92 e0       	ldi	r25, 0x02	; 2
     c7a:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     c7e:	99 b1       	in	r25, 0x09	; 9
     c80:	81 e0       	ldi	r24, 0x01	; 1
     c82:	92 95       	swap	r25
     c84:	91 70       	andi	r25, 0x01	; 1
     c86:	98 27       	eor	r25, r24
     c88:	90 93 06 07 	sts	0x0706, r25
     c8c:	99 b1       	in	r25, 0x09	; 9
     c8e:	96 fb       	bst	r25, 6
     c90:	99 27       	eor	r25, r25
     c92:	90 f9       	bld	r25, 0
     c94:	98 27       	eor	r25, r24
     c96:	90 93 b6 06 	sts	0x06B6, r25
     c9a:	99 b1       	in	r25, 0x09	; 9
     c9c:	90 95       	com	r25
     c9e:	99 1f       	adc	r25, r25
     ca0:	99 27       	eor	r25, r25
     ca2:	99 1f       	adc	r25, r25
     ca4:	90 93 88 07 	sts	0x0788, r25
     ca8:	93 b1       	in	r25, 0x03	; 3
     caa:	92 95       	swap	r25
     cac:	91 70       	andi	r25, 0x01	; 1
     cae:	89 27       	eor	r24, r25
     cb0:	80 93 c6 07 	sts	0x07C6, r24
     cb4:	e2 dd       	rcall	.-1084   	; 0x87a <DetectHallSensor>
     cb6:	7d 99       	sbic	0x0f, 5	; 15
     cb8:	18 c0       	rjmp	.+48     	; 0xcea <Calibrate+0x122>
     cba:	80 91 b7 06 	lds	r24, 0x06B7
     cbe:	88 23       	and	r24, r24
     cc0:	39 f0       	breq	.+14     	; 0xcd0 <Calibrate+0x108>
     cc2:	10 92 b7 06 	sts	0x06B7, r1
     cc6:	8d e6       	ldi	r24, 0x6D	; 109
     cc8:	92 e0       	ldi	r25, 0x02	; 2
     cca:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     cce:	07 c0       	rjmp	.+14     	; 0xcde <Calibrate+0x116>
     cd0:	81 e0       	ldi	r24, 0x01	; 1
     cd2:	80 93 b7 06 	sts	0x06B7, r24
     cd6:	85 e8       	ldi	r24, 0x85	; 133
     cd8:	92 e0       	ldi	r25, 0x02	; 2
     cda:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     cde:	60 91 b7 06 	lds	r22, 0x06B7
     ce2:	8f e0       	ldi	r24, 0x0F	; 15
     ce4:	92 e0       	ldi	r25, 0x02	; 2
     ce6:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
     cea:	81 ec       	ldi	r24, 0xC1	; 193
     cec:	92 e0       	ldi	r25, 0x02	; 2
     cee:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     cf2:	d5 e0       	ldi	r29, 0x05	; 5
     cf4:	0f 2e       	mov	r0, r31
     cf6:	fe e1       	ldi	r31, 0x1E	; 30
     cf8:	ef 2e       	mov	r14, r31
     cfa:	f0 2d       	mov	r31, r0
     cfc:	02 c0       	rjmp	.+4      	; 0xd02 <Calibrate+0x13a>
     cfe:	cf 5f       	subi	r28, 0xFF	; 255
     d00:	df 5f       	subi	r29, 0xFF	; 255
     d02:	62 e0       	ldi	r22, 0x02	; 2
     d04:	8c 2f       	mov	r24, r28
     d06:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     d0a:	60 e0       	ldi	r22, 0x00	; 0
     d0c:	8c e2       	ldi	r24, 0x2C	; 44
     d0e:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     d12:	10 de       	rcall	.-992    	; 0x934 <WaitForKeypress>
     d14:	8c 01       	movw	r16, r24
     d16:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
     d1a:	f8 2e       	mov	r15, r24
     d1c:	11 27       	eor	r17, r17
     d1e:	48 2f       	mov	r20, r24
     d20:	4d 7f       	andi	r20, 0xFD	; 253
     d22:	b8 01       	movw	r22, r16
     d24:	8c 2f       	mov	r24, r28
     d26:	15 de       	rcall	.-982    	; 0x952 <TeachHIDKey>
     d28:	cf 30       	cpi	r28, 0x0F	; 15
     d2a:	39 f4       	brne	.+14     	; 0xd3a <Calibrate+0x172>
     d2c:	f8 01       	movw	r30, r16
     d2e:	e6 5f       	subi	r30, 0xF6	; 246
     d30:	f5 4f       	sbci	r31, 0xF5	; 245
     d32:	e0 82       	st	Z, r14
     d34:	f2 fc       	sbrc	r15, 2
     d36:	e1 c1       	rjmp	.+962    	; 0x10fa <Calibrate+0x532>
     d38:	02 c0       	rjmp	.+4      	; 0xd3e <Calibrate+0x176>
     d3a:	f2 fc       	sbrc	r15, 2
     d3c:	0c c0       	rjmp	.+24     	; 0xd56 <Calibrate+0x18e>
     d3e:	f8 01       	movw	r30, r16
     d40:	e8 5b       	subi	r30, 0xB8	; 184
     d42:	f8 4f       	sbci	r31, 0xF8	; 248
     d44:	8c e3       	ldi	r24, 0x3C	; 60
     d46:	8d 0f       	add	r24, r29
     d48:	80 83       	st	Z, r24
     d4a:	f8 01       	movw	r30, r16
     d4c:	e9 53       	subi	r30, 0x39	; 57
     d4e:	f8 4f       	sbci	r31, 0xF8	; 248
     d50:	8c e5       	ldi	r24, 0x5C	; 92
     d52:	8d 0f       	add	r24, r29
     d54:	80 83       	st	Z, r24
     d56:	60 e0       	ldi	r22, 0x00	; 0
     d58:	88 e2       	ldi	r24, 0x28	; 40
     d5a:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     d5e:	de 31       	cpi	r29, 0x1E	; 30
     d60:	70 f2       	brcs	.-100    	; 0xcfe <Calibrate+0x136>
     d62:	0f 2e       	mov	r0, r31
     d64:	fc ec       	ldi	r31, 0xCC	; 204
     d66:	cf 2e       	mov	r12, r31
     d68:	f2 e0       	ldi	r31, 0x02	; 2
     d6a:	df 2e       	mov	r13, r31
     d6c:	f0 2d       	mov	r31, r0
     d6e:	00 e0       	ldi	r16, 0x00	; 0
     d70:	10 e0       	ldi	r17, 0x00	; 0
     d72:	f6 01       	movw	r30, r12
     d74:	e1 90       	ld	r14, Z+
     d76:	6f 01       	movw	r12, r30
     d78:	60 e0       	ldi	r22, 0x00	; 0
     d7a:	8e 2d       	mov	r24, r14
     d7c:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     d80:	60 e0       	ldi	r22, 0x00	; 0
     d82:	8c e2       	ldi	r24, 0x2C	; 44
     d84:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     d88:	d5 dd       	rcall	.-1110   	; 0x934 <WaitForKeypress>
     d8a:	ec 01       	movw	r28, r24
     d8c:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
     d90:	f8 2e       	mov	r15, r24
     d92:	dd 27       	eor	r29, r29
     d94:	48 2f       	mov	r20, r24
     d96:	4d 7f       	andi	r20, 0xFD	; 253
     d98:	be 01       	movw	r22, r28
     d9a:	8e 2d       	mov	r24, r14
     d9c:	da dd       	rcall	.-1100   	; 0x952 <TeachHIDKey>
     d9e:	f2 fc       	sbrc	r15, 2
     da0:	15 c0       	rjmp	.+42     	; 0xdcc <Calibrate+0x204>
     da2:	fe 01       	movw	r30, r28
     da4:	e9 53       	subi	r30, 0x39	; 57
     da6:	f8 4f       	sbci	r31, 0xF8	; 248
     da8:	d8 01       	movw	r26, r16
     daa:	ae 53       	subi	r26, 0x3E	; 62
     dac:	bd 4f       	sbci	r27, 0xFD	; 253
     dae:	8c 91       	ld	r24, X
     db0:	80 83       	st	Z, r24
     db2:	fe 01       	movw	r30, r28
     db4:	e8 5b       	subi	r30, 0xB8	; 184
     db6:	f8 4f       	sbci	r31, 0xF8	; 248
     db8:	d8 01       	movw	r26, r16
     dba:	a8 54       	subi	r26, 0x48	; 72
     dbc:	bd 4f       	sbci	r27, 0xFD	; 253
     dbe:	8c 91       	ld	r24, X
     dc0:	80 83       	st	Z, r24
     dc2:	c6 5f       	subi	r28, 0xF6	; 246
     dc4:	d5 4f       	sbci	r29, 0xF5	; 245
     dc6:	8a e3       	ldi	r24, 0x3A	; 58
     dc8:	80 0f       	add	r24, r16
     dca:	88 83       	st	Y, r24
     dcc:	60 e0       	ldi	r22, 0x00	; 0
     dce:	88 e2       	ldi	r24, 0x28	; 40
     dd0:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     dd4:	0f 5f       	subi	r16, 0xFF	; 255
     dd6:	1f 4f       	sbci	r17, 0xFF	; 255
     dd8:	0a 30       	cpi	r16, 0x0A	; 10
     dda:	11 05       	cpc	r17, r1
     ddc:	51 f6       	brne	.-108    	; 0xd72 <Calibrate+0x1aa>
     dde:	84 ea       	ldi	r24, 0xA4	; 164
     de0:	92 e0       	ldi	r25, 0x02	; 2
     de2:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     de6:	60 e0       	ldi	r22, 0x00	; 0
     de8:	8c e2       	ldi	r24, 0x2C	; 44
     dea:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     dee:	a2 dd       	rcall	.-1212   	; 0x934 <WaitForKeypress>
     df0:	ec 01       	movw	r28, r24
     df2:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
     df6:	be 01       	movw	r22, r28
     df8:	77 27       	eor	r23, r23
     dfa:	48 2f       	mov	r20, r24
     dfc:	8a e3       	ldi	r24, 0x3A	; 58
     dfe:	a9 dd       	rcall	.-1198   	; 0x952 <TeachHIDKey>
     e00:	60 e0       	ldi	r22, 0x00	; 0
     e02:	88 e2       	ldi	r24, 0x28	; 40
     e04:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     e08:	87 ea       	ldi	r24, 0xA7	; 167
     e0a:	92 e0       	ldi	r25, 0x02	; 2
     e0c:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     e10:	60 e0       	ldi	r22, 0x00	; 0
     e12:	8c e2       	ldi	r24, 0x2C	; 44
     e14:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     e18:	8d dd       	rcall	.-1254   	; 0x934 <WaitForKeypress>
     e1a:	ec 01       	movw	r28, r24
     e1c:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
     e20:	be 01       	movw	r22, r28
     e22:	77 27       	eor	r23, r23
     e24:	48 2f       	mov	r20, r24
     e26:	84 e4       	ldi	r24, 0x44	; 68
     e28:	94 dd       	rcall	.-1240   	; 0x952 <TeachHIDKey>
     e2a:	60 e0       	ldi	r22, 0x00	; 0
     e2c:	88 e2       	ldi	r24, 0x28	; 40
     e2e:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     e32:	8b ea       	ldi	r24, 0xAB	; 171
     e34:	92 e0       	ldi	r25, 0x02	; 2
     e36:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     e3a:	60 e0       	ldi	r22, 0x00	; 0
     e3c:	8c e2       	ldi	r24, 0x2C	; 44
     e3e:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     e42:	78 dd       	rcall	.-1296   	; 0x934 <WaitForKeypress>
     e44:	ec 01       	movw	r28, r24
     e46:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
     e4a:	be 01       	movw	r22, r28
     e4c:	77 27       	eor	r23, r23
     e4e:	48 2f       	mov	r20, r24
     e50:	85 e4       	ldi	r24, 0x45	; 69
     e52:	7f dd       	rcall	.-1282   	; 0x952 <TeachHIDKey>
     e54:	60 e0       	ldi	r22, 0x00	; 0
     e56:	88 e2       	ldi	r24, 0x28	; 40
     e58:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     e5c:	8b e8       	ldi	r24, 0x8B	; 139
     e5e:	92 e0       	ldi	r25, 0x02	; 2
     e60:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
     e64:	60 e0       	ldi	r22, 0x00	; 0
     e66:	8c e2       	ldi	r24, 0x2C	; 44
     e68:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     e6c:	63 dd       	rcall	.-1338   	; 0x934 <WaitForKeypress>
     e6e:	9f ef       	ldi	r25, 0xFF	; 255
     e70:	98 0f       	add	r25, r24
     e72:	98 30       	cpi	r25, 0x08	; 8
     e74:	28 f4       	brcc	.+10     	; 0xe80 <Calibrate+0x2b8>
     e76:	80 93 ff 06 	sts	0x06FF, r24
     e7a:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
     e7e:	04 c0       	rjmp	.+8      	; 0xe88 <Calibrate+0x2c0>
     e80:	8b e9       	ldi	r24, 0x9B	; 155
     e82:	92 e0       	ldi	r25, 0x02	; 2
     e84:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
     e88:	ff ef       	ldi	r31, 0xFF	; 255
     e8a:	24 e3       	ldi	r18, 0x34	; 52
     e8c:	8c e0       	ldi	r24, 0x0C	; 12
     e8e:	f1 50       	subi	r31, 0x01	; 1
     e90:	20 40       	sbci	r18, 0x00	; 0
     e92:	80 40       	sbci	r24, 0x00	; 0
     e94:	e1 f7       	brne	.-8      	; 0xe8e <Calibrate+0x2c6>
     e96:	00 c0       	rjmp	.+0      	; 0xe98 <Calibrate+0x2d0>
     e98:	00 00       	nop
     e9a:	60 e0       	ldi	r22, 0x00	; 0
     e9c:	88 e2       	ldi	r24, 0x28	; 40
     e9e:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     ea2:	1e e2       	ldi	r17, 0x2E	; 46
     ea4:	cd e2       	ldi	r28, 0x2D	; 45
     ea6:	0f 2e       	mov	r0, r31
     ea8:	fe e2       	ldi	r31, 0x2E	; 46
     eaa:	df 2e       	mov	r13, r31
     eac:	f0 2d       	mov	r31, r0
     eae:	0f e3       	ldi	r16, 0x3F	; 63
     eb0:	0f 2e       	mov	r0, r31
     eb2:	ff e2       	ldi	r31, 0x2F	; 47
     eb4:	4f 2e       	mov	r4, r31
     eb6:	f0 2d       	mov	r31, r0
     eb8:	0f 2e       	mov	r0, r31
     eba:	fd e2       	ldi	r31, 0x2D	; 45
     ebc:	5f 2e       	mov	r5, r31
     ebe:	f0 2d       	mov	r31, r0
     ec0:	0f 2e       	mov	r0, r31
     ec2:	fa e2       	ldi	r31, 0x2A	; 42
     ec4:	6f 2e       	mov	r6, r31
     ec6:	f0 2d       	mov	r31, r0
     ec8:	0f 2e       	mov	r0, r31
     eca:	f0 e6       	ldi	r31, 0x60	; 96
     ecc:	7f 2e       	mov	r7, r31
     ece:	f0 2d       	mov	r31, r0
     ed0:	0f 2e       	mov	r0, r31
     ed2:	fe e7       	ldi	r31, 0x7E	; 126
     ed4:	8f 2e       	mov	r8, r31
     ed6:	f0 2d       	mov	r31, r0
     ed8:	0f 2e       	mov	r0, r31
     eda:	fd e3       	ldi	r31, 0x3D	; 61
     edc:	9f 2e       	mov	r9, r31
     ede:	f0 2d       	mov	r31, r0
     ee0:	0f 2e       	mov	r0, r31
     ee2:	fb e2       	ldi	r31, 0x2B	; 43
     ee4:	af 2e       	mov	r10, r31
     ee6:	f0 2d       	mov	r31, r0
     ee8:	0f 2e       	mov	r0, r31
     eea:	fb e3       	ldi	r31, 0x3B	; 59
     eec:	bf 2e       	mov	r11, r31
     eee:	f0 2d       	mov	r31, r0
     ef0:	0f 2e       	mov	r0, r31
     ef2:	fa e3       	ldi	r31, 0x3A	; 58
     ef4:	cf 2e       	mov	r12, r31
     ef6:	f0 2d       	mov	r31, r0
     ef8:	02 c0       	rjmp	.+4      	; 0xefe <Calibrate+0x336>
     efa:	cf 5f       	subi	r28, 0xFF	; 255
     efc:	1f 5f       	subi	r17, 0xFF	; 255
     efe:	c2 33       	cpi	r28, 0x32	; 50
     f00:	e1 f3       	breq	.-8      	; 0xefa <Calibrate+0x332>
     f02:	60 e0       	ldi	r22, 0x00	; 0
     f04:	8c 2f       	mov	r24, r28
     f06:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     f0a:	60 e0       	ldi	r22, 0x00	; 0
     f0c:	8c e2       	ldi	r24, 0x2C	; 44
     f0e:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     f12:	10 dd       	rcall	.-1504   	; 0x934 <WaitForKeypress>
     f14:	7c 01       	movw	r14, r24
     f16:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
     f1a:	d8 2f       	mov	r29, r24
     f1c:	ff 24       	eor	r15, r15
     f1e:	48 2f       	mov	r20, r24
     f20:	b7 01       	movw	r22, r14
     f22:	8c 2f       	mov	r24, r28
     f24:	16 dd       	rcall	.-1492   	; 0x952 <TeachHIDKey>
     f26:	d2 fd       	sbrc	r29, 2
     f28:	4d c0       	rjmp	.+154    	; 0xfc4 <Calibrate+0x3fc>
     f2a:	c3 33       	cpi	r28, 0x33	; 51
     f2c:	49 f4       	brne	.+18     	; 0xf40 <Calibrate+0x378>
     f2e:	f7 01       	movw	r30, r14
     f30:	e9 53       	subi	r30, 0x39	; 57
     f32:	f8 4f       	sbci	r31, 0xF8	; 248
     f34:	b0 82       	st	Z, r11
     f36:	f7 01       	movw	r30, r14
     f38:	e8 5b       	subi	r30, 0xB8	; 184
     f3a:	f8 4f       	sbci	r31, 0xF8	; 248
     f3c:	c0 82       	st	Z, r12
     f3e:	16 c0       	rjmp	.+44     	; 0xf6c <Calibrate+0x3a4>
     f40:	ce 32       	cpi	r28, 0x2E	; 46
     f42:	49 f4       	brne	.+18     	; 0xf56 <Calibrate+0x38e>
     f44:	f7 01       	movw	r30, r14
     f46:	e9 53       	subi	r30, 0x39	; 57
     f48:	f8 4f       	sbci	r31, 0xF8	; 248
     f4a:	90 82       	st	Z, r9
     f4c:	f7 01       	movw	r30, r14
     f4e:	e8 5b       	subi	r30, 0xB8	; 184
     f50:	f8 4f       	sbci	r31, 0xF8	; 248
     f52:	a0 82       	st	Z, r10
     f54:	16 c0       	rjmp	.+44     	; 0xf82 <Calibrate+0x3ba>
     f56:	c5 33       	cpi	r28, 0x35	; 53
     f58:	49 f4       	brne	.+18     	; 0xf6c <Calibrate+0x3a4>
     f5a:	f7 01       	movw	r30, r14
     f5c:	e9 53       	subi	r30, 0x39	; 57
     f5e:	f8 4f       	sbci	r31, 0xF8	; 248
     f60:	70 82       	st	Z, r7
     f62:	f7 01       	movw	r30, r14
     f64:	e8 5b       	subi	r30, 0xB8	; 184
     f66:	f8 4f       	sbci	r31, 0xF8	; 248
     f68:	80 82       	st	Z, r8
     f6a:	16 c0       	rjmp	.+44     	; 0xf98 <Calibrate+0x3d0>
     f6c:	cd 32       	cpi	r28, 0x2D	; 45
     f6e:	49 f4       	brne	.+18     	; 0xf82 <Calibrate+0x3ba>
     f70:	f7 01       	movw	r30, r14
     f72:	e9 53       	subi	r30, 0x39	; 57
     f74:	f8 4f       	sbci	r31, 0xF8	; 248
     f76:	50 82       	st	Z, r5
     f78:	f7 01       	movw	r30, r14
     f7a:	e8 5b       	subi	r30, 0xB8	; 184
     f7c:	f8 4f       	sbci	r31, 0xF8	; 248
     f7e:	60 82       	st	Z, r6
     f80:	17 c0       	rjmp	.+46     	; 0xfb0 <Calibrate+0x3e8>
     f82:	c8 33       	cpi	r28, 0x38	; 56
     f84:	49 f4       	brne	.+18     	; 0xf98 <Calibrate+0x3d0>
     f86:	f7 01       	movw	r30, r14
     f88:	e9 53       	subi	r30, 0x39	; 57
     f8a:	f8 4f       	sbci	r31, 0xF8	; 248
     f8c:	40 82       	st	Z, r4
     f8e:	f7 01       	movw	r30, r14
     f90:	e8 5b       	subi	r30, 0xB8	; 184
     f92:	f8 4f       	sbci	r31, 0xF8	; 248
     f94:	00 83       	st	Z, r16
     f96:	16 c0       	rjmp	.+44     	; 0xfc4 <Calibrate+0x3fc>
     f98:	c6 33       	cpi	r28, 0x36	; 54
     f9a:	51 f4       	brne	.+20     	; 0xfb0 <Calibrate+0x3e8>
     f9c:	f7 01       	movw	r30, r14
     f9e:	e9 53       	subi	r30, 0x39	; 57
     fa0:	f8 4f       	sbci	r31, 0xF8	; 248
     fa2:	8c e2       	ldi	r24, 0x2C	; 44
     fa4:	80 83       	st	Z, r24
     fa6:	f7 01       	movw	r30, r14
     fa8:	e8 5b       	subi	r30, 0xB8	; 184
     faa:	f8 4f       	sbci	r31, 0xF8	; 248
     fac:	00 83       	st	Z, r16
     fae:	0a c0       	rjmp	.+20     	; 0xfc4 <Calibrate+0x3fc>
     fb0:	c7 33       	cpi	r28, 0x37	; 55
     fb2:	41 f4       	brne	.+16     	; 0xfc4 <Calibrate+0x3fc>
     fb4:	f7 01       	movw	r30, r14
     fb6:	e9 53       	subi	r30, 0x39	; 57
     fb8:	f8 4f       	sbci	r31, 0xF8	; 248
     fba:	d0 82       	st	Z, r13
     fbc:	f7 01       	movw	r30, r14
     fbe:	e8 5b       	subi	r30, 0xB8	; 184
     fc0:	f8 4f       	sbci	r31, 0xF8	; 248
     fc2:	d0 82       	st	Z, r13
     fc4:	60 e0       	ldi	r22, 0x00	; 0
     fc6:	88 e2       	ldi	r24, 0x28	; 40
     fc8:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     fcc:	19 33       	cpi	r17, 0x39	; 57
     fce:	08 f4       	brcc	.+2      	; 0xfd2 <Calibrate+0x40a>
     fd0:	94 cf       	rjmp	.-216    	; 0xefa <Calibrate+0x332>
     fd2:	62 e0       	ldi	r22, 0x02	; 2
     fd4:	8f e1       	ldi	r24, 0x1F	; 31
     fd6:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     fda:	60 e0       	ldi	r22, 0x00	; 0
     fdc:	8c e2       	ldi	r24, 0x2C	; 44
     fde:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
     fe2:	a8 dc       	rcall	.-1712   	; 0x934 <WaitForKeypress>
     fe4:	ec 01       	movw	r28, r24
     fe6:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
     fea:	9e 01       	movw	r18, r28
     fec:	33 27       	eor	r19, r19
     fee:	82 30       	cpi	r24, 0x02	; 2
     ff0:	71 f4       	brne	.+28     	; 0x100e <Calibrate+0x446>
     ff2:	f9 01       	movw	r30, r18
     ff4:	e8 5b       	subi	r30, 0xB8	; 184
     ff6:	f8 4f       	sbci	r31, 0xF8	; 248
     ff8:	80 e4       	ldi	r24, 0x40	; 64
     ffa:	80 83       	st	Z, r24
     ffc:	8b e8       	ldi	r24, 0x8B	; 139
     ffe:	92 e0       	ldi	r25, 0x02	; 2
    1000:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
    1004:	62 e0       	ldi	r22, 0x02	; 2
    1006:	8e e2       	ldi	r24, 0x2E	; 46
    1008:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
    100c:	07 c0       	rjmp	.+14     	; 0x101c <Calibrate+0x454>
    100e:	82 fd       	sbrc	r24, 2
    1010:	05 c0       	rjmp	.+10     	; 0x101c <Calibrate+0x454>
    1012:	f9 01       	movw	r30, r18
    1014:	e9 53       	subi	r30, 0x39	; 57
    1016:	f8 4f       	sbci	r31, 0xF8	; 248
    1018:	80 e4       	ldi	r24, 0x40	; 64
    101a:	80 83       	st	Z, r24
    101c:	8c 2f       	mov	r24, r28
    101e:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
    1022:	60 e0       	ldi	r22, 0x00	; 0
    1024:	88 e2       	ldi	r24, 0x28	; 40
    1026:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
    102a:	9f ef       	ldi	r25, 0xFF	; 255
    102c:	e4 e3       	ldi	r30, 0x34	; 52
    102e:	fc e0       	ldi	r31, 0x0C	; 12
    1030:	91 50       	subi	r25, 0x01	; 1
    1032:	e0 40       	sbci	r30, 0x00	; 0
    1034:	f0 40       	sbci	r31, 0x00	; 0
    1036:	e1 f7       	brne	.-8      	; 0x1030 <Calibrate+0x468>
    1038:	00 c0       	rjmp	.+0      	; 0x103a <Calibrate+0x472>
    103a:	00 00       	nop
    103c:	62 e0       	ldi	r22, 0x02	; 2
    103e:	88 e3       	ldi	r24, 0x38	; 56
    1040:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
    1044:	60 e0       	ldi	r22, 0x00	; 0
    1046:	8c e2       	ldi	r24, 0x2C	; 44
    1048:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
    104c:	73 dc       	rcall	.-1818   	; 0x934 <WaitForKeypress>
    104e:	ec 01       	movw	r28, r24
    1050:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
    1054:	9e 01       	movw	r18, r28
    1056:	33 27       	eor	r19, r19
    1058:	82 30       	cpi	r24, 0x02	; 2
    105a:	71 f4       	brne	.+28     	; 0x1078 <Calibrate+0x4b0>
    105c:	f9 01       	movw	r30, r18
    105e:	e8 5b       	subi	r30, 0xB8	; 184
    1060:	f8 4f       	sbci	r31, 0xF8	; 248
    1062:	8f e3       	ldi	r24, 0x3F	; 63
    1064:	80 83       	st	Z, r24
    1066:	8b e8       	ldi	r24, 0x8B	; 139
    1068:	92 e0       	ldi	r25, 0x02	; 2
    106a:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
    106e:	62 e0       	ldi	r22, 0x02	; 2
    1070:	8e e2       	ldi	r24, 0x2E	; 46
    1072:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
    1076:	07 c0       	rjmp	.+14     	; 0x1086 <Calibrate+0x4be>
    1078:	82 fd       	sbrc	r24, 2
    107a:	05 c0       	rjmp	.+10     	; 0x1086 <Calibrate+0x4be>
    107c:	f9 01       	movw	r30, r18
    107e:	e9 53       	subi	r30, 0x39	; 57
    1080:	f8 4f       	sbci	r31, 0xF8	; 248
    1082:	8f e3       	ldi	r24, 0x3F	; 63
    1084:	80 83       	st	Z, r24
    1086:	8c 2f       	mov	r24, r28
    1088:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
    108c:	60 e0       	ldi	r22, 0x00	; 0
    108e:	88 e2       	ldi	r24, 0x28	; 40
    1090:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
    1094:	2f ef       	ldi	r18, 0xFF	; 255
    1096:	84 e3       	ldi	r24, 0x34	; 52
    1098:	9c e0       	ldi	r25, 0x0C	; 12
    109a:	21 50       	subi	r18, 0x01	; 1
    109c:	80 40       	sbci	r24, 0x00	; 0
    109e:	90 40       	sbci	r25, 0x00	; 0
    10a0:	e1 f7       	brne	.-8      	; 0x109a <Calibrate+0x4d2>
    10a2:	00 c0       	rjmp	.+0      	; 0x10a4 <Calibrate+0x4dc>
    10a4:	00 00       	nop
    10a6:	62 e0       	ldi	r22, 0x02	; 2
    10a8:	8e e9       	ldi	r24, 0x9E	; 158
    10aa:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
    10ae:	60 e0       	ldi	r22, 0x00	; 0
    10b0:	8c e2       	ldi	r24, 0x2C	; 44
    10b2:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
    10b6:	3e dc       	rcall	.-1924   	; 0x934 <WaitForKeypress>
    10b8:	ec 01       	movw	r28, r24
    10ba:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
    10be:	18 2f       	mov	r17, r24
    10c0:	dd 27       	eor	r29, r29
    10c2:	48 2f       	mov	r20, r24
    10c4:	be 01       	movw	r22, r28
    10c6:	8e e9       	ldi	r24, 0x9E	; 158
    10c8:	44 dc       	rcall	.-1912   	; 0x952 <TeachHIDKey>
    10ca:	12 30       	cpi	r17, 0x02	; 2
    10cc:	29 f4       	brne	.+10     	; 0x10d8 <Calibrate+0x510>
    10ce:	c8 5b       	subi	r28, 0xB8	; 184
    10d0:	d8 4f       	sbci	r29, 0xF8	; 248
    10d2:	81 e2       	ldi	r24, 0x21	; 33
    10d4:	88 83       	st	Y, r24
    10d6:	06 c0       	rjmp	.+12     	; 0x10e4 <Calibrate+0x51c>
    10d8:	12 fd       	sbrc	r17, 2
    10da:	04 c0       	rjmp	.+8      	; 0x10e4 <Calibrate+0x51c>
    10dc:	c9 53       	subi	r28, 0x39	; 57
    10de:	d8 4f       	sbci	r29, 0xF8	; 248
    10e0:	81 e2       	ldi	r24, 0x21	; 33
    10e2:	88 83       	st	Y, r24
    10e4:	60 e0       	ldi	r22, 0x00	; 0
    10e6:	88 e2       	ldi	r24, 0x28	; 40
    10e8:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
    10ec:	6c dc       	rcall	.-1832   	; 0x9c6 <CalibrateReeds>
    10ee:	7a db       	rcall	.-2316   	; 0x7e4 <SaveCalibration>
    10f0:	8c ea       	ldi	r24, 0xAC	; 172
    10f2:	90 e0       	ldi	r25, 0x00	; 0
    10f4:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
    10f8:	05 c0       	rjmp	.+10     	; 0x1104 <Calibrate+0x53c>
    10fa:	60 e0       	ldi	r22, 0x00	; 0
    10fc:	88 e2       	ldi	r24, 0x28	; 40
    10fe:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
    1102:	fd cd       	rjmp	.-1030   	; 0xcfe <Calibrate+0x136>
    1104:	df 91       	pop	r29
    1106:	cf 91       	pop	r28
    1108:	1f 91       	pop	r17
    110a:	0f 91       	pop	r16
    110c:	ff 90       	pop	r15
    110e:	ef 90       	pop	r14
    1110:	df 90       	pop	r13
    1112:	cf 90       	pop	r12
    1114:	bf 90       	pop	r11
    1116:	af 90       	pop	r10
    1118:	9f 90       	pop	r9
    111a:	8f 90       	pop	r8
    111c:	7f 90       	pop	r7
    111e:	6f 90       	pop	r6
    1120:	5f 90       	pop	r5
    1122:	4f 90       	pop	r4
    1124:	08 95       	ret

00001126 <Adjust_Sensitivity>:
	}
}

void Adjust_Sensitivity(){
    1126:	cf 93       	push	r28
	KeyHoldTime = eeprom_read_byte((uint8_t*)HOLD_TIME_ADDR);
    1128:	81 e0       	ldi	r24, 0x01	; 1
    112a:	92 e0       	ldi	r25, 0x02	; 2
    112c:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    1130:	80 93 47 07 	sts	0x0747, r24
	KeyReleaseTime = eeprom_read_byte((uint8_t*)RELEASE_TIME_ADDR);
    1134:	82 e0       	ldi	r24, 0x02	; 2
    1136:	92 e0       	ldi	r25, 0x02	; 2
    1138:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    113c:	80 93 ba 06 	sts	0x06BA, r24
	DoubleTapTime= eeprom_read_byte((uint8_t*)DOUBLE_TAP_ADDR);
    1140:	80 e0       	ldi	r24, 0x00	; 0
    1142:	92 e0       	ldi	r25, 0x02	; 2
    1144:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    1148:	80 93 fe 06 	sts	0x06FE, r24
	
	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
    114c:	80 91 4e 0a 	lds	r24, 0x0A4E
    1150:	84 30       	cpi	r24, 0x04	; 4
    1152:	e1 f7       	brne	.-8      	; 0x114c <Adjust_Sensitivity+0x26>
    1154:	2f ef       	ldi	r18, 0xFF	; 255
    1156:	89 e6       	ldi	r24, 0x69	; 105
    1158:	98 e1       	ldi	r25, 0x18	; 24
    115a:	21 50       	subi	r18, 0x01	; 1
    115c:	80 40       	sbci	r24, 0x00	; 0
    115e:	90 40       	sbci	r25, 0x00	; 0
    1160:	e1 f7       	brne	.-8      	; 0x115a <Adjust_Sensitivity+0x34>
    1162:	00 c0       	rjmp	.+0      	; 0x1164 <Adjust_Sensitivity+0x3e>
    1164:	00 00       	nop
	Delay_MS(1000);//wait 1 second.
	
	USBSendPROGString(Str_Adj_Sensitivity);
    1166:	81 ea       	ldi	r24, 0xA1	; 161
    1168:	91 e0       	ldi	r25, 0x01	; 1
    116a:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
	USBSendPROGString(Str_Press_CMD);
    116e:	83 e8       	ldi	r24, 0x83	; 131
    1170:	91 e0       	ldi	r25, 0x01	; 1
    1172:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
	while(is_high(S3)){;}
    1176:	7e 99       	sbic	0x0f, 6	; 15
    1178:	fe cf       	rjmp	.-4      	; 0x1176 <Adjust_Sensitivity+0x50>
	
	USBSendPROGString(Str_Set_Reaction_Time);
    117a:	83 e5       	ldi	r24, 0x53	; 83
    117c:	91 e0       	ldi	r25, 0x01	; 1
    117e:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
	USBSendNumber(KeyHoldTime);
    1182:	80 91 47 07 	lds	r24, 0x0747
    1186:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    118a:	60 e0       	ldi	r22, 0x00	; 0
    118c:	88 e2       	ldi	r24, 0x28	; 40
    118e:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
	while(is_high(S3)){
    1192:	1a c0       	rjmp	.+52     	; 0x11c8 <Adjust_Sensitivity+0xa2>
		if(is_low(S1)){KeyHoldTime++;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
    1194:	7c 99       	sbic	0x0f, 4	; 15
    1196:	0b c0       	rjmp	.+22     	; 0x11ae <Adjust_Sensitivity+0x88>
    1198:	80 91 47 07 	lds	r24, 0x0747
    119c:	8f 5f       	subi	r24, 0xFF	; 255
    119e:	80 93 47 07 	sts	0x0747, r24
    11a2:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
    11a6:	60 e0       	ldi	r22, 0x00	; 0
    11a8:	88 e2       	ldi	r24, 0x28	; 40
    11aa:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
		if(is_low(S2)){KeyHoldTime--;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
    11ae:	7d 99       	sbic	0x0f, 5	; 15
    11b0:	0b c0       	rjmp	.+22     	; 0x11c8 <Adjust_Sensitivity+0xa2>
    11b2:	80 91 47 07 	lds	r24, 0x0747
    11b6:	81 50       	subi	r24, 0x01	; 1
    11b8:	80 93 47 07 	sts	0x0747, r24
    11bc:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
    11c0:	60 e0       	ldi	r22, 0x00	; 0
    11c2:	88 e2       	ldi	r24, 0x28	; 40
    11c4:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
	while(is_high(S3)){;}
	
	USBSendPROGString(Str_Set_Reaction_Time);
	USBSendNumber(KeyHoldTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    11c8:	7e 99       	sbic	0x0f, 6	; 15
    11ca:	e4 cf       	rjmp	.-56     	; 0x1194 <Adjust_Sensitivity+0x6e>
		if(is_low(S1)){KeyHoldTime++;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){KeyHoldTime--;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
	}
	
	USBSendPROGString(Str_Set_Release_Time);
    11cc:	85 e3       	ldi	r24, 0x35	; 53
    11ce:	91 e0       	ldi	r25, 0x01	; 1
    11d0:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
	USBSendNumber(KeyReleaseTime);
    11d4:	80 91 ba 06 	lds	r24, 0x06BA
    11d8:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    11dc:	60 e0       	ldi	r22, 0x00	; 0
    11de:	88 e2       	ldi	r24, 0x28	; 40
    11e0:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
	while(is_high(S3)){
    11e4:	1a c0       	rjmp	.+52     	; 0x121a <Adjust_Sensitivity+0xf4>
		if(is_low(S1)){KeyReleaseTime++;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
    11e6:	7c 99       	sbic	0x0f, 4	; 15
    11e8:	0b c0       	rjmp	.+22     	; 0x1200 <Adjust_Sensitivity+0xda>
    11ea:	80 91 ba 06 	lds	r24, 0x06BA
    11ee:	8f 5f       	subi	r24, 0xFF	; 255
    11f0:	80 93 ba 06 	sts	0x06BA, r24
    11f4:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
    11f8:	60 e0       	ldi	r22, 0x00	; 0
    11fa:	88 e2       	ldi	r24, 0x28	; 40
    11fc:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
		if(is_low(S2)){KeyReleaseTime--;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
    1200:	7d 99       	sbic	0x0f, 5	; 15
    1202:	0b c0       	rjmp	.+22     	; 0x121a <Adjust_Sensitivity+0xf4>
    1204:	80 91 ba 06 	lds	r24, 0x06BA
    1208:	81 50       	subi	r24, 0x01	; 1
    120a:	80 93 ba 06 	sts	0x06BA, r24
    120e:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
    1212:	60 e0       	ldi	r22, 0x00	; 0
    1214:	88 e2       	ldi	r24, 0x28	; 40
    1216:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
	}
	
	USBSendPROGString(Str_Set_Release_Time);
	USBSendNumber(KeyReleaseTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    121a:	7e 99       	sbic	0x0f, 6	; 15
    121c:	e4 cf       	rjmp	.-56     	; 0x11e6 <Adjust_Sensitivity+0xc0>
		if(is_low(S1)){KeyReleaseTime++;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){KeyReleaseTime--;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
	}
	
	USBSendPROGString(Str_Set_Double_Time);
    121e:	87 e0       	ldi	r24, 0x07	; 7
    1220:	91 e0       	ldi	r25, 0x01	; 1
    1222:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
	USBSendNumber(DoubleTapTime);
    1226:	80 91 fe 06 	lds	r24, 0x06FE
    122a:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    122e:	60 e0       	ldi	r22, 0x00	; 0
    1230:	88 e2       	ldi	r24, 0x28	; 40
    1232:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
	while(is_high(S3)){
    1236:	1a c0       	rjmp	.+52     	; 0x126c <Adjust_Sensitivity+0x146>
		if(is_low(S1)){DoubleTapTime++;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
    1238:	7c 99       	sbic	0x0f, 4	; 15
    123a:	0b c0       	rjmp	.+22     	; 0x1252 <Adjust_Sensitivity+0x12c>
    123c:	80 91 fe 06 	lds	r24, 0x06FE
    1240:	8f 5f       	subi	r24, 0xFF	; 255
    1242:	80 93 fe 06 	sts	0x06FE, r24
    1246:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
    124a:	60 e0       	ldi	r22, 0x00	; 0
    124c:	88 e2       	ldi	r24, 0x28	; 40
    124e:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
		if(is_low(S2)){DoubleTapTime--;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
    1252:	7d 99       	sbic	0x0f, 5	; 15
    1254:	0b c0       	rjmp	.+22     	; 0x126c <Adjust_Sensitivity+0x146>
    1256:	80 91 fe 06 	lds	r24, 0x06FE
    125a:	81 50       	subi	r24, 0x01	; 1
    125c:	80 93 fe 06 	sts	0x06FE, r24
    1260:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
    1264:	60 e0       	ldi	r22, 0x00	; 0
    1266:	88 e2       	ldi	r24, 0x28	; 40
    1268:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
	}
	
	USBSendPROGString(Str_Set_Double_Time);
	USBSendNumber(DoubleTapTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    126c:	7e 99       	sbic	0x0f, 6	; 15
    126e:	e4 cf       	rjmp	.-56     	; 0x1238 <Adjust_Sensitivity+0x112>
		if(is_low(S1)){DoubleTapTime++;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){DoubleTapTime--;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
	}
	
	USBSendPROGString(Str_Set_Reed_Time);
    1270:	87 ee       	ldi	r24, 0xE7	; 231
    1272:	90 e0       	ldi	r25, 0x00	; 0
    1274:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
	USBSendNumber(ReedHoldTime);
    1278:	80 91 fd 06 	lds	r24, 0x06FD
    127c:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    1280:	60 e0       	ldi	r22, 0x00	; 0
    1282:	88 e2       	ldi	r24, 0x28	; 40
    1284:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
	while(is_high(S3)){
    1288:	1a c0       	rjmp	.+52     	; 0x12be <Adjust_Sensitivity+0x198>
		if(is_low(S1)){ReedHoldTime++;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
    128a:	7c 99       	sbic	0x0f, 4	; 15
    128c:	0b c0       	rjmp	.+22     	; 0x12a4 <Adjust_Sensitivity+0x17e>
    128e:	80 91 fd 06 	lds	r24, 0x06FD
    1292:	8f 5f       	subi	r24, 0xFF	; 255
    1294:	80 93 fd 06 	sts	0x06FD, r24
    1298:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
    129c:	60 e0       	ldi	r22, 0x00	; 0
    129e:	88 e2       	ldi	r24, 0x28	; 40
    12a0:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
    12a4:	7d 99       	sbic	0x0f, 5	; 15
    12a6:	0b c0       	rjmp	.+22     	; 0x12be <Adjust_Sensitivity+0x198>
    12a8:	80 91 fd 06 	lds	r24, 0x06FD
    12ac:	81 50       	subi	r24, 0x01	; 1
    12ae:	80 93 fd 06 	sts	0x06FD, r24
    12b2:	0e 94 48 2a 	call	0x5490	; 0x5490 <USBSendNumber>
    12b6:	60 e0       	ldi	r22, 0x00	; 0
    12b8:	88 e2       	ldi	r24, 0x28	; 40
    12ba:	0e 94 7c 29 	call	0x52f8	; 0x52f8 <USBSend>
	}
	
	USBSendPROGString(Str_Set_Reed_Time);
	USBSendNumber(ReedHoldTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    12be:	7e 99       	sbic	0x0f, 6	; 15
    12c0:	e4 cf       	rjmp	.-56     	; 0x128a <Adjust_Sensitivity+0x164>
		if(is_low(S1)){ReedHoldTime++;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
	}	
	
	USBSendPROGString(Str_Spacebar_Blocks_Enter);
    12c2:	8d eb       	ldi	r24, 0xBD	; 189
    12c4:	90 e0       	ldi	r25, 0x00	; 0
    12c6:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
	Reeds_Are_Independent ? USBSendString("NO\r") : USBSendString("YES\r");
    12ca:	80 91 b8 06 	lds	r24, 0x06B8
    12ce:	88 23       	and	r24, r24
    12d0:	29 f0       	breq	.+10     	; 0x12dc <Adjust_Sensitivity+0x1b6>
    12d2:	8f ea       	ldi	r24, 0xAF	; 175
    12d4:	92 e0       	ldi	r25, 0x02	; 2
    12d6:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
    12da:	1a c0       	rjmp	.+52     	; 0x1310 <Adjust_Sensitivity+0x1ea>
    12dc:	83 eb       	ldi	r24, 0xB3	; 179
    12de:	92 e0       	ldi	r25, 0x02	; 2
    12e0:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
    12e4:	15 c0       	rjmp	.+42     	; 0x1310 <Adjust_Sensitivity+0x1ea>
	while(is_high(S3)){
		if(is_low(S1)){Reeds_Are_Independent = false; USBSendString("YES\r");}
    12e6:	7c 99       	sbic	0x0f, 4	; 15
    12e8:	06 c0       	rjmp	.+12     	; 0x12f6 <Adjust_Sensitivity+0x1d0>
    12ea:	10 92 b8 06 	sts	0x06B8, r1
    12ee:	83 eb       	ldi	r24, 0xB3	; 179
    12f0:	92 e0       	ldi	r25, 0x02	; 2
    12f2:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
		if(is_low(S2)){Reeds_Are_Independent = true; USBSendString("NO\r");}
    12f6:	7d 99       	sbic	0x0f, 5	; 15
    12f8:	06 c0       	rjmp	.+12     	; 0x1306 <Adjust_Sensitivity+0x1e0>
    12fa:	c0 93 b8 06 	sts	0x06B8, r28
    12fe:	8f ea       	ldi	r24, 0xAF	; 175
    1300:	92 e0       	ldi	r25, 0x02	; 2
    1302:	0e 94 c0 29 	call	0x5380	; 0x5380 <USBSendString>
		while(is_low(S1)||is_low(S2)){;}//wait until one of the switches is released before looping.
    1306:	7c 9b       	sbis	0x0f, 4	; 15
    1308:	fe cf       	rjmp	.-4      	; 0x1306 <Adjust_Sensitivity+0x1e0>
    130a:	7d 9b       	sbis	0x0f, 5	; 15
    130c:	fc cf       	rjmp	.-8      	; 0x1306 <Adjust_Sensitivity+0x1e0>
    130e:	01 c0       	rjmp	.+2      	; 0x1312 <Adjust_Sensitivity+0x1ec>
	
	USBSendPROGString(Str_Spacebar_Blocks_Enter);
	Reeds_Are_Independent ? USBSendString("NO\r") : USBSendString("YES\r");
	while(is_high(S3)){
		if(is_low(S1)){Reeds_Are_Independent = false; USBSendString("YES\r");}
		if(is_low(S2)){Reeds_Are_Independent = true; USBSendString("NO\r");}
    1310:	c1 e0       	ldi	r28, 0x01	; 1
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
	}	
	
	USBSendPROGString(Str_Spacebar_Blocks_Enter);
	Reeds_Are_Independent ? USBSendString("NO\r") : USBSendString("YES\r");
	while(is_high(S3)){
    1312:	7e 99       	sbic	0x0f, 6	; 15
    1314:	e8 cf       	rjmp	.-48     	; 0x12e6 <Adjust_Sensitivity+0x1c0>
		if(is_low(S1)){Reeds_Are_Independent = false; USBSendString("YES\r");}
		if(is_low(S2)){Reeds_Are_Independent = true; USBSendString("NO\r");}
		while(is_low(S1)||is_low(S2)){;}//wait until one of the switches is released before looping.
	}
	
	eeprom_update_byte((uint8_t*)DOUBLE_TAP_ADDR,DoubleTapTime);
    1316:	60 91 fe 06 	lds	r22, 0x06FE
    131a:	80 e0       	ldi	r24, 0x00	; 0
    131c:	92 e0       	ldi	r25, 0x02	; 2
    131e:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)RELEASE_TIME_ADDR,KeyReleaseTime);
    1322:	60 91 ba 06 	lds	r22, 0x06BA
    1326:	82 e0       	ldi	r24, 0x02	; 2
    1328:	92 e0       	ldi	r25, 0x02	; 2
    132a:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)HOLD_TIME_ADDR,KeyHoldTime);
    132e:	60 91 47 07 	lds	r22, 0x0747
    1332:	81 e0       	ldi	r24, 0x01	; 1
    1334:	92 e0       	ldi	r25, 0x02	; 2
    1336:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)REED_HOLD_TIME_ADDR,ReedHoldTime);
    133a:	60 91 fd 06 	lds	r22, 0x06FD
    133e:	8c e0       	ldi	r24, 0x0C	; 12
    1340:	92 e0       	ldi	r25, 0x02	; 2
    1342:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)REEDS_INDEPENDENT_ADDR,Reeds_Are_Independent);
    1346:	60 91 b8 06 	lds	r22, 0x06B8
    134a:	8e e0       	ldi	r24, 0x0E	; 14
    134c:	92 e0       	ldi	r25, 0x02	; 2
    134e:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
	
	USBSendPROGString(Str_Settings_Saved);
    1352:	8c ea       	ldi	r24, 0xAC	; 172
    1354:	90 e0       	ldi	r25, 0x00	; 0
    1356:	0e 94 3f 2a 	call	0x547e	; 0x547e <USBSendPROGString>
}
    135a:	cf 91       	pop	r28
    135c:	08 95       	ret

0000135e <Config_Interrupts>:


void Config_Interrupts(){

	
	bit_clr(PRR0,PRTIM1); // clear power-reduction bit for timer1
    135e:	e4 e6       	ldi	r30, 0x64	; 100
    1360:	f0 e0       	ldi	r31, 0x00	; 0
    1362:	80 81       	ld	r24, Z
    1364:	87 7f       	andi	r24, 0xF7	; 247
    1366:	80 83       	st	Z, r24
	TCCR1B = BIT(CTC1) | BIT(CS11); //set CTC (clear timer on compare equal mode) and set tmr prescaler to 8 -- page 125 of datasheet
    1368:	8a e0       	ldi	r24, 0x0A	; 10
    136a:	80 93 81 00 	sts	0x0081, r24
	
	OCR1AH = TIMER1_COMPARE_HIGH;//high register MUST be written before low register.  Datasheet says so!
    136e:	87 e2       	ldi	r24, 0x27	; 39
    1370:	80 93 89 00 	sts	0x0089, r24
	OCR1AL = UINT8_C(TIMER1_COMPARE_LOW); //we only want the first 8 bits of the "low" variable.
    1374:	80 e1       	ldi	r24, 0x10	; 16
    1376:	80 93 88 00 	sts	0x0088, r24
	
	bit_set(TIMSK1,OCIE1A); //enable output compare interrupt for timer1
    137a:	ef e6       	ldi	r30, 0x6F	; 111
    137c:	f0 e0       	ldi	r31, 0x00	; 0
    137e:	80 81       	ld	r24, Z
    1380:	82 60       	ori	r24, 0x02	; 2
    1382:	80 83       	st	Z, r24
    1384:	08 95       	ret

00001386 <Config_IO>:
volatile uint8_t GlowDirection; //global variable that sets direction of led glow (fade up or down)


void Config_IO(){
	
	configure_as_input(SD_DETECT);
    1386:	20 98       	cbi	0x04, 0	; 4
	pullup_on(SD_DETECT);
    1388:	28 9a       	sbi	0x05, 0	; 5
	
	configure_as_input(REED_1);
    138a:	54 98       	cbi	0x0a, 4	; 10
	pullup_on(REED_1);
    138c:	5c 9a       	sbi	0x0b, 4	; 11
	
	configure_as_input(REED_2);
    138e:	56 98       	cbi	0x0a, 6	; 10
	pullup_on(REED_2);	
    1390:	5e 9a       	sbi	0x0b, 6	; 11

	configure_as_input(REED_3);
    1392:	57 98       	cbi	0x0a, 7	; 10
	pullup_on(REED_3);	
    1394:	5f 9a       	sbi	0x0b, 7	; 11
	
	configure_as_input(REED_4);
    1396:	24 98       	cbi	0x04, 4	; 4
	pullup_on(REED_4);	
    1398:	2c 9a       	sbi	0x05, 4	; 5
	
	
	set_high(SD_MISO);
    139a:	2b 9a       	sbi	0x05, 3	; 5
	configure_as_input(SD_MISO);
    139c:	23 98       	cbi	0x04, 3	; 4
	pullup_on(SD_MISO);
    139e:	2b 9a       	sbi	0x05, 3	; 5
	
	set_high(SD_MOSI);
    13a0:	2a 9a       	sbi	0x05, 2	; 5
	configure_as_input(SD_MOSI);
    13a2:	22 98       	cbi	0x04, 2	; 4
	pullup_on(SD_MOSI);
    13a4:	2a 9a       	sbi	0x05, 2	; 5
	
	configure_as_output(SENSE_CLK);
    13a6:	6a 9a       	sbi	0x0d, 2	; 13
	
	configure_as_input(SENSE_SER);
    13a8:	25 98       	cbi	0x04, 5	; 4
	pullup_on(SENSE_SER);
    13aa:	2d 9a       	sbi	0x05, 5	; 5

	set_high(SD_CLK);
    13ac:	29 9a       	sbi	0x05, 1	; 5
	configure_as_input(SD_CLK);
    13ae:	21 98       	cbi	0x04, 1	; 4
	pullup_on(SD_CLK);
    13b0:	29 9a       	sbi	0x05, 1	; 5
	
	set_high(SD_CHIP_SELECT);
    13b2:	59 9a       	sbi	0x0b, 1	; 11
	configure_as_output(SD_CHIP_SELECT);
    13b4:	51 9a       	sbi	0x0a, 1	; 10
	
	configure_as_input(DUMMY_LOAD);
    13b6:	55 98       	cbi	0x0a, 5	; 10
	//no pullup;
	
	set_high(TX);
    13b8:	5b 9a       	sbi	0x0b, 3	; 11
	configure_as_output(TX);
    13ba:	53 9a       	sbi	0x0a, 3	; 10
	
	configure_as_input(RX);
    13bc:	52 98       	cbi	0x0a, 2	; 10
	pullup_on(RX);
    13be:	5a 9a       	sbi	0x0b, 2	; 11
	
	configure_as_input(S1);
    13c0:	84 98       	cbi	0x10, 4	; 16
	pullup_on(S1);
    13c2:	8c 9a       	sbi	0x11, 4	; 17
	
	configure_as_input(S2);
    13c4:	85 98       	cbi	0x10, 5	; 16
	pullup_on(S2);
    13c6:	8d 9a       	sbi	0x11, 5	; 17
	
	configure_as_input(S3);
    13c8:	86 98       	cbi	0x10, 6	; 16
	pullup_on(S3);
    13ca:	8e 9a       	sbi	0x11, 6	; 17
	
	set_low(BT_RESET);// bt is off by default
    13cc:	8f 98       	cbi	0x11, 7	; 17
	configure_as_output(BT_RESET); 
    13ce:	87 9a       	sbi	0x10, 7	; 16
	
	set_high(BT_BAUD);
    13d0:	47 9a       	sbi	0x08, 7	; 8
	configure_as_output(BT_BAUD);
    13d2:	3f 9a       	sbi	0x07, 7	; 7
	
	configure_as_input(BT_CONNECTED);
    13d4:	81 98       	cbi	0x10, 1	; 16
	pullup_on(BT_CONNECTED);
    13d6:	89 9a       	sbi	0x11, 1	; 17
	
	set_high(BT_CTS);
    13d8:	76 9a       	sbi	0x0e, 6	; 14
	configure_as_output(BT_CTS);
    13da:	6e 9a       	sbi	0x0d, 6	; 13
	
	set_high(LED1);
    13dc:	46 9a       	sbi	0x08, 6	; 8
	configure_as_output(LED1);
    13de:	3e 9a       	sbi	0x07, 6	; 7
	
	set_high(LED2);
    13e0:	2e 9a       	sbi	0x05, 6	; 5
	configure_as_output(LED2);
    13e2:	26 9a       	sbi	0x04, 6	; 4
    13e4:	08 95       	ret

000013e6 <GlowGreenLED>:
}

void GlowGreenLED(uint8_t speed, uint8_t mode){

	//green led is also called the ~OC4A pin
	cli();//disable interrupts;
    13e6:	f8 94       	cli
	OCR4C = 0xFF; //clear tmr4 when reaching this value
    13e8:	9f ef       	ldi	r25, 0xFF	; 255
    13ea:	90 93 d1 00 	sts	0x00D1, r25
	TC4H = 0x00; //clearing this register sets timer4 to 8-bit mode
    13ee:	10 92 bf 00 	sts	0x00BF, r1
	OCR4A = 0x20; //when counter reaches this value, it triggers LED.
    13f2:	90 e2       	ldi	r25, 0x20	; 32
    13f4:	90 93 cf 00 	sts	0x00CF, r25
	
	if(mode == SOLID){
    13f8:	61 30       	cpi	r22, 0x01	; 1
    13fa:	61 f4       	brne	.+24     	; 0x1414 <GlowGreenLED+0x2e>
		bit_clr(TCCR4E,OC4OE0);//disconnect ~oc4a output
    13fc:	e4 ec       	ldi	r30, 0xC4	; 196
    13fe:	f0 e0       	ldi	r31, 0x00	; 0
    1400:	90 81       	ld	r25, Z
    1402:	9e 7f       	andi	r25, 0xFE	; 254
    1404:	90 83       	st	Z, r25
		bit_clr(TCCR4A,COM4A0); //clear the bit for ~OC4A pin to be active in fast pwm mode
    1406:	e0 ec       	ldi	r30, 0xC0	; 192
    1408:	f0 e0       	ldi	r31, 0x00	; 0
    140a:	90 81       	ld	r25, Z
    140c:	9f 7b       	andi	r25, 0xBF	; 191
    140e:	90 83       	st	Z, r25
		set_low(GREEN_LED);	//manually pull led low
    1410:	46 98       	cbi	0x08, 6	; 8
    1412:	0a c0       	rjmp	.+20     	; 0x1428 <GlowGreenLED+0x42>
	}
	else{
		bit_set(TCCR4E,OC4OE0);//enable the ~oc4a output
    1414:	e4 ec       	ldi	r30, 0xC4	; 196
    1416:	f0 e0       	ldi	r31, 0x00	; 0
    1418:	90 81       	ld	r25, Z
    141a:	91 60       	ori	r25, 0x01	; 1
    141c:	90 83       	st	Z, r25
		bit_set(TCCR4A,COM4A0); //set the bit for ~OC4A pin to be active in fast pwm mode
    141e:	e0 ec       	ldi	r30, 0xC0	; 192
    1420:	f0 e0       	ldi	r31, 0x00	; 0
    1422:	90 81       	ld	r25, Z
    1424:	90 64       	ori	r25, 0x40	; 64
    1426:	90 83       	st	Z, r25
	}
	
	
	bit_set(TCCR4A,PWM4A);//activate fast pwm mode
    1428:	e0 ec       	ldi	r30, 0xC0	; 192
    142a:	f0 e0       	ldi	r31, 0x00	; 0
    142c:	90 81       	ld	r25, Z
    142e:	92 60       	ori	r25, 0x02	; 2
    1430:	90 83       	st	Z, r25
	bit_set(TIMSK4,TOIE4);//enable timer overflow interrupts.
    1432:	e2 e7       	ldi	r30, 0x72	; 114
    1434:	f0 e0       	ldi	r31, 0x00	; 0
    1436:	90 81       	ld	r25, Z
    1438:	94 60       	ori	r25, 0x04	; 4
    143a:	90 83       	st	Z, r25
	switch(speed){
    143c:	81 30       	cpi	r24, 0x01	; 1
    143e:	49 f0       	breq	.+18     	; 0x1452 <GlowGreenLED+0x6c>
    1440:	28 f0       	brcs	.+10     	; 0x144c <GlowGreenLED+0x66>
    1442:	82 30       	cpi	r24, 0x02	; 2
    1444:	61 f0       	breq	.+24     	; 0x145e <GlowGreenLED+0x78>
    1446:	83 30       	cpi	r24, 0x03	; 3
    1448:	71 f0       	breq	.+28     	; 0x1466 <GlowGreenLED+0x80>
    144a:	11 c0       	rjmp	.+34     	; 0x146e <GlowGreenLED+0x88>
		case 0:
			TCCR4B = BIT(CS43)|BIT(CS40);
    144c:	89 e0       	ldi	r24, 0x09	; 9
    144e:	80 93 c1 00 	sts	0x00C1, r24
		case 1:
			bit_set(TCCR4B,CS43);//enable 1:128 prescaler (should make each tick worth about 10khZ).
    1452:	e1 ec       	ldi	r30, 0xC1	; 193
    1454:	f0 e0       	ldi	r31, 0x00	; 0
    1456:	80 81       	ld	r24, Z
    1458:	88 60       	ori	r24, 0x08	; 8
    145a:	80 83       	st	Z, r24
		break;
    145c:	0d c0       	rjmp	.+26     	; 0x1478 <GlowGreenLED+0x92>
		case 2:
			TCCR4B = BIT(CS42)|BIT(CS41)|BIT(CS40);
    145e:	87 e0       	ldi	r24, 0x07	; 7
    1460:	80 93 c1 00 	sts	0x00C1, r24
		break;
    1464:	09 c0       	rjmp	.+18     	; 0x1478 <GlowGreenLED+0x92>
		case 3:
			TCCR4B = BIT(CS42)|BIT(CS41);
    1466:	86 e0       	ldi	r24, 0x06	; 6
    1468:	80 93 c1 00 	sts	0x00C1, r24
		break;
    146c:	05 c0       	rjmp	.+10     	; 0x1478 <GlowGreenLED+0x92>
		default:
			bit_set(TCCR4B,CS43);
    146e:	e1 ec       	ldi	r30, 0xC1	; 193
    1470:	f0 e0       	ldi	r31, 0x00	; 0
    1472:	80 81       	ld	r24, Z
    1474:	88 60       	ori	r24, 0x08	; 8
    1476:	80 83       	st	Z, r24
		break;
	}
		
		GlowDirection = BRIGHTEN;
    1478:	10 92 b5 06 	sts	0x06B5, r1
		TCNT4 = 0;//clear the timer to 0;}
    147c:	10 92 bf 00 	sts	0x00BF, r1
    1480:	10 92 be 00 	sts	0x00BE, r1

	sei();//enable interrupts again.
    1484:	78 94       	sei
    1486:	08 95       	ret

00001488 <__vector_41>:
}

ISR(TIMER4_OVF_vect){ //called each time timer1 counts up to the OCR1A register (every couple ms)
    1488:	1f 92       	push	r1
    148a:	0f 92       	push	r0
    148c:	0f b6       	in	r0, 0x3f	; 63
    148e:	0f 92       	push	r0
    1490:	11 24       	eor	r1, r1
    1492:	8f 93       	push	r24
    1494:	9f 93       	push	r25
    1496:	ef 93       	push	r30
    1498:	ff 93       	push	r31

	uint8_t temp;
	temp = OCR4A;
    149a:	80 91 cf 00 	lds	r24, 0x00CF
	switch(GlowDirection){
    149e:	90 91 b5 06 	lds	r25, 0x06B5
    14a2:	99 23       	and	r25, r25
    14a4:	19 f0       	breq	.+6      	; 0x14ac <__vector_41+0x24>
    14a6:	92 30       	cpi	r25, 0x02	; 2
    14a8:	49 f0       	breq	.+18     	; 0x14bc <__vector_41+0x34>
    14aa:	0c c0       	rjmp	.+24     	; 0x14c4 <__vector_41+0x3c>
	case BRIGHTEN:
		if(temp==0xFF) GlowDirection = DIM;
    14ac:	8f 3f       	cpi	r24, 0xFF	; 255
    14ae:	21 f4       	brne	.+8      	; 0x14b8 <__vector_41+0x30>
    14b0:	91 e0       	ldi	r25, 0x01	; 1
    14b2:	90 93 b5 06 	sts	0x06B5, r25
    14b6:	12 c0       	rjmp	.+36     	; 0x14dc <__vector_41+0x54>
		else temp++;
    14b8:	8f 5f       	subi	r24, 0xFF	; 255
    14ba:	10 c0       	rjmp	.+32     	; 0x14dc <__vector_41+0x54>
	break;
	case BRIGHTEN_ONLY:
			if(temp!=0xFF) temp++;
    14bc:	8f 3f       	cpi	r24, 0xFF	; 255
    14be:	71 f0       	breq	.+28     	; 0x14dc <__vector_41+0x54>
    14c0:	8f 5f       	subi	r24, 0xFF	; 255
    14c2:	0c c0       	rjmp	.+24     	; 0x14dc <__vector_41+0x54>
	break;
	case DIM:
	default:
		if(temp == 0x00){
    14c4:	81 11       	cpse	r24, r1
    14c6:	09 c0       	rjmp	.+18     	; 0x14da <__vector_41+0x52>
			bit_clr(TCCR4A,COM4A0); //disconnect green led output pin
    14c8:	e0 ec       	ldi	r30, 0xC0	; 192
    14ca:	f0 e0       	ldi	r31, 0x00	; 0
    14cc:	90 81       	ld	r25, Z
    14ce:	9f 7b       	andi	r25, 0xBF	; 191
    14d0:	90 83       	st	Z, r25
			TCCR4B = 0;//clear the timer4 register (disable the timer);
    14d2:	10 92 c1 00 	sts	0x00C1, r1
			set_high(GREEN_LED); //turn off led
    14d6:	46 9a       	sbi	0x08, 6	; 8
    14d8:	01 c0       	rjmp	.+2      	; 0x14dc <__vector_41+0x54>
		}
		else{
			temp--;
    14da:	81 50       	subi	r24, 0x01	; 1
		}
	break;
	}
	OCR4A = temp;
    14dc:	80 93 cf 00 	sts	0x00CF, r24
}
    14e0:	ff 91       	pop	r31
    14e2:	ef 91       	pop	r30
    14e4:	9f 91       	pop	r25
    14e6:	8f 91       	pop	r24
    14e8:	0f 90       	pop	r0
    14ea:	0f be       	out	0x3f, r0	; 63
    14ec:	0f 90       	pop	r0
    14ee:	1f 90       	pop	r1
    14f0:	18 95       	reti

000014f2 <CALLBACK_USB_GetDescriptor>:
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
    14f2:	29 2f       	mov	r18, r25
    14f4:	33 27       	eor	r19, r19
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
    14f6:	23 30       	cpi	r18, 0x03	; 3
    14f8:	31 05       	cpc	r19, r1
    14fa:	c9 f0       	breq	.+50     	; 0x152e <CALLBACK_USB_GetDescriptor+0x3c>
    14fc:	3c f4       	brge	.+14     	; 0x150c <CALLBACK_USB_GetDescriptor+0x1a>
    14fe:	21 30       	cpi	r18, 0x01	; 1
    1500:	31 05       	cpc	r19, r1
    1502:	59 f0       	breq	.+22     	; 0x151a <CALLBACK_USB_GetDescriptor+0x28>
    1504:	22 30       	cpi	r18, 0x02	; 2
    1506:	31 05       	cpc	r19, r1
    1508:	69 f0       	breq	.+26     	; 0x1524 <CALLBACK_USB_GetDescriptor+0x32>
    150a:	36 c0       	rjmp	.+108    	; 0x1578 <CALLBACK_USB_GetDescriptor+0x86>
    150c:	21 32       	cpi	r18, 0x21	; 33
    150e:	31 05       	cpc	r19, r1
    1510:	49 f1       	breq	.+82     	; 0x1564 <CALLBACK_USB_GetDescriptor+0x72>
    1512:	22 32       	cpi	r18, 0x22	; 34
    1514:	31 05       	cpc	r19, r1
    1516:	59 f1       	breq	.+86     	; 0x156e <CALLBACK_USB_GetDescriptor+0x7c>
    1518:	2f c0       	rjmp	.+94     	; 0x1578 <CALLBACK_USB_GetDescriptor+0x86>
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
    151a:	82 e1       	ldi	r24, 0x12	; 18
    151c:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
    151e:	29 e4       	ldi	r18, 0x49	; 73
    1520:	34 e0       	ldi	r19, 0x04	; 4
    1522:	33 c0       	rjmp	.+102    	; 0x158a <CALLBACK_USB_GetDescriptor+0x98>
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
    1524:	89 e3       	ldi	r24, 0x39	; 57
    1526:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
    1528:	20 e1       	ldi	r18, 0x10	; 16
    152a:	34 e0       	ldi	r19, 0x04	; 4
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
    152c:	2e c0       	rjmp	.+92     	; 0x158a <CALLBACK_USB_GetDescriptor+0x98>
    152e:	99 27       	eor	r25, r25
		case DTYPE_String:
			switch (DescriptorNumber)
    1530:	81 30       	cpi	r24, 0x01	; 1
    1532:	91 05       	cpc	r25, r1
    1534:	59 f0       	breq	.+22     	; 0x154c <CALLBACK_USB_GetDescriptor+0x5a>
    1536:	82 30       	cpi	r24, 0x02	; 2
    1538:	91 05       	cpc	r25, r1
    153a:	71 f0       	breq	.+28     	; 0x1558 <CALLBACK_USB_GetDescriptor+0x66>
    153c:	89 2b       	or	r24, r25
    153e:	09 f5       	brne	.+66     	; 0x1582 <CALLBACK_USB_GetDescriptor+0x90>
			{
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
    1540:	ec e0       	ldi	r30, 0x0C	; 12
    1542:	f4 e0       	ldi	r31, 0x04	; 4
    1544:	84 91       	lpm	r24, Z
    1546:	90 e0       	ldi	r25, 0x00	; 0
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
			{
				case STRING_ID_Language:
					Address = &LanguageString;
    1548:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&LanguageString.Header.Size);
					break;
    154a:	1f c0       	rjmp	.+62     	; 0x158a <CALLBACK_USB_GetDescriptor+0x98>
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
    154c:	e4 ee       	ldi	r30, 0xE4	; 228
    154e:	f3 e0       	ldi	r31, 0x03	; 3
    1550:	84 91       	lpm	r24, Z
    1552:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
					break;
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
    1554:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
    1556:	19 c0       	rjmp	.+50     	; 0x158a <CALLBACK_USB_GetDescriptor+0x98>
				case STRING_ID_Product:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
    1558:	e2 eb       	ldi	r30, 0xB2	; 178
    155a:	f3 e0       	ldi	r31, 0x03	; 3
    155c:	84 91       	lpm	r24, Z
    155e:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case STRING_ID_Product:
					Address = &ProductString;
    1560:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
    1562:	13 c0       	rjmp	.+38     	; 0x158a <CALLBACK_USB_GetDescriptor+0x98>
			}

			break;
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
    1564:	89 e0       	ldi	r24, 0x09	; 9
    1566:	90 e0       	ldi	r25, 0x00	; 0
					break;
			}

			break;
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
    1568:	29 e3       	ldi	r18, 0x39	; 57
    156a:	34 e0       	ldi	r19, 0x04	; 4
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
    156c:	0e c0       	rjmp	.+28     	; 0x158a <CALLBACK_USB_GetDescriptor+0x98>
		case HID_DTYPE_Report:
			Address = &KeyboardReport;
			Size    = sizeof(KeyboardReport);
    156e:	8f e3       	ldi	r24, 0x3F	; 63
    1570:	90 e0       	ldi	r25, 0x00	; 0
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
		case HID_DTYPE_Report:
			Address = &KeyboardReport;
    1572:	2b e5       	ldi	r18, 0x5B	; 91
    1574:	34 e0       	ldi	r19, 0x04	; 4
			Size    = sizeof(KeyboardReport);
			break;
    1576:	09 c0       	rjmp	.+18     	; 0x158a <CALLBACK_USB_GetDescriptor+0x98>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
    1578:	80 e0       	ldi	r24, 0x00	; 0
    157a:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
    157c:	20 e0       	ldi	r18, 0x00	; 0
    157e:	30 e0       	ldi	r19, 0x00	; 0
    1580:	04 c0       	rjmp	.+8      	; 0x158a <CALLBACK_USB_GetDescriptor+0x98>
	uint16_t    Size    = NO_DESCRIPTOR;
    1582:	80 e0       	ldi	r24, 0x00	; 0
    1584:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
    1586:	20 e0       	ldi	r18, 0x00	; 0
    1588:	30 e0       	ldi	r19, 0x00	; 0
			Address = &KeyboardReport;
			Size    = sizeof(KeyboardReport);
			break;
	}

	*DescriptorAddress = Address;
    158a:	fa 01       	movw	r30, r20
    158c:	31 83       	std	Z+1, r19	; 0x01
    158e:	20 83       	st	Z, r18
	return Size;
}
    1590:	08 95       	ret

00001592 <OpenLogFile>:
			CloseLogFile(); // close log file so a new one can be opened later.
}

/** Opens the log file on the Dataflash's FAT formatted partition according to the current date */
FRESULT OpenLogFile(void)
{
    1592:	cf 93       	push	r28
	
//	if (USB_DeviceState == DEVICE_STATE_Configured){
//		return FR_LOCKED; //the disk is locked if the USB is engaged.  This prevents collision with filesystem read/writes
//	}
	
		diskstatus = f_open(&LogFile, FileName, FA_OPEN_ALWAYS | FA_WRITE);
    1594:	42 e1       	ldi	r20, 0x12	; 18
    1596:	60 e0       	ldi	r22, 0x00	; 0
    1598:	71 e0       	ldi	r23, 0x01	; 1
    159a:	87 eb       	ldi	r24, 0xB7	; 183
    159c:	93 e0       	ldi	r25, 0x03	; 3
    159e:	0e 94 96 1d 	call	0x3b2c	; 0x3b2c <f_open>
		f_sync(&LogFile);
    15a2:	87 eb       	ldi	r24, 0xB7	; 183
    15a4:	93 e0       	ldi	r25, 0x03	; 3
    15a6:	0e 94 4b 20 	call	0x4096	; 0x4096 <f_sync>
		f_close(&LogFile);
    15aa:	87 eb       	ldi	r24, 0xB7	; 183
    15ac:	93 e0       	ldi	r25, 0x03	; 3
    15ae:	0e 94 8c 20 	call	0x4118	; 0x4118 <f_close>
		diskstatus = f_open(&LogFile, FileName, FA_OPEN_ALWAYS | FA_WRITE);
    15b2:	42 e1       	ldi	r20, 0x12	; 18
    15b4:	60 e0       	ldi	r22, 0x00	; 0
    15b6:	71 e0       	ldi	r23, 0x01	; 1
    15b8:	87 eb       	ldi	r24, 0xB7	; 183
    15ba:	93 e0       	ldi	r25, 0x03	; 3
    15bc:	0e 94 96 1d 	call	0x3b2c	; 0x3b2c <f_open>
    15c0:	c8 2f       	mov	r28, r24
		
		f_lseek(&LogFile, LogFile.fsize);
    15c2:	40 91 c1 03 	lds	r20, 0x03C1
    15c6:	50 91 c2 03 	lds	r21, 0x03C2
    15ca:	60 91 c3 03 	lds	r22, 0x03C3
    15ce:	70 91 c4 03 	lds	r23, 0x03C4
    15d2:	87 eb       	ldi	r24, 0xB7	; 183
    15d4:	93 e0       	ldi	r25, 0x03	; 3
    15d6:	0e 94 9c 20 	call	0x4138	; 0x4138 <f_lseek>
	
	return diskstatus;
}
    15da:	8c 2f       	mov	r24, r28
    15dc:	cf 91       	pop	r28
    15de:	08 95       	ret

000015e0 <CloseLogFile>:

/** Closes the open data log file on the Dataflash's FAT formatted partition */
void CloseLogFile(void)
{
	/* Sync any data waiting to be written, unmount the storage device */
	f_sync(&LogFile);
    15e0:	87 eb       	ldi	r24, 0xB7	; 183
    15e2:	93 e0       	ldi	r25, 0x03	; 3
    15e4:	0e 94 4b 20 	call	0x4096	; 0x4096 <f_sync>
	f_close(&LogFile);
    15e8:	87 eb       	ldi	r24, 0xB7	; 183
    15ea:	93 e0       	ldi	r25, 0x03	; 3
    15ec:	0c 94 8c 20 	jmp	0x4118	; 0x4118 <f_close>
    15f0:	08 95       	ret

000015f2 <MountFilesystem>:
}

bool MountFilesystem(){
	bool diskstatus;
	diskstatus = f_mount(&DiskFATState,"",1);
    15f2:	41 e0       	ldi	r20, 0x01	; 1
    15f4:	6a ee       	ldi	r22, 0xEA	; 234
    15f6:	72 e0       	ldi	r23, 0x02	; 2
    15f8:	87 ed       	ldi	r24, 0xD7	; 215
    15fa:	93 e0       	ldi	r25, 0x03	; 3
    15fc:	0e 94 43 1d 	call	0x3a86	; 0x3a86 <f_mount>
    1600:	91 e0       	ldi	r25, 0x01	; 1
    1602:	81 11       	cpse	r24, r1
    1604:	01 c0       	rjmp	.+2      	; 0x1608 <MountFilesystem+0x16>
    1606:	90 e0       	ldi	r25, 0x00	; 0
	return diskstatus;
}
    1608:	89 2f       	mov	r24, r25
    160a:	08 95       	ret

0000160c <get_num_of_sectors>:

uint32_t get_num_of_sectors(){
	static uint32_t tot_sect;
	if(!tot_sect){ //if we have not yet read a valid value into totsect
    160c:	80 91 b3 03 	lds	r24, 0x03B3
    1610:	90 91 b4 03 	lds	r25, 0x03B4
    1614:	a0 91 b5 03 	lds	r26, 0x03B5
    1618:	b0 91 b6 03 	lds	r27, 0x03B6
    161c:	89 2b       	or	r24, r25
    161e:	8a 2b       	or	r24, r26
    1620:	8b 2b       	or	r24, r27
    1622:	c1 f4       	brne	.+48     	; 0x1654 <get_num_of_sectors+0x48>
		tot_sect = (DiskFATState.n_fatent - 2) * DiskFATState.csize;
    1624:	e7 ed       	ldi	r30, 0xD7	; 215
    1626:	f3 e0       	ldi	r31, 0x03	; 3
    1628:	a2 81       	ldd	r26, Z+2	; 0x02
    162a:	42 89       	ldd	r20, Z+18	; 0x12
    162c:	53 89       	ldd	r21, Z+19	; 0x13
    162e:	64 89       	ldd	r22, Z+20	; 0x14
    1630:	75 89       	ldd	r23, Z+21	; 0x15
    1632:	9a 01       	movw	r18, r20
    1634:	ab 01       	movw	r20, r22
    1636:	22 50       	subi	r18, 0x02	; 2
    1638:	31 09       	sbc	r19, r1
    163a:	41 09       	sbc	r20, r1
    163c:	51 09       	sbc	r21, r1
    163e:	b0 e0       	ldi	r27, 0x00	; 0
    1640:	0e 94 2f 39 	call	0x725e	; 0x725e <__muluhisi3>
    1644:	60 93 b3 03 	sts	0x03B3, r22
    1648:	70 93 b4 03 	sts	0x03B4, r23
    164c:	80 93 b5 03 	sts	0x03B5, r24
    1650:	90 93 b6 03 	sts	0x03B6, r25
	}
	return 	tot_sect;
    1654:	60 91 b3 03 	lds	r22, 0x03B3
    1658:	70 91 b4 03 	lds	r23, 0x03B4
    165c:	80 91 b5 03 	lds	r24, 0x03B5
    1660:	90 91 b6 03 	lds	r25, 0x03B6
}
    1664:	08 95       	ret

00001666 <WriteToLogFile>:

bool WriteToLogFile(){
    1666:	ff 92       	push	r15
    1668:	0f 93       	push	r16
    166a:	1f 93       	push	r17
    166c:	cf 93       	push	r28
    166e:	df 93       	push	r29
    1670:	00 d0       	rcall	.+0      	; 0x1672 <WriteToLogFile+0xc>
    1672:	cd b7       	in	r28, 0x3d	; 61
    1674:	de b7       	in	r29, 0x3e	; 62
	UINT BytesWritten;
	uint8_t result;
	
	
	BytesWritten = strlen((char*)SD_Buffer);
    1676:	0a e0       	ldi	r16, 0x0A	; 10
    1678:	18 e0       	ldi	r17, 0x08	; 8
    167a:	f8 01       	movw	r30, r16
    167c:	01 90       	ld	r0, Z+
    167e:	00 20       	and	r0, r0
    1680:	e9 f7       	brne	.-6      	; 0x167c <WriteToLogFile+0x16>
    1682:	31 97       	sbiw	r30, 0x01	; 1
    1684:	ea 50       	subi	r30, 0x0A	; 10
    1686:	f8 40       	sbci	r31, 0x08	; 8
    1688:	fa 83       	std	Y+2, r31	; 0x02
    168a:	e9 83       	std	Y+1, r30	; 0x01
//	BytesWritten = sprintf(SD_Buffer, "TESTINGTESTING/r/n");//debug 
	f_lseek(&LogFile, LogFile.fsize);
    168c:	40 91 c1 03 	lds	r20, 0x03C1
    1690:	50 91 c2 03 	lds	r21, 0x03C2
    1694:	60 91 c3 03 	lds	r22, 0x03C3
    1698:	70 91 c4 03 	lds	r23, 0x03C4
    169c:	87 eb       	ldi	r24, 0xB7	; 183
    169e:	93 e0       	ldi	r25, 0x03	; 3
    16a0:	0e 94 9c 20 	call	0x4138	; 0x4138 <f_lseek>
	result = f_write(&LogFile, (void *) SD_Buffer, BytesWritten, &BytesWritten);
    16a4:	49 81       	ldd	r20, Y+1	; 0x01
    16a6:	5a 81       	ldd	r21, Y+2	; 0x02
    16a8:	9e 01       	movw	r18, r28
    16aa:	2f 5f       	subi	r18, 0xFF	; 255
    16ac:	3f 4f       	sbci	r19, 0xFF	; 255
    16ae:	b8 01       	movw	r22, r16
    16b0:	87 eb       	ldi	r24, 0xB7	; 183
    16b2:	93 e0       	ldi	r25, 0x03	; 3
    16b4:	0e 94 b0 1e 	call	0x3d60	; 0x3d60 <f_write>
    16b8:	f8 2e       	mov	r15, r24
	SD_Buffer[0] = '\0'; //a simple way to clear the buffer (equivalent to saving an empty string into the buffer)
    16ba:	f8 01       	movw	r30, r16
    16bc:	10 82       	st	Z, r1
	f_sync(&LogFile);
    16be:	87 eb       	ldi	r24, 0xB7	; 183
    16c0:	93 e0       	ldi	r25, 0x03	; 3
    16c2:	0e 94 4b 20 	call	0x4096	; 0x4096 <f_sync>
	
	return result;
    16c6:	81 e0       	ldi	r24, 0x01	; 1
    16c8:	f1 10       	cpse	r15, r1
    16ca:	01 c0       	rjmp	.+2      	; 0x16ce <WriteToLogFile+0x68>
    16cc:	80 e0       	ldi	r24, 0x00	; 0
	
}
    16ce:	0f 90       	pop	r0
    16d0:	0f 90       	pop	r0
    16d2:	df 91       	pop	r29
    16d4:	cf 91       	pop	r28
    16d6:	1f 91       	pop	r17
    16d8:	0f 91       	pop	r16
    16da:	ff 90       	pop	r15
    16dc:	08 95       	ret

000016de <TestSDHardware>:

void TestSDHardware(){
    16de:	cf 93       	push	r28
		FRESULT diskstatus;
		
		diskstatus = MountFilesystem();
    16e0:	88 df       	rcall	.-240    	; 0x15f2 <MountFilesystem>
		
		if (diskstatus != FR_OK){
    16e2:	88 23       	and	r24, r24
    16e4:	21 f0       	breq	.+8      	; 0x16ee <TestSDHardware+0x10>
			Typewriter_Mode = PANIC_MODE;
    16e6:	8a e0       	ldi	r24, 0x0A	; 10
    16e8:	80 93 09 08 	sts	0x0809, r24
    16ec:	20 c0       	rjmp	.+64     	; 0x172e <TestSDHardware+0x50>
			return;
		}
		
		strcpy(FileName, "SDHW.TXT");
    16ee:	89 e0       	ldi	r24, 0x09	; 9
    16f0:	e6 ed       	ldi	r30, 0xD6	; 214
    16f2:	f2 e0       	ldi	r31, 0x02	; 2
    16f4:	a0 e0       	ldi	r26, 0x00	; 0
    16f6:	b1 e0       	ldi	r27, 0x01	; 1
    16f8:	01 90       	ld	r0, Z+
    16fa:	0d 92       	st	X+, r0
    16fc:	8a 95       	dec	r24
    16fe:	e1 f7       	brne	.-8      	; 0x16f8 <TestSDHardware+0x1a>
		while(1){
		OpenLogFile();
		strcpy((CHAR*)SD_Buffer,"testphrase\n");
    1700:	cc e0       	ldi	r28, 0x0C	; 12
			return;
		}
		
		strcpy(FileName, "SDHW.TXT");
		while(1){
		OpenLogFile();
    1702:	47 df       	rcall	.-370    	; 0x1592 <OpenLogFile>
		strcpy((CHAR*)SD_Buffer,"testphrase\n");
    1704:	ef ed       	ldi	r30, 0xDF	; 223
    1706:	f2 e0       	ldi	r31, 0x02	; 2
    1708:	aa e0       	ldi	r26, 0x0A	; 10
    170a:	b8 e0       	ldi	r27, 0x08	; 8
    170c:	8c 2f       	mov	r24, r28
    170e:	01 90       	ld	r0, Z+
    1710:	0d 92       	st	X+, r0
    1712:	8a 95       	dec	r24
    1714:	e1 f7       	brne	.-8      	; 0x170e <TestSDHardware+0x30>
		WriteToLogFile();
    1716:	a7 df       	rcall	.-178    	; 0x1666 <WriteToLogFile>
		CloseLogFile();
    1718:	63 df       	rcall	.-314    	; 0x15e0 <CloseLogFile>
    171a:	2f ef       	ldi	r18, 0xFF	; 255
    171c:	80 e7       	ldi	r24, 0x70	; 112
    171e:	92 e0       	ldi	r25, 0x02	; 2
    1720:	21 50       	subi	r18, 0x01	; 1
    1722:	80 40       	sbci	r24, 0x00	; 0
    1724:	90 40       	sbci	r25, 0x00	; 0
    1726:	e1 f7       	brne	.-8      	; 0x1720 <TestSDHardware+0x42>
    1728:	00 c0       	rjmp	.+0      	; 0x172a <TestSDHardware+0x4c>
    172a:	00 00       	nop
    172c:	ea cf       	rjmp	.-44     	; 0x1702 <TestSDHardware+0x24>
		Delay_MS(100);
		}
		
}
    172e:	cf 91       	pop	r28
    1730:	08 95       	ret

00001732 <AddToSDBuffer>:

void AddToSDBuffer(char character){
	UINT index;
	static char prevcharacter;
	
	index = strlen((char*)SD_Buffer); //index is moved to the end of the string saved in the SD_Buffer.
    1732:	ea e0       	ldi	r30, 0x0A	; 10
    1734:	f8 e0       	ldi	r31, 0x08	; 8
    1736:	01 90       	ld	r0, Z+
    1738:	00 20       	and	r0, r0
    173a:	e9 f7       	brne	.-6      	; 0x1736 <AddToSDBuffer+0x4>
    173c:	31 97       	sbiw	r30, 0x01	; 1
    173e:	ea 50       	subi	r30, 0x0A	; 10
    1740:	f8 40       	sbci	r31, 0x08	; 8
	if (index >= SD_BUFFER_LENGTH-10){
    1742:	e6 3f       	cpi	r30, 0xF6	; 246
    1744:	91 e0       	ldi	r25, 0x01	; 1
    1746:	f9 07       	cpc	r31, r25
    1748:	08 f0       	brcs	.+2      	; 0x174c <AddToSDBuffer+0x1a>
    174a:	4b c0       	rjmp	.+150    	; 0x17e2 <AddToSDBuffer+0xb0>
		return; //take no action if SD_Buffer is nearly full.  this could over-write other variables and cause a mess.
	}
	
	if (character == '\r'){ //special treatment for return character
    174c:	8d 30       	cpi	r24, 0x0D	; 13
    174e:	d1 f5       	brne	.+116    	; 0x17c4 <AddToSDBuffer+0x92>
		if(prevcharacter != '\r'){ //if this is first time \r is pressed, insert a space instead, and save to file.
    1750:	90 91 b2 03 	lds	r25, 0x03B2
    1754:	9d 30       	cpi	r25, 0x0D	; 13
    1756:	49 f0       	breq	.+18     	; 0x176a <AddToSDBuffer+0x38>
			SD_Buffer[index] = ' ';
    1758:	df 01       	movw	r26, r30
    175a:	a6 5f       	subi	r26, 0xF6	; 246
    175c:	b7 4f       	sbci	r27, 0xF7	; 247
    175e:	90 e2       	ldi	r25, 0x20	; 32
    1760:	9c 93       	st	X, r25
			SD_Buffer[index+1] = '\0';
    1762:	e5 5f       	subi	r30, 0xF5	; 245
    1764:	f7 4f       	sbci	r31, 0xF7	; 247
    1766:	10 82       	st	Z, r1
    1768:	3a c0       	rjmp	.+116    	; 0x17de <AddToSDBuffer+0xac>
		}
		else if (SD_Buffer[index-1] == ' '){//if a space was inserted last time in place of \r\n, user has pressed return twice.
    176a:	9f 01       	movw	r18, r30
    176c:	21 50       	subi	r18, 0x01	; 1
    176e:	31 09       	sbc	r19, r1
    1770:	d9 01       	movw	r26, r18
    1772:	a6 5f       	subi	r26, 0xF6	; 246
    1774:	b7 4f       	sbci	r27, 0xF7	; 247
    1776:	9c 91       	ld	r25, X
    1778:	90 32       	cpi	r25, 0x20	; 32
    177a:	b1 f4       	brne	.+44     	; 0x17a8 <AddToSDBuffer+0x76>
			SD_Buffer[index-1] = '\r'; //so put the missing \r\n in now
    177c:	d9 01       	movw	r26, r18
    177e:	a6 5f       	subi	r26, 0xF6	; 246
    1780:	b7 4f       	sbci	r27, 0xF7	; 247
    1782:	4d e0       	ldi	r20, 0x0D	; 13
    1784:	4c 93       	st	X, r20
			SD_Buffer[index] = '\n';
    1786:	df 01       	movw	r26, r30
    1788:	a6 5f       	subi	r26, 0xF6	; 246
    178a:	b7 4f       	sbci	r27, 0xF7	; 247
    178c:	9a e0       	ldi	r25, 0x0A	; 10
    178e:	9c 93       	st	X, r25
			SD_Buffer[index+1] = '\r';
    1790:	df 01       	movw	r26, r30
    1792:	a5 5f       	subi	r26, 0xF5	; 245
    1794:	b7 4f       	sbci	r27, 0xF7	; 247
    1796:	4c 93       	st	X, r20
			SD_Buffer[index+2] = '\n';
    1798:	df 01       	movw	r26, r30
    179a:	a4 5f       	subi	r26, 0xF4	; 244
    179c:	b7 4f       	sbci	r27, 0xF7	; 247
    179e:	9c 93       	st	X, r25
			SD_Buffer[index+3] = '\0';
    17a0:	e3 5f       	subi	r30, 0xF3	; 243
    17a2:	f7 4f       	sbci	r31, 0xF7	; 247
    17a4:	10 82       	st	Z, r1
    17a6:	1b c0       	rjmp	.+54     	; 0x17de <AddToSDBuffer+0xac>
		}
		else { //but if the last character entered was not recorded as a space (\r has already been pressed several times), then call a spade a spade.
			SD_Buffer[index] = '\r';
    17a8:	df 01       	movw	r26, r30
    17aa:	a6 5f       	subi	r26, 0xF6	; 246
    17ac:	b7 4f       	sbci	r27, 0xF7	; 247
    17ae:	9d e0       	ldi	r25, 0x0D	; 13
    17b0:	9c 93       	st	X, r25
			SD_Buffer[index+1] = '\n';
    17b2:	df 01       	movw	r26, r30
    17b4:	a5 5f       	subi	r26, 0xF5	; 245
    17b6:	b7 4f       	sbci	r27, 0xF7	; 247
    17b8:	9a e0       	ldi	r25, 0x0A	; 10
    17ba:	9c 93       	st	X, r25
			SD_Buffer[index+2] = '\0';
    17bc:	e4 5f       	subi	r30, 0xF4	; 244
    17be:	f7 4f       	sbci	r31, 0xF7	; 247
    17c0:	10 82       	st	Z, r1
    17c2:	0d c0       	rjmp	.+26     	; 0x17de <AddToSDBuffer+0xac>
		}
	}
	else if (character == '\b'){ //for a backspace character,
    17c4:	88 30       	cpi	r24, 0x08	; 8
    17c6:	21 f4       	brne	.+8      	; 0x17d0 <AddToSDBuffer+0x9e>
		SD_Buffer[index-1] = '\0'; //turn the previous character into an "end of string" character 
    17c8:	e7 5f       	subi	r30, 0xF7	; 247
    17ca:	f7 4f       	sbci	r31, 0xF7	; 247
    17cc:	10 82       	st	Z, r1
    17ce:	07 c0       	rjmp	.+14     	; 0x17de <AddToSDBuffer+0xac>
	}
	else{ //the most common scenario -- put a character at the end of the buffer, then follow with a \0;
		SD_Buffer[index] = character;
    17d0:	df 01       	movw	r26, r30
    17d2:	a6 5f       	subi	r26, 0xF6	; 246
    17d4:	b7 4f       	sbci	r27, 0xF7	; 247
    17d6:	8c 93       	st	X, r24
		SD_Buffer[index+1] = '\0';
    17d8:	e5 5f       	subi	r30, 0xF5	; 245
    17da:	f7 4f       	sbci	r31, 0xF7	; 247
    17dc:	10 82       	st	Z, r1
	}
	
	prevcharacter = character; // save the character just pressed.
    17de:	80 93 b2 03 	sts	0x03B2, r24
    17e2:	08 95       	ret

000017e4 <LogKeystrokes>:
static FATFS DiskFATState;

/** FAT Fs structure to hold a FAT file handle for the log data write destination. */
static FIL LogFile;

void LogKeystrokes(){
    17e4:	cf 92       	push	r12
    17e6:	df 92       	push	r13
    17e8:	ef 92       	push	r14
    17ea:	ff 92       	push	r15
    17ec:	0f 93       	push	r16
    17ee:	1f 93       	push	r17
    17f0:	cf 93       	push	r28
    17f2:	df 93       	push	r29
    17f4:	cd b7       	in	r28, 0x3d	; 61
    17f6:	de b7       	in	r29, 0x3e	; 62
    17f8:	66 97       	sbiw	r28, 0x16	; 22
    17fa:	0f b6       	in	r0, 0x3f	; 63
    17fc:	f8 94       	cli
    17fe:	de bf       	out	0x3e, r29	; 62
    1800:	0f be       	out	0x3f, r0	; 63
    1802:	cd bf       	out	0x3d, r28	; 61
	uint16_t filenum;
	uint8_t code = 0;
	uint8_t modifier;
	uint8_t key;
	
	SD_Buffer[0] = '\0'; // A simple way to erase the SD_Buffer string -- first character is now the end of the string;
    1804:	10 92 0a 08 	sts	0x080A, r1

	diskstatus = MountFilesystem();
    1808:	f4 de       	rcall	.-536    	; 0x15f2 <MountFilesystem>
	
	if (diskstatus != FR_OK){
    180a:	88 23       	and	r24, r24
    180c:	21 f0       	breq	.+8      	; 0x1816 <LogKeystrokes+0x32>
		Typewriter_Mode = PANIC_MODE;
    180e:	8a e0       	ldi	r24, 0x0A	; 10
    1810:	80 93 09 08 	sts	0x0809, r24
		return;
    1814:	bb c0       	rjmp	.+374    	; 0x198c <LogKeystrokes+0x1a8>
	}
	else{
		GlowGreenLED(VERY_SLOW,SOLID);
    1816:	61 e0       	ldi	r22, 0x01	; 1
    1818:	80 e0       	ldi	r24, 0x00	; 0
    181a:	e5 dd       	rcall	.-1078   	; 0x13e6 <GlowGreenLED>
	}
	
	filenum = eeprom_read_word((uint16_t *)FILENUM_ADDR); //filenum is the last used filenum, plus 1;
    181c:	8a e0       	ldi	r24, 0x0A	; 10
    181e:	92 e0       	ldi	r25, 0x02	; 2
    1820:	0e 94 bd 3c 	call	0x797a	; 0x797a <eeprom_read_word>
    1824:	8c 01       	movw	r16, r24
	
	if (filenum>9999){
    1826:	80 31       	cpi	r24, 0x10	; 16
    1828:	97 42       	sbci	r25, 0x27	; 39
    182a:	10 f0       	brcs	.+4      	; 0x1830 <LogKeystrokes+0x4c>
		filenum = 0;
    182c:	00 e0       	ldi	r16, 0x00	; 0
    182e:	10 e0       	ldi	r17, 0x00	; 0
	} //filenum can only be 4 digits long.

	do{ //increment filenum until a file name is found that does not already exist ("no file" error)
		filenum++; //increment file number
		sprintf(FileName,"PAGE%04d.TXT",filenum); //filename can only be 8 characters long (not including .TXT).
    1830:	0f 2e       	mov	r0, r31
    1832:	fb ee       	ldi	r31, 0xEB	; 235
    1834:	cf 2e       	mov	r12, r31
    1836:	f2 e0       	ldi	r31, 0x02	; 2
    1838:	df 2e       	mov	r13, r31
    183a:	f0 2d       	mov	r31, r0
    183c:	0f 2e       	mov	r0, r31
    183e:	f0 e0       	ldi	r31, 0x00	; 0
    1840:	ef 2e       	mov	r14, r31
    1842:	f1 e0       	ldi	r31, 0x01	; 1
    1844:	ff 2e       	mov	r15, r31
    1846:	f0 2d       	mov	r31, r0
	if (filenum>9999){
		filenum = 0;
	} //filenum can only be 4 digits long.

	do{ //increment filenum until a file name is found that does not already exist ("no file" error)
		filenum++; //increment file number
    1848:	0f 5f       	subi	r16, 0xFF	; 255
    184a:	1f 4f       	sbci	r17, 0xFF	; 255
		sprintf(FileName,"PAGE%04d.TXT",filenum); //filename can only be 8 characters long (not including .TXT).
    184c:	1f 93       	push	r17
    184e:	0f 93       	push	r16
    1850:	df 92       	push	r13
    1852:	cf 92       	push	r12
    1854:	ff 92       	push	r15
    1856:	ef 92       	push	r14
    1858:	0e 94 16 3a 	call	0x742c	; 0x742c <sprintf>
		filestatus = f_stat(FileName, &fileinfo);
    185c:	be 01       	movw	r22, r28
    185e:	6f 5f       	subi	r22, 0xFF	; 255
    1860:	7f 4f       	sbci	r23, 0xFF	; 255
    1862:	c7 01       	movw	r24, r14
    1864:	0e 94 53 22 	call	0x44a6	; 0x44a6 <f_stat>
	}while(filestatus == FR_OK); //at the end of this loop, FileName is unique
    1868:	0f 90       	pop	r0
    186a:	0f 90       	pop	r0
    186c:	0f 90       	pop	r0
    186e:	0f 90       	pop	r0
    1870:	0f 90       	pop	r0
    1872:	0f 90       	pop	r0
    1874:	88 23       	and	r24, r24
    1876:	41 f3       	breq	.-48     	; 0x1848 <LogKeystrokes+0x64>
	
	if (filestatus != FR_NO_FILE){ //if the error was not "no file" something went wrong
    1878:	84 30       	cpi	r24, 0x04	; 4
    187a:	21 f0       	breq	.+8      	; 0x1884 <LogKeystrokes+0xa0>
		Typewriter_Mode = PANIC_MODE; // go into panic mode
    187c:	8a e0       	ldi	r24, 0x0A	; 10
    187e:	80 93 09 08 	sts	0x0809, r24
		return;
    1882:	84 c0       	rjmp	.+264    	; 0x198c <LogKeystrokes+0x1a8>
	}
	
	while(!code){ // wait for a key to be pressed before actually opening the file -- this stops lots of empty files from being created
		key = GetKey();
    1884:	0e 94 d1 2b 	call	0x57a2	; 0x57a2 <GetKey>
    1888:	f8 2e       	mov	r15, r24
		modifier = GetModifier();
    188a:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
		code = GetASCIIKeyCode(key,modifier);
    188e:	68 2f       	mov	r22, r24
    1890:	8f 2d       	mov	r24, r15
    1892:	0e 94 67 2d 	call	0x5ace	; 0x5ace <GetASCIIKeyCode>
	if (filestatus != FR_NO_FILE){ //if the error was not "no file" something went wrong
		Typewriter_Mode = PANIC_MODE; // go into panic mode
		return;
	}
	
	while(!code){ // wait for a key to be pressed before actually opening the file -- this stops lots of empty files from being created
    1896:	88 23       	and	r24, r24
    1898:	a9 f3       	breq	.-22     	; 0x1884 <LogKeystrokes+0xa0>
		key = GetKey();
		modifier = GetModifier();
		code = GetASCIIKeyCode(key,modifier);
	}
	
	AddToSDBuffer(code); //save this first key pressed to the buffer.  there will be more, and those will be handled in the main loop
    189a:	4b df       	rcall	.-362    	; 0x1732 <AddToSDBuffer>

	if (OpenLogFile()!=FR_OK){ //open the new log file.
    189c:	7a de       	rcall	.-780    	; 0x1592 <OpenLogFile>
    189e:	88 23       	and	r24, r24
    18a0:	21 f0       	breq	.+8      	; 0x18aa <LogKeystrokes+0xc6>
		Typewriter_Mode = PANIC_MODE; // go into panic mode
    18a2:	8a e0       	ldi	r24, 0x0A	; 10
    18a4:	80 93 09 08 	sts	0x0809, r24
		return;
    18a8:	71 c0       	rjmp	.+226    	; 0x198c <LogKeystrokes+0x1a8>
	}
	
	eeprom_write_word((uint16_t *)FILENUM_ADDR,filenum); // save the new filenumber for next time
    18aa:	b8 01       	movw	r22, r16
    18ac:	8a e0       	ldi	r24, 0x0A	; 10
    18ae:	92 e0       	ldi	r25, 0x02	; 2
    18b0:	0e 94 eb 3c 	call	0x79d6	; 0x79d6 <eeprom_write_word>
	
	TimeoutCounter = 0; //reset timeout
    18b4:	10 92 08 08 	sts	0x0808, r1
    18b8:	10 92 07 08 	sts	0x0807, r1
				GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
				WriteToLogFile(); //save your work every time enter key is pressed.
			}
			Delay_MS(SENSE_DELAY);
			
			if ((TimeoutCounter > SD_SAVE_TIME) && (SD_Buffer[0] != '\0')){
    18bc:	0f 2e       	mov	r0, r31
    18be:	fa e0       	ldi	r31, 0x0A	; 10
    18c0:	ef 2e       	mov	r14, r31
    18c2:	f8 e0       	ldi	r31, 0x08	; 8
    18c4:	ff 2e       	mov	r15, r31
    18c6:	f0 2d       	mov	r31, r0
	
	eeprom_write_word((uint16_t *)FILENUM_ADDR,filenum); // save the new filenumber for next time
	
	TimeoutCounter = 0; //reset timeout

	while(TimeoutCounter < (SD_TIMEOUT)){ //keep listening for keys and adding them to buffer. Clear buffer occassionally.
    18c8:	49 c0       	rjmp	.+146    	; 0x195c <LogKeystrokes+0x178>
			key = GetKey();
    18ca:	0e 94 d1 2b 	call	0x57a2	; 0x57a2 <GetKey>
    18ce:	18 2f       	mov	r17, r24
			modifier = GetModifier();
    18d0:	0e 94 9e 2a 	call	0x553c	; 0x553c <GetModifier>
			
			code = GetASCIIKeyCode(key, modifier);
    18d4:	68 2f       	mov	r22, r24
    18d6:	81 2f       	mov	r24, r17
    18d8:	0e 94 67 2d 	call	0x5ace	; 0x5ace <GetASCIIKeyCode>
    18dc:	18 2f       	mov	r17, r24
			
			if(code){
    18de:	88 23       	and	r24, r24
    18e0:	01 f1       	breq	.+64     	; 0x1922 <LogKeystrokes+0x13e>
				if ((code == 's') && Ignore_Flag) code = 0; //if user is holding down S on startup, don't add this to file.
    18e2:	83 37       	cpi	r24, 0x73	; 115
    18e4:	29 f4       	brne	.+10     	; 0x18f0 <LogKeystrokes+0x10c>
    18e6:	80 91 02 07 	lds	r24, 0x0702
    18ea:	81 11       	cpse	r24, r1
    18ec:	45 c0       	rjmp	.+138    	; 0x1978 <LogKeystrokes+0x194>
    18ee:	45 c0       	rjmp	.+138    	; 0x197a <LogKeystrokes+0x196>
				Ignore_Flag = 0;
    18f0:	10 92 02 07 	sts	0x0702, r1
				AddToSDBuffer(code); //this adds the character to the sd write buffer.
    18f4:	1e df       	rcall	.-452    	; 0x1732 <AddToSDBuffer>
				TimeoutCounter = 0; //reset timeout every time a key is pressed.
    18f6:	10 92 08 08 	sts	0x0808, r1
    18fa:	10 92 07 08 	sts	0x0807, r1
			}
			if((code == '\r')||(code == '.')||(code == ',')||(code == '!')||(code == '?')||(code == ':')||(code == '\"')){
    18fe:	1d 30       	cpi	r17, 0x0D	; 13
    1900:	61 f0       	breq	.+24     	; 0x191a <LogKeystrokes+0x136>
    1902:	81 2f       	mov	r24, r17
    1904:	8d 7f       	andi	r24, 0xFD	; 253
    1906:	8c 32       	cpi	r24, 0x2C	; 44
    1908:	41 f0       	breq	.+16     	; 0x191a <LogKeystrokes+0x136>
    190a:	8f ed       	ldi	r24, 0xDF	; 223
    190c:	81 0f       	add	r24, r17
    190e:	82 30       	cpi	r24, 0x02	; 2
    1910:	20 f0       	brcs	.+8      	; 0x191a <LogKeystrokes+0x136>
    1912:	1f 33       	cpi	r17, 0x3F	; 63
    1914:	11 f0       	breq	.+4      	; 0x191a <LogKeystrokes+0x136>
    1916:	1a 33       	cpi	r17, 0x3A	; 58
    1918:	21 f4       	brne	.+8      	; 0x1922 <LogKeystrokes+0x13e>
				GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
    191a:	60 e0       	ldi	r22, 0x00	; 0
    191c:	82 e0       	ldi	r24, 0x02	; 2
    191e:	63 dd       	rcall	.-1338   	; 0x13e6 <GlowGreenLED>
				WriteToLogFile(); //save your work every time enter key is pressed.
    1920:	a2 de       	rcall	.-700    	; 0x1666 <WriteToLogFile>
    1922:	8f ec       	ldi	r24, 0xCF	; 207
    1924:	97 e0       	ldi	r25, 0x07	; 7
    1926:	01 97       	sbiw	r24, 0x01	; 1
    1928:	f1 f7       	brne	.-4      	; 0x1926 <LogKeystrokes+0x142>
    192a:	00 c0       	rjmp	.+0      	; 0x192c <LogKeystrokes+0x148>
    192c:	00 00       	nop
			}
			Delay_MS(SENSE_DELAY);
			
			if ((TimeoutCounter > SD_SAVE_TIME) && (SD_Buffer[0] != '\0')){
    192e:	80 91 07 08 	lds	r24, 0x0807
    1932:	90 91 08 08 	lds	r25, 0x0808
    1936:	81 37       	cpi	r24, 0x71	; 113
    1938:	97 41       	sbci	r25, 0x17	; 23
    193a:	80 f0       	brcs	.+32     	; 0x195c <LogKeystrokes+0x178>
    193c:	f7 01       	movw	r30, r14
    193e:	80 81       	ld	r24, Z
    1940:	88 23       	and	r24, r24
    1942:	61 f0       	breq	.+24     	; 0x195c <LogKeystrokes+0x178>
				set_low(GREEN_LED);
    1944:	46 98       	cbi	0x08, 6	; 8
    1946:	ff ef       	ldi	r31, 0xFF	; 255
    1948:	2d e3       	ldi	r18, 0x3D	; 61
    194a:	89 e4       	ldi	r24, 0x49	; 73
    194c:	f1 50       	subi	r31, 0x01	; 1
    194e:	20 40       	sbci	r18, 0x00	; 0
    1950:	80 40       	sbci	r24, 0x00	; 0
    1952:	e1 f7       	brne	.-8      	; 0x194c <LogKeystrokes+0x168>
    1954:	00 c0       	rjmp	.+0      	; 0x1956 <LogKeystrokes+0x172>
    1956:	00 00       	nop
				Delay_MS(3000);
				WriteToLogFile();
    1958:	86 de       	rcall	.-756    	; 0x1666 <WriteToLogFile>
				set_high(GREEN_LED);
    195a:	46 9a       	sbi	0x08, 6	; 8
	
	eeprom_write_word((uint16_t *)FILENUM_ADDR,filenum); // save the new filenumber for next time
	
	TimeoutCounter = 0; //reset timeout

	while(TimeoutCounter < (SD_TIMEOUT)){ //keep listening for keys and adding them to buffer. Clear buffer occassionally.
    195c:	80 91 07 08 	lds	r24, 0x0807
    1960:	90 91 08 08 	lds	r25, 0x0808
    1964:	80 32       	cpi	r24, 0x20	; 32
    1966:	9f 4b       	sbci	r25, 0xBF	; 191
    1968:	08 f4       	brcc	.+2      	; 0x196c <LogKeystrokes+0x188>
    196a:	af cf       	rjmp	.-162    	; 0x18ca <LogKeystrokes+0xe6>
				WriteToLogFile();
				set_high(GREEN_LED);
			}
	}
	
			GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
    196c:	60 e0       	ldi	r22, 0x00	; 0
    196e:	82 e0       	ldi	r24, 0x02	; 2
    1970:	3a dd       	rcall	.-1420   	; 0x13e6 <GlowGreenLED>
			WriteToLogFile(); //save your work then "sleep" -- stop recording keystrokes
    1972:	79 de       	rcall	.-782    	; 0x1666 <WriteToLogFile>
			CloseLogFile(); // close log file so a new one can be opened later.
    1974:	35 de       	rcall	.-918    	; 0x15e0 <CloseLogFile>
    1976:	0a c0       	rjmp	.+20     	; 0x198c <LogKeystrokes+0x1a8>
			modifier = GetModifier();
			
			code = GetASCIIKeyCode(key, modifier);
			
			if(code){
				if ((code == 's') && Ignore_Flag) code = 0; //if user is holding down S on startup, don't add this to file.
    1978:	10 e0       	ldi	r17, 0x00	; 0
				Ignore_Flag = 0;
    197a:	10 92 02 07 	sts	0x0702, r1
				AddToSDBuffer(code); //this adds the character to the sd write buffer.
    197e:	81 2f       	mov	r24, r17
    1980:	d8 de       	rcall	.-592    	; 0x1732 <AddToSDBuffer>
				TimeoutCounter = 0; //reset timeout every time a key is pressed.
    1982:	10 92 08 08 	sts	0x0808, r1
    1986:	10 92 07 08 	sts	0x0807, r1
    198a:	bb cf       	rjmp	.-138    	; 0x1902 <LogKeystrokes+0x11e>
	}
	
			GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
			WriteToLogFile(); //save your work then "sleep" -- stop recording keystrokes
			CloseLogFile(); // close log file so a new one can be opened later.
}
    198c:	66 96       	adiw	r28, 0x16	; 22
    198e:	0f b6       	in	r0, 0x3f	; 63
    1990:	f8 94       	cli
    1992:	de bf       	out	0x3e, r29	; 62
    1994:	0f be       	out	0x3f, r0	; 63
    1996:	cd bf       	out	0x3d, r28	; 61
    1998:	df 91       	pop	r29
    199a:	cf 91       	pop	r28
    199c:	1f 91       	pop	r17
    199e:	0f 91       	pop	r16
    19a0:	ff 90       	pop	r15
    19a2:	ef 90       	pop	r14
    19a4:	df 90       	pop	r13
    19a6:	cf 90       	pop	r12
    19a8:	08 95       	ret

000019aa <dly_us>:

static
void dly_us (UINT n)	/* Delay n microseconds (avr-gcc -Os) */
{
	do {
		PINB;
    19aa:	23 b1       	in	r18, 0x03	; 3
		PINB;
    19ac:	23 b1       	in	r18, 0x03	; 3
		 //PINB is a throwaway command that wastes one op cycle.  1 PINB commands is recommended for 8MHZ clock.  We can lengthen this or randomize this for EMC reasons.
	} while (--n);
    19ae:	01 97       	sbiw	r24, 0x01	; 1
    19b0:	e1 f7       	brne	.-8      	; 0x19aa <dly_us>
}
    19b2:	08 95       	ret

000019b4 <xmit_mmc>:
static
void xmit_mmc (
	const BYTE* buff,	/* Data to be sent */
	UINT bc				/* Number of bytes to send */
)
{
    19b4:	fc 01       	movw	r30, r24
    19b6:	68 0f       	add	r22, r24
    19b8:	79 1f       	adc	r23, r25
	BYTE d;


	do {
		d = *buff++;	/* Get a byte to be sent */
    19ba:	91 91       	ld	r25, Z+
		if (d & 0x80) DI_H(); else DI_L();	/* bit7 */
    19bc:	99 23       	and	r25, r25
    19be:	14 f4       	brge	.+4      	; 0x19c4 <xmit_mmc+0x10>
    19c0:	2a 9a       	sbi	0x05, 2	; 5
    19c2:	01 c0       	rjmp	.+2      	; 0x19c6 <xmit_mmc+0x12>
    19c4:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    19c6:	29 9a       	sbi	0x05, 1	; 5
    19c8:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x40) DI_H(); else DI_L();	/* bit6 */
    19ca:	96 ff       	sbrs	r25, 6
    19cc:	02 c0       	rjmp	.+4      	; 0x19d2 <xmit_mmc+0x1e>
    19ce:	2a 9a       	sbi	0x05, 2	; 5
    19d0:	01 c0       	rjmp	.+2      	; 0x19d4 <xmit_mmc+0x20>
    19d2:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    19d4:	29 9a       	sbi	0x05, 1	; 5
    19d6:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x20) DI_H(); else DI_L();	/* bit5 */
    19d8:	95 ff       	sbrs	r25, 5
    19da:	02 c0       	rjmp	.+4      	; 0x19e0 <xmit_mmc+0x2c>
    19dc:	2a 9a       	sbi	0x05, 2	; 5
    19de:	01 c0       	rjmp	.+2      	; 0x19e2 <xmit_mmc+0x2e>
    19e0:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    19e2:	29 9a       	sbi	0x05, 1	; 5
    19e4:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x10) DI_H(); else DI_L();	/* bit4 */
    19e6:	94 ff       	sbrs	r25, 4
    19e8:	02 c0       	rjmp	.+4      	; 0x19ee <xmit_mmc+0x3a>
    19ea:	2a 9a       	sbi	0x05, 2	; 5
    19ec:	01 c0       	rjmp	.+2      	; 0x19f0 <xmit_mmc+0x3c>
    19ee:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    19f0:	29 9a       	sbi	0x05, 1	; 5
    19f2:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x08) DI_H(); else DI_L();	/* bit3 */
    19f4:	93 ff       	sbrs	r25, 3
    19f6:	02 c0       	rjmp	.+4      	; 0x19fc <xmit_mmc+0x48>
    19f8:	2a 9a       	sbi	0x05, 2	; 5
    19fa:	01 c0       	rjmp	.+2      	; 0x19fe <xmit_mmc+0x4a>
    19fc:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    19fe:	29 9a       	sbi	0x05, 1	; 5
    1a00:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x04) DI_H(); else DI_L();	/* bit2 */
    1a02:	92 ff       	sbrs	r25, 2
    1a04:	02 c0       	rjmp	.+4      	; 0x1a0a <xmit_mmc+0x56>
    1a06:	2a 9a       	sbi	0x05, 2	; 5
    1a08:	01 c0       	rjmp	.+2      	; 0x1a0c <xmit_mmc+0x58>
    1a0a:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1a0c:	29 9a       	sbi	0x05, 1	; 5
    1a0e:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x02) DI_H(); else DI_L();	/* bit1 */
    1a10:	91 ff       	sbrs	r25, 1
    1a12:	02 c0       	rjmp	.+4      	; 0x1a18 <xmit_mmc+0x64>
    1a14:	2a 9a       	sbi	0x05, 2	; 5
    1a16:	01 c0       	rjmp	.+2      	; 0x1a1a <xmit_mmc+0x66>
    1a18:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1a1a:	29 9a       	sbi	0x05, 1	; 5
    1a1c:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x01) DI_H(); else DI_L();	/* bit0 */
    1a1e:	90 ff       	sbrs	r25, 0
    1a20:	02 c0       	rjmp	.+4      	; 0x1a26 <xmit_mmc+0x72>
    1a22:	2a 9a       	sbi	0x05, 2	; 5
    1a24:	01 c0       	rjmp	.+2      	; 0x1a28 <xmit_mmc+0x74>
    1a26:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1a28:	29 9a       	sbi	0x05, 1	; 5
    1a2a:	29 98       	cbi	0x05, 1	; 5
	} while (--bc);
    1a2c:	e6 17       	cp	r30, r22
    1a2e:	f7 07       	cpc	r31, r23
    1a30:	21 f6       	brne	.-120    	; 0x19ba <xmit_mmc+0x6>
}
    1a32:	08 95       	ret

00001a34 <rcvr_mmc>:
)
{
	BYTE r;


	DI_H();	/* Send 0xFF */
    1a34:	2a 9a       	sbi	0x05, 2	; 5
    1a36:	fc 01       	movw	r30, r24
    1a38:	68 0f       	add	r22, r24
    1a3a:	79 1f       	adc	r23, r25

	do {
		r = 0;	 if (DO) r++;	/* bit7 */
    1a3c:	93 b1       	in	r25, 0x03	; 3
		CK_H(); CK_L();
    1a3e:	29 9a       	sbi	0x05, 1	; 5
    1a40:	29 98       	cbi	0x05, 1	; 5


	DI_H();	/* Send 0xFF */

	do {
		r = 0;	 if (DO) r++;	/* bit7 */
    1a42:	93 fb       	bst	r25, 3
    1a44:	99 27       	eor	r25, r25
    1a46:	90 f9       	bld	r25, 0
		CK_H(); CK_L();
		r <<= 1; if (DO) r++;	/* bit6 */
    1a48:	99 0f       	add	r25, r25
    1a4a:	1b 99       	sbic	0x03, 3	; 3
    1a4c:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a4e:	29 9a       	sbi	0x05, 1	; 5
    1a50:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit5 */
    1a52:	99 0f       	add	r25, r25
    1a54:	1b 99       	sbic	0x03, 3	; 3
    1a56:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a58:	29 9a       	sbi	0x05, 1	; 5
    1a5a:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit4 */
    1a5c:	99 0f       	add	r25, r25
    1a5e:	1b 99       	sbic	0x03, 3	; 3
    1a60:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a62:	29 9a       	sbi	0x05, 1	; 5
    1a64:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit3 */
    1a66:	99 0f       	add	r25, r25
    1a68:	1b 99       	sbic	0x03, 3	; 3
    1a6a:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a6c:	29 9a       	sbi	0x05, 1	; 5
    1a6e:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit2 */
    1a70:	99 0f       	add	r25, r25
    1a72:	1b 99       	sbic	0x03, 3	; 3
    1a74:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a76:	29 9a       	sbi	0x05, 1	; 5
    1a78:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit1 */
    1a7a:	99 0f       	add	r25, r25
    1a7c:	1b 99       	sbic	0x03, 3	; 3
    1a7e:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a80:	29 9a       	sbi	0x05, 1	; 5
    1a82:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit0 */
    1a84:	99 0f       	add	r25, r25
    1a86:	1b 99       	sbic	0x03, 3	; 3
    1a88:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a8a:	29 9a       	sbi	0x05, 1	; 5
    1a8c:	29 98       	cbi	0x05, 1	; 5
		*buff++ = r;			/* Store a received byte */
    1a8e:	91 93       	st	Z+, r25
	} while (--bc);
    1a90:	e6 17       	cp	r30, r22
    1a92:	f7 07       	cpc	r31, r23
    1a94:	99 f6       	brne	.-90     	; 0x1a3c <rcvr_mmc+0x8>
}
    1a96:	08 95       	ret

00001a98 <wait_ready>:
/* Wait for card ready                                                   */
/*-----------------------------------------------------------------------*/

static
int wait_ready (void)	/* 1:OK, 0:Timeout */
{
    1a98:	0f 93       	push	r16
    1a9a:	1f 93       	push	r17
    1a9c:	cf 93       	push	r28
    1a9e:	df 93       	push	r29
    1aa0:	1f 92       	push	r1
    1aa2:	cd b7       	in	r28, 0x3d	; 61
    1aa4:	de b7       	in	r29, 0x3e	; 62
	BYTE d;
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
    1aa6:	08 e8       	ldi	r16, 0x88	; 136
    1aa8:	13 e1       	ldi	r17, 0x13	; 19
		rcvr_mmc(&d, 1);
    1aaa:	61 e0       	ldi	r22, 0x01	; 1
    1aac:	70 e0       	ldi	r23, 0x00	; 0
    1aae:	ce 01       	movw	r24, r28
    1ab0:	01 96       	adiw	r24, 0x01	; 1
    1ab2:	c0 df       	rcall	.-128    	; 0x1a34 <rcvr_mmc>
		if (d == 0xFF) break;
    1ab4:	89 81       	ldd	r24, Y+1	; 0x01
    1ab6:	8f 3f       	cpi	r24, 0xFF	; 255
    1ab8:	31 f0       	breq	.+12     	; 0x1ac6 <wait_ready+0x2e>
		dly_us(100);
    1aba:	84 e6       	ldi	r24, 0x64	; 100
    1abc:	90 e0       	ldi	r25, 0x00	; 0
    1abe:	75 df       	rcall	.-278    	; 0x19aa <dly_us>
{
	BYTE d;
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
    1ac0:	01 50       	subi	r16, 0x01	; 1
    1ac2:	11 09       	sbc	r17, r1
    1ac4:	91 f7       	brne	.-28     	; 0x1aaa <wait_ready+0x12>
		rcvr_mmc(&d, 1);
		if (d == 0xFF) break;
		dly_us(100);
	}

	return tmr ? 1 : 0;
    1ac6:	81 e0       	ldi	r24, 0x01	; 1
    1ac8:	90 e0       	ldi	r25, 0x00	; 0
    1aca:	01 2b       	or	r16, r17
    1acc:	11 f4       	brne	.+4      	; 0x1ad2 <wait_ready+0x3a>
    1ace:	80 e0       	ldi	r24, 0x00	; 0
    1ad0:	90 e0       	ldi	r25, 0x00	; 0
}
    1ad2:	0f 90       	pop	r0
    1ad4:	df 91       	pop	r29
    1ad6:	cf 91       	pop	r28
    1ad8:	1f 91       	pop	r17
    1ada:	0f 91       	pop	r16
    1adc:	08 95       	ret

00001ade <deselect>:
/* Deselect the card and release SPI bus                                 */
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
    1ade:	cf 93       	push	r28
    1ae0:	df 93       	push	r29
    1ae2:	1f 92       	push	r1
    1ae4:	cd b7       	in	r28, 0x3d	; 61
    1ae6:	de b7       	in	r29, 0x3e	; 62
	BYTE d;

	CS_H();
    1ae8:	59 9a       	sbi	0x0b, 1	; 11
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
    1aea:	61 e0       	ldi	r22, 0x01	; 1
    1aec:	70 e0       	ldi	r23, 0x00	; 0
    1aee:	ce 01       	movw	r24, r28
    1af0:	01 96       	adiw	r24, 0x01	; 1
    1af2:	a0 df       	rcall	.-192    	; 0x1a34 <rcvr_mmc>
}
    1af4:	0f 90       	pop	r0
    1af6:	df 91       	pop	r29
    1af8:	cf 91       	pop	r28
    1afa:	08 95       	ret

00001afc <select>:
/* Select the card and wait for ready                                    */
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
    1afc:	0f 93       	push	r16
    1afe:	1f 93       	push	r17
    1b00:	cf 93       	push	r28
    1b02:	df 93       	push	r29
    1b04:	1f 92       	push	r1
    1b06:	cd b7       	in	r28, 0x3d	; 61
    1b08:	de b7       	in	r29, 0x3e	; 62
	BYTE d;

	CS_L();
    1b0a:	59 98       	cbi	0x0b, 1	; 11
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO enabled) */
    1b0c:	61 e0       	ldi	r22, 0x01	; 1
    1b0e:	70 e0       	ldi	r23, 0x00	; 0
    1b10:	ce 01       	movw	r24, r28
    1b12:	01 96       	adiw	r24, 0x01	; 1
    1b14:	8f df       	rcall	.-226    	; 0x1a34 <rcvr_mmc>

	if (wait_ready()) return 1;	/* OK */
    1b16:	c0 df       	rcall	.-128    	; 0x1a98 <wait_ready>
    1b18:	8c 01       	movw	r16, r24
    1b1a:	89 2b       	or	r24, r25
    1b1c:	11 f4       	brne	.+4      	; 0x1b22 <select+0x26>
	deselect();
    1b1e:	df df       	rcall	.-66     	; 0x1ade <deselect>
	return 0;			/* Failed */
    1b20:	02 c0       	rjmp	.+4      	; 0x1b26 <select+0x2a>
	BYTE d;

	CS_L();
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO enabled) */

	if (wait_ready()) return 1;	/* OK */
    1b22:	01 e0       	ldi	r16, 0x01	; 1
    1b24:	10 e0       	ldi	r17, 0x00	; 0
	deselect();
	return 0;			/* Failed */
}
    1b26:	c8 01       	movw	r24, r16
    1b28:	0f 90       	pop	r0
    1b2a:	df 91       	pop	r29
    1b2c:	cf 91       	pop	r28
    1b2e:	1f 91       	pop	r17
    1b30:	0f 91       	pop	r16
    1b32:	08 95       	ret

00001b34 <rcvr_datablock>:
static
int rcvr_datablock (	/* 1:OK, 0:Failed */
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count */
)
{
    1b34:	cf 92       	push	r12
    1b36:	df 92       	push	r13
    1b38:	ef 92       	push	r14
    1b3a:	ff 92       	push	r15
    1b3c:	0f 93       	push	r16
    1b3e:	1f 93       	push	r17
    1b40:	cf 93       	push	r28
    1b42:	df 93       	push	r29
    1b44:	00 d0       	rcall	.+0      	; 0x1b46 <rcvr_datablock+0x12>
    1b46:	cd b7       	in	r28, 0x3d	; 61
    1b48:	de b7       	in	r29, 0x3e	; 62
    1b4a:	7c 01       	movw	r14, r24
    1b4c:	6b 01       	movw	r12, r22
    1b4e:	08 ee       	ldi	r16, 0xE8	; 232
    1b50:	13 e0       	ldi	r17, 0x03	; 3
	BYTE d[2];
	UINT tmr;


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
		rcvr_mmc(d, 1);
    1b52:	61 e0       	ldi	r22, 0x01	; 1
    1b54:	70 e0       	ldi	r23, 0x00	; 0
    1b56:	ce 01       	movw	r24, r28
    1b58:	01 96       	adiw	r24, 0x01	; 1
    1b5a:	6c df       	rcall	.-296    	; 0x1a34 <rcvr_mmc>
		if (d[0] != 0xFF) break;
    1b5c:	99 81       	ldd	r25, Y+1	; 0x01
    1b5e:	9f 3f       	cpi	r25, 0xFF	; 255
    1b60:	31 f4       	brne	.+12     	; 0x1b6e <rcvr_datablock+0x3a>
		dly_us(100);
    1b62:	84 e6       	ldi	r24, 0x64	; 100
    1b64:	90 e0       	ldi	r25, 0x00	; 0
    1b66:	21 df       	rcall	.-446    	; 0x19aa <dly_us>
    1b68:	01 50       	subi	r16, 0x01	; 1
    1b6a:	11 09       	sbc	r17, r1
{
	BYTE d[2];
	UINT tmr;


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
    1b6c:	91 f7       	brne	.-28     	; 0x1b52 <rcvr_datablock+0x1e>
		rcvr_mmc(d, 1);
		if (d[0] != 0xFF) break;
		dly_us(100);
	}
	if (d[0] != 0xFE) return 0;		/* If not valid data token, return with error */
    1b6e:	99 81       	ldd	r25, Y+1	; 0x01
    1b70:	9e 3f       	cpi	r25, 0xFE	; 254
    1b72:	59 f4       	brne	.+22     	; 0x1b8a <rcvr_datablock+0x56>

	rcvr_mmc(buff, btr);			/* Receive the data block into buffer */
    1b74:	b6 01       	movw	r22, r12
    1b76:	c7 01       	movw	r24, r14
    1b78:	5d df       	rcall	.-326    	; 0x1a34 <rcvr_mmc>
	rcvr_mmc(d, 2);					/* Discard CRC */
    1b7a:	62 e0       	ldi	r22, 0x02	; 2
    1b7c:	70 e0       	ldi	r23, 0x00	; 0
    1b7e:	ce 01       	movw	r24, r28
    1b80:	01 96       	adiw	r24, 0x01	; 1
    1b82:	58 df       	rcall	.-336    	; 0x1a34 <rcvr_mmc>

	return 1;						/* Return with success */
    1b84:	81 e0       	ldi	r24, 0x01	; 1
    1b86:	90 e0       	ldi	r25, 0x00	; 0
    1b88:	02 c0       	rjmp	.+4      	; 0x1b8e <rcvr_datablock+0x5a>
	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
		rcvr_mmc(d, 1);
		if (d[0] != 0xFF) break;
		dly_us(100);
	}
	if (d[0] != 0xFE) return 0;		/* If not valid data token, return with error */
    1b8a:	80 e0       	ldi	r24, 0x00	; 0
    1b8c:	90 e0       	ldi	r25, 0x00	; 0

	rcvr_mmc(buff, btr);			/* Receive the data block into buffer */
	rcvr_mmc(d, 2);					/* Discard CRC */

	return 1;						/* Return with success */
}
    1b8e:	0f 90       	pop	r0
    1b90:	0f 90       	pop	r0
    1b92:	df 91       	pop	r29
    1b94:	cf 91       	pop	r28
    1b96:	1f 91       	pop	r17
    1b98:	0f 91       	pop	r16
    1b9a:	ff 90       	pop	r15
    1b9c:	ef 90       	pop	r14
    1b9e:	df 90       	pop	r13
    1ba0:	cf 90       	pop	r12
    1ba2:	08 95       	ret

00001ba4 <xmit_datablock>:
static
int xmit_datablock (	/* 1:OK, 0:Failed */
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
    1ba4:	ef 92       	push	r14
    1ba6:	ff 92       	push	r15
    1ba8:	1f 93       	push	r17
    1baa:	cf 93       	push	r28
    1bac:	df 93       	push	r29
    1bae:	00 d0       	rcall	.+0      	; 0x1bb0 <xmit_datablock+0xc>
    1bb0:	cd b7       	in	r28, 0x3d	; 61
    1bb2:	de b7       	in	r29, 0x3e	; 62
    1bb4:	7c 01       	movw	r14, r24
    1bb6:	16 2f       	mov	r17, r22
	BYTE d[2];


	if (!wait_ready()) return 0;
    1bb8:	6f df       	rcall	.-290    	; 0x1a98 <wait_ready>
    1bba:	00 97       	sbiw	r24, 0x00	; 0
    1bbc:	11 f1       	breq	.+68     	; 0x1c02 <xmit_datablock+0x5e>

	d[0] = token;
    1bbe:	19 83       	std	Y+1, r17	; 0x01
	xmit_mmc(d, 1);				/* Xmit a token */
    1bc0:	61 e0       	ldi	r22, 0x01	; 1
    1bc2:	70 e0       	ldi	r23, 0x00	; 0
    1bc4:	ce 01       	movw	r24, r28
    1bc6:	01 96       	adiw	r24, 0x01	; 1
    1bc8:	f5 de       	rcall	.-534    	; 0x19b4 <xmit_mmc>
	if (token != 0xFD) {		/* Is it data token? */
    1bca:	1d 3f       	cpi	r17, 0xFD	; 253
    1bcc:	c1 f0       	breq	.+48     	; 0x1bfe <xmit_datablock+0x5a>
		xmit_mmc(buff, 512);	/* Xmit the 512 byte data block to MMC */
    1bce:	60 e0       	ldi	r22, 0x00	; 0
    1bd0:	72 e0       	ldi	r23, 0x02	; 2
    1bd2:	c7 01       	movw	r24, r14
    1bd4:	ef de       	rcall	.-546    	; 0x19b4 <xmit_mmc>
		rcvr_mmc(d, 2);			/* Xmit dummy CRC (0xFF,0xFF) */
    1bd6:	62 e0       	ldi	r22, 0x02	; 2
    1bd8:	70 e0       	ldi	r23, 0x00	; 0
    1bda:	ce 01       	movw	r24, r28
    1bdc:	01 96       	adiw	r24, 0x01	; 1
    1bde:	2a df       	rcall	.-428    	; 0x1a34 <rcvr_mmc>
		rcvr_mmc(d, 1);			/* Receive data response */
    1be0:	61 e0       	ldi	r22, 0x01	; 1
    1be2:	70 e0       	ldi	r23, 0x00	; 0
    1be4:	ce 01       	movw	r24, r28
    1be6:	01 96       	adiw	r24, 0x01	; 1
    1be8:	25 df       	rcall	.-438    	; 0x1a34 <rcvr_mmc>
		if ((d[0] & 0x1F) != 0x05)	/* If not accepted, return with error */
    1bea:	89 81       	ldd	r24, Y+1	; 0x01
    1bec:	8f 71       	andi	r24, 0x1F	; 31
    1bee:	31 e0       	ldi	r19, 0x01	; 1
    1bf0:	20 e0       	ldi	r18, 0x00	; 0
    1bf2:	85 30       	cpi	r24, 0x05	; 5
    1bf4:	09 f0       	breq	.+2      	; 0x1bf8 <xmit_datablock+0x54>
    1bf6:	30 e0       	ldi	r19, 0x00	; 0
)
{
	BYTE d[2];


	if (!wait_ready()) return 0;
    1bf8:	83 2f       	mov	r24, r19
    1bfa:	92 2f       	mov	r25, r18
    1bfc:	02 c0       	rjmp	.+4      	; 0x1c02 <xmit_datablock+0x5e>
		rcvr_mmc(d, 1);			/* Receive data response */
		if ((d[0] & 0x1F) != 0x05)	/* If not accepted, return with error */
			return 0;
	}

	return 1;
    1bfe:	81 e0       	ldi	r24, 0x01	; 1
    1c00:	90 e0       	ldi	r25, 0x00	; 0
}
    1c02:	0f 90       	pop	r0
    1c04:	0f 90       	pop	r0
    1c06:	df 91       	pop	r29
    1c08:	cf 91       	pop	r28
    1c0a:	1f 91       	pop	r17
    1c0c:	ff 90       	pop	r15
    1c0e:	ef 90       	pop	r14
    1c10:	08 95       	ret

00001c12 <send_cmd>:
static
BYTE send_cmd (		/* Returns command response (bit7==1:Send failed)*/
	BYTE cmd,		/* Command byte */
	DWORD arg		/* Argument */
)
{
    1c12:	df 92       	push	r13
    1c14:	ef 92       	push	r14
    1c16:	ff 92       	push	r15
    1c18:	0f 93       	push	r16
    1c1a:	1f 93       	push	r17
    1c1c:	cf 93       	push	r28
    1c1e:	df 93       	push	r29
    1c20:	cd b7       	in	r28, 0x3d	; 61
    1c22:	de b7       	in	r29, 0x3e	; 62
    1c24:	27 97       	sbiw	r28, 0x07	; 7
    1c26:	0f b6       	in	r0, 0x3f	; 63
    1c28:	f8 94       	cli
    1c2a:	de bf       	out	0x3e, r29	; 62
    1c2c:	0f be       	out	0x3f, r0	; 63
    1c2e:	cd bf       	out	0x3d, r28	; 61
    1c30:	18 2f       	mov	r17, r24
    1c32:	04 2f       	mov	r16, r20
    1c34:	f5 2e       	mov	r15, r21
    1c36:	e6 2e       	mov	r14, r22
    1c38:	d7 2e       	mov	r13, r23
	BYTE n, d, buf[6];


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
    1c3a:	88 23       	and	r24, r24
    1c3c:	4c f4       	brge	.+18     	; 0x1c50 <send_cmd+0x3e>
		cmd &= 0x7F;
		n = send_cmd(CMD55, 0);
    1c3e:	40 e0       	ldi	r20, 0x00	; 0
    1c40:	50 e0       	ldi	r21, 0x00	; 0
    1c42:	ba 01       	movw	r22, r20
    1c44:	87 e3       	ldi	r24, 0x37	; 55
    1c46:	e5 df       	rcall	.-54     	; 0x1c12 <send_cmd>
		if (n > 1) return n;
    1c48:	82 30       	cpi	r24, 0x02	; 2
    1c4a:	08 f0       	brcs	.+2      	; 0x1c4e <send_cmd+0x3c>
    1c4c:	4f c0       	rjmp	.+158    	; 0x1cec <send_cmd+0xda>
{
	BYTE n, d, buf[6];


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
    1c4e:	1f 77       	andi	r17, 0x7F	; 127
		n = send_cmd(CMD55, 0);
		if (n > 1) return n;
	}

	/* Select the card and wait for ready except to stop multiple block read */
	if (cmd != CMD12) {
    1c50:	1c 30       	cpi	r17, 0x0C	; 12
    1c52:	09 f1       	breq	.+66     	; 0x1c96 <send_cmd+0x84>
		deselect();
    1c54:	44 df       	rcall	.-376    	; 0x1ade <deselect>
		if (!select()) return 0xFF;
    1c56:	52 df       	rcall	.-348    	; 0x1afc <select>
    1c58:	89 2b       	or	r24, r25
    1c5a:	d9 f0       	breq	.+54     	; 0x1c92 <send_cmd+0x80>
	}

	/* Send a command packet */
	buf[0] = 0x40 | cmd;			/* Start + Command index */
    1c5c:	81 2f       	mov	r24, r17
    1c5e:	80 64       	ori	r24, 0x40	; 64
    1c60:	8a 83       	std	Y+2, r24	; 0x02
	buf[1] = (BYTE)(arg >> 24);		/* Argument[31..24] */
    1c62:	db 82       	std	Y+3, r13	; 0x03
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
    1c64:	ec 82       	std	Y+4, r14	; 0x04
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
    1c66:	fd 82       	std	Y+5, r15	; 0x05
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
    1c68:	0e 83       	std	Y+6, r16	; 0x06
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
    1c6a:	11 23       	and	r17, r17
    1c6c:	b9 f1       	breq	.+110    	; 0x1cdc <send_cmd+0xca>
    1c6e:	33 c0       	rjmp	.+102    	; 0x1cd6 <send_cmd+0xc4>
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
	buf[5] = n;
	xmit_mmc(buf, 6);

	/* Receive command response */
	if (cmd == CMD12) rcvr_mmc(&d, 1);	/* Skip a stuff byte when stop reading */
    1c70:	61 e0       	ldi	r22, 0x01	; 1
    1c72:	70 e0       	ldi	r23, 0x00	; 0
    1c74:	ce 01       	movw	r24, r28
    1c76:	01 96       	adiw	r24, 0x01	; 1
    1c78:	dd de       	rcall	.-582    	; 0x1a34 <rcvr_mmc>
static
BYTE send_cmd (		/* Returns command response (bit7==1:Send failed)*/
	BYTE cmd,		/* Command byte */
	DWORD arg		/* Argument */
)
{
    1c7a:	1a e0       	ldi	r17, 0x0A	; 10

	/* Receive command response */
	if (cmd == CMD12) rcvr_mmc(&d, 1);	/* Skip a stuff byte when stop reading */
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		rcvr_mmc(&d, 1);
    1c7c:	61 e0       	ldi	r22, 0x01	; 1
    1c7e:	70 e0       	ldi	r23, 0x00	; 0
    1c80:	ce 01       	movw	r24, r28
    1c82:	01 96       	adiw	r24, 0x01	; 1
    1c84:	d7 de       	rcall	.-594    	; 0x1a34 <rcvr_mmc>
	while ((d & 0x80) && --n);
    1c86:	89 81       	ldd	r24, Y+1	; 0x01
    1c88:	88 23       	and	r24, r24
    1c8a:	84 f5       	brge	.+96     	; 0x1cec <send_cmd+0xda>
    1c8c:	11 50       	subi	r17, 0x01	; 1
    1c8e:	b1 f7       	brne	.-20     	; 0x1c7c <send_cmd+0x6a>
    1c90:	2d c0       	rjmp	.+90     	; 0x1cec <send_cmd+0xda>
	}

	/* Select the card and wait for ready except to stop multiple block read */
	if (cmd != CMD12) {
		deselect();
		if (!select()) return 0xFF;
    1c92:	8f ef       	ldi	r24, 0xFF	; 255
    1c94:	2b c0       	rjmp	.+86     	; 0x1cec <send_cmd+0xda>
	}

	/* Send a command packet */
	buf[0] = 0x40 | cmd;			/* Start + Command index */
    1c96:	8c e4       	ldi	r24, 0x4C	; 76
    1c98:	8a 83       	std	Y+2, r24	; 0x02
	buf[1] = (BYTE)(arg >> 24);		/* Argument[31..24] */
    1c9a:	db 82       	std	Y+3, r13	; 0x03
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
    1c9c:	ec 82       	std	Y+4, r14	; 0x04
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
    1c9e:	fd 82       	std	Y+5, r15	; 0x05
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
    1ca0:	0e 83       	std	Y+6, r16	; 0x06
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
	buf[5] = n;
    1ca2:	81 e0       	ldi	r24, 0x01	; 1
    1ca4:	8f 83       	std	Y+7, r24	; 0x07
	xmit_mmc(buf, 6);
    1ca6:	66 e0       	ldi	r22, 0x06	; 6
    1ca8:	70 e0       	ldi	r23, 0x00	; 0
    1caa:	ce 01       	movw	r24, r28
    1cac:	02 96       	adiw	r24, 0x02	; 2
    1cae:	82 de       	rcall	.-764    	; 0x19b4 <xmit_mmc>

	/* Receive command response */
	if (cmd == CMD12) rcvr_mmc(&d, 1);	/* Skip a stuff byte when stop reading */
    1cb0:	1c 30       	cpi	r17, 0x0C	; 12
    1cb2:	19 f7       	brne	.-58     	; 0x1c7a <send_cmd+0x68>
    1cb4:	dd cf       	rjmp	.-70     	; 0x1c70 <send_cmd+0x5e>
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
	buf[5] = n;
    1cb6:	87 e8       	ldi	r24, 0x87	; 135
    1cb8:	8f 83       	std	Y+7, r24	; 0x07
	xmit_mmc(buf, 6);
    1cba:	66 e0       	ldi	r22, 0x06	; 6
    1cbc:	70 e0       	ldi	r23, 0x00	; 0
    1cbe:	ce 01       	movw	r24, r28
    1cc0:	02 96       	adiw	r24, 0x02	; 2
    1cc2:	78 de       	rcall	.-784    	; 0x19b4 <xmit_mmc>
    1cc4:	da cf       	rjmp	.-76     	; 0x1c7a <send_cmd+0x68>
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
	buf[5] = n;
    1cc6:	81 e0       	ldi	r24, 0x01	; 1
    1cc8:	8f 83       	std	Y+7, r24	; 0x07
	xmit_mmc(buf, 6);
    1cca:	66 e0       	ldi	r22, 0x06	; 6
    1ccc:	70 e0       	ldi	r23, 0x00	; 0
    1cce:	ce 01       	movw	r24, r28
    1cd0:	02 96       	adiw	r24, 0x02	; 2
    1cd2:	70 de       	rcall	.-800    	; 0x19b4 <xmit_mmc>
    1cd4:	d2 cf       	rjmp	.-92     	; 0x1c7a <send_cmd+0x68>
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
    1cd6:	18 30       	cpi	r17, 0x08	; 8
    1cd8:	71 f3       	breq	.-36     	; 0x1cb6 <send_cmd+0xa4>
    1cda:	f5 cf       	rjmp	.-22     	; 0x1cc6 <send_cmd+0xb4>
	buf[5] = n;
    1cdc:	85 e9       	ldi	r24, 0x95	; 149
    1cde:	8f 83       	std	Y+7, r24	; 0x07
	xmit_mmc(buf, 6);
    1ce0:	66 e0       	ldi	r22, 0x06	; 6
    1ce2:	70 e0       	ldi	r23, 0x00	; 0
    1ce4:	ce 01       	movw	r24, r28
    1ce6:	02 96       	adiw	r24, 0x02	; 2
    1ce8:	65 de       	rcall	.-822    	; 0x19b4 <xmit_mmc>
    1cea:	c7 cf       	rjmp	.-114    	; 0x1c7a <send_cmd+0x68>
	do
		rcvr_mmc(&d, 1);
	while ((d & 0x80) && --n);

	return d;			/* Return with the response value */
}
    1cec:	27 96       	adiw	r28, 0x07	; 7
    1cee:	0f b6       	in	r0, 0x3f	; 63
    1cf0:	f8 94       	cli
    1cf2:	de bf       	out	0x3e, r29	; 62
    1cf4:	0f be       	out	0x3f, r0	; 63
    1cf6:	cd bf       	out	0x3d, r28	; 61
    1cf8:	df 91       	pop	r29
    1cfa:	cf 91       	pop	r28
    1cfc:	1f 91       	pop	r17
    1cfe:	0f 91       	pop	r16
    1d00:	ff 90       	pop	r15
    1d02:	ef 90       	pop	r14
    1d04:	df 90       	pop	r13
    1d06:	08 95       	ret

00001d08 <disk_status>:

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    1d08:	81 11       	cpse	r24, r1
    1d0a:	03 c0       	rjmp	.+6      	; 0x1d12 <disk_status+0xa>

	return Stat;
    1d0c:	80 91 0d 01 	lds	r24, 0x010D
    1d10:	08 95       	ret

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    1d12:	81 e0       	ldi	r24, 0x01	; 1

	return Stat;
}
    1d14:	08 95       	ret

00001d16 <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
    1d16:	ef 92       	push	r14
    1d18:	ff 92       	push	r15
    1d1a:	0f 93       	push	r16
    1d1c:	1f 93       	push	r17
    1d1e:	cf 93       	push	r28
    1d20:	df 93       	push	r29
    1d22:	00 d0       	rcall	.+0      	; 0x1d24 <disk_initialize+0xe>
    1d24:	00 d0       	rcall	.+0      	; 0x1d26 <disk_initialize+0x10>
    1d26:	cd b7       	in	r28, 0x3d	; 61
    1d28:	de b7       	in	r29, 0x3e	; 62
	BYTE n, ty, cmd, buf[4];
	UINT tmr;
	DSTATUS s;


	if (drv) return RES_NOTRDY;
    1d2a:	81 11       	cpse	r24, r1
    1d2c:	a1 c0       	rjmp	.+322    	; 0x1e70 <disk_initialize+0x15a>

	dly_us(10000);			/* 10ms */
    1d2e:	80 e1       	ldi	r24, 0x10	; 16
    1d30:	97 e2       	ldi	r25, 0x27	; 39
    1d32:	3b de       	rcall	.-906    	; 0x19aa <dly_us>
	CS_INIT(); CS_H();		/* Initialize port pin tied to CS */
    1d34:	51 9a       	sbi	0x0a, 1	; 10
    1d36:	59 9a       	sbi	0x0b, 1	; 11
	CK_INIT(); CK_L();		/* Initialize port pin tied to SCLK */
    1d38:	29 98       	cbi	0x05, 1	; 5
    1d3a:	21 9a       	sbi	0x04, 1	; 4
    1d3c:	29 98       	cbi	0x05, 1	; 5
	DI_INIT();				/* Initialize port pin tied to DI */
    1d3e:	22 9a       	sbi	0x04, 2	; 4
	DO_INIT();				/* Initialize port pin tied to DO */
    1d40:	2b 9a       	sbi	0x05, 3	; 5
    1d42:	1a e0       	ldi	r17, 0x0A	; 10

	for (n = 10; n; n--) rcvr_mmc(buf, 1);	/* Apply 80 dummy clocks and the card gets ready to receive command */
    1d44:	61 e0       	ldi	r22, 0x01	; 1
    1d46:	70 e0       	ldi	r23, 0x00	; 0
    1d48:	ce 01       	movw	r24, r28
    1d4a:	01 96       	adiw	r24, 0x01	; 1
    1d4c:	73 de       	rcall	.-794    	; 0x1a34 <rcvr_mmc>
    1d4e:	11 50       	subi	r17, 0x01	; 1
    1d50:	c9 f7       	brne	.-14     	; 0x1d44 <disk_initialize+0x2e>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
    1d52:	40 e0       	ldi	r20, 0x00	; 0
    1d54:	50 e0       	ldi	r21, 0x00	; 0
    1d56:	ba 01       	movw	r22, r20
    1d58:	80 e0       	ldi	r24, 0x00	; 0
    1d5a:	5b df       	rcall	.-330    	; 0x1c12 <send_cmd>
    1d5c:	81 30       	cpi	r24, 0x01	; 1
    1d5e:	09 f0       	breq	.+2      	; 0x1d62 <disk_initialize+0x4c>
    1d60:	6d c0       	rjmp	.+218    	; 0x1e3c <disk_initialize+0x126>
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
    1d62:	4a ea       	ldi	r20, 0xAA	; 170
    1d64:	51 e0       	ldi	r21, 0x01	; 1
    1d66:	60 e0       	ldi	r22, 0x00	; 0
    1d68:	70 e0       	ldi	r23, 0x00	; 0
    1d6a:	88 e0       	ldi	r24, 0x08	; 8
    1d6c:	52 df       	rcall	.-348    	; 0x1c12 <send_cmd>
    1d6e:	81 30       	cpi	r24, 0x01	; 1
    1d70:	a9 f5       	brne	.+106    	; 0x1ddc <disk_initialize+0xc6>
			rcvr_mmc(buf, 4);							/* Get trailing return value of R7 resp */
    1d72:	64 e0       	ldi	r22, 0x04	; 4
    1d74:	70 e0       	ldi	r23, 0x00	; 0
    1d76:	ce 01       	movw	r24, r28
    1d78:	01 96       	adiw	r24, 0x01	; 1
    1d7a:	5c de       	rcall	.-840    	; 0x1a34 <rcvr_mmc>
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
    1d7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d7e:	81 30       	cpi	r24, 0x01	; 1
    1d80:	09 f0       	breq	.+2      	; 0x1d84 <disk_initialize+0x6e>
    1d82:	5e c0       	rjmp	.+188    	; 0x1e40 <disk_initialize+0x12a>
    1d84:	8c 81       	ldd	r24, Y+4	; 0x04
    1d86:	8a 3a       	cpi	r24, 0xAA	; 170
    1d88:	09 f0       	breq	.+2      	; 0x1d8c <disk_initialize+0x76>
    1d8a:	5c c0       	rjmp	.+184    	; 0x1e44 <disk_initialize+0x12e>
    1d8c:	08 ee       	ldi	r16, 0xE8	; 232
    1d8e:	13 e0       	ldi	r17, 0x03	; 3
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
    1d90:	40 e0       	ldi	r20, 0x00	; 0
    1d92:	50 e0       	ldi	r21, 0x00	; 0
    1d94:	60 e0       	ldi	r22, 0x00	; 0
    1d96:	70 e4       	ldi	r23, 0x40	; 64
    1d98:	89 ea       	ldi	r24, 0xA9	; 169
    1d9a:	3b df       	rcall	.-394    	; 0x1c12 <send_cmd>
    1d9c:	88 23       	and	r24, r24
    1d9e:	41 f0       	breq	.+16     	; 0x1db0 <disk_initialize+0x9a>
					dly_us(1000);
    1da0:	88 ee       	ldi	r24, 0xE8	; 232
    1da2:	93 e0       	ldi	r25, 0x03	; 3
    1da4:	02 de       	rcall	.-1020   	; 0x19aa <dly_us>
	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			rcvr_mmc(buf, 4);							/* Get trailing return value of R7 resp */
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
    1da6:	01 50       	subi	r16, 0x01	; 1
    1da8:	11 09       	sbc	r17, r1
    1daa:	91 f7       	brne	.-28     	; 0x1d90 <disk_initialize+0x7a>
	DI_INIT();				/* Initialize port pin tied to DI */
	DO_INIT();				/* Initialize port pin tied to DO */

	for (n = 10; n; n--) rcvr_mmc(buf, 1);	/* Apply 80 dummy clocks and the card gets ready to receive command */

	ty = 0;
    1dac:	f1 2c       	mov	r15, r1
    1dae:	56 c0       	rjmp	.+172    	; 0x1e5c <disk_initialize+0x146>
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
					dly_us(1000);
				}
				if (tmr && send_cmd(CMD58, 0) == 0) {	/* Check CCS bit in the OCR */
    1db0:	01 2b       	or	r16, r17
    1db2:	09 f4       	brne	.+2      	; 0x1db6 <disk_initialize+0xa0>
    1db4:	49 c0       	rjmp	.+146    	; 0x1e48 <disk_initialize+0x132>
    1db6:	40 e0       	ldi	r20, 0x00	; 0
    1db8:	50 e0       	ldi	r21, 0x00	; 0
    1dba:	ba 01       	movw	r22, r20
    1dbc:	8a e3       	ldi	r24, 0x3A	; 58
    1dbe:	29 df       	rcall	.-430    	; 0x1c12 <send_cmd>
    1dc0:	81 11       	cpse	r24, r1
    1dc2:	44 c0       	rjmp	.+136    	; 0x1e4c <disk_initialize+0x136>
					rcvr_mmc(buf, 4);
    1dc4:	64 e0       	ldi	r22, 0x04	; 4
    1dc6:	70 e0       	ldi	r23, 0x00	; 0
    1dc8:	ce 01       	movw	r24, r28
    1dca:	01 96       	adiw	r24, 0x01	; 1
    1dcc:	33 de       	rcall	.-922    	; 0x1a34 <rcvr_mmc>
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
    1dce:	89 81       	ldd	r24, Y+1	; 0x01
    1dd0:	86 fd       	sbrc	r24, 6
    1dd2:	3e c0       	rjmp	.+124    	; 0x1e50 <disk_initialize+0x13a>
    1dd4:	68 94       	set
    1dd6:	ff 24       	eor	r15, r15
    1dd8:	f2 f8       	bld	r15, 2
    1dda:	40 c0       	rjmp	.+128    	; 0x1e5c <disk_initialize+0x146>
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
    1ddc:	40 e0       	ldi	r20, 0x00	; 0
    1dde:	50 e0       	ldi	r21, 0x00	; 0
    1de0:	ba 01       	movw	r22, r20
    1de2:	89 ea       	ldi	r24, 0xA9	; 169
    1de4:	16 df       	rcall	.-468    	; 0x1c12 <send_cmd>
    1de6:	82 30       	cpi	r24, 0x02	; 2
    1de8:	28 f0       	brcs	.+10     	; 0x1df4 <disk_initialize+0xde>
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
    1dea:	ee 24       	eor	r14, r14
    1dec:	e3 94       	inc	r14
    1dee:	ff 24       	eor	r15, r15
    1df0:	f3 94       	inc	r15
    1df2:	07 c0       	rjmp	.+14     	; 0x1e02 <disk_initialize+0xec>
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
    1df4:	0f 2e       	mov	r0, r31
    1df6:	f9 ea       	ldi	r31, 0xA9	; 169
    1df8:	ef 2e       	mov	r14, r31
    1dfa:	f0 2d       	mov	r31, r0
    1dfc:	68 94       	set
    1dfe:	ff 24       	eor	r15, r15
    1e00:	f1 f8       	bld	r15, 1
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
    1e02:	08 ee       	ldi	r16, 0xE8	; 232
    1e04:	13 e0       	ldi	r17, 0x03	; 3
				if (send_cmd(cmd, 0) == 0) break;
    1e06:	40 e0       	ldi	r20, 0x00	; 0
    1e08:	50 e0       	ldi	r21, 0x00	; 0
    1e0a:	ba 01       	movw	r22, r20
    1e0c:	8e 2d       	mov	r24, r14
    1e0e:	01 df       	rcall	.-510    	; 0x1c12 <send_cmd>
    1e10:	88 23       	and	r24, r24
    1e12:	41 f0       	breq	.+16     	; 0x1e24 <disk_initialize+0x10e>
				dly_us(1000);
    1e14:	88 ee       	ldi	r24, 0xE8	; 232
    1e16:	93 e0       	ldi	r25, 0x03	; 3
    1e18:	c8 dd       	rcall	.-1136   	; 0x19aa <dly_us>
			if (send_cmd(ACMD41, 0) <= 1) 	{
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
    1e1a:	01 50       	subi	r16, 0x01	; 1
    1e1c:	11 09       	sbc	r17, r1
    1e1e:	99 f7       	brne	.-26     	; 0x1e06 <disk_initialize+0xf0>
				if (send_cmd(cmd, 0) == 0) break;
				dly_us(1000);
			}
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
    1e20:	f1 2c       	mov	r15, r1
    1e22:	1c c0       	rjmp	.+56     	; 0x1e5c <disk_initialize+0x146>
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
				if (send_cmd(cmd, 0) == 0) break;
				dly_us(1000);
			}
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
    1e24:	01 2b       	or	r16, r17
    1e26:	c9 f0       	breq	.+50     	; 0x1e5a <disk_initialize+0x144>
    1e28:	40 e0       	ldi	r20, 0x00	; 0
    1e2a:	52 e0       	ldi	r21, 0x02	; 2
    1e2c:	60 e0       	ldi	r22, 0x00	; 0
    1e2e:	70 e0       	ldi	r23, 0x00	; 0
    1e30:	80 e1       	ldi	r24, 0x10	; 16
    1e32:	ef de       	rcall	.-546    	; 0x1c12 <send_cmd>
    1e34:	88 23       	and	r24, r24
    1e36:	91 f0       	breq	.+36     	; 0x1e5c <disk_initialize+0x146>
				ty = 0;
    1e38:	f1 2c       	mov	r15, r1
    1e3a:	10 c0       	rjmp	.+32     	; 0x1e5c <disk_initialize+0x146>
	DI_INIT();				/* Initialize port pin tied to DI */
	DO_INIT();				/* Initialize port pin tied to DO */

	for (n = 10; n; n--) rcvr_mmc(buf, 1);	/* Apply 80 dummy clocks and the card gets ready to receive command */

	ty = 0;
    1e3c:	f1 2c       	mov	r15, r1
    1e3e:	0e c0       	rjmp	.+28     	; 0x1e5c <disk_initialize+0x146>
    1e40:	f1 2c       	mov	r15, r1
    1e42:	0c c0       	rjmp	.+24     	; 0x1e5c <disk_initialize+0x146>
    1e44:	f1 2c       	mov	r15, r1
    1e46:	0a c0       	rjmp	.+20     	; 0x1e5c <disk_initialize+0x146>
    1e48:	f1 2c       	mov	r15, r1
    1e4a:	08 c0       	rjmp	.+16     	; 0x1e5c <disk_initialize+0x146>
    1e4c:	f1 2c       	mov	r15, r1
    1e4e:	06 c0       	rjmp	.+12     	; 0x1e5c <disk_initialize+0x146>
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
					dly_us(1000);
				}
				if (tmr && send_cmd(CMD58, 0) == 0) {	/* Check CCS bit in the OCR */
					rcvr_mmc(buf, 4);
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
    1e50:	0f 2e       	mov	r0, r31
    1e52:	fc e0       	ldi	r31, 0x0C	; 12
    1e54:	ff 2e       	mov	r15, r31
    1e56:	f0 2d       	mov	r31, r0
    1e58:	01 c0       	rjmp	.+2      	; 0x1e5c <disk_initialize+0x146>
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
				if (send_cmd(cmd, 0) == 0) break;
				dly_us(1000);
			}
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
    1e5a:	f1 2c       	mov	r15, r1
		}
	}
	CardType = ty;
    1e5c:	f0 92 05 06 	sts	0x0605, r15
	
				
	s = ty ? 0 : STA_NOINIT;
    1e60:	11 e0       	ldi	r17, 0x01	; 1
    1e62:	f1 10       	cpse	r15, r1
    1e64:	10 e0       	ldi	r17, 0x00	; 0
	Stat = s;
    1e66:	10 93 0d 01 	sts	0x010D, r17

	deselect();
    1e6a:	39 de       	rcall	.-910    	; 0x1ade <deselect>

	return s;
    1e6c:	81 2f       	mov	r24, r17
    1e6e:	01 c0       	rjmp	.+2      	; 0x1e72 <disk_initialize+0x15c>
	BYTE n, ty, cmd, buf[4];
	UINT tmr;
	DSTATUS s;


	if (drv) return RES_NOTRDY;
    1e70:	83 e0       	ldi	r24, 0x03	; 3
	Stat = s;

	deselect();

	return s;
}
    1e72:	0f 90       	pop	r0
    1e74:	0f 90       	pop	r0
    1e76:	0f 90       	pop	r0
    1e78:	0f 90       	pop	r0
    1e7a:	df 91       	pop	r29
    1e7c:	cf 91       	pop	r28
    1e7e:	1f 91       	pop	r17
    1e80:	0f 91       	pop	r16
    1e82:	ff 90       	pop	r15
    1e84:	ef 90       	pop	r14
    1e86:	08 95       	ret

00001e88 <disk_read>:
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
    1e88:	ff 92       	push	r15
    1e8a:	0f 93       	push	r16
    1e8c:	1f 93       	push	r17
    1e8e:	cf 93       	push	r28
    1e90:	df 93       	push	r29
    1e92:	eb 01       	movw	r28, r22

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    1e94:	81 11       	cpse	r24, r1
    1e96:	3b c0       	rjmp	.+118    	; 0x1f0e <disk_read+0x86>
)
{
	BYTE cmd;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    1e98:	80 91 0d 01 	lds	r24, 0x010D
    1e9c:	80 fd       	sbrc	r24, 0
    1e9e:	39 c0       	rjmp	.+114    	; 0x1f12 <disk_read+0x8a>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
    1ea0:	80 91 05 06 	lds	r24, 0x0605
    1ea4:	83 fd       	sbrc	r24, 3
    1ea6:	09 c0       	rjmp	.+18     	; 0x1eba <disk_read+0x32>
    1ea8:	01 2e       	mov	r0, r17
    1eaa:	19 e0       	ldi	r17, 0x09	; 9
    1eac:	22 0f       	add	r18, r18
    1eae:	33 1f       	adc	r19, r19
    1eb0:	44 1f       	adc	r20, r20
    1eb2:	55 1f       	adc	r21, r21
    1eb4:	1a 95       	dec	r17
    1eb6:	d1 f7       	brne	.-12     	; 0x1eac <disk_read+0x24>
    1eb8:	10 2d       	mov	r17, r0

	cmd = count > 1 ? CMD18 : CMD17;			/*  READ_MULTIPLE_BLOCK : READ_SINGLE_BLOCK */
    1eba:	02 30       	cpi	r16, 0x02	; 2
    1ebc:	11 05       	cpc	r17, r1
    1ebe:	28 f4       	brcc	.+10     	; 0x1eca <disk_read+0x42>
    1ec0:	0f 2e       	mov	r0, r31
    1ec2:	f1 e1       	ldi	r31, 0x11	; 17
    1ec4:	ff 2e       	mov	r15, r31
    1ec6:	f0 2d       	mov	r31, r0
    1ec8:	04 c0       	rjmp	.+8      	; 0x1ed2 <disk_read+0x4a>
    1eca:	0f 2e       	mov	r0, r31
    1ecc:	f2 e1       	ldi	r31, 0x12	; 18
    1ece:	ff 2e       	mov	r15, r31
    1ed0:	f0 2d       	mov	r31, r0
	if (send_cmd(cmd, sector) == 0) {
    1ed2:	ba 01       	movw	r22, r20
    1ed4:	a9 01       	movw	r20, r18
    1ed6:	8f 2d       	mov	r24, r15
    1ed8:	9c de       	rcall	.-712    	; 0x1c12 <send_cmd>
    1eda:	81 11       	cpse	r24, r1
    1edc:	12 c0       	rjmp	.+36     	; 0x1f02 <disk_read+0x7a>
		do {
			if (!rcvr_datablock(buff, 512)) break;
    1ede:	60 e0       	ldi	r22, 0x00	; 0
    1ee0:	72 e0       	ldi	r23, 0x02	; 2
    1ee2:	ce 01       	movw	r24, r28
    1ee4:	27 de       	rcall	.-946    	; 0x1b34 <rcvr_datablock>
    1ee6:	89 2b       	or	r24, r25
    1ee8:	21 f0       	breq	.+8      	; 0x1ef2 <disk_read+0x6a>
			buff += 512;
    1eea:	de 5f       	subi	r29, 0xFE	; 254
		} while (--count);
    1eec:	01 50       	subi	r16, 0x01	; 1
    1eee:	11 09       	sbc	r17, r1
    1ef0:	b1 f7       	brne	.-20     	; 0x1ede <disk_read+0x56>
		if (cmd == CMD18) send_cmd(CMD12, 0);	/* STOP_TRANSMISSION */
    1ef2:	82 e1       	ldi	r24, 0x12	; 18
    1ef4:	f8 12       	cpse	r15, r24
    1ef6:	05 c0       	rjmp	.+10     	; 0x1f02 <disk_read+0x7a>
    1ef8:	40 e0       	ldi	r20, 0x00	; 0
    1efa:	50 e0       	ldi	r21, 0x00	; 0
    1efc:	ba 01       	movw	r22, r20
    1efe:	8c e0       	ldi	r24, 0x0C	; 12
    1f00:	88 de       	rcall	.-752    	; 0x1c12 <send_cmd>
	}
	deselect();
    1f02:	ed dd       	rcall	.-1062   	; 0x1ade <deselect>

	return count ? RES_ERROR : RES_OK;
    1f04:	81 e0       	ldi	r24, 0x01	; 1
    1f06:	01 2b       	or	r16, r17
    1f08:	29 f4       	brne	.+10     	; 0x1f14 <disk_read+0x8c>
    1f0a:	80 e0       	ldi	r24, 0x00	; 0
    1f0c:	03 c0       	rjmp	.+6      	; 0x1f14 <disk_read+0x8c>
)
{
	BYTE cmd;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    1f0e:	83 e0       	ldi	r24, 0x03	; 3
    1f10:	01 c0       	rjmp	.+2      	; 0x1f14 <disk_read+0x8c>
    1f12:	83 e0       	ldi	r24, 0x03	; 3
		if (cmd == CMD18) send_cmd(CMD12, 0);	/* STOP_TRANSMISSION */
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
    1f14:	df 91       	pop	r29
    1f16:	cf 91       	pop	r28
    1f18:	1f 91       	pop	r17
    1f1a:	0f 91       	pop	r16
    1f1c:	ff 90       	pop	r15
    1f1e:	08 95       	ret

00001f20 <disk_write>:
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
    1f20:	cf 92       	push	r12
    1f22:	df 92       	push	r13
    1f24:	ef 92       	push	r14
    1f26:	ff 92       	push	r15
    1f28:	0f 93       	push	r16
    1f2a:	1f 93       	push	r17
    1f2c:	cf 93       	push	r28
    1f2e:	df 93       	push	r29
    1f30:	eb 01       	movw	r28, r22
    1f32:	69 01       	movw	r12, r18
    1f34:	7a 01       	movw	r14, r20

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    1f36:	81 11       	cpse	r24, r1
    1f38:	49 c0       	rjmp	.+146    	; 0x1fcc <disk_write+0xac>
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    1f3a:	80 91 0d 01 	lds	r24, 0x010D
    1f3e:	80 fd       	sbrc	r24, 0
    1f40:	47 c0       	rjmp	.+142    	; 0x1fd0 <disk_write+0xb0>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
    1f42:	80 91 05 06 	lds	r24, 0x0605
    1f46:	83 fd       	sbrc	r24, 3
    1f48:	09 c0       	rjmp	.+18     	; 0x1f5c <disk_write+0x3c>
    1f4a:	0b 2e       	mov	r0, r27
    1f4c:	b9 e0       	ldi	r27, 0x09	; 9
    1f4e:	cc 0c       	add	r12, r12
    1f50:	dd 1c       	adc	r13, r13
    1f52:	ee 1c       	adc	r14, r14
    1f54:	ff 1c       	adc	r15, r15
    1f56:	ba 95       	dec	r27
    1f58:	d1 f7       	brne	.-12     	; 0x1f4e <disk_write+0x2e>
    1f5a:	b0 2d       	mov	r27, r0

	if (count == 1) {	/* Single block write */
    1f5c:	01 30       	cpi	r16, 0x01	; 1
    1f5e:	11 05       	cpc	r17, r1
    1f60:	89 f4       	brne	.+34     	; 0x1f84 <disk_write+0x64>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
    1f62:	b7 01       	movw	r22, r14
    1f64:	a6 01       	movw	r20, r12
    1f66:	88 e1       	ldi	r24, 0x18	; 24
    1f68:	54 de       	rcall	.-856    	; 0x1c12 <send_cmd>
    1f6a:	81 11       	cpse	r24, r1
    1f6c:	29 c0       	rjmp	.+82     	; 0x1fc0 <disk_write+0xa0>
			&& xmit_datablock(buff, 0xFE))
    1f6e:	6e ef       	ldi	r22, 0xFE	; 254
    1f70:	ce 01       	movw	r24, r28
    1f72:	18 de       	rcall	.-976    	; 0x1ba4 <xmit_datablock>
    1f74:	31 e0       	ldi	r19, 0x01	; 1
    1f76:	20 e0       	ldi	r18, 0x00	; 0
    1f78:	89 2b       	or	r24, r25
    1f7a:	09 f0       	breq	.+2      	; 0x1f7e <disk_write+0x5e>
    1f7c:	30 e0       	ldi	r19, 0x00	; 0
    1f7e:	03 2f       	mov	r16, r19
    1f80:	12 2f       	mov	r17, r18
    1f82:	1e c0       	rjmp	.+60     	; 0x1fc0 <disk_write+0xa0>
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
    1f84:	86 70       	andi	r24, 0x06	; 6
    1f86:	29 f0       	breq	.+10     	; 0x1f92 <disk_write+0x72>
    1f88:	a8 01       	movw	r20, r16
    1f8a:	60 e0       	ldi	r22, 0x00	; 0
    1f8c:	70 e0       	ldi	r23, 0x00	; 0
    1f8e:	87 e9       	ldi	r24, 0x97	; 151
    1f90:	40 de       	rcall	.-896    	; 0x1c12 <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
    1f92:	b7 01       	movw	r22, r14
    1f94:	a6 01       	movw	r20, r12
    1f96:	89 e1       	ldi	r24, 0x19	; 25
    1f98:	3c de       	rcall	.-904    	; 0x1c12 <send_cmd>
    1f9a:	81 11       	cpse	r24, r1
    1f9c:	11 c0       	rjmp	.+34     	; 0x1fc0 <disk_write+0xa0>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
    1f9e:	6c ef       	ldi	r22, 0xFC	; 252
    1fa0:	ce 01       	movw	r24, r28
    1fa2:	00 de       	rcall	.-1024   	; 0x1ba4 <xmit_datablock>
    1fa4:	89 2b       	or	r24, r25
    1fa6:	21 f0       	breq	.+8      	; 0x1fb0 <disk_write+0x90>
				buff += 512;
    1fa8:	de 5f       	subi	r29, 0xFE	; 254
			} while (--count);
    1faa:	01 50       	subi	r16, 0x01	; 1
    1fac:	11 09       	sbc	r17, r1
    1fae:	b9 f7       	brne	.-18     	; 0x1f9e <disk_write+0x7e>
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
    1fb0:	6d ef       	ldi	r22, 0xFD	; 253
    1fb2:	80 e0       	ldi	r24, 0x00	; 0
    1fb4:	90 e0       	ldi	r25, 0x00	; 0
    1fb6:	f6 dd       	rcall	.-1044   	; 0x1ba4 <xmit_datablock>
    1fb8:	89 2b       	or	r24, r25
    1fba:	11 f4       	brne	.+4      	; 0x1fc0 <disk_write+0xa0>
				count = 1;
    1fbc:	01 e0       	ldi	r16, 0x01	; 1
    1fbe:	10 e0       	ldi	r17, 0x00	; 0
		}
	}
	deselect();
    1fc0:	8e dd       	rcall	.-1252   	; 0x1ade <deselect>

	return count ? RES_ERROR : RES_OK;
    1fc2:	81 e0       	ldi	r24, 0x01	; 1
    1fc4:	01 2b       	or	r16, r17
    1fc6:	29 f4       	brne	.+10     	; 0x1fd2 <disk_write+0xb2>
    1fc8:	80 e0       	ldi	r24, 0x00	; 0
    1fca:	03 c0       	rjmp	.+6      	; 0x1fd2 <disk_write+0xb2>
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    1fcc:	83 e0       	ldi	r24, 0x03	; 3
    1fce:	01 c0       	rjmp	.+2      	; 0x1fd2 <disk_write+0xb2>
    1fd0:	83 e0       	ldi	r24, 0x03	; 3
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
    1fd2:	df 91       	pop	r29
    1fd4:	cf 91       	pop	r28
    1fd6:	1f 91       	pop	r17
    1fd8:	0f 91       	pop	r16
    1fda:	ff 90       	pop	r15
    1fdc:	ef 90       	pop	r14
    1fde:	df 90       	pop	r13
    1fe0:	cf 90       	pop	r12
    1fe2:	08 95       	ret

00001fe4 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
    1fe4:	0f 93       	push	r16
    1fe6:	1f 93       	push	r17
    1fe8:	cf 93       	push	r28
    1fea:	df 93       	push	r29
    1fec:	cd b7       	in	r28, 0x3d	; 61
    1fee:	de b7       	in	r29, 0x3e	; 62
    1ff0:	60 97       	sbiw	r28, 0x10	; 16
    1ff2:	0f b6       	in	r0, 0x3f	; 63
    1ff4:	f8 94       	cli
    1ff6:	de bf       	out	0x3e, r29	; 62
    1ff8:	0f be       	out	0x3f, r0	; 63
    1ffa:	cd bf       	out	0x3d, r28	; 61

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    1ffc:	81 11       	cpse	r24, r1
    1ffe:	98 c0       	rjmp	.+304    	; 0x2130 <disk_ioctl+0x14c>
	DRESULT res;
	BYTE n, csd[16];
	DWORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */
    2000:	80 91 0d 01 	lds	r24, 0x010D
    2004:	80 fd       	sbrc	r24, 0
    2006:	96 c0       	rjmp	.+300    	; 0x2134 <disk_ioctl+0x150>
    2008:	8a 01       	movw	r16, r20

	res = RES_ERROR;
	switch (ctrl) {
    200a:	61 30       	cpi	r22, 0x01	; 1
    200c:	61 f0       	breq	.+24     	; 0x2026 <disk_ioctl+0x42>
    200e:	20 f0       	brcs	.+8      	; 0x2018 <disk_ioctl+0x34>
    2010:	63 30       	cpi	r22, 0x03	; 3
    2012:	09 f4       	brne	.+2      	; 0x2016 <disk_ioctl+0x32>
    2014:	7a c0       	rjmp	.+244    	; 0x210a <disk_ioctl+0x126>
    2016:	84 c0       	rjmp	.+264    	; 0x2120 <disk_ioctl+0x13c>
		case CTRL_SYNC :		/* Make sure that no pending write process */
			if (select()) res = RES_OK;
    2018:	71 dd       	rcall	.-1310   	; 0x1afc <select>
    201a:	11 e0       	ldi	r17, 0x01	; 1
    201c:	89 2b       	or	r24, r25
    201e:	09 f4       	brne	.+2      	; 0x2022 <disk_ioctl+0x3e>
    2020:	84 c0       	rjmp	.+264    	; 0x212a <disk_ioctl+0x146>
    2022:	10 e0       	ldi	r17, 0x00	; 0
    2024:	82 c0       	rjmp	.+260    	; 0x212a <disk_ioctl+0x146>
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
    2026:	40 e0       	ldi	r20, 0x00	; 0
    2028:	50 e0       	ldi	r21, 0x00	; 0
    202a:	ba 01       	movw	r22, r20
    202c:	89 e0       	ldi	r24, 0x09	; 9
    202e:	f1 dd       	rcall	.-1054   	; 0x1c12 <send_cmd>
    2030:	81 11       	cpse	r24, r1
    2032:	78 c0       	rjmp	.+240    	; 0x2124 <disk_ioctl+0x140>
    2034:	60 e1       	ldi	r22, 0x10	; 16
    2036:	70 e0       	ldi	r23, 0x00	; 0
    2038:	ce 01       	movw	r24, r28
    203a:	01 96       	adiw	r24, 0x01	; 1
    203c:	7b dd       	rcall	.-1290   	; 0x1b34 <rcvr_datablock>
    203e:	89 2b       	or	r24, r25
    2040:	09 f4       	brne	.+2      	; 0x2044 <disk_ioctl+0x60>
    2042:	72 c0       	rjmp	.+228    	; 0x2128 <disk_ioctl+0x144>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
    2044:	89 81       	ldd	r24, Y+1	; 0x01
    2046:	82 95       	swap	r24
    2048:	86 95       	lsr	r24
    204a:	86 95       	lsr	r24
    204c:	83 70       	andi	r24, 0x03	; 3
    204e:	81 30       	cpi	r24, 0x01	; 1
    2050:	31 f5       	brne	.+76     	; 0x209e <disk_ioctl+0xba>
					cs = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
    2052:	88 85       	ldd	r24, Y+8	; 0x08
    2054:	8f 73       	andi	r24, 0x3F	; 63
    2056:	90 e0       	ldi	r25, 0x00	; 0
    2058:	a0 e0       	ldi	r26, 0x00	; 0
    205a:	b0 e0       	ldi	r27, 0x00	; 0
    205c:	dc 01       	movw	r26, r24
    205e:	99 27       	eor	r25, r25
    2060:	88 27       	eor	r24, r24
    2062:	01 96       	adiw	r24, 0x01	; 1
    2064:	a1 1d       	adc	r26, r1
    2066:	b1 1d       	adc	r27, r1
    2068:	29 85       	ldd	r18, Y+9	; 0x09
    206a:	30 e0       	ldi	r19, 0x00	; 0
    206c:	32 2f       	mov	r19, r18
    206e:	22 27       	eor	r18, r18
    2070:	4a 85       	ldd	r20, Y+10	; 0x0a
    2072:	24 0f       	add	r18, r20
    2074:	31 1d       	adc	r19, r1
    2076:	82 0f       	add	r24, r18
    2078:	93 1f       	adc	r25, r19
    207a:	a1 1d       	adc	r26, r1
    207c:	b1 1d       	adc	r27, r1
					*(DWORD*)buff = cs << 10;
    207e:	07 2e       	mov	r0, r23
    2080:	7a e0       	ldi	r23, 0x0A	; 10
    2082:	88 0f       	add	r24, r24
    2084:	99 1f       	adc	r25, r25
    2086:	aa 1f       	adc	r26, r26
    2088:	bb 1f       	adc	r27, r27
    208a:	7a 95       	dec	r23
    208c:	d1 f7       	brne	.-12     	; 0x2082 <disk_ioctl+0x9e>
    208e:	70 2d       	mov	r23, r0
    2090:	f8 01       	movw	r30, r16
    2092:	80 83       	st	Z, r24
    2094:	91 83       	std	Z+1, r25	; 0x01
    2096:	a2 83       	std	Z+2, r26	; 0x02
    2098:	b3 83       	std	Z+3, r27	; 0x03
				} else {					/* SDC ver 1.XX or MMC */
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = cs << (n - 9);
				}
				res = RES_OK;
    209a:	10 e0       	ldi	r17, 0x00	; 0
    209c:	46 c0       	rjmp	.+140    	; 0x212a <disk_ioctl+0x146>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					cs = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = cs << 10;
				} else {					/* SDC ver 1.XX or MMC */
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
    209e:	89 85       	ldd	r24, Y+9	; 0x09
    20a0:	82 95       	swap	r24
    20a2:	86 95       	lsr	r24
    20a4:	86 95       	lsr	r24
    20a6:	83 70       	andi	r24, 0x03	; 3
    20a8:	28 85       	ldd	r18, Y+8	; 0x08
    20aa:	90 e0       	ldi	r25, 0x00	; 0
    20ac:	f4 e0       	ldi	r31, 0x04	; 4
    20ae:	2f 9f       	mul	r18, r31
    20b0:	80 0d       	add	r24, r0
    20b2:	91 1d       	adc	r25, r1
    20b4:	11 24       	eor	r1, r1
    20b6:	9c 01       	movw	r18, r24
    20b8:	2f 5f       	subi	r18, 0xFF	; 255
    20ba:	3f 4f       	sbci	r19, 0xFF	; 255
    20bc:	9f 81       	ldd	r25, Y+7	; 0x07
    20be:	93 70       	andi	r25, 0x03	; 3
    20c0:	89 2f       	mov	r24, r25
    20c2:	90 e0       	ldi	r25, 0x00	; 0
    20c4:	98 2f       	mov	r25, r24
    20c6:	88 27       	eor	r24, r24
    20c8:	99 0f       	add	r25, r25
    20ca:	99 0f       	add	r25, r25
    20cc:	82 0f       	add	r24, r18
    20ce:	93 1f       	adc	r25, r19
    20d0:	a0 e0       	ldi	r26, 0x00	; 0
    20d2:	b0 e0       	ldi	r27, 0x00	; 0
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					cs = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = cs << 10;
				} else {					/* SDC ver 1.XX or MMC */
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
    20d4:	2e 81       	ldd	r18, Y+6	; 0x06
    20d6:	32 2f       	mov	r19, r18
    20d8:	3f 70       	andi	r19, 0x0F	; 15
    20da:	2b 85       	ldd	r18, Y+11	; 0x0b
    20dc:	22 1f       	adc	r18, r18
    20de:	22 27       	eor	r18, r18
    20e0:	22 1f       	adc	r18, r18
    20e2:	23 0f       	add	r18, r19
    20e4:	3a 85       	ldd	r19, Y+10	; 0x0a
    20e6:	33 70       	andi	r19, 0x03	; 3
    20e8:	33 0f       	add	r19, r19
    20ea:	23 0f       	add	r18, r19
					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = cs << (n - 9);
    20ec:	27 50       	subi	r18, 0x07	; 7
    20ee:	04 c0       	rjmp	.+8      	; 0x20f8 <disk_ioctl+0x114>
    20f0:	88 0f       	add	r24, r24
    20f2:	99 1f       	adc	r25, r25
    20f4:	aa 1f       	adc	r26, r26
    20f6:	bb 1f       	adc	r27, r27
    20f8:	2a 95       	dec	r18
    20fa:	d2 f7       	brpl	.-12     	; 0x20f0 <disk_ioctl+0x10c>
    20fc:	f8 01       	movw	r30, r16
    20fe:	80 83       	st	Z, r24
    2100:	91 83       	std	Z+1, r25	; 0x01
    2102:	a2 83       	std	Z+2, r26	; 0x02
    2104:	b3 83       	std	Z+3, r27	; 0x03
				}
				res = RES_OK;
    2106:	10 e0       	ldi	r17, 0x00	; 0
    2108:	10 c0       	rjmp	.+32     	; 0x212a <disk_ioctl+0x146>
			}
			break;

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			*(DWORD*)buff = 128;
    210a:	80 e8       	ldi	r24, 0x80	; 128
    210c:	90 e0       	ldi	r25, 0x00	; 0
    210e:	a0 e0       	ldi	r26, 0x00	; 0
    2110:	b0 e0       	ldi	r27, 0x00	; 0
    2112:	fa 01       	movw	r30, r20
    2114:	80 83       	st	Z, r24
    2116:	91 83       	std	Z+1, r25	; 0x01
    2118:	a2 83       	std	Z+2, r26	; 0x02
    211a:	b3 83       	std	Z+3, r27	; 0x03
			res = RES_OK;
    211c:	10 e0       	ldi	r17, 0x00	; 0
			break;
    211e:	05 c0       	rjmp	.+10     	; 0x212a <disk_ioctl+0x146>

		default:
			res = RES_PARERR;
    2120:	14 e0       	ldi	r17, 0x04	; 4
    2122:	03 c0       	rjmp	.+6      	; 0x212a <disk_ioctl+0x146>
	DWORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */

	res = RES_ERROR;
    2124:	11 e0       	ldi	r17, 0x01	; 1
    2126:	01 c0       	rjmp	.+2      	; 0x212a <disk_ioctl+0x146>
    2128:	11 e0       	ldi	r17, 0x01	; 1

		default:
			res = RES_PARERR;
	}

	deselect();
    212a:	d9 dc       	rcall	.-1614   	; 0x1ade <deselect>

	return res;
    212c:	81 2f       	mov	r24, r17
    212e:	03 c0       	rjmp	.+6      	; 0x2136 <disk_ioctl+0x152>
	DRESULT res;
	BYTE n, csd[16];
	DWORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */
    2130:	83 e0       	ldi	r24, 0x03	; 3
    2132:	01 c0       	rjmp	.+2      	; 0x2136 <disk_ioctl+0x152>
    2134:	83 e0       	ldi	r24, 0x03	; 3
	}

	deselect();

	return res;
}
    2136:	60 96       	adiw	r28, 0x10	; 16
    2138:	0f b6       	in	r0, 0x3f	; 63
    213a:	f8 94       	cli
    213c:	de bf       	out	0x3e, r29	; 62
    213e:	0f be       	out	0x3f, r0	; 63
    2140:	cd bf       	out	0x3d, r28	; 61
    2142:	df 91       	pop	r29
    2144:	cf 91       	pop	r28
    2146:	1f 91       	pop	r17
    2148:	0f 91       	pop	r16
    214a:	08 95       	ret

0000214c <mem_cpy>:
			FREE_BUF();
		}
	}

	LEAVE_FF(dp->fs, res);
}
    214c:	cf 93       	push	r28
    214e:	df 93       	push	r29
    2150:	42 30       	cpi	r20, 0x02	; 2
    2152:	51 05       	cpc	r21, r1
    2154:	c0 f0       	brcs	.+48     	; 0x2186 <mem_cpy+0x3a>
    2156:	db 01       	movw	r26, r22
    2158:	fc 01       	movw	r30, r24
    215a:	9a 01       	movw	r18, r20
    215c:	cd 91       	ld	r28, X+
    215e:	dd 91       	ld	r29, X+
    2160:	c1 93       	st	Z+, r28
    2162:	d1 93       	st	Z+, r29
    2164:	22 50       	subi	r18, 0x02	; 2
    2166:	31 09       	sbc	r19, r1
    2168:	22 30       	cpi	r18, 0x02	; 2
    216a:	31 05       	cpc	r19, r1
    216c:	b8 f7       	brcc	.-18     	; 0x215c <mem_cpy+0x10>
    216e:	9a 01       	movw	r18, r20
    2170:	22 50       	subi	r18, 0x02	; 2
    2172:	31 09       	sbc	r19, r1
    2174:	2e 7f       	andi	r18, 0xFE	; 254
    2176:	2e 5f       	subi	r18, 0xFE	; 254
    2178:	3f 4f       	sbci	r19, 0xFF	; 255
    217a:	82 0f       	add	r24, r18
    217c:	93 1f       	adc	r25, r19
    217e:	62 0f       	add	r22, r18
    2180:	73 1f       	adc	r23, r19
    2182:	41 70       	andi	r20, 0x01	; 1
    2184:	55 27       	eor	r21, r21
    2186:	41 15       	cp	r20, r1
    2188:	51 05       	cpc	r21, r1
    218a:	49 f0       	breq	.+18     	; 0x219e <mem_cpy+0x52>
    218c:	db 01       	movw	r26, r22
    218e:	fc 01       	movw	r30, r24
    2190:	48 0f       	add	r20, r24
    2192:	59 1f       	adc	r21, r25
    2194:	9d 91       	ld	r25, X+
    2196:	91 93       	st	Z+, r25
    2198:	e4 17       	cp	r30, r20
    219a:	f5 07       	cpc	r31, r21
    219c:	d9 f7       	brne	.-10     	; 0x2194 <mem_cpy+0x48>
    219e:	df 91       	pop	r29
    21a0:	cf 91       	pop	r28
    21a2:	08 95       	ret

000021a4 <ld_clust>:
    21a4:	0f 93       	push	r16
    21a6:	1f 93       	push	r17
    21a8:	dc 01       	movw	r26, r24
    21aa:	fb 01       	movw	r30, r22
    21ac:	62 8d       	ldd	r22, Z+26	; 0x1a
    21ae:	73 8d       	ldd	r23, Z+27	; 0x1b
    21b0:	80 e0       	ldi	r24, 0x00	; 0
    21b2:	90 e0       	ldi	r25, 0x00	; 0
    21b4:	2c 91       	ld	r18, X
    21b6:	23 30       	cpi	r18, 0x03	; 3
    21b8:	59 f4       	brne	.+22     	; 0x21d0 <ld_clust+0x2c>
    21ba:	04 89       	ldd	r16, Z+20	; 0x14
    21bc:	15 89       	ldd	r17, Z+21	; 0x15
    21be:	20 e0       	ldi	r18, 0x00	; 0
    21c0:	30 e0       	ldi	r19, 0x00	; 0
    21c2:	98 01       	movw	r18, r16
    21c4:	11 27       	eor	r17, r17
    21c6:	00 27       	eor	r16, r16
    21c8:	60 2b       	or	r22, r16
    21ca:	71 2b       	or	r23, r17
    21cc:	82 2b       	or	r24, r18
    21ce:	93 2b       	or	r25, r19
    21d0:	1f 91       	pop	r17
    21d2:	0f 91       	pop	r16
    21d4:	08 95       	ret

000021d6 <get_fileinfo>:
    21d6:	0f 93       	push	r16
    21d8:	1f 93       	push	r17
    21da:	cf 93       	push	r28
    21dc:	df 93       	push	r29
    21de:	eb 01       	movw	r28, r22
    21e0:	fb 01       	movw	r30, r22
    21e2:	39 96       	adiw	r30, 0x09	; 9
    21e4:	dc 01       	movw	r26, r24
    21e6:	1e 96       	adiw	r26, 0x0e	; 14
    21e8:	4d 91       	ld	r20, X+
    21ea:	5d 91       	ld	r21, X+
    21ec:	6d 91       	ld	r22, X+
    21ee:	7c 91       	ld	r23, X
    21f0:	51 97       	sbiw	r26, 0x11	; 17
    21f2:	45 2b       	or	r20, r21
    21f4:	46 2b       	or	r20, r22
    21f6:	47 2b       	or	r20, r23
    21f8:	a9 f1       	breq	.+106    	; 0x2264 <get_fileinfo+0x8e>
    21fa:	52 96       	adiw	r26, 0x12	; 18
    21fc:	4d 91       	ld	r20, X+
    21fe:	5c 91       	ld	r21, X
    2200:	53 97       	sbiw	r26, 0x13	; 19
    2202:	da 01       	movw	r26, r20
    2204:	80 e0       	ldi	r24, 0x00	; 0
    2206:	90 e0       	ldi	r25, 0x00	; 0
    2208:	6e e2       	ldi	r22, 0x2E	; 46
    220a:	35 ee       	ldi	r19, 0xE5	; 229
    220c:	01 96       	adiw	r24, 0x01	; 1
    220e:	2d 91       	ld	r18, X+
    2210:	20 32       	cpi	r18, 0x20	; 32
    2212:	51 f0       	breq	.+20     	; 0x2228 <get_fileinfo+0x52>
    2214:	25 30       	cpi	r18, 0x05	; 5
    2216:	09 f4       	brne	.+2      	; 0x221a <get_fileinfo+0x44>
    2218:	23 2f       	mov	r18, r19
    221a:	89 30       	cpi	r24, 0x09	; 9
    221c:	91 05       	cpc	r25, r1
    221e:	11 f4       	brne	.+4      	; 0x2224 <get_fileinfo+0x4e>
    2220:	60 83       	st	Z, r22
    2222:	31 96       	adiw	r30, 0x01	; 1
    2224:	20 83       	st	Z, r18
    2226:	31 96       	adiw	r30, 0x01	; 1
    2228:	8b 30       	cpi	r24, 0x0B	; 11
    222a:	91 05       	cpc	r25, r1
    222c:	79 f7       	brne	.-34     	; 0x220c <get_fileinfo+0x36>
    222e:	da 01       	movw	r26, r20
    2230:	1b 96       	adiw	r26, 0x0b	; 11
    2232:	8c 91       	ld	r24, X
    2234:	1b 97       	sbiw	r26, 0x0b	; 11
    2236:	88 87       	std	Y+8, r24	; 0x08
    2238:	5c 96       	adiw	r26, 0x1c	; 28
    223a:	0d 91       	ld	r16, X+
    223c:	1d 91       	ld	r17, X+
    223e:	2d 91       	ld	r18, X+
    2240:	3c 91       	ld	r19, X
    2242:	5f 97       	sbiw	r26, 0x1f	; 31
    2244:	08 83       	st	Y, r16
    2246:	19 83       	std	Y+1, r17	; 0x01
    2248:	2a 83       	std	Y+2, r18	; 0x02
    224a:	3b 83       	std	Y+3, r19	; 0x03
    224c:	58 96       	adiw	r26, 0x18	; 24
    224e:	8d 91       	ld	r24, X+
    2250:	9c 91       	ld	r25, X
    2252:	59 97       	sbiw	r26, 0x19	; 25
    2254:	9d 83       	std	Y+5, r25	; 0x05
    2256:	8c 83       	std	Y+4, r24	; 0x04
    2258:	56 96       	adiw	r26, 0x16	; 22
    225a:	8d 91       	ld	r24, X+
    225c:	9c 91       	ld	r25, X
    225e:	57 97       	sbiw	r26, 0x17	; 23
    2260:	9f 83       	std	Y+7, r25	; 0x07
    2262:	8e 83       	std	Y+6, r24	; 0x06
    2264:	10 82       	st	Z, r1
    2266:	df 91       	pop	r29
    2268:	cf 91       	pop	r28
    226a:	1f 91       	pop	r17
    226c:	0f 91       	pop	r16
    226e:	08 95       	ret

00002270 <get_ldnumber>:
    2270:	cf 93       	push	r28
    2272:	df 93       	push	r29
    2274:	ec 01       	movw	r28, r24
    2276:	a8 81       	ld	r26, Y
    2278:	b9 81       	ldd	r27, Y+1	; 0x01
    227a:	10 97       	sbiw	r26, 0x00	; 0
    227c:	f9 f0       	breq	.+62     	; 0x22bc <get_ldnumber+0x4c>
    227e:	4c 91       	ld	r20, X
    2280:	41 32       	cpi	r20, 0x21	; 33
    2282:	58 f0       	brcs	.+22     	; 0x229a <get_ldnumber+0x2a>
    2284:	4a 33       	cpi	r20, 0x3A	; 58
    2286:	31 f1       	breq	.+76     	; 0x22d4 <get_ldnumber+0x64>
    2288:	fd 01       	movw	r30, r26
    228a:	31 96       	adiw	r30, 0x01	; 1
    228c:	9f 01       	movw	r18, r30
    228e:	91 91       	ld	r25, Z+
    2290:	91 32       	cpi	r25, 0x21	; 33
    2292:	28 f0       	brcs	.+10     	; 0x229e <get_ldnumber+0x2e>
    2294:	9a 33       	cpi	r25, 0x3A	; 58
    2296:	d1 f7       	brne	.-12     	; 0x228c <get_ldnumber+0x1c>
    2298:	04 c0       	rjmp	.+8      	; 0x22a2 <get_ldnumber+0x32>
    229a:	94 2f       	mov	r25, r20
    229c:	9d 01       	movw	r18, r26
    229e:	9a 33       	cpi	r25, 0x3A	; 58
    22a0:	81 f4       	brne	.+32     	; 0x22c2 <get_ldnumber+0x52>
    22a2:	cd 01       	movw	r24, r26
    22a4:	01 96       	adiw	r24, 0x01	; 1
    22a6:	28 17       	cp	r18, r24
    22a8:	39 07       	cpc	r19, r25
    22aa:	71 f4       	brne	.+28     	; 0x22c8 <get_ldnumber+0x58>
    22ac:	40 33       	cpi	r20, 0x30	; 48
    22ae:	79 f4       	brne	.+30     	; 0x22ce <get_ldnumber+0x5e>
    22b0:	12 96       	adiw	r26, 0x02	; 2
    22b2:	b9 83       	std	Y+1, r27	; 0x01
    22b4:	a8 83       	st	Y, r26
    22b6:	80 e0       	ldi	r24, 0x00	; 0
    22b8:	90 e0       	ldi	r25, 0x00	; 0
    22ba:	0e c0       	rjmp	.+28     	; 0x22d8 <get_ldnumber+0x68>
    22bc:	8f ef       	ldi	r24, 0xFF	; 255
    22be:	9f ef       	ldi	r25, 0xFF	; 255
    22c0:	0b c0       	rjmp	.+22     	; 0x22d8 <get_ldnumber+0x68>
    22c2:	80 e0       	ldi	r24, 0x00	; 0
    22c4:	90 e0       	ldi	r25, 0x00	; 0
    22c6:	08 c0       	rjmp	.+16     	; 0x22d8 <get_ldnumber+0x68>
    22c8:	8f ef       	ldi	r24, 0xFF	; 255
    22ca:	9f ef       	ldi	r25, 0xFF	; 255
    22cc:	05 c0       	rjmp	.+10     	; 0x22d8 <get_ldnumber+0x68>
    22ce:	8f ef       	ldi	r24, 0xFF	; 255
    22d0:	9f ef       	ldi	r25, 0xFF	; 255
    22d2:	02 c0       	rjmp	.+4      	; 0x22d8 <get_ldnumber+0x68>
    22d4:	9d 01       	movw	r18, r26
    22d6:	e5 cf       	rjmp	.-54     	; 0x22a2 <get_ldnumber+0x32>
    22d8:	df 91       	pop	r29
    22da:	cf 91       	pop	r28
    22dc:	08 95       	ret

000022de <sync_window>:
    22de:	8f 92       	push	r8
    22e0:	9f 92       	push	r9
    22e2:	af 92       	push	r10
    22e4:	bf 92       	push	r11
    22e6:	cf 92       	push	r12
    22e8:	df 92       	push	r13
    22ea:	ef 92       	push	r14
    22ec:	ff 92       	push	r15
    22ee:	0f 93       	push	r16
    22f0:	1f 93       	push	r17
    22f2:	cf 93       	push	r28
    22f4:	df 93       	push	r29
    22f6:	fc 01       	movw	r30, r24
    22f8:	24 81       	ldd	r18, Z+4	; 0x04
    22fa:	22 23       	and	r18, r18
    22fc:	09 f4       	brne	.+2      	; 0x2300 <sync_window+0x22>
    22fe:	44 c0       	rjmp	.+136    	; 0x2388 <sync_window+0xaa>
    2300:	ec 01       	movw	r28, r24
    2302:	c2 a4       	ldd	r12, Z+42	; 0x2a
    2304:	d3 a4       	ldd	r13, Z+43	; 0x2b
    2306:	e4 a4       	ldd	r14, Z+44	; 0x2c
    2308:	f5 a4       	ldd	r15, Z+45	; 0x2d
    230a:	5c 01       	movw	r10, r24
    230c:	fe e2       	ldi	r31, 0x2E	; 46
    230e:	af 0e       	add	r10, r31
    2310:	b1 1c       	adc	r11, r1
    2312:	01 e0       	ldi	r16, 0x01	; 1
    2314:	10 e0       	ldi	r17, 0x00	; 0
    2316:	a7 01       	movw	r20, r14
    2318:	96 01       	movw	r18, r12
    231a:	b5 01       	movw	r22, r10
    231c:	89 81       	ldd	r24, Y+1	; 0x01
    231e:	00 de       	rcall	.-1024   	; 0x1f20 <disk_write>
    2320:	81 11       	cpse	r24, r1
    2322:	34 c0       	rjmp	.+104    	; 0x238c <sync_window+0xae>
    2324:	1c 82       	std	Y+4, r1	; 0x04
    2326:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2328:	9f 8d       	ldd	r25, Y+31	; 0x1f
    232a:	a8 a1       	ldd	r26, Y+32	; 0x20
    232c:	b9 a1       	ldd	r27, Y+33	; 0x21
    232e:	b7 01       	movw	r22, r14
    2330:	a6 01       	movw	r20, r12
    2332:	48 1b       	sub	r20, r24
    2334:	59 0b       	sbc	r21, r25
    2336:	6a 0b       	sbc	r22, r26
    2338:	7b 0b       	sbc	r23, r27
    233a:	8e 89       	ldd	r24, Y+22	; 0x16
    233c:	9f 89       	ldd	r25, Y+23	; 0x17
    233e:	a8 8d       	ldd	r26, Y+24	; 0x18
    2340:	b9 8d       	ldd	r27, Y+25	; 0x19
    2342:	48 17       	cp	r20, r24
    2344:	59 07       	cpc	r21, r25
    2346:	6a 07       	cpc	r22, r26
    2348:	7b 07       	cpc	r23, r27
    234a:	10 f5       	brcc	.+68     	; 0x2390 <sync_window+0xb2>
    234c:	8b 80       	ldd	r8, Y+3	; 0x03
    234e:	91 2c       	mov	r9, r1
    2350:	82 e0       	ldi	r24, 0x02	; 2
    2352:	88 16       	cp	r8, r24
    2354:	91 04       	cpc	r9, r1
    2356:	f0 f0       	brcs	.+60     	; 0x2394 <sync_window+0xb6>
    2358:	8e 89       	ldd	r24, Y+22	; 0x16
    235a:	9f 89       	ldd	r25, Y+23	; 0x17
    235c:	a8 8d       	ldd	r26, Y+24	; 0x18
    235e:	b9 8d       	ldd	r27, Y+25	; 0x19
    2360:	c8 0e       	add	r12, r24
    2362:	d9 1e       	adc	r13, r25
    2364:	ea 1e       	adc	r14, r26
    2366:	fb 1e       	adc	r15, r27
    2368:	01 e0       	ldi	r16, 0x01	; 1
    236a:	10 e0       	ldi	r17, 0x00	; 0
    236c:	a7 01       	movw	r20, r14
    236e:	96 01       	movw	r18, r12
    2370:	b5 01       	movw	r22, r10
    2372:	89 81       	ldd	r24, Y+1	; 0x01
    2374:	d5 dd       	rcall	.-1110   	; 0x1f20 <disk_write>
    2376:	e1 e0       	ldi	r30, 0x01	; 1
    2378:	8e 1a       	sub	r8, r30
    237a:	91 08       	sbc	r9, r1
    237c:	f1 e0       	ldi	r31, 0x01	; 1
    237e:	8f 16       	cp	r8, r31
    2380:	91 04       	cpc	r9, r1
    2382:	51 f7       	brne	.-44     	; 0x2358 <sync_window+0x7a>
    2384:	80 e0       	ldi	r24, 0x00	; 0
    2386:	07 c0       	rjmp	.+14     	; 0x2396 <sync_window+0xb8>
    2388:	80 e0       	ldi	r24, 0x00	; 0
    238a:	05 c0       	rjmp	.+10     	; 0x2396 <sync_window+0xb8>
    238c:	81 e0       	ldi	r24, 0x01	; 1
    238e:	03 c0       	rjmp	.+6      	; 0x2396 <sync_window+0xb8>
    2390:	80 e0       	ldi	r24, 0x00	; 0
    2392:	01 c0       	rjmp	.+2      	; 0x2396 <sync_window+0xb8>
    2394:	80 e0       	ldi	r24, 0x00	; 0
    2396:	df 91       	pop	r29
    2398:	cf 91       	pop	r28
    239a:	1f 91       	pop	r17
    239c:	0f 91       	pop	r16
    239e:	ff 90       	pop	r15
    23a0:	ef 90       	pop	r14
    23a2:	df 90       	pop	r13
    23a4:	cf 90       	pop	r12
    23a6:	bf 90       	pop	r11
    23a8:	af 90       	pop	r10
    23aa:	9f 90       	pop	r9
    23ac:	8f 90       	pop	r8
    23ae:	08 95       	ret

000023b0 <move_window>:
    23b0:	8f 92       	push	r8
    23b2:	9f 92       	push	r9
    23b4:	af 92       	push	r10
    23b6:	bf 92       	push	r11
    23b8:	ff 92       	push	r15
    23ba:	0f 93       	push	r16
    23bc:	1f 93       	push	r17
    23be:	cf 93       	push	r28
    23c0:	df 93       	push	r29
    23c2:	ec 01       	movw	r28, r24
    23c4:	4a 01       	movw	r8, r20
    23c6:	5b 01       	movw	r10, r22
    23c8:	8a a5       	ldd	r24, Y+42	; 0x2a
    23ca:	9b a5       	ldd	r25, Y+43	; 0x2b
    23cc:	ac a5       	ldd	r26, Y+44	; 0x2c
    23ce:	bd a5       	ldd	r27, Y+45	; 0x2d
    23d0:	84 17       	cp	r24, r20
    23d2:	95 07       	cpc	r25, r21
    23d4:	a6 07       	cpc	r26, r22
    23d6:	b7 07       	cpc	r27, r23
    23d8:	d9 f0       	breq	.+54     	; 0x2410 <move_window+0x60>
    23da:	ce 01       	movw	r24, r28
    23dc:	80 df       	rcall	.-256    	; 0x22de <sync_window>
    23de:	f8 2e       	mov	r15, r24
    23e0:	81 11       	cpse	r24, r1
    23e2:	17 c0       	rjmp	.+46     	; 0x2412 <move_window+0x62>
    23e4:	01 e0       	ldi	r16, 0x01	; 1
    23e6:	10 e0       	ldi	r17, 0x00	; 0
    23e8:	a5 01       	movw	r20, r10
    23ea:	94 01       	movw	r18, r8
    23ec:	be 01       	movw	r22, r28
    23ee:	62 5d       	subi	r22, 0xD2	; 210
    23f0:	7f 4f       	sbci	r23, 0xFF	; 255
    23f2:	89 81       	ldd	r24, Y+1	; 0x01
    23f4:	49 dd       	rcall	.-1390   	; 0x1e88 <disk_read>
    23f6:	88 23       	and	r24, r24
    23f8:	31 f0       	breq	.+12     	; 0x2406 <move_window+0x56>
    23fa:	ff 24       	eor	r15, r15
    23fc:	f3 94       	inc	r15
    23fe:	88 24       	eor	r8, r8
    2400:	8a 94       	dec	r8
    2402:	98 2c       	mov	r9, r8
    2404:	54 01       	movw	r10, r8
    2406:	8a a6       	std	Y+42, r8	; 0x2a
    2408:	9b a6       	std	Y+43, r9	; 0x2b
    240a:	ac a6       	std	Y+44, r10	; 0x2c
    240c:	bd a6       	std	Y+45, r11	; 0x2d
    240e:	01 c0       	rjmp	.+2      	; 0x2412 <move_window+0x62>
    2410:	f1 2c       	mov	r15, r1
    2412:	8f 2d       	mov	r24, r15
    2414:	df 91       	pop	r29
    2416:	cf 91       	pop	r28
    2418:	1f 91       	pop	r17
    241a:	0f 91       	pop	r16
    241c:	ff 90       	pop	r15
    241e:	bf 90       	pop	r11
    2420:	af 90       	pop	r10
    2422:	9f 90       	pop	r9
    2424:	8f 90       	pop	r8
    2426:	08 95       	ret

00002428 <check_fs>:
    2428:	cf 93       	push	r28
    242a:	df 93       	push	r29
    242c:	ec 01       	movw	r28, r24
    242e:	1c 82       	std	Y+4, r1	; 0x04
    2430:	8f ef       	ldi	r24, 0xFF	; 255
    2432:	9f ef       	ldi	r25, 0xFF	; 255
    2434:	dc 01       	movw	r26, r24
    2436:	8a a7       	std	Y+42, r24	; 0x2a
    2438:	9b a7       	std	Y+43, r25	; 0x2b
    243a:	ac a7       	std	Y+44, r26	; 0x2c
    243c:	bd a7       	std	Y+45, r27	; 0x2d
    243e:	ce 01       	movw	r24, r28
    2440:	b7 df       	rcall	.-146    	; 0x23b0 <move_window>
    2442:	81 11       	cpse	r24, r1
    2444:	23 c0       	rjmp	.+70     	; 0x248c <check_fs+0x64>
    2446:	fe 01       	movw	r30, r28
    2448:	e4 5d       	subi	r30, 0xD4	; 212
    244a:	fd 4f       	sbci	r31, 0xFD	; 253
    244c:	80 81       	ld	r24, Z
    244e:	91 81       	ldd	r25, Z+1	; 0x01
    2450:	85 35       	cpi	r24, 0x55	; 85
    2452:	9a 4a       	sbci	r25, 0xAA	; 170
    2454:	e9 f4       	brne	.+58     	; 0x2490 <check_fs+0x68>
    2456:	e8 5c       	subi	r30, 0xC8	; 200
    2458:	f1 40       	sbci	r31, 0x01	; 1
    245a:	80 81       	ld	r24, Z
    245c:	91 81       	ldd	r25, Z+1	; 0x01
    245e:	a2 81       	ldd	r26, Z+2	; 0x02
    2460:	b3 81       	ldd	r27, Z+3	; 0x03
    2462:	bb 27       	eor	r27, r27
    2464:	86 34       	cpi	r24, 0x46	; 70
    2466:	91 44       	sbci	r25, 0x41	; 65
    2468:	a4 45       	sbci	r26, 0x54	; 84
    246a:	b1 05       	cpc	r27, r1
    246c:	99 f0       	breq	.+38     	; 0x2494 <check_fs+0x6c>
    246e:	c0 58       	subi	r28, 0x80	; 128
    2470:	df 4f       	sbci	r29, 0xFF	; 255
    2472:	48 81       	ld	r20, Y
    2474:	59 81       	ldd	r21, Y+1	; 0x01
    2476:	6a 81       	ldd	r22, Y+2	; 0x02
    2478:	7b 81       	ldd	r23, Y+3	; 0x03
    247a:	77 27       	eor	r23, r23
    247c:	81 e0       	ldi	r24, 0x01	; 1
    247e:	46 34       	cpi	r20, 0x46	; 70
    2480:	51 44       	sbci	r21, 0x41	; 65
    2482:	64 45       	sbci	r22, 0x54	; 84
    2484:	71 05       	cpc	r23, r1
    2486:	39 f4       	brne	.+14     	; 0x2496 <check_fs+0x6e>
    2488:	80 e0       	ldi	r24, 0x00	; 0
    248a:	05 c0       	rjmp	.+10     	; 0x2496 <check_fs+0x6e>
    248c:	83 e0       	ldi	r24, 0x03	; 3
    248e:	03 c0       	rjmp	.+6      	; 0x2496 <check_fs+0x6e>
    2490:	82 e0       	ldi	r24, 0x02	; 2
    2492:	01 c0       	rjmp	.+2      	; 0x2496 <check_fs+0x6e>
    2494:	80 e0       	ldi	r24, 0x00	; 0
    2496:	df 91       	pop	r29
    2498:	cf 91       	pop	r28
    249a:	08 95       	ret

0000249c <validate>:
    249c:	00 97       	sbiw	r24, 0x00	; 0
    249e:	c1 f0       	breq	.+48     	; 0x24d0 <validate+0x34>
    24a0:	dc 01       	movw	r26, r24
    24a2:	ed 91       	ld	r30, X+
    24a4:	fc 91       	ld	r31, X
    24a6:	11 97       	sbiw	r26, 0x01	; 1
    24a8:	30 97       	sbiw	r30, 0x00	; 0
    24aa:	a1 f0       	breq	.+40     	; 0x24d4 <validate+0x38>
    24ac:	20 81       	ld	r18, Z
    24ae:	22 23       	and	r18, r18
    24b0:	99 f0       	breq	.+38     	; 0x24d8 <validate+0x3c>
    24b2:	26 81       	ldd	r18, Z+6	; 0x06
    24b4:	37 81       	ldd	r19, Z+7	; 0x07
    24b6:	12 96       	adiw	r26, 0x02	; 2
    24b8:	8d 91       	ld	r24, X+
    24ba:	9c 91       	ld	r25, X
    24bc:	13 97       	sbiw	r26, 0x03	; 3
    24be:	28 17       	cp	r18, r24
    24c0:	39 07       	cpc	r19, r25
    24c2:	61 f4       	brne	.+24     	; 0x24dc <validate+0x40>
    24c4:	81 81       	ldd	r24, Z+1	; 0x01
    24c6:	20 dc       	rcall	.-1984   	; 0x1d08 <disk_status>
    24c8:	80 fd       	sbrc	r24, 0
    24ca:	0a c0       	rjmp	.+20     	; 0x24e0 <validate+0x44>
    24cc:	80 e0       	ldi	r24, 0x00	; 0
    24ce:	08 95       	ret
    24d0:	89 e0       	ldi	r24, 0x09	; 9
    24d2:	08 95       	ret
    24d4:	89 e0       	ldi	r24, 0x09	; 9
    24d6:	08 95       	ret
    24d8:	89 e0       	ldi	r24, 0x09	; 9
    24da:	08 95       	ret
    24dc:	89 e0       	ldi	r24, 0x09	; 9
    24de:	08 95       	ret
    24e0:	83 e0       	ldi	r24, 0x03	; 3
    24e2:	08 95       	ret

000024e4 <find_volume>:
    24e4:	2f 92       	push	r2
    24e6:	3f 92       	push	r3
    24e8:	4f 92       	push	r4
    24ea:	5f 92       	push	r5
    24ec:	6f 92       	push	r6
    24ee:	7f 92       	push	r7
    24f0:	8f 92       	push	r8
    24f2:	9f 92       	push	r9
    24f4:	af 92       	push	r10
    24f6:	bf 92       	push	r11
    24f8:	cf 92       	push	r12
    24fa:	df 92       	push	r13
    24fc:	ef 92       	push	r14
    24fe:	ff 92       	push	r15
    2500:	0f 93       	push	r16
    2502:	1f 93       	push	r17
    2504:	cf 93       	push	r28
    2506:	df 93       	push	r29
    2508:	cd b7       	in	r28, 0x3d	; 61
    250a:	de b7       	in	r29, 0x3e	; 62
    250c:	6d 97       	sbiw	r28, 0x1d	; 29
    250e:	0f b6       	in	r0, 0x3f	; 63
    2510:	f8 94       	cli
    2512:	de bf       	out	0x3e, r29	; 62
    2514:	0f be       	out	0x3f, r0	; 63
    2516:	cd bf       	out	0x3d, r28	; 61
    2518:	6c 01       	movw	r12, r24
    251a:	cb 01       	movw	r24, r22
    251c:	b4 2e       	mov	r11, r20
    251e:	d6 01       	movw	r26, r12
    2520:	1d 92       	st	X+, r1
    2522:	1c 92       	st	X, r1
    2524:	a5 de       	rcall	.-694    	; 0x2270 <get_ldnumber>
    2526:	7c 01       	movw	r14, r24
    2528:	99 23       	and	r25, r25
    252a:	0c f4       	brge	.+2      	; 0x252e <find_volume+0x4a>
    252c:	00 c2       	rjmp	.+1024   	; 0x292e <find_volume+0x44a>
    252e:	fc 01       	movw	r30, r24
    2530:	ee 0f       	add	r30, r30
    2532:	ff 1f       	adc	r31, r31
    2534:	e8 5f       	subi	r30, 0xF8	; 248
    2536:	f9 4f       	sbci	r31, 0xF9	; 249
    2538:	00 81       	ld	r16, Z
    253a:	11 81       	ldd	r17, Z+1	; 0x01
    253c:	01 15       	cp	r16, r1
    253e:	11 05       	cpc	r17, r1
    2540:	09 f4       	brne	.+2      	; 0x2544 <find_volume+0x60>
    2542:	f7 c1       	rjmp	.+1006   	; 0x2932 <find_volume+0x44e>
    2544:	f6 01       	movw	r30, r12
    2546:	11 83       	std	Z+1, r17	; 0x01
    2548:	00 83       	st	Z, r16
    254a:	d8 01       	movw	r26, r16
    254c:	8c 91       	ld	r24, X
    254e:	88 23       	and	r24, r24
    2550:	61 f0       	breq	.+24     	; 0x256a <find_volume+0x86>
    2552:	11 96       	adiw	r26, 0x01	; 1
    2554:	8c 91       	ld	r24, X
    2556:	d8 db       	rcall	.-2128   	; 0x1d08 <disk_status>
    2558:	80 fd       	sbrc	r24, 0
    255a:	07 c0       	rjmp	.+14     	; 0x256a <find_volume+0x86>
    255c:	bb 20       	and	r11, r11
    255e:	09 f4       	brne	.+2      	; 0x2562 <find_volume+0x7e>
    2560:	ea c1       	rjmp	.+980    	; 0x2936 <find_volume+0x452>
    2562:	82 ff       	sbrs	r24, 2
    2564:	ea c1       	rjmp	.+980    	; 0x293a <find_volume+0x456>
    2566:	8a e0       	ldi	r24, 0x0A	; 10
    2568:	8a c2       	rjmp	.+1300   	; 0x2a7e <find_volume+0x59a>
    256a:	f8 01       	movw	r30, r16
    256c:	10 82       	st	Z, r1
    256e:	e1 82       	std	Z+1, r14	; 0x01
    2570:	8e 2d       	mov	r24, r14
    2572:	d1 db       	rcall	.-2142   	; 0x1d16 <disk_initialize>
    2574:	80 fd       	sbrc	r24, 0
    2576:	e3 c1       	rjmp	.+966    	; 0x293e <find_volume+0x45a>
    2578:	bb 20       	and	r11, r11
    257a:	09 f4       	brne	.+2      	; 0x257e <find_volume+0x9a>
    257c:	00 c2       	rjmp	.+1024   	; 0x297e <find_volume+0x49a>
    257e:	82 fd       	sbrc	r24, 2
    2580:	e0 c1       	rjmp	.+960    	; 0x2942 <find_volume+0x45e>
    2582:	fd c1       	rjmp	.+1018   	; 0x297e <find_volume+0x49a>
    2584:	80 81       	ld	r24, Z
    2586:	88 23       	and	r24, r24
    2588:	29 f0       	breq	.+10     	; 0x2594 <find_volume+0xb0>
    258a:	44 80       	ldd	r4, Z+4	; 0x04
    258c:	55 80       	ldd	r5, Z+5	; 0x05
    258e:	66 80       	ldd	r6, Z+6	; 0x06
    2590:	77 80       	ldd	r7, Z+7	; 0x07
    2592:	04 c0       	rjmp	.+8      	; 0x259c <find_volume+0xb8>
    2594:	4e 2c       	mov	r4, r14
    2596:	5f 2c       	mov	r5, r15
    2598:	67 2e       	mov	r6, r23
    259a:	76 2e       	mov	r7, r22
    259c:	d9 01       	movw	r26, r18
    259e:	4d 92       	st	X+, r4
    25a0:	5d 92       	st	X+, r5
    25a2:	6d 92       	st	X+, r6
    25a4:	7d 92       	st	X+, r7
    25a6:	9d 01       	movw	r18, r26
    25a8:	70 96       	adiw	r30, 0x10	; 16
    25aa:	e4 17       	cp	r30, r20
    25ac:	f5 07       	cpc	r31, r21
    25ae:	51 f7       	brne	.-44     	; 0x2584 <find_volume+0xa0>
    25b0:	4e 01       	movw	r8, r28
    25b2:	b1 e1       	ldi	r27, 0x11	; 17
    25b4:	8b 0e       	add	r8, r27
    25b6:	91 1c       	adc	r9, r1
    25b8:	68 94       	set
    25ba:	77 24       	eor	r7, r7
    25bc:	71 f8       	bld	r7, 1
    25be:	f5 01       	movw	r30, r10
    25c0:	c1 90       	ld	r12, Z+
    25c2:	d1 90       	ld	r13, Z+
    25c4:	e1 90       	ld	r14, Z+
    25c6:	f1 90       	ld	r15, Z+
    25c8:	5f 01       	movw	r10, r30
    25ca:	c1 14       	cp	r12, r1
    25cc:	d1 04       	cpc	r13, r1
    25ce:	e1 04       	cpc	r14, r1
    25d0:	f1 04       	cpc	r15, r1
    25d2:	39 f0       	breq	.+14     	; 0x25e2 <find_volume+0xfe>
    25d4:	b7 01       	movw	r22, r14
    25d6:	a6 01       	movw	r20, r12
    25d8:	c8 01       	movw	r24, r16
    25da:	26 df       	rcall	.-436    	; 0x2428 <check_fs>
    25dc:	81 11       	cpse	r24, r1
    25de:	02 c0       	rjmp	.+4      	; 0x25e4 <find_volume+0x100>
    25e0:	08 c0       	rjmp	.+16     	; 0x25f2 <find_volume+0x10e>
    25e2:	87 2d       	mov	r24, r7
    25e4:	a8 14       	cp	r10, r8
    25e6:	b9 04       	cpc	r11, r9
    25e8:	51 f7       	brne	.-44     	; 0x25be <find_volume+0xda>
    25ea:	03 c0       	rjmp	.+6      	; 0x25f2 <find_volume+0x10e>
    25ec:	c1 2c       	mov	r12, r1
    25ee:	d1 2c       	mov	r13, r1
    25f0:	76 01       	movw	r14, r12
    25f2:	83 30       	cpi	r24, 0x03	; 3
    25f4:	09 f4       	brne	.+2      	; 0x25f8 <find_volume+0x114>
    25f6:	a7 c1       	rjmp	.+846    	; 0x2946 <find_volume+0x462>
    25f8:	81 11       	cpse	r24, r1
    25fa:	a7 c1       	rjmp	.+846    	; 0x294a <find_volume+0x466>
    25fc:	d8 01       	movw	r26, r16
    25fe:	d9 96       	adiw	r26, 0x39	; 57
    2600:	8d 91       	ld	r24, X+
    2602:	9c 91       	ld	r25, X
    2604:	da 97       	sbiw	r26, 0x3a	; 58
    2606:	81 15       	cp	r24, r1
    2608:	92 40       	sbci	r25, 0x02	; 2
    260a:	09 f0       	breq	.+2      	; 0x260e <find_volume+0x12a>
    260c:	a0 c1       	rjmp	.+832    	; 0x294e <find_volume+0x46a>
    260e:	f8 01       	movw	r30, r16
    2610:	ec 5b       	subi	r30, 0xBC	; 188
    2612:	ff 4f       	sbci	r31, 0xFF	; 255
    2614:	40 80       	ld	r4, Z
    2616:	51 80       	ldd	r5, Z+1	; 0x01
    2618:	61 2c       	mov	r6, r1
    261a:	71 2c       	mov	r7, r1
    261c:	41 14       	cp	r4, r1
    261e:	51 04       	cpc	r5, r1
    2620:	61 04       	cpc	r6, r1
    2622:	71 04       	cpc	r7, r1
    2624:	29 f4       	brne	.+10     	; 0x2630 <find_volume+0x14c>
    2626:	3e 96       	adiw	r30, 0x0e	; 14
    2628:	40 80       	ld	r4, Z
    262a:	51 80       	ldd	r5, Z+1	; 0x01
    262c:	62 80       	ldd	r6, Z+2	; 0x02
    262e:	73 80       	ldd	r7, Z+3	; 0x03
    2630:	f8 01       	movw	r30, r16
    2632:	46 8a       	std	Z+22, r4	; 0x16
    2634:	57 8a       	std	Z+23, r5	; 0x17
    2636:	60 8e       	std	Z+24, r6	; 0x18
    2638:	71 8e       	std	Z+25, r7	; 0x19
    263a:	a6 ad       	ldd	r26, Z+62	; 0x3e
    263c:	a3 83       	std	Z+3, r26	; 0x03
    263e:	8f ef       	ldi	r24, 0xFF	; 255
    2640:	8a 0f       	add	r24, r26
    2642:	82 30       	cpi	r24, 0x02	; 2
    2644:	08 f0       	brcs	.+2      	; 0x2648 <find_volume+0x164>
    2646:	85 c1       	rjmp	.+778    	; 0x2952 <find_volume+0x46e>
    2648:	f3 ad       	ldd	r31, Z+59	; 0x3b
    264a:	f9 8b       	std	Y+17, r31	; 0x11
    264c:	2f 2f       	mov	r18, r31
    264e:	f8 01       	movw	r30, r16
    2650:	22 83       	std	Z+2, r18	; 0x02
    2652:	22 23       	and	r18, r18
    2654:	09 f4       	brne	.+2      	; 0x2658 <find_volume+0x174>
    2656:	7f c1       	rjmp	.+766    	; 0x2956 <find_volume+0x472>
    2658:	82 2f       	mov	r24, r18
    265a:	90 e0       	ldi	r25, 0x00	; 0
    265c:	9c 01       	movw	r18, r24
    265e:	21 50       	subi	r18, 0x01	; 1
    2660:	31 09       	sbc	r19, r1
    2662:	82 23       	and	r24, r18
    2664:	93 23       	and	r25, r19
    2666:	89 2b       	or	r24, r25
    2668:	09 f0       	breq	.+2      	; 0x266c <find_volume+0x188>
    266a:	77 c1       	rjmp	.+750    	; 0x295a <find_volume+0x476>
    266c:	ff 96       	adiw	r30, 0x3f	; 63
    266e:	20 80       	ld	r2, Z
    2670:	31 80       	ldd	r3, Z+1	; 0x01
    2672:	f8 01       	movw	r30, r16
    2674:	31 86       	std	Z+9, r3	; 0x09
    2676:	20 86       	std	Z+8, r2	; 0x08
    2678:	c1 01       	movw	r24, r2
    267a:	8f 70       	andi	r24, 0x0F	; 15
    267c:	99 27       	eor	r25, r25
    267e:	89 2b       	or	r24, r25
    2680:	09 f0       	breq	.+2      	; 0x2684 <find_volume+0x1a0>
    2682:	6d c1       	rjmp	.+730    	; 0x295e <find_volume+0x47a>
    2684:	ef 5b       	subi	r30, 0xBF	; 191
    2686:	ff 4f       	sbci	r31, 0xFF	; 255
    2688:	80 80       	ld	r8, Z
    268a:	91 80       	ldd	r9, Z+1	; 0x01
    268c:	a1 2c       	mov	r10, r1
    268e:	b1 2c       	mov	r11, r1
    2690:	81 14       	cp	r8, r1
    2692:	91 04       	cpc	r9, r1
    2694:	a1 04       	cpc	r10, r1
    2696:	b1 04       	cpc	r11, r1
    2698:	29 f4       	brne	.+10     	; 0x26a4 <find_volume+0x1c0>
    269a:	3d 96       	adiw	r30, 0x0d	; 13
    269c:	80 80       	ld	r8, Z
    269e:	91 80       	ldd	r9, Z+1	; 0x01
    26a0:	a2 80       	ldd	r10, Z+2	; 0x02
    26a2:	b3 80       	ldd	r11, Z+3	; 0x03
    26a4:	f8 01       	movw	r30, r16
    26a6:	04 ac       	ldd	r0, Z+60	; 0x3c
    26a8:	f5 ad       	ldd	r31, Z+61	; 0x3d
    26aa:	e0 2d       	mov	r30, r0
    26ac:	30 97       	sbiw	r30, 0x00	; 0
    26ae:	09 f4       	brne	.+2      	; 0x26b2 <find_volume+0x1ce>
    26b0:	58 c1       	rjmp	.+688    	; 0x2962 <find_volume+0x47e>
    26b2:	b0 e0       	ldi	r27, 0x00	; 0
    26b4:	a3 01       	movw	r20, r6
    26b6:	92 01       	movw	r18, r4
    26b8:	0e 94 2f 39 	call	0x725e	; 0x725e <__muluhisi3>
    26bc:	6a 8f       	std	Y+26, r22	; 0x1a
    26be:	7b 8f       	std	Y+27, r23	; 0x1b
    26c0:	8c 8f       	std	Y+28, r24	; 0x1c
    26c2:	9d 8f       	std	Y+29, r25	; 0x1d
    26c4:	9f 01       	movw	r18, r30
    26c6:	40 e0       	ldi	r20, 0x00	; 0
    26c8:	50 e0       	ldi	r21, 0x00	; 0
    26ca:	2e 8b       	std	Y+22, r18	; 0x16
    26cc:	3f 8b       	std	Y+23, r19	; 0x17
    26ce:	48 8f       	std	Y+24, r20	; 0x18
    26d0:	59 8f       	std	Y+25, r21	; 0x19
    26d2:	c1 01       	movw	r24, r2
    26d4:	92 95       	swap	r25
    26d6:	82 95       	swap	r24
    26d8:	8f 70       	andi	r24, 0x0F	; 15
    26da:	89 27       	eor	r24, r25
    26dc:	9f 70       	andi	r25, 0x0F	; 15
    26de:	89 27       	eor	r24, r25
    26e0:	28 0f       	add	r18, r24
    26e2:	39 1f       	adc	r19, r25
    26e4:	41 1d       	adc	r20, r1
    26e6:	51 1d       	adc	r21, r1
    26e8:	da 01       	movw	r26, r20
    26ea:	c9 01       	movw	r24, r18
    26ec:	2a 8d       	ldd	r18, Y+26	; 0x1a
    26ee:	3b 8d       	ldd	r19, Y+27	; 0x1b
    26f0:	4c 8d       	ldd	r20, Y+28	; 0x1c
    26f2:	5d 8d       	ldd	r21, Y+29	; 0x1d
    26f4:	28 0f       	add	r18, r24
    26f6:	39 1f       	adc	r19, r25
    26f8:	4a 1f       	adc	r20, r26
    26fa:	5b 1f       	adc	r21, r27
    26fc:	2a 8b       	std	Y+18, r18	; 0x12
    26fe:	3b 8b       	std	Y+19, r19	; 0x13
    2700:	4c 8b       	std	Y+20, r20	; 0x14
    2702:	5d 8b       	std	Y+21, r21	; 0x15
    2704:	82 16       	cp	r8, r18
    2706:	93 06       	cpc	r9, r19
    2708:	a4 06       	cpc	r10, r20
    270a:	b5 06       	cpc	r11, r21
    270c:	08 f4       	brcc	.+2      	; 0x2710 <find_volume+0x22c>
    270e:	2b c1       	rjmp	.+598    	; 0x2966 <find_volume+0x482>
    2710:	c5 01       	movw	r24, r10
    2712:	b4 01       	movw	r22, r8
    2714:	62 1b       	sub	r22, r18
    2716:	73 0b       	sbc	r23, r19
    2718:	84 0b       	sbc	r24, r20
    271a:	95 0b       	sbc	r25, r21
    271c:	e9 89       	ldd	r30, Y+17	; 0x11
    271e:	2e 2f       	mov	r18, r30
    2720:	30 e0       	ldi	r19, 0x00	; 0
    2722:	40 e0       	ldi	r20, 0x00	; 0
    2724:	50 e0       	ldi	r21, 0x00	; 0
    2726:	0e 94 0d 39 	call	0x721a	; 0x721a <__udivmodsi4>
    272a:	da 01       	movw	r26, r20
    272c:	c9 01       	movw	r24, r18
    272e:	21 15       	cp	r18, r1
    2730:	31 05       	cpc	r19, r1
    2732:	41 05       	cpc	r20, r1
    2734:	51 05       	cpc	r21, r1
    2736:	09 f4       	brne	.+2      	; 0x273a <find_volume+0x256>
    2738:	18 c1       	rjmp	.+560    	; 0x296a <find_volume+0x486>
    273a:	26 3f       	cpi	r18, 0xF6	; 246
    273c:	ff e0       	ldi	r31, 0x0F	; 15
    273e:	3f 07       	cpc	r19, r31
    2740:	41 05       	cpc	r20, r1
    2742:	51 05       	cpc	r21, r1
    2744:	18 f0       	brcs	.+6      	; 0x274c <find_volume+0x268>
    2746:	e2 e0       	ldi	r30, 0x02	; 2
    2748:	e9 8b       	std	Y+17, r30	; 0x11
    274a:	02 c0       	rjmp	.+4      	; 0x2750 <find_volume+0x26c>
    274c:	f1 e0       	ldi	r31, 0x01	; 1
    274e:	f9 8b       	std	Y+17, r31	; 0x11
    2750:	86 3f       	cpi	r24, 0xF6	; 246
    2752:	9f 4f       	sbci	r25, 0xFF	; 255
    2754:	a1 05       	cpc	r26, r1
    2756:	b1 05       	cpc	r27, r1
    2758:	08 f0       	brcs	.+2      	; 0x275c <find_volume+0x278>
    275a:	28 c1       	rjmp	.+592    	; 0x29ac <find_volume+0x4c8>
    275c:	49 01       	movw	r8, r18
    275e:	5a 01       	movw	r10, r20
    2760:	82 e0       	ldi	r24, 0x02	; 2
    2762:	88 0e       	add	r8, r24
    2764:	91 1c       	adc	r9, r1
    2766:	a1 1c       	adc	r10, r1
    2768:	b1 1c       	adc	r11, r1
    276a:	d8 01       	movw	r26, r16
    276c:	52 96       	adiw	r26, 0x12	; 18
    276e:	8d 92       	st	X+, r8
    2770:	9d 92       	st	X+, r9
    2772:	ad 92       	st	X+, r10
    2774:	bc 92       	st	X, r11
    2776:	55 97       	sbiw	r26, 0x15	; 21
    2778:	f8 01       	movw	r30, r16
    277a:	c2 8e       	std	Z+26, r12	; 0x1a
    277c:	d3 8e       	std	Z+27, r13	; 0x1b
    277e:	e4 8e       	std	Z+28, r14	; 0x1c
    2780:	f5 8e       	std	Z+29, r15	; 0x1d
    2782:	8e 89       	ldd	r24, Y+22	; 0x16
    2784:	9f 89       	ldd	r25, Y+23	; 0x17
    2786:	a8 8d       	ldd	r26, Y+24	; 0x18
    2788:	b9 8d       	ldd	r27, Y+25	; 0x19
    278a:	8c 0d       	add	r24, r12
    278c:	9d 1d       	adc	r25, r13
    278e:	ae 1d       	adc	r26, r14
    2790:	bf 1d       	adc	r27, r15
    2792:	86 8f       	std	Z+30, r24	; 0x1e
    2794:	97 8f       	std	Z+31, r25	; 0x1f
    2796:	a0 a3       	std	Z+32, r26	; 0x20
    2798:	b1 a3       	std	Z+33, r27	; 0x21
    279a:	4a 89       	ldd	r20, Y+18	; 0x12
    279c:	5b 89       	ldd	r21, Y+19	; 0x13
    279e:	6c 89       	ldd	r22, Y+20	; 0x14
    27a0:	7d 89       	ldd	r23, Y+21	; 0x15
    27a2:	4c 0d       	add	r20, r12
    27a4:	5d 1d       	adc	r21, r13
    27a6:	6e 1d       	adc	r22, r14
    27a8:	7f 1d       	adc	r23, r15
    27aa:	46 a3       	std	Z+38, r20	; 0x26
    27ac:	57 a3       	std	Z+39, r21	; 0x27
    27ae:	60 a7       	std	Z+40, r22	; 0x28
    27b0:	71 a7       	std	Z+41, r23	; 0x29
    27b2:	f9 89       	ldd	r31, Y+17	; 0x11
    27b4:	f3 30       	cpi	r31, 0x03	; 3
    27b6:	69 f5       	brne	.+90     	; 0x2812 <find_volume+0x32e>
    27b8:	23 28       	or	r2, r3
    27ba:	09 f0       	breq	.+2      	; 0x27be <find_volume+0x2da>
    27bc:	d8 c0       	rjmp	.+432    	; 0x296e <find_volume+0x48a>
    27be:	f8 01       	movw	r30, r16
    27c0:	e6 5a       	subi	r30, 0xA6	; 166
    27c2:	ff 4f       	sbci	r31, 0xFF	; 255
    27c4:	80 81       	ld	r24, Z
    27c6:	91 81       	ldd	r25, Z+1	; 0x01
    27c8:	a2 81       	ldd	r26, Z+2	; 0x02
    27ca:	b3 81       	ldd	r27, Z+3	; 0x03
    27cc:	f8 01       	movw	r30, r16
    27ce:	82 a3       	std	Z+34, r24	; 0x22
    27d0:	93 a3       	std	Z+35, r25	; 0x23
    27d2:	a4 a3       	std	Z+36, r26	; 0x24
    27d4:	b5 a3       	std	Z+37, r27	; 0x25
    27d6:	88 0c       	add	r8, r8
    27d8:	99 1c       	adc	r9, r9
    27da:	aa 1c       	adc	r10, r10
    27dc:	bb 1c       	adc	r11, r11
    27de:	88 0c       	add	r8, r8
    27e0:	99 1c       	adc	r9, r9
    27e2:	aa 1c       	adc	r10, r10
    27e4:	bb 1c       	adc	r11, r11
    27e6:	ff ef       	ldi	r31, 0xFF	; 255
    27e8:	8f 0e       	add	r8, r31
    27ea:	f1 e0       	ldi	r31, 0x01	; 1
    27ec:	9f 1e       	adc	r9, r31
    27ee:	a1 1c       	adc	r10, r1
    27f0:	b1 1c       	adc	r11, r1
    27f2:	07 2e       	mov	r0, r23
    27f4:	79 e0       	ldi	r23, 0x09	; 9
    27f6:	b6 94       	lsr	r11
    27f8:	a7 94       	ror	r10
    27fa:	97 94       	ror	r9
    27fc:	87 94       	ror	r8
    27fe:	7a 95       	dec	r23
    2800:	d1 f7       	brne	.-12     	; 0x27f6 <find_volume+0x312>
    2802:	70 2d       	mov	r23, r0
    2804:	48 14       	cp	r4, r8
    2806:	59 04       	cpc	r5, r9
    2808:	6a 04       	cpc	r6, r10
    280a:	7b 04       	cpc	r7, r11
    280c:	08 f4       	brcc	.+2      	; 0x2810 <find_volume+0x32c>
    280e:	b1 c0       	rjmp	.+354    	; 0x2972 <find_volume+0x48e>
    2810:	1e c1       	rjmp	.+572    	; 0x2a4e <find_volume+0x56a>
    2812:	23 28       	or	r2, r3
    2814:	09 f4       	brne	.+2      	; 0x2818 <find_volume+0x334>
    2816:	af c0       	rjmp	.+350    	; 0x2976 <find_volume+0x492>
    2818:	2a 8d       	ldd	r18, Y+26	; 0x1a
    281a:	3b 8d       	ldd	r19, Y+27	; 0x1b
    281c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    281e:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2820:	82 0f       	add	r24, r18
    2822:	93 1f       	adc	r25, r19
    2824:	a4 1f       	adc	r26, r20
    2826:	b5 1f       	adc	r27, r21
    2828:	f8 01       	movw	r30, r16
    282a:	82 a3       	std	Z+34, r24	; 0x22
    282c:	93 a3       	std	Z+35, r25	; 0x23
    282e:	a4 a3       	std	Z+36, r26	; 0x24
    2830:	b5 a3       	std	Z+37, r27	; 0x25
    2832:	f9 89       	ldd	r31, Y+17	; 0x11
    2834:	f2 30       	cpi	r31, 0x02	; 2
    2836:	29 f4       	brne	.+10     	; 0x2842 <find_volume+0x35e>
    2838:	88 0c       	add	r8, r8
    283a:	99 1c       	adc	r9, r9
    283c:	aa 1c       	adc	r10, r10
    283e:	bb 1c       	adc	r11, r11
    2840:	f0 c0       	rjmp	.+480    	; 0x2a22 <find_volume+0x53e>
    2842:	a3 e0       	ldi	r26, 0x03	; 3
    2844:	b0 e0       	ldi	r27, 0x00	; 0
    2846:	a5 01       	movw	r20, r10
    2848:	94 01       	movw	r18, r8
    284a:	0e 94 2f 39 	call	0x725e	; 0x725e <__muluhisi3>
    284e:	dc 01       	movw	r26, r24
    2850:	cb 01       	movw	r24, r22
    2852:	b6 95       	lsr	r27
    2854:	a7 95       	ror	r26
    2856:	97 95       	ror	r25
    2858:	87 95       	ror	r24
    285a:	21 e0       	ldi	r18, 0x01	; 1
    285c:	82 22       	and	r8, r18
    285e:	99 24       	eor	r9, r9
    2860:	aa 24       	eor	r10, r10
    2862:	bb 24       	eor	r11, r11
    2864:	88 0e       	add	r8, r24
    2866:	99 1e       	adc	r9, r25
    2868:	aa 1e       	adc	r10, r26
    286a:	bb 1e       	adc	r11, r27
    286c:	da c0       	rjmp	.+436    	; 0x2a22 <find_volume+0x53e>
    286e:	b7 01       	movw	r22, r14
    2870:	a6 01       	movw	r20, r12
    2872:	4f 5f       	subi	r20, 0xFF	; 255
    2874:	5f 4f       	sbci	r21, 0xFF	; 255
    2876:	6f 4f       	sbci	r22, 0xFF	; 255
    2878:	7f 4f       	sbci	r23, 0xFF	; 255
    287a:	c8 01       	movw	r24, r16
    287c:	99 dd       	rcall	.-1230   	; 0x23b0 <move_window>
    287e:	81 11       	cpse	r24, r1
    2880:	39 c0       	rjmp	.+114    	; 0x28f4 <find_volume+0x410>
    2882:	d8 01       	movw	r26, r16
    2884:	15 96       	adiw	r26, 0x05	; 5
    2886:	1c 92       	st	X, r1
    2888:	f8 01       	movw	r30, r16
    288a:	e4 5d       	subi	r30, 0xD4	; 212
    288c:	fd 4f       	sbci	r31, 0xFD	; 253
    288e:	80 81       	ld	r24, Z
    2890:	91 81       	ldd	r25, Z+1	; 0x01
    2892:	85 35       	cpi	r24, 0x55	; 85
    2894:	9a 4a       	sbci	r25, 0xAA	; 170
    2896:	89 f5       	brne	.+98     	; 0x28fa <find_volume+0x416>
    2898:	f8 01       	movw	r30, r16
    289a:	86 a5       	ldd	r24, Z+46	; 0x2e
    289c:	97 a5       	ldd	r25, Z+47	; 0x2f
    289e:	a0 a9       	ldd	r26, Z+48	; 0x30
    28a0:	b1 a9       	ldd	r27, Z+49	; 0x31
    28a2:	82 35       	cpi	r24, 0x52	; 82
    28a4:	92 45       	sbci	r25, 0x52	; 82
    28a6:	a1 46       	sbci	r26, 0x61	; 97
    28a8:	b1 44       	sbci	r27, 0x41	; 65
    28aa:	51 f5       	brne	.+84     	; 0x2900 <find_volume+0x41c>
    28ac:	f8 01       	movw	r30, r16
    28ae:	ee 5e       	subi	r30, 0xEE	; 238
    28b0:	fd 4f       	sbci	r31, 0xFD	; 253
    28b2:	80 81       	ld	r24, Z
    28b4:	91 81       	ldd	r25, Z+1	; 0x01
    28b6:	a2 81       	ldd	r26, Z+2	; 0x02
    28b8:	b3 81       	ldd	r27, Z+3	; 0x03
    28ba:	82 37       	cpi	r24, 0x72	; 114
    28bc:	92 47       	sbci	r25, 0x72	; 114
    28be:	a1 44       	sbci	r26, 0x41	; 65
    28c0:	b1 46       	sbci	r27, 0x61	; 97
    28c2:	09 f5       	brne	.+66     	; 0x2906 <find_volume+0x422>
    28c4:	34 96       	adiw	r30, 0x04	; 4
    28c6:	80 81       	ld	r24, Z
    28c8:	91 81       	ldd	r25, Z+1	; 0x01
    28ca:	a2 81       	ldd	r26, Z+2	; 0x02
    28cc:	b3 81       	ldd	r27, Z+3	; 0x03
    28ce:	f8 01       	movw	r30, r16
    28d0:	86 87       	std	Z+14, r24	; 0x0e
    28d2:	97 87       	std	Z+15, r25	; 0x0f
    28d4:	a0 8b       	std	Z+16, r26	; 0x10
    28d6:	b1 8b       	std	Z+17, r27	; 0x11
    28d8:	e6 5e       	subi	r30, 0xE6	; 230
    28da:	fd 4f       	sbci	r31, 0xFD	; 253
    28dc:	80 81       	ld	r24, Z
    28de:	91 81       	ldd	r25, Z+1	; 0x01
    28e0:	a2 81       	ldd	r26, Z+2	; 0x02
    28e2:	b3 81       	ldd	r27, Z+3	; 0x03
    28e4:	f8 01       	movw	r30, r16
    28e6:	82 87       	std	Z+10, r24	; 0x0a
    28e8:	93 87       	std	Z+11, r25	; 0x0b
    28ea:	a4 87       	std	Z+12, r26	; 0x0c
    28ec:	b5 87       	std	Z+13, r27	; 0x0d
    28ee:	f3 e0       	ldi	r31, 0x03	; 3
    28f0:	f9 8b       	std	Y+17, r31	; 0x11
    28f2:	0b c0       	rjmp	.+22     	; 0x290a <find_volume+0x426>
    28f4:	e3 e0       	ldi	r30, 0x03	; 3
    28f6:	e9 8b       	std	Y+17, r30	; 0x11
    28f8:	08 c0       	rjmp	.+16     	; 0x290a <find_volume+0x426>
    28fa:	f3 e0       	ldi	r31, 0x03	; 3
    28fc:	f9 8b       	std	Y+17, r31	; 0x11
    28fe:	05 c0       	rjmp	.+10     	; 0x290a <find_volume+0x426>
    2900:	e3 e0       	ldi	r30, 0x03	; 3
    2902:	e9 8b       	std	Y+17, r30	; 0x11
    2904:	02 c0       	rjmp	.+4      	; 0x290a <find_volume+0x426>
    2906:	f3 e0       	ldi	r31, 0x03	; 3
    2908:	f9 8b       	std	Y+17, r31	; 0x11
    290a:	e9 89       	ldd	r30, Y+17	; 0x11
    290c:	d8 01       	movw	r26, r16
    290e:	ec 93       	st	X, r30
    2910:	80 91 06 06 	lds	r24, 0x0606
    2914:	90 91 07 06 	lds	r25, 0x0607
    2918:	01 96       	adiw	r24, 0x01	; 1
    291a:	90 93 07 06 	sts	0x0607, r25
    291e:	80 93 06 06 	sts	0x0606, r24
    2922:	17 96       	adiw	r26, 0x07	; 7
    2924:	9c 93       	st	X, r25
    2926:	8e 93       	st	-X, r24
    2928:	16 97       	sbiw	r26, 0x06	; 6
    292a:	80 e0       	ldi	r24, 0x00	; 0
    292c:	a8 c0       	rjmp	.+336    	; 0x2a7e <find_volume+0x59a>
    292e:	8b e0       	ldi	r24, 0x0B	; 11
    2930:	a6 c0       	rjmp	.+332    	; 0x2a7e <find_volume+0x59a>
    2932:	8c e0       	ldi	r24, 0x0C	; 12
    2934:	a4 c0       	rjmp	.+328    	; 0x2a7e <find_volume+0x59a>
    2936:	80 e0       	ldi	r24, 0x00	; 0
    2938:	a2 c0       	rjmp	.+324    	; 0x2a7e <find_volume+0x59a>
    293a:	80 e0       	ldi	r24, 0x00	; 0
    293c:	a0 c0       	rjmp	.+320    	; 0x2a7e <find_volume+0x59a>
    293e:	83 e0       	ldi	r24, 0x03	; 3
    2940:	9e c0       	rjmp	.+316    	; 0x2a7e <find_volume+0x59a>
    2942:	8a e0       	ldi	r24, 0x0A	; 10
    2944:	9c c0       	rjmp	.+312    	; 0x2a7e <find_volume+0x59a>
    2946:	81 e0       	ldi	r24, 0x01	; 1
    2948:	9a c0       	rjmp	.+308    	; 0x2a7e <find_volume+0x59a>
    294a:	8d e0       	ldi	r24, 0x0D	; 13
    294c:	98 c0       	rjmp	.+304    	; 0x2a7e <find_volume+0x59a>
    294e:	8d e0       	ldi	r24, 0x0D	; 13
    2950:	96 c0       	rjmp	.+300    	; 0x2a7e <find_volume+0x59a>
    2952:	8d e0       	ldi	r24, 0x0D	; 13
    2954:	94 c0       	rjmp	.+296    	; 0x2a7e <find_volume+0x59a>
    2956:	8d e0       	ldi	r24, 0x0D	; 13
    2958:	92 c0       	rjmp	.+292    	; 0x2a7e <find_volume+0x59a>
    295a:	8d e0       	ldi	r24, 0x0D	; 13
    295c:	90 c0       	rjmp	.+288    	; 0x2a7e <find_volume+0x59a>
    295e:	8d e0       	ldi	r24, 0x0D	; 13
    2960:	8e c0       	rjmp	.+284    	; 0x2a7e <find_volume+0x59a>
    2962:	8d e0       	ldi	r24, 0x0D	; 13
    2964:	8c c0       	rjmp	.+280    	; 0x2a7e <find_volume+0x59a>
    2966:	8d e0       	ldi	r24, 0x0D	; 13
    2968:	8a c0       	rjmp	.+276    	; 0x2a7e <find_volume+0x59a>
    296a:	8d e0       	ldi	r24, 0x0D	; 13
    296c:	88 c0       	rjmp	.+272    	; 0x2a7e <find_volume+0x59a>
    296e:	8d e0       	ldi	r24, 0x0D	; 13
    2970:	86 c0       	rjmp	.+268    	; 0x2a7e <find_volume+0x59a>
    2972:	8d e0       	ldi	r24, 0x0D	; 13
    2974:	84 c0       	rjmp	.+264    	; 0x2a7e <find_volume+0x59a>
    2976:	8d e0       	ldi	r24, 0x0D	; 13
    2978:	82 c0       	rjmp	.+260    	; 0x2a7e <find_volume+0x59a>
    297a:	8d e0       	ldi	r24, 0x0D	; 13
    297c:	80 c0       	rjmp	.+256    	; 0x2a7e <find_volume+0x59a>
    297e:	40 e0       	ldi	r20, 0x00	; 0
    2980:	50 e0       	ldi	r21, 0x00	; 0
    2982:	ba 01       	movw	r22, r20
    2984:	c8 01       	movw	r24, r16
    2986:	50 dd       	rcall	.-1376   	; 0x2428 <check_fs>
    2988:	81 30       	cpi	r24, 0x01	; 1
    298a:	09 f0       	breq	.+2      	; 0x298e <find_volume+0x4aa>
    298c:	2f ce       	rjmp	.-930    	; 0x25ec <find_volume+0x108>
    298e:	f8 01       	movw	r30, r16
    2990:	e0 51       	subi	r30, 0x10	; 16
    2992:	fe 4f       	sbci	r31, 0xFE	; 254
    2994:	9e 01       	movw	r18, r28
    2996:	2f 5f       	subi	r18, 0xFF	; 255
    2998:	3f 4f       	sbci	r19, 0xFF	; 255
    299a:	59 01       	movw	r10, r18
    299c:	a8 01       	movw	r20, r16
    299e:	40 5d       	subi	r20, 0xD0	; 208
    29a0:	5d 4f       	sbci	r21, 0xFD	; 253
    29a2:	e1 2c       	mov	r14, r1
    29a4:	f1 2c       	mov	r15, r1
    29a6:	70 e0       	ldi	r23, 0x00	; 0
    29a8:	60 e0       	ldi	r22, 0x00	; 0
    29aa:	ec cd       	rjmp	.-1064   	; 0x2584 <find_volume+0xa0>
    29ac:	49 01       	movw	r8, r18
    29ae:	5a 01       	movw	r10, r20
    29b0:	62 e0       	ldi	r22, 0x02	; 2
    29b2:	86 0e       	add	r8, r22
    29b4:	91 1c       	adc	r9, r1
    29b6:	a1 1c       	adc	r10, r1
    29b8:	b1 1c       	adc	r11, r1
    29ba:	d8 01       	movw	r26, r16
    29bc:	52 96       	adiw	r26, 0x12	; 18
    29be:	8d 92       	st	X+, r8
    29c0:	9d 92       	st	X+, r9
    29c2:	ad 92       	st	X+, r10
    29c4:	bc 92       	st	X, r11
    29c6:	55 97       	sbiw	r26, 0x15	; 21
    29c8:	f8 01       	movw	r30, r16
    29ca:	c2 8e       	std	Z+26, r12	; 0x1a
    29cc:	d3 8e       	std	Z+27, r13	; 0x1b
    29ce:	e4 8e       	std	Z+28, r14	; 0x1c
    29d0:	f5 8e       	std	Z+29, r15	; 0x1d
    29d2:	8e 89       	ldd	r24, Y+22	; 0x16
    29d4:	9f 89       	ldd	r25, Y+23	; 0x17
    29d6:	a8 8d       	ldd	r26, Y+24	; 0x18
    29d8:	b9 8d       	ldd	r27, Y+25	; 0x19
    29da:	8c 0d       	add	r24, r12
    29dc:	9d 1d       	adc	r25, r13
    29de:	ae 1d       	adc	r26, r14
    29e0:	bf 1d       	adc	r27, r15
    29e2:	86 8f       	std	Z+30, r24	; 0x1e
    29e4:	97 8f       	std	Z+31, r25	; 0x1f
    29e6:	a0 a3       	std	Z+32, r26	; 0x20
    29e8:	b1 a3       	std	Z+33, r27	; 0x21
    29ea:	8a 89       	ldd	r24, Y+18	; 0x12
    29ec:	9b 89       	ldd	r25, Y+19	; 0x13
    29ee:	ac 89       	ldd	r26, Y+20	; 0x14
    29f0:	bd 89       	ldd	r27, Y+21	; 0x15
    29f2:	8c 0d       	add	r24, r12
    29f4:	9d 1d       	adc	r25, r13
    29f6:	ae 1d       	adc	r26, r14
    29f8:	bf 1d       	adc	r27, r15
    29fa:	86 a3       	std	Z+38, r24	; 0x26
    29fc:	97 a3       	std	Z+39, r25	; 0x27
    29fe:	a0 a7       	std	Z+40, r26	; 0x28
    2a00:	b1 a7       	std	Z+41, r27	; 0x29
    2a02:	da ce       	rjmp	.-588    	; 0x27b8 <find_volume+0x2d4>
    2a04:	8f ef       	ldi	r24, 0xFF	; 255
    2a06:	9f ef       	ldi	r25, 0xFF	; 255
    2a08:	dc 01       	movw	r26, r24
    2a0a:	f8 01       	movw	r30, r16
    2a0c:	86 87       	std	Z+14, r24	; 0x0e
    2a0e:	97 87       	std	Z+15, r25	; 0x0f
    2a10:	a0 8b       	std	Z+16, r26	; 0x10
    2a12:	b1 8b       	std	Z+17, r27	; 0x11
    2a14:	82 87       	std	Z+10, r24	; 0x0a
    2a16:	93 87       	std	Z+11, r25	; 0x0b
    2a18:	a4 87       	std	Z+12, r26	; 0x0c
    2a1a:	b5 87       	std	Z+13, r27	; 0x0d
    2a1c:	80 e8       	ldi	r24, 0x80	; 128
    2a1e:	85 83       	std	Z+5, r24	; 0x05
    2a20:	74 cf       	rjmp	.-280    	; 0x290a <find_volume+0x426>
    2a22:	ff ef       	ldi	r31, 0xFF	; 255
    2a24:	8f 0e       	add	r8, r31
    2a26:	f1 e0       	ldi	r31, 0x01	; 1
    2a28:	9f 1e       	adc	r9, r31
    2a2a:	a1 1c       	adc	r10, r1
    2a2c:	b1 1c       	adc	r11, r1
    2a2e:	07 2e       	mov	r0, r23
    2a30:	79 e0       	ldi	r23, 0x09	; 9
    2a32:	b6 94       	lsr	r11
    2a34:	a7 94       	ror	r10
    2a36:	97 94       	ror	r9
    2a38:	87 94       	ror	r8
    2a3a:	7a 95       	dec	r23
    2a3c:	d1 f7       	brne	.-12     	; 0x2a32 <find_volume+0x54e>
    2a3e:	70 2d       	mov	r23, r0
    2a40:	48 14       	cp	r4, r8
    2a42:	59 04       	cpc	r5, r9
    2a44:	6a 04       	cpc	r6, r10
    2a46:	7b 04       	cpc	r7, r11
    2a48:	08 f4       	brcc	.+2      	; 0x2a4c <find_volume+0x568>
    2a4a:	97 cf       	rjmp	.-210    	; 0x297a <find_volume+0x496>
    2a4c:	db cf       	rjmp	.-74     	; 0x2a04 <find_volume+0x520>
    2a4e:	8f ef       	ldi	r24, 0xFF	; 255
    2a50:	9f ef       	ldi	r25, 0xFF	; 255
    2a52:	dc 01       	movw	r26, r24
    2a54:	f8 01       	movw	r30, r16
    2a56:	86 87       	std	Z+14, r24	; 0x0e
    2a58:	97 87       	std	Z+15, r25	; 0x0f
    2a5a:	a0 8b       	std	Z+16, r26	; 0x10
    2a5c:	b1 8b       	std	Z+17, r27	; 0x11
    2a5e:	82 87       	std	Z+10, r24	; 0x0a
    2a60:	93 87       	std	Z+11, r25	; 0x0b
    2a62:	a4 87       	std	Z+12, r26	; 0x0c
    2a64:	b5 87       	std	Z+13, r27	; 0x0d
    2a66:	80 e8       	ldi	r24, 0x80	; 128
    2a68:	85 83       	std	Z+5, r24	; 0x05
    2a6a:	e2 5a       	subi	r30, 0xA2	; 162
    2a6c:	ff 4f       	sbci	r31, 0xFF	; 255
    2a6e:	80 81       	ld	r24, Z
    2a70:	91 81       	ldd	r25, Z+1	; 0x01
    2a72:	01 97       	sbiw	r24, 0x01	; 1
    2a74:	09 f4       	brne	.+2      	; 0x2a78 <find_volume+0x594>
    2a76:	fb ce       	rjmp	.-522    	; 0x286e <find_volume+0x38a>
    2a78:	f3 e0       	ldi	r31, 0x03	; 3
    2a7a:	f9 8b       	std	Y+17, r31	; 0x11
    2a7c:	46 cf       	rjmp	.-372    	; 0x290a <find_volume+0x426>
    2a7e:	6d 96       	adiw	r28, 0x1d	; 29
    2a80:	0f b6       	in	r0, 0x3f	; 63
    2a82:	f8 94       	cli
    2a84:	de bf       	out	0x3e, r29	; 62
    2a86:	0f be       	out	0x3f, r0	; 63
    2a88:	cd bf       	out	0x3d, r28	; 61
    2a8a:	df 91       	pop	r29
    2a8c:	cf 91       	pop	r28
    2a8e:	1f 91       	pop	r17
    2a90:	0f 91       	pop	r16
    2a92:	ff 90       	pop	r15
    2a94:	ef 90       	pop	r14
    2a96:	df 90       	pop	r13
    2a98:	cf 90       	pop	r12
    2a9a:	bf 90       	pop	r11
    2a9c:	af 90       	pop	r10
    2a9e:	9f 90       	pop	r9
    2aa0:	8f 90       	pop	r8
    2aa2:	7f 90       	pop	r7
    2aa4:	6f 90       	pop	r6
    2aa6:	5f 90       	pop	r5
    2aa8:	4f 90       	pop	r4
    2aaa:	3f 90       	pop	r3
    2aac:	2f 90       	pop	r2
    2aae:	08 95       	ret

00002ab0 <sync_fs>:
    2ab0:	0f 93       	push	r16
    2ab2:	1f 93       	push	r17
    2ab4:	cf 93       	push	r28
    2ab6:	df 93       	push	r29
    2ab8:	ec 01       	movw	r28, r24
    2aba:	11 dc       	rcall	.-2014   	; 0x22de <sync_window>
    2abc:	98 2f       	mov	r25, r24
    2abe:	81 11       	cpse	r24, r1
    2ac0:	59 c0       	rjmp	.+178    	; 0x2b74 <sync_fs+0xc4>
    2ac2:	88 81       	ld	r24, Y
    2ac4:	83 30       	cpi	r24, 0x03	; 3
    2ac6:	09 f0       	breq	.+2      	; 0x2aca <sync_fs+0x1a>
    2ac8:	4c c0       	rjmp	.+152    	; 0x2b62 <sync_fs+0xb2>
    2aca:	8d 81       	ldd	r24, Y+5	; 0x05
    2acc:	81 30       	cpi	r24, 0x01	; 1
    2ace:	09 f0       	breq	.+2      	; 0x2ad2 <sync_fs+0x22>
    2ad0:	48 c0       	rjmp	.+144    	; 0x2b62 <sync_fs+0xb2>
    2ad2:	be 01       	movw	r22, r28
    2ad4:	62 5d       	subi	r22, 0xD2	; 210
    2ad6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ad8:	fb 01       	movw	r30, r22
    2ada:	ce 01       	movw	r24, r28
    2adc:	82 5d       	subi	r24, 0xD2	; 210
    2ade:	9d 4f       	sbci	r25, 0xFD	; 253
    2ae0:	11 92       	st	Z+, r1
    2ae2:	e8 17       	cp	r30, r24
    2ae4:	f9 07       	cpc	r31, r25
    2ae6:	e1 f7       	brne	.-8      	; 0x2ae0 <sync_fs+0x30>
    2ae8:	85 e5       	ldi	r24, 0x55	; 85
    2aea:	9a ea       	ldi	r25, 0xAA	; 170
    2aec:	fe 01       	movw	r30, r28
    2aee:	e4 5d       	subi	r30, 0xD4	; 212
    2af0:	fd 4f       	sbci	r31, 0xFD	; 253
    2af2:	91 83       	std	Z+1, r25	; 0x01
    2af4:	80 83       	st	Z, r24
    2af6:	82 e5       	ldi	r24, 0x52	; 82
    2af8:	92 e5       	ldi	r25, 0x52	; 82
    2afa:	a1 e6       	ldi	r26, 0x61	; 97
    2afc:	b1 e4       	ldi	r27, 0x41	; 65
    2afe:	8e a7       	std	Y+46, r24	; 0x2e
    2b00:	9f a7       	std	Y+47, r25	; 0x2f
    2b02:	a8 ab       	std	Y+48, r26	; 0x30
    2b04:	b9 ab       	std	Y+49, r27	; 0x31
    2b06:	82 e7       	ldi	r24, 0x72	; 114
    2b08:	92 e7       	ldi	r25, 0x72	; 114
    2b0a:	a1 e4       	ldi	r26, 0x41	; 65
    2b0c:	b1 e6       	ldi	r27, 0x61	; 97
    2b0e:	7a 97       	sbiw	r30, 0x1a	; 26
    2b10:	80 83       	st	Z, r24
    2b12:	91 83       	std	Z+1, r25	; 0x01
    2b14:	a2 83       	std	Z+2, r26	; 0x02
    2b16:	b3 83       	std	Z+3, r27	; 0x03
    2b18:	8e 85       	ldd	r24, Y+14	; 0x0e
    2b1a:	9f 85       	ldd	r25, Y+15	; 0x0f
    2b1c:	a8 89       	ldd	r26, Y+16	; 0x10
    2b1e:	b9 89       	ldd	r27, Y+17	; 0x11
    2b20:	34 96       	adiw	r30, 0x04	; 4
    2b22:	80 83       	st	Z, r24
    2b24:	91 83       	std	Z+1, r25	; 0x01
    2b26:	a2 83       	std	Z+2, r26	; 0x02
    2b28:	b3 83       	std	Z+3, r27	; 0x03
    2b2a:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b2c:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b2e:	ac 85       	ldd	r26, Y+12	; 0x0c
    2b30:	bd 85       	ldd	r27, Y+13	; 0x0d
    2b32:	34 96       	adiw	r30, 0x04	; 4
    2b34:	80 83       	st	Z, r24
    2b36:	91 83       	std	Z+1, r25	; 0x01
    2b38:	a2 83       	std	Z+2, r26	; 0x02
    2b3a:	b3 83       	std	Z+3, r27	; 0x03
    2b3c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b3e:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2b40:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2b42:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2b44:	9c 01       	movw	r18, r24
    2b46:	ad 01       	movw	r20, r26
    2b48:	2f 5f       	subi	r18, 0xFF	; 255
    2b4a:	3f 4f       	sbci	r19, 0xFF	; 255
    2b4c:	4f 4f       	sbci	r20, 0xFF	; 255
    2b4e:	5f 4f       	sbci	r21, 0xFF	; 255
    2b50:	2a a7       	std	Y+42, r18	; 0x2a
    2b52:	3b a7       	std	Y+43, r19	; 0x2b
    2b54:	4c a7       	std	Y+44, r20	; 0x2c
    2b56:	5d a7       	std	Y+45, r21	; 0x2d
    2b58:	01 e0       	ldi	r16, 0x01	; 1
    2b5a:	10 e0       	ldi	r17, 0x00	; 0
    2b5c:	89 81       	ldd	r24, Y+1	; 0x01
    2b5e:	e0 d9       	rcall	.-3136   	; 0x1f20 <disk_write>
    2b60:	1d 82       	std	Y+5, r1	; 0x05
    2b62:	40 e0       	ldi	r20, 0x00	; 0
    2b64:	50 e0       	ldi	r21, 0x00	; 0
    2b66:	60 e0       	ldi	r22, 0x00	; 0
    2b68:	89 81       	ldd	r24, Y+1	; 0x01
    2b6a:	3c da       	rcall	.-2952   	; 0x1fe4 <disk_ioctl>
    2b6c:	91 e0       	ldi	r25, 0x01	; 1
    2b6e:	81 11       	cpse	r24, r1
    2b70:	01 c0       	rjmp	.+2      	; 0x2b74 <sync_fs+0xc4>
    2b72:	90 e0       	ldi	r25, 0x00	; 0
    2b74:	89 2f       	mov	r24, r25
    2b76:	df 91       	pop	r29
    2b78:	cf 91       	pop	r28
    2b7a:	1f 91       	pop	r17
    2b7c:	0f 91       	pop	r16
    2b7e:	08 95       	ret

00002b80 <clust2sect>:
    2b80:	cf 92       	push	r12
    2b82:	df 92       	push	r13
    2b84:	ef 92       	push	r14
    2b86:	ff 92       	push	r15
    2b88:	fc 01       	movw	r30, r24
    2b8a:	9a 01       	movw	r18, r20
    2b8c:	ab 01       	movw	r20, r22
    2b8e:	22 50       	subi	r18, 0x02	; 2
    2b90:	31 09       	sbc	r19, r1
    2b92:	41 09       	sbc	r20, r1
    2b94:	51 09       	sbc	r21, r1
    2b96:	c2 88       	ldd	r12, Z+18	; 0x12
    2b98:	d3 88       	ldd	r13, Z+19	; 0x13
    2b9a:	e4 88       	ldd	r14, Z+20	; 0x14
    2b9c:	f5 88       	ldd	r15, Z+21	; 0x15
    2b9e:	82 e0       	ldi	r24, 0x02	; 2
    2ba0:	c8 1a       	sub	r12, r24
    2ba2:	d1 08       	sbc	r13, r1
    2ba4:	e1 08       	sbc	r14, r1
    2ba6:	f1 08       	sbc	r15, r1
    2ba8:	2c 15       	cp	r18, r12
    2baa:	3d 05       	cpc	r19, r13
    2bac:	4e 05       	cpc	r20, r14
    2bae:	5f 05       	cpc	r21, r15
    2bb0:	68 f4       	brcc	.+26     	; 0x2bcc <clust2sect+0x4c>
    2bb2:	a2 81       	ldd	r26, Z+2	; 0x02
    2bb4:	b0 e0       	ldi	r27, 0x00	; 0
    2bb6:	0e 94 2f 39 	call	0x725e	; 0x725e <__muluhisi3>
    2bba:	c6 a0       	ldd	r12, Z+38	; 0x26
    2bbc:	d7 a0       	ldd	r13, Z+39	; 0x27
    2bbe:	e0 a4       	ldd	r14, Z+40	; 0x28
    2bc0:	f1 a4       	ldd	r15, Z+41	; 0x29
    2bc2:	6c 0d       	add	r22, r12
    2bc4:	7d 1d       	adc	r23, r13
    2bc6:	8e 1d       	adc	r24, r14
    2bc8:	9f 1d       	adc	r25, r15
    2bca:	03 c0       	rjmp	.+6      	; 0x2bd2 <clust2sect+0x52>
    2bcc:	60 e0       	ldi	r22, 0x00	; 0
    2bce:	70 e0       	ldi	r23, 0x00	; 0
    2bd0:	cb 01       	movw	r24, r22
    2bd2:	ff 90       	pop	r15
    2bd4:	ef 90       	pop	r14
    2bd6:	df 90       	pop	r13
    2bd8:	cf 90       	pop	r12
    2bda:	08 95       	ret

00002bdc <get_fat>:
    2bdc:	af 92       	push	r10
    2bde:	bf 92       	push	r11
    2be0:	cf 92       	push	r12
    2be2:	df 92       	push	r13
    2be4:	ef 92       	push	r14
    2be6:	ff 92       	push	r15
    2be8:	0f 93       	push	r16
    2bea:	1f 93       	push	r17
    2bec:	cf 93       	push	r28
    2bee:	df 93       	push	r29
    2bf0:	ec 01       	movw	r28, r24
    2bf2:	6a 01       	movw	r12, r20
    2bf4:	7b 01       	movw	r14, r22
    2bf6:	42 30       	cpi	r20, 0x02	; 2
    2bf8:	51 05       	cpc	r21, r1
    2bfa:	61 05       	cpc	r22, r1
    2bfc:	71 05       	cpc	r23, r1
    2bfe:	08 f4       	brcc	.+2      	; 0x2c02 <get_fat+0x26>
    2c00:	a7 c0       	rjmp	.+334    	; 0x2d50 <get_fat+0x174>
    2c02:	8a 89       	ldd	r24, Y+18	; 0x12
    2c04:	9b 89       	ldd	r25, Y+19	; 0x13
    2c06:	ac 89       	ldd	r26, Y+20	; 0x14
    2c08:	bd 89       	ldd	r27, Y+21	; 0x15
    2c0a:	48 17       	cp	r20, r24
    2c0c:	59 07       	cpc	r21, r25
    2c0e:	6a 07       	cpc	r22, r26
    2c10:	7b 07       	cpc	r23, r27
    2c12:	08 f0       	brcs	.+2      	; 0x2c16 <get_fat+0x3a>
    2c14:	a2 c0       	rjmp	.+324    	; 0x2d5a <get_fat+0x17e>
    2c16:	88 81       	ld	r24, Y
    2c18:	82 30       	cpi	r24, 0x02	; 2
    2c1a:	09 f4       	brne	.+2      	; 0x2c1e <get_fat+0x42>
    2c1c:	4b c0       	rjmp	.+150    	; 0x2cb4 <get_fat+0xd8>
    2c1e:	83 30       	cpi	r24, 0x03	; 3
    2c20:	09 f4       	brne	.+2      	; 0x2c24 <get_fat+0x48>
    2c22:	69 c0       	rjmp	.+210    	; 0x2cf6 <get_fat+0x11a>
    2c24:	81 30       	cpi	r24, 0x01	; 1
    2c26:	09 f0       	breq	.+2      	; 0x2c2a <get_fat+0x4e>
    2c28:	9d c0       	rjmp	.+314    	; 0x2d64 <get_fat+0x188>
    2c2a:	8a 01       	movw	r16, r20
    2c2c:	16 95       	lsr	r17
    2c2e:	07 95       	ror	r16
    2c30:	04 0f       	add	r16, r20
    2c32:	15 1f       	adc	r17, r21
    2c34:	c8 01       	movw	r24, r16
    2c36:	89 2f       	mov	r24, r25
    2c38:	99 27       	eor	r25, r25
    2c3a:	86 95       	lsr	r24
    2c3c:	4e 8d       	ldd	r20, Y+30	; 0x1e
    2c3e:	5f 8d       	ldd	r21, Y+31	; 0x1f
    2c40:	68 a1       	ldd	r22, Y+32	; 0x20
    2c42:	79 a1       	ldd	r23, Y+33	; 0x21
    2c44:	48 0f       	add	r20, r24
    2c46:	59 1f       	adc	r21, r25
    2c48:	61 1d       	adc	r22, r1
    2c4a:	71 1d       	adc	r23, r1
    2c4c:	ce 01       	movw	r24, r28
    2c4e:	b0 db       	rcall	.-2208   	; 0x23b0 <move_window>
    2c50:	81 11       	cpse	r24, r1
    2c52:	8d c0       	rjmp	.+282    	; 0x2d6e <get_fat+0x192>
    2c54:	58 01       	movw	r10, r16
    2c56:	8f ef       	ldi	r24, 0xFF	; 255
    2c58:	a8 1a       	sub	r10, r24
    2c5a:	b8 0a       	sbc	r11, r24
    2c5c:	11 70       	andi	r17, 0x01	; 1
    2c5e:	fe 01       	movw	r30, r28
    2c60:	e0 0f       	add	r30, r16
    2c62:	f1 1f       	adc	r31, r17
    2c64:	16 a5       	ldd	r17, Z+46	; 0x2e
    2c66:	c5 01       	movw	r24, r10
    2c68:	89 2f       	mov	r24, r25
    2c6a:	99 27       	eor	r25, r25
    2c6c:	86 95       	lsr	r24
    2c6e:	4e 8d       	ldd	r20, Y+30	; 0x1e
    2c70:	5f 8d       	ldd	r21, Y+31	; 0x1f
    2c72:	68 a1       	ldd	r22, Y+32	; 0x20
    2c74:	79 a1       	ldd	r23, Y+33	; 0x21
    2c76:	48 0f       	add	r20, r24
    2c78:	59 1f       	adc	r21, r25
    2c7a:	61 1d       	adc	r22, r1
    2c7c:	71 1d       	adc	r23, r1
    2c7e:	ce 01       	movw	r24, r28
    2c80:	97 db       	rcall	.-2258   	; 0x23b0 <move_window>
    2c82:	81 11       	cpse	r24, r1
    2c84:	78 c0       	rjmp	.+240    	; 0x2d76 <get_fat+0x19a>
    2c86:	81 e0       	ldi	r24, 0x01	; 1
    2c88:	b8 22       	and	r11, r24
    2c8a:	ca 0d       	add	r28, r10
    2c8c:	db 1d       	adc	r29, r11
    2c8e:	8e a5       	ldd	r24, Y+46	; 0x2e
    2c90:	61 2f       	mov	r22, r17
    2c92:	70 e0       	ldi	r23, 0x00	; 0
    2c94:	78 2b       	or	r23, r24
    2c96:	c0 fe       	sbrs	r12, 0
    2c98:	09 c0       	rjmp	.+18     	; 0x2cac <get_fat+0xd0>
    2c9a:	72 95       	swap	r23
    2c9c:	62 95       	swap	r22
    2c9e:	6f 70       	andi	r22, 0x0F	; 15
    2ca0:	67 27       	eor	r22, r23
    2ca2:	7f 70       	andi	r23, 0x0F	; 15
    2ca4:	67 27       	eor	r22, r23
    2ca6:	80 e0       	ldi	r24, 0x00	; 0
    2ca8:	90 e0       	ldi	r25, 0x00	; 0
    2caa:	70 c0       	rjmp	.+224    	; 0x2d8c <get_fat+0x1b0>
    2cac:	7f 70       	andi	r23, 0x0F	; 15
    2cae:	80 e0       	ldi	r24, 0x00	; 0
    2cb0:	90 e0       	ldi	r25, 0x00	; 0
    2cb2:	6c c0       	rjmp	.+216    	; 0x2d8c <get_fat+0x1b0>
    2cb4:	45 2f       	mov	r20, r21
    2cb6:	56 2f       	mov	r21, r22
    2cb8:	67 2f       	mov	r22, r23
    2cba:	77 27       	eor	r23, r23
    2cbc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2cbe:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2cc0:	a8 a1       	ldd	r26, Y+32	; 0x20
    2cc2:	b9 a1       	ldd	r27, Y+33	; 0x21
    2cc4:	48 0f       	add	r20, r24
    2cc6:	59 1f       	adc	r21, r25
    2cc8:	6a 1f       	adc	r22, r26
    2cca:	7b 1f       	adc	r23, r27
    2ccc:	ce 01       	movw	r24, r28
    2cce:	70 db       	rcall	.-2336   	; 0x23b0 <move_window>
    2cd0:	81 11       	cpse	r24, r1
    2cd2:	55 c0       	rjmp	.+170    	; 0x2d7e <get_fat+0x1a2>
    2cd4:	cc 0c       	add	r12, r12
    2cd6:	dd 1c       	adc	r13, r13
    2cd8:	ee 1c       	adc	r14, r14
    2cda:	ff 1c       	adc	r15, r15
    2cdc:	e8 94       	clt
    2cde:	c0 f8       	bld	r12, 0
    2ce0:	81 e0       	ldi	r24, 0x01	; 1
    2ce2:	d8 22       	and	r13, r24
    2ce4:	ee 24       	eor	r14, r14
    2ce6:	ff 24       	eor	r15, r15
    2ce8:	cc 0d       	add	r28, r12
    2cea:	dd 1d       	adc	r29, r13
    2cec:	6e a5       	ldd	r22, Y+46	; 0x2e
    2cee:	7f a5       	ldd	r23, Y+47	; 0x2f
    2cf0:	80 e0       	ldi	r24, 0x00	; 0
    2cf2:	90 e0       	ldi	r25, 0x00	; 0
    2cf4:	4b c0       	rjmp	.+150    	; 0x2d8c <get_fat+0x1b0>
    2cf6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2cf8:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2cfa:	a8 a1       	ldd	r26, Y+32	; 0x20
    2cfc:	b9 a1       	ldd	r27, Y+33	; 0x21
    2cfe:	68 94       	set
    2d00:	16 f8       	bld	r1, 6
    2d02:	76 95       	lsr	r23
    2d04:	67 95       	ror	r22
    2d06:	57 95       	ror	r21
    2d08:	47 95       	ror	r20
    2d0a:	16 94       	lsr	r1
    2d0c:	d1 f7       	brne	.-12     	; 0x2d02 <get_fat+0x126>
    2d0e:	48 0f       	add	r20, r24
    2d10:	59 1f       	adc	r21, r25
    2d12:	6a 1f       	adc	r22, r26
    2d14:	7b 1f       	adc	r23, r27
    2d16:	ce 01       	movw	r24, r28
    2d18:	4b db       	rcall	.-2410   	; 0x23b0 <move_window>
    2d1a:	81 11       	cpse	r24, r1
    2d1c:	34 c0       	rjmp	.+104    	; 0x2d86 <get_fat+0x1aa>
    2d1e:	cc 0c       	add	r12, r12
    2d20:	dd 1c       	adc	r13, r13
    2d22:	ee 1c       	adc	r14, r14
    2d24:	ff 1c       	adc	r15, r15
    2d26:	cc 0c       	add	r12, r12
    2d28:	dd 1c       	adc	r13, r13
    2d2a:	ee 1c       	adc	r14, r14
    2d2c:	ff 1c       	adc	r15, r15
    2d2e:	8c ef       	ldi	r24, 0xFC	; 252
    2d30:	c8 22       	and	r12, r24
    2d32:	81 e0       	ldi	r24, 0x01	; 1
    2d34:	d8 22       	and	r13, r24
    2d36:	ee 24       	eor	r14, r14
    2d38:	ff 24       	eor	r15, r15
    2d3a:	fe 01       	movw	r30, r28
    2d3c:	ec 0d       	add	r30, r12
    2d3e:	fd 1d       	adc	r31, r13
    2d40:	86 a5       	ldd	r24, Z+46	; 0x2e
    2d42:	97 a5       	ldd	r25, Z+47	; 0x2f
    2d44:	a0 a9       	ldd	r26, Z+48	; 0x30
    2d46:	b1 a9       	ldd	r27, Z+49	; 0x31
    2d48:	bc 01       	movw	r22, r24
    2d4a:	cd 01       	movw	r24, r26
    2d4c:	9f 70       	andi	r25, 0x0F	; 15
    2d4e:	1e c0       	rjmp	.+60     	; 0x2d8c <get_fat+0x1b0>
    2d50:	61 e0       	ldi	r22, 0x01	; 1
    2d52:	70 e0       	ldi	r23, 0x00	; 0
    2d54:	80 e0       	ldi	r24, 0x00	; 0
    2d56:	90 e0       	ldi	r25, 0x00	; 0
    2d58:	19 c0       	rjmp	.+50     	; 0x2d8c <get_fat+0x1b0>
    2d5a:	61 e0       	ldi	r22, 0x01	; 1
    2d5c:	70 e0       	ldi	r23, 0x00	; 0
    2d5e:	80 e0       	ldi	r24, 0x00	; 0
    2d60:	90 e0       	ldi	r25, 0x00	; 0
    2d62:	14 c0       	rjmp	.+40     	; 0x2d8c <get_fat+0x1b0>
    2d64:	61 e0       	ldi	r22, 0x01	; 1
    2d66:	70 e0       	ldi	r23, 0x00	; 0
    2d68:	80 e0       	ldi	r24, 0x00	; 0
    2d6a:	90 e0       	ldi	r25, 0x00	; 0
    2d6c:	0f c0       	rjmp	.+30     	; 0x2d8c <get_fat+0x1b0>
    2d6e:	6f ef       	ldi	r22, 0xFF	; 255
    2d70:	7f ef       	ldi	r23, 0xFF	; 255
    2d72:	cb 01       	movw	r24, r22
    2d74:	0b c0       	rjmp	.+22     	; 0x2d8c <get_fat+0x1b0>
    2d76:	6f ef       	ldi	r22, 0xFF	; 255
    2d78:	7f ef       	ldi	r23, 0xFF	; 255
    2d7a:	cb 01       	movw	r24, r22
    2d7c:	07 c0       	rjmp	.+14     	; 0x2d8c <get_fat+0x1b0>
    2d7e:	6f ef       	ldi	r22, 0xFF	; 255
    2d80:	7f ef       	ldi	r23, 0xFF	; 255
    2d82:	cb 01       	movw	r24, r22
    2d84:	03 c0       	rjmp	.+6      	; 0x2d8c <get_fat+0x1b0>
    2d86:	6f ef       	ldi	r22, 0xFF	; 255
    2d88:	7f ef       	ldi	r23, 0xFF	; 255
    2d8a:	cb 01       	movw	r24, r22
    2d8c:	df 91       	pop	r29
    2d8e:	cf 91       	pop	r28
    2d90:	1f 91       	pop	r17
    2d92:	0f 91       	pop	r16
    2d94:	ff 90       	pop	r15
    2d96:	ef 90       	pop	r14
    2d98:	df 90       	pop	r13
    2d9a:	cf 90       	pop	r12
    2d9c:	bf 90       	pop	r11
    2d9e:	af 90       	pop	r10
    2da0:	08 95       	ret

00002da2 <dir_sdi>:
    2da2:	af 92       	push	r10
    2da4:	bf 92       	push	r11
    2da6:	cf 92       	push	r12
    2da8:	df 92       	push	r13
    2daa:	ef 92       	push	r14
    2dac:	ff 92       	push	r15
    2dae:	0f 93       	push	r16
    2db0:	1f 93       	push	r17
    2db2:	cf 93       	push	r28
    2db4:	df 93       	push	r29
    2db6:	ec 01       	movw	r28, r24
    2db8:	8b 01       	movw	r16, r22
    2dba:	7d 83       	std	Y+5, r23	; 0x05
    2dbc:	6c 83       	std	Y+4, r22	; 0x04
    2dbe:	ce 80       	ldd	r12, Y+6	; 0x06
    2dc0:	df 80       	ldd	r13, Y+7	; 0x07
    2dc2:	e8 84       	ldd	r14, Y+8	; 0x08
    2dc4:	f9 84       	ldd	r15, Y+9	; 0x09
    2dc6:	81 e0       	ldi	r24, 0x01	; 1
    2dc8:	c8 16       	cp	r12, r24
    2dca:	d1 04       	cpc	r13, r1
    2dcc:	e1 04       	cpc	r14, r1
    2dce:	f1 04       	cpc	r15, r1
    2dd0:	09 f4       	brne	.+2      	; 0x2dd4 <dir_sdi+0x32>
    2dd2:	8a c0       	rjmp	.+276    	; 0x2ee8 <dir_sdi+0x146>
    2dd4:	e8 81       	ld	r30, Y
    2dd6:	f9 81       	ldd	r31, Y+1	; 0x01
    2dd8:	82 89       	ldd	r24, Z+18	; 0x12
    2dda:	93 89       	ldd	r25, Z+19	; 0x13
    2ddc:	a4 89       	ldd	r26, Z+20	; 0x14
    2dde:	b5 89       	ldd	r27, Z+21	; 0x15
    2de0:	c8 16       	cp	r12, r24
    2de2:	d9 06       	cpc	r13, r25
    2de4:	ea 06       	cpc	r14, r26
    2de6:	fb 06       	cpc	r15, r27
    2de8:	08 f0       	brcs	.+2      	; 0x2dec <dir_sdi+0x4a>
    2dea:	80 c0       	rjmp	.+256    	; 0x2eec <dir_sdi+0x14a>
    2dec:	c1 14       	cp	r12, r1
    2dee:	d1 04       	cpc	r13, r1
    2df0:	e1 04       	cpc	r14, r1
    2df2:	f1 04       	cpc	r15, r1
    2df4:	c1 f4       	brne	.+48     	; 0x2e26 <dir_sdi+0x84>
    2df6:	80 81       	ld	r24, Z
    2df8:	83 30       	cpi	r24, 0x03	; 3
    2dfa:	41 f4       	brne	.+16     	; 0x2e0c <dir_sdi+0x6a>
    2dfc:	82 a1       	ldd	r24, Z+34	; 0x22
    2dfe:	93 a1       	ldd	r25, Z+35	; 0x23
    2e00:	a4 a1       	ldd	r26, Z+36	; 0x24
    2e02:	b5 a1       	ldd	r27, Z+37	; 0x25
    2e04:	00 97       	sbiw	r24, 0x00	; 0
    2e06:	a1 05       	cpc	r26, r1
    2e08:	b1 05       	cpc	r27, r1
    2e0a:	59 f4       	brne	.+22     	; 0x2e22 <dir_sdi+0x80>
    2e0c:	80 85       	ldd	r24, Z+8	; 0x08
    2e0e:	91 85       	ldd	r25, Z+9	; 0x09
    2e10:	08 17       	cp	r16, r24
    2e12:	19 07       	cpc	r17, r25
    2e14:	08 f0       	brcs	.+2      	; 0x2e18 <dir_sdi+0x76>
    2e16:	6c c0       	rjmp	.+216    	; 0x2ef0 <dir_sdi+0x14e>
    2e18:	62 a1       	ldd	r22, Z+34	; 0x22
    2e1a:	73 a1       	ldd	r23, Z+35	; 0x23
    2e1c:	84 a1       	ldd	r24, Z+36	; 0x24
    2e1e:	95 a1       	ldd	r25, Z+37	; 0x25
    2e20:	35 c0       	rjmp	.+106    	; 0x2e8c <dir_sdi+0xea>
    2e22:	6c 01       	movw	r12, r24
    2e24:	7d 01       	movw	r14, r26
    2e26:	a2 80       	ldd	r10, Z+2	; 0x02
    2e28:	80 e1       	ldi	r24, 0x10	; 16
    2e2a:	a8 9e       	mul	r10, r24
    2e2c:	50 01       	movw	r10, r0
    2e2e:	11 24       	eor	r1, r1
    2e30:	0a 15       	cp	r16, r10
    2e32:	1b 05       	cpc	r17, r11
    2e34:	30 f1       	brcs	.+76     	; 0x2e82 <dir_sdi+0xe0>
    2e36:	b7 01       	movw	r22, r14
    2e38:	a6 01       	movw	r20, r12
    2e3a:	88 81       	ld	r24, Y
    2e3c:	99 81       	ldd	r25, Y+1	; 0x01
    2e3e:	ce de       	rcall	.-612    	; 0x2bdc <get_fat>
    2e40:	6b 01       	movw	r12, r22
    2e42:	7c 01       	movw	r14, r24
    2e44:	8f ef       	ldi	r24, 0xFF	; 255
    2e46:	c8 16       	cp	r12, r24
    2e48:	d8 06       	cpc	r13, r24
    2e4a:	e8 06       	cpc	r14, r24
    2e4c:	f8 06       	cpc	r15, r24
    2e4e:	09 f4       	brne	.+2      	; 0x2e52 <dir_sdi+0xb0>
    2e50:	51 c0       	rjmp	.+162    	; 0x2ef4 <dir_sdi+0x152>
    2e52:	82 e0       	ldi	r24, 0x02	; 2
    2e54:	c8 16       	cp	r12, r24
    2e56:	d1 04       	cpc	r13, r1
    2e58:	e1 04       	cpc	r14, r1
    2e5a:	f1 04       	cpc	r15, r1
    2e5c:	08 f4       	brcc	.+2      	; 0x2e60 <dir_sdi+0xbe>
    2e5e:	4c c0       	rjmp	.+152    	; 0x2ef8 <dir_sdi+0x156>
    2e60:	e8 81       	ld	r30, Y
    2e62:	f9 81       	ldd	r31, Y+1	; 0x01
    2e64:	82 89       	ldd	r24, Z+18	; 0x12
    2e66:	93 89       	ldd	r25, Z+19	; 0x13
    2e68:	a4 89       	ldd	r26, Z+20	; 0x14
    2e6a:	b5 89       	ldd	r27, Z+21	; 0x15
    2e6c:	c8 16       	cp	r12, r24
    2e6e:	d9 06       	cpc	r13, r25
    2e70:	ea 06       	cpc	r14, r26
    2e72:	fb 06       	cpc	r15, r27
    2e74:	08 f0       	brcs	.+2      	; 0x2e78 <dir_sdi+0xd6>
    2e76:	42 c0       	rjmp	.+132    	; 0x2efc <dir_sdi+0x15a>
    2e78:	0a 19       	sub	r16, r10
    2e7a:	1b 09       	sbc	r17, r11
    2e7c:	0a 15       	cp	r16, r10
    2e7e:	1b 05       	cpc	r17, r11
    2e80:	d0 f6       	brcc	.-76     	; 0x2e36 <dir_sdi+0x94>
    2e82:	b7 01       	movw	r22, r14
    2e84:	a6 01       	movw	r20, r12
    2e86:	88 81       	ld	r24, Y
    2e88:	99 81       	ldd	r25, Y+1	; 0x01
    2e8a:	7a de       	rcall	.-780    	; 0x2b80 <clust2sect>
    2e8c:	ca 86       	std	Y+10, r12	; 0x0a
    2e8e:	db 86       	std	Y+11, r13	; 0x0b
    2e90:	ec 86       	std	Y+12, r14	; 0x0c
    2e92:	fd 86       	std	Y+13, r15	; 0x0d
    2e94:	61 15       	cp	r22, r1
    2e96:	71 05       	cpc	r23, r1
    2e98:	81 05       	cpc	r24, r1
    2e9a:	91 05       	cpc	r25, r1
    2e9c:	89 f1       	breq	.+98     	; 0x2f00 <dir_sdi+0x15e>
    2e9e:	98 01       	movw	r18, r16
    2ea0:	32 95       	swap	r19
    2ea2:	22 95       	swap	r18
    2ea4:	2f 70       	andi	r18, 0x0F	; 15
    2ea6:	23 27       	eor	r18, r19
    2ea8:	3f 70       	andi	r19, 0x0F	; 15
    2eaa:	23 27       	eor	r18, r19
    2eac:	dc 01       	movw	r26, r24
    2eae:	cb 01       	movw	r24, r22
    2eb0:	82 0f       	add	r24, r18
    2eb2:	93 1f       	adc	r25, r19
    2eb4:	a1 1d       	adc	r26, r1
    2eb6:	b1 1d       	adc	r27, r1
    2eb8:	8e 87       	std	Y+14, r24	; 0x0e
    2eba:	9f 87       	std	Y+15, r25	; 0x0f
    2ebc:	a8 8b       	std	Y+16, r26	; 0x10
    2ebe:	b9 8b       	std	Y+17, r27	; 0x11
    2ec0:	0f 70       	andi	r16, 0x0F	; 15
    2ec2:	11 27       	eor	r17, r17
    2ec4:	00 0f       	add	r16, r16
    2ec6:	11 1f       	adc	r17, r17
    2ec8:	02 95       	swap	r16
    2eca:	12 95       	swap	r17
    2ecc:	10 7f       	andi	r17, 0xF0	; 240
    2ece:	10 27       	eor	r17, r16
    2ed0:	00 7f       	andi	r16, 0xF0	; 240
    2ed2:	10 27       	eor	r17, r16
    2ed4:	02 5d       	subi	r16, 0xD2	; 210
    2ed6:	1f 4f       	sbci	r17, 0xFF	; 255
    2ed8:	88 81       	ld	r24, Y
    2eda:	99 81       	ldd	r25, Y+1	; 0x01
    2edc:	80 0f       	add	r24, r16
    2ede:	91 1f       	adc	r25, r17
    2ee0:	9b 8b       	std	Y+19, r25	; 0x13
    2ee2:	8a 8b       	std	Y+18, r24	; 0x12
    2ee4:	80 e0       	ldi	r24, 0x00	; 0
    2ee6:	0d c0       	rjmp	.+26     	; 0x2f02 <dir_sdi+0x160>
    2ee8:	82 e0       	ldi	r24, 0x02	; 2
    2eea:	0b c0       	rjmp	.+22     	; 0x2f02 <dir_sdi+0x160>
    2eec:	82 e0       	ldi	r24, 0x02	; 2
    2eee:	09 c0       	rjmp	.+18     	; 0x2f02 <dir_sdi+0x160>
    2ef0:	82 e0       	ldi	r24, 0x02	; 2
    2ef2:	07 c0       	rjmp	.+14     	; 0x2f02 <dir_sdi+0x160>
    2ef4:	81 e0       	ldi	r24, 0x01	; 1
    2ef6:	05 c0       	rjmp	.+10     	; 0x2f02 <dir_sdi+0x160>
    2ef8:	82 e0       	ldi	r24, 0x02	; 2
    2efa:	03 c0       	rjmp	.+6      	; 0x2f02 <dir_sdi+0x160>
    2efc:	82 e0       	ldi	r24, 0x02	; 2
    2efe:	01 c0       	rjmp	.+2      	; 0x2f02 <dir_sdi+0x160>
    2f00:	82 e0       	ldi	r24, 0x02	; 2
    2f02:	df 91       	pop	r29
    2f04:	cf 91       	pop	r28
    2f06:	1f 91       	pop	r17
    2f08:	0f 91       	pop	r16
    2f0a:	ff 90       	pop	r15
    2f0c:	ef 90       	pop	r14
    2f0e:	df 90       	pop	r13
    2f10:	cf 90       	pop	r12
    2f12:	bf 90       	pop	r11
    2f14:	af 90       	pop	r10
    2f16:	08 95       	ret

00002f18 <put_fat>:
    2f18:	4f 92       	push	r4
    2f1a:	5f 92       	push	r5
    2f1c:	6f 92       	push	r6
    2f1e:	7f 92       	push	r7
    2f20:	8f 92       	push	r8
    2f22:	9f 92       	push	r9
    2f24:	af 92       	push	r10
    2f26:	bf 92       	push	r11
    2f28:	cf 92       	push	r12
    2f2a:	df 92       	push	r13
    2f2c:	ef 92       	push	r14
    2f2e:	ff 92       	push	r15
    2f30:	0f 93       	push	r16
    2f32:	1f 93       	push	r17
    2f34:	cf 93       	push	r28
    2f36:	df 93       	push	r29
    2f38:	ec 01       	movw	r28, r24
    2f3a:	6a 01       	movw	r12, r20
    2f3c:	7b 01       	movw	r14, r22
    2f3e:	28 01       	movw	r4, r16
    2f40:	39 01       	movw	r6, r18
    2f42:	42 30       	cpi	r20, 0x02	; 2
    2f44:	51 05       	cpc	r21, r1
    2f46:	61 05       	cpc	r22, r1
    2f48:	71 05       	cpc	r23, r1
    2f4a:	08 f4       	brcc	.+2      	; 0x2f4e <put_fat+0x36>
    2f4c:	d2 c0       	rjmp	.+420    	; 0x30f2 <put_fat+0x1da>
    2f4e:	8a 89       	ldd	r24, Y+18	; 0x12
    2f50:	9b 89       	ldd	r25, Y+19	; 0x13
    2f52:	ac 89       	ldd	r26, Y+20	; 0x14
    2f54:	bd 89       	ldd	r27, Y+21	; 0x15
    2f56:	48 17       	cp	r20, r24
    2f58:	59 07       	cpc	r21, r25
    2f5a:	6a 07       	cpc	r22, r26
    2f5c:	7b 07       	cpc	r23, r27
    2f5e:	08 f0       	brcs	.+2      	; 0x2f62 <put_fat+0x4a>
    2f60:	ca c0       	rjmp	.+404    	; 0x30f6 <put_fat+0x1de>
    2f62:	88 81       	ld	r24, Y
    2f64:	82 30       	cpi	r24, 0x02	; 2
    2f66:	09 f4       	brne	.+2      	; 0x2f6a <put_fat+0x52>
    2f68:	62 c0       	rjmp	.+196    	; 0x302e <put_fat+0x116>
    2f6a:	83 30       	cpi	r24, 0x03	; 3
    2f6c:	09 f4       	brne	.+2      	; 0x2f70 <put_fat+0x58>
    2f6e:	85 c0       	rjmp	.+266    	; 0x307a <put_fat+0x162>
    2f70:	81 30       	cpi	r24, 0x01	; 1
    2f72:	09 f0       	breq	.+2      	; 0x2f76 <put_fat+0x5e>
    2f74:	c2 c0       	rjmp	.+388    	; 0x30fa <put_fat+0x1e2>
    2f76:	5a 01       	movw	r10, r20
    2f78:	b6 94       	lsr	r11
    2f7a:	a7 94       	ror	r10
    2f7c:	a4 0e       	add	r10, r20
    2f7e:	b5 1e       	adc	r11, r21
    2f80:	c5 01       	movw	r24, r10
    2f82:	89 2f       	mov	r24, r25
    2f84:	99 27       	eor	r25, r25
    2f86:	86 95       	lsr	r24
    2f88:	4e 8d       	ldd	r20, Y+30	; 0x1e
    2f8a:	5f 8d       	ldd	r21, Y+31	; 0x1f
    2f8c:	68 a1       	ldd	r22, Y+32	; 0x20
    2f8e:	79 a1       	ldd	r23, Y+33	; 0x21
    2f90:	48 0f       	add	r20, r24
    2f92:	59 1f       	adc	r21, r25
    2f94:	61 1d       	adc	r22, r1
    2f96:	71 1d       	adc	r23, r1
    2f98:	ce 01       	movw	r24, r28
    2f9a:	0a da       	rcall	.-3052   	; 0x23b0 <move_window>
    2f9c:	18 2f       	mov	r17, r24
    2f9e:	81 11       	cpse	r24, r1
    2fa0:	ca c0       	rjmp	.+404    	; 0x3136 <put_fat+0x21e>
    2fa2:	45 01       	movw	r8, r10
    2fa4:	8f ef       	ldi	r24, 0xFF	; 255
    2fa6:	88 1a       	sub	r8, r24
    2fa8:	98 0a       	sbc	r9, r24
    2faa:	31 e0       	ldi	r19, 0x01	; 1
    2fac:	b3 22       	and	r11, r19
    2fae:	c0 fe       	sbrs	r12, 0
    2fb0:	20 c0       	rjmp	.+64     	; 0x2ff2 <put_fat+0xda>
    2fb2:	fe 01       	movw	r30, r28
    2fb4:	ea 0d       	add	r30, r10
    2fb6:	fb 1d       	adc	r31, r11
    2fb8:	86 a5       	ldd	r24, Z+46	; 0x2e
    2fba:	28 2f       	mov	r18, r24
    2fbc:	2f 70       	andi	r18, 0x0F	; 15
    2fbe:	30 e1       	ldi	r19, 0x10	; 16
    2fc0:	43 9e       	mul	r4, r19
    2fc2:	c0 01       	movw	r24, r0
    2fc4:	11 24       	eor	r1, r1
    2fc6:	82 2b       	or	r24, r18
    2fc8:	86 a7       	std	Z+46, r24	; 0x2e
    2fca:	81 e0       	ldi	r24, 0x01	; 1
    2fcc:	8c 83       	std	Y+4, r24	; 0x04
    2fce:	4e 8d       	ldd	r20, Y+30	; 0x1e
    2fd0:	5f 8d       	ldd	r21, Y+31	; 0x1f
    2fd2:	68 a1       	ldd	r22, Y+32	; 0x20
    2fd4:	79 a1       	ldd	r23, Y+33	; 0x21
    2fd6:	c4 01       	movw	r24, r8
    2fd8:	89 2f       	mov	r24, r25
    2fda:	99 27       	eor	r25, r25
    2fdc:	86 95       	lsr	r24
    2fde:	48 0f       	add	r20, r24
    2fe0:	59 1f       	adc	r21, r25
    2fe2:	61 1d       	adc	r22, r1
    2fe4:	71 1d       	adc	r23, r1
    2fe6:	ce 01       	movw	r24, r28
    2fe8:	e3 d9       	rcall	.-3130   	; 0x23b0 <move_window>
    2fea:	88 23       	and	r24, r24
    2fec:	09 f4       	brne	.+2      	; 0x2ff0 <put_fat+0xd8>
    2fee:	8b c0       	rjmp	.+278    	; 0x3106 <put_fat+0x1ee>
    2ff0:	86 c0       	rjmp	.+268    	; 0x30fe <put_fat+0x1e6>
    2ff2:	fe 01       	movw	r30, r28
    2ff4:	ea 0d       	add	r30, r10
    2ff6:	fb 1d       	adc	r31, r11
    2ff8:	46 a6       	std	Z+46, r4	; 0x2e
    2ffa:	81 e0       	ldi	r24, 0x01	; 1
    2ffc:	8c 83       	std	Y+4, r24	; 0x04
    2ffe:	4e 8d       	ldd	r20, Y+30	; 0x1e
    3000:	5f 8d       	ldd	r21, Y+31	; 0x1f
    3002:	68 a1       	ldd	r22, Y+32	; 0x20
    3004:	79 a1       	ldd	r23, Y+33	; 0x21
    3006:	c4 01       	movw	r24, r8
    3008:	89 2f       	mov	r24, r25
    300a:	99 27       	eor	r25, r25
    300c:	86 95       	lsr	r24
    300e:	48 0f       	add	r20, r24
    3010:	59 1f       	adc	r21, r25
    3012:	61 1d       	adc	r22, r1
    3014:	71 1d       	adc	r23, r1
    3016:	ce 01       	movw	r24, r28
    3018:	cb d9       	rcall	.-3178   	; 0x23b0 <move_window>
    301a:	88 23       	and	r24, r24
    301c:	09 f4       	brne	.+2      	; 0x3020 <put_fat+0x108>
    301e:	7e c0       	rjmp	.+252    	; 0x311c <put_fat+0x204>
    3020:	70 c0       	rjmp	.+224    	; 0x3102 <put_fat+0x1ea>
    3022:	ec 0f       	add	r30, r28
    3024:	fd 1f       	adc	r31, r29
    3026:	46 a6       	std	Z+46, r4	; 0x2e
    3028:	81 e0       	ldi	r24, 0x01	; 1
    302a:	8c 83       	std	Y+4, r24	; 0x04
    302c:	84 c0       	rjmp	.+264    	; 0x3136 <put_fat+0x21e>
    302e:	45 2f       	mov	r20, r21
    3030:	56 2f       	mov	r21, r22
    3032:	67 2f       	mov	r22, r23
    3034:	77 27       	eor	r23, r23
    3036:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3038:	9f 8d       	ldd	r25, Y+31	; 0x1f
    303a:	a8 a1       	ldd	r26, Y+32	; 0x20
    303c:	b9 a1       	ldd	r27, Y+33	; 0x21
    303e:	48 0f       	add	r20, r24
    3040:	59 1f       	adc	r21, r25
    3042:	6a 1f       	adc	r22, r26
    3044:	7b 1f       	adc	r23, r27
    3046:	ce 01       	movw	r24, r28
    3048:	b3 d9       	rcall	.-3226   	; 0x23b0 <move_window>
    304a:	18 2f       	mov	r17, r24
    304c:	81 11       	cpse	r24, r1
    304e:	73 c0       	rjmp	.+230    	; 0x3136 <put_fat+0x21e>
    3050:	cc 0c       	add	r12, r12
    3052:	dd 1c       	adc	r13, r13
    3054:	ee 1c       	adc	r14, r14
    3056:	ff 1c       	adc	r15, r15
    3058:	e8 94       	clt
    305a:	c0 f8       	bld	r12, 0
    305c:	81 e0       	ldi	r24, 0x01	; 1
    305e:	d8 22       	and	r13, r24
    3060:	ee 24       	eor	r14, r14
    3062:	ff 24       	eor	r15, r15
    3064:	3e e2       	ldi	r19, 0x2E	; 46
    3066:	c3 0e       	add	r12, r19
    3068:	d1 1c       	adc	r13, r1
    306a:	fe 01       	movw	r30, r28
    306c:	ec 0d       	add	r30, r12
    306e:	fd 1d       	adc	r31, r13
    3070:	51 82       	std	Z+1, r5	; 0x01
    3072:	40 82       	st	Z, r4
    3074:	81 e0       	ldi	r24, 0x01	; 1
    3076:	8c 83       	std	Y+4, r24	; 0x04
    3078:	5e c0       	rjmp	.+188    	; 0x3136 <put_fat+0x21e>
    307a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    307c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    307e:	a8 a1       	ldd	r26, Y+32	; 0x20
    3080:	b9 a1       	ldd	r27, Y+33	; 0x21
    3082:	68 94       	set
    3084:	16 f8       	bld	r1, 6
    3086:	76 95       	lsr	r23
    3088:	67 95       	ror	r22
    308a:	57 95       	ror	r21
    308c:	47 95       	ror	r20
    308e:	16 94       	lsr	r1
    3090:	d1 f7       	brne	.-12     	; 0x3086 <put_fat+0x16e>
    3092:	48 0f       	add	r20, r24
    3094:	59 1f       	adc	r21, r25
    3096:	6a 1f       	adc	r22, r26
    3098:	7b 1f       	adc	r23, r27
    309a:	ce 01       	movw	r24, r28
    309c:	89 d9       	rcall	.-3310   	; 0x23b0 <move_window>
    309e:	18 2f       	mov	r17, r24
    30a0:	81 11       	cpse	r24, r1
    30a2:	49 c0       	rjmp	.+146    	; 0x3136 <put_fat+0x21e>
    30a4:	cc 0c       	add	r12, r12
    30a6:	dd 1c       	adc	r13, r13
    30a8:	ee 1c       	adc	r14, r14
    30aa:	ff 1c       	adc	r15, r15
    30ac:	cc 0c       	add	r12, r12
    30ae:	dd 1c       	adc	r13, r13
    30b0:	ee 1c       	adc	r14, r14
    30b2:	ff 1c       	adc	r15, r15
    30b4:	8c ef       	ldi	r24, 0xFC	; 252
    30b6:	c8 22       	and	r12, r24
    30b8:	81 e0       	ldi	r24, 0x01	; 1
    30ba:	d8 22       	and	r13, r24
    30bc:	ee 24       	eor	r14, r14
    30be:	ff 24       	eor	r15, r15
    30c0:	3e e2       	ldi	r19, 0x2E	; 46
    30c2:	c3 0e       	add	r12, r19
    30c4:	d1 1c       	adc	r13, r1
    30c6:	fe 01       	movw	r30, r28
    30c8:	ec 0d       	add	r30, r12
    30ca:	fd 1d       	adc	r31, r13
    30cc:	80 81       	ld	r24, Z
    30ce:	91 81       	ldd	r25, Z+1	; 0x01
    30d0:	a2 81       	ldd	r26, Z+2	; 0x02
    30d2:	b3 81       	ldd	r27, Z+3	; 0x03
    30d4:	88 27       	eor	r24, r24
    30d6:	99 27       	eor	r25, r25
    30d8:	aa 27       	eor	r26, r26
    30da:	b0 7f       	andi	r27, 0xF0	; 240
    30dc:	48 2a       	or	r4, r24
    30de:	59 2a       	or	r5, r25
    30e0:	6a 2a       	or	r6, r26
    30e2:	7b 2a       	or	r7, r27
    30e4:	40 82       	st	Z, r4
    30e6:	51 82       	std	Z+1, r5	; 0x01
    30e8:	62 82       	std	Z+2, r6	; 0x02
    30ea:	73 82       	std	Z+3, r7	; 0x03
    30ec:	81 e0       	ldi	r24, 0x01	; 1
    30ee:	8c 83       	std	Y+4, r24	; 0x04
    30f0:	22 c0       	rjmp	.+68     	; 0x3136 <put_fat+0x21e>
    30f2:	12 e0       	ldi	r17, 0x02	; 2
    30f4:	20 c0       	rjmp	.+64     	; 0x3136 <put_fat+0x21e>
    30f6:	12 e0       	ldi	r17, 0x02	; 2
    30f8:	1e c0       	rjmp	.+60     	; 0x3136 <put_fat+0x21e>
    30fa:	12 e0       	ldi	r17, 0x02	; 2
    30fc:	1c c0       	rjmp	.+56     	; 0x3136 <put_fat+0x21e>
    30fe:	18 2f       	mov	r17, r24
    3100:	1a c0       	rjmp	.+52     	; 0x3136 <put_fat+0x21e>
    3102:	18 2f       	mov	r17, r24
    3104:	18 c0       	rjmp	.+48     	; 0x3136 <put_fat+0x21e>
    3106:	f4 01       	movw	r30, r8
    3108:	f1 70       	andi	r31, 0x01	; 1
    310a:	68 94       	set
    310c:	13 f8       	bld	r1, 3
    310e:	76 94       	lsr	r7
    3110:	67 94       	ror	r6
    3112:	57 94       	ror	r5
    3114:	47 94       	ror	r4
    3116:	16 94       	lsr	r1
    3118:	d1 f7       	brne	.-12     	; 0x310e <put_fat+0x1f6>
    311a:	83 cf       	rjmp	.-250    	; 0x3022 <put_fat+0x10a>
    311c:	f4 01       	movw	r30, r8
    311e:	f1 70       	andi	r31, 0x01	; 1
    3120:	de 01       	movw	r26, r28
    3122:	ae 0f       	add	r26, r30
    3124:	bf 1f       	adc	r27, r31
    3126:	9e 96       	adiw	r26, 0x2e	; 46
    3128:	9c 91       	ld	r25, X
    312a:	90 7f       	andi	r25, 0xF0	; 240
    312c:	85 2d       	mov	r24, r5
    312e:	8f 70       	andi	r24, 0x0F	; 15
    3130:	49 2e       	mov	r4, r25
    3132:	48 2a       	or	r4, r24
    3134:	76 cf       	rjmp	.-276    	; 0x3022 <put_fat+0x10a>
    3136:	81 2f       	mov	r24, r17
    3138:	df 91       	pop	r29
    313a:	cf 91       	pop	r28
    313c:	1f 91       	pop	r17
    313e:	0f 91       	pop	r16
    3140:	ff 90       	pop	r15
    3142:	ef 90       	pop	r14
    3144:	df 90       	pop	r13
    3146:	cf 90       	pop	r12
    3148:	bf 90       	pop	r11
    314a:	af 90       	pop	r10
    314c:	9f 90       	pop	r9
    314e:	8f 90       	pop	r8
    3150:	7f 90       	pop	r7
    3152:	6f 90       	pop	r6
    3154:	5f 90       	pop	r5
    3156:	4f 90       	pop	r4
    3158:	08 95       	ret

0000315a <create_chain>:
    315a:	2f 92       	push	r2
    315c:	3f 92       	push	r3
    315e:	4f 92       	push	r4
    3160:	5f 92       	push	r5
    3162:	6f 92       	push	r6
    3164:	7f 92       	push	r7
    3166:	8f 92       	push	r8
    3168:	9f 92       	push	r9
    316a:	af 92       	push	r10
    316c:	bf 92       	push	r11
    316e:	cf 92       	push	r12
    3170:	df 92       	push	r13
    3172:	ef 92       	push	r14
    3174:	ff 92       	push	r15
    3176:	0f 93       	push	r16
    3178:	1f 93       	push	r17
    317a:	cf 93       	push	r28
    317c:	df 93       	push	r29
    317e:	ec 01       	movw	r28, r24
    3180:	2a 01       	movw	r4, r20
    3182:	3b 01       	movw	r6, r22
    3184:	41 15       	cp	r20, r1
    3186:	51 05       	cpc	r21, r1
    3188:	61 05       	cpc	r22, r1
    318a:	71 05       	cpc	r23, r1
    318c:	b9 f4       	brne	.+46     	; 0x31bc <create_chain+0x62>
    318e:	8a 84       	ldd	r8, Y+10	; 0x0a
    3190:	9b 84       	ldd	r9, Y+11	; 0x0b
    3192:	ac 84       	ldd	r10, Y+12	; 0x0c
    3194:	bd 84       	ldd	r11, Y+13	; 0x0d
    3196:	81 14       	cp	r8, r1
    3198:	91 04       	cpc	r9, r1
    319a:	a1 04       	cpc	r10, r1
    319c:	b1 04       	cpc	r11, r1
    319e:	59 f1       	breq	.+86     	; 0x31f6 <create_chain+0x9c>
    31a0:	8a 89       	ldd	r24, Y+18	; 0x12
    31a2:	9b 89       	ldd	r25, Y+19	; 0x13
    31a4:	ac 89       	ldd	r26, Y+20	; 0x14
    31a6:	bd 89       	ldd	r27, Y+21	; 0x15
    31a8:	88 16       	cp	r8, r24
    31aa:	99 06       	cpc	r9, r25
    31ac:	aa 06       	cpc	r10, r26
    31ae:	bb 06       	cpc	r11, r27
    31b0:	30 f1       	brcs	.+76     	; 0x31fe <create_chain+0xa4>
    31b2:	81 2c       	mov	r8, r1
    31b4:	91 2c       	mov	r9, r1
    31b6:	54 01       	movw	r10, r8
    31b8:	83 94       	inc	r8
    31ba:	21 c0       	rjmp	.+66     	; 0x31fe <create_chain+0xa4>
    31bc:	0f dd       	rcall	.-1506   	; 0x2bdc <get_fat>
    31be:	6b 01       	movw	r12, r22
    31c0:	7c 01       	movw	r14, r24
    31c2:	62 30       	cpi	r22, 0x02	; 2
    31c4:	71 05       	cpc	r23, r1
    31c6:	81 05       	cpc	r24, r1
    31c8:	91 05       	cpc	r25, r1
    31ca:	08 f4       	brcc	.+2      	; 0x31ce <create_chain+0x74>
    31cc:	96 c0       	rjmp	.+300    	; 0x32fa <create_chain+0x1a0>
    31ce:	8f ef       	ldi	r24, 0xFF	; 255
    31d0:	c8 16       	cp	r12, r24
    31d2:	d8 06       	cpc	r13, r24
    31d4:	e8 06       	cpc	r14, r24
    31d6:	f8 06       	cpc	r15, r24
    31d8:	09 f4       	brne	.+2      	; 0x31dc <create_chain+0x82>
    31da:	94 c0       	rjmp	.+296    	; 0x3304 <create_chain+0x1aa>
    31dc:	8a 89       	ldd	r24, Y+18	; 0x12
    31de:	9b 89       	ldd	r25, Y+19	; 0x13
    31e0:	ac 89       	ldd	r26, Y+20	; 0x14
    31e2:	bd 89       	ldd	r27, Y+21	; 0x15
    31e4:	c8 16       	cp	r12, r24
    31e6:	d9 06       	cpc	r13, r25
    31e8:	ea 06       	cpc	r14, r26
    31ea:	fb 06       	cpc	r15, r27
    31ec:	08 f4       	brcc	.+2      	; 0x31f0 <create_chain+0x96>
    31ee:	8f c0       	rjmp	.+286    	; 0x330e <create_chain+0x1b4>
    31f0:	53 01       	movw	r10, r6
    31f2:	42 01       	movw	r8, r4
    31f4:	04 c0       	rjmp	.+8      	; 0x31fe <create_chain+0xa4>
    31f6:	81 2c       	mov	r8, r1
    31f8:	91 2c       	mov	r9, r1
    31fa:	54 01       	movw	r10, r8
    31fc:	83 94       	inc	r8
    31fe:	75 01       	movw	r14, r10
    3200:	64 01       	movw	r12, r8
    3202:	68 94       	set
    3204:	22 24       	eor	r2, r2
    3206:	21 f8       	bld	r2, 1
    3208:	31 2c       	mov	r3, r1
    320a:	00 e0       	ldi	r16, 0x00	; 0
    320c:	10 e0       	ldi	r17, 0x00	; 0
    320e:	2f ef       	ldi	r18, 0xFF	; 255
    3210:	c2 1a       	sub	r12, r18
    3212:	d2 0a       	sbc	r13, r18
    3214:	e2 0a       	sbc	r14, r18
    3216:	f2 0a       	sbc	r15, r18
    3218:	8a 89       	ldd	r24, Y+18	; 0x12
    321a:	9b 89       	ldd	r25, Y+19	; 0x13
    321c:	ac 89       	ldd	r26, Y+20	; 0x14
    321e:	bd 89       	ldd	r27, Y+21	; 0x15
    3220:	c8 16       	cp	r12, r24
    3222:	d9 06       	cpc	r13, r25
    3224:	ea 06       	cpc	r14, r26
    3226:	fb 06       	cpc	r15, r27
    3228:	58 f0       	brcs	.+22     	; 0x3240 <create_chain+0xe6>
    322a:	82 e0       	ldi	r24, 0x02	; 2
    322c:	88 16       	cp	r8, r24
    322e:	91 04       	cpc	r9, r1
    3230:	a1 04       	cpc	r10, r1
    3232:	b1 04       	cpc	r11, r1
    3234:	08 f4       	brcc	.+2      	; 0x3238 <create_chain+0xde>
    3236:	70 c0       	rjmp	.+224    	; 0x3318 <create_chain+0x1be>
    3238:	c2 2c       	mov	r12, r2
    323a:	d3 2c       	mov	r13, r3
    323c:	e0 2e       	mov	r14, r16
    323e:	f1 2e       	mov	r15, r17
    3240:	b7 01       	movw	r22, r14
    3242:	a6 01       	movw	r20, r12
    3244:	ce 01       	movw	r24, r28
    3246:	ca dc       	rcall	.-1644   	; 0x2bdc <get_fat>
    3248:	61 15       	cp	r22, r1
    324a:	71 05       	cpc	r23, r1
    324c:	81 05       	cpc	r24, r1
    324e:	91 05       	cpc	r25, r1
    3250:	99 f0       	breq	.+38     	; 0x3278 <create_chain+0x11e>
    3252:	6f 3f       	cpi	r22, 0xFF	; 255
    3254:	2f ef       	ldi	r18, 0xFF	; 255
    3256:	72 07       	cpc	r23, r18
    3258:	82 07       	cpc	r24, r18
    325a:	92 07       	cpc	r25, r18
    325c:	09 f4       	brne	.+2      	; 0x3260 <create_chain+0x106>
    325e:	61 c0       	rjmp	.+194    	; 0x3322 <create_chain+0x1c8>
    3260:	61 30       	cpi	r22, 0x01	; 1
    3262:	71 05       	cpc	r23, r1
    3264:	81 05       	cpc	r24, r1
    3266:	91 05       	cpc	r25, r1
    3268:	09 f4       	brne	.+2      	; 0x326c <create_chain+0x112>
    326a:	60 c0       	rjmp	.+192    	; 0x332c <create_chain+0x1d2>
    326c:	c8 14       	cp	r12, r8
    326e:	d9 04       	cpc	r13, r9
    3270:	ea 04       	cpc	r14, r10
    3272:	fb 04       	cpc	r15, r11
    3274:	61 f6       	brne	.-104    	; 0x320e <create_chain+0xb4>
    3276:	5f c0       	rjmp	.+190    	; 0x3336 <create_chain+0x1dc>
    3278:	8c 2c       	mov	r8, r12
    327a:	9d 2c       	mov	r9, r13
    327c:	ae 2c       	mov	r10, r14
    327e:	bf 2c       	mov	r11, r15
    3280:	0f ef       	ldi	r16, 0xFF	; 255
    3282:	1f ef       	ldi	r17, 0xFF	; 255
    3284:	2f ef       	ldi	r18, 0xFF	; 255
    3286:	3f e0       	ldi	r19, 0x0F	; 15
    3288:	b7 01       	movw	r22, r14
    328a:	a6 01       	movw	r20, r12
    328c:	ce 01       	movw	r24, r28
    328e:	44 de       	rcall	.-888    	; 0x2f18 <put_fat>
    3290:	81 11       	cpse	r24, r1
    3292:	2c c0       	rjmp	.+88     	; 0x32ec <create_chain+0x192>
    3294:	41 14       	cp	r4, r1
    3296:	51 04       	cpc	r5, r1
    3298:	61 04       	cpc	r6, r1
    329a:	71 04       	cpc	r7, r1
    329c:	51 f0       	breq	.+20     	; 0x32b2 <create_chain+0x158>
    329e:	0c 2d       	mov	r16, r12
    32a0:	1d 2d       	mov	r17, r13
    32a2:	2e 2d       	mov	r18, r14
    32a4:	3f 2d       	mov	r19, r15
    32a6:	b3 01       	movw	r22, r6
    32a8:	a2 01       	movw	r20, r4
    32aa:	ce 01       	movw	r24, r28
    32ac:	35 de       	rcall	.-918    	; 0x2f18 <put_fat>
    32ae:	81 11       	cpse	r24, r1
    32b0:	1d c0       	rjmp	.+58     	; 0x32ec <create_chain+0x192>
    32b2:	8a 86       	std	Y+10, r8	; 0x0a
    32b4:	9b 86       	std	Y+11, r9	; 0x0b
    32b6:	ac 86       	std	Y+12, r10	; 0x0c
    32b8:	bd 86       	std	Y+13, r11	; 0x0d
    32ba:	8e 85       	ldd	r24, Y+14	; 0x0e
    32bc:	9f 85       	ldd	r25, Y+15	; 0x0f
    32be:	a8 89       	ldd	r26, Y+16	; 0x10
    32c0:	b9 89       	ldd	r27, Y+17	; 0x11
    32c2:	8f 3f       	cpi	r24, 0xFF	; 255
    32c4:	2f ef       	ldi	r18, 0xFF	; 255
    32c6:	92 07       	cpc	r25, r18
    32c8:	a2 07       	cpc	r26, r18
    32ca:	b2 07       	cpc	r27, r18
    32cc:	c9 f1       	breq	.+114    	; 0x3340 <create_chain+0x1e6>
    32ce:	01 97       	sbiw	r24, 0x01	; 1
    32d0:	a1 09       	sbc	r26, r1
    32d2:	b1 09       	sbc	r27, r1
    32d4:	8e 87       	std	Y+14, r24	; 0x0e
    32d6:	9f 87       	std	Y+15, r25	; 0x0f
    32d8:	a8 8b       	std	Y+16, r26	; 0x10
    32da:	b9 8b       	std	Y+17, r27	; 0x11
    32dc:	8d 81       	ldd	r24, Y+5	; 0x05
    32de:	81 60       	ori	r24, 0x01	; 1
    32e0:	8d 83       	std	Y+5, r24	; 0x05
    32e2:	6c 2d       	mov	r22, r12
    32e4:	7d 2d       	mov	r23, r13
    32e6:	8e 2d       	mov	r24, r14
    32e8:	9f 2d       	mov	r25, r15
    32ea:	33 c0       	rjmp	.+102    	; 0x3352 <create_chain+0x1f8>
    32ec:	81 30       	cpi	r24, 0x01	; 1
    32ee:	69 f1       	breq	.+90     	; 0x334a <create_chain+0x1f0>
    32f0:	61 e0       	ldi	r22, 0x01	; 1
    32f2:	70 e0       	ldi	r23, 0x00	; 0
    32f4:	80 e0       	ldi	r24, 0x00	; 0
    32f6:	90 e0       	ldi	r25, 0x00	; 0
    32f8:	2c c0       	rjmp	.+88     	; 0x3352 <create_chain+0x1f8>
    32fa:	61 e0       	ldi	r22, 0x01	; 1
    32fc:	70 e0       	ldi	r23, 0x00	; 0
    32fe:	80 e0       	ldi	r24, 0x00	; 0
    3300:	90 e0       	ldi	r25, 0x00	; 0
    3302:	27 c0       	rjmp	.+78     	; 0x3352 <create_chain+0x1f8>
    3304:	6f ef       	ldi	r22, 0xFF	; 255
    3306:	7f ef       	ldi	r23, 0xFF	; 255
    3308:	8f ef       	ldi	r24, 0xFF	; 255
    330a:	9f ef       	ldi	r25, 0xFF	; 255
    330c:	22 c0       	rjmp	.+68     	; 0x3352 <create_chain+0x1f8>
    330e:	6c 2d       	mov	r22, r12
    3310:	7d 2d       	mov	r23, r13
    3312:	8e 2d       	mov	r24, r14
    3314:	9f 2d       	mov	r25, r15
    3316:	1d c0       	rjmp	.+58     	; 0x3352 <create_chain+0x1f8>
    3318:	60 e0       	ldi	r22, 0x00	; 0
    331a:	70 e0       	ldi	r23, 0x00	; 0
    331c:	80 e0       	ldi	r24, 0x00	; 0
    331e:	90 e0       	ldi	r25, 0x00	; 0
    3320:	18 c0       	rjmp	.+48     	; 0x3352 <create_chain+0x1f8>
    3322:	6f ef       	ldi	r22, 0xFF	; 255
    3324:	7f ef       	ldi	r23, 0xFF	; 255
    3326:	8f ef       	ldi	r24, 0xFF	; 255
    3328:	9f ef       	ldi	r25, 0xFF	; 255
    332a:	13 c0       	rjmp	.+38     	; 0x3352 <create_chain+0x1f8>
    332c:	61 e0       	ldi	r22, 0x01	; 1
    332e:	70 e0       	ldi	r23, 0x00	; 0
    3330:	80 e0       	ldi	r24, 0x00	; 0
    3332:	90 e0       	ldi	r25, 0x00	; 0
    3334:	0e c0       	rjmp	.+28     	; 0x3352 <create_chain+0x1f8>
    3336:	60 e0       	ldi	r22, 0x00	; 0
    3338:	70 e0       	ldi	r23, 0x00	; 0
    333a:	80 e0       	ldi	r24, 0x00	; 0
    333c:	90 e0       	ldi	r25, 0x00	; 0
    333e:	09 c0       	rjmp	.+18     	; 0x3352 <create_chain+0x1f8>
    3340:	6c 2d       	mov	r22, r12
    3342:	7d 2d       	mov	r23, r13
    3344:	8e 2d       	mov	r24, r14
    3346:	9f 2d       	mov	r25, r15
    3348:	04 c0       	rjmp	.+8      	; 0x3352 <create_chain+0x1f8>
    334a:	6f ef       	ldi	r22, 0xFF	; 255
    334c:	7f ef       	ldi	r23, 0xFF	; 255
    334e:	8f ef       	ldi	r24, 0xFF	; 255
    3350:	9f ef       	ldi	r25, 0xFF	; 255
    3352:	df 91       	pop	r29
    3354:	cf 91       	pop	r28
    3356:	1f 91       	pop	r17
    3358:	0f 91       	pop	r16
    335a:	ff 90       	pop	r15
    335c:	ef 90       	pop	r14
    335e:	df 90       	pop	r13
    3360:	cf 90       	pop	r12
    3362:	bf 90       	pop	r11
    3364:	af 90       	pop	r10
    3366:	9f 90       	pop	r9
    3368:	8f 90       	pop	r8
    336a:	7f 90       	pop	r7
    336c:	6f 90       	pop	r6
    336e:	5f 90       	pop	r5
    3370:	4f 90       	pop	r4
    3372:	3f 90       	pop	r3
    3374:	2f 90       	pop	r2
    3376:	08 95       	ret

00003378 <dir_next>:
    3378:	7f 92       	push	r7
    337a:	8f 92       	push	r8
    337c:	9f 92       	push	r9
    337e:	af 92       	push	r10
    3380:	bf 92       	push	r11
    3382:	cf 92       	push	r12
    3384:	df 92       	push	r13
    3386:	ef 92       	push	r14
    3388:	ff 92       	push	r15
    338a:	0f 93       	push	r16
    338c:	1f 93       	push	r17
    338e:	cf 93       	push	r28
    3390:	df 93       	push	r29
    3392:	dc 01       	movw	r26, r24
    3394:	14 96       	adiw	r26, 0x04	; 4
    3396:	cd 91       	ld	r28, X+
    3398:	dc 91       	ld	r29, X
    339a:	15 97       	sbiw	r26, 0x05	; 5
    339c:	21 96       	adiw	r28, 0x01	; 1
    339e:	09 f4       	brne	.+2      	; 0x33a2 <dir_next+0x2a>
    33a0:	03 c1       	rjmp	.+518    	; 0x35a8 <dir_next+0x230>
    33a2:	1e 96       	adiw	r26, 0x0e	; 14
    33a4:	8d 90       	ld	r8, X+
    33a6:	9d 90       	ld	r9, X+
    33a8:	ad 90       	ld	r10, X+
    33aa:	bc 90       	ld	r11, X
    33ac:	51 97       	sbiw	r26, 0x11	; 17
    33ae:	81 14       	cp	r8, r1
    33b0:	91 04       	cpc	r9, r1
    33b2:	a1 04       	cpc	r10, r1
    33b4:	b1 04       	cpc	r11, r1
    33b6:	09 f4       	brne	.+2      	; 0x33ba <dir_next+0x42>
    33b8:	f9 c0       	rjmp	.+498    	; 0x35ac <dir_next+0x234>
    33ba:	7b 01       	movw	r14, r22
    33bc:	8c 01       	movw	r16, r24
    33be:	6e 01       	movw	r12, r28
    33c0:	bf e0       	ldi	r27, 0x0F	; 15
    33c2:	cb 22       	and	r12, r27
    33c4:	dd 24       	eor	r13, r13
    33c6:	c1 14       	cp	r12, r1
    33c8:	d1 04       	cpc	r13, r1
    33ca:	09 f0       	breq	.+2      	; 0x33ce <dir_next+0x56>
    33cc:	d1 c0       	rjmp	.+418    	; 0x3570 <dir_next+0x1f8>
    33ce:	ef ef       	ldi	r30, 0xFF	; 255
    33d0:	8e 1a       	sub	r8, r30
    33d2:	9e 0a       	sbc	r9, r30
    33d4:	ae 0a       	sbc	r10, r30
    33d6:	be 0a       	sbc	r11, r30
    33d8:	dc 01       	movw	r26, r24
    33da:	1e 96       	adiw	r26, 0x0e	; 14
    33dc:	8d 92       	st	X+, r8
    33de:	9d 92       	st	X+, r9
    33e0:	ad 92       	st	X+, r10
    33e2:	bc 92       	st	X, r11
    33e4:	51 97       	sbiw	r26, 0x11	; 17
    33e6:	1a 96       	adiw	r26, 0x0a	; 10
    33e8:	4d 91       	ld	r20, X+
    33ea:	5d 91       	ld	r21, X+
    33ec:	6d 91       	ld	r22, X+
    33ee:	7c 91       	ld	r23, X
    33f0:	1d 97       	sbiw	r26, 0x0d	; 13
    33f2:	41 15       	cp	r20, r1
    33f4:	51 05       	cpc	r21, r1
    33f6:	61 05       	cpc	r22, r1
    33f8:	71 05       	cpc	r23, r1
    33fa:	49 f4       	brne	.+18     	; 0x340e <dir_next+0x96>
    33fc:	ed 91       	ld	r30, X+
    33fe:	fc 91       	ld	r31, X
    3400:	80 85       	ldd	r24, Z+8	; 0x08
    3402:	91 85       	ldd	r25, Z+9	; 0x09
    3404:	c8 17       	cp	r28, r24
    3406:	d9 07       	cpc	r29, r25
    3408:	08 f0       	brcs	.+2      	; 0x340c <dir_next+0x94>
    340a:	d2 c0       	rjmp	.+420    	; 0x35b0 <dir_next+0x238>
    340c:	b1 c0       	rjmp	.+354    	; 0x3570 <dir_next+0x1f8>
    340e:	dc 01       	movw	r26, r24
    3410:	ed 91       	ld	r30, X+
    3412:	fc 91       	ld	r31, X
    3414:	22 81       	ldd	r18, Z+2	; 0x02
    3416:	30 e0       	ldi	r19, 0x00	; 0
    3418:	21 50       	subi	r18, 0x01	; 1
    341a:	31 09       	sbc	r19, r1
    341c:	ce 01       	movw	r24, r28
    341e:	92 95       	swap	r25
    3420:	82 95       	swap	r24
    3422:	8f 70       	andi	r24, 0x0F	; 15
    3424:	89 27       	eor	r24, r25
    3426:	9f 70       	andi	r25, 0x0F	; 15
    3428:	89 27       	eor	r24, r25
    342a:	28 23       	and	r18, r24
    342c:	39 23       	and	r19, r25
    342e:	23 2b       	or	r18, r19
    3430:	09 f0       	breq	.+2      	; 0x3434 <dir_next+0xbc>
    3432:	9e c0       	rjmp	.+316    	; 0x3570 <dir_next+0x1f8>
    3434:	cf 01       	movw	r24, r30
    3436:	d2 db       	rcall	.-2140   	; 0x2bdc <get_fat>
    3438:	4b 01       	movw	r8, r22
    343a:	5c 01       	movw	r10, r24
    343c:	62 30       	cpi	r22, 0x02	; 2
    343e:	71 05       	cpc	r23, r1
    3440:	81 05       	cpc	r24, r1
    3442:	91 05       	cpc	r25, r1
    3444:	08 f4       	brcc	.+2      	; 0x3448 <dir_next+0xd0>
    3446:	b6 c0       	rjmp	.+364    	; 0x35b4 <dir_next+0x23c>
    3448:	6f 3f       	cpi	r22, 0xFF	; 255
    344a:	7f 4f       	sbci	r23, 0xFF	; 255
    344c:	8f 4f       	sbci	r24, 0xFF	; 255
    344e:	9f 4f       	sbci	r25, 0xFF	; 255
    3450:	09 f4       	brne	.+2      	; 0x3454 <dir_next+0xdc>
    3452:	b2 c0       	rjmp	.+356    	; 0x35b8 <dir_next+0x240>
    3454:	d8 01       	movw	r26, r16
    3456:	ed 91       	ld	r30, X+
    3458:	fc 91       	ld	r31, X
    345a:	82 89       	ldd	r24, Z+18	; 0x12
    345c:	93 89       	ldd	r25, Z+19	; 0x13
    345e:	a4 89       	ldd	r26, Z+20	; 0x14
    3460:	b5 89       	ldd	r27, Z+21	; 0x15
    3462:	88 16       	cp	r8, r24
    3464:	99 06       	cpc	r9, r25
    3466:	aa 06       	cpc	r10, r26
    3468:	bb 06       	cpc	r11, r27
    346a:	08 f4       	brcc	.+2      	; 0x346e <dir_next+0xf6>
    346c:	70 c0       	rjmp	.+224    	; 0x354e <dir_next+0x1d6>
    346e:	ef 28       	or	r14, r15
    3470:	09 f4       	brne	.+2      	; 0x3474 <dir_next+0xfc>
    3472:	a4 c0       	rjmp	.+328    	; 0x35bc <dir_next+0x244>
    3474:	d8 01       	movw	r26, r16
    3476:	1a 96       	adiw	r26, 0x0a	; 10
    3478:	4d 91       	ld	r20, X+
    347a:	5d 91       	ld	r21, X+
    347c:	6d 91       	ld	r22, X+
    347e:	7c 91       	ld	r23, X
    3480:	1d 97       	sbiw	r26, 0x0d	; 13
    3482:	cf 01       	movw	r24, r30
    3484:	6a de       	rcall	.-812    	; 0x315a <create_chain>
    3486:	4b 01       	movw	r8, r22
    3488:	5c 01       	movw	r10, r24
    348a:	61 15       	cp	r22, r1
    348c:	71 05       	cpc	r23, r1
    348e:	81 05       	cpc	r24, r1
    3490:	91 05       	cpc	r25, r1
    3492:	09 f4       	brne	.+2      	; 0x3496 <dir_next+0x11e>
    3494:	95 c0       	rjmp	.+298    	; 0x35c0 <dir_next+0x248>
    3496:	61 30       	cpi	r22, 0x01	; 1
    3498:	71 05       	cpc	r23, r1
    349a:	81 05       	cpc	r24, r1
    349c:	91 05       	cpc	r25, r1
    349e:	09 f4       	brne	.+2      	; 0x34a2 <dir_next+0x12a>
    34a0:	91 c0       	rjmp	.+290    	; 0x35c4 <dir_next+0x24c>
    34a2:	6f 3f       	cpi	r22, 0xFF	; 255
    34a4:	7f 4f       	sbci	r23, 0xFF	; 255
    34a6:	8f 4f       	sbci	r24, 0xFF	; 255
    34a8:	9f 4f       	sbci	r25, 0xFF	; 255
    34aa:	09 f4       	brne	.+2      	; 0x34ae <dir_next+0x136>
    34ac:	8d c0       	rjmp	.+282    	; 0x35c8 <dir_next+0x250>
    34ae:	d8 01       	movw	r26, r16
    34b0:	8d 91       	ld	r24, X+
    34b2:	9c 91       	ld	r25, X
    34b4:	0e 94 6f 11 	call	0x22de	; 0x22de <sync_window>
    34b8:	81 11       	cpse	r24, r1
    34ba:	88 c0       	rjmp	.+272    	; 0x35cc <dir_next+0x254>
    34bc:	f8 01       	movw	r30, r16
    34be:	80 81       	ld	r24, Z
    34c0:	91 81       	ldd	r25, Z+1	; 0x01
    34c2:	fc 01       	movw	r30, r24
    34c4:	be 96       	adiw	r30, 0x2e	; 46
    34c6:	82 5d       	subi	r24, 0xD2	; 210
    34c8:	9d 4f       	sbci	r25, 0xFD	; 253
    34ca:	11 92       	st	Z+, r1
    34cc:	e8 17       	cp	r30, r24
    34ce:	f9 07       	cpc	r31, r25
    34d0:	e1 f7       	brne	.-8      	; 0x34ca <dir_next+0x152>
    34d2:	d8 01       	movw	r26, r16
    34d4:	ed 90       	ld	r14, X+
    34d6:	fc 90       	ld	r15, X
    34d8:	b5 01       	movw	r22, r10
    34da:	a4 01       	movw	r20, r8
    34dc:	c7 01       	movw	r24, r14
    34de:	50 db       	rcall	.-2400   	; 0x2b80 <clust2sect>
    34e0:	f7 01       	movw	r30, r14
    34e2:	62 a7       	std	Z+42, r22	; 0x2a
    34e4:	73 a7       	std	Z+43, r23	; 0x2b
    34e6:	84 a7       	std	Z+44, r24	; 0x2c
    34e8:	95 a7       	std	Z+45, r25	; 0x2d
    34ea:	e1 2c       	mov	r14, r1
    34ec:	f1 2c       	mov	r15, r1
    34ee:	77 24       	eor	r7, r7
    34f0:	73 94       	inc	r7
    34f2:	19 c0       	rjmp	.+50     	; 0x3526 <dir_next+0x1ae>
    34f4:	74 82       	std	Z+4, r7	; 0x04
    34f6:	d8 01       	movw	r26, r16
    34f8:	8d 91       	ld	r24, X+
    34fa:	9c 91       	ld	r25, X
    34fc:	0e 94 6f 11 	call	0x22de	; 0x22de <sync_window>
    3500:	81 11       	cpse	r24, r1
    3502:	66 c0       	rjmp	.+204    	; 0x35d0 <dir_next+0x258>
    3504:	d8 01       	movw	r26, r16
    3506:	ed 91       	ld	r30, X+
    3508:	fc 91       	ld	r31, X
    350a:	82 a5       	ldd	r24, Z+42	; 0x2a
    350c:	93 a5       	ldd	r25, Z+43	; 0x2b
    350e:	a4 a5       	ldd	r26, Z+44	; 0x2c
    3510:	b5 a5       	ldd	r27, Z+45	; 0x2d
    3512:	01 96       	adiw	r24, 0x01	; 1
    3514:	a1 1d       	adc	r26, r1
    3516:	b1 1d       	adc	r27, r1
    3518:	82 a7       	std	Z+42, r24	; 0x2a
    351a:	93 a7       	std	Z+43, r25	; 0x2b
    351c:	a4 a7       	std	Z+44, r26	; 0x2c
    351e:	b5 a7       	std	Z+45, r27	; 0x2d
    3520:	bf ef       	ldi	r27, 0xFF	; 255
    3522:	eb 1a       	sub	r14, r27
    3524:	fb 0a       	sbc	r15, r27
    3526:	d8 01       	movw	r26, r16
    3528:	ed 91       	ld	r30, X+
    352a:	fc 91       	ld	r31, X
    352c:	82 81       	ldd	r24, Z+2	; 0x02
    352e:	90 e0       	ldi	r25, 0x00	; 0
    3530:	e8 16       	cp	r14, r24
    3532:	f9 06       	cpc	r15, r25
    3534:	f8 f2       	brcs	.-66     	; 0x34f4 <dir_next+0x17c>
    3536:	82 a5       	ldd	r24, Z+42	; 0x2a
    3538:	93 a5       	ldd	r25, Z+43	; 0x2b
    353a:	a4 a5       	ldd	r26, Z+44	; 0x2c
    353c:	b5 a5       	ldd	r27, Z+45	; 0x2d
    353e:	8e 19       	sub	r24, r14
    3540:	9f 09       	sbc	r25, r15
    3542:	a1 09       	sbc	r26, r1
    3544:	b1 09       	sbc	r27, r1
    3546:	82 a7       	std	Z+42, r24	; 0x2a
    3548:	93 a7       	std	Z+43, r25	; 0x2b
    354a:	a4 a7       	std	Z+44, r26	; 0x2c
    354c:	b5 a7       	std	Z+45, r27	; 0x2d
    354e:	f8 01       	movw	r30, r16
    3550:	82 86       	std	Z+10, r8	; 0x0a
    3552:	93 86       	std	Z+11, r9	; 0x0b
    3554:	a4 86       	std	Z+12, r10	; 0x0c
    3556:	b5 86       	std	Z+13, r11	; 0x0d
    3558:	b5 01       	movw	r22, r10
    355a:	a4 01       	movw	r20, r8
    355c:	80 81       	ld	r24, Z
    355e:	91 81       	ldd	r25, Z+1	; 0x01
    3560:	0f db       	rcall	.-2530   	; 0x2b80 <clust2sect>
    3562:	d8 01       	movw	r26, r16
    3564:	1e 96       	adiw	r26, 0x0e	; 14
    3566:	6d 93       	st	X+, r22
    3568:	7d 93       	st	X+, r23
    356a:	8d 93       	st	X+, r24
    356c:	9c 93       	st	X, r25
    356e:	51 97       	sbiw	r26, 0x11	; 17
    3570:	f8 01       	movw	r30, r16
    3572:	d5 83       	std	Z+5, r29	; 0x05
    3574:	c4 83       	std	Z+4, r28	; 0x04
    3576:	cc 0c       	add	r12, r12
    3578:	dd 1c       	adc	r13, r13
    357a:	cc 0c       	add	r12, r12
    357c:	dd 1c       	adc	r13, r13
    357e:	cc 0c       	add	r12, r12
    3580:	dd 1c       	adc	r13, r13
    3582:	cc 0c       	add	r12, r12
    3584:	dd 1c       	adc	r13, r13
    3586:	cc 0c       	add	r12, r12
    3588:	dd 1c       	adc	r13, r13
    358a:	fe e2       	ldi	r31, 0x2E	; 46
    358c:	cf 0e       	add	r12, r31
    358e:	d1 1c       	adc	r13, r1
    3590:	d8 01       	movw	r26, r16
    3592:	8d 91       	ld	r24, X+
    3594:	9c 91       	ld	r25, X
    3596:	11 97       	sbiw	r26, 0x01	; 1
    3598:	c8 0e       	add	r12, r24
    359a:	d9 1e       	adc	r13, r25
    359c:	53 96       	adiw	r26, 0x13	; 19
    359e:	dc 92       	st	X, r13
    35a0:	ce 92       	st	-X, r12
    35a2:	52 97       	sbiw	r26, 0x12	; 18
    35a4:	80 e0       	ldi	r24, 0x00	; 0
    35a6:	15 c0       	rjmp	.+42     	; 0x35d2 <dir_next+0x25a>
    35a8:	84 e0       	ldi	r24, 0x04	; 4
    35aa:	13 c0       	rjmp	.+38     	; 0x35d2 <dir_next+0x25a>
    35ac:	84 e0       	ldi	r24, 0x04	; 4
    35ae:	11 c0       	rjmp	.+34     	; 0x35d2 <dir_next+0x25a>
    35b0:	84 e0       	ldi	r24, 0x04	; 4
    35b2:	0f c0       	rjmp	.+30     	; 0x35d2 <dir_next+0x25a>
    35b4:	82 e0       	ldi	r24, 0x02	; 2
    35b6:	0d c0       	rjmp	.+26     	; 0x35d2 <dir_next+0x25a>
    35b8:	81 e0       	ldi	r24, 0x01	; 1
    35ba:	0b c0       	rjmp	.+22     	; 0x35d2 <dir_next+0x25a>
    35bc:	84 e0       	ldi	r24, 0x04	; 4
    35be:	09 c0       	rjmp	.+18     	; 0x35d2 <dir_next+0x25a>
    35c0:	87 e0       	ldi	r24, 0x07	; 7
    35c2:	07 c0       	rjmp	.+14     	; 0x35d2 <dir_next+0x25a>
    35c4:	82 e0       	ldi	r24, 0x02	; 2
    35c6:	05 c0       	rjmp	.+10     	; 0x35d2 <dir_next+0x25a>
    35c8:	81 e0       	ldi	r24, 0x01	; 1
    35ca:	03 c0       	rjmp	.+6      	; 0x35d2 <dir_next+0x25a>
    35cc:	81 e0       	ldi	r24, 0x01	; 1
    35ce:	01 c0       	rjmp	.+2      	; 0x35d2 <dir_next+0x25a>
    35d0:	81 e0       	ldi	r24, 0x01	; 1
    35d2:	df 91       	pop	r29
    35d4:	cf 91       	pop	r28
    35d6:	1f 91       	pop	r17
    35d8:	0f 91       	pop	r16
    35da:	ff 90       	pop	r15
    35dc:	ef 90       	pop	r14
    35de:	df 90       	pop	r13
    35e0:	cf 90       	pop	r12
    35e2:	bf 90       	pop	r11
    35e4:	af 90       	pop	r10
    35e6:	9f 90       	pop	r9
    35e8:	8f 90       	pop	r8
    35ea:	7f 90       	pop	r7
    35ec:	08 95       	ret

000035ee <follow_path>:
    35ee:	2f 92       	push	r2
    35f0:	3f 92       	push	r3
    35f2:	4f 92       	push	r4
    35f4:	5f 92       	push	r5
    35f6:	6f 92       	push	r6
    35f8:	7f 92       	push	r7
    35fa:	8f 92       	push	r8
    35fc:	9f 92       	push	r9
    35fe:	af 92       	push	r10
    3600:	bf 92       	push	r11
    3602:	cf 92       	push	r12
    3604:	df 92       	push	r13
    3606:	ef 92       	push	r14
    3608:	ff 92       	push	r15
    360a:	0f 93       	push	r16
    360c:	1f 93       	push	r17
    360e:	cf 93       	push	r28
    3610:	df 93       	push	r29
    3612:	00 d0       	rcall	.+0      	; 0x3614 <follow_path+0x26>
    3614:	00 d0       	rcall	.+0      	; 0x3616 <follow_path+0x28>
    3616:	1f 92       	push	r1
    3618:	cd b7       	in	r28, 0x3d	; 61
    361a:	de b7       	in	r29, 0x3e	; 62
    361c:	8c 01       	movw	r16, r24
    361e:	7b 01       	movw	r14, r22
    3620:	db 01       	movw	r26, r22
    3622:	8c 91       	ld	r24, X
    3624:	8f 32       	cpi	r24, 0x2F	; 47
    3626:	11 f0       	breq	.+4      	; 0x362c <follow_path+0x3e>
    3628:	8c 35       	cpi	r24, 0x5C	; 92
    362a:	19 f4       	brne	.+6      	; 0x3632 <follow_path+0x44>
    362c:	bf ef       	ldi	r27, 0xFF	; 255
    362e:	eb 1a       	sub	r14, r27
    3630:	fb 0a       	sbc	r15, r27
    3632:	f8 01       	movw	r30, r16
    3634:	16 82       	std	Z+6, r1	; 0x06
    3636:	17 82       	std	Z+7, r1	; 0x07
    3638:	10 86       	std	Z+8, r1	; 0x08
    363a:	11 86       	std	Z+9, r1	; 0x09
    363c:	d7 01       	movw	r26, r14
    363e:	8c 91       	ld	r24, X
    3640:	80 32       	cpi	r24, 0x20	; 32
    3642:	40 f4       	brcc	.+16     	; 0x3654 <follow_path+0x66>
    3644:	60 e0       	ldi	r22, 0x00	; 0
    3646:	70 e0       	ldi	r23, 0x00	; 0
    3648:	c8 01       	movw	r24, r16
    364a:	ab db       	rcall	.-2218   	; 0x2da2 <dir_sdi>
    364c:	f8 01       	movw	r30, r16
    364e:	13 8a       	std	Z+19, r1	; 0x13
    3650:	12 8a       	std	Z+18, r1	; 0x12
    3652:	32 c1       	rjmp	.+612    	; 0x38b8 <follow_path+0x2ca>
    3654:	68 94       	set
    3656:	bb 24       	eor	r11, r11
    3658:	b5 f8       	bld	r11, 5
    365a:	a1 2c       	mov	r10, r1
    365c:	81 2c       	mov	r8, r1
    365e:	68 94       	set
    3660:	77 24       	eor	r7, r7
    3662:	73 f8       	bld	r7, 3
    3664:	51 2c       	mov	r5, r1
    3666:	61 2c       	mov	r6, r1
    3668:	7a 82       	std	Y+2, r7	; 0x02
    366a:	5b 82       	std	Y+3, r5	; 0x03
    366c:	0f 2e       	mov	r0, r31
    366e:	f9 ef       	ldi	r31, 0xF9	; 249
    3670:	2f 2e       	mov	r2, r31
    3672:	f2 e0       	ldi	r31, 0x02	; 2
    3674:	3f 2e       	mov	r3, r31
    3676:	f0 2d       	mov	r31, r0
    3678:	1d 83       	std	Y+5, r17	; 0x05
    367a:	0c 83       	std	Y+4, r16	; 0x04
    367c:	59 82       	std	Y+1, r5	; 0x01
    367e:	f7 01       	movw	r30, r14
    3680:	2c 81       	ldd	r18, Y+4	; 0x04
    3682:	3d 81       	ldd	r19, Y+5	; 0x05
    3684:	af 01       	movw	r20, r30
    3686:	81 91       	ld	r24, Z+
    3688:	8f 32       	cpi	r24, 0x2F	; 47
    368a:	e1 f3       	breq	.-8      	; 0x3684 <follow_path+0x96>
    368c:	8c 35       	cpi	r24, 0x5C	; 92
    368e:	d1 f3       	breq	.-12     	; 0x3684 <follow_path+0x96>
    3690:	3d 83       	std	Y+5, r19	; 0x05
    3692:	2c 83       	std	Y+4, r18	; 0x04
    3694:	f9 01       	movw	r30, r18
    3696:	a4 89       	ldd	r26, Z+20	; 0x14
    3698:	b5 89       	ldd	r27, Z+21	; 0x15
    369a:	fd 01       	movw	r30, r26
    369c:	cd 01       	movw	r24, r26
    369e:	0b 96       	adiw	r24, 0x0b	; 11
    36a0:	b1 92       	st	Z+, r11
    36a2:	e8 17       	cp	r30, r24
    36a4:	f9 07       	cpc	r31, r25
    36a6:	e1 f7       	brne	.-8      	; 0x36a0 <follow_path+0xb2>
    36a8:	3d 83       	std	Y+5, r19	; 0x05
    36aa:	2c 83       	std	Y+4, r18	; 0x04
    36ac:	ca 2c       	mov	r12, r10
    36ae:	d8 2c       	mov	r13, r8
    36b0:	2a 2d       	mov	r18, r10
    36b2:	38 2d       	mov	r19, r8
    36b4:	47 2c       	mov	r4, r7
    36b6:	59 80       	ldd	r5, Y+1	; 0x01
    36b8:	96 2c       	mov	r9, r6
    36ba:	8a 01       	movw	r16, r20
    36bc:	8c 81       	ldd	r24, Y+4	; 0x04
    36be:	9d 81       	ldd	r25, Y+5	; 0x05
    36c0:	5d 83       	std	Y+5, r21	; 0x05
    36c2:	4c 83       	std	Y+4, r20	; 0x04
    36c4:	7c 01       	movw	r14, r24
    36c6:	2f 5f       	subi	r18, 0xFF	; 255
    36c8:	3f 4f       	sbci	r19, 0xFF	; 255
    36ca:	ec 81       	ldd	r30, Y+4	; 0x04
    36cc:	fd 81       	ldd	r31, Y+5	; 0x05
    36ce:	61 91       	ld	r22, Z+
    36d0:	fd 83       	std	Y+5, r31	; 0x05
    36d2:	ec 83       	std	Y+4, r30	; 0x04
    36d4:	61 32       	cpi	r22, 0x21	; 33
    36d6:	08 f4       	brcc	.+2      	; 0x36da <follow_path+0xec>
    36d8:	d5 c0       	rjmp	.+426    	; 0x3884 <follow_path+0x296>
    36da:	6f 32       	cpi	r22, 0x2F	; 47
    36dc:	09 f4       	brne	.+2      	; 0x36e0 <follow_path+0xf2>
    36de:	cb c0       	rjmp	.+406    	; 0x3876 <follow_path+0x288>
    36e0:	6c 35       	cpi	r22, 0x5C	; 92
    36e2:	09 f4       	brne	.+2      	; 0x36e6 <follow_path+0xf8>
    36e4:	c8 c0       	rjmp	.+400    	; 0x3876 <follow_path+0x288>
    36e6:	6e 32       	cpi	r22, 0x2E	; 46
    36e8:	09 f4       	brne	.+2      	; 0x36ec <follow_path+0xfe>
    36ea:	b2 c0       	rjmp	.+356    	; 0x3850 <follow_path+0x262>
    36ec:	c4 14       	cp	r12, r4
    36ee:	d5 04       	cpc	r13, r5
    36f0:	08 f0       	brcs	.+2      	; 0x36f4 <follow_path+0x106>
    36f2:	a2 c0       	rjmp	.+324    	; 0x3838 <follow_path+0x24a>
    36f4:	0a c0       	rjmp	.+20     	; 0x370a <follow_path+0x11c>
    36f6:	99 0c       	add	r9, r9
    36f8:	99 0c       	add	r9, r9
    36fa:	ca 80       	ldd	r12, Y+2	; 0x02
    36fc:	db 80       	ldd	r13, Y+3	; 0x03
    36fe:	0f 2e       	mov	r0, r31
    3700:	fb e0       	ldi	r31, 0x0B	; 11
    3702:	4f 2e       	mov	r4, r31
    3704:	f0 2d       	mov	r31, r0
    3706:	51 2c       	mov	r5, r1
    3708:	de cf       	rjmp	.-68     	; 0x36c6 <follow_path+0xd8>
    370a:	66 23       	and	r22, r22
    370c:	0c f0       	brlt	.+2      	; 0x3710 <follow_path+0x122>
    370e:	a6 c0       	rjmp	.+332    	; 0x385c <follow_path+0x26e>
    3710:	f9 2d       	mov	r31, r9
    3712:	f3 60       	ori	r31, 0x03	; 3
    3714:	9f 2e       	mov	r9, r31
    3716:	e6 2f       	mov	r30, r22
    3718:	f0 e0       	ldi	r31, 0x00	; 0
    371a:	e9 57       	subi	r30, 0x79	; 121
    371c:	fd 4f       	sbci	r31, 0xFD	; 253
    371e:	60 81       	ld	r22, Z
    3720:	9d c0       	rjmp	.+314    	; 0x385c <follow_path+0x26e>
    3722:	81 91       	ld	r24, Z+
    3724:	88 23       	and	r24, r24
    3726:	09 f4       	brne	.+2      	; 0x372a <follow_path+0x13c>
    3728:	a0 c0       	rjmp	.+320    	; 0x386a <follow_path+0x27c>
    372a:	90 e0       	ldi	r25, 0x00	; 0
    372c:	48 17       	cp	r20, r24
    372e:	59 07       	cpc	r21, r25
    3730:	c1 f7       	brne	.-16     	; 0x3722 <follow_path+0x134>
    3732:	86 e0       	ldi	r24, 0x06	; 6
    3734:	c1 c0       	rjmp	.+386    	; 0x38b8 <follow_path+0x2ca>
    3736:	89 2d       	mov	r24, r9
    3738:	82 60       	ori	r24, 0x02	; 2
    373a:	98 2e       	mov	r9, r24
    373c:	08 c0       	rjmp	.+16     	; 0x374e <follow_path+0x160>
    373e:	8f e9       	ldi	r24, 0x9F	; 159
    3740:	86 0f       	add	r24, r22
    3742:	8a 31       	cpi	r24, 0x1A	; 26
    3744:	20 f4       	brcc	.+8      	; 0x374e <follow_path+0x160>
    3746:	99 2d       	mov	r25, r9
    3748:	91 60       	ori	r25, 0x01	; 1
    374a:	99 2e       	mov	r9, r25
    374c:	60 52       	subi	r22, 0x20	; 32
    374e:	fd 01       	movw	r30, r26
    3750:	ec 0d       	add	r30, r12
    3752:	fd 1d       	adc	r31, r13
    3754:	60 83       	st	Z, r22
    3756:	f6 01       	movw	r30, r12
    3758:	31 96       	adiw	r30, 0x01	; 1
    375a:	6f 01       	movw	r12, r30
    375c:	b4 cf       	rjmp	.-152    	; 0x36c6 <follow_path+0xd8>
    375e:	cd 28       	or	r12, r13
    3760:	09 f4       	brne	.+2      	; 0x3764 <follow_path+0x176>
    3762:	6c c0       	rjmp	.+216    	; 0x383c <follow_path+0x24e>
    3764:	9c 91       	ld	r25, X
    3766:	95 3e       	cpi	r25, 0xE5	; 229
    3768:	11 f4       	brne	.+4      	; 0x376e <follow_path+0x180>
    376a:	f5 e0       	ldi	r31, 0x05	; 5
    376c:	fc 93       	st	X, r31
    376e:	98 e0       	ldi	r25, 0x08	; 8
    3770:	49 16       	cp	r4, r25
    3772:	51 04       	cpc	r5, r1
    3774:	11 f4       	brne	.+4      	; 0x377a <follow_path+0x18c>
    3776:	99 0c       	add	r9, r9
    3778:	99 0c       	add	r9, r9
    377a:	99 2d       	mov	r25, r9
    377c:	93 70       	andi	r25, 0x03	; 3
    377e:	91 30       	cpi	r25, 0x01	; 1
    3780:	09 f4       	brne	.+2      	; 0x3784 <follow_path+0x196>
    3782:	80 61       	ori	r24, 0x10	; 16
    3784:	99 2d       	mov	r25, r9
    3786:	9c 70       	andi	r25, 0x0C	; 12
    3788:	94 30       	cpi	r25, 0x04	; 4
    378a:	09 f4       	brne	.+2      	; 0x378e <follow_path+0x1a0>
    378c:	88 60       	ori	r24, 0x08	; 8
    378e:	1b 96       	adiw	r26, 0x0b	; 11
    3790:	8c 93       	st	X, r24
    3792:	6a 2d       	mov	r22, r10
    3794:	78 2d       	mov	r23, r8
    3796:	8c 81       	ldd	r24, Y+4	; 0x04
    3798:	9d 81       	ldd	r25, Y+5	; 0x05
    379a:	03 db       	rcall	.-2554   	; 0x2da2 <dir_sdi>
    379c:	81 11       	cpse	r24, r1
    379e:	81 c0       	rjmp	.+258    	; 0x38a2 <follow_path+0x2b4>
    37a0:	0c 81       	ldd	r16, Y+4	; 0x04
    37a2:	1d 81       	ldd	r17, Y+5	; 0x05
    37a4:	d8 01       	movw	r26, r16
    37a6:	1e 96       	adiw	r26, 0x0e	; 14
    37a8:	4d 91       	ld	r20, X+
    37aa:	5d 91       	ld	r21, X+
    37ac:	6d 91       	ld	r22, X+
    37ae:	7c 91       	ld	r23, X
    37b0:	51 97       	sbiw	r26, 0x11	; 17
    37b2:	8d 91       	ld	r24, X+
    37b4:	9c 91       	ld	r25, X
    37b6:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <move_window>
    37ba:	81 11       	cpse	r24, r1
    37bc:	74 c0       	rjmp	.+232    	; 0x38a6 <follow_path+0x2b8>
    37be:	f8 01       	movw	r30, r16
    37c0:	62 89       	ldd	r22, Z+18	; 0x12
    37c2:	73 89       	ldd	r23, Z+19	; 0x13
    37c4:	db 01       	movw	r26, r22
    37c6:	9c 91       	ld	r25, X
    37c8:	99 23       	and	r25, r25
    37ca:	e9 f0       	breq	.+58     	; 0x3806 <follow_path+0x218>
    37cc:	1b 96       	adiw	r26, 0x0b	; 11
    37ce:	9c 91       	ld	r25, X
    37d0:	93 fd       	sbrc	r25, 3
    37d2:	12 c0       	rjmp	.+36     	; 0x37f8 <follow_path+0x20a>
    37d4:	44 89       	ldd	r20, Z+20	; 0x14
    37d6:	55 89       	ldd	r21, Z+21	; 0x15
    37d8:	fb 01       	movw	r30, r22
    37da:	da 01       	movw	r26, r20
    37dc:	9b 01       	movw	r18, r22
    37de:	25 5f       	subi	r18, 0xF5	; 245
    37e0:	3f 4f       	sbci	r19, 0xFF	; 255
    37e2:	68 01       	movw	r12, r16
    37e4:	04 c0       	rjmp	.+8      	; 0x37ee <follow_path+0x200>
    37e6:	e2 17       	cp	r30, r18
    37e8:	f3 07       	cpc	r31, r19
    37ea:	09 f4       	brne	.+2      	; 0x37ee <follow_path+0x200>
    37ec:	52 c0       	rjmp	.+164    	; 0x3892 <follow_path+0x2a4>
    37ee:	11 91       	ld	r17, Z+
    37f0:	9d 91       	ld	r25, X+
    37f2:	19 17       	cp	r17, r25
    37f4:	c1 f3       	breq	.-16     	; 0x37e6 <follow_path+0x1f8>
    37f6:	86 01       	movw	r16, r12
    37f8:	6a 2d       	mov	r22, r10
    37fa:	78 2d       	mov	r23, r8
    37fc:	c8 01       	movw	r24, r16
    37fe:	bc dd       	rcall	.-1160   	; 0x3378 <dir_next>
    3800:	88 23       	and	r24, r24
    3802:	81 f2       	breq	.-96     	; 0x37a4 <follow_path+0x1b6>
    3804:	50 c0       	rjmp	.+160    	; 0x38a6 <follow_path+0x2b8>
    3806:	04 88       	ldd	r0, Z+20	; 0x14
    3808:	f5 89       	ldd	r31, Z+21	; 0x15
    380a:	e0 2d       	mov	r30, r0
    380c:	93 85       	ldd	r25, Z+11	; 0x0b
    380e:	92 fd       	sbrc	r25, 2
    3810:	17 c0       	rjmp	.+46     	; 0x3840 <follow_path+0x252>
    3812:	85 e0       	ldi	r24, 0x05	; 5
    3814:	51 c0       	rjmp	.+162    	; 0x38b8 <follow_path+0x2ca>
    3816:	fb 01       	movw	r30, r22
    3818:	83 85       	ldd	r24, Z+11	; 0x0b
    381a:	84 ff       	sbrs	r24, 4
    381c:	13 c0       	rjmp	.+38     	; 0x3844 <follow_path+0x256>
    381e:	ac 81       	ldd	r26, Y+4	; 0x04
    3820:	bd 81       	ldd	r27, Y+5	; 0x05
    3822:	8d 91       	ld	r24, X+
    3824:	9c 91       	ld	r25, X
    3826:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <ld_clust>
    382a:	ec 81       	ldd	r30, Y+4	; 0x04
    382c:	fd 81       	ldd	r31, Y+5	; 0x05
    382e:	66 83       	std	Z+6, r22	; 0x06
    3830:	77 83       	std	Z+7, r23	; 0x07
    3832:	80 87       	std	Z+8, r24	; 0x08
    3834:	91 87       	std	Z+9, r25	; 0x09
    3836:	23 cf       	rjmp	.-442    	; 0x367e <follow_path+0x90>
    3838:	86 e0       	ldi	r24, 0x06	; 6
    383a:	3e c0       	rjmp	.+124    	; 0x38b8 <follow_path+0x2ca>
    383c:	86 e0       	ldi	r24, 0x06	; 6
    383e:	3c c0       	rjmp	.+120    	; 0x38b8 <follow_path+0x2ca>
    3840:	84 e0       	ldi	r24, 0x04	; 4
    3842:	3a c0       	rjmp	.+116    	; 0x38b8 <follow_path+0x2ca>
    3844:	85 e0       	ldi	r24, 0x05	; 5
    3846:	38 c0       	rjmp	.+112    	; 0x38b8 <follow_path+0x2ca>
    3848:	86 e0       	ldi	r24, 0x06	; 6
    384a:	36 c0       	rjmp	.+108    	; 0x38b8 <follow_path+0x2ca>
    384c:	86 e0       	ldi	r24, 0x06	; 6
    384e:	34 c0       	rjmp	.+104    	; 0x38b8 <follow_path+0x2ca>
    3850:	f8 e0       	ldi	r31, 0x08	; 8
    3852:	4f 16       	cp	r4, r31
    3854:	51 04       	cpc	r5, r1
    3856:	09 f4       	brne	.+2      	; 0x385a <follow_path+0x26c>
    3858:	4e cf       	rjmp	.-356    	; 0x36f6 <follow_path+0x108>
    385a:	f6 cf       	rjmp	.-20     	; 0x3848 <follow_path+0x25a>
    385c:	46 2f       	mov	r20, r22
    385e:	50 e0       	ldi	r21, 0x00	; 0
    3860:	42 32       	cpi	r20, 0x22	; 34
    3862:	51 05       	cpc	r21, r1
    3864:	99 f3       	breq	.-26     	; 0x384c <follow_path+0x25e>
    3866:	f1 01       	movw	r30, r2
    3868:	5c cf       	rjmp	.-328    	; 0x3722 <follow_path+0x134>
    386a:	8f eb       	ldi	r24, 0xBF	; 191
    386c:	86 0f       	add	r24, r22
    386e:	8a 31       	cpi	r24, 0x1A	; 26
    3870:	08 f4       	brcc	.+2      	; 0x3874 <follow_path+0x286>
    3872:	61 cf       	rjmp	.-318    	; 0x3736 <follow_path+0x148>
    3874:	64 cf       	rjmp	.-312    	; 0x373e <follow_path+0x150>
    3876:	fd 82       	std	Y+5, r15	; 0x05
    3878:	ec 82       	std	Y+4, r14	; 0x04
    387a:	78 01       	movw	r14, r16
    387c:	e2 0e       	add	r14, r18
    387e:	f3 1e       	adc	r15, r19
    3880:	86 2d       	mov	r24, r6
    3882:	6d cf       	rjmp	.-294    	; 0x375e <follow_path+0x170>
    3884:	fd 82       	std	Y+5, r15	; 0x05
    3886:	ec 82       	std	Y+4, r14	; 0x04
    3888:	78 01       	movw	r14, r16
    388a:	e2 0e       	add	r14, r18
    388c:	f3 1e       	adc	r15, r19
    388e:	84 e0       	ldi	r24, 0x04	; 4
    3890:	66 cf       	rjmp	.-308    	; 0x375e <follow_path+0x170>
    3892:	dd 82       	std	Y+5, r13	; 0x05
    3894:	cc 82       	std	Y+4, r12	; 0x04
    3896:	da 01       	movw	r26, r20
    3898:	1b 96       	adiw	r26, 0x0b	; 11
    389a:	9c 91       	ld	r25, X
    389c:	92 ff       	sbrs	r25, 2
    389e:	bb cf       	rjmp	.-138    	; 0x3816 <follow_path+0x228>
    38a0:	0b c0       	rjmp	.+22     	; 0x38b8 <follow_path+0x2ca>
    38a2:	0c 81       	ldd	r16, Y+4	; 0x04
    38a4:	1d 81       	ldd	r17, Y+5	; 0x05
    38a6:	d8 01       	movw	r26, r16
    38a8:	54 96       	adiw	r26, 0x14	; 20
    38aa:	ed 91       	ld	r30, X+
    38ac:	fc 91       	ld	r31, X
    38ae:	55 97       	sbiw	r26, 0x15	; 21
    38b0:	93 85       	ldd	r25, Z+11	; 0x0b
    38b2:	84 30       	cpi	r24, 0x04	; 4
    38b4:	09 f4       	brne	.+2      	; 0x38b8 <follow_path+0x2ca>
    38b6:	ab cf       	rjmp	.-170    	; 0x380e <follow_path+0x220>
    38b8:	0f 90       	pop	r0
    38ba:	0f 90       	pop	r0
    38bc:	0f 90       	pop	r0
    38be:	0f 90       	pop	r0
    38c0:	0f 90       	pop	r0
    38c2:	df 91       	pop	r29
    38c4:	cf 91       	pop	r28
    38c6:	1f 91       	pop	r17
    38c8:	0f 91       	pop	r16
    38ca:	ff 90       	pop	r15
    38cc:	ef 90       	pop	r14
    38ce:	df 90       	pop	r13
    38d0:	cf 90       	pop	r12
    38d2:	bf 90       	pop	r11
    38d4:	af 90       	pop	r10
    38d6:	9f 90       	pop	r9
    38d8:	8f 90       	pop	r8
    38da:	7f 90       	pop	r7
    38dc:	6f 90       	pop	r6
    38de:	5f 90       	pop	r5
    38e0:	4f 90       	pop	r4
    38e2:	3f 90       	pop	r3
    38e4:	2f 90       	pop	r2
    38e6:	08 95       	ret

000038e8 <dir_register>:
    38e8:	0f 93       	push	r16
    38ea:	1f 93       	push	r17
    38ec:	cf 93       	push	r28
    38ee:	8c 01       	movw	r16, r24
    38f0:	60 e0       	ldi	r22, 0x00	; 0
    38f2:	70 e0       	ldi	r23, 0x00	; 0
    38f4:	56 da       	rcall	.-2900   	; 0x2da2 <dir_sdi>
    38f6:	c8 2f       	mov	r28, r24
    38f8:	81 11       	cpse	r24, r1
    38fa:	46 c0       	rjmp	.+140    	; 0x3988 <dir_register+0xa0>
    38fc:	d8 01       	movw	r26, r16
    38fe:	1e 96       	adiw	r26, 0x0e	; 14
    3900:	4d 91       	ld	r20, X+
    3902:	5d 91       	ld	r21, X+
    3904:	6d 91       	ld	r22, X+
    3906:	7c 91       	ld	r23, X
    3908:	51 97       	sbiw	r26, 0x11	; 17
    390a:	8d 91       	ld	r24, X+
    390c:	9c 91       	ld	r25, X
    390e:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <move_window>
    3912:	c8 2f       	mov	r28, r24
    3914:	81 11       	cpse	r24, r1
    3916:	38 c0       	rjmp	.+112    	; 0x3988 <dir_register+0xa0>
    3918:	d8 01       	movw	r26, r16
    391a:	52 96       	adiw	r26, 0x12	; 18
    391c:	ed 91       	ld	r30, X+
    391e:	fc 91       	ld	r31, X
    3920:	53 97       	sbiw	r26, 0x13	; 19
    3922:	80 81       	ld	r24, Z
    3924:	85 3e       	cpi	r24, 0xE5	; 229
    3926:	51 f0       	breq	.+20     	; 0x393c <dir_register+0x54>
    3928:	88 23       	and	r24, r24
    392a:	41 f0       	breq	.+16     	; 0x393c <dir_register+0x54>
    392c:	61 e0       	ldi	r22, 0x01	; 1
    392e:	70 e0       	ldi	r23, 0x00	; 0
    3930:	c8 01       	movw	r24, r16
    3932:	22 dd       	rcall	.-1468   	; 0x3378 <dir_next>
    3934:	c8 2f       	mov	r28, r24
    3936:	88 23       	and	r24, r24
    3938:	09 f3       	breq	.-62     	; 0x38fc <dir_register+0x14>
    393a:	26 c0       	rjmp	.+76     	; 0x3988 <dir_register+0xa0>
    393c:	f8 01       	movw	r30, r16
    393e:	46 85       	ldd	r20, Z+14	; 0x0e
    3940:	57 85       	ldd	r21, Z+15	; 0x0f
    3942:	60 89       	ldd	r22, Z+16	; 0x10
    3944:	71 89       	ldd	r23, Z+17	; 0x11
    3946:	80 81       	ld	r24, Z
    3948:	91 81       	ldd	r25, Z+1	; 0x01
    394a:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <move_window>
    394e:	c8 2f       	mov	r28, r24
    3950:	81 11       	cpse	r24, r1
    3952:	1d c0       	rjmp	.+58     	; 0x398e <dir_register+0xa6>
    3954:	d8 01       	movw	r26, r16
    3956:	52 96       	adiw	r26, 0x12	; 18
    3958:	ed 91       	ld	r30, X+
    395a:	fc 91       	ld	r31, X
    395c:	53 97       	sbiw	r26, 0x13	; 19
    395e:	cf 01       	movw	r24, r30
    3960:	80 96       	adiw	r24, 0x20	; 32
    3962:	11 92       	st	Z+, r1
    3964:	e8 17       	cp	r30, r24
    3966:	f9 07       	cpc	r31, r25
    3968:	e1 f7       	brne	.-8      	; 0x3962 <dir_register+0x7a>
    396a:	f8 01       	movw	r30, r16
    396c:	64 89       	ldd	r22, Z+20	; 0x14
    396e:	75 89       	ldd	r23, Z+21	; 0x15
    3970:	4b e0       	ldi	r20, 0x0B	; 11
    3972:	50 e0       	ldi	r21, 0x00	; 0
    3974:	82 89       	ldd	r24, Z+18	; 0x12
    3976:	93 89       	ldd	r25, Z+19	; 0x13
    3978:	0e 94 a6 10 	call	0x214c	; 0x214c <mem_cpy>
    397c:	d8 01       	movw	r26, r16
    397e:	ed 91       	ld	r30, X+
    3980:	fc 91       	ld	r31, X
    3982:	81 e0       	ldi	r24, 0x01	; 1
    3984:	84 83       	std	Z+4, r24	; 0x04
    3986:	03 c0       	rjmp	.+6      	; 0x398e <dir_register+0xa6>
    3988:	c4 30       	cpi	r28, 0x04	; 4
    398a:	09 f4       	brne	.+2      	; 0x398e <dir_register+0xa6>
    398c:	c7 e0       	ldi	r28, 0x07	; 7
    398e:	8c 2f       	mov	r24, r28
    3990:	cf 91       	pop	r28
    3992:	1f 91       	pop	r17
    3994:	0f 91       	pop	r16
    3996:	08 95       	ret

00003998 <remove_chain>:
    3998:	8f 92       	push	r8
    399a:	9f 92       	push	r9
    399c:	af 92       	push	r10
    399e:	bf 92       	push	r11
    39a0:	cf 92       	push	r12
    39a2:	df 92       	push	r13
    39a4:	ef 92       	push	r14
    39a6:	ff 92       	push	r15
    39a8:	0f 93       	push	r16
    39aa:	1f 93       	push	r17
    39ac:	cf 93       	push	r28
    39ae:	df 93       	push	r29
    39b0:	ec 01       	movw	r28, r24
    39b2:	6a 01       	movw	r12, r20
    39b4:	7b 01       	movw	r14, r22
    39b6:	42 30       	cpi	r20, 0x02	; 2
    39b8:	51 05       	cpc	r21, r1
    39ba:	61 05       	cpc	r22, r1
    39bc:	71 05       	cpc	r23, r1
    39be:	08 f4       	brcc	.+2      	; 0x39c2 <remove_chain+0x2a>
    39c0:	4c c0       	rjmp	.+152    	; 0x3a5a <remove_chain+0xc2>
    39c2:	8a 89       	ldd	r24, Y+18	; 0x12
    39c4:	9b 89       	ldd	r25, Y+19	; 0x13
    39c6:	ac 89       	ldd	r26, Y+20	; 0x14
    39c8:	bd 89       	ldd	r27, Y+21	; 0x15
    39ca:	48 17       	cp	r20, r24
    39cc:	59 07       	cpc	r21, r25
    39ce:	6a 07       	cpc	r22, r26
    39d0:	7b 07       	cpc	r23, r27
    39d2:	08 f0       	brcs	.+2      	; 0x39d6 <remove_chain+0x3e>
    39d4:	44 c0       	rjmp	.+136    	; 0x3a5e <remove_chain+0xc6>
    39d6:	35 c0       	rjmp	.+106    	; 0x3a42 <remove_chain+0xaa>
    39d8:	b7 01       	movw	r22, r14
    39da:	a6 01       	movw	r20, r12
    39dc:	ce 01       	movw	r24, r28
    39de:	fe d8       	rcall	.-3588   	; 0x2bdc <get_fat>
    39e0:	4b 01       	movw	r8, r22
    39e2:	5c 01       	movw	r10, r24
    39e4:	67 2b       	or	r22, r23
    39e6:	68 2b       	or	r22, r24
    39e8:	69 2b       	or	r22, r25
    39ea:	d9 f1       	breq	.+118    	; 0x3a62 <remove_chain+0xca>
    39ec:	81 e0       	ldi	r24, 0x01	; 1
    39ee:	88 16       	cp	r8, r24
    39f0:	91 04       	cpc	r9, r1
    39f2:	a1 04       	cpc	r10, r1
    39f4:	b1 04       	cpc	r11, r1
    39f6:	b9 f1       	breq	.+110    	; 0x3a66 <remove_chain+0xce>
    39f8:	2f ef       	ldi	r18, 0xFF	; 255
    39fa:	82 16       	cp	r8, r18
    39fc:	92 06       	cpc	r9, r18
    39fe:	a2 06       	cpc	r10, r18
    3a00:	b2 06       	cpc	r11, r18
    3a02:	99 f1       	breq	.+102    	; 0x3a6a <remove_chain+0xd2>
    3a04:	00 e0       	ldi	r16, 0x00	; 0
    3a06:	10 e0       	ldi	r17, 0x00	; 0
    3a08:	98 01       	movw	r18, r16
    3a0a:	b7 01       	movw	r22, r14
    3a0c:	a6 01       	movw	r20, r12
    3a0e:	ce 01       	movw	r24, r28
    3a10:	83 da       	rcall	.-2810   	; 0x2f18 <put_fat>
    3a12:	81 11       	cpse	r24, r1
    3a14:	2b c0       	rjmp	.+86     	; 0x3a6c <remove_chain+0xd4>
    3a16:	8e 85       	ldd	r24, Y+14	; 0x0e
    3a18:	9f 85       	ldd	r25, Y+15	; 0x0f
    3a1a:	a8 89       	ldd	r26, Y+16	; 0x10
    3a1c:	b9 89       	ldd	r27, Y+17	; 0x11
    3a1e:	8f 3f       	cpi	r24, 0xFF	; 255
    3a20:	2f ef       	ldi	r18, 0xFF	; 255
    3a22:	92 07       	cpc	r25, r18
    3a24:	a2 07       	cpc	r26, r18
    3a26:	b2 07       	cpc	r27, r18
    3a28:	51 f0       	breq	.+20     	; 0x3a3e <remove_chain+0xa6>
    3a2a:	01 96       	adiw	r24, 0x01	; 1
    3a2c:	a1 1d       	adc	r26, r1
    3a2e:	b1 1d       	adc	r27, r1
    3a30:	8e 87       	std	Y+14, r24	; 0x0e
    3a32:	9f 87       	std	Y+15, r25	; 0x0f
    3a34:	a8 8b       	std	Y+16, r26	; 0x10
    3a36:	b9 8b       	std	Y+17, r27	; 0x11
    3a38:	8d 81       	ldd	r24, Y+5	; 0x05
    3a3a:	81 60       	ori	r24, 0x01	; 1
    3a3c:	8d 83       	std	Y+5, r24	; 0x05
    3a3e:	75 01       	movw	r14, r10
    3a40:	64 01       	movw	r12, r8
    3a42:	8a 89       	ldd	r24, Y+18	; 0x12
    3a44:	9b 89       	ldd	r25, Y+19	; 0x13
    3a46:	ac 89       	ldd	r26, Y+20	; 0x14
    3a48:	bd 89       	ldd	r27, Y+21	; 0x15
    3a4a:	c8 16       	cp	r12, r24
    3a4c:	d9 06       	cpc	r13, r25
    3a4e:	ea 06       	cpc	r14, r26
    3a50:	fb 06       	cpc	r15, r27
    3a52:	08 f4       	brcc	.+2      	; 0x3a56 <remove_chain+0xbe>
    3a54:	c1 cf       	rjmp	.-126    	; 0x39d8 <remove_chain+0x40>
    3a56:	80 e0       	ldi	r24, 0x00	; 0
    3a58:	09 c0       	rjmp	.+18     	; 0x3a6c <remove_chain+0xd4>
    3a5a:	82 e0       	ldi	r24, 0x02	; 2
    3a5c:	07 c0       	rjmp	.+14     	; 0x3a6c <remove_chain+0xd4>
    3a5e:	82 e0       	ldi	r24, 0x02	; 2
    3a60:	05 c0       	rjmp	.+10     	; 0x3a6c <remove_chain+0xd4>
    3a62:	80 e0       	ldi	r24, 0x00	; 0
    3a64:	03 c0       	rjmp	.+6      	; 0x3a6c <remove_chain+0xd4>
    3a66:	82 e0       	ldi	r24, 0x02	; 2
    3a68:	01 c0       	rjmp	.+2      	; 0x3a6c <remove_chain+0xd4>
    3a6a:	81 e0       	ldi	r24, 0x01	; 1
    3a6c:	df 91       	pop	r29
    3a6e:	cf 91       	pop	r28
    3a70:	1f 91       	pop	r17
    3a72:	0f 91       	pop	r16
    3a74:	ff 90       	pop	r15
    3a76:	ef 90       	pop	r14
    3a78:	df 90       	pop	r13
    3a7a:	cf 90       	pop	r12
    3a7c:	bf 90       	pop	r11
    3a7e:	af 90       	pop	r10
    3a80:	9f 90       	pop	r9
    3a82:	8f 90       	pop	r8
    3a84:	08 95       	ret

00003a86 <f_mount>:
    3a86:	1f 93       	push	r17
    3a88:	cf 93       	push	r28
    3a8a:	df 93       	push	r29
    3a8c:	00 d0       	rcall	.+0      	; 0x3a8e <f_mount+0x8>
    3a8e:	00 d0       	rcall	.+0      	; 0x3a90 <f_mount+0xa>
    3a90:	00 d0       	rcall	.+0      	; 0x3a92 <f_mount+0xc>
    3a92:	cd b7       	in	r28, 0x3d	; 61
    3a94:	de b7       	in	r29, 0x3e	; 62
    3a96:	9c 83       	std	Y+4, r25	; 0x04
    3a98:	8b 83       	std	Y+3, r24	; 0x03
    3a9a:	7e 83       	std	Y+6, r23	; 0x06
    3a9c:	6d 83       	std	Y+5, r22	; 0x05
    3a9e:	14 2f       	mov	r17, r20
    3aa0:	7a 83       	std	Y+2, r23	; 0x02
    3aa2:	69 83       	std	Y+1, r22	; 0x01
    3aa4:	ce 01       	movw	r24, r28
    3aa6:	01 96       	adiw	r24, 0x01	; 1
    3aa8:	0e 94 38 11 	call	0x2270	; 0x2270 <get_ldnumber>
    3aac:	99 23       	and	r25, r25
    3aae:	34 f1       	brlt	.+76     	; 0x3afc <f_mount+0x76>
    3ab0:	fc 01       	movw	r30, r24
    3ab2:	ee 0f       	add	r30, r30
    3ab4:	ff 1f       	adc	r31, r31
    3ab6:	e8 5f       	subi	r30, 0xF8	; 248
    3ab8:	f9 4f       	sbci	r31, 0xF9	; 249
    3aba:	01 90       	ld	r0, Z+
    3abc:	f0 81       	ld	r31, Z
    3abe:	e0 2d       	mov	r30, r0
    3ac0:	30 97       	sbiw	r30, 0x00	; 0
    3ac2:	09 f0       	breq	.+2      	; 0x3ac6 <f_mount+0x40>
    3ac4:	10 82       	st	Z, r1
    3ac6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ac8:	fc 81       	ldd	r31, Y+4	; 0x04
    3aca:	30 97       	sbiw	r30, 0x00	; 0
    3acc:	e9 f0       	breq	.+58     	; 0x3b08 <f_mount+0x82>
    3ace:	10 82       	st	Z, r1
    3ad0:	2b 81       	ldd	r18, Y+3	; 0x03
    3ad2:	3c 81       	ldd	r19, Y+4	; 0x04
    3ad4:	88 0f       	add	r24, r24
    3ad6:	99 1f       	adc	r25, r25
    3ad8:	fc 01       	movw	r30, r24
    3ada:	e8 5f       	subi	r30, 0xF8	; 248
    3adc:	f9 4f       	sbci	r31, 0xF9	; 249
    3ade:	31 83       	std	Z+1, r19	; 0x01
    3ae0:	20 83       	st	Z, r18
    3ae2:	23 2b       	or	r18, r19
    3ae4:	69 f0       	breq	.+26     	; 0x3b00 <f_mount+0x7a>
    3ae6:	11 30       	cpi	r17, 0x01	; 1
    3ae8:	69 f4       	brne	.+26     	; 0x3b04 <f_mount+0x7e>
    3aea:	40 e0       	ldi	r20, 0x00	; 0
    3aec:	be 01       	movw	r22, r28
    3aee:	6b 5f       	subi	r22, 0xFB	; 251
    3af0:	7f 4f       	sbci	r23, 0xFF	; 255
    3af2:	ce 01       	movw	r24, r28
    3af4:	03 96       	adiw	r24, 0x03	; 3
    3af6:	0e 94 72 12 	call	0x24e4	; 0x24e4 <find_volume>
    3afa:	0e c0       	rjmp	.+28     	; 0x3b18 <f_mount+0x92>
    3afc:	8b e0       	ldi	r24, 0x0B	; 11
    3afe:	0c c0       	rjmp	.+24     	; 0x3b18 <f_mount+0x92>
    3b00:	80 e0       	ldi	r24, 0x00	; 0
    3b02:	0a c0       	rjmp	.+20     	; 0x3b18 <f_mount+0x92>
    3b04:	80 e0       	ldi	r24, 0x00	; 0
    3b06:	08 c0       	rjmp	.+16     	; 0x3b18 <f_mount+0x92>
    3b08:	88 0f       	add	r24, r24
    3b0a:	99 1f       	adc	r25, r25
    3b0c:	fc 01       	movw	r30, r24
    3b0e:	e8 5f       	subi	r30, 0xF8	; 248
    3b10:	f9 4f       	sbci	r31, 0xF9	; 249
    3b12:	11 82       	std	Z+1, r1	; 0x01
    3b14:	10 82       	st	Z, r1
    3b16:	80 e0       	ldi	r24, 0x00	; 0
    3b18:	26 96       	adiw	r28, 0x06	; 6
    3b1a:	0f b6       	in	r0, 0x3f	; 63
    3b1c:	f8 94       	cli
    3b1e:	de bf       	out	0x3e, r29	; 62
    3b20:	0f be       	out	0x3f, r0	; 63
    3b22:	cd bf       	out	0x3d, r28	; 61
    3b24:	df 91       	pop	r29
    3b26:	cf 91       	pop	r28
    3b28:	1f 91       	pop	r17
    3b2a:	08 95       	ret

00003b2c <f_open>:
    3b2c:	3f 92       	push	r3
    3b2e:	4f 92       	push	r4
    3b30:	5f 92       	push	r5
    3b32:	6f 92       	push	r6
    3b34:	7f 92       	push	r7
    3b36:	8f 92       	push	r8
    3b38:	9f 92       	push	r9
    3b3a:	af 92       	push	r10
    3b3c:	bf 92       	push	r11
    3b3e:	cf 92       	push	r12
    3b40:	df 92       	push	r13
    3b42:	ef 92       	push	r14
    3b44:	ff 92       	push	r15
    3b46:	0f 93       	push	r16
    3b48:	1f 93       	push	r17
    3b4a:	cf 93       	push	r28
    3b4c:	df 93       	push	r29
    3b4e:	cd b7       	in	r28, 0x3d	; 61
    3b50:	de b7       	in	r29, 0x3e	; 62
    3b52:	a4 97       	sbiw	r28, 0x24	; 36
    3b54:	0f b6       	in	r0, 0x3f	; 63
    3b56:	f8 94       	cli
    3b58:	de bf       	out	0x3e, r29	; 62
    3b5a:	0f be       	out	0x3f, r0	; 63
    3b5c:	cd bf       	out	0x3d, r28	; 61
    3b5e:	7c a3       	std	Y+36, r23	; 0x24
    3b60:	6b a3       	std	Y+35, r22	; 0x23
    3b62:	00 97       	sbiw	r24, 0x00	; 0
    3b64:	09 f4       	brne	.+2      	; 0x3b68 <f_open+0x3c>
    3b66:	ba c0       	rjmp	.+372    	; 0x3cdc <f_open+0x1b0>
    3b68:	d4 2e       	mov	r13, r20
    3b6a:	8c 01       	movw	r16, r24
    3b6c:	fc 01       	movw	r30, r24
    3b6e:	11 82       	std	Z+1, r1	; 0x01
    3b70:	10 82       	st	Z, r1
    3b72:	4e 71       	andi	r20, 0x1E	; 30
    3b74:	be 01       	movw	r22, r28
    3b76:	6d 5d       	subi	r22, 0xDD	; 221
    3b78:	7f 4f       	sbci	r23, 0xFF	; 255
    3b7a:	ce 01       	movw	r24, r28
    3b7c:	01 96       	adiw	r24, 0x01	; 1
    3b7e:	0e 94 72 12 	call	0x24e4	; 0x24e4 <find_volume>
    3b82:	81 11       	cpse	r24, r1
    3b84:	d5 c0       	rjmp	.+426    	; 0x3d30 <f_open+0x204>
    3b86:	fd 2d       	mov	r31, r13
    3b88:	ff 71       	andi	r31, 0x1F	; 31
    3b8a:	3f 2e       	mov	r3, r31
    3b8c:	ce 01       	movw	r24, r28
    3b8e:	47 96       	adiw	r24, 0x17	; 23
    3b90:	9e 8b       	std	Y+22, r25	; 0x16
    3b92:	8d 8b       	std	Y+21, r24	; 0x15
    3b94:	6b a1       	ldd	r22, Y+35	; 0x23
    3b96:	7c a1       	ldd	r23, Y+36	; 0x24
    3b98:	46 97       	sbiw	r24, 0x16	; 22
    3b9a:	29 dd       	rcall	.-1454   	; 0x35ee <follow_path>
    3b9c:	eb 88       	ldd	r14, Y+19	; 0x13
    3b9e:	fc 88       	ldd	r15, Y+20	; 0x14
    3ba0:	81 11       	cpse	r24, r1
    3ba2:	9e c0       	rjmp	.+316    	; 0x3ce0 <f_open+0x1b4>
    3ba4:	e1 14       	cp	r14, r1
    3ba6:	f1 04       	cpc	r15, r1
    3ba8:	09 f0       	breq	.+2      	; 0x3bac <f_open+0x80>
    3baa:	a4 c0       	rjmp	.+328    	; 0x3cf4 <f_open+0x1c8>
    3bac:	9e c0       	rjmp	.+316    	; 0x3cea <f_open+0x1be>
    3bae:	84 30       	cpi	r24, 0x04	; 4
    3bb0:	09 f0       	breq	.+2      	; 0x3bb4 <f_open+0x88>
    3bb2:	b0 c0       	rjmp	.+352    	; 0x3d14 <f_open+0x1e8>
    3bb4:	ce 01       	movw	r24, r28
    3bb6:	01 96       	adiw	r24, 0x01	; 1
    3bb8:	97 de       	rcall	.-722    	; 0x38e8 <dir_register>
    3bba:	23 2d       	mov	r18, r3
    3bbc:	28 60       	ori	r18, 0x08	; 8
    3bbe:	32 2e       	mov	r3, r18
    3bc0:	eb 88       	ldd	r14, Y+19	; 0x13
    3bc2:	fc 88       	ldd	r15, Y+20	; 0x14
    3bc4:	88 23       	and	r24, r24
    3bc6:	41 f0       	breq	.+16     	; 0x3bd8 <f_open+0xac>
    3bc8:	9d c0       	rjmp	.+314    	; 0x3d04 <f_open+0x1d8>
    3bca:	f7 01       	movw	r30, r14
    3bcc:	83 85       	ldd	r24, Z+11	; 0x0b
    3bce:	81 71       	andi	r24, 0x11	; 17
    3bd0:	09 f0       	breq	.+2      	; 0x3bd4 <f_open+0xa8>
    3bd2:	ab c0       	rjmp	.+342    	; 0x3d2a <f_open+0x1fe>
    3bd4:	d2 fc       	sbrc	r13, 2
    3bd6:	ab c0       	rjmp	.+342    	; 0x3d2e <f_open+0x202>
    3bd8:	33 fe       	sbrs	r3, 3
    3bda:	98 c0       	rjmp	.+304    	; 0x3d0c <f_open+0x1e0>
    3bdc:	80 e0       	ldi	r24, 0x00	; 0
    3bde:	90 e0       	ldi	r25, 0x00	; 0
    3be0:	a9 e6       	ldi	r26, 0x69	; 105
    3be2:	b5 e4       	ldi	r27, 0x45	; 69
    3be4:	f7 01       	movw	r30, r14
    3be6:	86 87       	std	Z+14, r24	; 0x0e
    3be8:	97 87       	std	Z+15, r25	; 0x0f
    3bea:	a0 8b       	std	Z+16, r26	; 0x10
    3bec:	b1 8b       	std	Z+17, r27	; 0x11
    3bee:	13 86       	std	Z+11, r1	; 0x0b
    3bf0:	14 8e       	std	Z+28, r1	; 0x1c
    3bf2:	15 8e       	std	Z+29, r1	; 0x1d
    3bf4:	16 8e       	std	Z+30, r1	; 0x1e
    3bf6:	17 8e       	std	Z+31, r1	; 0x1f
    3bf8:	c9 80       	ldd	r12, Y+1	; 0x01
    3bfa:	da 80       	ldd	r13, Y+2	; 0x02
    3bfc:	b7 01       	movw	r22, r14
    3bfe:	c6 01       	movw	r24, r12
    3c00:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <ld_clust>
    3c04:	2b 01       	movw	r4, r22
    3c06:	3c 01       	movw	r6, r24
    3c08:	f7 01       	movw	r30, r14
    3c0a:	13 8e       	std	Z+27, r1	; 0x1b
    3c0c:	12 8e       	std	Z+26, r1	; 0x1a
    3c0e:	15 8a       	std	Z+21, r1	; 0x15
    3c10:	14 8a       	std	Z+20, r1	; 0x14
    3c12:	81 e0       	ldi	r24, 0x01	; 1
    3c14:	f6 01       	movw	r30, r12
    3c16:	84 83       	std	Z+4, r24	; 0x04
    3c18:	41 14       	cp	r4, r1
    3c1a:	51 04       	cpc	r5, r1
    3c1c:	61 04       	cpc	r6, r1
    3c1e:	71 04       	cpc	r7, r1
    3c20:	09 f4       	brne	.+2      	; 0x3c24 <f_open+0xf8>
    3c22:	74 c0       	rjmp	.+232    	; 0x3d0c <f_open+0x1e0>
    3c24:	82 a4       	ldd	r8, Z+42	; 0x2a
    3c26:	93 a4       	ldd	r9, Z+43	; 0x2b
    3c28:	a4 a4       	ldd	r10, Z+44	; 0x2c
    3c2a:	b5 a4       	ldd	r11, Z+45	; 0x2d
    3c2c:	b3 01       	movw	r22, r6
    3c2e:	a2 01       	movw	r20, r4
    3c30:	c6 01       	movw	r24, r12
    3c32:	b2 de       	rcall	.-668    	; 0x3998 <remove_chain>
    3c34:	81 11       	cpse	r24, r1
    3c36:	66 c0       	rjmp	.+204    	; 0x3d04 <f_open+0x1d8>
    3c38:	89 81       	ldd	r24, Y+1	; 0x01
    3c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c3c:	f1 e0       	ldi	r31, 0x01	; 1
    3c3e:	4f 1a       	sub	r4, r31
    3c40:	51 08       	sbc	r5, r1
    3c42:	61 08       	sbc	r6, r1
    3c44:	71 08       	sbc	r7, r1
    3c46:	fc 01       	movw	r30, r24
    3c48:	42 86       	std	Z+10, r4	; 0x0a
    3c4a:	53 86       	std	Z+11, r5	; 0x0b
    3c4c:	64 86       	std	Z+12, r6	; 0x0c
    3c4e:	75 86       	std	Z+13, r7	; 0x0d
    3c50:	b5 01       	movw	r22, r10
    3c52:	a4 01       	movw	r20, r8
    3c54:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <move_window>
    3c58:	88 23       	and	r24, r24
    3c5a:	31 f0       	breq	.+12     	; 0x3c68 <f_open+0x13c>
    3c5c:	69 c0       	rjmp	.+210    	; 0x3d30 <f_open+0x204>
    3c5e:	d1 fe       	sbrs	r13, 1
    3c60:	55 c0       	rjmp	.+170    	; 0x3d0c <f_open+0x1e0>
    3c62:	80 fd       	sbrc	r24, 0
    3c64:	4c c0       	rjmp	.+152    	; 0x3cfe <f_open+0x1d2>
    3c66:	52 c0       	rjmp	.+164    	; 0x3d0c <f_open+0x1e0>
    3c68:	f3 2d       	mov	r31, r3
    3c6a:	f0 62       	ori	r31, 0x20	; 32
    3c6c:	3f 2e       	mov	r3, r31
    3c6e:	e9 81       	ldd	r30, Y+1	; 0x01
    3c70:	fa 81       	ldd	r31, Y+2	; 0x02
    3c72:	82 a5       	ldd	r24, Z+42	; 0x2a
    3c74:	93 a5       	ldd	r25, Z+43	; 0x2b
    3c76:	a4 a5       	ldd	r26, Z+44	; 0x2c
    3c78:	b5 a5       	ldd	r27, Z+45	; 0x2d
    3c7a:	f8 01       	movw	r30, r16
    3c7c:	82 8f       	std	Z+26, r24	; 0x1a
    3c7e:	93 8f       	std	Z+27, r25	; 0x1b
    3c80:	a4 8f       	std	Z+28, r26	; 0x1c
    3c82:	b5 8f       	std	Z+29, r27	; 0x1d
    3c84:	f7 8e       	std	Z+31, r15	; 0x1f
    3c86:	e6 8e       	std	Z+30, r14	; 0x1e
    3c88:	f8 01       	movw	r30, r16
    3c8a:	34 82       	std	Z+4, r3	; 0x04
    3c8c:	15 82       	std	Z+5, r1	; 0x05
    3c8e:	c9 80       	ldd	r12, Y+1	; 0x01
    3c90:	da 80       	ldd	r13, Y+2	; 0x02
    3c92:	b7 01       	movw	r22, r14
    3c94:	c6 01       	movw	r24, r12
    3c96:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <ld_clust>
    3c9a:	f8 01       	movw	r30, r16
    3c9c:	66 87       	std	Z+14, r22	; 0x0e
    3c9e:	77 87       	std	Z+15, r23	; 0x0f
    3ca0:	80 8b       	std	Z+16, r24	; 0x10
    3ca2:	91 8b       	std	Z+17, r25	; 0x11
    3ca4:	f7 01       	movw	r30, r14
    3ca6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ca8:	95 8d       	ldd	r25, Z+29	; 0x1d
    3caa:	a6 8d       	ldd	r26, Z+30	; 0x1e
    3cac:	b7 8d       	ldd	r27, Z+31	; 0x1f
    3cae:	f8 01       	movw	r30, r16
    3cb0:	82 87       	std	Z+10, r24	; 0x0a
    3cb2:	93 87       	std	Z+11, r25	; 0x0b
    3cb4:	a4 87       	std	Z+12, r26	; 0x0c
    3cb6:	b5 87       	std	Z+13, r27	; 0x0d
    3cb8:	16 82       	std	Z+6, r1	; 0x06
    3cba:	17 82       	std	Z+7, r1	; 0x07
    3cbc:	10 86       	std	Z+8, r1	; 0x08
    3cbe:	11 86       	std	Z+9, r1	; 0x09
    3cc0:	16 8a       	std	Z+22, r1	; 0x16
    3cc2:	17 8a       	std	Z+23, r1	; 0x17
    3cc4:	10 8e       	std	Z+24, r1	; 0x18
    3cc6:	11 8e       	std	Z+25, r1	; 0x19
    3cc8:	d1 82       	std	Z+1, r13	; 0x01
    3cca:	c0 82       	st	Z, r12
    3ccc:	f6 01       	movw	r30, r12
    3cce:	86 81       	ldd	r24, Z+6	; 0x06
    3cd0:	97 81       	ldd	r25, Z+7	; 0x07
    3cd2:	f8 01       	movw	r30, r16
    3cd4:	93 83       	std	Z+3, r25	; 0x03
    3cd6:	82 83       	std	Z+2, r24	; 0x02
    3cd8:	80 e0       	ldi	r24, 0x00	; 0
    3cda:	2a c0       	rjmp	.+84     	; 0x3d30 <f_open+0x204>
    3cdc:	89 e0       	ldi	r24, 0x09	; 9
    3cde:	28 c0       	rjmp	.+80     	; 0x3d30 <f_open+0x204>
    3ce0:	4d 2d       	mov	r20, r13
    3ce2:	4c 71       	andi	r20, 0x1C	; 28
    3ce4:	09 f0       	breq	.+2      	; 0x3ce8 <f_open+0x1bc>
    3ce6:	63 cf       	rjmp	.-314    	; 0x3bae <f_open+0x82>
    3ce8:	0d c0       	rjmp	.+26     	; 0x3d04 <f_open+0x1d8>
    3cea:	4d 2d       	mov	r20, r13
    3cec:	4c 71       	andi	r20, 0x1C	; 28
    3cee:	89 f4       	brne	.+34     	; 0x3d12 <f_open+0x1e6>
    3cf0:	86 e0       	ldi	r24, 0x06	; 6
    3cf2:	08 c0       	rjmp	.+16     	; 0x3d04 <f_open+0x1d8>
    3cf4:	8d 2d       	mov	r24, r13
    3cf6:	8c 71       	andi	r24, 0x1C	; 28
    3cf8:	09 f0       	breq	.+2      	; 0x3cfc <f_open+0x1d0>
    3cfa:	67 cf       	rjmp	.-306    	; 0x3bca <f_open+0x9e>
    3cfc:	11 c0       	rjmp	.+34     	; 0x3d20 <f_open+0x1f4>
    3cfe:	87 e0       	ldi	r24, 0x07	; 7
    3d00:	01 c0       	rjmp	.+2      	; 0x3d04 <f_open+0x1d8>
    3d02:	84 e0       	ldi	r24, 0x04	; 4
    3d04:	88 23       	and	r24, r24
    3d06:	09 f4       	brne	.+2      	; 0x3d0a <f_open+0x1de>
    3d08:	bf cf       	rjmp	.-130    	; 0x3c88 <f_open+0x15c>
    3d0a:	12 c0       	rjmp	.+36     	; 0x3d30 <f_open+0x204>
    3d0c:	33 fc       	sbrc	r3, 3
    3d0e:	ac cf       	rjmp	.-168    	; 0x3c68 <f_open+0x13c>
    3d10:	ae cf       	rjmp	.-164    	; 0x3c6e <f_open+0x142>
    3d12:	86 e0       	ldi	r24, 0x06	; 6
    3d14:	f3 2d       	mov	r31, r3
    3d16:	f8 60       	ori	r31, 0x08	; 8
    3d18:	3f 2e       	mov	r3, r31
    3d1a:	eb 88       	ldd	r14, Y+19	; 0x13
    3d1c:	fc 88       	ldd	r15, Y+20	; 0x14
    3d1e:	f2 cf       	rjmp	.-28     	; 0x3d04 <f_open+0x1d8>
    3d20:	f7 01       	movw	r30, r14
    3d22:	83 85       	ldd	r24, Z+11	; 0x0b
    3d24:	84 fd       	sbrc	r24, 4
    3d26:	ed cf       	rjmp	.-38     	; 0x3d02 <f_open+0x1d6>
    3d28:	9a cf       	rjmp	.-204    	; 0x3c5e <f_open+0x132>
    3d2a:	87 e0       	ldi	r24, 0x07	; 7
    3d2c:	01 c0       	rjmp	.+2      	; 0x3d30 <f_open+0x204>
    3d2e:	88 e0       	ldi	r24, 0x08	; 8
    3d30:	a4 96       	adiw	r28, 0x24	; 36
    3d32:	0f b6       	in	r0, 0x3f	; 63
    3d34:	f8 94       	cli
    3d36:	de bf       	out	0x3e, r29	; 62
    3d38:	0f be       	out	0x3f, r0	; 63
    3d3a:	cd bf       	out	0x3d, r28	; 61
    3d3c:	df 91       	pop	r29
    3d3e:	cf 91       	pop	r28
    3d40:	1f 91       	pop	r17
    3d42:	0f 91       	pop	r16
    3d44:	ff 90       	pop	r15
    3d46:	ef 90       	pop	r14
    3d48:	df 90       	pop	r13
    3d4a:	cf 90       	pop	r12
    3d4c:	bf 90       	pop	r11
    3d4e:	af 90       	pop	r10
    3d50:	9f 90       	pop	r9
    3d52:	8f 90       	pop	r8
    3d54:	7f 90       	pop	r7
    3d56:	6f 90       	pop	r6
    3d58:	5f 90       	pop	r5
    3d5a:	4f 90       	pop	r4
    3d5c:	3f 90       	pop	r3
    3d5e:	08 95       	ret

00003d60 <f_write>:
    3d60:	2f 92       	push	r2
    3d62:	3f 92       	push	r3
    3d64:	4f 92       	push	r4
    3d66:	5f 92       	push	r5
    3d68:	6f 92       	push	r6
    3d6a:	7f 92       	push	r7
    3d6c:	8f 92       	push	r8
    3d6e:	9f 92       	push	r9
    3d70:	af 92       	push	r10
    3d72:	bf 92       	push	r11
    3d74:	cf 92       	push	r12
    3d76:	df 92       	push	r13
    3d78:	ef 92       	push	r14
    3d7a:	ff 92       	push	r15
    3d7c:	0f 93       	push	r16
    3d7e:	1f 93       	push	r17
    3d80:	cf 93       	push	r28
    3d82:	df 93       	push	r29
    3d84:	ec 01       	movw	r28, r24
    3d86:	4b 01       	movw	r8, r22
    3d88:	6a 01       	movw	r12, r20
    3d8a:	59 01       	movw	r10, r18
    3d8c:	f9 01       	movw	r30, r18
    3d8e:	11 82       	std	Z+1, r1	; 0x01
    3d90:	10 82       	st	Z, r1
    3d92:	0e 94 4e 12 	call	0x249c	; 0x249c <validate>
    3d96:	81 11       	cpse	r24, r1
    3d98:	6b c1       	rjmp	.+726    	; 0x4070 <f_write+0x310>
    3d9a:	8d 81       	ldd	r24, Y+5	; 0x05
    3d9c:	81 11       	cpse	r24, r1
    3d9e:	68 c1       	rjmp	.+720    	; 0x4070 <f_write+0x310>
    3da0:	8c 81       	ldd	r24, Y+4	; 0x04
    3da2:	81 ff       	sbrs	r24, 1
    3da4:	64 c1       	rjmp	.+712    	; 0x406e <f_write+0x30e>
    3da6:	8e 81       	ldd	r24, Y+6	; 0x06
    3da8:	9f 81       	ldd	r25, Y+7	; 0x07
    3daa:	a8 85       	ldd	r26, Y+8	; 0x08
    3dac:	b9 85       	ldd	r27, Y+9	; 0x09
    3dae:	ac 01       	movw	r20, r24
    3db0:	bd 01       	movw	r22, r26
    3db2:	4c 0d       	add	r20, r12
    3db4:	5d 1d       	adc	r21, r13
    3db6:	61 1d       	adc	r22, r1
    3db8:	71 1d       	adc	r23, r1
    3dba:	48 17       	cp	r20, r24
    3dbc:	59 07       	cpc	r21, r25
    3dbe:	6a 07       	cpc	r22, r26
    3dc0:	7b 07       	cpc	r23, r27
    3dc2:	08 f4       	brcc	.+2      	; 0x3dc6 <f_write+0x66>
    3dc4:	3e c1       	rjmp	.+636    	; 0x4042 <f_write+0x2e2>
    3dc6:	c1 14       	cp	r12, r1
    3dc8:	d1 04       	cpc	r13, r1
    3dca:	09 f4       	brne	.+2      	; 0x3dce <f_write+0x6e>
    3dcc:	3a c1       	rjmp	.+628    	; 0x4042 <f_write+0x2e2>
    3dce:	4e 81       	ldd	r20, Y+6	; 0x06
    3dd0:	5f 81       	ldd	r21, Y+7	; 0x07
    3dd2:	68 85       	ldd	r22, Y+8	; 0x08
    3dd4:	79 85       	ldd	r23, Y+9	; 0x09
    3dd6:	db 01       	movw	r26, r22
    3dd8:	ca 01       	movw	r24, r20
    3dda:	91 70       	andi	r25, 0x01	; 1
    3ddc:	aa 27       	eor	r26, r26
    3dde:	bb 27       	eor	r27, r27
    3de0:	89 2b       	or	r24, r25
    3de2:	8a 2b       	or	r24, r26
    3de4:	8b 2b       	or	r24, r27
    3de6:	09 f0       	breq	.+2      	; 0x3dea <f_write+0x8a>
    3de8:	e6 c0       	rjmp	.+460    	; 0x3fb6 <f_write+0x256>
    3dea:	e8 81       	ld	r30, Y
    3dec:	f9 81       	ldd	r31, Y+1	; 0x01
    3dee:	12 81       	ldd	r17, Z+2	; 0x02
    3df0:	11 50       	subi	r17, 0x01	; 1
    3df2:	db 01       	movw	r26, r22
    3df4:	ca 01       	movw	r24, r20
    3df6:	07 2e       	mov	r0, r23
    3df8:	79 e0       	ldi	r23, 0x09	; 9
    3dfa:	b6 95       	lsr	r27
    3dfc:	a7 95       	ror	r26
    3dfe:	97 95       	ror	r25
    3e00:	87 95       	ror	r24
    3e02:	7a 95       	dec	r23
    3e04:	d1 f7       	brne	.-12     	; 0x3dfa <f_write+0x9a>
    3e06:	70 2d       	mov	r23, r0
    3e08:	18 23       	and	r17, r24
    3e0a:	09 f0       	breq	.+2      	; 0x3e0e <f_write+0xae>
    3e0c:	40 c0       	rjmp	.+128    	; 0x3e8e <f_write+0x12e>
    3e0e:	45 2b       	or	r20, r21
    3e10:	46 2b       	or	r20, r22
    3e12:	47 2b       	or	r20, r23
    3e14:	79 f4       	brne	.+30     	; 0x3e34 <f_write+0xd4>
    3e16:	6e 85       	ldd	r22, Y+14	; 0x0e
    3e18:	7f 85       	ldd	r23, Y+15	; 0x0f
    3e1a:	88 89       	ldd	r24, Y+16	; 0x10
    3e1c:	99 89       	ldd	r25, Y+17	; 0x11
    3e1e:	61 15       	cp	r22, r1
    3e20:	71 05       	cpc	r23, r1
    3e22:	81 05       	cpc	r24, r1
    3e24:	91 05       	cpc	r25, r1
    3e26:	91 f4       	brne	.+36     	; 0x3e4c <f_write+0xec>
    3e28:	40 e0       	ldi	r20, 0x00	; 0
    3e2a:	50 e0       	ldi	r21, 0x00	; 0
    3e2c:	ba 01       	movw	r22, r20
    3e2e:	cf 01       	movw	r24, r30
    3e30:	94 d9       	rcall	.-3288   	; 0x315a <create_chain>
    3e32:	06 c0       	rjmp	.+12     	; 0x3e40 <f_write+0xe0>
    3e34:	4a 89       	ldd	r20, Y+18	; 0x12
    3e36:	5b 89       	ldd	r21, Y+19	; 0x13
    3e38:	6c 89       	ldd	r22, Y+20	; 0x14
    3e3a:	7d 89       	ldd	r23, Y+21	; 0x15
    3e3c:	cf 01       	movw	r24, r30
    3e3e:	8d d9       	rcall	.-3302   	; 0x315a <create_chain>
    3e40:	61 15       	cp	r22, r1
    3e42:	71 05       	cpc	r23, r1
    3e44:	81 05       	cpc	r24, r1
    3e46:	91 05       	cpc	r25, r1
    3e48:	09 f4       	brne	.+2      	; 0x3e4c <f_write+0xec>
    3e4a:	fb c0       	rjmp	.+502    	; 0x4042 <f_write+0x2e2>
    3e4c:	61 30       	cpi	r22, 0x01	; 1
    3e4e:	71 05       	cpc	r23, r1
    3e50:	81 05       	cpc	r24, r1
    3e52:	91 05       	cpc	r25, r1
    3e54:	19 f4       	brne	.+6      	; 0x3e5c <f_write+0xfc>
    3e56:	82 e0       	ldi	r24, 0x02	; 2
    3e58:	8d 83       	std	Y+5, r24	; 0x05
    3e5a:	0a c1       	rjmp	.+532    	; 0x4070 <f_write+0x310>
    3e5c:	6f 3f       	cpi	r22, 0xFF	; 255
    3e5e:	ff ef       	ldi	r31, 0xFF	; 255
    3e60:	7f 07       	cpc	r23, r31
    3e62:	8f 07       	cpc	r24, r31
    3e64:	9f 07       	cpc	r25, r31
    3e66:	19 f4       	brne	.+6      	; 0x3e6e <f_write+0x10e>
    3e68:	81 e0       	ldi	r24, 0x01	; 1
    3e6a:	8d 83       	std	Y+5, r24	; 0x05
    3e6c:	01 c1       	rjmp	.+514    	; 0x4070 <f_write+0x310>
    3e6e:	6a 8b       	std	Y+18, r22	; 0x12
    3e70:	7b 8b       	std	Y+19, r23	; 0x13
    3e72:	8c 8b       	std	Y+20, r24	; 0x14
    3e74:	9d 8b       	std	Y+21, r25	; 0x15
    3e76:	4e 84       	ldd	r4, Y+14	; 0x0e
    3e78:	5f 84       	ldd	r5, Y+15	; 0x0f
    3e7a:	68 88       	ldd	r6, Y+16	; 0x10
    3e7c:	79 88       	ldd	r7, Y+17	; 0x11
    3e7e:	45 28       	or	r4, r5
    3e80:	46 28       	or	r4, r6
    3e82:	47 28       	or	r4, r7
    3e84:	21 f4       	brne	.+8      	; 0x3e8e <f_write+0x12e>
    3e86:	6e 87       	std	Y+14, r22	; 0x0e
    3e88:	7f 87       	std	Y+15, r23	; 0x0f
    3e8a:	88 8b       	std	Y+16, r24	; 0x10
    3e8c:	99 8b       	std	Y+17, r25	; 0x11
    3e8e:	e8 81       	ld	r30, Y
    3e90:	f9 81       	ldd	r31, Y+1	; 0x01
    3e92:	42 a5       	ldd	r20, Z+42	; 0x2a
    3e94:	53 a5       	ldd	r21, Z+43	; 0x2b
    3e96:	64 a5       	ldd	r22, Z+44	; 0x2c
    3e98:	75 a5       	ldd	r23, Z+45	; 0x2d
    3e9a:	8e 89       	ldd	r24, Y+22	; 0x16
    3e9c:	9f 89       	ldd	r25, Y+23	; 0x17
    3e9e:	a8 8d       	ldd	r26, Y+24	; 0x18
    3ea0:	b9 8d       	ldd	r27, Y+25	; 0x19
    3ea2:	48 17       	cp	r20, r24
    3ea4:	59 07       	cpc	r21, r25
    3ea6:	6a 07       	cpc	r22, r26
    3ea8:	7b 07       	cpc	r23, r27
    3eaa:	41 f4       	brne	.+16     	; 0x3ebc <f_write+0x15c>
    3eac:	cf 01       	movw	r24, r30
    3eae:	0e 94 6f 11 	call	0x22de	; 0x22de <sync_window>
    3eb2:	88 23       	and	r24, r24
    3eb4:	19 f0       	breq	.+6      	; 0x3ebc <f_write+0x15c>
    3eb6:	81 e0       	ldi	r24, 0x01	; 1
    3eb8:	8d 83       	std	Y+5, r24	; 0x05
    3eba:	da c0       	rjmp	.+436    	; 0x4070 <f_write+0x310>
    3ebc:	28 80       	ld	r2, Y
    3ebe:	39 80       	ldd	r3, Y+1	; 0x01
    3ec0:	4a 89       	ldd	r20, Y+18	; 0x12
    3ec2:	5b 89       	ldd	r21, Y+19	; 0x13
    3ec4:	6c 89       	ldd	r22, Y+20	; 0x14
    3ec6:	7d 89       	ldd	r23, Y+21	; 0x15
    3ec8:	c1 01       	movw	r24, r2
    3eca:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <clust2sect>
    3ece:	61 15       	cp	r22, r1
    3ed0:	71 05       	cpc	r23, r1
    3ed2:	81 05       	cpc	r24, r1
    3ed4:	91 05       	cpc	r25, r1
    3ed6:	19 f4       	brne	.+6      	; 0x3ede <f_write+0x17e>
    3ed8:	82 e0       	ldi	r24, 0x02	; 2
    3eda:	8d 83       	std	Y+5, r24	; 0x05
    3edc:	c9 c0       	rjmp	.+402    	; 0x4070 <f_write+0x310>
    3ede:	2b 01       	movw	r4, r22
    3ee0:	3c 01       	movw	r6, r24
    3ee2:	41 0e       	add	r4, r17
    3ee4:	51 1c       	adc	r5, r1
    3ee6:	61 1c       	adc	r6, r1
    3ee8:	71 1c       	adc	r7, r1
    3eea:	76 01       	movw	r14, r12
    3eec:	ef 2c       	mov	r14, r15
    3eee:	ff 24       	eor	r15, r15
    3ef0:	e6 94       	lsr	r14
    3ef2:	e1 14       	cp	r14, r1
    3ef4:	f1 04       	cpc	r15, r1
    3ef6:	09 f4       	brne	.+2      	; 0x3efa <f_write+0x19a>
    3ef8:	3f c0       	rjmp	.+126    	; 0x3f78 <f_write+0x218>
    3efa:	f1 01       	movw	r30, r2
    3efc:	42 81       	ldd	r20, Z+2	; 0x02
    3efe:	24 2f       	mov	r18, r20
    3f00:	30 e0       	ldi	r19, 0x00	; 0
    3f02:	c7 01       	movw	r24, r14
    3f04:	81 0f       	add	r24, r17
    3f06:	91 1d       	adc	r25, r1
    3f08:	28 17       	cp	r18, r24
    3f0a:	39 07       	cpc	r19, r25
    3f0c:	18 f4       	brcc	.+6      	; 0x3f14 <f_write+0x1b4>
    3f0e:	79 01       	movw	r14, r18
    3f10:	e1 1a       	sub	r14, r17
    3f12:	f1 08       	sbc	r15, r1
    3f14:	87 01       	movw	r16, r14
    3f16:	a3 01       	movw	r20, r6
    3f18:	92 01       	movw	r18, r4
    3f1a:	b4 01       	movw	r22, r8
    3f1c:	f1 01       	movw	r30, r2
    3f1e:	81 81       	ldd	r24, Z+1	; 0x01
    3f20:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <disk_write>
    3f24:	88 23       	and	r24, r24
    3f26:	19 f0       	breq	.+6      	; 0x3f2e <f_write+0x1ce>
    3f28:	81 e0       	ldi	r24, 0x01	; 1
    3f2a:	8d 83       	std	Y+5, r24	; 0x05
    3f2c:	a1 c0       	rjmp	.+322    	; 0x4070 <f_write+0x310>
    3f2e:	e8 81       	ld	r30, Y
    3f30:	f9 81       	ldd	r31, Y+1	; 0x01
    3f32:	82 a5       	ldd	r24, Z+42	; 0x2a
    3f34:	93 a5       	ldd	r25, Z+43	; 0x2b
    3f36:	a4 a5       	ldd	r26, Z+44	; 0x2c
    3f38:	b5 a5       	ldd	r27, Z+45	; 0x2d
    3f3a:	84 19       	sub	r24, r4
    3f3c:	95 09       	sbc	r25, r5
    3f3e:	a6 09       	sbc	r26, r6
    3f40:	b7 09       	sbc	r27, r7
    3f42:	a7 01       	movw	r20, r14
    3f44:	60 e0       	ldi	r22, 0x00	; 0
    3f46:	70 e0       	ldi	r23, 0x00	; 0
    3f48:	84 17       	cp	r24, r20
    3f4a:	95 07       	cpc	r25, r21
    3f4c:	a6 07       	cpc	r26, r22
    3f4e:	b7 07       	cpc	r27, r23
    3f50:	78 f4       	brcc	.+30     	; 0x3f70 <f_write+0x210>
    3f52:	98 2f       	mov	r25, r24
    3f54:	88 27       	eor	r24, r24
    3f56:	99 0f       	add	r25, r25
    3f58:	b4 01       	movw	r22, r8
    3f5a:	68 0f       	add	r22, r24
    3f5c:	79 1f       	adc	r23, r25
    3f5e:	40 e0       	ldi	r20, 0x00	; 0
    3f60:	52 e0       	ldi	r21, 0x02	; 2
    3f62:	cf 01       	movw	r24, r30
    3f64:	8e 96       	adiw	r24, 0x2e	; 46
    3f66:	0e 94 a6 10 	call	0x214c	; 0x214c <mem_cpy>
    3f6a:	e8 81       	ld	r30, Y
    3f6c:	f9 81       	ldd	r31, Y+1	; 0x01
    3f6e:	14 82       	std	Z+4, r1	; 0x04
    3f70:	fe 2c       	mov	r15, r14
    3f72:	ee 24       	eor	r14, r14
    3f74:	ff 0c       	add	r15, r15
    3f76:	4c c0       	rjmp	.+152    	; 0x4010 <f_write+0x2b0>
    3f78:	4e 81       	ldd	r20, Y+6	; 0x06
    3f7a:	5f 81       	ldd	r21, Y+7	; 0x07
    3f7c:	68 85       	ldd	r22, Y+8	; 0x08
    3f7e:	79 85       	ldd	r23, Y+9	; 0x09
    3f80:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f82:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f84:	ac 85       	ldd	r26, Y+12	; 0x0c
    3f86:	bd 85       	ldd	r27, Y+13	; 0x0d
    3f88:	48 17       	cp	r20, r24
    3f8a:	59 07       	cpc	r21, r25
    3f8c:	6a 07       	cpc	r22, r26
    3f8e:	7b 07       	cpc	r23, r27
    3f90:	70 f0       	brcs	.+28     	; 0x3fae <f_write+0x24e>
    3f92:	c1 01       	movw	r24, r2
    3f94:	0e 94 6f 11 	call	0x22de	; 0x22de <sync_window>
    3f98:	88 23       	and	r24, r24
    3f9a:	19 f0       	breq	.+6      	; 0x3fa2 <f_write+0x242>
    3f9c:	81 e0       	ldi	r24, 0x01	; 1
    3f9e:	8d 83       	std	Y+5, r24	; 0x05
    3fa0:	67 c0       	rjmp	.+206    	; 0x4070 <f_write+0x310>
    3fa2:	e8 81       	ld	r30, Y
    3fa4:	f9 81       	ldd	r31, Y+1	; 0x01
    3fa6:	42 a6       	std	Z+42, r4	; 0x2a
    3fa8:	53 a6       	std	Z+43, r5	; 0x2b
    3faa:	64 a6       	std	Z+44, r6	; 0x2c
    3fac:	75 a6       	std	Z+45, r7	; 0x2d
    3fae:	4e 8a       	std	Y+22, r4	; 0x16
    3fb0:	5f 8a       	std	Y+23, r5	; 0x17
    3fb2:	68 8e       	std	Y+24, r6	; 0x18
    3fb4:	79 8e       	std	Y+25, r7	; 0x19
    3fb6:	2e 81       	ldd	r18, Y+6	; 0x06
    3fb8:	3f 81       	ldd	r19, Y+7	; 0x07
    3fba:	31 70       	andi	r19, 0x01	; 1
    3fbc:	80 e0       	ldi	r24, 0x00	; 0
    3fbe:	92 e0       	ldi	r25, 0x02	; 2
    3fc0:	82 1b       	sub	r24, r18
    3fc2:	93 0b       	sbc	r25, r19
    3fc4:	76 01       	movw	r14, r12
    3fc6:	8c 15       	cp	r24, r12
    3fc8:	9d 05       	cpc	r25, r13
    3fca:	08 f4       	brcc	.+2      	; 0x3fce <f_write+0x26e>
    3fcc:	7c 01       	movw	r14, r24
    3fce:	4e 89       	ldd	r20, Y+22	; 0x16
    3fd0:	5f 89       	ldd	r21, Y+23	; 0x17
    3fd2:	68 8d       	ldd	r22, Y+24	; 0x18
    3fd4:	79 8d       	ldd	r23, Y+25	; 0x19
    3fd6:	88 81       	ld	r24, Y
    3fd8:	99 81       	ldd	r25, Y+1	; 0x01
    3fda:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <move_window>
    3fde:	88 23       	and	r24, r24
    3fe0:	19 f0       	breq	.+6      	; 0x3fe8 <f_write+0x288>
    3fe2:	81 e0       	ldi	r24, 0x01	; 1
    3fe4:	8d 83       	std	Y+5, r24	; 0x05
    3fe6:	44 c0       	rjmp	.+136    	; 0x4070 <f_write+0x310>
    3fe8:	8e 81       	ldd	r24, Y+6	; 0x06
    3fea:	9f 81       	ldd	r25, Y+7	; 0x07
    3fec:	a8 85       	ldd	r26, Y+8	; 0x08
    3fee:	b9 85       	ldd	r27, Y+9	; 0x09
    3ff0:	91 70       	andi	r25, 0x01	; 1
    3ff2:	aa 27       	eor	r26, r26
    3ff4:	bb 27       	eor	r27, r27
    3ff6:	8e 96       	adiw	r24, 0x2e	; 46
    3ff8:	28 81       	ld	r18, Y
    3ffa:	39 81       	ldd	r19, Y+1	; 0x01
    3ffc:	a7 01       	movw	r20, r14
    3ffe:	b4 01       	movw	r22, r8
    4000:	82 0f       	add	r24, r18
    4002:	93 1f       	adc	r25, r19
    4004:	0e 94 a6 10 	call	0x214c	; 0x214c <mem_cpy>
    4008:	e8 81       	ld	r30, Y
    400a:	f9 81       	ldd	r31, Y+1	; 0x01
    400c:	21 e0       	ldi	r18, 0x01	; 1
    400e:	24 83       	std	Z+4, r18	; 0x04
    4010:	8e 0c       	add	r8, r14
    4012:	9f 1c       	adc	r9, r15
    4014:	8e 81       	ldd	r24, Y+6	; 0x06
    4016:	9f 81       	ldd	r25, Y+7	; 0x07
    4018:	a8 85       	ldd	r26, Y+8	; 0x08
    401a:	b9 85       	ldd	r27, Y+9	; 0x09
    401c:	8e 0d       	add	r24, r14
    401e:	9f 1d       	adc	r25, r15
    4020:	a1 1d       	adc	r26, r1
    4022:	b1 1d       	adc	r27, r1
    4024:	8e 83       	std	Y+6, r24	; 0x06
    4026:	9f 83       	std	Y+7, r25	; 0x07
    4028:	a8 87       	std	Y+8, r26	; 0x08
    402a:	b9 87       	std	Y+9, r27	; 0x09
    402c:	f5 01       	movw	r30, r10
    402e:	80 81       	ld	r24, Z
    4030:	91 81       	ldd	r25, Z+1	; 0x01
    4032:	8e 0d       	add	r24, r14
    4034:	9f 1d       	adc	r25, r15
    4036:	91 83       	std	Z+1, r25	; 0x01
    4038:	80 83       	st	Z, r24
    403a:	ce 18       	sub	r12, r14
    403c:	df 08       	sbc	r13, r15
    403e:	09 f0       	breq	.+2      	; 0x4042 <f_write+0x2e2>
    4040:	c6 ce       	rjmp	.-628    	; 0x3dce <f_write+0x6e>
    4042:	8e 81       	ldd	r24, Y+6	; 0x06
    4044:	9f 81       	ldd	r25, Y+7	; 0x07
    4046:	a8 85       	ldd	r26, Y+8	; 0x08
    4048:	b9 85       	ldd	r27, Y+9	; 0x09
    404a:	4a 85       	ldd	r20, Y+10	; 0x0a
    404c:	5b 85       	ldd	r21, Y+11	; 0x0b
    404e:	6c 85       	ldd	r22, Y+12	; 0x0c
    4050:	7d 85       	ldd	r23, Y+13	; 0x0d
    4052:	48 17       	cp	r20, r24
    4054:	59 07       	cpc	r21, r25
    4056:	6a 07       	cpc	r22, r26
    4058:	7b 07       	cpc	r23, r27
    405a:	20 f4       	brcc	.+8      	; 0x4064 <f_write+0x304>
    405c:	8a 87       	std	Y+10, r24	; 0x0a
    405e:	9b 87       	std	Y+11, r25	; 0x0b
    4060:	ac 87       	std	Y+12, r26	; 0x0c
    4062:	bd 87       	std	Y+13, r27	; 0x0d
    4064:	8c 81       	ldd	r24, Y+4	; 0x04
    4066:	80 62       	ori	r24, 0x20	; 32
    4068:	8c 83       	std	Y+4, r24	; 0x04
    406a:	80 e0       	ldi	r24, 0x00	; 0
    406c:	01 c0       	rjmp	.+2      	; 0x4070 <f_write+0x310>
    406e:	87 e0       	ldi	r24, 0x07	; 7
    4070:	df 91       	pop	r29
    4072:	cf 91       	pop	r28
    4074:	1f 91       	pop	r17
    4076:	0f 91       	pop	r16
    4078:	ff 90       	pop	r15
    407a:	ef 90       	pop	r14
    407c:	df 90       	pop	r13
    407e:	cf 90       	pop	r12
    4080:	bf 90       	pop	r11
    4082:	af 90       	pop	r10
    4084:	9f 90       	pop	r9
    4086:	8f 90       	pop	r8
    4088:	7f 90       	pop	r7
    408a:	6f 90       	pop	r6
    408c:	5f 90       	pop	r5
    408e:	4f 90       	pop	r4
    4090:	3f 90       	pop	r3
    4092:	2f 90       	pop	r2
    4094:	08 95       	ret

00004096 <f_sync>:
    4096:	cf 93       	push	r28
    4098:	df 93       	push	r29
    409a:	ec 01       	movw	r28, r24
    409c:	0e 94 4e 12 	call	0x249c	; 0x249c <validate>
    40a0:	81 11       	cpse	r24, r1
    40a2:	37 c0       	rjmp	.+110    	; 0x4112 <f_sync+0x7c>
    40a4:	9c 81       	ldd	r25, Y+4	; 0x04
    40a6:	95 ff       	sbrs	r25, 5
    40a8:	34 c0       	rjmp	.+104    	; 0x4112 <f_sync+0x7c>
    40aa:	4a 8d       	ldd	r20, Y+26	; 0x1a
    40ac:	5b 8d       	ldd	r21, Y+27	; 0x1b
    40ae:	6c 8d       	ldd	r22, Y+28	; 0x1c
    40b0:	7d 8d       	ldd	r23, Y+29	; 0x1d
    40b2:	88 81       	ld	r24, Y
    40b4:	99 81       	ldd	r25, Y+1	; 0x01
    40b6:	0e 94 d8 11 	call	0x23b0	; 0x23b0 <move_window>
    40ba:	81 11       	cpse	r24, r1
    40bc:	2a c0       	rjmp	.+84     	; 0x4112 <f_sync+0x7c>
    40be:	ee 8d       	ldd	r30, Y+30	; 0x1e
    40c0:	ff 8d       	ldd	r31, Y+31	; 0x1f
    40c2:	83 85       	ldd	r24, Z+11	; 0x0b
    40c4:	80 62       	ori	r24, 0x20	; 32
    40c6:	83 87       	std	Z+11, r24	; 0x0b
    40c8:	8a 85       	ldd	r24, Y+10	; 0x0a
    40ca:	9b 85       	ldd	r25, Y+11	; 0x0b
    40cc:	ac 85       	ldd	r26, Y+12	; 0x0c
    40ce:	bd 85       	ldd	r27, Y+13	; 0x0d
    40d0:	84 8f       	std	Z+28, r24	; 0x1c
    40d2:	95 8f       	std	Z+29, r25	; 0x1d
    40d4:	a6 8f       	std	Z+30, r26	; 0x1e
    40d6:	b7 8f       	std	Z+31, r27	; 0x1f
    40d8:	8e 85       	ldd	r24, Y+14	; 0x0e
    40da:	9f 85       	ldd	r25, Y+15	; 0x0f
    40dc:	a8 89       	ldd	r26, Y+16	; 0x10
    40de:	b9 89       	ldd	r27, Y+17	; 0x11
    40e0:	93 8f       	std	Z+27, r25	; 0x1b
    40e2:	82 8f       	std	Z+26, r24	; 0x1a
    40e4:	b5 8b       	std	Z+21, r27	; 0x15
    40e6:	a4 8b       	std	Z+20, r26	; 0x14
    40e8:	80 e0       	ldi	r24, 0x00	; 0
    40ea:	90 e0       	ldi	r25, 0x00	; 0
    40ec:	a9 e6       	ldi	r26, 0x69	; 105
    40ee:	b5 e4       	ldi	r27, 0x45	; 69
    40f0:	86 8b       	std	Z+22, r24	; 0x16
    40f2:	97 8b       	std	Z+23, r25	; 0x17
    40f4:	a0 8f       	std	Z+24, r26	; 0x18
    40f6:	b1 8f       	std	Z+25, r27	; 0x19
    40f8:	13 8a       	std	Z+19, r1	; 0x13
    40fa:	12 8a       	std	Z+18, r1	; 0x12
    40fc:	8c 81       	ldd	r24, Y+4	; 0x04
    40fe:	8f 7d       	andi	r24, 0xDF	; 223
    4100:	8c 83       	std	Y+4, r24	; 0x04
    4102:	e8 81       	ld	r30, Y
    4104:	f9 81       	ldd	r31, Y+1	; 0x01
    4106:	81 e0       	ldi	r24, 0x01	; 1
    4108:	84 83       	std	Z+4, r24	; 0x04
    410a:	88 81       	ld	r24, Y
    410c:	99 81       	ldd	r25, Y+1	; 0x01
    410e:	0e 94 58 15 	call	0x2ab0	; 0x2ab0 <sync_fs>
    4112:	df 91       	pop	r29
    4114:	cf 91       	pop	r28
    4116:	08 95       	ret

00004118 <f_close>:
    4118:	cf 93       	push	r28
    411a:	df 93       	push	r29
    411c:	ec 01       	movw	r28, r24
    411e:	bb df       	rcall	.-138    	; 0x4096 <f_sync>
    4120:	81 11       	cpse	r24, r1
    4122:	07 c0       	rjmp	.+14     	; 0x4132 <f_close+0x1a>
    4124:	ce 01       	movw	r24, r28
    4126:	0e 94 4e 12 	call	0x249c	; 0x249c <validate>
    412a:	81 11       	cpse	r24, r1
    412c:	02 c0       	rjmp	.+4      	; 0x4132 <f_close+0x1a>
    412e:	19 82       	std	Y+1, r1	; 0x01
    4130:	18 82       	st	Y, r1
    4132:	df 91       	pop	r29
    4134:	cf 91       	pop	r28
    4136:	08 95       	ret

00004138 <f_lseek>:
    4138:	2f 92       	push	r2
    413a:	3f 92       	push	r3
    413c:	4f 92       	push	r4
    413e:	5f 92       	push	r5
    4140:	6f 92       	push	r6
    4142:	7f 92       	push	r7
    4144:	8f 92       	push	r8
    4146:	9f 92       	push	r9
    4148:	af 92       	push	r10
    414a:	bf 92       	push	r11
    414c:	cf 92       	push	r12
    414e:	df 92       	push	r13
    4150:	ef 92       	push	r14
    4152:	ff 92       	push	r15
    4154:	0f 93       	push	r16
    4156:	1f 93       	push	r17
    4158:	cf 93       	push	r28
    415a:	df 93       	push	r29
    415c:	00 d0       	rcall	.+0      	; 0x415e <f_lseek+0x26>
    415e:	00 d0       	rcall	.+0      	; 0x4160 <f_lseek+0x28>
    4160:	cd b7       	in	r28, 0x3d	; 61
    4162:	de b7       	in	r29, 0x3e	; 62
    4164:	1c 01       	movw	r2, r24
    4166:	6a 01       	movw	r12, r20
    4168:	7b 01       	movw	r14, r22
    416a:	0e 94 4e 12 	call	0x249c	; 0x249c <validate>
    416e:	81 11       	cpse	r24, r1
    4170:	83 c1       	rjmp	.+774    	; 0x4478 <f_lseek+0x340>
    4172:	d1 01       	movw	r26, r2
    4174:	15 96       	adiw	r26, 0x05	; 5
    4176:	8c 91       	ld	r24, X
    4178:	15 97       	sbiw	r26, 0x05	; 5
    417a:	81 11       	cpse	r24, r1
    417c:	7d c1       	rjmp	.+762    	; 0x4478 <f_lseek+0x340>
    417e:	1a 96       	adiw	r26, 0x0a	; 10
    4180:	8d 91       	ld	r24, X+
    4182:	9d 91       	ld	r25, X+
    4184:	0d 90       	ld	r0, X+
    4186:	bc 91       	ld	r27, X
    4188:	a0 2d       	mov	r26, r0
    418a:	8c 15       	cp	r24, r12
    418c:	9d 05       	cpc	r25, r13
    418e:	ae 05       	cpc	r26, r14
    4190:	bf 05       	cpc	r27, r15
    4192:	30 f4       	brcc	.+12     	; 0x41a0 <f_lseek+0x68>
    4194:	f1 01       	movw	r30, r2
    4196:	24 81       	ldd	r18, Z+4	; 0x04
    4198:	21 fd       	sbrc	r18, 1
    419a:	02 c0       	rjmp	.+4      	; 0x41a0 <f_lseek+0x68>
    419c:	6c 01       	movw	r12, r24
    419e:	7d 01       	movw	r14, r26
    41a0:	d1 01       	movw	r26, r2
    41a2:	16 96       	adiw	r26, 0x06	; 6
    41a4:	4d 90       	ld	r4, X+
    41a6:	5d 90       	ld	r5, X+
    41a8:	6d 90       	ld	r6, X+
    41aa:	7c 90       	ld	r7, X
    41ac:	19 97       	sbiw	r26, 0x09	; 9
    41ae:	f1 01       	movw	r30, r2
    41b0:	16 82       	std	Z+6, r1	; 0x06
    41b2:	17 82       	std	Z+7, r1	; 0x07
    41b4:	10 86       	std	Z+8, r1	; 0x08
    41b6:	11 86       	std	Z+9, r1	; 0x09
    41b8:	c1 14       	cp	r12, r1
    41ba:	d1 04       	cpc	r13, r1
    41bc:	e1 04       	cpc	r14, r1
    41be:	f1 04       	cpc	r15, r1
    41c0:	09 f4       	brne	.+2      	; 0x41c4 <f_lseek+0x8c>
    41c2:	57 c1       	rjmp	.+686    	; 0x4472 <f_lseek+0x33a>
    41c4:	00 81       	ld	r16, Z
    41c6:	11 81       	ldd	r17, Z+1	; 0x01
    41c8:	d8 01       	movw	r26, r16
    41ca:	12 96       	adiw	r26, 0x02	; 2
    41cc:	8c 90       	ld	r8, X
    41ce:	91 2c       	mov	r9, r1
    41d0:	a1 2c       	mov	r10, r1
    41d2:	b1 2c       	mov	r11, r1
    41d4:	07 2e       	mov	r0, r23
    41d6:	79 e0       	ldi	r23, 0x09	; 9
    41d8:	88 0c       	add	r8, r8
    41da:	99 1c       	adc	r9, r9
    41dc:	aa 1c       	adc	r10, r10
    41de:	bb 1c       	adc	r11, r11
    41e0:	7a 95       	dec	r23
    41e2:	d1 f7       	brne	.-12     	; 0x41d8 <f_lseek+0xa0>
    41e4:	70 2d       	mov	r23, r0
    41e6:	41 14       	cp	r4, r1
    41e8:	51 04       	cpc	r5, r1
    41ea:	61 04       	cpc	r6, r1
    41ec:	71 04       	cpc	r7, r1
    41ee:	09 f4       	brne	.+2      	; 0x41f2 <f_lseek+0xba>
    41f0:	3f c0       	rjmp	.+126    	; 0x4270 <f_lseek+0x138>
    41f2:	b1 e0       	ldi	r27, 0x01	; 1
    41f4:	4b 1a       	sub	r4, r27
    41f6:	51 08       	sbc	r5, r1
    41f8:	61 08       	sbc	r6, r1
    41fa:	71 08       	sbc	r7, r1
    41fc:	c7 01       	movw	r24, r14
    41fe:	b6 01       	movw	r22, r12
    4200:	61 50       	subi	r22, 0x01	; 1
    4202:	71 09       	sbc	r23, r1
    4204:	81 09       	sbc	r24, r1
    4206:	91 09       	sbc	r25, r1
    4208:	a5 01       	movw	r20, r10
    420a:	94 01       	movw	r18, r8
    420c:	0e 94 0d 39 	call	0x721a	; 0x721a <__udivmodsi4>
    4210:	29 83       	std	Y+1, r18	; 0x01
    4212:	3a 83       	std	Y+2, r19	; 0x02
    4214:	4b 83       	std	Y+3, r20	; 0x03
    4216:	5c 83       	std	Y+4, r21	; 0x04
    4218:	c3 01       	movw	r24, r6
    421a:	b2 01       	movw	r22, r4
    421c:	a5 01       	movw	r20, r10
    421e:	94 01       	movw	r18, r8
    4220:	0e 94 0d 39 	call	0x721a	; 0x721a <__udivmodsi4>
    4224:	89 81       	ldd	r24, Y+1	; 0x01
    4226:	9a 81       	ldd	r25, Y+2	; 0x02
    4228:	ab 81       	ldd	r26, Y+3	; 0x03
    422a:	bc 81       	ldd	r27, Y+4	; 0x04
    422c:	82 17       	cp	r24, r18
    422e:	93 07       	cpc	r25, r19
    4230:	a4 07       	cpc	r26, r20
    4232:	b5 07       	cpc	r27, r21
    4234:	e8 f0       	brcs	.+58     	; 0x4270 <f_lseek+0x138>
    4236:	88 27       	eor	r24, r24
    4238:	99 27       	eor	r25, r25
    423a:	dc 01       	movw	r26, r24
    423c:	88 19       	sub	r24, r8
    423e:	99 09       	sbc	r25, r9
    4240:	aa 09       	sbc	r26, r10
    4242:	bb 09       	sbc	r27, r11
    4244:	48 22       	and	r4, r24
    4246:	59 22       	and	r5, r25
    4248:	6a 22       	and	r6, r26
    424a:	7b 22       	and	r7, r27
    424c:	d1 01       	movw	r26, r2
    424e:	16 96       	adiw	r26, 0x06	; 6
    4250:	4d 92       	st	X+, r4
    4252:	5d 92       	st	X+, r5
    4254:	6d 92       	st	X+, r6
    4256:	7c 92       	st	X, r7
    4258:	19 97       	sbiw	r26, 0x09	; 9
    425a:	c4 18       	sub	r12, r4
    425c:	d5 08       	sbc	r13, r5
    425e:	e6 08       	sbc	r14, r6
    4260:	f7 08       	sbc	r15, r7
    4262:	52 96       	adiw	r26, 0x12	; 18
    4264:	4d 91       	ld	r20, X+
    4266:	5d 91       	ld	r21, X+
    4268:	6d 91       	ld	r22, X+
    426a:	7c 91       	ld	r23, X
    426c:	55 97       	sbiw	r26, 0x15	; 21
    426e:	32 c0       	rjmp	.+100    	; 0x42d4 <f_lseek+0x19c>
    4270:	f1 01       	movw	r30, r2
    4272:	46 85       	ldd	r20, Z+14	; 0x0e
    4274:	57 85       	ldd	r21, Z+15	; 0x0f
    4276:	60 89       	ldd	r22, Z+16	; 0x10
    4278:	71 89       	ldd	r23, Z+17	; 0x11
    427a:	41 15       	cp	r20, r1
    427c:	51 05       	cpc	r21, r1
    427e:	61 05       	cpc	r22, r1
    4280:	71 05       	cpc	r23, r1
    4282:	19 f5       	brne	.+70     	; 0x42ca <f_lseek+0x192>
    4284:	40 e0       	ldi	r20, 0x00	; 0
    4286:	50 e0       	ldi	r21, 0x00	; 0
    4288:	ba 01       	movw	r22, r20
    428a:	c8 01       	movw	r24, r16
    428c:	0e 94 ad 18 	call	0x315a	; 0x315a <create_chain>
    4290:	ab 01       	movw	r20, r22
    4292:	bc 01       	movw	r22, r24
    4294:	41 30       	cpi	r20, 0x01	; 1
    4296:	51 05       	cpc	r21, r1
    4298:	61 05       	cpc	r22, r1
    429a:	71 05       	cpc	r23, r1
    429c:	29 f4       	brne	.+10     	; 0x42a8 <f_lseek+0x170>
    429e:	82 e0       	ldi	r24, 0x02	; 2
    42a0:	d1 01       	movw	r26, r2
    42a2:	15 96       	adiw	r26, 0x05	; 5
    42a4:	8c 93       	st	X, r24
    42a6:	e8 c0       	rjmp	.+464    	; 0x4478 <f_lseek+0x340>
    42a8:	4f 3f       	cpi	r20, 0xFF	; 255
    42aa:	bf ef       	ldi	r27, 0xFF	; 255
    42ac:	5b 07       	cpc	r21, r27
    42ae:	6b 07       	cpc	r22, r27
    42b0:	7b 07       	cpc	r23, r27
    42b2:	21 f4       	brne	.+8      	; 0x42bc <f_lseek+0x184>
    42b4:	81 e0       	ldi	r24, 0x01	; 1
    42b6:	f1 01       	movw	r30, r2
    42b8:	85 83       	std	Z+5, r24	; 0x05
    42ba:	de c0       	rjmp	.+444    	; 0x4478 <f_lseek+0x340>
    42bc:	d1 01       	movw	r26, r2
    42be:	1e 96       	adiw	r26, 0x0e	; 14
    42c0:	4d 93       	st	X+, r20
    42c2:	5d 93       	st	X+, r21
    42c4:	6d 93       	st	X+, r22
    42c6:	7c 93       	st	X, r23
    42c8:	51 97       	sbiw	r26, 0x11	; 17
    42ca:	f1 01       	movw	r30, r2
    42cc:	42 8b       	std	Z+18, r20	; 0x12
    42ce:	53 8b       	std	Z+19, r21	; 0x13
    42d0:	64 8b       	std	Z+20, r22	; 0x14
    42d2:	75 8b       	std	Z+21, r23	; 0x15
    42d4:	41 15       	cp	r20, r1
    42d6:	51 05       	cpc	r21, r1
    42d8:	61 05       	cpc	r22, r1
    42da:	71 05       	cpc	r23, r1
    42dc:	09 f4       	brne	.+2      	; 0x42e0 <f_lseek+0x1a8>
    42de:	94 c0       	rjmp	.+296    	; 0x4408 <f_lseek+0x2d0>
    42e0:	8c 14       	cp	r8, r12
    42e2:	9d 04       	cpc	r9, r13
    42e4:	ae 04       	cpc	r10, r14
    42e6:	bf 04       	cpc	r11, r15
    42e8:	08 f0       	brcs	.+2      	; 0x42ec <f_lseek+0x1b4>
    42ea:	5c c0       	rjmp	.+184    	; 0x43a4 <f_lseek+0x26c>
    42ec:	d1 01       	movw	r26, r2
    42ee:	14 96       	adiw	r26, 0x04	; 4
    42f0:	8c 91       	ld	r24, X
    42f2:	14 97       	sbiw	r26, 0x04	; 4
    42f4:	81 ff       	sbrs	r24, 1
    42f6:	0c c0       	rjmp	.+24     	; 0x4310 <f_lseek+0x1d8>
    42f8:	8d 91       	ld	r24, X+
    42fa:	9c 91       	ld	r25, X
    42fc:	0e 94 ad 18 	call	0x315a	; 0x315a <create_chain>
    4300:	ab 01       	movw	r20, r22
    4302:	bc 01       	movw	r22, r24
    4304:	41 15       	cp	r20, r1
    4306:	51 05       	cpc	r21, r1
    4308:	61 05       	cpc	r22, r1
    430a:	71 05       	cpc	r23, r1
    430c:	41 f4       	brne	.+16     	; 0x431e <f_lseek+0x1e6>
    430e:	48 c0       	rjmp	.+144    	; 0x43a0 <f_lseek+0x268>
    4310:	f1 01       	movw	r30, r2
    4312:	80 81       	ld	r24, Z
    4314:	91 81       	ldd	r25, Z+1	; 0x01
    4316:	0e 94 ee 15 	call	0x2bdc	; 0x2bdc <get_fat>
    431a:	ab 01       	movw	r20, r22
    431c:	bc 01       	movw	r22, r24
    431e:	4f 3f       	cpi	r20, 0xFF	; 255
    4320:	ff ef       	ldi	r31, 0xFF	; 255
    4322:	5f 07       	cpc	r21, r31
    4324:	6f 07       	cpc	r22, r31
    4326:	7f 07       	cpc	r23, r31
    4328:	29 f4       	brne	.+10     	; 0x4334 <f_lseek+0x1fc>
    432a:	81 e0       	ldi	r24, 0x01	; 1
    432c:	d1 01       	movw	r26, r2
    432e:	15 96       	adiw	r26, 0x05	; 5
    4330:	8c 93       	st	X, r24
    4332:	a2 c0       	rjmp	.+324    	; 0x4478 <f_lseek+0x340>
    4334:	42 30       	cpi	r20, 0x02	; 2
    4336:	51 05       	cpc	r21, r1
    4338:	61 05       	cpc	r22, r1
    433a:	71 05       	cpc	r23, r1
    433c:	60 f0       	brcs	.+24     	; 0x4356 <f_lseek+0x21e>
    433e:	d1 01       	movw	r26, r2
    4340:	ed 91       	ld	r30, X+
    4342:	fc 91       	ld	r31, X
    4344:	82 89       	ldd	r24, Z+18	; 0x12
    4346:	93 89       	ldd	r25, Z+19	; 0x13
    4348:	a4 89       	ldd	r26, Z+20	; 0x14
    434a:	b5 89       	ldd	r27, Z+21	; 0x15
    434c:	48 17       	cp	r20, r24
    434e:	59 07       	cpc	r21, r25
    4350:	6a 07       	cpc	r22, r26
    4352:	7b 07       	cpc	r23, r27
    4354:	20 f0       	brcs	.+8      	; 0x435e <f_lseek+0x226>
    4356:	82 e0       	ldi	r24, 0x02	; 2
    4358:	f1 01       	movw	r30, r2
    435a:	85 83       	std	Z+5, r24	; 0x05
    435c:	8d c0       	rjmp	.+282    	; 0x4478 <f_lseek+0x340>
    435e:	d1 01       	movw	r26, r2
    4360:	52 96       	adiw	r26, 0x12	; 18
    4362:	4d 93       	st	X+, r20
    4364:	5d 93       	st	X+, r21
    4366:	6d 93       	st	X+, r22
    4368:	7c 93       	st	X, r23
    436a:	55 97       	sbiw	r26, 0x15	; 21
    436c:	16 96       	adiw	r26, 0x06	; 6
    436e:	8d 91       	ld	r24, X+
    4370:	9d 91       	ld	r25, X+
    4372:	0d 90       	ld	r0, X+
    4374:	bc 91       	ld	r27, X
    4376:	a0 2d       	mov	r26, r0
    4378:	88 0d       	add	r24, r8
    437a:	99 1d       	adc	r25, r9
    437c:	aa 1d       	adc	r26, r10
    437e:	bb 1d       	adc	r27, r11
    4380:	f1 01       	movw	r30, r2
    4382:	86 83       	std	Z+6, r24	; 0x06
    4384:	97 83       	std	Z+7, r25	; 0x07
    4386:	a0 87       	std	Z+8, r26	; 0x08
    4388:	b1 87       	std	Z+9, r27	; 0x09
    438a:	c8 18       	sub	r12, r8
    438c:	d9 08       	sbc	r13, r9
    438e:	ea 08       	sbc	r14, r10
    4390:	fb 08       	sbc	r15, r11
    4392:	8c 14       	cp	r8, r12
    4394:	9d 04       	cpc	r9, r13
    4396:	ae 04       	cpc	r10, r14
    4398:	bf 04       	cpc	r11, r15
    439a:	08 f4       	brcc	.+2      	; 0x439e <f_lseek+0x266>
    439c:	a7 cf       	rjmp	.-178    	; 0x42ec <f_lseek+0x1b4>
    439e:	02 c0       	rjmp	.+4      	; 0x43a4 <f_lseek+0x26c>
    43a0:	75 01       	movw	r14, r10
    43a2:	64 01       	movw	r12, r8
    43a4:	f1 01       	movw	r30, r2
    43a6:	86 81       	ldd	r24, Z+6	; 0x06
    43a8:	97 81       	ldd	r25, Z+7	; 0x07
    43aa:	a0 85       	ldd	r26, Z+8	; 0x08
    43ac:	b1 85       	ldd	r27, Z+9	; 0x09
    43ae:	8c 0d       	add	r24, r12
    43b0:	9d 1d       	adc	r25, r13
    43b2:	ae 1d       	adc	r26, r14
    43b4:	bf 1d       	adc	r27, r15
    43b6:	86 83       	std	Z+6, r24	; 0x06
    43b8:	97 83       	std	Z+7, r25	; 0x07
    43ba:	a0 87       	std	Z+8, r26	; 0x08
    43bc:	b1 87       	std	Z+9, r27	; 0x09
    43be:	d7 01       	movw	r26, r14
    43c0:	c6 01       	movw	r24, r12
    43c2:	91 70       	andi	r25, 0x01	; 1
    43c4:	aa 27       	eor	r26, r26
    43c6:	bb 27       	eor	r27, r27
    43c8:	89 2b       	or	r24, r25
    43ca:	8a 2b       	or	r24, r26
    43cc:	8b 2b       	or	r24, r27
    43ce:	01 f1       	breq	.+64     	; 0x4410 <f_lseek+0x2d8>
    43d0:	80 81       	ld	r24, Z
    43d2:	91 81       	ldd	r25, Z+1	; 0x01
    43d4:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <clust2sect>
    43d8:	61 15       	cp	r22, r1
    43da:	71 05       	cpc	r23, r1
    43dc:	81 05       	cpc	r24, r1
    43de:	91 05       	cpc	r25, r1
    43e0:	29 f4       	brne	.+10     	; 0x43ec <f_lseek+0x2b4>
    43e2:	82 e0       	ldi	r24, 0x02	; 2
    43e4:	d1 01       	movw	r26, r2
    43e6:	15 96       	adiw	r26, 0x05	; 5
    43e8:	8c 93       	st	X, r24
    43ea:	46 c0       	rjmp	.+140    	; 0x4478 <f_lseek+0x340>
    43ec:	0b 2e       	mov	r0, r27
    43ee:	b9 e0       	ldi	r27, 0x09	; 9
    43f0:	f6 94       	lsr	r15
    43f2:	e7 94       	ror	r14
    43f4:	d7 94       	ror	r13
    43f6:	c7 94       	ror	r12
    43f8:	ba 95       	dec	r27
    43fa:	d1 f7       	brne	.-12     	; 0x43f0 <f_lseek+0x2b8>
    43fc:	b0 2d       	mov	r27, r0
    43fe:	c6 0e       	add	r12, r22
    4400:	d7 1e       	adc	r13, r23
    4402:	e8 1e       	adc	r14, r24
    4404:	f9 1e       	adc	r15, r25
    4406:	07 c0       	rjmp	.+14     	; 0x4416 <f_lseek+0x2de>
    4408:	c1 2c       	mov	r12, r1
    440a:	d1 2c       	mov	r13, r1
    440c:	76 01       	movw	r14, r12
    440e:	03 c0       	rjmp	.+6      	; 0x4416 <f_lseek+0x2de>
    4410:	c1 2c       	mov	r12, r1
    4412:	d1 2c       	mov	r13, r1
    4414:	76 01       	movw	r14, r12
    4416:	f1 01       	movw	r30, r2
    4418:	86 81       	ldd	r24, Z+6	; 0x06
    441a:	97 81       	ldd	r25, Z+7	; 0x07
    441c:	a0 85       	ldd	r26, Z+8	; 0x08
    441e:	b1 85       	ldd	r27, Z+9	; 0x09
    4420:	ac 01       	movw	r20, r24
    4422:	bd 01       	movw	r22, r26
    4424:	51 70       	andi	r21, 0x01	; 1
    4426:	66 27       	eor	r22, r22
    4428:	77 27       	eor	r23, r23
    442a:	45 2b       	or	r20, r21
    442c:	46 2b       	or	r20, r22
    442e:	47 2b       	or	r20, r23
    4430:	69 f0       	breq	.+26     	; 0x444c <f_lseek+0x314>
    4432:	46 89       	ldd	r20, Z+22	; 0x16
    4434:	57 89       	ldd	r21, Z+23	; 0x17
    4436:	60 8d       	ldd	r22, Z+24	; 0x18
    4438:	71 8d       	ldd	r23, Z+25	; 0x19
    443a:	4c 15       	cp	r20, r12
    443c:	5d 05       	cpc	r21, r13
    443e:	6e 05       	cpc	r22, r14
    4440:	7f 05       	cpc	r23, r15
    4442:	21 f0       	breq	.+8      	; 0x444c <f_lseek+0x314>
    4444:	c6 8a       	std	Z+22, r12	; 0x16
    4446:	d7 8a       	std	Z+23, r13	; 0x17
    4448:	e0 8e       	std	Z+24, r14	; 0x18
    444a:	f1 8e       	std	Z+25, r15	; 0x19
    444c:	f1 01       	movw	r30, r2
    444e:	42 85       	ldd	r20, Z+10	; 0x0a
    4450:	53 85       	ldd	r21, Z+11	; 0x0b
    4452:	64 85       	ldd	r22, Z+12	; 0x0c
    4454:	75 85       	ldd	r23, Z+13	; 0x0d
    4456:	48 17       	cp	r20, r24
    4458:	59 07       	cpc	r21, r25
    445a:	6a 07       	cpc	r22, r26
    445c:	7b 07       	cpc	r23, r27
    445e:	58 f4       	brcc	.+22     	; 0x4476 <f_lseek+0x33e>
    4460:	82 87       	std	Z+10, r24	; 0x0a
    4462:	93 87       	std	Z+11, r25	; 0x0b
    4464:	a4 87       	std	Z+12, r26	; 0x0c
    4466:	b5 87       	std	Z+13, r27	; 0x0d
    4468:	84 81       	ldd	r24, Z+4	; 0x04
    446a:	80 62       	ori	r24, 0x20	; 32
    446c:	84 83       	std	Z+4, r24	; 0x04
    446e:	80 e0       	ldi	r24, 0x00	; 0
    4470:	03 c0       	rjmp	.+6      	; 0x4478 <f_lseek+0x340>
    4472:	80 e0       	ldi	r24, 0x00	; 0
    4474:	01 c0       	rjmp	.+2      	; 0x4478 <f_lseek+0x340>
    4476:	80 e0       	ldi	r24, 0x00	; 0
    4478:	0f 90       	pop	r0
    447a:	0f 90       	pop	r0
    447c:	0f 90       	pop	r0
    447e:	0f 90       	pop	r0
    4480:	df 91       	pop	r29
    4482:	cf 91       	pop	r28
    4484:	1f 91       	pop	r17
    4486:	0f 91       	pop	r16
    4488:	ff 90       	pop	r15
    448a:	ef 90       	pop	r14
    448c:	df 90       	pop	r13
    448e:	cf 90       	pop	r12
    4490:	bf 90       	pop	r11
    4492:	af 90       	pop	r10
    4494:	9f 90       	pop	r9
    4496:	8f 90       	pop	r8
    4498:	7f 90       	pop	r7
    449a:	6f 90       	pop	r6
    449c:	5f 90       	pop	r5
    449e:	4f 90       	pop	r4
    44a0:	3f 90       	pop	r3
    44a2:	2f 90       	pop	r2
    44a4:	08 95       	ret

000044a6 <f_stat>:

FRESULT f_stat (
	const TCHAR* path,	/* Pointer to the file path */
	FILINFO* fno		/* Pointer to file information to return */
)
{
    44a6:	ef 92       	push	r14
    44a8:	ff 92       	push	r15
    44aa:	1f 93       	push	r17
    44ac:	cf 93       	push	r28
    44ae:	df 93       	push	r29
    44b0:	cd b7       	in	r28, 0x3d	; 61
    44b2:	de b7       	in	r29, 0x3e	; 62
    44b4:	a4 97       	sbiw	r28, 0x24	; 36
    44b6:	0f b6       	in	r0, 0x3f	; 63
    44b8:	f8 94       	cli
    44ba:	de bf       	out	0x3e, r29	; 62
    44bc:	0f be       	out	0x3f, r0	; 63
    44be:	cd bf       	out	0x3d, r28	; 61
    44c0:	9c a3       	std	Y+36, r25	; 0x24
    44c2:	8b a3       	std	Y+35, r24	; 0x23
    44c4:	7b 01       	movw	r14, r22
	DIR dj;
	DEF_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
    44c6:	40 e0       	ldi	r20, 0x00	; 0
    44c8:	be 01       	movw	r22, r28
    44ca:	6d 5d       	subi	r22, 0xDD	; 221
    44cc:	7f 4f       	sbci	r23, 0xFF	; 255
    44ce:	ce 01       	movw	r24, r28
    44d0:	01 96       	adiw	r24, 0x01	; 1
    44d2:	0e 94 72 12 	call	0x24e4	; 0x24e4 <find_volume>
    44d6:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    44d8:	81 11       	cpse	r24, r1
    44da:	19 c0       	rjmp	.+50     	; 0x450e <f_stat+0x68>
		INIT_BUF(dj);
    44dc:	ce 01       	movw	r24, r28
    44de:	47 96       	adiw	r24, 0x17	; 23
    44e0:	9e 8b       	std	Y+22, r25	; 0x16
    44e2:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    44e4:	6b a1       	ldd	r22, Y+35	; 0x23
    44e6:	7c a1       	ldd	r23, Y+36	; 0x24
    44e8:	46 97       	sbiw	r24, 0x16	; 22
    44ea:	81 d8       	rcall	.-3838   	; 0x35ee <follow_path>
    44ec:	18 2f       	mov	r17, r24
		if (res == FR_OK) {				/* Follow completed */
    44ee:	81 11       	cpse	r24, r1
    44f0:	0e c0       	rjmp	.+28     	; 0x450e <f_stat+0x68>
			if (dj.dir) {		/* Found an object */
    44f2:	8b 89       	ldd	r24, Y+19	; 0x13
    44f4:	9c 89       	ldd	r25, Y+20	; 0x14
    44f6:	89 2b       	or	r24, r25
    44f8:	49 f0       	breq	.+18     	; 0x450c <f_stat+0x66>
				if (fno) get_fileinfo(&dj, fno);
    44fa:	e1 14       	cp	r14, r1
    44fc:	f1 04       	cpc	r15, r1
    44fe:	39 f0       	breq	.+14     	; 0x450e <f_stat+0x68>
    4500:	b7 01       	movw	r22, r14
    4502:	ce 01       	movw	r24, r28
    4504:	01 96       	adiw	r24, 0x01	; 1
    4506:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <get_fileinfo>
    450a:	01 c0       	rjmp	.+2      	; 0x450e <f_stat+0x68>
			} else {			/* It is root directory */
				res = FR_INVALID_NAME;
    450c:	16 e0       	ldi	r17, 0x06	; 6
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    450e:	81 2f       	mov	r24, r17
    4510:	a4 96       	adiw	r28, 0x24	; 36
    4512:	0f b6       	in	r0, 0x3f	; 63
    4514:	f8 94       	cli
    4516:	de bf       	out	0x3e, r29	; 62
    4518:	0f be       	out	0x3f, r0	; 63
    451a:	cd bf       	out	0x3d, r28	; 61
    451c:	df 91       	pop	r29
    451e:	cf 91       	pop	r28
    4520:	1f 91       	pop	r17
    4522:	ff 90       	pop	r15
    4524:	ef 90       	pop	r14
    4526:	08 95       	ret

00004528 <SCSI_Command_ReadWrite_10>:
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_ReadWrite_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                      const bool IsDataRead)
{
    4528:	bf 92       	push	r11
    452a:	cf 92       	push	r12
    452c:	df 92       	push	r13
    452e:	ef 92       	push	r14
    4530:	ff 92       	push	r15
    4532:	0f 93       	push	r16
    4534:	1f 93       	push	r17
    4536:	cf 93       	push	r28
    4538:	df 93       	push	r29
    453a:	ec 01       	movw	r28, r24
    453c:	b6 2e       	mov	r11, r22

				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
    453e:	c8 a0       	ldd	r12, Y+32	; 0x20
    4540:	df 8c       	ldd	r13, Y+31	; 0x1f
    4542:	ee 8c       	ldd	r14, Y+30	; 0x1e
    4544:	fd 8c       	ldd	r15, Y+29	; 0x1d

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
    4546:	0b a1       	ldd	r16, Y+35	; 0x23
    4548:	1a a1       	ldd	r17, Y+34	; 0x22

	/* Load in the 16-bit total blocks (SCSI uses big-endian, so have to reverse the byte order) */
	TotalBlocks  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[7]);

	/* Check if the block address is outside the maximum allowable value for the LUN */
	if (BlockAddress >= get_num_of_sectors())
    454a:	0e 94 06 0b 	call	0x160c	; 0x160c <get_num_of_sectors>
    454e:	c6 16       	cp	r12, r22
    4550:	d7 06       	cpc	r13, r23
    4552:	e8 06       	cpc	r14, r24
    4554:	f9 06       	cpc	r15, r25
    4556:	68 f0       	brcs	.+26     	; 0x4572 <SCSI_Command_ReadWrite_10+0x4a>
	{
		/* Block address is invalid, update SENSE key and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    4558:	e0 e1       	ldi	r30, 0x10	; 16
    455a:	f1 e0       	ldi	r31, 0x01	; 1
    455c:	80 81       	ld	r24, Z
    455e:	80 7f       	andi	r24, 0xF0	; 240
    4560:	85 60       	ori	r24, 0x05	; 5
    4562:	80 83       	st	Z, r24
    4564:	ee e0       	ldi	r30, 0x0E	; 14
    4566:	f1 e0       	ldi	r31, 0x01	; 1
    4568:	81 e2       	ldi	r24, 0x21	; 33
    456a:	84 87       	std	Z+12, r24	; 0x0c
    456c:	15 86       	std	Z+13, r1	; 0x0d
		               SCSI_ASENSE_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
    456e:	80 e0       	ldi	r24, 0x00	; 0
    4570:	28 c0       	rjmp	.+80     	; 0x45c2 <SCSI_Command_ReadWrite_10+0x9a>
	}

	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
    4572:	bb 20       	and	r11, r11
    4574:	31 f0       	breq	.+12     	; 0x4582 <SCSI_Command_ReadWrite_10+0x5a>
	  //SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
	  SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
    4576:	98 01       	movw	r18, r16
    4578:	b7 01       	movw	r22, r14
    457a:	a6 01       	movw	r20, r12
    457c:	ce 01       	movw	r24, r28
    457e:	bf d2       	rcall	.+1406   	; 0x4afe <SDCardManager_ReadBlocks>
    4580:	05 c0       	rjmp	.+10     	; 0x458c <SCSI_Command_ReadWrite_10+0x64>
	else
	  SDCardManager_WriteBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
    4582:	98 01       	movw	r18, r16
    4584:	b7 01       	movw	r22, r14
    4586:	a6 01       	movw	r20, r12
    4588:	ce 01       	movw	r24, r28
    458a:	1b d2       	rcall	.+1078   	; 0x49c2 <SDCardManager_WriteBlocks>

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= ((uint32_t)TotalBlocks * VIRTUAL_MEMORY_BLOCK_SIZE);
    458c:	c8 01       	movw	r24, r16
    458e:	a0 e0       	ldi	r26, 0x00	; 0
    4590:	b0 e0       	ldi	r27, 0x00	; 0
    4592:	07 2e       	mov	r0, r23
    4594:	79 e0       	ldi	r23, 0x09	; 9
    4596:	88 0f       	add	r24, r24
    4598:	99 1f       	adc	r25, r25
    459a:	aa 1f       	adc	r26, r26
    459c:	bb 1f       	adc	r27, r27
    459e:	7a 95       	dec	r23
    45a0:	d1 f7       	brne	.-12     	; 0x4596 <SCSI_Command_ReadWrite_10+0x6e>
    45a2:	70 2d       	mov	r23, r0
    45a4:	4c 89       	ldd	r20, Y+20	; 0x14
    45a6:	5d 89       	ldd	r21, Y+21	; 0x15
    45a8:	6e 89       	ldd	r22, Y+22	; 0x16
    45aa:	7f 89       	ldd	r23, Y+23	; 0x17
    45ac:	8a 01       	movw	r16, r20
    45ae:	9b 01       	movw	r18, r22
    45b0:	08 1b       	sub	r16, r24
    45b2:	19 0b       	sbc	r17, r25
    45b4:	2a 0b       	sbc	r18, r26
    45b6:	3b 0b       	sbc	r19, r27
    45b8:	0c 8b       	std	Y+20, r16	; 0x14
    45ba:	1d 8b       	std	Y+21, r17	; 0x15
    45bc:	2e 8b       	std	Y+22, r18	; 0x16
    45be:	3f 8b       	std	Y+23, r19	; 0x17

	return true;
    45c0:	81 e0       	ldi	r24, 0x01	; 1
}
    45c2:	df 91       	pop	r29
    45c4:	cf 91       	pop	r28
    45c6:	1f 91       	pop	r17
    45c8:	0f 91       	pop	r16
    45ca:	ff 90       	pop	r15
    45cc:	ef 90       	pop	r14
    45ce:	df 90       	pop	r13
    45d0:	cf 90       	pop	r12
    45d2:	bf 90       	pop	r11
    45d4:	08 95       	ret

000045d6 <SCSI_DecodeSCSICommand>:
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise
 */
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    45d6:	cf 92       	push	r12
    45d8:	df 92       	push	r13
    45da:	ef 92       	push	r14
    45dc:	ff 92       	push	r15
    45de:	0f 93       	push	r16
    45e0:	1f 93       	push	r17
    45e2:	cf 93       	push	r28
    45e4:	df 93       	push	r29
    45e6:	cd b7       	in	r28, 0x3d	; 61
    45e8:	de b7       	in	r29, 0x3e	; 62
    45ea:	28 97       	sbiw	r28, 0x08	; 8
    45ec:	0f b6       	in	r0, 0x3f	; 63
    45ee:	f8 94       	cli
    45f0:	de bf       	out	0x3e, r29	; 62
    45f2:	0f be       	out	0x3f, r0	; 63
    45f4:	cd bf       	out	0x3d, r28	; 61
    45f6:	8c 01       	movw	r16, r24
	bool CommandSuccess = false;



	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
    45f8:	fc 01       	movw	r30, r24
    45fa:	93 8d       	ldd	r25, Z+27	; 0x1b
    45fc:	9d 31       	cpi	r25, 0x1D	; 29
    45fe:	09 f4       	brne	.+2      	; 0x4602 <SCSI_DecodeSCSICommand+0x2c>
    4600:	db c0       	rjmp	.+438    	; 0x47b8 <SCSI_DecodeSCSICommand+0x1e2>
    4602:	88 f4       	brcc	.+34     	; 0x4626 <SCSI_DecodeSCSICommand+0x50>
    4604:	92 31       	cpi	r25, 0x12	; 18
    4606:	09 f1       	breq	.+66     	; 0x464a <SCSI_DecodeSCSICommand+0x74>
    4608:	38 f4       	brcc	.+14     	; 0x4618 <SCSI_DecodeSCSICommand+0x42>
    460a:	99 23       	and	r25, r25
    460c:	09 f4       	brne	.+2      	; 0x4610 <SCSI_DecodeSCSICommand+0x3a>
    460e:	46 c1       	rjmp	.+652    	; 0x489c <SCSI_DecodeSCSICommand+0x2c6>
    4610:	93 30       	cpi	r25, 0x03	; 3
    4612:	09 f4       	brne	.+2      	; 0x4616 <SCSI_DecodeSCSICommand+0x40>
    4614:	5a c0       	rjmp	.+180    	; 0x46ca <SCSI_DecodeSCSICommand+0xf4>
    4616:	5c c1       	rjmp	.+696    	; 0x48d0 <SCSI_DecodeSCSICommand+0x2fa>
    4618:	9a 31       	cpi	r25, 0x1A	; 26
    461a:	09 f4       	brne	.+2      	; 0x461e <SCSI_DecodeSCSICommand+0x48>
    461c:	21 c1       	rjmp	.+578    	; 0x4860 <SCSI_DecodeSCSICommand+0x28a>
    461e:	9b 31       	cpi	r25, 0x1B	; 27
    4620:	09 f4       	brne	.+2      	; 0x4624 <SCSI_DecodeSCSICommand+0x4e>
    4622:	36 c1       	rjmp	.+620    	; 0x4890 <SCSI_DecodeSCSICommand+0x2ba>
    4624:	55 c1       	rjmp	.+682    	; 0x48d0 <SCSI_DecodeSCSICommand+0x2fa>
    4626:	98 32       	cpi	r25, 0x28	; 40
    4628:	09 f4       	brne	.+2      	; 0x462c <SCSI_DecodeSCSICommand+0x56>
    462a:	02 c1       	rjmp	.+516    	; 0x4830 <SCSI_DecodeSCSICommand+0x25a>
    462c:	38 f4       	brcc	.+14     	; 0x463c <SCSI_DecodeSCSICommand+0x66>
    462e:	9e 31       	cpi	r25, 0x1E	; 30
    4630:	09 f4       	brne	.+2      	; 0x4634 <SCSI_DecodeSCSICommand+0x5e>
    4632:	2e c1       	rjmp	.+604    	; 0x4890 <SCSI_DecodeSCSICommand+0x2ba>
    4634:	95 32       	cpi	r25, 0x25	; 37
    4636:	09 f4       	brne	.+2      	; 0x463a <SCSI_DecodeSCSICommand+0x64>
    4638:	76 c0       	rjmp	.+236    	; 0x4726 <SCSI_DecodeSCSICommand+0x150>
    463a:	4a c1       	rjmp	.+660    	; 0x48d0 <SCSI_DecodeSCSICommand+0x2fa>
    463c:	9a 32       	cpi	r25, 0x2A	; 42
    463e:	09 f4       	brne	.+2      	; 0x4642 <SCSI_DecodeSCSICommand+0x6c>
    4640:	df c0       	rjmp	.+446    	; 0x4800 <SCSI_DecodeSCSICommand+0x22a>
    4642:	9f 32       	cpi	r25, 0x2F	; 47
    4644:	09 f4       	brne	.+2      	; 0x4648 <SCSI_DecodeSCSICommand+0x72>
    4646:	24 c1       	rjmp	.+584    	; 0x4890 <SCSI_DecodeSCSICommand+0x2ba>
    4648:	43 c1       	rjmp	.+646    	; 0x48d0 <SCSI_DecodeSCSICommand+0x2fa>
    464a:	f8 01       	movw	r30, r16
    464c:	e7 8c       	ldd	r14, Z+31	; 0x1f
    464e:	f6 8c       	ldd	r15, Z+30	; 0x1e
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));

	/* Only the standard INQUIRY data is supported, check if any optional INQUIRY bits set */
	if ((MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & ((1 << 0) | (1 << 1))) ||
    4650:	94 8d       	ldd	r25, Z+28	; 0x1c
    4652:	93 70       	andi	r25, 0x03	; 3
    4654:	19 f4       	brne	.+6      	; 0x465c <SCSI_DecodeSCSICommand+0x86>
    4656:	85 8d       	ldd	r24, Z+29	; 0x1d
    4658:	88 23       	and	r24, r24
    465a:	61 f0       	breq	.+24     	; 0x4674 <SCSI_DecodeSCSICommand+0x9e>
	     MSInterfaceInfo->State.CommandBlock.SCSICommandData[2])
	{
		/* Optional but unsupported bits set - update the SENSE key and fail the request */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    465c:	e0 e1       	ldi	r30, 0x10	; 16
    465e:	f1 e0       	ldi	r31, 0x01	; 1
    4660:	80 81       	ld	r24, Z
    4662:	80 7f       	andi	r24, 0xF0	; 240
    4664:	85 60       	ori	r24, 0x05	; 5
    4666:	80 83       	st	Z, r24
    4668:	ee e0       	ldi	r30, 0x0E	; 14
    466a:	f1 e0       	ldi	r31, 0x01	; 1
    466c:	84 e2       	ldi	r24, 0x24	; 36
    466e:	84 87       	std	Z+12, r24	; 0x0c
    4670:	15 86       	std	Z+13, r1	; 0x0d
    4672:	49 c1       	rjmp	.+658    	; 0x4906 <SCSI_DecodeSCSICommand+0x330>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));
    4674:	67 01       	movw	r12, r14
    4676:	f5 e2       	ldi	r31, 0x25	; 37
    4678:	ef 16       	cp	r14, r31
    467a:	f1 04       	cpc	r15, r1
    467c:	28 f0       	brcs	.+10     	; 0x4688 <SCSI_DecodeSCSICommand+0xb2>
    467e:	0f 2e       	mov	r0, r31
    4680:	f4 e2       	ldi	r31, 0x24	; 36
    4682:	cf 2e       	mov	r12, r31
    4684:	d1 2c       	mov	r13, r1
    4686:	f0 2d       	mov	r31, r0
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
	}

	Endpoint_Write_Stream_LE(&InquiryData, BytesTransferred, NULL);
    4688:	40 e0       	ldi	r20, 0x00	; 0
    468a:	50 e0       	ldi	r21, 0x00	; 0
    468c:	b6 01       	movw	r22, r12
    468e:	87 e8       	ldi	r24, 0x87	; 135
    4690:	93 e0       	ldi	r25, 0x03	; 3
    4692:	0e 94 69 32 	call	0x64d2	; 0x64d2 <Endpoint_Write_Stream_LE>

	/* Pad out remaining bytes with 0x00 */
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
    4696:	60 e0       	ldi	r22, 0x00	; 0
    4698:	70 e0       	ldi	r23, 0x00	; 0
    469a:	c7 01       	movw	r24, r14
    469c:	8c 19       	sub	r24, r12
    469e:	9d 09       	sbc	r25, r13
    46a0:	0e 94 1a 32 	call	0x6434	; 0x6434 <Endpoint_Null_Stream>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    46a4:	e8 ee       	ldi	r30, 0xE8	; 232
    46a6:	f0 e0       	ldi	r31, 0x00	; 0
    46a8:	80 81       	ld	r24, Z
    46aa:	8e 77       	andi	r24, 0x7E	; 126
    46ac:	80 83       	st	Z, r24

	/* Finalize the stream transfer to send the last packet */
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
    46ae:	f8 01       	movw	r30, r16
    46b0:	84 89       	ldd	r24, Z+20	; 0x14
    46b2:	95 89       	ldd	r25, Z+21	; 0x15
    46b4:	a6 89       	ldd	r26, Z+22	; 0x16
    46b6:	b7 89       	ldd	r27, Z+23	; 0x17
    46b8:	8c 19       	sub	r24, r12
    46ba:	9d 09       	sbc	r25, r13
    46bc:	a1 09       	sbc	r26, r1
    46be:	b1 09       	sbc	r27, r1
    46c0:	84 8b       	std	Z+20, r24	; 0x14
    46c2:	95 8b       	std	Z+21, r25	; 0x15
    46c4:	a6 8b       	std	Z+22, r26	; 0x16
    46c6:	b7 8b       	std	Z+23, r27	; 0x17
    46c8:	11 c1       	rjmp	.+546    	; 0x48ec <SCSI_DecodeSCSICommand+0x316>
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint8_t  AllocationLength = MSInterfaceInfo->State.CommandBlock.SCSICommandData[4];
    46ca:	f8 01       	movw	r30, r16
    46cc:	f7 8c       	ldd	r15, Z+31	; 0x1f
	uint8_t  BytesTransferred = MIN(AllocationLength, sizeof(SenseData));
    46ce:	ef 2c       	mov	r14, r15
    46d0:	f2 e1       	ldi	r31, 0x12	; 18
    46d2:	ff 15       	cp	r31, r15
    46d4:	20 f4       	brcc	.+8      	; 0x46de <SCSI_DecodeSCSICommand+0x108>
    46d6:	0f 2e       	mov	r0, r31
    46d8:	f2 e1       	ldi	r31, 0x12	; 18
    46da:	ef 2e       	mov	r14, r31
    46dc:	f0 2d       	mov	r31, r0

	Endpoint_Write_Stream_LE(&SenseData, BytesTransferred, NULL);
    46de:	ce 2c       	mov	r12, r14
    46e0:	d1 2c       	mov	r13, r1
    46e2:	40 e0       	ldi	r20, 0x00	; 0
    46e4:	50 e0       	ldi	r21, 0x00	; 0
    46e6:	b6 01       	movw	r22, r12
    46e8:	8e e0       	ldi	r24, 0x0E	; 14
    46ea:	91 e0       	ldi	r25, 0x01	; 1
    46ec:	0e 94 69 32 	call	0x64d2	; 0x64d2 <Endpoint_Write_Stream_LE>
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
    46f0:	8f 2d       	mov	r24, r15
    46f2:	90 e0       	ldi	r25, 0x00	; 0
    46f4:	60 e0       	ldi	r22, 0x00	; 0
    46f6:	70 e0       	ldi	r23, 0x00	; 0
    46f8:	8c 19       	sub	r24, r12
    46fa:	9d 09       	sbc	r25, r13
    46fc:	0e 94 1a 32 	call	0x6434	; 0x6434 <Endpoint_Null_Stream>
    4700:	e8 ee       	ldi	r30, 0xE8	; 232
    4702:	f0 e0       	ldi	r31, 0x00	; 0
    4704:	80 81       	ld	r24, Z
    4706:	8e 77       	andi	r24, 0x7E	; 126
    4708:	80 83       	st	Z, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
    470a:	f8 01       	movw	r30, r16
    470c:	84 89       	ldd	r24, Z+20	; 0x14
    470e:	95 89       	ldd	r25, Z+21	; 0x15
    4710:	a6 89       	ldd	r26, Z+22	; 0x16
    4712:	b7 89       	ldd	r27, Z+23	; 0x17
    4714:	8e 19       	sub	r24, r14
    4716:	91 09       	sbc	r25, r1
    4718:	a1 09       	sbc	r26, r1
    471a:	b1 09       	sbc	r27, r1
    471c:	84 8b       	std	Z+20, r24	; 0x14
    471e:	95 8b       	std	Z+21, r25	; 0x15
    4720:	a6 8b       	std	Z+22, r26	; 0x16
    4722:	b7 8b       	std	Z+23, r27	; 0x17
		case SCSI_CMD_INQUIRY:
			CommandSuccess = SCSI_Command_Inquiry(MSInterfaceInfo);
			break;
		case SCSI_CMD_REQUEST_SENSE:
			CommandSuccess = SCSI_Command_Request_Sense(MSInterfaceInfo);
			break;
    4724:	e3 c0       	rjmp	.+454    	; 0x48ec <SCSI_DecodeSCSICommand+0x316>
		case SCSI_CMD_READ_CAPACITY_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    4726:	4a d2       	rcall	.+1172   	; 0x4bbc <SDCardManager_CheckSDCardOperation>
    4728:	88 23       	and	r24, r24
    472a:	21 f0       	breq	.+8      	; 0x4734 <SCSI_DecodeSCSICommand+0x15e>
    472c:	80 91 09 08 	lds	r24, 0x0809
    4730:	81 30       	cpi	r24, 0x01	; 1
    4732:	69 f0       	breq	.+26     	; 0x474e <SCSI_DecodeSCSICommand+0x178>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
    4734:	e0 e1       	ldi	r30, 0x10	; 16
    4736:	f1 e0       	ldi	r31, 0x01	; 1
    4738:	80 81       	ld	r24, Z
    473a:	80 7f       	andi	r24, 0xF0	; 240
    473c:	82 60       	ori	r24, 0x02	; 2
    473e:	80 83       	st	Z, r24
    4740:	ee e0       	ldi	r30, 0x0E	; 14
    4742:	f1 e0       	ldi	r31, 0x01	; 1
    4744:	8a e3       	ldi	r24, 0x3A	; 58
    4746:	84 87       	std	Z+12, r24	; 0x0c
    4748:	15 86       	std	Z+13, r1	; 0x0d
				return false; //return with an error flag -- send a failure response to host.
    474a:	80 e0       	ldi	r24, 0x00	; 0
    474c:	dd c0       	rjmp	.+442    	; 0x4908 <SCSI_DecodeSCSICommand+0x332>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Read_Capacity_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint32_t LastBlockAddressInLUN;
	uint32_t MediaBlockSize        = VIRTUAL_MEMORY_BLOCK_SIZE;
    474e:	80 e0       	ldi	r24, 0x00	; 0
    4750:	92 e0       	ldi	r25, 0x02	; 2
    4752:	a0 e0       	ldi	r26, 0x00	; 0
    4754:	b0 e0       	ldi	r27, 0x00	; 0
    4756:	89 83       	std	Y+1, r24	; 0x01
    4758:	9a 83       	std	Y+2, r25	; 0x02
    475a:	ab 83       	std	Y+3, r26	; 0x03
    475c:	bc 83       	std	Y+4, r27	; 0x04

	LastBlockAddressInLUN = get_num_of_sectors()-1;
    475e:	0e 94 06 0b 	call	0x160c	; 0x160c <get_num_of_sectors>
    4762:	dc 01       	movw	r26, r24
    4764:	cb 01       	movw	r24, r22
    4766:	01 97       	sbiw	r24, 0x01	; 1
    4768:	a1 09       	sbc	r26, r1
    476a:	b1 09       	sbc	r27, r1
    476c:	8d 83       	std	Y+5, r24	; 0x05
    476e:	9e 83       	std	Y+6, r25	; 0x06
    4770:	af 83       	std	Y+7, r26	; 0x07
    4772:	b8 87       	std	Y+8, r27	; 0x08

	Endpoint_Write_Stream_BE(&LastBlockAddressInLUN, sizeof(LastBlockAddressInLUN), NULL);
    4774:	40 e0       	ldi	r20, 0x00	; 0
    4776:	50 e0       	ldi	r21, 0x00	; 0
    4778:	64 e0       	ldi	r22, 0x04	; 4
    477a:	70 e0       	ldi	r23, 0x00	; 0
    477c:	ce 01       	movw	r24, r28
    477e:	05 96       	adiw	r24, 0x05	; 5
    4780:	0e 94 c6 32 	call	0x658c	; 0x658c <Endpoint_Write_Stream_BE>
	Endpoint_Write_Stream_BE(&MediaBlockSize, sizeof(MediaBlockSize), NULL);
    4784:	40 e0       	ldi	r20, 0x00	; 0
    4786:	50 e0       	ldi	r21, 0x00	; 0
    4788:	64 e0       	ldi	r22, 0x04	; 4
    478a:	70 e0       	ldi	r23, 0x00	; 0
    478c:	ce 01       	movw	r24, r28
    478e:	01 96       	adiw	r24, 0x01	; 1
    4790:	0e 94 c6 32 	call	0x658c	; 0x658c <Endpoint_Write_Stream_BE>
    4794:	e8 ee       	ldi	r30, 0xE8	; 232
    4796:	f0 e0       	ldi	r31, 0x00	; 0
    4798:	80 81       	ld	r24, Z
    479a:	8e 77       	andi	r24, 0x7E	; 126
    479c:	80 83       	st	Z, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 8;
    479e:	f8 01       	movw	r30, r16
    47a0:	84 89       	ldd	r24, Z+20	; 0x14
    47a2:	95 89       	ldd	r25, Z+21	; 0x15
    47a4:	a6 89       	ldd	r26, Z+22	; 0x16
    47a6:	b7 89       	ldd	r27, Z+23	; 0x17
    47a8:	08 97       	sbiw	r24, 0x08	; 8
    47aa:	a1 09       	sbc	r26, r1
    47ac:	b1 09       	sbc	r27, r1
    47ae:	84 8b       	std	Z+20, r24	; 0x14
    47b0:	95 8b       	std	Z+21, r25	; 0x15
    47b2:	a6 8b       	std	Z+22, r26	; 0x16
    47b4:	b7 8b       	std	Z+23, r27	; 0x17
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
				return false; //return with an error flag -- send a failure response to host.
			}
			CommandSuccess = SCSI_Command_Read_Capacity_10(MSInterfaceInfo);
			break;
    47b6:	9a c0       	rjmp	.+308    	; 0x48ec <SCSI_DecodeSCSICommand+0x316>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Send_Diagnostic(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	/* Check to see if the SELF TEST bit is not set */
	if (!(MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & (1 << 2)))
    47b8:	f8 01       	movw	r30, r16
    47ba:	84 8d       	ldd	r24, Z+28	; 0x1c
    47bc:	82 fd       	sbrc	r24, 2
    47be:	0c c0       	rjmp	.+24     	; 0x47d8 <SCSI_DecodeSCSICommand+0x202>
	{
		/* Only self-test supported - update SENSE key and fail the command */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    47c0:	e0 e1       	ldi	r30, 0x10	; 16
    47c2:	f1 e0       	ldi	r31, 0x01	; 1
    47c4:	80 81       	ld	r24, Z
    47c6:	80 7f       	andi	r24, 0xF0	; 240
    47c8:	85 60       	ori	r24, 0x05	; 5
    47ca:	80 83       	st	Z, r24
    47cc:	ee e0       	ldi	r30, 0x0E	; 14
    47ce:	f1 e0       	ldi	r31, 0x01	; 1
    47d0:	84 e2       	ldi	r24, 0x24	; 36
    47d2:	84 87       	std	Z+12, r24	; 0x0c
    47d4:	15 86       	std	Z+13, r1	; 0x0d
    47d6:	97 c0       	rjmp	.+302    	; 0x4906 <SCSI_DecodeSCSICommand+0x330>

		return false;
	}

	/* Check to see if all attached Dataflash ICs are functional */
	if (!(SDCardManager_CheckSDCardOperation()))
    47d8:	f1 d1       	rcall	.+994    	; 0x4bbc <SDCardManager_CheckSDCardOperation>
    47da:	81 11       	cpse	r24, r1
    47dc:	0b c0       	rjmp	.+22     	; 0x47f4 <SCSI_DecodeSCSICommand+0x21e>
	{
		/* Update SENSE key with a hardware error condition and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_HARDWARE_ERROR,
    47de:	e0 e1       	ldi	r30, 0x10	; 16
    47e0:	f1 e0       	ldi	r31, 0x01	; 1
    47e2:	80 81       	ld	r24, Z
    47e4:	80 7f       	andi	r24, 0xF0	; 240
    47e6:	84 60       	ori	r24, 0x04	; 4
    47e8:	80 83       	st	Z, r24
    47ea:	ee e0       	ldi	r30, 0x0E	; 14
    47ec:	f1 e0       	ldi	r31, 0x01	; 1
    47ee:	14 86       	std	Z+12, r1	; 0x0c
    47f0:	15 86       	std	Z+13, r1	; 0x0d
    47f2:	89 c0       	rjmp	.+274    	; 0x4906 <SCSI_DecodeSCSICommand+0x330>

		return false;
	}

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
    47f4:	f8 01       	movw	r30, r16
    47f6:	14 8a       	std	Z+20, r1	; 0x14
    47f8:	15 8a       	std	Z+21, r1	; 0x15
    47fa:	16 8a       	std	Z+22, r1	; 0x16
    47fc:	17 8a       	std	Z+23, r1	; 0x17
    47fe:	76 c0       	rjmp	.+236    	; 0x48ec <SCSI_DecodeSCSICommand+0x316>
			break;
		case SCSI_CMD_SEND_DIAGNOSTIC:
			CommandSuccess = SCSI_Command_Send_Diagnostic(MSInterfaceInfo);
			break;
		case SCSI_CMD_WRITE_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    4800:	dd d1       	rcall	.+954    	; 0x4bbc <SDCardManager_CheckSDCardOperation>
    4802:	88 23       	and	r24, r24
    4804:	21 f0       	breq	.+8      	; 0x480e <SCSI_DecodeSCSICommand+0x238>
    4806:	80 91 09 08 	lds	r24, 0x0809
    480a:	81 30       	cpi	r24, 0x01	; 1
    480c:	69 f0       	breq	.+26     	; 0x4828 <SCSI_DecodeSCSICommand+0x252>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
    480e:	e0 e1       	ldi	r30, 0x10	; 16
    4810:	f1 e0       	ldi	r31, 0x01	; 1
    4812:	80 81       	ld	r24, Z
    4814:	80 7f       	andi	r24, 0xF0	; 240
    4816:	82 60       	ori	r24, 0x02	; 2
    4818:	80 83       	st	Z, r24
    481a:	ee e0       	ldi	r30, 0x0E	; 14
    481c:	f1 e0       	ldi	r31, 0x01	; 1
    481e:	8a e3       	ldi	r24, 0x3A	; 58
    4820:	84 87       	std	Z+12, r24	; 0x0c
    4822:	15 86       	std	Z+13, r1	; 0x0d
				return false; //return with an error flag -- send a failure response to host.
    4824:	80 e0       	ldi	r24, 0x00	; 0
    4826:	70 c0       	rjmp	.+224    	; 0x4908 <SCSI_DecodeSCSICommand+0x332>
			}
			
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_WRITE);
    4828:	60 e0       	ldi	r22, 0x00	; 0
    482a:	c8 01       	movw	r24, r16
    482c:	7d de       	rcall	.-774    	; 0x4528 <SCSI_Command_ReadWrite_10>
			break;
    482e:	5c c0       	rjmp	.+184    	; 0x48e8 <SCSI_DecodeSCSICommand+0x312>
		case SCSI_CMD_READ_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    4830:	c5 d1       	rcall	.+906    	; 0x4bbc <SDCardManager_CheckSDCardOperation>
    4832:	88 23       	and	r24, r24
    4834:	21 f0       	breq	.+8      	; 0x483e <SCSI_DecodeSCSICommand+0x268>
    4836:	80 91 09 08 	lds	r24, 0x0809
    483a:	81 30       	cpi	r24, 0x01	; 1
    483c:	69 f0       	breq	.+26     	; 0x4858 <SCSI_DecodeSCSICommand+0x282>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
    483e:	e0 e1       	ldi	r30, 0x10	; 16
    4840:	f1 e0       	ldi	r31, 0x01	; 1
    4842:	80 81       	ld	r24, Z
    4844:	80 7f       	andi	r24, 0xF0	; 240
    4846:	82 60       	ori	r24, 0x02	; 2
    4848:	80 83       	st	Z, r24
    484a:	ee e0       	ldi	r30, 0x0E	; 14
    484c:	f1 e0       	ldi	r31, 0x01	; 1
    484e:	8a e3       	ldi	r24, 0x3A	; 58
    4850:	84 87       	std	Z+12, r24	; 0x0c
    4852:	15 86       	std	Z+13, r1	; 0x0d
				return false; //return with an error flag -- send a failure response to host.
    4854:	80 e0       	ldi	r24, 0x00	; 0
    4856:	58 c0       	rjmp	.+176    	; 0x4908 <SCSI_DecodeSCSICommand+0x332>
			}
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
    4858:	61 e0       	ldi	r22, 0x01	; 1
    485a:	c8 01       	movw	r24, r16
    485c:	65 de       	rcall	.-822    	; 0x4528 <SCSI_Command_ReadWrite_10>
			break;
    485e:	44 c0       	rjmp	.+136    	; 0x48e8 <SCSI_DecodeSCSICommand+0x312>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4860:	e1 ef       	ldi	r30, 0xF1	; 241
    4862:	f0 e0       	ldi	r31, 0x00	; 0
    4864:	10 82       	st	Z, r1
    4866:	10 82       	st	Z, r1
    4868:	10 82       	st	Z, r1
    486a:	10 82       	st	Z, r1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    486c:	e8 ee       	ldi	r30, 0xE8	; 232
    486e:	f0 e0       	ldi	r31, 0x00	; 0
    4870:	80 81       	ld	r24, Z
    4872:	8e 77       	andi	r24, 0x7E	; 126
    4874:	80 83       	st	Z, r24
	Endpoint_Write_8(DISK_READ_ONLY ? 0x80 : 0x00);
	Endpoint_Write_8(0x00);
	Endpoint_ClearIN();

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 4;
    4876:	f8 01       	movw	r30, r16
    4878:	84 89       	ldd	r24, Z+20	; 0x14
    487a:	95 89       	ldd	r25, Z+21	; 0x15
    487c:	a6 89       	ldd	r26, Z+22	; 0x16
    487e:	b7 89       	ldd	r27, Z+23	; 0x17
    4880:	04 97       	sbiw	r24, 0x04	; 4
    4882:	a1 09       	sbc	r26, r1
    4884:	b1 09       	sbc	r27, r1
    4886:	84 8b       	std	Z+20, r24	; 0x14
    4888:	95 8b       	std	Z+21, r25	; 0x15
    488a:	a6 8b       	std	Z+22, r26	; 0x16
    488c:	b7 8b       	std	Z+23, r27	; 0x17
			}
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
			break;
		case SCSI_CMD_MODE_SENSE_6:
			CommandSuccess = SCSI_Command_ModeSense_6(MSInterfaceInfo);
			break;
    488e:	2e c0       	rjmp	.+92     	; 0x48ec <SCSI_DecodeSCSICommand+0x316>
		case SCSI_CMD_START_STOP_UNIT:
		case SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
		case SCSI_CMD_VERIFY_10:
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
    4890:	f8 01       	movw	r30, r16
    4892:	14 8a       	std	Z+20, r1	; 0x14
    4894:	15 8a       	std	Z+21, r1	; 0x15
    4896:	16 8a       	std	Z+22, r1	; 0x16
    4898:	17 8a       	std	Z+23, r1	; 0x17
			break;
    489a:	28 c0       	rjmp	.+80     	; 0x48ec <SCSI_DecodeSCSICommand+0x316>
		case SCSI_CMD_TEST_UNIT_READY:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    489c:	8f d1       	rcall	.+798    	; 0x4bbc <SDCardManager_CheckSDCardOperation>
    489e:	88 23       	and	r24, r24
    48a0:	21 f0       	breq	.+8      	; 0x48aa <SCSI_DecodeSCSICommand+0x2d4>
    48a2:	80 91 09 08 	lds	r24, 0x0809
    48a6:	81 30       	cpi	r24, 0x01	; 1
    48a8:	69 f0       	breq	.+26     	; 0x48c4 <SCSI_DecodeSCSICommand+0x2ee>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
    48aa:	e0 e1       	ldi	r30, 0x10	; 16
    48ac:	f1 e0       	ldi	r31, 0x01	; 1
    48ae:	80 81       	ld	r24, Z
    48b0:	80 7f       	andi	r24, 0xF0	; 240
    48b2:	82 60       	ori	r24, 0x02	; 2
    48b4:	80 83       	st	Z, r24
    48b6:	ee e0       	ldi	r30, 0x0E	; 14
    48b8:	f1 e0       	ldi	r31, 0x01	; 1
    48ba:	8a e3       	ldi	r24, 0x3A	; 58
    48bc:	84 87       	std	Z+12, r24	; 0x0c
    48be:	15 86       	std	Z+13, r1	; 0x0d
				return false; //return with an error flag -- send a failure response to host.
    48c0:	80 e0       	ldi	r24, 0x00	; 0
    48c2:	22 c0       	rjmp	.+68     	; 0x4908 <SCSI_DecodeSCSICommand+0x332>
			}
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
    48c4:	f8 01       	movw	r30, r16
    48c6:	14 8a       	std	Z+20, r1	; 0x14
    48c8:	15 8a       	std	Z+21, r1	; 0x15
    48ca:	16 8a       	std	Z+22, r1	; 0x16
    48cc:	17 8a       	std	Z+23, r1	; 0x17
			break;
    48ce:	0e c0       	rjmp	.+28     	; 0x48ec <SCSI_DecodeSCSICommand+0x316>
		default:
			/* Update the SENSE key to reflect the invalid command */
			SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    48d0:	e0 e1       	ldi	r30, 0x10	; 16
    48d2:	f1 e0       	ldi	r31, 0x01	; 1
    48d4:	80 81       	ld	r24, Z
    48d6:	80 7f       	andi	r24, 0xF0	; 240
    48d8:	85 60       	ori	r24, 0x05	; 5
    48da:	80 83       	st	Z, r24
    48dc:	ee e0       	ldi	r30, 0x0E	; 14
    48de:	f1 e0       	ldi	r31, 0x01	; 1
    48e0:	80 e2       	ldi	r24, 0x20	; 32
    48e2:	84 87       	std	Z+12, r24	; 0x0c
    48e4:	15 86       	std	Z+13, r1	; 0x0d
		                   SCSI_ASENSE_INVALID_COMMAND,
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
    48e6:	0f c0       	rjmp	.+30     	; 0x4906 <SCSI_DecodeSCSICommand+0x330>
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
    48e8:	88 23       	and	r24, r24
    48ea:	59 f0       	breq	.+22     	; 0x4902 <SCSI_DecodeSCSICommand+0x32c>
	{
		SCSI_SET_SENSE(SCSI_SENSE_KEY_GOOD,
    48ec:	e0 e1       	ldi	r30, 0x10	; 16
    48ee:	f1 e0       	ldi	r31, 0x01	; 1
    48f0:	80 81       	ld	r24, Z
    48f2:	80 7f       	andi	r24, 0xF0	; 240
    48f4:	80 83       	st	Z, r24
    48f6:	ee e0       	ldi	r30, 0x0E	; 14
    48f8:	f1 e0       	ldi	r31, 0x01	; 1
    48fa:	14 86       	std	Z+12, r1	; 0x0c
    48fc:	15 86       	std	Z+13, r1	; 0x0d
		               SCSI_ASENSE_NO_ADDITIONAL_INFORMATION,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return true;
    48fe:	81 e0       	ldi	r24, 0x01	; 1
    4900:	03 c0       	rjmp	.+6      	; 0x4908 <SCSI_DecodeSCSICommand+0x332>
	}

	return false;
    4902:	80 e0       	ldi	r24, 0x00	; 0
    4904:	01 c0       	rjmp	.+2      	; 0x4908 <SCSI_DecodeSCSICommand+0x332>
    4906:	80 e0       	ldi	r24, 0x00	; 0
}
    4908:	28 96       	adiw	r28, 0x08	; 8
    490a:	0f b6       	in	r0, 0x3f	; 63
    490c:	f8 94       	cli
    490e:	de bf       	out	0x3e, r29	; 62
    4910:	0f be       	out	0x3f, r0	; 63
    4912:	cd bf       	out	0x3d, r28	; 61
    4914:	df 91       	pop	r29
    4916:	cf 91       	pop	r28
    4918:	1f 91       	pop	r17
    491a:	0f 91       	pop	r16
    491c:	ff 90       	pop	r15
    491e:	ef 90       	pop	r14
    4920:	df 90       	pop	r13
    4922:	cf 90       	pop	r12
    4924:	08 95       	ret

00004926 <SDCardManager_Init>:
static bool SDCard_Present= false;

void SDCardManager_Init(void)
{

	if(disk_initialize(0)==FR_OK){ //if the disk initializes correctly
    4926:	80 e0       	ldi	r24, 0x00	; 0
    4928:	0e 94 8b 0e 	call	0x1d16	; 0x1d16 <disk_initialize>
    492c:	81 11       	cpse	r24, r1
    492e:	04 c0       	rjmp	.+8      	; 0x4938 <SDCardManager_Init+0x12>
		SDCard_Present = true;
    4930:	81 e0       	ldi	r24, 0x01	; 1
    4932:	80 93 0a 06 	sts	0x060A, r24
    4936:	08 95       	ret
	}
	else{
		SDCard_Present = false; //tell other functions that the SD Card is missing/malfunctioned
    4938:	10 92 0a 06 	sts	0x060A, r1
    493c:	08 95       	ret

0000493e <SDCardManager_WriteBlockHandler>:
	}
}


uintptr_t SDCardManager_WriteBlockHandler(uint8_t* buffer, uint16_t offset)
{
    493e:	0f 93       	push	r16
    4940:	1f 93       	push	r17
    4942:	cf 93       	push	r28
    4944:	df 93       	push	r29
    4946:	8c 01       	movw	r16, r24
    4948:	eb 01       	movw	r28, r22
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    494a:	90 91 e8 00 	lds	r25, 0x00E8

	/* Check if the endpoint is currently empty */
	if (!(Endpoint_IsReadWriteAllowed()))
    494e:	95 fd       	sbrc	r25, 5
    4950:	09 c0       	rjmp	.+18     	; 0x4964 <SDCardManager_WriteBlockHandler+0x26>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4952:	e8 ee       	ldi	r30, 0xE8	; 232
    4954:	f0 e0       	ldi	r31, 0x00	; 0
    4956:	80 81       	ld	r24, Z
    4958:	8b 77       	andi	r24, 0x7B	; 123
    495a:	80 83       	st	Z, r24
	{
		/* Clear the current endpoint bank */
		Endpoint_ClearOUT();
		
		/* Wait until the host has sent another packet */
		if (Endpoint_WaitUntilReady())
    495c:	0e 94 f5 35 	call	0x6bea	; 0x6bea <Endpoint_WaitUntilReady>
    4960:	81 11       	cpse	r24, r1
    4962:	28 c0       	rjmp	.+80     	; 0x49b4 <SDCardManager_WriteBlockHandler+0x76>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    4964:	a1 ef       	ldi	r26, 0xF1	; 241
    4966:	b0 e0       	ldi	r27, 0x00	; 0
    4968:	8c 91       	ld	r24, X
		  return 0;
	}
	
	/* Write one 16-byte chunk of data to the dataflash */
	buffer[0+offset] = Endpoint_Read_8();
    496a:	f8 01       	movw	r30, r16
    496c:	ec 0f       	add	r30, r28
    496e:	fd 1f       	adc	r31, r29
    4970:	80 83       	st	Z, r24
    4972:	8c 91       	ld	r24, X
	buffer[1+offset] = Endpoint_Read_8();
    4974:	81 83       	std	Z+1, r24	; 0x01
    4976:	8c 91       	ld	r24, X
	buffer[2+offset] = Endpoint_Read_8();
    4978:	82 83       	std	Z+2, r24	; 0x02
    497a:	8c 91       	ld	r24, X
	buffer[3+offset] = Endpoint_Read_8();
    497c:	83 83       	std	Z+3, r24	; 0x03
    497e:	8c 91       	ld	r24, X
	buffer[4+offset] = Endpoint_Read_8();
    4980:	84 83       	std	Z+4, r24	; 0x04
    4982:	8c 91       	ld	r24, X
	buffer[5+offset] = Endpoint_Read_8();
    4984:	85 83       	std	Z+5, r24	; 0x05
    4986:	8c 91       	ld	r24, X
	buffer[6+offset] = Endpoint_Read_8();
    4988:	86 83       	std	Z+6, r24	; 0x06
    498a:	8c 91       	ld	r24, X
	buffer[7+offset] = Endpoint_Read_8();
    498c:	87 83       	std	Z+7, r24	; 0x07
    498e:	8c 91       	ld	r24, X
	buffer[8+offset] = Endpoint_Read_8();
    4990:	80 87       	std	Z+8, r24	; 0x08
    4992:	8c 91       	ld	r24, X
	buffer[9+offset] = Endpoint_Read_8();
    4994:	81 87       	std	Z+9, r24	; 0x09
    4996:	8c 91       	ld	r24, X
	buffer[10+offset] = Endpoint_Read_8();
    4998:	82 87       	std	Z+10, r24	; 0x0a
    499a:	8c 91       	ld	r24, X
	buffer[11+offset] = Endpoint_Read_8();
    499c:	83 87       	std	Z+11, r24	; 0x0b
    499e:	8c 91       	ld	r24, X
	buffer[12+offset] = Endpoint_Read_8();
    49a0:	84 87       	std	Z+12, r24	; 0x0c
    49a2:	8c 91       	ld	r24, X
	buffer[13+offset] = Endpoint_Read_8();
    49a4:	85 87       	std	Z+13, r24	; 0x0d
    49a6:	8c 91       	ld	r24, X
	buffer[14+offset] = Endpoint_Read_8();
    49a8:	86 87       	std	Z+14, r24	; 0x0e
    49aa:	8c 91       	ld	r24, X
	buffer[15+offset] = Endpoint_Read_8();
    49ac:	87 87       	std	Z+15, r24	; 0x0f
	
	return 16;
    49ae:	80 e1       	ldi	r24, 0x10	; 16
    49b0:	90 e0       	ldi	r25, 0x00	; 0
    49b2:	02 c0       	rjmp	.+4      	; 0x49b8 <SDCardManager_WriteBlockHandler+0x7a>
		/* Clear the current endpoint bank */
		Endpoint_ClearOUT();
		
		/* Wait until the host has sent another packet */
		if (Endpoint_WaitUntilReady())
		  return 0;
    49b4:	80 e0       	ldi	r24, 0x00	; 0
    49b6:	90 e0       	ldi	r25, 0x00	; 0
	buffer[13+offset] = Endpoint_Read_8();
	buffer[14+offset] = Endpoint_Read_8();
	buffer[15+offset] = Endpoint_Read_8();
	
	return 16;
}
    49b8:	df 91       	pop	r29
    49ba:	cf 91       	pop	r28
    49bc:	1f 91       	pop	r17
    49be:	0f 91       	pop	r16
    49c0:	08 95       	ret

000049c2 <SDCardManager_WriteBlocks>:
 *
 *  \param[in] BlockAddress  Data block starting address for the write sequence
 *  \param[in] TotalBlocks   Number of blocks of data to write
 */
void SDCardManager_WriteBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo, uint32_t BlockAddress, uint16_t TotalBlocks)
{
    49c2:	6f 92       	push	r6
    49c4:	7f 92       	push	r7
    49c6:	8f 92       	push	r8
    49c8:	9f 92       	push	r9
    49ca:	af 92       	push	r10
    49cc:	bf 92       	push	r11
    49ce:	cf 92       	push	r12
    49d0:	df 92       	push	r13
    49d2:	ef 92       	push	r14
    49d4:	ff 92       	push	r15
    49d6:	0f 93       	push	r16
    49d8:	1f 93       	push	r17
    49da:	cf 93       	push	r28
    49dc:	df 93       	push	r29
    49de:	7c 01       	movw	r14, r24
    49e0:	4a 01       	movw	r8, r20
    49e2:	5b 01       	movw	r10, r22
    49e4:	69 01       	movw	r12, r18
	uint16_t  BytesWritten;

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
    49e6:	0e 94 f5 35 	call	0x6bea	; 0x6bea <Endpoint_WaitUntilReady>
    49ea:	81 11       	cpse	r24, r1
    49ec:	36 c0       	rjmp	.+108    	; 0x4a5a <SDCardManager_WriteBlocks+0x98>
	  return;
	
	while (TotalBlocks)
    49ee:	c1 14       	cp	r12, r1
    49f0:	d1 04       	cpc	r13, r1
    49f2:	49 f1       	breq	.+82     	; 0x4a46 <SDCardManager_WriteBlocks+0x84>
	{
		set_low(RED_LED); //red LED indicates busy status
		
		//Reset BytesWritten every time you finish writing a block, Dummy!
		BytesWritten = 0;
    49f4:	61 2c       	mov	r6, r1
    49f6:	71 2c       	mov	r7, r1
	if (Endpoint_WaitUntilReady())
	  return;
	
	while (TotalBlocks)
	{
		set_low(RED_LED); //red LED indicates busy status
    49f8:	2e 98       	cbi	0x05, 6	; 5
		
		//Reset BytesWritten every time you finish writing a block, Dummy!
		BytesWritten = 0;
    49fa:	c6 2d       	mov	r28, r6
    49fc:	d7 2d       	mov	r29, r7
		
		while((BytesWritten<512)){
			BytesWritten += SDCardManager_WriteBlockHandler((uint8_t*)SD_Buffer, BytesWritten);
    49fe:	be 01       	movw	r22, r28
    4a00:	8a e0       	ldi	r24, 0x0A	; 10
    4a02:	98 e0       	ldi	r25, 0x08	; 8
    4a04:	9c df       	rcall	.-200    	; 0x493e <SDCardManager_WriteBlockHandler>
    4a06:	c8 0f       	add	r28, r24
    4a08:	d9 1f       	adc	r29, r25
			if (USB_DeviceState != DEVICE_STATE_Configured){return;}//if the device is not configured, exit out of this
    4a0a:	90 91 4e 0a 	lds	r25, 0x0A4E
    4a0e:	94 30       	cpi	r25, 0x04	; 4
    4a10:	21 f5       	brne	.+72     	; 0x4a5a <SDCardManager_WriteBlocks+0x98>
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
    4a12:	f7 01       	movw	r30, r14
    4a14:	90 ad       	ldd	r25, Z+56	; 0x38
    4a16:	91 11       	cpse	r25, r1
    4a18:	20 c0       	rjmp	.+64     	; 0x4a5a <SDCardManager_WriteBlocks+0x98>
		set_low(RED_LED); //red LED indicates busy status
		
		//Reset BytesWritten every time you finish writing a block, Dummy!
		BytesWritten = 0;
		
		while((BytesWritten<512)){
    4a1a:	c1 15       	cp	r28, r1
    4a1c:	f2 e0       	ldi	r31, 0x02	; 2
    4a1e:	df 07       	cpc	r29, r31
    4a20:	70 f3       	brcs	.-36     	; 0x49fe <SDCardManager_WriteBlocks+0x3c>
			BytesWritten += SDCardManager_WriteBlockHandler((uint8_t*)SD_Buffer, BytesWritten);
			if (USB_DeviceState != DEVICE_STATE_Configured){return;}//if the device is not configured, exit out of this
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
		}
		
		disk_write (0, (uint8_t*)SD_Buffer, BlockAddress, 1);//write to disk 0, from Buffer array, into BlockAddress, Write only 1 sector (block);
    4a22:	01 e0       	ldi	r16, 0x01	; 1
    4a24:	10 e0       	ldi	r17, 0x00	; 0
    4a26:	a5 01       	movw	r20, r10
    4a28:	94 01       	movw	r18, r8
    4a2a:	6a e0       	ldi	r22, 0x0A	; 10
    4a2c:	78 e0       	ldi	r23, 0x08	; 8
    4a2e:	80 e0       	ldi	r24, 0x00	; 0
    4a30:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <disk_write>
	
		/* Decrement the blocks remaining counter and reset the sub block counter */
		BlockAddress++;
    4a34:	8f ef       	ldi	r24, 0xFF	; 255
    4a36:	88 1a       	sub	r8, r24
    4a38:	98 0a       	sbc	r9, r24
    4a3a:	a8 0a       	sbc	r10, r24
    4a3c:	b8 0a       	sbc	r11, r24
		TotalBlocks--;			
    4a3e:	e1 e0       	ldi	r30, 0x01	; 1
    4a40:	ce 1a       	sub	r12, r30
    4a42:	d1 08       	sbc	r13, r1

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;
	
	while (TotalBlocks)
    4a44:	c9 f6       	brne	.-78     	; 0x49f8 <SDCardManager_WriteBlocks+0x36>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4a46:	80 91 e8 00 	lds	r24, 0x00E8
		TotalBlocks--;			
		
	}

	/* If the endpoint is empty, clear it ready for the next packet from the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    4a4a:	85 fd       	sbrc	r24, 5
    4a4c:	05 c0       	rjmp	.+10     	; 0x4a58 <SDCardManager_WriteBlocks+0x96>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4a4e:	e8 ee       	ldi	r30, 0xE8	; 232
    4a50:	f0 e0       	ldi	r31, 0x00	; 0
    4a52:	80 81       	ld	r24, Z
    4a54:	8b 77       	andi	r24, 0x7B	; 123
    4a56:	80 83       	st	Z, r24
	  Endpoint_ClearOUT();
	  
	  set_high(RED_LED);
    4a58:	2e 9a       	sbi	0x05, 6	; 5
}
    4a5a:	df 91       	pop	r29
    4a5c:	cf 91       	pop	r28
    4a5e:	1f 91       	pop	r17
    4a60:	0f 91       	pop	r16
    4a62:	ff 90       	pop	r15
    4a64:	ef 90       	pop	r14
    4a66:	df 90       	pop	r13
    4a68:	cf 90       	pop	r12
    4a6a:	bf 90       	pop	r11
    4a6c:	af 90       	pop	r10
    4a6e:	9f 90       	pop	r9
    4a70:	8f 90       	pop	r8
    4a72:	7f 90       	pop	r7
    4a74:	6f 90       	pop	r6
    4a76:	08 95       	ret

00004a78 <SDCardManager_ReadBlockHandler>:
 *  \param[in] BlockAddress  Data block starting address for the read sequence
 *  \param[in] TotalBlocks   Number of blocks of data to read
 *  \output -- number of bytes forwarded successfully.  Return 16 if they are forwarded successfully, 0 if host rejects them.
 */
uint8_t SDCardManager_ReadBlockHandler(uint8_t* buffer, uint16_t offset)
{
    4a78:	ef 92       	push	r14
    4a7a:	ff 92       	push	r15
    4a7c:	0f 93       	push	r16
    4a7e:	1f 93       	push	r17
    4a80:	cf 93       	push	r28
    4a82:	7c 01       	movw	r14, r24
    4a84:	8b 01       	movw	r16, r22
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4a86:	90 91 e8 00 	lds	r25, 0x00E8

	/* Check if the endpoint is currently full */
	if (!(Endpoint_IsReadWriteAllowed()))
    4a8a:	c9 2f       	mov	r28, r25
    4a8c:	c0 72       	andi	r28, 0x20	; 32
    4a8e:	95 fd       	sbrc	r25, 5
    4a90:	09 c0       	rjmp	.+18     	; 0x4aa4 <SDCardManager_ReadBlockHandler+0x2c>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4a92:	e8 ee       	ldi	r30, 0xE8	; 232
    4a94:	f0 e0       	ldi	r31, 0x00	; 0
    4a96:	80 81       	ld	r24, Z
    4a98:	8e 77       	andi	r24, 0x7E	; 126
    4a9a:	80 83       	st	Z, r24
	{
		/* Clear the endpoint bank to send its contents to the host */
		Endpoint_ClearIN();
		
		/* Wait until the endpoint is ready for more data */
		if (Endpoint_WaitUntilReady())
    4a9c:	0e 94 f5 35 	call	0x6bea	; 0x6bea <Endpoint_WaitUntilReady>
    4aa0:	81 11       	cpse	r24, r1
    4aa2:	26 c0       	rjmp	.+76     	; 0x4af0 <SDCardManager_ReadBlockHandler+0x78>
		return 0;
	}
	
	Endpoint_Write_8(buffer[0+offset]);
    4aa4:	f7 01       	movw	r30, r14
    4aa6:	e0 0f       	add	r30, r16
    4aa8:	f1 1f       	adc	r31, r17
    4aaa:	80 81       	ld	r24, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4aac:	a1 ef       	ldi	r26, 0xF1	; 241
    4aae:	b0 e0       	ldi	r27, 0x00	; 0
    4ab0:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[1+offset]);
    4ab2:	81 81       	ldd	r24, Z+1	; 0x01
    4ab4:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[2+offset]);
    4ab6:	82 81       	ldd	r24, Z+2	; 0x02
    4ab8:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[3+offset]);
    4aba:	83 81       	ldd	r24, Z+3	; 0x03
    4abc:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[4+offset]);
    4abe:	84 81       	ldd	r24, Z+4	; 0x04
    4ac0:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[5+offset]);
    4ac2:	85 81       	ldd	r24, Z+5	; 0x05
    4ac4:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[6+offset]);
    4ac6:	86 81       	ldd	r24, Z+6	; 0x06
    4ac8:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[7+offset]);
    4aca:	87 81       	ldd	r24, Z+7	; 0x07
    4acc:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[8+offset]);
    4ace:	80 85       	ldd	r24, Z+8	; 0x08
    4ad0:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[9+offset]);
    4ad2:	81 85       	ldd	r24, Z+9	; 0x09
    4ad4:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[10+offset]);
    4ad6:	82 85       	ldd	r24, Z+10	; 0x0a
    4ad8:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[11+offset]);
    4ada:	83 85       	ldd	r24, Z+11	; 0x0b
    4adc:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[12+offset]);
    4ade:	84 85       	ldd	r24, Z+12	; 0x0c
    4ae0:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[13+offset]);
    4ae2:	85 85       	ldd	r24, Z+13	; 0x0d
    4ae4:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[14+offset]);
    4ae6:	86 85       	ldd	r24, Z+14	; 0x0e
    4ae8:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[15+offset]);
    4aea:	87 85       	ldd	r24, Z+15	; 0x0f
    4aec:	8c 93       	st	X, r24
	
	return 16;
    4aee:	c0 e1       	ldi	r28, 0x10	; 16
}
    4af0:	8c 2f       	mov	r24, r28
    4af2:	cf 91       	pop	r28
    4af4:	1f 91       	pop	r17
    4af6:	0f 91       	pop	r16
    4af8:	ff 90       	pop	r15
    4afa:	ef 90       	pop	r14
    4afc:	08 95       	ret

00004afe <SDCardManager_ReadBlocks>:
 *
 *  \param[in] BlockAddress  Data block starting address for the read sequence
 *  \param[in] TotalBlocks   Number of blocks of data to read
 */
void SDCardManager_ReadBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo, uint32_t BlockAddress, uint16_t TotalBlocks)
{
    4afe:	6f 92       	push	r6
    4b00:	7f 92       	push	r7
    4b02:	8f 92       	push	r8
    4b04:	9f 92       	push	r9
    4b06:	af 92       	push	r10
    4b08:	bf 92       	push	r11
    4b0a:	cf 92       	push	r12
    4b0c:	df 92       	push	r13
    4b0e:	ef 92       	push	r14
    4b10:	ff 92       	push	r15
    4b12:	0f 93       	push	r16
    4b14:	1f 93       	push	r17
    4b16:	cf 93       	push	r28
    4b18:	df 93       	push	r29
    4b1a:	7c 01       	movw	r14, r24
    4b1c:	4a 01       	movw	r8, r20
    4b1e:	5b 01       	movw	r10, r22
    4b20:	69 01       	movw	r12, r18
	uint16_t BytesRead;
	
	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
    4b22:	0e 94 f5 35 	call	0x6bea	; 0x6bea <Endpoint_WaitUntilReady>
    4b26:	81 11       	cpse	r24, r1
    4b28:	3a c0       	rjmp	.+116    	; 0x4b9e <SDCardManager_ReadBlocks+0xa0>
	  return;
	
	while (TotalBlocks)
    4b2a:	c1 14       	cp	r12, r1
    4b2c:	d1 04       	cpc	r13, r1
    4b2e:	69 f1       	breq	.+90     	; 0x4b8a <SDCardManager_ReadBlocks+0x8c>
	{		
		set_low(RED_LED); //red LED indicates busy status
		//Reset tally of BytesRead every time a new block is accessed.  
		BytesRead = 0;
    4b30:	61 2c       	mov	r6, r1
    4b32:	71 2c       	mov	r7, r1
	if (Endpoint_WaitUntilReady())
	  return;
	
	while (TotalBlocks)
	{		
		set_low(RED_LED); //red LED indicates busy status
    4b34:	2e 98       	cbi	0x05, 6	; 5
		//Reset tally of BytesRead every time a new block is accessed.  
		BytesRead = 0;
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)
    4b36:	01 e0       	ldi	r16, 0x01	; 1
    4b38:	10 e0       	ldi	r17, 0x00	; 0
    4b3a:	a5 01       	movw	r20, r10
    4b3c:	94 01       	movw	r18, r8
    4b3e:	6a e0       	ldi	r22, 0x0A	; 10
    4b40:	78 e0       	ldi	r23, 0x08	; 8
    4b42:	80 e0       	ldi	r24, 0x00	; 0
    4b44:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <disk_read>
	
	while (TotalBlocks)
	{		
		set_low(RED_LED); //red LED indicates busy status
		//Reset tally of BytesRead every time a new block is accessed.  
		BytesRead = 0;
    4b48:	c6 2d       	mov	r28, r6
    4b4a:	d7 2d       	mov	r29, r7
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)

		while(BytesRead<512){  //send the results to the usb endpoint buffer, 16 bytes at a time.
			BytesRead += SDCardManager_ReadBlockHandler((uint8_t*)SD_Buffer, BytesRead); // BytesRead increases 16 every time handler is called, if all goes well.
    4b4c:	be 01       	movw	r22, r28
    4b4e:	8a e0       	ldi	r24, 0x0A	; 10
    4b50:	98 e0       	ldi	r25, 0x08	; 8
    4b52:	92 df       	rcall	.-220    	; 0x4a78 <SDCardManager_ReadBlockHandler>
    4b54:	c8 0f       	add	r28, r24
    4b56:	d1 1d       	adc	r29, r1
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
    4b58:	f7 01       	movw	r30, r14
    4b5a:	90 ad       	ldd	r25, Z+56	; 0x38
    4b5c:	91 11       	cpse	r25, r1
    4b5e:	1f c0       	rjmp	.+62     	; 0x4b9e <SDCardManager_ReadBlocks+0xa0>
			if (USB_DeviceState != DEVICE_STATE_Configured){Typewriter_Mode = PANIC_MODE; return;}
    4b60:	90 91 4e 0a 	lds	r25, 0x0A4E
    4b64:	94 30       	cpi	r25, 0x04	; 4
    4b66:	21 f0       	breq	.+8      	; 0x4b70 <SDCardManager_ReadBlocks+0x72>
    4b68:	8a e0       	ldi	r24, 0x0A	; 10
    4b6a:	80 93 09 08 	sts	0x0809, r24
    4b6e:	17 c0       	rjmp	.+46     	; 0x4b9e <SDCardManager_ReadBlocks+0xa0>
		BytesRead = 0;
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)

		while(BytesRead<512){  //send the results to the usb endpoint buffer, 16 bytes at a time.
    4b70:	c1 15       	cp	r28, r1
    4b72:	f2 e0       	ldi	r31, 0x02	; 2
    4b74:	df 07       	cpc	r29, r31
    4b76:	50 f3       	brcs	.-44     	; 0x4b4c <SDCardManager_ReadBlocks+0x4e>
			BytesRead += SDCardManager_ReadBlockHandler((uint8_t*)SD_Buffer, BytesRead); // BytesRead increases 16 every time handler is called, if all goes well.
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
			if (USB_DeviceState != DEVICE_STATE_Configured){Typewriter_Mode = PANIC_MODE; return;}
		}
		/* Decrement the blocks remaining counter */
		BlockAddress++;
    4b78:	8f ef       	ldi	r24, 0xFF	; 255
    4b7a:	88 1a       	sub	r8, r24
    4b7c:	98 0a       	sbc	r9, r24
    4b7e:	a8 0a       	sbc	r10, r24
    4b80:	b8 0a       	sbc	r11, r24
		TotalBlocks--;
    4b82:	e1 e0       	ldi	r30, 0x01	; 1
    4b84:	ce 1a       	sub	r12, r30
    4b86:	d1 08       	sbc	r13, r1
	
	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;
	
	while (TotalBlocks)
    4b88:	a9 f6       	brne	.-86     	; 0x4b34 <SDCardManager_ReadBlocks+0x36>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4b8a:	80 91 e8 00 	lds	r24, 0x00E8
		BlockAddress++;
		TotalBlocks--;
	}
	
	/* If the endpoint is full, send its contents to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    4b8e:	85 fd       	sbrc	r24, 5
    4b90:	05 c0       	rjmp	.+10     	; 0x4b9c <SDCardManager_ReadBlocks+0x9e>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4b92:	e8 ee       	ldi	r30, 0xE8	; 232
    4b94:	f0 e0       	ldi	r31, 0x00	; 0
    4b96:	80 81       	ld	r24, Z
    4b98:	8e 77       	andi	r24, 0x7E	; 126
    4b9a:	80 83       	st	Z, r24
	  Endpoint_ClearIN();
	 
	 set_high(RED_LED);
    4b9c:	2e 9a       	sbi	0x05, 6	; 5
}
    4b9e:	df 91       	pop	r29
    4ba0:	cf 91       	pop	r28
    4ba2:	1f 91       	pop	r17
    4ba4:	0f 91       	pop	r16
    4ba6:	ff 90       	pop	r15
    4ba8:	ef 90       	pop	r14
    4baa:	df 90       	pop	r13
    4bac:	cf 90       	pop	r12
    4bae:	bf 90       	pop	r11
    4bb0:	af 90       	pop	r10
    4bb2:	9f 90       	pop	r9
    4bb4:	8f 90       	pop	r8
    4bb6:	7f 90       	pop	r7
    4bb8:	6f 90       	pop	r6
    4bba:	08 95       	ret

00004bbc <SDCardManager_CheckSDCardOperation>:
 *  \return Boolean true if all media chips are working, false otherwise
 */
bool SDCardManager_CheckSDCardOperation(void)
{	
	return SDCard_Present; //return whether or not sd card is present and working.
}
    4bbc:	80 91 0a 06 	lds	r24, 0x060A
    4bc0:	08 95       	ret

00004bc2 <__vector_25>:
ISR (UART0_RECEIVE_INTERRUPT)	
/*************************************************************************
Function: UART Receive Complete interrupt
Purpose:  called when the UART has received a character
**************************************************************************/
{
    4bc2:	1f 92       	push	r1
    4bc4:	0f 92       	push	r0
    4bc6:	0f b6       	in	r0, 0x3f	; 63
    4bc8:	0f 92       	push	r0
    4bca:	11 24       	eor	r1, r1
    4bcc:	2f 93       	push	r18
    4bce:	8f 93       	push	r24
    4bd0:	9f 93       	push	r25
    4bd2:	ef 93       	push	r30
    4bd4:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART0_STATUS;
    4bd6:	80 91 c8 00 	lds	r24, 0x00C8
    data = UART0_DATA;
    4bda:	20 91 ce 00 	lds	r18, 0x00CE
    
    /* */
#if defined( AT90_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
    4bde:	88 71       	andi	r24, 0x18	; 24
#elif defined( AT90USB_USART )
    lastRxError = (usr & (_BV(FE1)|_BV(DOR1)) );
#endif
        
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    4be0:	e0 91 0d 06 	lds	r30, 0x060D
    4be4:	ef 5f       	subi	r30, 0xFF	; 255
    4be6:	ef 73       	andi	r30, 0x3F	; 63
    
    if ( tmphead == UART_RxTail ) {
    4be8:	90 91 0c 06 	lds	r25, 0x060C
    4bec:	e9 17       	cp	r30, r25
    4bee:	39 f0       	breq	.+14     	; 0x4bfe <__vector_25+0x3c>
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART_RxHead = tmphead;
    4bf0:	e0 93 0d 06 	sts	0x060D, r30
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    4bf4:	f0 e0       	ldi	r31, 0x00	; 0
    4bf6:	e0 5f       	subi	r30, 0xF0	; 240
    4bf8:	f9 4f       	sbci	r31, 0xF9	; 249
    4bfa:	20 83       	st	Z, r18
    4bfc:	01 c0       	rjmp	.+2      	; 0x4c00 <__vector_25+0x3e>
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    
    if ( tmphead == UART_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    4bfe:	82 e0       	ldi	r24, 0x02	; 2
        /* store new index */
        UART_RxHead = tmphead;
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    }
    UART_LastRxError |= lastRxError;   
    4c00:	90 91 0b 06 	lds	r25, 0x060B
    4c04:	89 2b       	or	r24, r25
    4c06:	80 93 0b 06 	sts	0x060B, r24
}
    4c0a:	ff 91       	pop	r31
    4c0c:	ef 91       	pop	r30
    4c0e:	9f 91       	pop	r25
    4c10:	8f 91       	pop	r24
    4c12:	2f 91       	pop	r18
    4c14:	0f 90       	pop	r0
    4c16:	0f be       	out	0x3f, r0	; 63
    4c18:	0f 90       	pop	r0
    4c1a:	1f 90       	pop	r1
    4c1c:	18 95       	reti

00004c1e <__vector_26>:
ISR (UART0_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/
{
    4c1e:	1f 92       	push	r1
    4c20:	0f 92       	push	r0
    4c22:	0f b6       	in	r0, 0x3f	; 63
    4c24:	0f 92       	push	r0
    4c26:	11 24       	eor	r1, r1
    4c28:	8f 93       	push	r24
    4c2a:	9f 93       	push	r25
    4c2c:	ef 93       	push	r30
    4c2e:	ff 93       	push	r31
    unsigned char tmptail;
    
    if ( UART_TxHead != UART_TxTail) {
    4c30:	90 91 0f 06 	lds	r25, 0x060F
    4c34:	80 91 0e 06 	lds	r24, 0x060E
    4c38:	98 17       	cp	r25, r24
    4c3a:	69 f0       	breq	.+26     	; 0x4c56 <__vector_26+0x38>
        /* calculate and store new buffer index */
        tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
    4c3c:	e0 91 0e 06 	lds	r30, 0x060E
    4c40:	ef 5f       	subi	r30, 0xFF	; 255
    4c42:	ef 70       	andi	r30, 0x0F	; 15
        UART_TxTail = tmptail;
    4c44:	e0 93 0e 06 	sts	0x060E, r30
        /* get one byte from buffer and write it to UART */
        UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
    4c48:	f0 e0       	ldi	r31, 0x00	; 0
    4c4a:	e0 5b       	subi	r30, 0xB0	; 176
    4c4c:	f9 4f       	sbci	r31, 0xF9	; 249
    4c4e:	80 81       	ld	r24, Z
    4c50:	80 93 ce 00 	sts	0x00CE, r24
    4c54:	05 c0       	rjmp	.+10     	; 0x4c60 <__vector_26+0x42>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART0_CONTROL &= ~_BV(UART0_UDRIE);
    4c56:	e9 ec       	ldi	r30, 0xC9	; 201
    4c58:	f0 e0       	ldi	r31, 0x00	; 0
    4c5a:	80 81       	ld	r24, Z
    4c5c:	8f 7d       	andi	r24, 0xDF	; 223
    4c5e:	80 83       	st	Z, r24
    }
}
    4c60:	ff 91       	pop	r31
    4c62:	ef 91       	pop	r30
    4c64:	9f 91       	pop	r25
    4c66:	8f 91       	pop	r24
    4c68:	0f 90       	pop	r0
    4c6a:	0f be       	out	0x3f, r0	; 63
    4c6c:	0f 90       	pop	r0
    4c6e:	1f 90       	pop	r1
    4c70:	18 95       	reti

00004c72 <uart_init>:
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart_init(unsigned int baudrate)
{
    UART_TxHead = 0;
    4c72:	10 92 0f 06 	sts	0x060F, r1
    UART_TxTail = 0;
    4c76:	10 92 0e 06 	sts	0x060E, r1
    UART_RxHead = 0;
    4c7a:	10 92 0d 06 	sts	0x060D, r1
    UART_RxTail = 0;
    4c7e:	10 92 0c 06 	sts	0x060C, r1
    /* enable UART receiver and transmmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);

#elif defined (ATMEGA_USART)
    /* Set baud rate */
    if ( baudrate & 0x8000 )
    4c82:	99 23       	and	r25, r25
    4c84:	24 f4       	brge	.+8      	; 0x4c8e <uart_init+0x1c>
    {
    	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
    4c86:	22 e0       	ldi	r18, 0x02	; 2
    4c88:	20 93 c8 00 	sts	0x00C8, r18
    	 baudrate &= ~0x8000;
    4c8c:	9f 77       	andi	r25, 0x7F	; 127
    }
    UBRRH = (unsigned char)(baudrate>>8);
    4c8e:	90 93 cd 00 	sts	0x00CD, r25
    UBRRL = (unsigned char) baudrate;
    4c92:	80 93 cc 00 	sts	0x00CC, r24
   
    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
    4c96:	88 e9       	ldi	r24, 0x98	; 152
    4c98:	80 93 c9 00 	sts	0x00C9, r24
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
    #ifdef URSEL
    UCSRC = (1<<URSEL)|(3<<UCSZ0);
    #else
    UCSRC = (3<<UCSZ0);
    4c9c:	86 e0       	ldi	r24, 0x06	; 6
    4c9e:	80 93 ca 00 	sts	0x00CA, r24
    4ca2:	08 95       	ret

00004ca4 <uart_getc>:
{    
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
    4ca4:	90 91 0d 06 	lds	r25, 0x060D
    4ca8:	80 91 0c 06 	lds	r24, 0x060C
    4cac:	98 17       	cp	r25, r24
    4cae:	81 f0       	breq	.+32     	; 0x4cd0 <uart_getc+0x2c>
        return UART_NO_DATA;   /* no data available */
    }
    
    /* calculate /store buffer index */
    tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
    4cb0:	e0 91 0c 06 	lds	r30, 0x060C
    4cb4:	ef 5f       	subi	r30, 0xFF	; 255
    4cb6:	ef 73       	andi	r30, 0x3F	; 63
    UART_RxTail = tmptail; 
    4cb8:	e0 93 0c 06 	sts	0x060C, r30
    
    /* get data from receive buffer */
    data = UART_RxBuf[tmptail];
    4cbc:	f0 e0       	ldi	r31, 0x00	; 0
    4cbe:	e0 5f       	subi	r30, 0xF0	; 240
    4cc0:	f9 4f       	sbci	r31, 0xF9	; 249
    4cc2:	80 81       	ld	r24, Z
    
    data = (UART_LastRxError << 8) + data;
    4cc4:	90 91 0b 06 	lds	r25, 0x060B
    UART_LastRxError = 0;
    4cc8:	10 92 0b 06 	sts	0x060B, r1
    return data;
    4ccc:	90 e0       	ldi	r25, 0x00	; 0
    4cce:	08 95       	ret
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
        return UART_NO_DATA;   /* no data available */
    4cd0:	80 e0       	ldi	r24, 0x00	; 0
    4cd2:	91 e0       	ldi	r25, 0x01	; 1
    
    data = (UART_LastRxError << 8) + data;
    UART_LastRxError = 0;
    return data;

}/* uart_getc */
    4cd4:	08 95       	ret

00004cd6 <uart_clear_rx_buffer>:

void uart_clear_rx_buffer(){
//the head and tail define the buffer index of the first and last byte of the received data.  
//If they are equal to each other, no data has been received (buffer empty)
	UART_RxHead = 0;
    4cd6:	10 92 0d 06 	sts	0x060D, r1
	UART_RxTail = 0; 
    4cda:	10 92 0c 06 	sts	0x060C, r1
    4cde:	08 95       	ret

00004ce0 <uart_putc>:
**************************************************************************/
void uart_putc(unsigned char data)
{
    unsigned char tmphead;
    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
    4ce0:	20 91 0f 06 	lds	r18, 0x060F
    4ce4:	2f 5f       	subi	r18, 0xFF	; 255
    4ce6:	2f 70       	andi	r18, 0x0F	; 15
    
    while ( tmphead == UART_TxTail ){
    4ce8:	90 91 0e 06 	lds	r25, 0x060E
    4cec:	29 17       	cp	r18, r25
    4cee:	e1 f3       	breq	.-8      	; 0x4ce8 <uart_putc+0x8>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
    4cf0:	e2 2f       	mov	r30, r18
    4cf2:	f0 e0       	ldi	r31, 0x00	; 0
    4cf4:	e0 5b       	subi	r30, 0xB0	; 176
    4cf6:	f9 4f       	sbci	r31, 0xF9	; 249
    4cf8:	80 83       	st	Z, r24
    UART_TxHead = tmphead;
    4cfa:	20 93 0f 06 	sts	0x060F, r18

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
    4cfe:	e9 ec       	ldi	r30, 0xC9	; 201
    4d00:	f0 e0       	ldi	r31, 0x00	; 0
    4d02:	80 81       	ld	r24, Z
    4d04:	80 62       	ori	r24, 0x20	; 32
    4d06:	80 83       	st	Z, r24
    4d08:	08 95       	ret

00004d0a <__vector_17>:
		return false;
	}
	else{
		return true;
	}
}
    4d0a:	1f 92       	push	r1
    4d0c:	0f 92       	push	r0
    4d0e:	0f b6       	in	r0, 0x3f	; 63
    4d10:	0f 92       	push	r0
    4d12:	11 24       	eor	r1, r1
    4d14:	2f 93       	push	r18
    4d16:	3f 93       	push	r19
    4d18:	4f 93       	push	r20
    4d1a:	5f 93       	push	r21
    4d1c:	6f 93       	push	r22
    4d1e:	7f 93       	push	r23
    4d20:	8f 93       	push	r24
    4d22:	9f 93       	push	r25
    4d24:	af 93       	push	r26
    4d26:	bf 93       	push	r27
    4d28:	ef 93       	push	r30
    4d2a:	ff 93       	push	r31
    4d2c:	80 91 00 07 	lds	r24, 0x0700
    4d30:	90 91 01 07 	lds	r25, 0x0701
    4d34:	01 96       	adiw	r24, 0x01	; 1
    4d36:	90 93 01 07 	sts	0x0701, r25
    4d3a:	80 93 00 07 	sts	0x0700, r24
    4d3e:	80 91 07 08 	lds	r24, 0x0807
    4d42:	90 91 08 08 	lds	r25, 0x0808
    4d46:	01 96       	adiw	r24, 0x01	; 1
    4d48:	90 93 08 08 	sts	0x0808, r25
    4d4c:	80 93 07 08 	sts	0x0807, r24
    4d50:	80 91 09 08 	lds	r24, 0x0809
    4d54:	81 30       	cpi	r24, 0x01	; 1
    4d56:	79 f0       	breq	.+30     	; 0x4d76 <__vector_17+0x6c>
    4d58:	80 91 09 08 	lds	r24, 0x0809
    4d5c:	8d 30       	cpi	r24, 0x0D	; 13
    4d5e:	59 f0       	breq	.+22     	; 0x4d76 <__vector_17+0x6c>
    4d60:	80 e3       	ldi	r24, 0x30	; 48
    4d62:	91 e0       	ldi	r25, 0x01	; 1
    4d64:	0e 94 df 30 	call	0x61be	; 0x61be <MS_Device_USBTask>
    4d68:	80 e2       	ldi	r24, 0x20	; 32
    4d6a:	91 e0       	ldi	r25, 0x01	; 1
    4d6c:	0e 94 c7 2f 	call	0x5f8e	; 0x5f8e <HID_Device_USBTask>
    4d70:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <USB_USBTask>
    4d74:	03 c0       	rjmp	.+6      	; 0x4d7c <__vector_17+0x72>
    4d76:	81 e0       	ldi	r24, 0x01	; 1
    4d78:	80 93 b9 06 	sts	0x06B9, r24
    4d7c:	ff 91       	pop	r31
    4d7e:	ef 91       	pop	r30
    4d80:	bf 91       	pop	r27
    4d82:	af 91       	pop	r26
    4d84:	9f 91       	pop	r25
    4d86:	8f 91       	pop	r24
    4d88:	7f 91       	pop	r23
    4d8a:	6f 91       	pop	r22
    4d8c:	5f 91       	pop	r21
    4d8e:	4f 91       	pop	r20
    4d90:	3f 91       	pop	r19
    4d92:	2f 91       	pop	r18
    4d94:	0f 90       	pop	r0
    4d96:	0f be       	out	0x3f, r0	; 63
    4d98:	0f 90       	pop	r0
    4d9a:	1f 90       	pop	r1
    4d9c:	18 95       	reti

00004d9e <Task_Manager>:
    4d9e:	80 91 b9 06 	lds	r24, 0x06B9
    4da2:	81 30       	cpi	r24, 0x01	; 1
    4da4:	59 f4       	brne	.+22     	; 0x4dbc <Task_Manager+0x1e>
    4da6:	80 e3       	ldi	r24, 0x30	; 48
    4da8:	91 e0       	ldi	r25, 0x01	; 1
    4daa:	0e 94 df 30 	call	0x61be	; 0x61be <MS_Device_USBTask>
    4dae:	80 e2       	ldi	r24, 0x20	; 32
    4db0:	91 e0       	ldi	r25, 0x01	; 1
    4db2:	0e 94 c7 2f 	call	0x5f8e	; 0x5f8e <HID_Device_USBTask>
    4db6:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <USB_USBTask>
    4dba:	15 c0       	rjmp	.+42     	; 0x4de6 <Task_Manager+0x48>
    4dbc:	80 91 b9 06 	lds	r24, 0x06B9
    4dc0:	83 30       	cpi	r24, 0x03	; 3
    4dc2:	39 f4       	brne	.+14     	; 0x4dd2 <Task_Manager+0x34>
    4dc4:	80 e2       	ldi	r24, 0x20	; 32
    4dc6:	91 e0       	ldi	r25, 0x01	; 1
    4dc8:	0e 94 c7 2f 	call	0x5f8e	; 0x5f8e <HID_Device_USBTask>
    4dcc:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <USB_USBTask>
    4dd0:	0a c0       	rjmp	.+20     	; 0x4de6 <Task_Manager+0x48>
    4dd2:	80 91 b9 06 	lds	r24, 0x06B9
    4dd6:	82 30       	cpi	r24, 0x02	; 2
    4dd8:	31 f4       	brne	.+12     	; 0x4de6 <Task_Manager+0x48>
    4dda:	80 e3       	ldi	r24, 0x30	; 48
    4ddc:	91 e0       	ldi	r25, 0x01	; 1
    4dde:	0e 94 df 30 	call	0x61be	; 0x61be <MS_Device_USBTask>
    4de2:	0e 94 e0 38 	call	0x71c0	; 0x71c0 <USB_USBTask>
    4de6:	10 92 b9 06 	sts	0x06B9, r1
    4dea:	08 95       	ret

00004dec <SetupHardware>:
/** Configures the board hardware and chip peripherals for functionality. */
void SetupHardware()
{

	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
    4dec:	84 b7       	in	r24, 0x34	; 52
    4dee:	87 7f       	andi	r24, 0xF7	; 247
    4df0:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    4df2:	0f b6       	in	r0, 0x3f	; 63
    4df4:	f8 94       	cli
    4df6:	a8 95       	wdr
    4df8:	80 91 60 00 	lds	r24, 0x0060
    4dfc:	88 61       	ori	r24, 0x18	; 24
    4dfe:	80 93 60 00 	sts	0x0060, r24
    4e02:	10 92 60 00 	sts	0x0060, r1
    4e06:	0f be       	out	0x3f, r0	; 63
	wdt_disable();
	
	/* Disable JTAG on PortF -- enables Port F pins to function normally.  Datasheet requires this pin to be written repeatedly in order for it to work. 
	("The application software must write this bit to the desired value twice within four cycles to change its value."*/
	MCUCR |= (1 << JTD); 
    4e08:	85 b7       	in	r24, 0x35	; 53
    4e0a:	80 68       	ori	r24, 0x80	; 128
    4e0c:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4e0e:	85 b7       	in	r24, 0x35	; 53
    4e10:	80 68       	ori	r24, 0x80	; 128
    4e12:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4e14:	85 b7       	in	r24, 0x35	; 53
    4e16:	80 68       	ori	r24, 0x80	; 128
    4e18:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4e1a:	85 b7       	in	r24, 0x35	; 53
    4e1c:	80 68       	ori	r24, 0x80	; 128
    4e1e:	85 bf       	out	0x35, r24	; 53
from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
    4e20:	90 e0       	ldi	r25, 0x00	; 0
    4e22:	80 e8       	ldi	r24, 0x80	; 128
    4e24:	0f b6       	in	r0, 0x3f	; 63
    4e26:	f8 94       	cli
    4e28:	80 93 61 00 	sts	0x0061, r24
    4e2c:	90 93 61 00 	sts	0x0061, r25
    4e30:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
	Config_Interrupts();
    4e32:	0e 94 af 09 	call	0x135e	; 0x135e <Config_Interrupts>
	
	/* Hardware Initialization */
	Config_IO();
    4e36:	0e 94 c3 09 	call	0x1386	; 0x1386 <Config_IO>
    4e3a:	2f e7       	ldi	r18, 0x7F	; 127
    4e3c:	88 e3       	ldi	r24, 0x38	; 56
    4e3e:	91 e0       	ldi	r25, 0x01	; 1
    4e40:	21 50       	subi	r18, 0x01	; 1
    4e42:	80 40       	sbci	r24, 0x00	; 0
    4e44:	90 40       	sbci	r25, 0x00	; 0
    4e46:	e1 f7       	brne	.-8      	; 0x4e40 <SetupHardware+0x54>
    4e48:	00 c0       	rjmp	.+0      	; 0x4e4a <SetupHardware+0x5e>
    4e4a:	00 00       	nop
	Delay_MS(50); //DELAY 50ms after setting IO.
	
	Reed1Polarity = eeprom_read_byte((uint8_t *)REED_1_POLARITY_ADDR);
    4e4c:	86 e0       	ldi	r24, 0x06	; 6
    4e4e:	92 e0       	ldi	r25, 0x02	; 2
    4e50:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    4e54:	91 e0       	ldi	r25, 0x01	; 1
    4e56:	81 11       	cpse	r24, r1
    4e58:	01 c0       	rjmp	.+2      	; 0x4e5c <SetupHardware+0x70>
    4e5a:	90 e0       	ldi	r25, 0x00	; 0
    4e5c:	90 93 06 07 	sts	0x0706, r25
	Reed2Polarity= eeprom_read_byte((uint8_t *)REED_2_POLARITY_ADDR);
    4e60:	87 e0       	ldi	r24, 0x07	; 7
    4e62:	92 e0       	ldi	r25, 0x02	; 2
    4e64:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    4e68:	91 e0       	ldi	r25, 0x01	; 1
    4e6a:	81 11       	cpse	r24, r1
    4e6c:	01 c0       	rjmp	.+2      	; 0x4e70 <SetupHardware+0x84>
    4e6e:	90 e0       	ldi	r25, 0x00	; 0
    4e70:	90 93 b6 06 	sts	0x06B6, r25
	Reed3Polarity = eeprom_read_byte((uint8_t *)REED_3_POLARITY_ADDR);
    4e74:	88 e0       	ldi	r24, 0x08	; 8
    4e76:	92 e0       	ldi	r25, 0x02	; 2
    4e78:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    4e7c:	91 e0       	ldi	r25, 0x01	; 1
    4e7e:	81 11       	cpse	r24, r1
    4e80:	01 c0       	rjmp	.+2      	; 0x4e84 <SetupHardware+0x98>
    4e82:	90 e0       	ldi	r25, 0x00	; 0
    4e84:	90 93 88 07 	sts	0x0788, r25
	Reed4Polarity = eeprom_read_byte((uint8_t *)REED_4_POLARITY_ADDR);
    4e88:	89 e0       	ldi	r24, 0x09	; 9
    4e8a:	92 e0       	ldi	r25, 0x02	; 2
    4e8c:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    4e90:	91 e0       	ldi	r25, 0x01	; 1
    4e92:	81 11       	cpse	r24, r1
    4e94:	01 c0       	rjmp	.+2      	; 0x4e98 <SetupHardware+0xac>
    4e96:	90 e0       	ldi	r25, 0x00	; 0
    4e98:	90 93 c6 07 	sts	0x07C6, r25
    4e9c:	08 95       	ret

00004e9e <EVENT_USB_Device_Connect>:
	
}

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
    4e9e:	08 95       	ret

00004ea0 <EVENT_USB_Device_Disconnect>:
}

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	if(SDCardManager_CheckSDCardOperation()){ //if there is an SD Card present, flip into sd mode if the computer is shut off.
    4ea0:	8d de       	rcall	.-742    	; 0x4bbc <SDCardManager_CheckSDCardOperation>
    4ea2:	88 23       	and	r24, r24
    4ea4:	19 f0       	breq	.+6      	; 0x4eac <EVENT_USB_Device_Disconnect+0xc>
		Typewriter_Mode = SD_MODE;
    4ea6:	82 e0       	ldi	r24, 0x02	; 2
    4ea8:	80 93 09 08 	sts	0x0809, r24
    4eac:	08 95       	ret

00004eae <EVENT_USB_Device_Suspend>:
	}

}

void EVENT_USB_Device_Suspend(void){
    4eae:	08 95       	ret

00004eb0 <EVENT_USB_Device_WakeUp>:
	
}

void EVENT_USB_Device_WakeUp(void){
    4eb0:	08 95       	ret

00004eb2 <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= HID_Device_ConfigureEndpoints(&Keyboard_HID_Interface);
    4eb2:	80 e2       	ldi	r24, 0x20	; 32
    4eb4:	91 e0       	ldi	r25, 0x01	; 1
    4eb6:	0e 94 b3 2f 	call	0x5f66	; 0x5f66 <HID_Device_ConfigureEndpoints>
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
    4eba:	80 e3       	ldi	r24, 0x30	; 48
    4ebc:	91 e0       	ldi	r25, 0x01	; 1
    4ebe:	0e 94 c5 30 	call	0x618a	; 0x618a <MS_Device_ConfigureEndpoints>
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
    4ec2:	e2 ee       	ldi	r30, 0xE2	; 226
    4ec4:	f0 e0       	ldi	r31, 0x00	; 0
    4ec6:	80 81       	ld	r24, Z
    4ec8:	84 60       	ori	r24, 0x04	; 4
    4eca:	80 83       	st	Z, r24
    4ecc:	08 95       	ret

00004ece <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	MS_Device_ProcessControlRequest(&Disk_MS_Interface);
    4ece:	80 e3       	ldi	r24, 0x30	; 48
    4ed0:	91 e0       	ldi	r25, 0x01	; 1
    4ed2:	0e 94 88 30 	call	0x6110	; 0x6110 <MS_Device_ProcessControlRequest>
	HID_Device_ProcessControlRequest(&Keyboard_HID_Interface);
    4ed6:	80 e2       	ldi	r24, 0x20	; 32
    4ed8:	91 e0       	ldi	r25, 0x01	; 1
    4eda:	fa c6       	rjmp	.+3572   	; 0x5cd0 <HID_Device_ProcessControlRequest>
    4edc:	08 95       	ret

00004ede <EVENT_USB_Device_StartOfFrame>:
			 *  \param[in,out] HIDInterfaceInfo  Pointer to a structure containing a HID Class configuration and state.
			 */
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo) ATTR_ALWAYS_INLINE ATTR_NON_NULL_PTR_ARG(1);
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
			{
				if (HIDInterfaceInfo->State.IdleMSRemaining)
    4ede:	80 91 2e 01 	lds	r24, 0x012E
    4ee2:	90 91 2f 01 	lds	r25, 0x012F
    4ee6:	00 97       	sbiw	r24, 0x00	; 0
    4ee8:	29 f0       	breq	.+10     	; 0x4ef4 <EVENT_USB_Device_StartOfFrame+0x16>
				  HIDInterfaceInfo->State.IdleMSRemaining--;
    4eea:	01 97       	sbiw	r24, 0x01	; 1
    4eec:	90 93 2f 01 	sts	0x012F, r25
    4ef0:	80 93 2e 01 	sts	0x012E, r24
    4ef4:	08 95       	ret

00004ef6 <CALLBACK_MS_Device_SCSICommandReceived>:
 */
bool CALLBACK_MS_Device_SCSICommandReceived(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	bool CommandSuccess;

	CommandSuccess = SCSI_DecodeSCSICommand(MSInterfaceInfo);
    4ef6:	6f cb       	rjmp	.-2338   	; 0x45d6 <SCSI_DecodeSCSICommand>

	return CommandSuccess;
}
    4ef8:	08 95       	ret

00004efa <CALLBACK_HID_Device_CreateHIDReport>:
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
                                         uint8_t* const ReportID,
                                         const uint8_t ReportType,
                                         void* ReportData,
                                         uint16_t* const ReportSize)
{
    4efa:	0f 93       	push	r16
    4efc:	1f 93       	push	r17
	USB_KeyboardReport_Data_t* KeyboardReport = (USB_KeyboardReport_Data_t*)ReportData;

//	memcpy((void*)KeyboardReport->KeyCode, (void*)KeyBuffer->KeyCode, 6); //copy the keybuffer into the keyboard report being sent to host.
	KeyboardReport->KeyCode[0] = KeyBuffer->KeyCode[0];
    4efe:	e0 91 03 07 	lds	r30, 0x0703
    4f02:	f0 91 04 07 	lds	r31, 0x0704
    4f06:	82 81       	ldd	r24, Z+2	; 0x02
    4f08:	f9 01       	movw	r30, r18
    4f0a:	82 83       	std	Z+2, r24	; 0x02

	if (KeyboardReport->KeyCode[0]){ //if there is a key waiting to be sent, then use the modifier that goes with that key.
    4f0c:	88 23       	and	r24, r24
    4f0e:	21 f0       	breq	.+8      	; 0x4f18 <CALLBACK_HID_Device_CreateHIDReport+0x1e>
		KeyboardReport->Modifier = KeyBufferMod;
    4f10:	80 91 bb 06 	lds	r24, 0x06BB
    4f14:	80 83       	st	Z, r24
    4f16:	02 c0       	rjmp	.+4      	; 0x4f1c <CALLBACK_HID_Device_CreateHIDReport+0x22>
	}
	else {
		KeyboardReport->Modifier = 0; //otherwise, clear the modifiers so the host doesn't think we are holding down shift or alt or whatever for no reason.
    4f18:	f9 01       	movw	r30, r18
    4f1a:	10 82       	st	Z, r1
	}
	
//	memset((void*)KeyBuffer->KeyCode,0,6);  //clear keybuffer to clear room for the next key.  This indicates to other routines that the USB buffer is available for sending.
	KeyBuffer->KeyCode[0] = 0;
    4f1c:	e0 91 03 07 	lds	r30, 0x0703
    4f20:	f0 91 04 07 	lds	r31, 0x0704
    4f24:	12 82       	std	Z+2, r1	; 0x02
	KeyBufferMod= 0;
    4f26:	10 92 bb 06 	sts	0x06BB, r1

	*ReportSize = sizeof(USB_KeyboardReport_Data_t);
    4f2a:	88 e0       	ldi	r24, 0x08	; 8
    4f2c:	90 e0       	ldi	r25, 0x00	; 0
    4f2e:	f8 01       	movw	r30, r16
    4f30:	91 83       	std	Z+1, r25	; 0x01
    4f32:	80 83       	st	Z, r24
	return false;
}
    4f34:	80 e0       	ldi	r24, 0x00	; 0
    4f36:	1f 91       	pop	r17
    4f38:	0f 91       	pop	r16
    4f3a:	08 95       	ret

00004f3c <CALLBACK_HID_Device_ProcessHIDReport>:
                                          const uint16_t ReportSize)
{

	uint8_t* LEDReport = (uint8_t*)ReportData;

	if (*LEDReport & HID_KEYBOARD_LED_NUMLOCK) //if numlock is somehow active,
    4f3c:	f9 01       	movw	r30, r18
    4f3e:	80 81       	ld	r24, Z
    4f40:	80 ff       	sbrs	r24, 0
    4f42:	07 c0       	rjmp	.+14     	; 0x4f52 <CALLBACK_HID_Device_ProcessHIDReport+0x16>
	  KeyBuffer->KeyCode[0] = HID_KEYBOARD_LED_NUMLOCK; //press numlock key to deactivate it.
    4f44:	e0 91 03 07 	lds	r30, 0x0703
    4f48:	f0 91 04 07 	lds	r31, 0x0704
    4f4c:	81 e0       	ldi	r24, 0x01	; 1
    4f4e:	82 83       	std	Z+2, r24	; 0x02
    4f50:	08 95       	ret

	else if (*LEDReport & HID_KEYBOARD_LED_CAPSLOCK) //if capslock is somehow active,
    4f52:	81 ff       	sbrs	r24, 1
    4f54:	07 c0       	rjmp	.+14     	; 0x4f64 <CALLBACK_HID_Device_ProcessHIDReport+0x28>
	  KeyBuffer ->KeyCode[0] = HID_KEYBOARD_LED_CAPSLOCK; //press capslock key to deactivate it.
    4f56:	e0 91 03 07 	lds	r30, 0x0703
    4f5a:	f0 91 04 07 	lds	r31, 0x0704
    4f5e:	82 e0       	ldi	r24, 0x02	; 2
    4f60:	82 83       	std	Z+2, r24	; 0x02
    4f62:	08 95       	ret

	else if (*LEDReport & HID_KEYBOARD_LED_SCROLLLOCK) //if scrolllock is somehow active,
    4f64:	82 ff       	sbrs	r24, 2
    4f66:	06 c0       	rjmp	.+12     	; 0x4f74 <CALLBACK_HID_Device_ProcessHIDReport+0x38>
	  KeyBuffer ->KeyCode[0] = HID_KEYBOARD_LED_SCROLLLOCK; //press scrolllock key to deactivate it.
    4f68:	e0 91 03 07 	lds	r30, 0x0703
    4f6c:	f0 91 04 07 	lds	r31, 0x0704
    4f70:	84 e0       	ldi	r24, 0x04	; 4
    4f72:	82 83       	std	Z+2, r24	; 0x02
    4f74:	08 95       	ret

00004f76 <Init_Mode>:

}


void Init_Mode(){
    4f76:	cf 93       	push	r28
	uint8_t key;
	uint8_t code;
	uint8_t Default_Mode;
	
	Default_Mode = eeprom_read_byte((uint8_t*)DEFAULT_MODE_ADDR);
    4f78:	8d e0       	ldi	r24, 0x0D	; 13
    4f7a:	92 e0       	ldi	r25, 0x02	; 2
    4f7c:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    4f80:	c8 2f       	mov	r28, r24
	
	key = GetKeySimple(); //read the key that is being held during startup (if any)
    4f82:	e7 d3       	rcall	.+1998   	; 0x5752 <GetKeySimple>
	code = GetASCIIKeyCode(key,UPPER);
    4f84:	62 e0       	ldi	r22, 0x02	; 2
    4f86:	a3 d5       	rcall	.+2886   	; 0x5ace <GetASCIIKeyCode>
	
	if (is_low(S1)&&is_low(S2)&&is_low(S3)){ //reset device to known state
    4f88:	7c 99       	sbic	0x0f, 4	; 15
    4f8a:	0d c0       	rjmp	.+26     	; 0x4fa6 <Init_Mode+0x30>
    4f8c:	7d 99       	sbic	0x0f, 5	; 15
    4f8e:	0b c0       	rjmp	.+22     	; 0x4fa6 <Init_Mode+0x30>
    4f90:	7e 99       	sbic	0x0f, 6	; 15
    4f92:	09 c0       	rjmp	.+18     	; 0x4fa6 <Init_Mode+0x30>
			Typewriter_Mode = USB_COMBO_MODE;
    4f94:	81 e0       	ldi	r24, 0x01	; 1
    4f96:	80 93 09 08 	sts	0x0809, r24
			Default_Mode = USB_COMBO_MODE;
			GlowGreenLED(SLOW,GLOWING);
    4f9a:	60 e0       	ldi	r22, 0x00	; 0
    4f9c:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <GlowGreenLED>
			RestoreFactoryDefaults();			
    4fa0:	40 d6       	rcall	.+3200   	; 0x5c22 <RestoreFactoryDefaults>
	key = GetKeySimple(); //read the key that is being held during startup (if any)
	code = GetASCIIKeyCode(key,UPPER);
	
	if (is_low(S1)&&is_low(S2)&&is_low(S3)){ //reset device to known state
			Typewriter_Mode = USB_COMBO_MODE;
			Default_Mode = USB_COMBO_MODE;
    4fa2:	c1 e0       	ldi	r28, 0x01	; 1
			GlowGreenLED(SLOW,GLOWING);
			RestoreFactoryDefaults();			
    4fa4:	95 c0       	rjmp	.+298    	; 0x50d0 <Init_Mode+0x15a>
	}
	else if(is_low(S2)&&is_low(S3)){ //configure bluetooth and test bluetooth -- reset bluetooth module  -- force initialization next time bluetooth is used.
    4fa6:	7d 99       	sbic	0x0f, 5	; 15
    4fa8:	1f c0       	rjmp	.+62     	; 0x4fe8 <Init_Mode+0x72>
    4faa:	7e 99       	sbic	0x0f, 6	; 15
    4fac:	1d c0       	rjmp	.+58     	; 0x4fe8 <Init_Mode+0x72>
			if(Bluetooth_Configure()){
    4fae:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <Bluetooth_Configure>
    4fb2:	88 23       	and	r24, r24
    4fb4:	71 f0       	breq	.+28     	; 0x4fd2 <Init_Mode+0x5c>
					//this test mode resets the bluetooth channel.
					BluetoothInquire();//clear paired device list and try to pair.
    4fb6:	0e 94 aa 03 	call	0x754	; 0x754 <BluetoothInquire>
					BluetoothConfigured = 0;// even though it has been configured, save it as "not configured" to force configuration next time (on customer's end.)
    4fba:	10 92 fc 06 	sts	0x06FC, r1
					eeprom_update_byte((uint8_t*)BLUETOOTH_CONFIGURED_ADDR, BluetoothConfigured); 	
    4fbe:	60 e0       	ldi	r22, 0x00	; 0
    4fc0:	80 e1       	ldi	r24, 0x10	; 16
    4fc2:	92 e0       	ldi	r25, 0x02	; 2
    4fc4:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
					Typewriter_Mode = BLUETOOTH_MODE;
    4fc8:	89 e0       	ldi	r24, 0x09	; 9
    4fca:	80 93 09 08 	sts	0x0809, r24
					Default_Mode = BLUETOOTH_MODE;  //Do not set bluetooth mode as the default, since this mode only tests the bluetooth
    4fce:	c9 e0       	ldi	r28, 0x09	; 9
    4fd0:	7f c0       	rjmp	.+254    	; 0x50d0 <Init_Mode+0x15a>
			}
			else{ //if something goes wrong during configuration...
				BluetoothConfigured = 0;
    4fd2:	10 92 fc 06 	sts	0x06FC, r1
				eeprom_update_byte((uint8_t*)BLUETOOTH_CONFIGURED_ADDR, BluetoothConfigured); //remember that bluetooth has not been configured already.
    4fd6:	60 e0       	ldi	r22, 0x00	; 0
    4fd8:	80 e1       	ldi	r24, 0x10	; 16
    4fda:	92 e0       	ldi	r25, 0x02	; 2
    4fdc:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
				Typewriter_Mode = PANIC_MODE; //don't change default mode
    4fe0:	8a e0       	ldi	r24, 0x0A	; 10
    4fe2:	80 93 09 08 	sts	0x0809, r24
    4fe6:	74 c0       	rjmp	.+232    	; 0x50d0 <Init_Mode+0x15a>
			}
	}
	else if(is_low(S1)&&is_low(S2)){
    4fe8:	7c 99       	sbic	0x0f, 4	; 15
    4fea:	06 c0       	rjmp	.+12     	; 0x4ff8 <Init_Mode+0x82>
    4fec:	7d 99       	sbic	0x0f, 5	; 15
    4fee:	04 c0       	rjmp	.+8      	; 0x4ff8 <Init_Mode+0x82>
			Typewriter_Mode = SD_MODE;
    4ff0:	82 e0       	ldi	r24, 0x02	; 2
    4ff2:	80 93 09 08 	sts	0x0809, r24
    4ff6:	6c c0       	rjmp	.+216    	; 0x50d0 <Init_Mode+0x15a>
	}
	else if(is_low(S1)&&is_low(S3)){//quick calibration mode
    4ff8:	7c 99       	sbic	0x0f, 4	; 15
    4ffa:	06 c0       	rjmp	.+12     	; 0x5008 <Init_Mode+0x92>
    4ffc:	7e 99       	sbic	0x0f, 6	; 15
    4ffe:	04 c0       	rjmp	.+8      	; 0x5008 <Init_Mode+0x92>
			Typewriter_Mode = QUICK_CAL_MODE;
    5000:	86 e0       	ldi	r24, 0x06	; 6
    5002:	80 93 09 08 	sts	0x0809, r24
    5006:	64 c0       	rjmp	.+200    	; 0x50d0 <Init_Mode+0x15a>
	}
	else if (is_low(S1)){ //hold down S1 during initialization to calibrate
    5008:	7c 99       	sbic	0x0f, 4	; 15
    500a:	04 c0       	rjmp	.+8      	; 0x5014 <Init_Mode+0x9e>
			Typewriter_Mode = CAL_MODE;
    500c:	85 e0       	ldi	r24, 0x05	; 5
    500e:	80 93 09 08 	sts	0x0809, r24
    5012:	5e c0       	rjmp	.+188    	; 0x50d0 <Init_Mode+0x15a>
	}
	else if(is_low(S2)){
    5014:	7d 99       	sbic	0x0f, 5	; 15
    5016:	04 c0       	rjmp	.+8      	; 0x5020 <Init_Mode+0xaa>
		Typewriter_Mode = SENSITIVITY_MODE;
    5018:	83 e0       	ldi	r24, 0x03	; 3
    501a:	80 93 09 08 	sts	0x0809, r24
    501e:	58 c0       	rjmp	.+176    	; 0x50d0 <Init_Mode+0x15a>
	}
	else if (is_low(S3)){ //hold down S3 to enter LED indication mode to test reed switches.
    5020:	7e 99       	sbic	0x0f, 6	; 15
    5022:	04 c0       	rjmp	.+8      	; 0x502c <Init_Mode+0xb6>
		Typewriter_Mode = TEST_MODE;
    5024:	84 e0       	ldi	r24, 0x04	; 4
    5026:	80 93 09 08 	sts	0x0809, r24
    502a:	52 c0       	rjmp	.+164    	; 0x50d0 <Init_Mode+0x15a>
	}
	else if(code == 'U'){ //if the letter U is being held by user
    502c:	85 35       	cpi	r24, 0x55	; 85
    502e:	39 f4       	brne	.+14     	; 0x503e <Init_Mode+0xc8>
		Typewriter_Mode = USB_COMBO_MODE;
    5030:	81 e0       	ldi	r24, 0x01	; 1
    5032:	80 93 09 08 	sts	0x0809, r24
		Default_Mode = USB_COMBO_MODE;	
		Ignore_Flag = 1; //tell sensor routine to ignore this U.
    5036:	80 93 02 07 	sts	0x0702, r24
	else if (is_low(S3)){ //hold down S3 to enter LED indication mode to test reed switches.
		Typewriter_Mode = TEST_MODE;
	}
	else if(code == 'U'){ //if the letter U is being held by user
		Typewriter_Mode = USB_COMBO_MODE;
		Default_Mode = USB_COMBO_MODE;	
    503a:	c1 e0       	ldi	r28, 0x01	; 1
    503c:	49 c0       	rjmp	.+146    	; 0x50d0 <Init_Mode+0x15a>
		Ignore_Flag = 1; //tell sensor routine to ignore this U.
	}
	else if(code == 'S'){//if the letter S is being held by the user
    503e:	83 35       	cpi	r24, 0x53	; 83
    5040:	81 f4       	brne	.+32     	; 0x5062 <Init_Mode+0xec>
		if(SDCardManager_CheckSDCardOperation()){ //if an sd card is present and working, put typewriter into sd mode
    5042:	bc dd       	rcall	.-1160   	; 0x4bbc <SDCardManager_CheckSDCardOperation>
    5044:	88 23       	and	r24, r24
    5046:	41 f0       	breq	.+16     	; 0x5058 <Init_Mode+0xe2>
			Typewriter_Mode = SD_MODE;
    5048:	82 e0       	ldi	r24, 0x02	; 2
    504a:	80 93 09 08 	sts	0x0809, r24
			Default_Mode = SD_MODE;
			Ignore_Flag = 1; //tell sensor routine to ignore this S.
    504e:	81 e0       	ldi	r24, 0x01	; 1
    5050:	80 93 02 07 	sts	0x0702, r24
		Ignore_Flag = 1; //tell sensor routine to ignore this U.
	}
	else if(code == 'S'){//if the letter S is being held by the user
		if(SDCardManager_CheckSDCardOperation()){ //if an sd card is present and working, put typewriter into sd mode
			Typewriter_Mode = SD_MODE;
			Default_Mode = SD_MODE;
    5054:	c2 e0       	ldi	r28, 0x02	; 2
    5056:	3c c0       	rjmp	.+120    	; 0x50d0 <Init_Mode+0x15a>
			Ignore_Flag = 1; //tell sensor routine to ignore this S.
		}
		else{
			Typewriter_Mode = PANIC_MODE; //otherwise, panic to indicate malfunction ... don't change default mode.
    5058:	8a e0       	ldi	r24, 0x0A	; 10
    505a:	80 93 09 08 	sts	0x0809, r24
			Default_Mode = SD_MODE; //even so, sd mode next time you plug in.
    505e:	c2 e0       	ldi	r28, 0x02	; 2
    5060:	37 c0       	rjmp	.+110    	; 0x50d0 <Init_Mode+0x15a>
		}
	}
	else if(code == 'B'){ //if the letter B is being held by the user
    5062:	82 34       	cpi	r24, 0x42	; 66
    5064:	61 f5       	brne	.+88     	; 0x50be <Init_Mode+0x148>
		USB_Disable();
    5066:	0e 94 36 36 	call	0x6c6c	; 0x6c6c <USB_Disable>
		if(BluetoothConfigured){
    506a:	80 91 fc 06 	lds	r24, 0x06FC
    506e:	88 23       	and	r24, r24
    5070:	39 f0       	breq	.+14     	; 0x5080 <Init_Mode+0x10a>
			BluetoothInquire();//get a new device to pair with when you hold b key down.
    5072:	0e 94 aa 03 	call	0x754	; 0x754 <BluetoothInquire>
			Typewriter_Mode = BLUETOOTH_MODE; // for now, this is commented out
    5076:	89 e0       	ldi	r24, 0x09	; 9
    5078:	80 93 09 08 	sts	0x0809, r24
			Default_Mode = BLUETOOTH_MODE;
    507c:	c9 e0       	ldi	r28, 0x09	; 9
    507e:	28 c0       	rjmp	.+80     	; 0x50d0 <Init_Mode+0x15a>
		}
		else if(Bluetooth_Configure()){ // attempt to configure.
    5080:	0e 94 6b 03 	call	0x6d6	; 0x6d6 <Bluetooth_Configure>
    5084:	88 23       	and	r24, r24
    5086:	81 f0       	breq	.+32     	; 0x50a8 <Init_Mode+0x132>
			BluetoothConfigured = 1;
    5088:	81 e0       	ldi	r24, 0x01	; 1
    508a:	80 93 fc 06 	sts	0x06FC, r24
			BluetoothInquire(); //get a new device to pair with when you hold b key down.
    508e:	0e 94 aa 03 	call	0x754	; 0x754 <BluetoothInquire>
			eeprom_update_byte((uint8_t*)BLUETOOTH_CONFIGURED_ADDR, BluetoothConfigured); //remember that bluetooth has been configured already.	
    5092:	60 91 fc 06 	lds	r22, 0x06FC
    5096:	80 e1       	ldi	r24, 0x10	; 16
    5098:	92 e0       	ldi	r25, 0x02	; 2
    509a:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
			Typewriter_Mode = BLUETOOTH_MODE;
    509e:	89 e0       	ldi	r24, 0x09	; 9
    50a0:	80 93 09 08 	sts	0x0809, r24
			Default_Mode = BLUETOOTH_MODE;
    50a4:	c9 e0       	ldi	r28, 0x09	; 9
    50a6:	14 c0       	rjmp	.+40     	; 0x50d0 <Init_Mode+0x15a>
		}
		else{ //if something goes wrong during configuration...
			BluetoothConfigured = 0;
    50a8:	10 92 fc 06 	sts	0x06FC, r1
			eeprom_update_byte((uint8_t*)BLUETOOTH_CONFIGURED_ADDR, BluetoothConfigured); //remember that bluetooth has NOT been configured successfully.
    50ac:	60 e0       	ldi	r22, 0x00	; 0
    50ae:	80 e1       	ldi	r24, 0x10	; 16
    50b0:	92 e0       	ldi	r25, 0x02	; 2
    50b2:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
			Typewriter_Mode = PANIC_MODE; //indicate error
    50b6:	8a e0       	ldi	r24, 0x0A	; 10
    50b8:	80 93 09 08 	sts	0x0809, r24
    50bc:	09 c0       	rjmp	.+18     	; 0x50d0 <Init_Mode+0x15a>
		}
	}
	else if(code == 'L'){
    50be:	8c 34       	cpi	r24, 0x4C	; 76
    50c0:	29 f4       	brne	.+10     	; 0x50cc <Init_Mode+0x156>
			Typewriter_Mode = USB_LIGHT_MODE;
    50c2:	8d e0       	ldi	r24, 0x0D	; 13
    50c4:	80 93 09 08 	sts	0x0809, r24
			Default_Mode = USB_LIGHT_MODE;
    50c8:	cd e0       	ldi	r28, 0x0D	; 13
    50ca:	02 c0       	rjmp	.+4      	; 0x50d0 <Init_Mode+0x15a>
	}

	else{
		Typewriter_Mode = Default_Mode; //otherwise just go into the last mode selected by user.
    50cc:	c0 93 09 08 	sts	0x0809, r28
	}
	
	eeprom_update_byte((uint8_t*)DEFAULT_MODE_ADDR,Default_Mode);  //Save the new default mode (if changed)
    50d0:	6c 2f       	mov	r22, r28
    50d2:	8d e0       	ldi	r24, 0x0D	; 13
    50d4:	92 e0       	ldi	r25, 0x02	; 2
    50d6:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
}
    50da:	cf 91       	pop	r28
    50dc:	08 95       	ret

000050de <main>:
	uint8_t key;
	uint8_t code;
	uint8_t modifier;
	uint8_t parity;
	
	Typewriter_Mode = INITIALIZING;
    50de:	8c e0       	ldi	r24, 0x0C	; 12
    50e0:	80 93 09 08 	sts	0x0809, r24

	SetupHardware();
    50e4:	83 de       	rcall	.-762    	; 0x4dec <SetupHardware>
	InitializeEeprom();//sets all EEPROM entries to zero if the checksum is incorrect
    50e6:	cd d5       	rcall	.+2970   	; 0x5c82 <InitializeEeprom>
	LoadEepromParameters();
    50e8:	39 d5       	rcall	.+2674   	; 0x5b5c <LoadEepromParameters>
	LoadKeyCodeTables();
    50ea:	0f d5       	rcall	.+2590   	; 0x5b0a <LoadKeyCodeTables>
	SDCardManager_Init(); 
    50ec:	1c dc       	rcall	.-1992   	; 0x4926 <SDCardManager_Init>
	USB_Init();//DEBUG ONLY
    50ee:	0e 94 8e 36 	call	0x6d1c	; 0x6d1c <USB_Init>
	uart_init(UART_BAUD_SELECT(9600,F_CPU));//initialize the uart with a baud rate of x bps
    50f2:	83 e3       	ldi	r24, 0x33	; 51
    50f4:	90 e0       	ldi	r25, 0x00	; 0
    50f6:	bd dd       	rcall	.-1158   	; 0x4c72 <uart_init>
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    50f8:	78 94       	sei

	//USB_Init(); COMMENTED FOR DEBUGGING
	GlobalInterruptEnable();
	
	Bluetooth_Init();
    50fa:	0e 94 51 03 	call	0x6a2	; 0x6a2 <Bluetooth_Init>
	
	Init_Mode();
    50fe:	3b df       	rcall	.-394    	; 0x4f76 <Init_Mode>
				USB_Disable(); //make sure no host is connected before accessing SD card.
				LogKeystrokes();
			break;
			case CAL_MODE:
				Calibrate();
				Typewriter_Mode = USB_LIGHT_MODE; //after calibrating, go to usb light mode.
    5100:	1d e0       	ldi	r17, 0x0D	; 13
			case SENSITIVITY_MODE:
				Adjust_Sensitivity();
				Typewriter_Mode = USB_LIGHT_MODE;
			break;
			default:
				Typewriter_Mode = PANIC_MODE;
    5102:	0a e0       	ldi	r16, 0x0A	; 10
	
	Init_Mode();
//	Delay_MS(INIT_DELAY);
	
	while(1){
		switch (Typewriter_Mode){
    5104:	80 91 09 08 	lds	r24, 0x0809
    5108:	85 30       	cpi	r24, 0x05	; 5
    510a:	09 f4       	brne	.+2      	; 0x510e <main+0x30>
    510c:	80 c0       	rjmp	.+256    	; 0x520e <main+0x130>
    510e:	74 f4       	brge	.+28     	; 0x512c <main+0x4e>
    5110:	82 30       	cpi	r24, 0x02	; 2
    5112:	09 f4       	brne	.+2      	; 0x5116 <main+0x38>
    5114:	71 c0       	rjmp	.+226    	; 0x51f8 <main+0x11a>
    5116:	1c f4       	brge	.+6      	; 0x511e <main+0x40>
    5118:	81 30       	cpi	r24, 0x01	; 1
    511a:	c9 f0       	breq	.+50     	; 0x514e <main+0x70>
    511c:	ea c0       	rjmp	.+468    	; 0x52f2 <main+0x214>
    511e:	83 30       	cpi	r24, 0x03	; 3
    5120:	09 f4       	brne	.+2      	; 0x5124 <main+0x46>
    5122:	e2 c0       	rjmp	.+452    	; 0x52e8 <main+0x20a>
    5124:	84 30       	cpi	r24, 0x04	; 4
    5126:	09 f4       	brne	.+2      	; 0x512a <main+0x4c>
    5128:	39 c0       	rjmp	.+114    	; 0x519c <main+0xbe>
    512a:	e3 c0       	rjmp	.+454    	; 0x52f2 <main+0x214>
    512c:	8a 30       	cpi	r24, 0x0A	; 10
    512e:	09 f4       	brne	.+2      	; 0x5132 <main+0x54>
    5130:	c2 c0       	rjmp	.+388    	; 0x52b6 <main+0x1d8>
    5132:	3c f4       	brge	.+14     	; 0x5142 <main+0x64>
    5134:	86 30       	cpi	r24, 0x06	; 6
    5136:	09 f4       	brne	.+2      	; 0x513a <main+0x5c>
    5138:	6f c0       	rjmp	.+222    	; 0x5218 <main+0x13a>
    513a:	89 30       	cpi	r24, 0x09	; 9
    513c:	09 f4       	brne	.+2      	; 0x5140 <main+0x62>
    513e:	71 c0       	rjmp	.+226    	; 0x5222 <main+0x144>
    5140:	d8 c0       	rjmp	.+432    	; 0x52f2 <main+0x214>
    5142:	8b 30       	cpi	r24, 0x0B	; 11
    5144:	09 f4       	brne	.+2      	; 0x5148 <main+0x6a>
    5146:	54 c0       	rjmp	.+168    	; 0x51f0 <main+0x112>
    5148:	8d 30       	cpi	r24, 0x0D	; 13
    514a:	09 f0       	breq	.+2      	; 0x514e <main+0x70>
    514c:	d2 c0       	rjmp	.+420    	; 0x52f2 <main+0x214>
			case USB_LIGHT_MODE:
			case USB_COMBO_MODE:				
			MountFilesystem();//mount the filesystem so that we have info on it
    514e:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <MountFilesystem>
			while(1){
				key = GetKey();
    5152:	27 d3       	rcall	.+1614   	; 0x57a2 <GetKey>
    5154:	c8 2f       	mov	r28, r24
				modifier = GetModifier(); 
    5156:	f2 d1       	rcall	.+996    	; 0x553c <GetModifier>
    5158:	d8 2f       	mov	r29, r24
				code = GetHIDKeyCode(key, modifier);
    515a:	68 2f       	mov	r22, r24
    515c:	8c 2f       	mov	r24, r28
    515e:	9f d4       	rcall	.+2366   	; 0x5a9e <GetHIDKeyCode>
				
				if(FnKeyCodeLookUpTable[key]){modifier &= ~HID_KEYBOARD_MODIFIER_LEFTALT;}// if the key is in the function table, it is a special key.  The alt modifier should not be sent..
    5160:	ec 2f       	mov	r30, r28
    5162:	f0 e0       	ldi	r31, 0x00	; 0
    5164:	e6 5f       	subi	r30, 0xF6	; 246
    5166:	f5 4f       	sbci	r31, 0xF5	; 245
    5168:	90 81       	ld	r25, Z
    516a:	91 11       	cpse	r25, r1
    516c:	db 7f       	andi	r29, 0xFB	; 251
					
				if(code){//if the code is valid, send it
    516e:	88 23       	and	r24, r24
    5170:	51 f0       	breq	.+20     	; 0x5186 <main+0xa8>
						if ((code == KEY_U)&&Ignore_Flag) code = 0; //if user is holding down U on startup, don't add this U to file.
    5172:	88 31       	cpi	r24, 0x18	; 24
    5174:	21 f4       	brne	.+8      	; 0x517e <main+0xa0>
    5176:	90 91 02 07 	lds	r25, 0x0702
    517a:	91 11       	cpse	r25, r1
    517c:	80 e0       	ldi	r24, 0x00	; 0
						Ignore_Flag = 0;
    517e:	10 92 02 07 	sts	0x0702, r1
						USBSend(code,modifier);
    5182:	6d 2f       	mov	r22, r29
    5184:	b9 d0       	rcall	.+370    	; 0x52f8 <USBSend>
    5186:	8f ec       	ldi	r24, 0xCF	; 207
    5188:	97 e0       	ldi	r25, 0x07	; 7
    518a:	01 97       	sbiw	r24, 0x01	; 1
    518c:	f1 f7       	brne	.-4      	; 0x518a <main+0xac>
    518e:	00 c0       	rjmp	.+0      	; 0x5190 <main+0xb2>
    5190:	00 00       	nop
				}
				Delay_MS(SENSE_DELAY);//perform this loop every X ms.
				HID_Device_USBTask(&Keyboard_HID_Interface);
    5192:	80 e2       	ldi	r24, 0x20	; 32
    5194:	91 e0       	ldi	r25, 0x01	; 1
    5196:	fb d6       	rcall	.+3574   	; 0x5f8e <HID_Device_USBTask>
				Task_Manager(); //do the required usb upkeep tasks, then update the list of scheduled tasks.
    5198:	02 de       	rcall	.-1020   	; 0x4d9e <Task_Manager>
				
			}
    519a:	db cf       	rjmp	.-74     	; 0x5152 <main+0x74>
			break;
			case TEST_MODE:
				USB_Disable(); //USB not needed for testing
    519c:	0e 94 36 36 	call	0x6c6c	; 0x6c6c <USB_Disable>
				while(1){
					UseHallSensor = HALL_NOT_PRESENT;//make sure hall sensor bit is not zeroed out by ReadSensor() as soon as it is read;
					parity = (uint8_t)is_low(REED_1) + (uint8_t)is_low(REED_2)+ (uint8_t)is_low(REED_3) + (uint8_t)is_low(REED_4) + (uint8_t)getHallState();
    51a0:	d1 e0       	ldi	r29, 0x01	; 1
			}
			break;
			case TEST_MODE:
				USB_Disable(); //USB not needed for testing
				while(1){
					UseHallSensor = HALL_NOT_PRESENT;//make sure hall sensor bit is not zeroed out by ReadSensor() as soon as it is read;
    51a2:	10 92 89 07 	sts	0x0789, r1
					parity = (uint8_t)is_low(REED_1) + (uint8_t)is_low(REED_2)+ (uint8_t)is_low(REED_3) + (uint8_t)is_low(REED_4) + (uint8_t)getHallState();
    51a6:	89 b1       	in	r24, 0x09	; 9
    51a8:	c9 b1       	in	r28, 0x09	; 9
    51aa:	29 b1       	in	r18, 0x09	; 9
    51ac:	93 b1       	in	r25, 0x03	; 3
    51ae:	c6 fb       	bst	r28, 6
    51b0:	cc 27       	eor	r28, r28
    51b2:	c0 f9       	bld	r28, 0
    51b4:	cd 27       	eor	r28, r29
    51b6:	82 95       	swap	r24
    51b8:	81 70       	andi	r24, 0x01	; 1
    51ba:	8d 27       	eor	r24, r29
    51bc:	c8 0f       	add	r28, r24
    51be:	20 95       	com	r18
    51c0:	22 1f       	adc	r18, r18
    51c2:	22 27       	eor	r18, r18
    51c4:	22 1f       	adc	r18, r18
    51c6:	c2 0f       	add	r28, r18
    51c8:	92 95       	swap	r25
    51ca:	91 70       	andi	r25, 0x01	; 1
    51cc:	9d 27       	eor	r25, r29
    51ce:	c9 0f       	add	r28, r25
    51d0:	93 d4       	rcall	.+2342   	; 0x5af8 <getHallState>
    51d2:	8c 0f       	add	r24, r28
				
					if (parity & 1){  //if first bit of parity is 1, then an odd number of sensors are active.
    51d4:	80 ff       	sbrs	r24, 0
    51d6:	03 c0       	rjmp	.+6      	; 0x51de <main+0x100>
						set_high(LED1);
    51d8:	46 9a       	sbi	0x08, 6	; 8
						set_low(LED2);
    51da:	2e 98       	cbi	0x05, 6	; 5
    51dc:	02 c0       	rjmp	.+4      	; 0x51e2 <main+0x104>
					}
					else{ //otherwise, an even number (or zero) are active.
						set_low(LED1);
    51de:	46 98       	cbi	0x08, 6	; 8
						set_high(LED2);
    51e0:	2e 9a       	sbi	0x05, 6	; 5
    51e2:	8f ec       	ldi	r24, 0xCF	; 207
    51e4:	97 e0       	ldi	r25, 0x07	; 7
    51e6:	01 97       	sbiw	r24, 0x01	; 1
    51e8:	f1 f7       	brne	.-4      	; 0x51e6 <main+0x108>
    51ea:	00 c0       	rjmp	.+0      	; 0x51ec <main+0x10e>
    51ec:	00 00       	nop
    51ee:	d9 cf       	rjmp	.-78     	; 0x51a2 <main+0xc4>
					}
					Delay_MS(SENSE_DELAY);
				}
			break;
			case HARDWARE_TEST:				
				USB_Disable(); //make sure no host is connected before accessing SD card.
    51f0:	0e 94 36 36 	call	0x6c6c	; 0x6c6c <USB_Disable>
				TestSDHardware();
    51f4:	0e 94 6f 0b 	call	0x16de	; 0x16de <TestSDHardware>
			case SD_MODE:
				if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
    51f8:	80 91 b7 06 	lds	r24, 0x06B7
    51fc:	88 23       	and	r24, r24
    51fe:	11 f0       	breq	.+4      	; 0x5204 <main+0x126>
    5200:	5d 98       	cbi	0x0b, 5	; 11
    5202:	55 9a       	sbi	0x0a, 5	; 10
				USB_Disable(); //make sure no host is connected before accessing SD card.
    5204:	0e 94 36 36 	call	0x6c6c	; 0x6c6c <USB_Disable>
				LogKeystrokes();
    5208:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <LogKeystrokes>
			break;
    520c:	7b cf       	rjmp	.-266    	; 0x5104 <main+0x26>
			case CAL_MODE:
				Calibrate();
    520e:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <Calibrate>
				Typewriter_Mode = USB_LIGHT_MODE; //after calibrating, go to usb light mode.
    5212:	10 93 09 08 	sts	0x0809, r17
			break;
    5216:	76 cf       	rjmp	.-276    	; 0x5104 <main+0x26>
			case QUICK_CAL_MODE:
				QuickCalibrate();
    5218:	0e 94 90 05 	call	0xb20	; 0xb20 <QuickCalibrate>
				Typewriter_Mode = USB_LIGHT_MODE;//after calibrating, go to usb light mode.
    521c:	10 93 09 08 	sts	0x0809, r17
			break;
    5220:	71 cf       	rjmp	.-286    	; 0x5104 <main+0x26>
			case BLUETOOTH_MODE:
				#ifndef _DEBUG
					USB_Disable();//don't disable usb if it is debug mode
    5222:	0e 94 36 36 	call	0x6c6c	; 0x6c6c <USB_Disable>
				#endif
				if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
    5226:	80 91 b7 06 	lds	r24, 0x06B7
    522a:	88 23       	and	r24, r24
    522c:	11 f0       	breq	.+4      	; 0x5232 <main+0x154>
    522e:	5d 98       	cbi	0x0b, 5	; 11
    5230:	55 9a       	sbi	0x0a, 5	; 10
				
				while(is_low(BT_CONNECTED)){
    5232:	79 99       	sbic	0x0f, 1	; 15
    5234:	0f c0       	rjmp	.+30     	; 0x5254 <main+0x176>
					set_low(RED_LED);
    5236:	2e 98       	cbi	0x05, 6	; 5
					set_high(GREEN_LED);
    5238:	46 9a       	sbi	0x08, 6	; 8
					Bluetooth_Connect();
    523a:	0e 94 af 03 	call	0x75e	; 0x75e <Bluetooth_Connect>
    523e:	9f ef       	ldi	r25, 0xFF	; 255
    5240:	21 e1       	ldi	r18, 0x11	; 17
    5242:	8a e7       	ldi	r24, 0x7A	; 122
    5244:	91 50       	subi	r25, 0x01	; 1
    5246:	20 40       	sbci	r18, 0x00	; 0
    5248:	80 40       	sbci	r24, 0x00	; 0
    524a:	e1 f7       	brne	.-8      	; 0x5244 <main+0x166>
    524c:	00 c0       	rjmp	.+0      	; 0x524e <main+0x170>
    524e:	00 00       	nop
				#ifndef _DEBUG
					USB_Disable();//don't disable usb if it is debug mode
				#endif
				if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
				
				while(is_low(BT_CONNECTED)){
    5250:	79 9b       	sbis	0x0f, 1	; 15
    5252:	f1 cf       	rjmp	.-30     	; 0x5236 <main+0x158>
					set_low(RED_LED);
					set_high(GREEN_LED);
					Bluetooth_Connect();
					Delay_MS(5000);
				}//wait for connection to happen, glow red until then.
				while(is_high(BT_CONNECTED)){
    5254:	79 9b       	sbis	0x0f, 1	; 15
    5256:	56 cf       	rjmp	.-340    	; 0x5104 <main+0x26>
					set_high(RED_LED);//turn off red led if bt is connected.
    5258:	2e 9a       	sbi	0x05, 6	; 5
					set_low(GREEN_LED);
    525a:	46 98       	cbi	0x08, 6	; 8
					while(is_high(BT_CONNECTED)){
    525c:	79 9b       	sbis	0x0f, 1	; 15
    525e:	0f c0       	rjmp	.+30     	; 0x527e <main+0x1a0>
						Bluetooth_Send(KEY_Z,LOWER);
    5260:	60 e0       	ldi	r22, 0x00	; 0
    5262:	8d e1       	ldi	r24, 0x1D	; 29
    5264:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <Bluetooth_Send>
    5268:	9f ef       	ldi	r25, 0xFF	; 255
    526a:	2d e3       	ldi	r18, 0x3D	; 61
    526c:	89 e4       	ldi	r24, 0x49	; 73
    526e:	91 50       	subi	r25, 0x01	; 1
    5270:	20 40       	sbci	r18, 0x00	; 0
    5272:	80 40       	sbci	r24, 0x00	; 0
    5274:	e1 f7       	brne	.-8      	; 0x526e <main+0x190>
    5276:	00 c0       	rjmp	.+0      	; 0x5278 <main+0x19a>
    5278:	00 00       	nop
					Delay_MS(5000);
				}//wait for connection to happen, glow red until then.
				while(is_high(BT_CONNECTED)){
					set_high(RED_LED);//turn off red led if bt is connected.
					set_low(GREEN_LED);
					while(is_high(BT_CONNECTED)){
    527a:	79 99       	sbic	0x0f, 1	; 15
    527c:	f1 cf       	rjmp	.-30     	; 0x5260 <main+0x182>
						Bluetooth_Send(KEY_Z,LOWER);
						Delay_MS(3000);
					}
					key = GetKey();
    527e:	91 d2       	rcall	.+1314   	; 0x57a2 <GetKey>
    5280:	c8 2f       	mov	r28, r24
					modifier = GetModifier();
    5282:	5c d1       	rcall	.+696    	; 0x553c <GetModifier>
    5284:	d8 2f       	mov	r29, r24
									
					code = GetHIDKeyCode(key, modifier);
    5286:	68 2f       	mov	r22, r24
    5288:	8c 2f       	mov	r24, r28
    528a:	09 d4       	rcall	.+2066   	; 0x5a9e <GetHIDKeyCode>
					
					if(FnKeyCodeLookUpTable[key]){modifier &= ~HID_KEYBOARD_MODIFIER_LEFTALT;}// if the key is in the function table, it is a special key.  The alt modifier should not be sent..
    528c:	ec 2f       	mov	r30, r28
    528e:	f0 e0       	ldi	r31, 0x00	; 0
    5290:	e6 5f       	subi	r30, 0xF6	; 246
    5292:	f5 4f       	sbci	r31, 0xF5	; 245
    5294:	90 81       	ld	r25, Z
    5296:	91 11       	cpse	r25, r1
    5298:	db 7f       	andi	r29, 0xFB	; 251
									
						if(code){
    529a:	88 23       	and	r24, r24
    529c:	19 f0       	breq	.+6      	; 0x52a4 <main+0x1c6>
						Bluetooth_Send(code,modifier);
    529e:	6d 2f       	mov	r22, r29
    52a0:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <Bluetooth_Send>
    52a4:	8f ec       	ldi	r24, 0xCF	; 207
    52a6:	97 e0       	ldi	r25, 0x07	; 7
    52a8:	01 97       	sbiw	r24, 0x01	; 1
    52aa:	f1 f7       	brne	.-4      	; 0x52a8 <main+0x1ca>
    52ac:	00 c0       	rjmp	.+0      	; 0x52ae <main+0x1d0>
    52ae:	00 00       	nop
					set_low(RED_LED);
					set_high(GREEN_LED);
					Bluetooth_Connect();
					Delay_MS(5000);
				}//wait for connection to happen, glow red until then.
				while(is_high(BT_CONNECTED)){
    52b0:	79 99       	sbic	0x0f, 1	; 15
    52b2:	d2 cf       	rjmp	.-92     	; 0x5258 <main+0x17a>
    52b4:	27 cf       	rjmp	.-434    	; 0x5104 <main+0x26>
					
					
				}
			break;
			case PANIC_MODE:
				USB_Disable();
    52b6:	0e 94 36 36 	call	0x6c6c	; 0x6c6c <USB_Disable>
				while(1){
					set_high(LED2);
    52ba:	2e 9a       	sbi	0x05, 6	; 5
					set_low(LED1);
    52bc:	46 98       	cbi	0x08, 6	; 8
    52be:	9f ef       	ldi	r25, 0xFF	; 255
    52c0:	21 ee       	ldi	r18, 0xE1	; 225
    52c2:	84 e0       	ldi	r24, 0x04	; 4
    52c4:	91 50       	subi	r25, 0x01	; 1
    52c6:	20 40       	sbci	r18, 0x00	; 0
    52c8:	80 40       	sbci	r24, 0x00	; 0
    52ca:	e1 f7       	brne	.-8      	; 0x52c4 <main+0x1e6>
    52cc:	00 c0       	rjmp	.+0      	; 0x52ce <main+0x1f0>
    52ce:	00 00       	nop
					Delay_MS(200);
					set_high(LED1);
    52d0:	46 9a       	sbi	0x08, 6	; 8
					set_low(LED2);
    52d2:	2e 98       	cbi	0x05, 6	; 5
    52d4:	9f ef       	ldi	r25, 0xFF	; 255
    52d6:	21 ee       	ldi	r18, 0xE1	; 225
    52d8:	84 e0       	ldi	r24, 0x04	; 4
    52da:	91 50       	subi	r25, 0x01	; 1
    52dc:	20 40       	sbci	r18, 0x00	; 0
    52de:	80 40       	sbci	r24, 0x00	; 0
    52e0:	e1 f7       	brne	.-8      	; 0x52da <main+0x1fc>
    52e2:	00 c0       	rjmp	.+0      	; 0x52e4 <main+0x206>
    52e4:	00 00       	nop
    52e6:	e9 cf       	rjmp	.-46     	; 0x52ba <main+0x1dc>
					Delay_MS(200);
				}		
			break;
			case SENSITIVITY_MODE:
				Adjust_Sensitivity();
    52e8:	0e 94 93 08 	call	0x1126	; 0x1126 <Adjust_Sensitivity>
				Typewriter_Mode = USB_LIGHT_MODE;
    52ec:	10 93 09 08 	sts	0x0809, r17
			break;
    52f0:	09 cf       	rjmp	.-494    	; 0x5104 <main+0x26>
			default:
				Typewriter_Mode = PANIC_MODE;
    52f2:	00 93 09 08 	sts	0x0809, r16
			break;
    52f6:	06 cf       	rjmp	.-500    	; 0x5104 <main+0x26>

000052f8 <USBSend>:
#include <ctype.h> // allows toupper()

extern USB_ClassInfo_HID_Device_t Keyboard_HID_Interface; //import the keyboard interface object from main routine so we can call usbtask on it.

/*Send a character over usb with a given modifier (shift, ctrl, etc)*/
void USBSend(uint8_t code,uint8_t mod){	
    52f8:	cf 93       	push	r28
    52fa:	df 93       	push	r29
    52fc:	c8 2f       	mov	r28, r24
    52fe:	d6 2f       	mov	r29, r22
	
	TMR1_Count = 0;
    5300:	10 92 01 07 	sts	0x0701, r1
    5304:	10 92 00 07 	sts	0x0700, r1
	while (KeyBuffer->KeyCode[0] && TMR1_Count < USB_SEND_TIMEOUT) {
    5308:	0b c0       	rjmp	.+22     	; 0x5320 <USBSend+0x28>
		if((Typewriter_Mode == USB_COMBO_MODE) || (Typewriter_Mode == USB_LIGHT_MODE)){ //interrupts do not handle keyboard stuff during this mode.
    530a:	90 91 09 08 	lds	r25, 0x0809
    530e:	91 30       	cpi	r25, 0x01	; 1
    5310:	21 f0       	breq	.+8      	; 0x531a <USBSend+0x22>
    5312:	90 91 09 08 	lds	r25, 0x0809
    5316:	9d 30       	cpi	r25, 0x0D	; 13
    5318:	19 f4       	brne	.+6      	; 0x5320 <USBSend+0x28>
			HID_Device_USBTask(&Keyboard_HID_Interface);
    531a:	80 e2       	ldi	r24, 0x20	; 32
    531c:	91 e0       	ldi	r25, 0x01	; 1
    531e:	37 d6       	rcall	.+3182   	; 0x5f8e <HID_Device_USBTask>

/*Send a character over usb with a given modifier (shift, ctrl, etc)*/
void USBSend(uint8_t code,uint8_t mod){	
	
	TMR1_Count = 0;
	while (KeyBuffer->KeyCode[0] && TMR1_Count < USB_SEND_TIMEOUT) {
    5320:	e0 91 03 07 	lds	r30, 0x0703
    5324:	f0 91 04 07 	lds	r31, 0x0704
    5328:	92 81       	ldd	r25, Z+2	; 0x02
    532a:	99 23       	and	r25, r25
    532c:	39 f0       	breq	.+14     	; 0x533c <USBSend+0x44>
    532e:	20 91 00 07 	lds	r18, 0x0700
    5332:	30 91 01 07 	lds	r19, 0x0701
    5336:	24 36       	cpi	r18, 0x64	; 100
    5338:	31 05       	cpc	r19, r1
    533a:	38 f3       	brcs	.-50     	; 0x530a <USBSend+0x12>
		if((Typewriter_Mode == USB_COMBO_MODE) || (Typewriter_Mode == USB_LIGHT_MODE)){ //interrupts do not handle keyboard stuff during this mode.
			HID_Device_USBTask(&Keyboard_HID_Interface);
		} //if buffer is full, wait.  If timeout expires, stop waiting.
	}
	
	if (code&FORCE_UPPER){ //in this program, we use the MSB of code to indicate that this key MUST be sent as upper case.
    533c:	cc 23       	and	r28, r28
    533e:	14 f4       	brge	.+4      	; 0x5344 <USBSend+0x4c>
		reg_clr(code,FORCE_UPPER); //clear the MSB,  
    5340:	cf 77       	andi	r28, 0x7F	; 127
		mod = UPPER; //and set the modifier to upper case.
    5342:	d2 e0       	ldi	r29, 0x02	; 2
	}
	
	if(code == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
    5344:	c4 37       	cpi	r28, 0x74	; 116
    5346:	11 f4       	brne	.+4      	; 0x534c <USBSend+0x54>
		code = KEY_ENTER;
		mod = HID_KEYBOARD_MODIFIER_LEFTCTRL;
    5348:	d1 e0       	ldi	r29, 0x01	; 1
		reg_clr(code,FORCE_UPPER); //clear the MSB,  
		mod = UPPER; //and set the modifier to upper case.
	}
	
	if(code == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
		code = KEY_ENTER;
    534a:	c8 e2       	ldi	r28, 0x28	; 40
		mod = HID_KEYBOARD_MODIFIER_LEFTCTRL;
	}
	
	cli();//make sure there are no interrupts between setting code and setting the modifier that goes with it.
    534c:	f8 94       	cli
	KeyBuffer->KeyCode[0] = code; //cue up keycode to be sent during next LUFA HID callback function.
    534e:	e0 91 03 07 	lds	r30, 0x0703
    5352:	f0 91 04 07 	lds	r31, 0x0704
    5356:	c2 83       	std	Z+2, r28	; 0x02
	KeyBufferMod = mod;
    5358:	d0 93 bb 06 	sts	0x06BB, r29
	HID_Device_USBTask(&Keyboard_HID_Interface); //Dean Camera says to call this function regularly -- right after sending a character seems like an appropriate time.
    535c:	80 e2       	ldi	r24, 0x20	; 32
    535e:	91 e0       	ldi	r25, 0x01	; 1
    5360:	16 d6       	rcall	.+3116   	; 0x5f8e <HID_Device_USBTask>
	sei();//re-enable the interrupts.
    5362:	78 94       	sei
    5364:	8f e2       	ldi	r24, 0x2F	; 47
    5366:	95 e7       	ldi	r25, 0x75	; 117
    5368:	01 97       	sbiw	r24, 0x01	; 1
    536a:	f1 f7       	brne	.-4      	; 0x5368 <USBSend+0x70>
    536c:	00 c0       	rjmp	.+0      	; 0x536e <USBSend+0x76>
    536e:	00 00       	nop
	
	Delay_MS(USB_SEND_DELAY);// wait X ms after sending each character.
	
	cli();//make sure no interrupts occur during the usb task.
    5370:	f8 94       	cli
	HID_Device_USBTask(&Keyboard_HID_Interface); //do LUFA hid usb tasks
    5372:	80 e2       	ldi	r24, 0x20	; 32
    5374:	91 e0       	ldi	r25, 0x01	; 1
    5376:	0b d6       	rcall	.+3094   	; 0x5f8e <HID_Device_USBTask>
	sei();
    5378:	78 94       	sei
}
    537a:	df 91       	pop	r29
    537c:	cf 91       	pop	r28
    537e:	08 95       	ret

00005380 <USBSendString>:

/*Send a string over USB. Only supports some characters.*/
void USBSendString(char *str){
    5380:	df 92       	push	r13
    5382:	ef 92       	push	r14
    5384:	ff 92       	push	r15
    5386:	0f 93       	push	r16
    5388:	1f 93       	push	r17
    538a:	cf 93       	push	r28
    538c:	df 93       	push	r29
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
    538e:	fc 01       	movw	r30, r24
    5390:	01 90       	ld	r0, Z+
    5392:	00 20       	and	r0, r0
    5394:	e9 f7       	brne	.-6      	; 0x5390 <USBSendString+0x10>
    5396:	31 97       	sbiw	r30, 0x01	; 1
    5398:	e8 1b       	sub	r30, r24
    539a:	f9 0b       	sbc	r31, r25
	for (int i=0; i<length; i++){
    539c:	1e 16       	cp	r1, r30
    539e:	1f 06       	cpc	r1, r31
    53a0:	0c f0       	brlt	.+2      	; 0x53a4 <USBSendString+0x24>
    53a2:	65 c0       	rjmp	.+202    	; 0x546e <USBSendString+0xee>
    53a4:	ec 01       	movw	r28, r24
    53a6:	8c 01       	movw	r16, r24
    53a8:	0e 0f       	add	r16, r30
    53aa:	1f 1f       	adc	r17, r31
		modifier = LOWER;
    53ac:	f1 2c       	mov	r15, r1
		if(str[i] == ' '){
			code = KEY_SPACE;
		}
		else if(str[i] == '('){
			code = KEY_9;
			modifier = UPPER;
    53ae:	68 94       	set
    53b0:	ee 24       	eor	r14, r14
    53b2:	e1 f8       	bld	r14, 1
		else if(str[i] == '='){
			code = KEY_EQ;
			modifier = LOWER;
		}
		else if(str[i] == '!'){
			code = KEY_1;
    53b4:	0f 2e       	mov	r0, r31
    53b6:	fe e1       	ldi	r31, 0x1E	; 30
    53b8:	df 2e       	mov	r13, r31
    53ba:	f0 2d       	mov	r31, r0
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
		if(str[i] == ' '){
    53bc:	99 91       	ld	r25, Y+
    53be:	90 32       	cpi	r25, 0x20	; 32
    53c0:	29 f1       	breq	.+74     	; 0x540c <USBSendString+0x8c>
			code = KEY_SPACE;
		}
		else if(str[i] == '('){
    53c2:	98 32       	cpi	r25, 0x28	; 40
    53c4:	31 f1       	breq	.+76     	; 0x5412 <USBSendString+0x92>
			code = KEY_9;
			modifier = UPPER;
		}
		else if(str[i] == ')'){
    53c6:	99 32       	cpi	r25, 0x29	; 41
    53c8:	39 f1       	breq	.+78     	; 0x5418 <USBSendString+0x98>
			code = KEY_0;
			modifier = UPPER;
		}
		else if(str[i] == '/'){
    53ca:	9f 32       	cpi	r25, 0x2F	; 47
    53cc:	41 f1       	breq	.+80     	; 0x541e <USBSendString+0x9e>
			code = KEY_SLASH;
		}
		else if(str[i] == '?'){
    53ce:	9f 33       	cpi	r25, 0x3F	; 63
    53d0:	49 f1       	breq	.+82     	; 0x5424 <USBSendString+0xa4>
			code = KEY_SLASH;
			modifier = UPPER;
		}
		else if(str[i] == ':'){
    53d2:	9a 33       	cpi	r25, 0x3A	; 58
    53d4:	51 f1       	breq	.+84     	; 0x542a <USBSendString+0xaa>
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
    53d6:	9d 30       	cpi	r25, 0x0D	; 13
    53d8:	59 f1       	breq	.+86     	; 0x5430 <USBSendString+0xb0>
    53da:	9a 30       	cpi	r25, 0x0A	; 10
    53dc:	61 f1       	breq	.+88     	; 0x5436 <USBSendString+0xb6>
			code = KEY_ENTER;
		}
		else if(str[i] == '.'){
    53de:	9e 32       	cpi	r25, 0x2E	; 46
    53e0:	69 f1       	breq	.+90     	; 0x543c <USBSendString+0xbc>
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if(str[i] == '='){
    53e2:	9d 33       	cpi	r25, 0x3D	; 61
    53e4:	71 f1       	breq	.+92     	; 0x5442 <USBSendString+0xc2>
			code = KEY_EQ;
			modifier = LOWER;
		}
		else if(str[i] == '!'){
    53e6:	91 32       	cpi	r25, 0x21	; 33
    53e8:	79 f1       	breq	.+94     	; 0x5448 <USBSendString+0xc8>
			code = KEY_1;
			modifier = UPPER;
		}
		else if(str[i] == '0'){
    53ea:	90 33       	cpi	r25, 0x30	; 48
    53ec:	81 f1       	breq	.+96     	; 0x544e <USBSendString+0xce>
			code = KEY_0;
		}
		else if((str[i] >= ASCII_1 )&&(str[i] <= ASCII_9)){
    53ee:	8f ec       	ldi	r24, 0xCF	; 207
    53f0:	89 0f       	add	r24, r25
    53f2:	89 30       	cpi	r24, 0x09	; 9
    53f4:	20 f4       	brcc	.+8      	; 0x53fe <USBSendString+0x7e>
			code = str[i] - ASCII_1 + KEY_1; //translate ascii to hid number code 
    53f6:	8d ee       	ldi	r24, 0xED	; 237
    53f8:	89 0f       	add	r24, r25
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    53fa:	6f 2d       	mov	r22, r15
    53fc:	2a c0       	rjmp	.+84     	; 0x5452 <USBSendString+0xd2>
		}
		else if((str[i] >= ASCII_1 )&&(str[i] <= ASCII_9)){
			code = str[i] - ASCII_1 + KEY_1; //translate ascii to hid number code 
		}
		else{
			code = toupper(str[i]);//make sure code is uppercase.
    53fe:	89 2f       	mov	r24, r25
    5400:	90 e0       	ldi	r25, 0x00	; 0
    5402:	0e 94 c0 39 	call	0x7380	; 0x7380 <toupper>
			code = code-ASCII_A+KEY_A;  //Convert the character (which is uppercase Ascii)  to an USB HID Keycode.
    5406:	8d 53       	subi	r24, 0x3D	; 61
			modifier = UPPER;
    5408:	6e 2d       	mov	r22, r14
    540a:	23 c0       	rjmp	.+70     	; 0x5452 <USBSendString+0xd2>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    540c:	6f 2d       	mov	r22, r15
		if(str[i] == ' '){
			code = KEY_SPACE;
    540e:	8c e2       	ldi	r24, 0x2C	; 44
    5410:	20 c0       	rjmp	.+64     	; 0x5452 <USBSendString+0xd2>
		}
		else if(str[i] == '('){
			code = KEY_9;
			modifier = UPPER;
    5412:	6e 2d       	mov	r22, r14
		modifier = LOWER;
		if(str[i] == ' '){
			code = KEY_SPACE;
		}
		else if(str[i] == '('){
			code = KEY_9;
    5414:	86 e2       	ldi	r24, 0x26	; 38
    5416:	1d c0       	rjmp	.+58     	; 0x5452 <USBSendString+0xd2>
			modifier = UPPER;
		}
		else if(str[i] == ')'){
			code = KEY_0;
			modifier = UPPER;
    5418:	6e 2d       	mov	r22, r14
		else if(str[i] == '('){
			code = KEY_9;
			modifier = UPPER;
		}
		else if(str[i] == ')'){
			code = KEY_0;
    541a:	87 e2       	ldi	r24, 0x27	; 39
    541c:	1a c0       	rjmp	.+52     	; 0x5452 <USBSendString+0xd2>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    541e:	6f 2d       	mov	r22, r15
		else if(str[i] == ')'){
			code = KEY_0;
			modifier = UPPER;
		}
		else if(str[i] == '/'){
			code = KEY_SLASH;
    5420:	88 e3       	ldi	r24, 0x38	; 56
    5422:	17 c0       	rjmp	.+46     	; 0x5452 <USBSendString+0xd2>
		}
		else if(str[i] == '?'){
			code = KEY_SLASH;
			modifier = UPPER;
    5424:	6e 2d       	mov	r22, r14
		}
		else if(str[i] == '/'){
			code = KEY_SLASH;
		}
		else if(str[i] == '?'){
			code = KEY_SLASH;
    5426:	88 e3       	ldi	r24, 0x38	; 56
    5428:	14 c0       	rjmp	.+40     	; 0x5452 <USBSendString+0xd2>
			modifier = UPPER;
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
    542a:	6e 2d       	mov	r22, r14
		else if(str[i] == '?'){
			code = KEY_SLASH;
			modifier = UPPER;
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
    542c:	83 e3       	ldi	r24, 0x33	; 51
    542e:	11 c0       	rjmp	.+34     	; 0x5452 <USBSendString+0xd2>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5430:	6f 2d       	mov	r22, r15
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
			code = KEY_ENTER;
    5432:	88 e2       	ldi	r24, 0x28	; 40
    5434:	0e c0       	rjmp	.+28     	; 0x5452 <USBSendString+0xd2>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5436:	6f 2d       	mov	r22, r15
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
			code = KEY_ENTER;
    5438:	88 e2       	ldi	r24, 0x28	; 40
    543a:	0b c0       	rjmp	.+22     	; 0x5452 <USBSendString+0xd2>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    543c:	6f 2d       	mov	r22, r15
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
			code = KEY_ENTER;
		}
		else if(str[i] == '.'){
			code = KEY_PERIOD;
    543e:	87 e3       	ldi	r24, 0x37	; 55
    5440:	08 c0       	rjmp	.+16     	; 0x5452 <USBSendString+0xd2>
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if(str[i] == '='){
			code = KEY_EQ;
			modifier = LOWER;
    5442:	6f 2d       	mov	r22, r15
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if(str[i] == '='){
			code = KEY_EQ;
    5444:	8e e2       	ldi	r24, 0x2E	; 46
    5446:	05 c0       	rjmp	.+10     	; 0x5452 <USBSendString+0xd2>
			modifier = LOWER;
		}
		else if(str[i] == '!'){
			code = KEY_1;
			modifier = UPPER;
    5448:	6e 2d       	mov	r22, r14
		else if(str[i] == '='){
			code = KEY_EQ;
			modifier = LOWER;
		}
		else if(str[i] == '!'){
			code = KEY_1;
    544a:	8d 2d       	mov	r24, r13
    544c:	02 c0       	rjmp	.+4      	; 0x5452 <USBSendString+0xd2>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    544e:	6f 2d       	mov	r22, r15
		else if(str[i] == '!'){
			code = KEY_1;
			modifier = UPPER;
		}
		else if(str[i] == '0'){
			code = KEY_0;
    5450:	87 e2       	ldi	r24, 0x27	; 39
		else{
			code = toupper(str[i]);//make sure code is uppercase.
			code = code-ASCII_A+KEY_A;  //Convert the character (which is uppercase Ascii)  to an USB HID Keycode.
			modifier = UPPER;
		}
		USBSend(code,modifier);
    5452:	52 df       	rcall	.-348    	; 0x52f8 <USBSend>
    5454:	2f e7       	ldi	r18, 0x7F	; 127
    5456:	88 e3       	ldi	r24, 0x38	; 56
    5458:	91 e0       	ldi	r25, 0x01	; 1
    545a:	21 50       	subi	r18, 0x01	; 1
    545c:	80 40       	sbci	r24, 0x00	; 0
    545e:	90 40       	sbci	r25, 0x00	; 0
    5460:	e1 f7       	brne	.-8      	; 0x545a <USBSendString+0xda>
    5462:	00 c0       	rjmp	.+0      	; 0x5464 <USBSendString+0xe4>
    5464:	00 00       	nop
void USBSendString(char *str){
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
    5466:	c0 17       	cp	r28, r16
    5468:	d1 07       	cpc	r29, r17
    546a:	09 f0       	breq	.+2      	; 0x546e <USBSendString+0xee>
    546c:	a7 cf       	rjmp	.-178    	; 0x53bc <USBSendString+0x3c>
			modifier = UPPER;
		}
		USBSend(code,modifier);
		Delay_MS(STRING_SEND_DELAY);
	}
} 
    546e:	df 91       	pop	r29
    5470:	cf 91       	pop	r28
    5472:	1f 91       	pop	r17
    5474:	0f 91       	pop	r16
    5476:	ff 90       	pop	r15
    5478:	ef 90       	pop	r14
    547a:	df 90       	pop	r13
    547c:	08 95       	ret

0000547e <USBSendPROGString>:

/*Send a string literal over USB, using a string stored in program memory instead of data memory (this saves on data RAM)*/
void USBSendPROGString(const char*  ProgStr){
	strcpy_P(StringBuffer, (char*) ProgStr);
    547e:	bc 01       	movw	r22, r24
    5480:	8a e8       	ldi	r24, 0x8A	; 138
    5482:	97 e0       	ldi	r25, 0x07	; 7
    5484:	0e 94 c8 39 	call	0x7390	; 0x7390 <strcpy_P>
	USBSendString(StringBuffer);
    5488:	8a e8       	ldi	r24, 0x8A	; 138
    548a:	97 e0       	ldi	r25, 0x07	; 7
    548c:	79 cf       	rjmp	.-270    	; 0x5380 <USBSendString>
    548e:	08 95       	ret

00005490 <USBSendNumber>:
}

/*Send a number between 0 and 255 over usb)*/
void USBSendNumber(uint8_t number){
    5490:	1f 93       	push	r17
    5492:	cf 93       	push	r28
    5494:	df 93       	push	r29
    5496:	28 2f       	mov	r18, r24
	uint8_t ones ;
	uint8_t tens;
	
	ones = number%10;
    5498:	cd ec       	ldi	r28, 0xCD	; 205
    549a:	8c 9f       	mul	r24, r28
    549c:	c1 2d       	mov	r28, r1
    549e:	11 24       	eor	r1, r1
    54a0:	c6 95       	lsr	r28
    54a2:	c6 95       	lsr	r28
    54a4:	c6 95       	lsr	r28
    54a6:	cc 0f       	add	r28, r28
    54a8:	8c 2f       	mov	r24, r28
    54aa:	88 0f       	add	r24, r24
    54ac:	88 0f       	add	r24, r24
    54ae:	c8 0f       	add	r28, r24
    54b0:	82 2f       	mov	r24, r18
    54b2:	8c 1b       	sub	r24, r28
    54b4:	c8 2f       	mov	r28, r24
	tens = ((number - ones)%100)/10;
    54b6:	82 2f       	mov	r24, r18
    54b8:	90 e0       	ldi	r25, 0x00	; 0
    54ba:	8c 1b       	sub	r24, r28
    54bc:	91 09       	sbc	r25, r1
    54be:	64 e6       	ldi	r22, 0x64	; 100
    54c0:	70 e0       	ldi	r23, 0x00	; 0
    54c2:	0e 94 fa 38 	call	0x71f4	; 0x71f4 <__divmodhi4>
    54c6:	6a e0       	ldi	r22, 0x0A	; 10
    54c8:	70 e0       	ldi	r23, 0x00	; 0
    54ca:	0e 94 fa 38 	call	0x71f4	; 0x71f4 <__divmodhi4>
    54ce:	d6 2f       	mov	r29, r22
    54d0:	16 2f       	mov	r17, r22
	
	if (number >= 200){
    54d2:	28 3c       	cpi	r18, 0xC8	; 200
    54d4:	20 f0       	brcs	.+8      	; 0x54de <USBSendNumber+0x4e>
		USBSend(KEY_2,LOWER);
    54d6:	60 e0       	ldi	r22, 0x00	; 0
    54d8:	8f e1       	ldi	r24, 0x1F	; 31
    54da:	0e df       	rcall	.-484    	; 0x52f8 <USBSend>
    54dc:	05 c0       	rjmp	.+10     	; 0x54e8 <USBSendNumber+0x58>
	}
	else if (number >= 100){
    54de:	24 36       	cpi	r18, 0x64	; 100
    54e0:	18 f0       	brcs	.+6      	; 0x54e8 <USBSendNumber+0x58>
		USBSend(KEY_1,LOWER);
    54e2:	60 e0       	ldi	r22, 0x00	; 0
    54e4:	8e e1       	ldi	r24, 0x1E	; 30
    54e6:	08 df       	rcall	.-496    	; 0x52f8 <USBSend>
	}
	
	if (tens != 0){
    54e8:	11 23       	and	r17, r17
    54ea:	29 f0       	breq	.+10     	; 0x54f6 <USBSendNumber+0x66>
		USBSend(29+tens,LOWER);
    54ec:	60 e0       	ldi	r22, 0x00	; 0
    54ee:	8d e1       	ldi	r24, 0x1D	; 29
    54f0:	8d 0f       	add	r24, r29
    54f2:	02 df       	rcall	.-508    	; 0x52f8 <USBSend>
    54f4:	03 c0       	rjmp	.+6      	; 0x54fc <USBSendNumber+0x6c>
	}
	else{
		USBSend(39,LOWER);
    54f6:	60 e0       	ldi	r22, 0x00	; 0
    54f8:	87 e2       	ldi	r24, 0x27	; 39
    54fa:	fe de       	rcall	.-516    	; 0x52f8 <USBSend>
    54fc:	9f ef       	ldi	r25, 0xFF	; 255
    54fe:	20 e7       	ldi	r18, 0x70	; 112
    5500:	82 e0       	ldi	r24, 0x02	; 2
    5502:	91 50       	subi	r25, 0x01	; 1
    5504:	20 40       	sbci	r18, 0x00	; 0
    5506:	80 40       	sbci	r24, 0x00	; 0
    5508:	e1 f7       	brne	.-8      	; 0x5502 <USBSendNumber+0x72>
    550a:	00 c0       	rjmp	.+0      	; 0x550c <USBSendNumber+0x7c>
    550c:	00 00       	nop
	}

	Delay_MS(100);
	
	if (ones!=0){
    550e:	cc 23       	and	r28, r28
    5510:	29 f0       	breq	.+10     	; 0x551c <USBSendNumber+0x8c>
		USBSend(29+ones,LOWER);
    5512:	60 e0       	ldi	r22, 0x00	; 0
    5514:	8d e1       	ldi	r24, 0x1D	; 29
    5516:	8c 0f       	add	r24, r28
    5518:	ef de       	rcall	.-546    	; 0x52f8 <USBSend>
    551a:	03 c0       	rjmp	.+6      	; 0x5522 <USBSendNumber+0x92>
	}
	else{
		USBSend(39,LOWER);
    551c:	60 e0       	ldi	r22, 0x00	; 0
    551e:	87 e2       	ldi	r24, 0x27	; 39
    5520:	eb de       	rcall	.-554    	; 0x52f8 <USBSend>
    5522:	9f ef       	ldi	r25, 0xFF	; 255
    5524:	20 e7       	ldi	r18, 0x70	; 112
    5526:	82 e0       	ldi	r24, 0x02	; 2
    5528:	91 50       	subi	r25, 0x01	; 1
    552a:	20 40       	sbci	r18, 0x00	; 0
    552c:	80 40       	sbci	r24, 0x00	; 0
    552e:	e1 f7       	brne	.-8      	; 0x5528 <USBSendNumber+0x98>
    5530:	00 c0       	rjmp	.+0      	; 0x5532 <USBSendNumber+0xa2>
    5532:	00 00       	nop
	}
	
	Delay_MS(100);

}
    5534:	df 91       	pop	r29
    5536:	cf 91       	pop	r28
    5538:	1f 91       	pop	r17
    553a:	08 95       	ret

0000553c <GetModifier>:

uint8_t GetModifier(){
	uint8_t Modifier = 0;
	bool ShiftIsPressed = false;
	
	switch (Shift_Reed){
    553c:	80 91 ff 06 	lds	r24, 0x06FF
    5540:	82 30       	cpi	r24, 0x02	; 2
    5542:	99 f0       	breq	.+38     	; 0x556a <GetModifier+0x2e>
    5544:	18 f4       	brcc	.+6      	; 0x554c <GetModifier+0x10>
    5546:	81 30       	cpi	r24, 0x01	; 1
    5548:	31 f0       	breq	.+12     	; 0x5556 <GetModifier+0x1a>
    554a:	2f c0       	rjmp	.+94     	; 0x55aa <GetModifier+0x6e>
    554c:	83 30       	cpi	r24, 0x03	; 3
    554e:	c1 f0       	breq	.+48     	; 0x5580 <GetModifier+0x44>
    5550:	84 30       	cpi	r24, 0x04	; 4
    5552:	09 f1       	breq	.+66     	; 0x5596 <GetModifier+0x5a>
    5554:	2a c0       	rjmp	.+84     	; 0x55aa <GetModifier+0x6e>
	case 0: ShiftIsPressed = false; break;// if shift reed is 0, no shift key has been programed;
	case 1: ShiftIsPressed = (is_high(REED_1) == Reed1Polarity); break; //test if reed_1 is at the active level (high/low) indicated by reed1polarity
    5556:	99 b1       	in	r25, 0x09	; 9
    5558:	92 95       	swap	r25
    555a:	91 70       	andi	r25, 0x01	; 1
    555c:	81 e0       	ldi	r24, 0x01	; 1
    555e:	20 91 06 07 	lds	r18, 0x0706
    5562:	92 17       	cp	r25, r18
    5564:	19 f1       	breq	.+70     	; 0x55ac <GetModifier+0x70>
    5566:	80 e0       	ldi	r24, 0x00	; 0
    5568:	21 c0       	rjmp	.+66     	; 0x55ac <GetModifier+0x70>
	case 2: ShiftIsPressed = (is_high(REED_2) == Reed2Polarity); break;
    556a:	99 b1       	in	r25, 0x09	; 9
    556c:	96 fb       	bst	r25, 6
    556e:	99 27       	eor	r25, r25
    5570:	90 f9       	bld	r25, 0
    5572:	81 e0       	ldi	r24, 0x01	; 1
    5574:	20 91 b6 06 	lds	r18, 0x06B6
    5578:	92 17       	cp	r25, r18
    557a:	c1 f0       	breq	.+48     	; 0x55ac <GetModifier+0x70>
    557c:	80 e0       	ldi	r24, 0x00	; 0
    557e:	16 c0       	rjmp	.+44     	; 0x55ac <GetModifier+0x70>
	case 3: ShiftIsPressed = (is_high(REED_3) == Reed3Polarity); break;
    5580:	99 b1       	in	r25, 0x09	; 9
    5582:	99 1f       	adc	r25, r25
    5584:	99 27       	eor	r25, r25
    5586:	99 1f       	adc	r25, r25
    5588:	81 e0       	ldi	r24, 0x01	; 1
    558a:	20 91 88 07 	lds	r18, 0x0788
    558e:	92 17       	cp	r25, r18
    5590:	69 f0       	breq	.+26     	; 0x55ac <GetModifier+0x70>
    5592:	80 e0       	ldi	r24, 0x00	; 0
    5594:	0b c0       	rjmp	.+22     	; 0x55ac <GetModifier+0x70>
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
    5596:	93 b1       	in	r25, 0x03	; 3
    5598:	92 95       	swap	r25
    559a:	91 70       	andi	r25, 0x01	; 1
    559c:	81 e0       	ldi	r24, 0x01	; 1
    559e:	20 91 c6 07 	lds	r18, 0x07C6
    55a2:	92 17       	cp	r25, r18
    55a4:	19 f0       	breq	.+6      	; 0x55ac <GetModifier+0x70>
    55a6:	80 e0       	ldi	r24, 0x00	; 0
    55a8:	01 c0       	rjmp	.+2      	; 0x55ac <GetModifier+0x70>
uint8_t GetModifier(){
	uint8_t Modifier = 0;
	bool ShiftIsPressed = false;
	
	switch (Shift_Reed){
	case 0: ShiftIsPressed = false; break;// if shift reed is 0, no shift key has been programed;
    55aa:	80 e0       	ldi	r24, 0x00	; 0
	case 3: ShiftIsPressed = (is_high(REED_3) == Reed3Polarity); break;
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
	default: ShiftIsPressed = false;
	}
	
	if(ShiftIsPressed) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTSHIFT;}
    55ac:	88 23       	and	r24, r24
    55ae:	11 f0       	breq	.+4      	; 0x55b4 <GetModifier+0x78>
    55b0:	82 e0       	ldi	r24, 0x02	; 2
    55b2:	01 c0       	rjmp	.+2      	; 0x55b6 <GetModifier+0x7a>

const uint8_t REED_BITS[] = {62,61,60,59}; //these are the bits of the sensor array that represent the reed switches


uint8_t GetModifier(){
	uint8_t Modifier = 0;
    55b4:	80 e0       	ldi	r24, 0x00	; 0
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
	default: ShiftIsPressed = false;
	}
	
	if(ShiftIsPressed) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTSHIFT;}
	if(is_low(CTRL_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTCTRL;}
    55b6:	7c 9b       	sbis	0x0f, 4	; 15
    55b8:	81 60       	ori	r24, 0x01	; 1
	if(is_low(ALT_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTALT;}
    55ba:	7d 9b       	sbis	0x0f, 5	; 15
    55bc:	84 60       	ori	r24, 0x04	; 4
	if(is_low(CMD_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTGUI;}
    55be:	7e 9b       	sbis	0x0f, 6	; 15
    55c0:	88 60       	ori	r24, 0x08	; 8
	
	return Modifier;
}
    55c2:	08 95       	ret

000055c4 <ReadSensor>:
			return 0; //if no keys or reeds need sending, return 0
		}

}

unsigned long long ReadSensor(){
    55c4:	4f 92       	push	r4
    55c6:	5f 92       	push	r5
    55c8:	6f 92       	push	r6
    55ca:	7f 92       	push	r7
    55cc:	8f 92       	push	r8
    55ce:	9f 92       	push	r9
    55d0:	af 92       	push	r10
    55d2:	bf 92       	push	r11
    55d4:	df 92       	push	r13
    55d6:	ef 92       	push	r14
    55d8:	ff 92       	push	r15
    55da:	0f 93       	push	r16
    55dc:	1f 93       	push	r17
    55de:	cf 93       	push	r28
    55e0:	df 93       	push	r29
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    55e2:	f8 94       	cli
		unsigned long long Readout = 0;	
		bool HallReading;
		
		GlobalInterruptDisable();
		set_high(SENSE_CLK);
    55e4:	72 9a       	sbi	0x0e, 2	; 14
    55e6:	8f ec       	ldi	r24, 0xCF	; 207
    55e8:	97 e0       	ldi	r25, 0x07	; 7
    55ea:	01 97       	sbiw	r24, 0x01	; 1
    55ec:	f1 f7       	brne	.-4      	; 0x55ea <ReadSensor+0x26>
    55ee:	00 c0       	rjmp	.+0      	; 0x55f0 <ReadSensor+0x2c>
    55f0:	00 00       	nop
		Delay_MS(1); //Sensor board has an LP filter and an inverter on the _LOAD signal.  Wait X ms for the low-pass filter on the _LOAD signal to fire low. 
		set_low(SENSE_CLK);
    55f2:	72 98       	cbi	0x0e, 2	; 14
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    55f4:	78 94       	sei
    55f6:	8f ec       	ldi	r24, 0xCF	; 207
    55f8:	97 e0       	ldi	r25, 0x07	; 7
    55fa:	01 97       	sbiw	r24, 0x01	; 1
    55fc:	f1 f7       	brne	.-4      	; 0x55fa <ReadSensor+0x36>
    55fe:	00 c0       	rjmp	.+0      	; 0x5600 <ReadSensor+0x3c>
    5600:	00 00       	nop
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
    5602:	e0 e0       	ldi	r30, 0x00	; 0
    5604:	f0 e0       	ldi	r31, 0x00	; 0
		}

}

unsigned long long ReadSensor(){
		unsigned long long Readout = 0;	
    5606:	d1 2c       	mov	r13, r1
    5608:	e1 2c       	mov	r14, r1
    560a:	f1 2c       	mov	r15, r1
    560c:	10 e0       	ldi	r17, 0x00	; 0
    560e:	d0 e0       	ldi	r29, 0x00	; 0
    5610:	c0 e0       	ldi	r28, 0x00	; 0
    5612:	b0 e0       	ldi	r27, 0x00	; 0
    5614:	a0 e0       	ldi	r26, 0x00	; 0
		set_low(SENSE_CLK);
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
			if (is_low(SENSE_SER)) { 
    5616:	1d 99       	sbic	0x03, 5	; 3
    5618:	13 c0       	rjmp	.+38     	; 0x5640 <ReadSensor+0x7c>
				longlongbit_set(Readout,i);// if the readout for one of the sensor pins comes back low, that key has been pressed -- store it as a 1 in the readout.
    561a:	21 e0       	ldi	r18, 0x01	; 1
    561c:	30 e0       	ldi	r19, 0x00	; 0
    561e:	40 e0       	ldi	r20, 0x00	; 0
    5620:	50 e0       	ldi	r21, 0x00	; 0
    5622:	60 e0       	ldi	r22, 0x00	; 0
    5624:	70 e0       	ldi	r23, 0x00	; 0
    5626:	80 e0       	ldi	r24, 0x00	; 0
    5628:	90 e0       	ldi	r25, 0x00	; 0
    562a:	0e 2f       	mov	r16, r30
    562c:	0e 94 41 39 	call	0x7282	; 0x7282 <__ashldi3>
    5630:	d2 2a       	or	r13, r18
    5632:	e3 2a       	or	r14, r19
    5634:	f4 2a       	or	r15, r20
    5636:	15 2b       	or	r17, r21
    5638:	d6 2b       	or	r29, r22
    563a:	c7 2b       	or	r28, r23
    563c:	b8 2b       	or	r27, r24
    563e:	a9 2b       	or	r26, r25
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    5640:	f8 94       	cli
			}	
			
			GlobalInterruptDisable();//if sense clk stays high too long, it could falsely trigger _Load signal.
			set_high(SENSE_CLK);
    5642:	72 9a       	sbi	0x0e, 2	; 14
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5644:	9a e1       	ldi	r25, 0x1A	; 26
    5646:	9a 95       	dec	r25
    5648:	f1 f7       	brne	.-4      	; 0x5646 <ReadSensor+0x82>
    564a:	00 c0       	rjmp	.+0      	; 0x564c <ReadSensor+0x88>
			_delay_us(CLK_POS_PULSE); //delay for the required pulsewidth
			set_low(SENSE_CLK);
    564c:	72 98       	cbi	0x0e, 2	; 14
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    564e:	78 94       	sei
    5650:	8a e6       	ldi	r24, 0x6A	; 106
    5652:	8a 95       	dec	r24
    5654:	f1 f7       	brne	.-4      	; 0x5652 <ReadSensor+0x8e>
    5656:	00 c0       	rjmp	.+0      	; 0x5658 <ReadSensor+0x94>
		Delay_MS(1); //Sensor board has an LP filter and an inverter on the _LOAD signal.  Wait X ms for the low-pass filter on the _LOAD signal to fire low. 
		set_low(SENSE_CLK);
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
    5658:	31 96       	adiw	r30, 0x01	; 1
    565a:	e0 33       	cpi	r30, 0x30	; 48
    565c:	f1 05       	cpc	r31, r1
    565e:	d9 f6       	brne	.-74     	; 0x5616 <ReadSensor+0x52>

		}
		
		/*The hall effect sensor on the end of the sensor board is only installed in certain cases -
		- its job is to tell if the entire crossbar has moved(active), or if it is at rest (therefore no keys should be detected)*/
		if(UseHallSensor == HALL_ACTIVE){ //when the hall effect sensor is installed and activated
    5660:	80 91 89 07 	lds	r24, 0x0789
    5664:	82 30       	cpi	r24, 0x02	; 2
    5666:	f1 f4       	brne	.+60     	; 0x56a4 <ReadSensor+0xe0>
			HallReading = Readout & LONGLONGBIT(HALL_SENSOR_BIT); //one of the bits of the sensor readout gives the state of the hall sensor
    5668:	2d 2d       	mov	r18, r13
    566a:	3e 2d       	mov	r19, r14
    566c:	4f 2d       	mov	r20, r15
    566e:	51 2f       	mov	r21, r17
    5670:	6d 2f       	mov	r22, r29
    5672:	7c 2f       	mov	r23, r28
    5674:	8b 2f       	mov	r24, r27
    5676:	9a 2f       	mov	r25, r26
    5678:	0c e2       	ldi	r16, 0x2C	; 44
    567a:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__lshrdi3>
    567e:	42 2e       	mov	r4, r18
    5680:	53 2e       	mov	r5, r19
    5682:	c2 01       	movw	r24, r4
    5684:	81 70       	andi	r24, 0x01	; 1
    5686:	99 27       	eor	r25, r25
			if(HallReading != HallSensorPolarity){
    5688:	20 91 05 07 	lds	r18, 0x0705
    568c:	30 e0       	ldi	r19, 0x00	; 0
    568e:	82 17       	cp	r24, r18
    5690:	93 07       	cpc	r25, r19
    5692:	41 f0       	breq	.+16     	; 0x56a4 <ReadSensor+0xe0>
				Readout = 0; //then if the hall effect sensor is not triggered, readout of keys is invalid -- clear it (including the hall sensor bit). 
    5694:	d1 2c       	mov	r13, r1
    5696:	e1 2c       	mov	r14, r1
    5698:	f1 2c       	mov	r15, r1
    569a:	10 e0       	ldi	r17, 0x00	; 0
    569c:	d0 e0       	ldi	r29, 0x00	; 0
    569e:	c0 e0       	ldi	r28, 0x00	; 0
    56a0:	b0 e0       	ldi	r27, 0x00	; 0
    56a2:	a0 e0       	ldi	r26, 0x00	; 0
			}
		}

		//add the reed switches to the last 4 bits of the readout array -- if the reed switch is for the shift key, ignore it!
		if (Shift_Reed != 1 && is_high(REED_1)==(bool)Reed1Polarity){ Readout |= LONGLONGBIT(REED_BITS[0]);} //63rd bit of readout (or something like that) represents Reed1
    56a4:	80 91 ff 06 	lds	r24, 0x06FF
    56a8:	81 30       	cpi	r24, 0x01	; 1
    56aa:	49 f1       	breq	.+82     	; 0x56fe <ReadSensor+0x13a>
    56ac:	99 b1       	in	r25, 0x09	; 9
    56ae:	92 95       	swap	r25
    56b0:	91 70       	andi	r25, 0x01	; 1
    56b2:	20 91 06 07 	lds	r18, 0x0706
    56b6:	92 13       	cpse	r25, r18
    56b8:	01 c0       	rjmp	.+2      	; 0x56bc <ReadSensor+0xf8>
    56ba:	a0 64       	ori	r26, 0x40	; 64
		if (Shift_Reed != 2 && is_high(REED_2)==(bool)Reed2Polarity){ Readout |= LONGLONGBIT(REED_BITS[1]);} //62nd bit of readout (or something like that) represents Reed2
    56bc:	82 30       	cpi	r24, 0x02	; 2
    56be:	41 f1       	breq	.+80     	; 0x5710 <ReadSensor+0x14c>
    56c0:	99 b1       	in	r25, 0x09	; 9
    56c2:	96 fb       	bst	r25, 6
    56c4:	99 27       	eor	r25, r25
    56c6:	90 f9       	bld	r25, 0
    56c8:	20 91 b6 06 	lds	r18, 0x06B6
    56cc:	92 13       	cpse	r25, r18
    56ce:	01 c0       	rjmp	.+2      	; 0x56d2 <ReadSensor+0x10e>
    56d0:	a0 62       	ori	r26, 0x20	; 32
		if (Shift_Reed != 3 && is_high(REED_3)==(bool)Reed3Polarity){ Readout |= LONGLONGBIT(REED_BITS[2]);} //61st bit of readout (or something like that) represents Reed3
    56d2:	83 30       	cpi	r24, 0x03	; 3
    56d4:	59 f0       	breq	.+22     	; 0x56ec <ReadSensor+0x128>
    56d6:	99 b1       	in	r25, 0x09	; 9
    56d8:	99 1f       	adc	r25, r25
    56da:	99 27       	eor	r25, r25
    56dc:	99 1f       	adc	r25, r25
    56de:	20 91 88 07 	lds	r18, 0x0788
    56e2:	92 13       	cpse	r25, r18
    56e4:	01 c0       	rjmp	.+2      	; 0x56e8 <ReadSensor+0x124>
    56e6:	a0 61       	ori	r26, 0x10	; 16
		if (Shift_Reed != 4 && is_high(REED_4)==(bool)Reed4Polarity){ Readout |= LONGLONGBIT(REED_BITS[3]);} //60th bit of readout (or something like that) represents Reed4
    56e8:	84 30       	cpi	r24, 0x04	; 4
    56ea:	d9 f0       	breq	.+54     	; 0x5722 <ReadSensor+0x15e>
    56ec:	83 b1       	in	r24, 0x03	; 3
    56ee:	82 95       	swap	r24
    56f0:	81 70       	andi	r24, 0x01	; 1
    56f2:	90 91 c6 07 	lds	r25, 0x07C6
    56f6:	89 13       	cpse	r24, r25
    56f8:	14 c0       	rjmp	.+40     	; 0x5722 <ReadSensor+0x15e>
    56fa:	a8 60       	ori	r26, 0x08	; 8
    56fc:	12 c0       	rjmp	.+36     	; 0x5722 <ReadSensor+0x15e>
			}
		}

		//add the reed switches to the last 4 bits of the readout array -- if the reed switch is for the shift key, ignore it!
		if (Shift_Reed != 1 && is_high(REED_1)==(bool)Reed1Polarity){ Readout |= LONGLONGBIT(REED_BITS[0]);} //63rd bit of readout (or something like that) represents Reed1
		if (Shift_Reed != 2 && is_high(REED_2)==(bool)Reed2Polarity){ Readout |= LONGLONGBIT(REED_BITS[1]);} //62nd bit of readout (or something like that) represents Reed2
    56fe:	99 b1       	in	r25, 0x09	; 9
    5700:	96 fb       	bst	r25, 6
    5702:	99 27       	eor	r25, r25
    5704:	90 f9       	bld	r25, 0
    5706:	20 91 b6 06 	lds	r18, 0x06B6
    570a:	92 13       	cpse	r25, r18
    570c:	e4 cf       	rjmp	.-56     	; 0x56d6 <ReadSensor+0x112>
    570e:	e0 cf       	rjmp	.-64     	; 0x56d0 <ReadSensor+0x10c>
		if (Shift_Reed != 3 && is_high(REED_3)==(bool)Reed3Polarity){ Readout |= LONGLONGBIT(REED_BITS[2]);} //61st bit of readout (or something like that) represents Reed3
    5710:	99 b1       	in	r25, 0x09	; 9
    5712:	99 1f       	adc	r25, r25
    5714:	99 27       	eor	r25, r25
    5716:	99 1f       	adc	r25, r25
    5718:	20 91 88 07 	lds	r18, 0x0788
    571c:	92 13       	cpse	r25, r18
    571e:	e6 cf       	rjmp	.-52     	; 0x56ec <ReadSensor+0x128>
    5720:	e2 cf       	rjmp	.-60     	; 0x56e6 <ReadSensor+0x122>
		if (Shift_Reed != 4 && is_high(REED_4)==(bool)Reed4Polarity){ Readout |= LONGLONGBIT(REED_BITS[3]);} //60th bit of readout (or something like that) represents Reed4
		
		return Readout;
}
    5722:	2d 2d       	mov	r18, r13
    5724:	3e 2d       	mov	r19, r14
    5726:	4f 2d       	mov	r20, r15
    5728:	51 2f       	mov	r21, r17
    572a:	6d 2f       	mov	r22, r29
    572c:	7c 2f       	mov	r23, r28
    572e:	8b 2f       	mov	r24, r27
    5730:	9a 2f       	mov	r25, r26
    5732:	df 91       	pop	r29
    5734:	cf 91       	pop	r28
    5736:	1f 91       	pop	r17
    5738:	0f 91       	pop	r16
    573a:	ff 90       	pop	r15
    573c:	ef 90       	pop	r14
    573e:	df 90       	pop	r13
    5740:	bf 90       	pop	r11
    5742:	af 90       	pop	r10
    5744:	9f 90       	pop	r9
    5746:	8f 90       	pop	r8
    5748:	7f 90       	pop	r7
    574a:	6f 90       	pop	r6
    574c:	5f 90       	pop	r5
    574e:	4f 90       	pop	r4
    5750:	08 95       	ret

00005752 <GetKeySimple>:
	if(is_low(CMD_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTGUI;}
	
	return Modifier;
}

uint8_t GetKeySimple(){
    5752:	ff 92       	push	r15
    5754:	0f 93       	push	r16
    5756:	1f 93       	push	r17
    5758:	cf 93       	push	r28
    575a:	df 93       	push	r29
	unsigned long long SensorReadout; //create 64-bit "long long" binary variable and set it all to 0s.
	uint8_t Key;
	
	Key=0;//by default, there is no key to send, unless one is detected later.
	
	SensorReadout = ReadSensor();
    575c:	33 df       	rcall	.-410    	; 0x55c4 <ReadSensor>
    575e:	f2 2e       	mov	r15, r18
    5760:	03 2f       	mov	r16, r19
    5762:	14 2f       	mov	r17, r20
    5764:	d5 2f       	mov	r29, r21
    5766:	c6 2f       	mov	r28, r22
    5768:	e7 2f       	mov	r30, r23
    576a:	b8 2f       	mov	r27, r24
    576c:	f9 2f       	mov	r31, r25
	if(UseHallSensor != HALL_NOT_PRESENT){
    576e:	80 91 89 07 	lds	r24, 0x0789
    5772:	81 11       	cpse	r24, r1
		SensorReadout &= ~LONGLONGBIT(HALL_SENSOR_BIT); //discard the hall effect bit of the array -- it is not an actual key, so don't report it as one.
    5774:	ef 7e       	andi	r30, 0xEF	; 239
	}

	if(SensorReadout){
    5776:	2f 2d       	mov	r18, r15
    5778:	30 2f       	mov	r19, r16
    577a:	41 2f       	mov	r20, r17
    577c:	5d 2f       	mov	r21, r29
    577e:	6c 2f       	mov	r22, r28
    5780:	7e 2f       	mov	r23, r30
    5782:	8b 2f       	mov	r24, r27
    5784:	9f 2f       	mov	r25, r31
    5786:	a0 e0       	ldi	r26, 0x00	; 0
    5788:	0e 94 78 39 	call	0x72f0	; 0x72f0 <__cmpdi2_s8>
    578c:	19 f0       	breq	.+6      	; 0x5794 <GetKeySimple+0x42>
		Key = (uint8_t) __builtin_clzll(SensorReadout); //this function finds the first nonzero bit in the bitfield SensorReadout (by counting leading zeros)
    578e:	0e 94 39 39 	call	0x7272	; 0x7272 <__clzdi2>
    5792:	01 c0       	rjmp	.+2      	; 0x5796 <GetKeySimple+0x44>
	}
	else{
		Key = 0;
    5794:	80 e0       	ldi	r24, 0x00	; 0
	}
	return  Key;
	
}
    5796:	df 91       	pop	r29
    5798:	cf 91       	pop	r28
    579a:	1f 91       	pop	r17
    579c:	0f 91       	pop	r16
    579e:	ff 90       	pop	r15
    57a0:	08 95       	ret

000057a2 <GetKey>:
	
uint8_t GetKey(){
    57a2:	2f 92       	push	r2
    57a4:	3f 92       	push	r3
    57a6:	4f 92       	push	r4
    57a8:	5f 92       	push	r5
    57aa:	6f 92       	push	r6
    57ac:	7f 92       	push	r7
    57ae:	8f 92       	push	r8
    57b0:	9f 92       	push	r9
    57b2:	af 92       	push	r10
    57b4:	bf 92       	push	r11
    57b6:	cf 92       	push	r12
    57b8:	df 92       	push	r13
    57ba:	ef 92       	push	r14
    57bc:	ff 92       	push	r15
    57be:	0f 93       	push	r16
    57c0:	1f 93       	push	r17
    57c2:	cf 93       	push	r28
    57c4:	df 93       	push	r29
    57c6:	00 d0       	rcall	.+0      	; 0x57c8 <GetKey+0x26>
    57c8:	1f 92       	push	r1
    57ca:	cd b7       	in	r28, 0x3d	; 61
    57cc:	de b7       	in	r29, 0x3e	; 62
		bool OKtoSendReed = false; //go ahead to send a reed switch
		
		uint8_t ReedToSend = 0;
	
/*READ INPUT FROM SENSOR STRIP*/	
		SensorReadout = ReadSensor();
    57ce:	fa de       	rcall	.-524    	; 0x55c4 <ReadSensor>
    57d0:	82 2e       	mov	r8, r18
    57d2:	93 2e       	mov	r9, r19
    57d4:	a4 2e       	mov	r10, r20
    57d6:	b5 2e       	mov	r11, r21
    57d8:	16 2f       	mov	r17, r22
    57da:	68 2e       	mov	r6, r24
    57dc:	49 2e       	mov	r4, r25
		
		if (UseHallSensor != HALL_NOT_PRESENT){ //if the user has not installed the hall sensor, don't do this part.
    57de:	80 91 89 07 	lds	r24, 0x0789
    57e2:	81 11       	cpse	r24, r1
			SensorReadout &= ~LONGLONGBIT(HALL_SENSOR_BIT); //after detecting it, discard the hall effect bit of the array -- it is not an actual key, so don't report it as one.
    57e4:	7f 7e       	andi	r23, 0xEF	; 239
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
			int reednumber = i+1;
			int j;
			
			if (Reeds_Are_Independent) j = i; //
    57e6:	70 90 b8 06 	lds	r7, 0x06B8
			else j = 0; //setting j = 0 means "If any reed is active, all reeds are considered active also (and are therefore won't be sent when pressed)
			
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
				if (ReedDebounce[i] < ReedHoldTime){//increment the debounce entry if not already maxed out.
    57ea:	30 90 fd 06 	lds	r3, 0x06FD
    57ee:	81 e7       	ldi	r24, 0x71	; 113
    57f0:	96 e0       	ldi	r25, 0x06	; 6
    57f2:	0f 2e       	mov	r0, r31
    57f4:	fb ea       	ldi	r31, 0xAB	; 171
    57f6:	ef 2e       	mov	r14, r31
    57f8:	f3 e0       	ldi	r31, 0x03	; 3
    57fa:	ff 2e       	mov	r15, r31
    57fc:	f0 2d       	mov	r31, r0
    57fe:	e0 e0       	ldi	r30, 0x00	; 0
    5800:	f0 e0       	ldi	r31, 0x00	; 0
		static uint8_t ReedDebounce[4]; //array tracking the debounce times of all four reed switches.  
		
		bool OKtoSendKey = false; //non static bool that gives the go-ahead to send a key over the usb/bluetooth bus.  Indicates that the key has been pressed first time.
		bool OKtoSendReed = false; //go ahead to send a reed switch
		
		uint8_t ReedToSend = 0;
    5802:	21 2c       	mov	r2, r1
		static uint8_t KeyReleaseCounter;
		static bool ActiveReeds[4];//array showing all currently active reeds.
		static uint8_t ReedDebounce[4]; //array tracking the debounce times of all four reed switches.  
		
		bool OKtoSendKey = false; //non static bool that gives the go-ahead to send a key over the usb/bluetooth bus.  Indicates that the key has been pressed first time.
		bool OKtoSendReed = false; //go ahead to send a reed switch
    5804:	51 2c       	mov	r5, r1
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
				if (ReedDebounce[i] < ReedHoldTime){//increment the debounce entry if not already maxed out.
					ReedDebounce[i] ++;
				} 
				else if (!ActiveReeds[j]){ //if the debounce has reached KeyHoldTime, but the reed isn't already listed as active
						ActiveReeds[j] = true; //then list it as active.
    5806:	9b 83       	std	Y+3, r25	; 0x03
    5808:	8a 83       	std	Y+2, r24	; 0x02
    580a:	79 83       	std	Y+1, r23	; 0x01
/*READ AND DEBOUNCE REED SWITCH INPUTS*/

		/*Detect which reeds have been pressed, and if they have been sent to the host already or if they still need to be*/
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
			int reednumber = i+1;
    580c:	6f 01       	movw	r12, r30
			int j;
			
			if (Reeds_Are_Independent) j = i; //
    580e:	71 10       	cpse	r7, r1
    5810:	13 c1       	rjmp	.+550    	; 0x5a38 <GetKey+0x296>
    5812:	f8 c0       	rjmp	.+496    	; 0x5a04 <GetKey+0x262>
			else j = 0; //setting j = 0 means "If any reed is active, all reeds are considered active also (and are therefore won't be sent when pressed)
    5814:	c1 2c       	mov	r12, r1
    5816:	d1 2c       	mov	r13, r1
			
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
				if (ReedDebounce[i] < ReedHoldTime){//increment the debounce entry if not already maxed out.
    5818:	aa 81       	ldd	r26, Y+2	; 0x02
    581a:	bb 81       	ldd	r27, Y+3	; 0x03
    581c:	8c 91       	ld	r24, X
    581e:	83 15       	cp	r24, r3
    5820:	18 f4       	brcc	.+6      	; 0x5828 <GetKey+0x86>
					ReedDebounce[i] ++;
    5822:	8f 5f       	subi	r24, 0xFF	; 255
    5824:	8c 93       	st	X, r24
    5826:	3b c0       	rjmp	.+118    	; 0x589e <GetKey+0xfc>
				} 
				else if (!ActiveReeds[j]){ //if the debounce has reached KeyHoldTime, but the reed isn't already listed as active
    5828:	c6 01       	movw	r24, r12
    582a:	83 59       	subi	r24, 0x93	; 147
    582c:	99 4f       	sbci	r25, 0xF9	; 249
    582e:	dc 01       	movw	r26, r24
    5830:	8c 91       	ld	r24, X
    5832:	81 11       	cpse	r24, r1
    5834:	34 c0       	rjmp	.+104    	; 0x589e <GetKey+0xfc>
						ActiveReeds[j] = true; //then list it as active.
    5836:	21 e0       	ldi	r18, 0x01	; 1
    5838:	2c 93       	st	X, r18
    583a:	22 24       	eor	r2, r2
    583c:	23 94       	inc	r2
    583e:	2e 0e       	add	r2, r30
						ReedToSend = reednumber; //code 1,2,3, or 4 indicates which reed has been pressed
						OKtoSendReed = true;//and tell the routine to send it
    5840:	55 24       	eor	r5, r5
    5842:	53 94       	inc	r5
    5844:	2c c0       	rjmp	.+88     	; 0x589e <GetKey+0xfc>
				}
			} 
			else if (Reeds_Are_Independent){//if the reed is not detected, and we are tracking them separately.
				if(ReedDebounce[i] == 0) ActiveReeds[j] = false; //then if the debounce counter has run down, consider the reed to be released.
    5846:	aa 81       	ldd	r26, Y+2	; 0x02
    5848:	bb 81       	ldd	r27, Y+3	; 0x03
    584a:	8c 91       	ld	r24, X
    584c:	81 11       	cpse	r24, r1
    584e:	06 c0       	rjmp	.+12     	; 0x585c <GetKey+0xba>
    5850:	cf 01       	movw	r24, r30
    5852:	83 59       	subi	r24, 0x93	; 147
    5854:	99 4f       	sbci	r25, 0xF9	; 249
    5856:	dc 01       	movw	r26, r24
    5858:	1c 92       	st	X, r1
    585a:	21 c0       	rjmp	.+66     	; 0x589e <GetKey+0xfc>
				else ReedDebounce[i]--; //if not already zero, decrement the counter
    585c:	81 50       	subi	r24, 0x01	; 1
    585e:	aa 81       	ldd	r26, Y+2	; 0x02
    5860:	bb 81       	ldd	r27, Y+3	; 0x03
    5862:	8c 93       	st	X, r24
    5864:	1c c0       	rjmp	.+56     	; 0x589e <GetKey+0xfc>
			}
			else if (!Reeds_Are_Independent){ //if reeds are not considered independent, all reeds must be released before another can fire.
				if((ReedDebounce[0] == 0)&&(ReedDebounce[1] == 0)&&(ReedDebounce[2]== 0)&&(ReedDebounce[3]==0)){ //so wait for all reeds to be released
    5866:	a1 e7       	ldi	r26, 0x71	; 113
    5868:	b6 e0       	ldi	r27, 0x06	; 6
    586a:	8c 91       	ld	r24, X
    586c:	81 11       	cpse	r24, r1
    586e:	10 c0       	rjmp	.+32     	; 0x5890 <GetKey+0xee>
    5870:	80 91 72 06 	lds	r24, 0x0672
    5874:	81 11       	cpse	r24, r1
    5876:	0c c0       	rjmp	.+24     	; 0x5890 <GetKey+0xee>
    5878:	80 91 73 06 	lds	r24, 0x0673
    587c:	81 11       	cpse	r24, r1
    587e:	08 c0       	rjmp	.+16     	; 0x5890 <GetKey+0xee>
    5880:	80 91 74 06 	lds	r24, 0x0674
    5884:	81 11       	cpse	r24, r1
    5886:	04 c0       	rjmp	.+8      	; 0x5890 <GetKey+0xee>
					ActiveReeds[j] = false; // only if all reeds are released do we allow a new reed to be pressed.
    5888:	ad e6       	ldi	r26, 0x6D	; 109
    588a:	b6 e0       	ldi	r27, 0x06	; 6
    588c:	1c 92       	st	X, r1
    588e:	07 c0       	rjmp	.+14     	; 0x589e <GetKey+0xfc>
				}
				else if (ReedDebounce[i]) {ReedDebounce[i]--;} //decrement debounce counter for this reed.
    5890:	aa 81       	ldd	r26, Y+2	; 0x02
    5892:	bb 81       	ldd	r27, Y+3	; 0x03
    5894:	8c 91       	ld	r24, X
    5896:	88 23       	and	r24, r24
    5898:	11 f0       	breq	.+4      	; 0x589e <GetKey+0xfc>
    589a:	81 50       	subi	r24, 0x01	; 1
    589c:	8c 93       	st	X, r24
    589e:	31 96       	adiw	r30, 0x01	; 1
    58a0:	8a 81       	ldd	r24, Y+2	; 0x02
    58a2:	9b 81       	ldd	r25, Y+3	; 0x03
    58a4:	01 96       	adiw	r24, 0x01	; 1
    58a6:	9b 83       	std	Y+3, r25	; 0x03
    58a8:	8a 83       	std	Y+2, r24	; 0x02
    58aa:	9f ef       	ldi	r25, 0xFF	; 255
    58ac:	e9 1a       	sub	r14, r25
    58ae:	f9 0a       	sbc	r15, r25
		
/*READ AND DEBOUNCE REED SWITCH INPUTS*/

		/*Detect which reeds have been pressed, and if they have been sent to the host already or if they still need to be*/
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
    58b0:	e4 30       	cpi	r30, 0x04	; 4
    58b2:	f1 05       	cpc	r31, r1
    58b4:	09 f0       	breq	.+2      	; 0x58b8 <GetKey+0x116>
    58b6:	aa cf       	rjmp	.-172    	; 0x580c <GetKey+0x6a>
    58b8:	79 81       	ldd	r23, Y+1	; 0x01
		

		

/*APPLY VARIOUS MASKS TO SIMPLIFY SENSOR READOUT*/	
		SensorReadout = SensorReadout & KEY_SENSOR_MASK;//discard the reed switch bits and the sensor bit -- look only at the key sensor contacts.
    58ba:	e8 2c       	mov	r14, r8
    58bc:	f9 2c       	mov	r15, r9
    58be:	ca 2c       	mov	r12, r10
    58c0:	bb 2d       	mov	r27, r11
    58c2:	f1 2f       	mov	r31, r17
    58c4:	e7 2f       	mov	r30, r23
    58c6:	d1 2c       	mov	r13, r1
    58c8:	00 e0       	ldi	r16, 0x00	; 0
		if (SensorReadout == KEY_SENSOR_MASK){
    58ca:	28 2d       	mov	r18, r8
    58cc:	39 2d       	mov	r19, r9
    58ce:	4a 2d       	mov	r20, r10
    58d0:	5b 2d       	mov	r21, r11
    58d2:	61 2f       	mov	r22, r17
    58d4:	80 e0       	ldi	r24, 0x00	; 0
    58d6:	90 e0       	ldi	r25, 0x00	; 0
    58d8:	2f 3f       	cpi	r18, 0xFF	; 255
    58da:	af ef       	ldi	r26, 0xFF	; 255
    58dc:	3a 07       	cpc	r19, r26
    58de:	4a 07       	cpc	r20, r26
    58e0:	5a 07       	cpc	r21, r26
    58e2:	6a 07       	cpc	r22, r26
    58e4:	7a 07       	cpc	r23, r26
    58e6:	81 05       	cpc	r24, r1
    58e8:	91 05       	cpc	r25, r1
    58ea:	09 f4       	brne	.+2      	; 0x58ee <GetKey+0x14c>
    58ec:	5f c0       	rjmp	.+190    	; 0x59ac <GetKey+0x20a>
			SensorReadout = 0;// if masked sensor readout is all ones, sensor is probably not plugged in -- discard.
		}
		else if(ActiveKey){
    58ee:	80 91 6c 06 	lds	r24, 0x066C
    58f2:	88 23       	and	r24, r24
    58f4:	a9 f0       	breq	.+42     	; 0x5920 <GetKey+0x17e>
			SensorReadout = (SensorReadout & KEYMASK(ActiveKey)); //if a key was detected last time, mask all others -- only look at that key this time -- prevents confusion from multiple keys.
    58f6:	0f e3       	ldi	r16, 0x3F	; 63
    58f8:	10 e0       	ldi	r17, 0x00	; 0
    58fa:	08 1b       	sub	r16, r24
    58fc:	11 09       	sbc	r17, r1
    58fe:	21 e0       	ldi	r18, 0x01	; 1
    5900:	30 e0       	ldi	r19, 0x00	; 0
    5902:	40 e0       	ldi	r20, 0x00	; 0
    5904:	50 e0       	ldi	r21, 0x00	; 0
    5906:	60 e0       	ldi	r22, 0x00	; 0
    5908:	70 e0       	ldi	r23, 0x00	; 0
    590a:	80 e0       	ldi	r24, 0x00	; 0
    590c:	0e 94 41 39 	call	0x7282	; 0x7282 <__ashldi3>
    5910:	e2 22       	and	r14, r18
    5912:	f3 22       	and	r15, r19
    5914:	c4 22       	and	r12, r20
    5916:	b5 23       	and	r27, r21
    5918:	f6 23       	and	r31, r22
    591a:	e7 23       	and	r30, r23
    591c:	00 e0       	ldi	r16, 0x00	; 0
    591e:	2e c0       	rjmp	.+92     	; 0x597c <GetKey+0x1da>
		}
		else if(PreviousKey){ //if no key was detected, but a key was recently detected (maybe it was just released, or maybe it bounced off)
    5920:	90 91 6b 06 	lds	r25, 0x066B
    5924:	99 23       	and	r25, r25
    5926:	51 f1       	breq	.+84     	; 0x597c <GetKey+0x1da>
			DoubleTapCounter++;
    5928:	80 91 6a 06 	lds	r24, 0x066A
    592c:	8f 5f       	subi	r24, 0xFF	; 255
    592e:	80 93 6a 06 	sts	0x066A, r24
			if (DoubleTapCounter >= DoubleTapTime){ //once the double tap timer has expired, reset everything and stop ignoring previous key.
    5932:	20 91 fe 06 	lds	r18, 0x06FE
    5936:	82 17       	cp	r24, r18
    5938:	28 f0       	brcs	.+10     	; 0x5944 <GetKey+0x1a2>
				DoubleTapCounter = 0;
    593a:	10 92 6a 06 	sts	0x066A, r1
				PreviousKey = 0; 
    593e:	10 92 6b 06 	sts	0x066B, r1
    5942:	1c c0       	rjmp	.+56     	; 0x597c <GetKey+0x1da>
			}		
			else{ //if timer has not expired yet, ignore the previous key pressed.
				SensorReadout = (SensorReadout & ~KEYMASK(PreviousKey)); //whatever the previous active key pressed was, ignore it.
    5944:	0f e3       	ldi	r16, 0x3F	; 63
    5946:	10 e0       	ldi	r17, 0x00	; 0
    5948:	09 1b       	sub	r16, r25
    594a:	11 09       	sbc	r17, r1
    594c:	21 e0       	ldi	r18, 0x01	; 1
    594e:	30 e0       	ldi	r19, 0x00	; 0
    5950:	40 e0       	ldi	r20, 0x00	; 0
    5952:	50 e0       	ldi	r21, 0x00	; 0
    5954:	60 e0       	ldi	r22, 0x00	; 0
    5956:	70 e0       	ldi	r23, 0x00	; 0
    5958:	80 e0       	ldi	r24, 0x00	; 0
    595a:	90 e0       	ldi	r25, 0x00	; 0
    595c:	0e 94 41 39 	call	0x7282	; 0x7282 <__ashldi3>
    5960:	20 95       	com	r18
    5962:	30 95       	com	r19
    5964:	40 95       	com	r20
    5966:	50 95       	com	r21
    5968:	60 95       	com	r22
    596a:	70 95       	com	r23
    596c:	e2 22       	and	r14, r18
    596e:	f3 22       	and	r15, r19
    5970:	c4 22       	and	r12, r20
    5972:	b5 23       	and	r27, r21
    5974:	f6 23       	and	r31, r22
    5976:	e7 23       	and	r30, r23
    5978:	d1 2c       	mov	r13, r1
    597a:	00 e0       	ldi	r16, 0x00	; 0
			}
		}
		
/*DETERMINE WHICH CONTACT, IF ANY, HAS DETECTED A KEY THIS ROUND*/	
		if(SensorReadout){ //if sensor readout is not all zeros
    597c:	2e 2d       	mov	r18, r14
    597e:	3f 2d       	mov	r19, r15
    5980:	4c 2d       	mov	r20, r12
    5982:	5b 2f       	mov	r21, r27
    5984:	6f 2f       	mov	r22, r31
    5986:	7e 2f       	mov	r23, r30
    5988:	8d 2d       	mov	r24, r13
    598a:	90 2f       	mov	r25, r16
    598c:	a0 e0       	ldi	r26, 0x00	; 0
    598e:	0e 94 78 39 	call	0x72f0	; 0x72f0 <__cmpdi2_s8>
    5992:	61 f0       	breq	.+24     	; 0x59ac <GetKey+0x20a>
			DetectedKey = (uint8_t) __builtin_clzll(SensorReadout); //get the position of the first "one" in the sparse key detection array 
    5994:	0e 94 39 39 	call	0x7272	; 0x7272 <__clzdi2>
		else{
			DetectedKey = 0;
		}
		
/*DEBOUNCE KEY READING*/
		if(DetectedKey){//if there is a detected key this time,
    5998:	88 23       	and	r24, r24
    599a:	41 f0       	breq	.+16     	; 0x59ac <GetKey+0x20a>
			 KeyHoldCounter++;  
    599c:	90 91 69 06 	lds	r25, 0x0669
    59a0:	9f 5f       	subi	r25, 0xFF	; 255
    59a2:	90 93 69 06 	sts	0x0669, r25
			 KeyReleaseCounter=0;		 
    59a6:	10 92 68 06 	sts	0x0668, r1
    59aa:	08 c0       	rjmp	.+16     	; 0x59bc <GetKey+0x21a>
		}
		else {
			KeyReleaseCounter++; 
    59ac:	80 91 68 06 	lds	r24, 0x0668
    59b0:	8f 5f       	subi	r24, 0xFF	; 255
    59b2:	80 93 68 06 	sts	0x0668, r24
			KeyHoldCounter = 0;  
    59b6:	10 92 69 06 	sts	0x0669, r1
    59ba:	80 e0       	ldi	r24, 0x00	; 0
		}
		
		if (KeyHoldCounter >= KeyHoldTime){
    59bc:	90 91 47 07 	lds	r25, 0x0747
    59c0:	20 91 69 06 	lds	r18, 0x0669
    59c4:	29 17       	cp	r18, r25
    59c6:	60 f0       	brcs	.+24     	; 0x59e0 <GetKey+0x23e>
			KeyHoldCounter = KeyHoldTime; // can't get higher than keyholdtime
    59c8:	90 93 69 06 	sts	0x0669, r25
			if (DetectedKey != ActiveKey){ // if this is a new active key (just pressed) then set the active key to the new value, and give go-ahead to send it.
    59cc:	90 91 6c 06 	lds	r25, 0x066C
    59d0:	89 17       	cp	r24, r25
    59d2:	09 f4       	brne	.+2      	; 0x59d6 <GetKey+0x234>
    59d4:	4b c0       	rjmp	.+150    	; 0x5a6c <GetKey+0x2ca>
				ActiveKey = DetectedKey; //the current key is the new active key
    59d6:	80 93 6c 06 	sts	0x066C, r24
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
    59da:	51 10       	cpse	r5, r1
    59dc:	11 c0       	rjmp	.+34     	; 0x5a00 <GetKey+0x25e>
    59de:	49 c0       	rjmp	.+146    	; 0x5a72 <GetKey+0x2d0>
			if (DetectedKey != ActiveKey){ // if this is a new active key (just pressed) then set the active key to the new value, and give go-ahead to send it.
				ActiveKey = DetectedKey; //the current key is the new active key
				OKtoSendKey = true;
			}
		}
		else if (KeyReleaseCounter >= KeyReleaseTime){
    59e0:	80 91 ba 06 	lds	r24, 0x06BA
    59e4:	90 91 68 06 	lds	r25, 0x0668
    59e8:	98 17       	cp	r25, r24
    59ea:	08 f4       	brcc	.+2      	; 0x59ee <GetKey+0x24c>
    59ec:	3f c0       	rjmp	.+126    	; 0x5a6c <GetKey+0x2ca>
			KeyReleaseCounter = KeyReleaseTime; //
    59ee:	80 93 68 06 	sts	0x0668, r24
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
    59f2:	80 91 6c 06 	lds	r24, 0x066C
    59f6:	80 93 6b 06 	sts	0x066B, r24
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
    59fa:	10 92 6c 06 	sts	0x066C, r1
    59fe:	36 c0       	rjmp	.+108    	; 0x5a6c <GetKey+0x2ca>
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
			return ReedToSend;
    5a00:	82 2d       	mov	r24, r2
    5a02:	37 c0       	rjmp	.+110    	; 0x5a72 <GetKey+0x2d0>
			int j;
			
			if (Reeds_Are_Independent) j = i; //
			else j = 0; //setting j = 0 means "If any reed is active, all reeds are considered active also (and are therefore won't be sent when pressed)
			
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
    5a04:	d7 01       	movw	r26, r14
    5a06:	0c 91       	ld	r16, X
    5a08:	28 2d       	mov	r18, r8
    5a0a:	39 2d       	mov	r19, r9
    5a0c:	4a 2d       	mov	r20, r10
    5a0e:	5b 2d       	mov	r21, r11
    5a10:	61 2f       	mov	r22, r17
    5a12:	79 81       	ldd	r23, Y+1	; 0x01
    5a14:	86 2d       	mov	r24, r6
    5a16:	94 2d       	mov	r25, r4
    5a18:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__lshrdi3>
    5a1c:	21 70       	andi	r18, 0x01	; 1
    5a1e:	30 e0       	ldi	r19, 0x00	; 0
    5a20:	40 e0       	ldi	r20, 0x00	; 0
    5a22:	50 e0       	ldi	r21, 0x00	; 0
    5a24:	60 e0       	ldi	r22, 0x00	; 0
    5a26:	70 e0       	ldi	r23, 0x00	; 0
    5a28:	80 e0       	ldi	r24, 0x00	; 0
    5a2a:	90 e0       	ldi	r25, 0x00	; 0
    5a2c:	a0 e0       	ldi	r26, 0x00	; 0
    5a2e:	0e 94 78 39 	call	0x72f0	; 0x72f0 <__cmpdi2_s8>
    5a32:	09 f0       	breq	.+2      	; 0x5a36 <GetKey+0x294>
    5a34:	ef ce       	rjmp	.-546    	; 0x5814 <GetKey+0x72>
    5a36:	17 cf       	rjmp	.-466    	; 0x5866 <GetKey+0xc4>
    5a38:	d7 01       	movw	r26, r14
    5a3a:	0c 91       	ld	r16, X
    5a3c:	28 2d       	mov	r18, r8
    5a3e:	39 2d       	mov	r19, r9
    5a40:	4a 2d       	mov	r20, r10
    5a42:	5b 2d       	mov	r21, r11
    5a44:	61 2f       	mov	r22, r17
    5a46:	79 81       	ldd	r23, Y+1	; 0x01
    5a48:	86 2d       	mov	r24, r6
    5a4a:	94 2d       	mov	r25, r4
    5a4c:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__lshrdi3>
    5a50:	21 70       	andi	r18, 0x01	; 1
    5a52:	30 e0       	ldi	r19, 0x00	; 0
    5a54:	40 e0       	ldi	r20, 0x00	; 0
    5a56:	50 e0       	ldi	r21, 0x00	; 0
    5a58:	60 e0       	ldi	r22, 0x00	; 0
    5a5a:	70 e0       	ldi	r23, 0x00	; 0
    5a5c:	80 e0       	ldi	r24, 0x00	; 0
    5a5e:	90 e0       	ldi	r25, 0x00	; 0
    5a60:	a0 e0       	ldi	r26, 0x00	; 0
    5a62:	0e 94 78 39 	call	0x72f0	; 0x72f0 <__cmpdi2_s8>
    5a66:	09 f0       	breq	.+2      	; 0x5a6a <GetKey+0x2c8>
    5a68:	d7 ce       	rjmp	.-594    	; 0x5818 <GetKey+0x76>
    5a6a:	ed ce       	rjmp	.-550    	; 0x5846 <GetKey+0xa4>
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
    5a6c:	51 10       	cpse	r5, r1
    5a6e:	c8 cf       	rjmp	.-112    	; 0x5a00 <GetKey+0x25e>
		}
		else if(OKtoSendKey){ //otherwise, if there is a key to send, report it
			return ActiveKey; 
		}
		else{
			return 0; //if no keys or reeds need sending, return 0
    5a70:	80 e0       	ldi	r24, 0x00	; 0
		}

}
    5a72:	0f 90       	pop	r0
    5a74:	0f 90       	pop	r0
    5a76:	0f 90       	pop	r0
    5a78:	df 91       	pop	r29
    5a7a:	cf 91       	pop	r28
    5a7c:	1f 91       	pop	r17
    5a7e:	0f 91       	pop	r16
    5a80:	ff 90       	pop	r15
    5a82:	ef 90       	pop	r14
    5a84:	df 90       	pop	r13
    5a86:	cf 90       	pop	r12
    5a88:	bf 90       	pop	r11
    5a8a:	af 90       	pop	r10
    5a8c:	9f 90       	pop	r9
    5a8e:	8f 90       	pop	r8
    5a90:	7f 90       	pop	r7
    5a92:	6f 90       	pop	r6
    5a94:	5f 90       	pop	r5
    5a96:	4f 90       	pop	r4
    5a98:	3f 90       	pop	r3
    5a9a:	2f 90       	pop	r2
    5a9c:	08 95       	ret

00005a9e <GetHIDKeyCode>:
		if (Shift_Reed != 4 && is_high(REED_4)==(bool)Reed4Polarity){ Readout |= LONGLONGBIT(REED_BITS[3]);} //60th bit of readout (or something like that) represents Reed4
		
		return Readout;
}

uint8_t GetHIDKeyCode(uint8_t key, uint8_t modifier){ 
    5a9e:	e8 2f       	mov	r30, r24
	uint8_t code;

	if ((modifier & HID_KEYBOARD_MODIFIER_LEFTALT) && FnKeyCodeLookUpTable[key]){ //if the FN key is held down, look up key in FN array.
    5aa0:	62 ff       	sbrs	r22, 2
    5aa2:	07 c0       	rjmp	.+14     	; 0x5ab2 <GetHIDKeyCode+0x14>
    5aa4:	a8 2f       	mov	r26, r24
    5aa6:	b0 e0       	ldi	r27, 0x00	; 0
    5aa8:	a6 5f       	subi	r26, 0xF6	; 246
    5aaa:	b5 4f       	sbci	r27, 0xF5	; 245
    5aac:	8c 91       	ld	r24, X
    5aae:	81 11       	cpse	r24, r1
    5ab0:	0d c0       	rjmp	.+26     	; 0x5acc <GetHIDKeyCode+0x2e>
		code = FnKeyCodeLookUpTable[key];
	}
	else if ((modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT) && ShiftKeyCodeLookUpTable[key]){
    5ab2:	61 ff       	sbrs	r22, 1
    5ab4:	07 c0       	rjmp	.+14     	; 0x5ac4 <GetHIDKeyCode+0x26>
    5ab6:	ae 2f       	mov	r26, r30
    5ab8:	b0 e0       	ldi	r27, 0x00	; 0
    5aba:	a9 5f       	subi	r26, 0xF9	; 249
    5abc:	b8 4f       	sbci	r27, 0xF8	; 248
    5abe:	8c 91       	ld	r24, X
    5ac0:	81 11       	cpse	r24, r1
    5ac2:	04 c0       	rjmp	.+8      	; 0x5acc <GetHIDKeyCode+0x2e>
		code = ShiftKeyCodeLookUpTable[key];
	}
	else {
		code = KeyCodeLookUpTable[key]; //otherwise, look up the key in the regular array.
    5ac4:	f0 e0       	ldi	r31, 0x00	; 0
    5ac6:	e4 54       	subi	r30, 0x44	; 68
    5ac8:	f9 4f       	sbci	r31, 0xF9	; 249
    5aca:	80 81       	ld	r24, Z
	}
	return code;
}
    5acc:	08 95       	ret

00005ace <GetASCIIKeyCode>:

uint8_t GetASCIIKeyCode(uint8_t key, uint8_t modifier){
	uint8_t code;
	
	if(key == 0){
    5ace:	88 23       	and	r24, r24
    5ad0:	79 f0       	breq	.+30     	; 0x5af0 <GetASCIIKeyCode+0x22>
		return 0;
	}
	
	if ((modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT) && ASCIIShiftLookUpTable[key]){
    5ad2:	61 ff       	sbrs	r22, 1
    5ad4:	07 c0       	rjmp	.+14     	; 0x5ae4 <GetASCIIKeyCode+0x16>
    5ad6:	e8 2f       	mov	r30, r24
    5ad8:	f0 e0       	ldi	r31, 0x00	; 0
    5ada:	e8 5b       	subi	r30, 0xB8	; 184
    5adc:	f8 4f       	sbci	r31, 0xF8	; 248
    5ade:	90 81       	ld	r25, Z
    5ae0:	91 11       	cpse	r25, r1
    5ae2:	08 c0       	rjmp	.+16     	; 0x5af4 <GetASCIIKeyCode+0x26>
		code = ASCIIShiftLookUpTable[key];
	}
	else {
		code = ASCIILookUpTable[key];
    5ae4:	e8 2f       	mov	r30, r24
    5ae6:	f0 e0       	ldi	r31, 0x00	; 0
    5ae8:	e9 53       	subi	r30, 0x39	; 57
    5aea:	f8 4f       	sbci	r31, 0xF8	; 248
    5aec:	80 81       	ld	r24, Z
    5aee:	08 95       	ret

uint8_t GetASCIIKeyCode(uint8_t key, uint8_t modifier){
	uint8_t code;
	
	if(key == 0){
		return 0;
    5af0:	80 e0       	ldi	r24, 0x00	; 0
    5af2:	08 95       	ret
	}
	
	if ((modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT) && ASCIIShiftLookUpTable[key]){
		code = ASCIIShiftLookUpTable[key];
    5af4:	89 2f       	mov	r24, r25
	}
	else {
		code = ASCIILookUpTable[key];
	}
	return code;
}
    5af6:	08 95       	ret

00005af8 <getHallState>:

bool getHallState(){ //don't call this function from inside ReadSensor !  It will cause an infinite loop...
    5af8:	0f 93       	push	r16
	bool hallstate;
	hallstate = (ReadSensor() & LONGLONGBIT(HALL_SENSOR_BIT));
    5afa:	64 dd       	rcall	.-1336   	; 0x55c4 <ReadSensor>
    5afc:	0c e2       	ldi	r16, 0x2C	; 44
    5afe:	0e 94 5c 39 	call	0x72b8	; 0x72b8 <__lshrdi3>
	return hallstate;
}
    5b02:	82 2f       	mov	r24, r18
    5b04:	81 70       	andi	r24, 0x01	; 1
    5b06:	0f 91       	pop	r16
    5b08:	08 95       	ret

00005b0a <LoadKeyCodeTables>:

	

void LoadKeyCodeTables(){
	 eeprom_read_block (( void *) KeyCodeLookUpTable, (void *) KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    5b0a:	40 e4       	ldi	r20, 0x40	; 64
    5b0c:	50 e0       	ldi	r21, 0x00	; 0
    5b0e:	60 e0       	ldi	r22, 0x00	; 0
    5b10:	70 e0       	ldi	r23, 0x00	; 0
    5b12:	8c eb       	ldi	r24, 0xBC	; 188
    5b14:	96 e0       	ldi	r25, 0x06	; 6
    5b16:	0e 94 a5 3c 	call	0x794a	; 0x794a <eeprom_read_block>
	 eeprom_read_block (( void *) FnKeyCodeLookUpTable, (void *) FN_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    5b1a:	40 e4       	ldi	r20, 0x40	; 64
    5b1c:	50 e0       	ldi	r21, 0x00	; 0
    5b1e:	60 e4       	ldi	r22, 0x40	; 64
    5b20:	70 e0       	ldi	r23, 0x00	; 0
    5b22:	8a e0       	ldi	r24, 0x0A	; 10
    5b24:	9a e0       	ldi	r25, 0x0A	; 10
    5b26:	0e 94 a5 3c 	call	0x794a	; 0x794a <eeprom_read_block>
	 eeprom_read_block (( void *) ShiftKeyCodeLookUpTable, (void *) SHIFT_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    5b2a:	40 e4       	ldi	r20, 0x40	; 64
    5b2c:	50 e0       	ldi	r21, 0x00	; 0
    5b2e:	60 e8       	ldi	r22, 0x80	; 128
    5b30:	70 e0       	ldi	r23, 0x00	; 0
    5b32:	87 e0       	ldi	r24, 0x07	; 7
    5b34:	97 e0       	ldi	r25, 0x07	; 7
    5b36:	0e 94 a5 3c 	call	0x794a	; 0x794a <eeprom_read_block>
	 eeprom_read_block (( void *) ASCIILookUpTable, (void *) ASCII_ADDR, KEYCODE_ARRAY_LENGTH);
    5b3a:	40 e4       	ldi	r20, 0x40	; 64
    5b3c:	50 e0       	ldi	r21, 0x00	; 0
    5b3e:	60 ec       	ldi	r22, 0xC0	; 192
    5b40:	70 e0       	ldi	r23, 0x00	; 0
    5b42:	87 ec       	ldi	r24, 0xC7	; 199
    5b44:	97 e0       	ldi	r25, 0x07	; 7
    5b46:	0e 94 a5 3c 	call	0x794a	; 0x794a <eeprom_read_block>
	 eeprom_read_block (( void *) ASCIIShiftLookUpTable, (void *) ASCII_SHIFT_ADDR, KEYCODE_ARRAY_LENGTH);
    5b4a:	40 e4       	ldi	r20, 0x40	; 64
    5b4c:	50 e0       	ldi	r21, 0x00	; 0
    5b4e:	60 e0       	ldi	r22, 0x00	; 0
    5b50:	71 e0       	ldi	r23, 0x01	; 1
    5b52:	88 e4       	ldi	r24, 0x48	; 72
    5b54:	97 e0       	ldi	r25, 0x07	; 7
    5b56:	0c 94 a5 3c 	jmp	0x794a	; 0x794a <eeprom_read_block>
    5b5a:	08 95       	ret

00005b5c <LoadEepromParameters>:

}

void LoadEepromParameters(){	
	 KeyReleaseTime = eeprom_read_byte((uint8_t *)RELEASE_TIME_ADDR);
    5b5c:	82 e0       	ldi	r24, 0x02	; 2
    5b5e:	92 e0       	ldi	r25, 0x02	; 2
    5b60:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    5b64:	80 93 ba 06 	sts	0x06BA, r24
	 KeyHoldTime = eeprom_read_byte((uint8_t *)HOLD_TIME_ADDR);
    5b68:	81 e0       	ldi	r24, 0x01	; 1
    5b6a:	92 e0       	ldi	r25, 0x02	; 2
    5b6c:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    5b70:	80 93 47 07 	sts	0x0747, r24
	 DoubleTapTime = eeprom_read_byte((uint8_t *)DOUBLE_TAP_ADDR);
    5b74:	80 e0       	ldi	r24, 0x00	; 0
    5b76:	92 e0       	ldi	r25, 0x02	; 2
    5b78:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    5b7c:	80 93 fe 06 	sts	0x06FE, r24
	 ReedHoldTime = eeprom_read_byte((uint8_t *)REED_HOLD_TIME_ADDR);
    5b80:	8c e0       	ldi	r24, 0x0C	; 12
    5b82:	92 e0       	ldi	r25, 0x02	; 2
    5b84:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    5b88:	80 93 fd 06 	sts	0x06FD, r24
	 UseHallSensor = eeprom_read_byte((uint8_t *)USE_HALL_SENSOR_ADDR);
    5b8c:	83 e0       	ldi	r24, 0x03	; 3
    5b8e:	92 e0       	ldi	r25, 0x02	; 2
    5b90:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    5b94:	80 93 89 07 	sts	0x0789, r24
	 HallSensorPolarity = eeprom_read_byte((uint8_t *)HALL_SENSOR_POLARITY_ADDR);
    5b98:	84 e0       	ldi	r24, 0x04	; 4
    5b9a:	92 e0       	ldi	r25, 0x02	; 2
    5b9c:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    5ba0:	80 93 05 07 	sts	0x0705, r24
	 Shift_Reed = eeprom_read_byte((uint8_t *)SHIFT_REED_ADDR);
    5ba4:	85 e0       	ldi	r24, 0x05	; 5
    5ba6:	92 e0       	ldi	r25, 0x02	; 2
    5ba8:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    5bac:	80 93 ff 06 	sts	0x06FF, r24
	 Reeds_Are_Independent = eeprom_read_byte((uint8_t *)REEDS_INDEPENDENT_ADDR);
    5bb0:	8e e0       	ldi	r24, 0x0E	; 14
    5bb2:	92 e0       	ldi	r25, 0x02	; 2
    5bb4:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    5bb8:	80 93 b8 06 	sts	0x06B8, r24
	 UseDummyLoad = eeprom_read_byte((uint8_t*)DUMMY_LOAD_ADDR);
    5bbc:	8f e0       	ldi	r24, 0x0F	; 15
    5bbe:	92 e0       	ldi	r25, 0x02	; 2
    5bc0:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    5bc4:	80 93 b7 06 	sts	0x06B7, r24
	 BluetoothConfigured = eeprom_read_byte((uint8_t*)BLUETOOTH_CONFIGURED_ADDR);
    5bc8:	80 e1       	ldi	r24, 0x10	; 16
    5bca:	92 e0       	ldi	r25, 0x02	; 2
    5bcc:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    5bd0:	80 93 fc 06 	sts	0x06FC, r24
    5bd4:	08 95       	ret

00005bd6 <ClearKeyCodeTables>:
}

void ClearKeyCodeTables(){
	memset (&KeyCodeLookUpTable[0] , 0, KEYCODE_ARRAY_LENGTH);
    5bd6:	80 e4       	ldi	r24, 0x40	; 64
    5bd8:	ec eb       	ldi	r30, 0xBC	; 188
    5bda:	f6 e0       	ldi	r31, 0x06	; 6
    5bdc:	df 01       	movw	r26, r30
    5bde:	98 2f       	mov	r25, r24
    5be0:	1d 92       	st	X+, r1
    5be2:	9a 95       	dec	r25
    5be4:	e9 f7       	brne	.-6      	; 0x5be0 <ClearKeyCodeTables+0xa>
	memset (&FnKeyCodeLookUpTable[0] , 0, KEYCODE_ARRAY_LENGTH);
    5be6:	ea e0       	ldi	r30, 0x0A	; 10
    5be8:	fa e0       	ldi	r31, 0x0A	; 10
    5bea:	df 01       	movw	r26, r30
    5bec:	98 2f       	mov	r25, r24
    5bee:	1d 92       	st	X+, r1
    5bf0:	9a 95       	dec	r25
    5bf2:	e9 f7       	brne	.-6      	; 0x5bee <ClearKeyCodeTables+0x18>
	memset (&ShiftKeyCodeLookUpTable[0], 0, KEYCODE_ARRAY_LENGTH);
    5bf4:	e7 e0       	ldi	r30, 0x07	; 7
    5bf6:	f7 e0       	ldi	r31, 0x07	; 7
    5bf8:	df 01       	movw	r26, r30
    5bfa:	98 2f       	mov	r25, r24
    5bfc:	1d 92       	st	X+, r1
    5bfe:	9a 95       	dec	r25
    5c00:	e9 f7       	brne	.-6      	; 0x5bfc <ClearKeyCodeTables+0x26>
	memset (&ASCIILookUpTable[0],0,KEYCODE_ARRAY_LENGTH);
    5c02:	e7 ec       	ldi	r30, 0xC7	; 199
    5c04:	f7 e0       	ldi	r31, 0x07	; 7
    5c06:	df 01       	movw	r26, r30
    5c08:	98 2f       	mov	r25, r24
    5c0a:	1d 92       	st	X+, r1
    5c0c:	9a 95       	dec	r25
    5c0e:	e9 f7       	brne	.-6      	; 0x5c0a <ClearKeyCodeTables+0x34>
	memset (&ASCIIShiftLookUpTable[0],0,KEYCODE_ARRAY_LENGTH);
    5c10:	e8 e4       	ldi	r30, 0x48	; 72
    5c12:	f7 e0       	ldi	r31, 0x07	; 7
    5c14:	df 01       	movw	r26, r30
    5c16:	1d 92       	st	X+, r1
    5c18:	8a 95       	dec	r24
    5c1a:	e9 f7       	brne	.-6      	; 0x5c16 <ClearKeyCodeTables+0x40>

	Shift_Reed = 0;
    5c1c:	10 92 ff 06 	sts	0x06FF, r1
    5c20:	08 95       	ret

00005c22 <RestoreFactoryDefaults>:
		eeprom_write_byte((uint8_t*)EEP_CHECKSUM_ADDR, EEP_CHECKSUM);//write the checksum to the eeprom to indicate that eeprom has been properly initialized.
	}
}

void RestoreFactoryDefaults(){
			eeprom_update_byte((uint8_t*)DOUBLE_TAP_ADDR, DEFAULT_DOUBLE_TAP_TIME);
    5c22:	65 e0       	ldi	r22, 0x05	; 5
    5c24:	80 e0       	ldi	r24, 0x00	; 0
    5c26:	92 e0       	ldi	r25, 0x02	; 2
    5c28:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)HOLD_TIME_ADDR, DEFAULT_HOLD_TIME);
    5c2c:	66 e0       	ldi	r22, 0x06	; 6
    5c2e:	81 e0       	ldi	r24, 0x01	; 1
    5c30:	92 e0       	ldi	r25, 0x02	; 2
    5c32:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)RELEASE_TIME_ADDR, DEFAULT_RELEASE_TIME);
    5c36:	63 e0       	ldi	r22, 0x03	; 3
    5c38:	82 e0       	ldi	r24, 0x02	; 2
    5c3a:	92 e0       	ldi	r25, 0x02	; 2
    5c3c:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)REED_HOLD_TIME_ADDR, DEFAULT_REED_HOLD_TIME);
    5c40:	63 e0       	ldi	r22, 0x03	; 3
    5c42:	8c e0       	ldi	r24, 0x0C	; 12
    5c44:	92 e0       	ldi	r25, 0x02	; 2
    5c46:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)REEDS_INDEPENDENT_ADDR,REEDS_ARE_INDEPENDENT_BY_DEFAULT);
    5c4a:	60 e0       	ldi	r22, 0x00	; 0
    5c4c:	8e e0       	ldi	r24, 0x0E	; 14
    5c4e:	92 e0       	ldi	r25, 0x02	; 2
    5c50:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)DEFAULT_MODE_ADDR,USB_COMBO_MODE);
    5c54:	61 e0       	ldi	r22, 0x01	; 1
    5c56:	8d e0       	ldi	r24, 0x0D	; 13
    5c58:	92 e0       	ldi	r25, 0x02	; 2
    5c5a:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)DUMMY_LOAD_ADDR,0); //do not use dummy load unless told to.
    5c5e:	60 e0       	ldi	r22, 0x00	; 0
    5c60:	8f e0       	ldi	r24, 0x0F	; 15
    5c62:	92 e0       	ldi	r25, 0x02	; 2
    5c64:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
			eeprom_write_word((uint16_t *)FILENUM_ADDR,0);//reset sd card file number to zero.
    5c68:	60 e0       	ldi	r22, 0x00	; 0
    5c6a:	70 e0       	ldi	r23, 0x00	; 0
    5c6c:	8a e0       	ldi	r24, 0x0A	; 10
    5c6e:	92 e0       	ldi	r25, 0x02	; 2
    5c70:	0e 94 eb 3c 	call	0x79d6	; 0x79d6 <eeprom_write_word>
			eeprom_write_byte((uint8_t*)USE_HALL_SENSOR_ADDR,HALL_NOT_PRESENT);
    5c74:	60 e0       	ldi	r22, 0x00	; 0
    5c76:	83 e0       	ldi	r24, 0x03	; 3
    5c78:	92 e0       	ldi	r25, 0x02	; 2
    5c7a:	0e 94 dd 3c 	call	0x79ba	; 0x79ba <eeprom_write_byte>
			
			LoadEepromParameters(); //load new defaults into RAM
    5c7e:	6e cf       	rjmp	.-292    	; 0x5b5c <LoadEepromParameters>
    5c80:	08 95       	ret

00005c82 <InitializeEeprom>:

	Shift_Reed = 0;
//	UseHallSensor = HALL_NOT_PRESENT;	
}

void InitializeEeprom(){
    5c82:	cf 93       	push	r28
    5c84:	df 93       	push	r29
	int i;
	if (eeprom_read_byte((uint8_t*)EEP_CHECKSUM_ADDR) != EEP_CHECKSUM){
    5c86:	8f ef       	ldi	r24, 0xFF	; 255
    5c88:	93 e0       	ldi	r25, 0x03	; 3
    5c8a:	0e 94 b5 3c 	call	0x796a	; 0x796a <eeprom_read_byte>
    5c8e:	87 34       	cpi	r24, 0x47	; 71
    5c90:	e1 f0       	breq	.+56     	; 0x5cca <InitializeEeprom+0x48>
    5c92:	c0 e0       	ldi	r28, 0x00	; 0
    5c94:	d0 e0       	ldi	r29, 0x00	; 0
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
    5c96:	60 e0       	ldi	r22, 0x00	; 0
    5c98:	ce 01       	movw	r24, r28
    5c9a:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>

void InitializeEeprom(){
	int i;
	if (eeprom_read_byte((uint8_t*)EEP_CHECKSUM_ADDR) != EEP_CHECKSUM){
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
    5c9e:	21 96       	adiw	r28, 0x01	; 1
    5ca0:	c1 35       	cpi	r28, 0x51	; 81
    5ca2:	81 e0       	ldi	r24, 0x01	; 1
    5ca4:	d8 07       	cpc	r29, r24
    5ca6:	b9 f7       	brne	.-18     	; 0x5c96 <InitializeEeprom+0x14>
    5ca8:	c0 e0       	ldi	r28, 0x00	; 0
    5caa:	d2 e0       	ldi	r29, 0x02	; 2
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		for(i=EEP_BANK2; i<=EEP_BANK2_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
    5cac:	60 e0       	ldi	r22, 0x00	; 0
    5cae:	ce 01       	movw	r24, r28
    5cb0:	0e 94 c2 3c 	call	0x7984	; 0x7984 <eeprom_update_byte>
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		for(i=EEP_BANK2; i<=EEP_BANK2_END; i++){
    5cb4:	21 96       	adiw	r28, 0x01	; 1
    5cb6:	c2 31       	cpi	r28, 0x12	; 18
    5cb8:	82 e0       	ldi	r24, 0x02	; 2
    5cba:	d8 07       	cpc	r29, r24
    5cbc:	b9 f7       	brne	.-18     	; 0x5cac <InitializeEeprom+0x2a>
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		RestoreFactoryDefaults();
    5cbe:	b1 df       	rcall	.-158    	; 0x5c22 <RestoreFactoryDefaults>

		eeprom_write_byte((uint8_t*)EEP_CHECKSUM_ADDR, EEP_CHECKSUM);//write the checksum to the eeprom to indicate that eeprom has been properly initialized.
    5cc0:	67 e4       	ldi	r22, 0x47	; 71
    5cc2:	8f ef       	ldi	r24, 0xFF	; 255
    5cc4:	93 e0       	ldi	r25, 0x03	; 3
    5cc6:	0e 94 dd 3c 	call	0x79ba	; 0x79ba <eeprom_write_byte>
	}
}
    5cca:	df 91       	pop	r29
    5ccc:	cf 91       	pop	r28
    5cce:	08 95       	ret

00005cd0 <HID_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_HID_DRIVER
#define  __INCLUDE_FROM_HID_DEVICE_C
#include "HIDClassDevice.h"

void HID_Device_ProcessControlRequest(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
    5cd0:	3f 92       	push	r3
    5cd2:	4f 92       	push	r4
    5cd4:	5f 92       	push	r5
    5cd6:	6f 92       	push	r6
    5cd8:	7f 92       	push	r7
    5cda:	8f 92       	push	r8
    5cdc:	9f 92       	push	r9
    5cde:	af 92       	push	r10
    5ce0:	bf 92       	push	r11
    5ce2:	cf 92       	push	r12
    5ce4:	df 92       	push	r13
    5ce6:	ef 92       	push	r14
    5ce8:	ff 92       	push	r15
    5cea:	0f 93       	push	r16
    5cec:	1f 93       	push	r17
    5cee:	cf 93       	push	r28
    5cf0:	df 93       	push	r29
    5cf2:	00 d0       	rcall	.+0      	; 0x5cf4 <HID_Device_ProcessControlRequest+0x24>
    5cf4:	1f 92       	push	r1
    5cf6:	cd b7       	in	r28, 0x3d	; 61
    5cf8:	de b7       	in	r29, 0x3e	; 62
    5cfa:	6c 01       	movw	r12, r24
				Endpoint_ClearStatusStage();
			}

			break;
	}
}
    5cfc:	ed b6       	in	r14, 0x3d	; 61
    5cfe:	fe b6       	in	r15, 0x3e	; 62
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5d00:	80 91 e8 00 	lds	r24, 0x00E8
#define  __INCLUDE_FROM_HID_DEVICE_C
#include "HIDClassDevice.h"

void HID_Device_ProcessControlRequest(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	if (!(Endpoint_IsSETUPReceived()))
    5d04:	83 ff       	sbrs	r24, 3
    5d06:	15 c1       	rjmp	.+554    	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
	  return;

	if (USB_ControlRequest.wIndex != HIDInterfaceInfo->Config.InterfaceNumber)
    5d08:	f6 01       	movw	r30, r12
    5d0a:	80 81       	ld	r24, Z
    5d0c:	90 e0       	ldi	r25, 0x00	; 0
    5d0e:	20 91 53 0a 	lds	r18, 0x0A53
    5d12:	30 91 54 0a 	lds	r19, 0x0A54
    5d16:	28 17       	cp	r18, r24
    5d18:	39 07       	cpc	r19, r25
    5d1a:	09 f0       	breq	.+2      	; 0x5d1e <HID_Device_ProcessControlRequest+0x4e>
    5d1c:	0a c1       	rjmp	.+532    	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
	  return;

	switch (USB_ControlRequest.bRequest)
    5d1e:	80 91 50 0a 	lds	r24, 0x0A50
    5d22:	83 30       	cpi	r24, 0x03	; 3
    5d24:	09 f4       	brne	.+2      	; 0x5d28 <HID_Device_ProcessControlRequest+0x58>
    5d26:	a2 c0       	rjmp	.+324    	; 0x5e6c <HID_Device_ProcessControlRequest+0x19c>
    5d28:	30 f4       	brcc	.+12     	; 0x5d36 <HID_Device_ProcessControlRequest+0x66>
    5d2a:	81 30       	cpi	r24, 0x01	; 1
    5d2c:	71 f0       	breq	.+28     	; 0x5d4a <HID_Device_ProcessControlRequest+0x7a>
    5d2e:	82 30       	cpi	r24, 0x02	; 2
    5d30:	09 f4       	brne	.+2      	; 0x5d34 <HID_Device_ProcessControlRequest+0x64>
    5d32:	e4 c0       	rjmp	.+456    	; 0x5efc <HID_Device_ProcessControlRequest+0x22c>
    5d34:	fe c0       	rjmp	.+508    	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
    5d36:	8a 30       	cpi	r24, 0x0A	; 10
    5d38:	09 f4       	brne	.+2      	; 0x5d3c <HID_Device_ProcessControlRequest+0x6c>
    5d3a:	c4 c0       	rjmp	.+392    	; 0x5ec4 <HID_Device_ProcessControlRequest+0x1f4>
    5d3c:	8b 30       	cpi	r24, 0x0B	; 11
    5d3e:	09 f4       	brne	.+2      	; 0x5d42 <HID_Device_ProcessControlRequest+0x72>
    5d40:	ad c0       	rjmp	.+346    	; 0x5e9c <HID_Device_ProcessControlRequest+0x1cc>
    5d42:	89 30       	cpi	r24, 0x09	; 9
    5d44:	09 f0       	breq	.+2      	; 0x5d48 <HID_Device_ProcessControlRequest+0x78>
    5d46:	f5 c0       	rjmp	.+490    	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
    5d48:	53 c0       	rjmp	.+166    	; 0x5df0 <HID_Device_ProcessControlRequest+0x120>
	{
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    5d4a:	80 91 4f 0a 	lds	r24, 0x0A4F
    5d4e:	81 3a       	cpi	r24, 0xA1	; 161
    5d50:	09 f0       	breq	.+2      	; 0x5d54 <HID_Device_ProcessControlRequest+0x84>
    5d52:	ef c0       	rjmp	.+478    	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
    5d54:	ad b6       	in	r10, 0x3d	; 61
    5d56:	be b6       	in	r11, 0x3e	; 62
			{
				uint16_t ReportSize = 0;
    5d58:	1a 82       	std	Y+2, r1	; 0x02
    5d5a:	19 82       	std	Y+1, r1	; 0x01
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
    5d5c:	ef e4       	ldi	r30, 0x4F	; 79
    5d5e:	fa e0       	ldi	r31, 0x0A	; 10
    5d60:	82 81       	ldd	r24, Z+2	; 0x02
    5d62:	13 81       	ldd	r17, Z+3	; 0x03
    5d64:	8b 83       	std	Y+3, r24	; 0x03
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
				uint8_t  ReportData[HIDInterfaceInfo->Config.PrevReportINBufferSize];
    5d66:	f6 01       	movw	r30, r12
    5d68:	80 85       	ldd	r24, Z+8	; 0x08
    5d6a:	48 2f       	mov	r20, r24
    5d6c:	50 e0       	ldi	r21, 0x00	; 0
    5d6e:	8d b7       	in	r24, 0x3d	; 61
    5d70:	9e b7       	in	r25, 0x3e	; 62
    5d72:	84 1b       	sub	r24, r20
    5d74:	95 0b       	sbc	r25, r21
    5d76:	0f b6       	in	r0, 0x3f	; 63
    5d78:	f8 94       	cli
    5d7a:	9e bf       	out	0x3e, r25	; 62
    5d7c:	0f be       	out	0x3f, r0	; 63
    5d7e:	8d bf       	out	0x3d, r24	; 61
    5d80:	ed b7       	in	r30, 0x3d	; 61
    5d82:	fe b7       	in	r31, 0x3e	; 62
    5d84:	31 96       	adiw	r30, 0x01	; 1
    5d86:	4f 01       	movw	r8, r30

				memset(ReportData, 0, sizeof(ReportData));
    5d88:	60 e0       	ldi	r22, 0x00	; 0
    5d8a:	70 e0       	ldi	r23, 0x00	; 0
    5d8c:	cf 01       	movw	r24, r30
    5d8e:	0e 94 e8 39 	call	0x73d0	; 0x73d0 <memset>
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				uint16_t ReportSize = 0;
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
    5d92:	4f ef       	ldi	r20, 0xFF	; 255
    5d94:	41 0f       	add	r20, r17
				uint8_t  ReportData[HIDInterfaceInfo->Config.PrevReportINBufferSize];

				memset(ReportData, 0, sizeof(ReportData));

				CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, ReportType, ReportData, &ReportSize);
    5d96:	8e 01       	movw	r16, r28
    5d98:	0f 5f       	subi	r16, 0xFF	; 255
    5d9a:	1f 4f       	sbci	r17, 0xFF	; 255
    5d9c:	94 01       	movw	r18, r8
    5d9e:	be 01       	movw	r22, r28
    5da0:	6d 5f       	subi	r22, 0xFD	; 253
    5da2:	7f 4f       	sbci	r23, 0xFF	; 255
    5da4:	c6 01       	movw	r24, r12
    5da6:	a9 d8       	rcall	.-3758   	; 0x4efa <CALLBACK_HID_Device_CreateHIDReport>

				if (HIDInterfaceInfo->Config.PrevReportINBuffer != NULL)
    5da8:	f6 01       	movw	r30, r12
    5daa:	86 81       	ldd	r24, Z+6	; 0x06
    5dac:	97 81       	ldd	r25, Z+7	; 0x07
    5dae:	00 97       	sbiw	r24, 0x00	; 0
    5db0:	29 f0       	breq	.+10     	; 0x5dbc <HID_Device_ProcessControlRequest+0xec>
				{
					memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportData,
    5db2:	40 85       	ldd	r20, Z+8	; 0x08
    5db4:	50 e0       	ldi	r21, 0x00	; 0
    5db6:	b4 01       	movw	r22, r8
    5db8:	0e 94 df 39 	call	0x73be	; 0x73be <memcpy>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5dbc:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5dc0:	e8 ee       	ldi	r30, 0xE8	; 232
    5dc2:	f0 e0       	ldi	r31, 0x00	; 0
    5dc4:	80 81       	ld	r24, Z
    5dc6:	87 7f       	andi	r24, 0xF7	; 247
    5dc8:	80 83       	st	Z, r24

				Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

				Endpoint_ClearSETUP();

				if (ReportID)
    5dca:	8b 81       	ldd	r24, Y+3	; 0x03
    5dcc:	81 11       	cpse	r24, r1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5dce:	80 93 f1 00 	sts	0x00F1, r24
				  Endpoint_Write_8(ReportID);

				Endpoint_Write_Control_Stream_LE(ReportData, ReportSize);
    5dd2:	69 81       	ldd	r22, Y+1	; 0x01
    5dd4:	7a 81       	ldd	r23, Y+2	; 0x02
    5dd6:	c4 01       	movw	r24, r8
    5dd8:	98 d4       	rcall	.+2352   	; 0x670a <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    5dda:	e8 ee       	ldi	r30, 0xE8	; 232
    5ddc:	f0 e0       	ldi	r31, 0x00	; 0
    5dde:	80 81       	ld	r24, Z
    5de0:	8b 77       	andi	r24, 0x7B	; 123
    5de2:	80 83       	st	Z, r24
    5de4:	0f b6       	in	r0, 0x3f	; 63
    5de6:	f8 94       	cli
    5de8:	be be       	out	0x3e, r11	; 62
    5dea:	0f be       	out	0x3f, r0	; 63
    5dec:	ad be       	out	0x3d, r10	; 61
    5dee:	a1 c0       	rjmp	.+322    	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
				Endpoint_ClearOUT();
			}

			break;
		case HID_REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5df0:	80 91 4f 0a 	lds	r24, 0x0A4F
    5df4:	81 32       	cpi	r24, 0x21	; 33
    5df6:	09 f0       	breq	.+2      	; 0x5dfa <HID_Device_ProcessControlRequest+0x12a>
    5df8:	9c c0       	rjmp	.+312    	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
    5dfa:	6d b6       	in	r6, 0x3d	; 61
    5dfc:	7e b6       	in	r7, 0x3e	; 62
			{
				uint16_t ReportSize = USB_ControlRequest.wLength;
    5dfe:	ef e4       	ldi	r30, 0x4F	; 79
    5e00:	fa e0       	ldi	r31, 0x0A	; 10
    5e02:	06 81       	ldd	r16, Z+6	; 0x06
    5e04:	17 81       	ldd	r17, Z+7	; 0x07
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
    5e06:	52 80       	ldd	r5, Z+2	; 0x02
    5e08:	43 80       	ldd	r4, Z+3	; 0x03
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
				uint8_t  ReportData[ReportSize];
    5e0a:	8d b7       	in	r24, 0x3d	; 61
    5e0c:	9e b7       	in	r25, 0x3e	; 62
    5e0e:	80 1b       	sub	r24, r16
    5e10:	91 0b       	sbc	r25, r17
    5e12:	0f b6       	in	r0, 0x3f	; 63
    5e14:	f8 94       	cli
    5e16:	9e bf       	out	0x3e, r25	; 62
    5e18:	0f be       	out	0x3f, r0	; 63
    5e1a:	8d bf       	out	0x3d, r24	; 61
    5e1c:	ed b7       	in	r30, 0x3d	; 61
    5e1e:	fe b7       	in	r31, 0x3e	; 62
    5e20:	31 96       	adiw	r30, 0x01	; 1
    5e22:	4f 01       	movw	r8, r30
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5e24:	0f 2e       	mov	r0, r31
    5e26:	f8 ee       	ldi	r31, 0xE8	; 232
    5e28:	af 2e       	mov	r10, r31
    5e2a:	b1 2c       	mov	r11, r1
    5e2c:	f0 2d       	mov	r31, r0
    5e2e:	f5 01       	movw	r30, r10
    5e30:	80 81       	ld	r24, Z
    5e32:	87 7f       	andi	r24, 0xF7	; 247
    5e34:	80 83       	st	Z, r24

				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(ReportData, ReportSize);
    5e36:	b8 01       	movw	r22, r16
    5e38:	c4 01       	movw	r24, r8
    5e3a:	eb d4       	rcall	.+2518   	; 0x6812 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5e3c:	f5 01       	movw	r30, r10
    5e3e:	80 81       	ld	r24, Z
    5e40:	8e 77       	andi	r24, 0x7E	; 126
    5e42:	80 83       	st	Z, r24
				Endpoint_ClearIN();

				CALLBACK_HID_Device_ProcessHIDReport(HIDInterfaceInfo, ReportID, ReportType,
    5e44:	21 e0       	ldi	r18, 0x01	; 1
    5e46:	51 10       	cpse	r5, r1
    5e48:	01 c0       	rjmp	.+2      	; 0x5e4c <HID_Device_ProcessControlRequest+0x17c>
    5e4a:	20 e0       	ldi	r18, 0x00	; 0
    5e4c:	30 e0       	ldi	r19, 0x00	; 0
    5e4e:	02 1b       	sub	r16, r18
    5e50:	13 0b       	sbc	r17, r19
				                                     &ReportData[ReportID ? 1 : 0], ReportSize - (ReportID ? 1 : 0));
    5e52:	28 0d       	add	r18, r8
    5e54:	39 1d       	adc	r19, r9
		case HID_REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				uint16_t ReportSize = USB_ControlRequest.wLength;
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
    5e56:	4f ef       	ldi	r20, 0xFF	; 255
    5e58:	44 0d       	add	r20, r4

				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(ReportData, ReportSize);
				Endpoint_ClearIN();

				CALLBACK_HID_Device_ProcessHIDReport(HIDInterfaceInfo, ReportID, ReportType,
    5e5a:	65 2d       	mov	r22, r5
    5e5c:	c6 01       	movw	r24, r12
    5e5e:	6e d8       	rcall	.-3876   	; 0x4f3c <CALLBACK_HID_Device_ProcessHIDReport>
    5e60:	0f b6       	in	r0, 0x3f	; 63
    5e62:	f8 94       	cli
    5e64:	7e be       	out	0x3e, r7	; 62
    5e66:	0f be       	out	0x3f, r0	; 63
    5e68:	6d be       	out	0x3d, r6	; 61
    5e6a:	63 c0       	rjmp	.+198    	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
				                                     &ReportData[ReportID ? 1 : 0], ReportSize - (ReportID ? 1 : 0));
			}

			break;
		case HID_REQ_GetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    5e6c:	80 91 4f 0a 	lds	r24, 0x0A4F
    5e70:	81 3a       	cpi	r24, 0xA1	; 161
    5e72:	09 f0       	breq	.+2      	; 0x5e76 <HID_Device_ProcessControlRequest+0x1a6>
    5e74:	5e c0       	rjmp	.+188    	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5e76:	e8 ee       	ldi	r30, 0xE8	; 232
    5e78:	f0 e0       	ldi	r31, 0x00	; 0
    5e7a:	80 81       	ld	r24, Z
    5e7c:	87 7f       	andi	r24, 0xF7	; 247
    5e7e:	80 83       	st	Z, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5e80:	80 81       	ld	r24, Z
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    5e82:	80 ff       	sbrs	r24, 0
    5e84:	fd cf       	rjmp	.-6      	; 0x5e80 <HID_Device_ProcessControlRequest+0x1b0>
				Endpoint_Write_8(HIDInterfaceInfo->State.UsingReportProtocol);
    5e86:	f6 01       	movw	r30, r12
    5e88:	81 85       	ldd	r24, Z+9	; 0x09
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5e8a:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5e8e:	e8 ee       	ldi	r30, 0xE8	; 232
    5e90:	f0 e0       	ldi	r31, 0x00	; 0
    5e92:	80 81       	ld	r24, Z
    5e94:	8e 77       	andi	r24, 0x7E	; 126
    5e96:	80 83       	st	Z, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    5e98:	84 d6       	rcall	.+3336   	; 0x6ba2 <Endpoint_ClearStatusStage>
    5e9a:	4b c0       	rjmp	.+150    	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
			}

			break;
		case HID_REQ_SetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5e9c:	80 91 4f 0a 	lds	r24, 0x0A4F
    5ea0:	81 32       	cpi	r24, 0x21	; 33
    5ea2:	09 f0       	breq	.+2      	; 0x5ea6 <HID_Device_ProcessControlRequest+0x1d6>
    5ea4:	46 c0       	rjmp	.+140    	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5ea6:	e8 ee       	ldi	r30, 0xE8	; 232
    5ea8:	f0 e0       	ldi	r31, 0x00	; 0
    5eaa:	80 81       	ld	r24, Z
    5eac:	87 7f       	andi	r24, 0xF7	; 247
    5eae:	80 83       	st	Z, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    5eb0:	78 d6       	rcall	.+3312   	; 0x6ba2 <Endpoint_ClearStatusStage>

				HIDInterfaceInfo->State.UsingReportProtocol = ((USB_ControlRequest.wValue & 0xFF) != 0x00);
    5eb2:	90 91 51 0a 	lds	r25, 0x0A51
    5eb6:	81 e0       	ldi	r24, 0x01	; 1
    5eb8:	91 11       	cpse	r25, r1
    5eba:	01 c0       	rjmp	.+2      	; 0x5ebe <HID_Device_ProcessControlRequest+0x1ee>
    5ebc:	80 e0       	ldi	r24, 0x00	; 0
    5ebe:	f6 01       	movw	r30, r12
    5ec0:	81 87       	std	Z+9, r24	; 0x09
    5ec2:	37 c0       	rjmp	.+110    	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
			}

			break;
		case HID_REQ_SetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5ec4:	80 91 4f 0a 	lds	r24, 0x0A4F
    5ec8:	81 32       	cpi	r24, 0x21	; 33
    5eca:	99 f5       	brne	.+102    	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
    5ecc:	e8 ee       	ldi	r30, 0xE8	; 232
    5ece:	f0 e0       	ldi	r31, 0x00	; 0
    5ed0:	80 81       	ld	r24, Z
    5ed2:	87 7f       	andi	r24, 0xF7	; 247
    5ed4:	80 83       	st	Z, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    5ed6:	65 d6       	rcall	.+3274   	; 0x6ba2 <Endpoint_ClearStatusStage>

				HIDInterfaceInfo->State.IdleCount = ((USB_ControlRequest.wValue & 0xFF00) >> 6);
    5ed8:	80 91 51 0a 	lds	r24, 0x0A51
    5edc:	90 91 52 0a 	lds	r25, 0x0A52
    5ee0:	88 27       	eor	r24, r24
    5ee2:	00 24       	eor	r0, r0
    5ee4:	88 0f       	add	r24, r24
    5ee6:	99 1f       	adc	r25, r25
    5ee8:	00 1c       	adc	r0, r0
    5eea:	88 0f       	add	r24, r24
    5eec:	99 1f       	adc	r25, r25
    5eee:	00 1c       	adc	r0, r0
    5ef0:	89 2f       	mov	r24, r25
    5ef2:	90 2d       	mov	r25, r0
    5ef4:	f6 01       	movw	r30, r12
    5ef6:	95 87       	std	Z+13, r25	; 0x0d
    5ef8:	84 87       	std	Z+12, r24	; 0x0c
    5efa:	1b c0       	rjmp	.+54     	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
			}

			break;
		case HID_REQ_GetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    5efc:	80 91 4f 0a 	lds	r24, 0x0A4F
    5f00:	81 3a       	cpi	r24, 0xA1	; 161
    5f02:	b9 f4       	brne	.+46     	; 0x5f32 <HID_Device_ProcessControlRequest+0x262>
    5f04:	e8 ee       	ldi	r30, 0xE8	; 232
    5f06:	f0 e0       	ldi	r31, 0x00	; 0
    5f08:	80 81       	ld	r24, Z
    5f0a:	87 7f       	andi	r24, 0xF7	; 247
    5f0c:	80 83       	st	Z, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5f0e:	80 81       	ld	r24, Z
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    5f10:	80 ff       	sbrs	r24, 0
    5f12:	fd cf       	rjmp	.-6      	; 0x5f0e <HID_Device_ProcessControlRequest+0x23e>
				Endpoint_Write_8(HIDInterfaceInfo->State.IdleCount >> 2);
    5f14:	f6 01       	movw	r30, r12
    5f16:	84 85       	ldd	r24, Z+12	; 0x0c
    5f18:	95 85       	ldd	r25, Z+13	; 0x0d
    5f1a:	96 95       	lsr	r25
    5f1c:	87 95       	ror	r24
    5f1e:	96 95       	lsr	r25
    5f20:	87 95       	ror	r24
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5f22:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5f26:	e8 ee       	ldi	r30, 0xE8	; 232
    5f28:	f0 e0       	ldi	r31, 0x00	; 0
    5f2a:	80 81       	ld	r24, Z
    5f2c:	8e 77       	andi	r24, 0x7E	; 126
    5f2e:	80 83       	st	Z, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    5f30:	38 d6       	rcall	.+3184   	; 0x6ba2 <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    5f32:	0f b6       	in	r0, 0x3f	; 63
    5f34:	f8 94       	cli
    5f36:	fe be       	out	0x3e, r15	; 62
    5f38:	0f be       	out	0x3f, r0	; 63
    5f3a:	ed be       	out	0x3d, r14	; 61
    5f3c:	0f 90       	pop	r0
    5f3e:	0f 90       	pop	r0
    5f40:	0f 90       	pop	r0
    5f42:	df 91       	pop	r29
    5f44:	cf 91       	pop	r28
    5f46:	1f 91       	pop	r17
    5f48:	0f 91       	pop	r16
    5f4a:	ff 90       	pop	r15
    5f4c:	ef 90       	pop	r14
    5f4e:	df 90       	pop	r13
    5f50:	cf 90       	pop	r12
    5f52:	bf 90       	pop	r11
    5f54:	af 90       	pop	r10
    5f56:	9f 90       	pop	r9
    5f58:	8f 90       	pop	r8
    5f5a:	7f 90       	pop	r7
    5f5c:	6f 90       	pop	r6
    5f5e:	5f 90       	pop	r5
    5f60:	4f 90       	pop	r4
    5f62:	3f 90       	pop	r3
    5f64:	08 95       	ret

00005f66 <HID_Device_ConfigureEndpoints>:

bool HID_Device_ConfigureEndpoints(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	memset(&HIDInterfaceInfo->State, 0x00, sizeof(HIDInterfaceInfo->State));
    5f66:	fc 01       	movw	r30, r24
    5f68:	39 96       	adiw	r30, 0x09	; 9
    5f6a:	27 e0       	ldi	r18, 0x07	; 7
    5f6c:	df 01       	movw	r26, r30
    5f6e:	1d 92       	st	X+, r1
    5f70:	2a 95       	dec	r18
    5f72:	e9 f7       	brne	.-6      	; 0x5f6e <HID_Device_ConfigureEndpoints+0x8>
	HIDInterfaceInfo->State.UsingReportProtocol = true;
    5f74:	21 e0       	ldi	r18, 0x01	; 1
    5f76:	fc 01       	movw	r30, r24
    5f78:	21 87       	std	Z+9, r18	; 0x09
	HIDInterfaceInfo->State.IdleCount           = 500;
    5f7a:	24 ef       	ldi	r18, 0xF4	; 244
    5f7c:	31 e0       	ldi	r19, 0x01	; 1
    5f7e:	35 87       	std	Z+13, r19	; 0x0d
    5f80:	24 87       	std	Z+12, r18	; 0x0c

	HIDInterfaceInfo->Config.ReportINEndpoint.Type = EP_TYPE_INTERRUPT;
    5f82:	23 e0       	ldi	r18, 0x03	; 3
    5f84:	24 83       	std	Z+4, r18	; 0x04

	if (!(Endpoint_ConfigureEndpointTable(&HIDInterfaceInfo->Config.ReportINEndpoint, 1)))
    5f86:	61 e0       	ldi	r22, 0x01	; 1
    5f88:	01 96       	adiw	r24, 0x01	; 1
    5f8a:	a5 c5       	rjmp	.+2890   	; 0x6ad6 <Endpoint_ConfigureEndpointTable>
	  return false;

	return true;
}
    5f8c:	08 95       	ret

00005f8e <HID_Device_USBTask>:

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
    5f8e:	5f 92       	push	r5
    5f90:	6f 92       	push	r6
    5f92:	7f 92       	push	r7
    5f94:	8f 92       	push	r8
    5f96:	9f 92       	push	r9
    5f98:	af 92       	push	r10
    5f9a:	bf 92       	push	r11
    5f9c:	cf 92       	push	r12
    5f9e:	df 92       	push	r13
    5fa0:	ef 92       	push	r14
    5fa2:	ff 92       	push	r15
    5fa4:	0f 93       	push	r16
    5fa6:	1f 93       	push	r17
    5fa8:	cf 93       	push	r28
    5faa:	df 93       	push	r29
    5fac:	00 d0       	rcall	.+0      	; 0x5fae <HID_Device_USBTask+0x20>
    5fae:	1f 92       	push	r1
    5fb0:	cd b7       	in	r28, 0x3d	; 61
    5fb2:	de b7       	in	r29, 0x3e	; 62
    5fb4:	7c 01       	movw	r14, r24
			Endpoint_ClearIN();
		}

		HIDInterfaceInfo->State.PrevFrameNum = USB_Device_GetFrameNumber();
	}
}
    5fb6:	ad b6       	in	r10, 0x3d	; 61
    5fb8:	be b6       	in	r11, 0x3e	; 62
	return true;
}

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	if (USB_DeviceState != DEVICE_STATE_Configured)
    5fba:	80 91 4e 0a 	lds	r24, 0x0A4E
    5fbe:	84 30       	cpi	r24, 0x04	; 4
    5fc0:	09 f0       	breq	.+2      	; 0x5fc4 <HID_Device_USBTask+0x36>
    5fc2:	8e c0       	rjmp	.+284    	; 0x60e0 <HID_Device_USBTask+0x152>
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    5fc4:	80 91 e4 00 	lds	r24, 0x00E4
    5fc8:	90 91 e5 00 	lds	r25, 0x00E5
	  return;

	if (HIDInterfaceInfo->State.PrevFrameNum == USB_Device_GetFrameNumber())
    5fcc:	f7 01       	movw	r30, r14
    5fce:	22 85       	ldd	r18, Z+10	; 0x0a
    5fd0:	33 85       	ldd	r19, Z+11	; 0x0b
    5fd2:	28 17       	cp	r18, r24
    5fd4:	39 07       	cpc	r19, r25
    5fd6:	09 f4       	brne	.+2      	; 0x5fda <HID_Device_USBTask+0x4c>
    5fd8:	83 c0       	rjmp	.+262    	; 0x60e0 <HID_Device_USBTask+0x152>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5fda:	81 81       	ldd	r24, Z+1	; 0x01
    5fdc:	8f 70       	andi	r24, 0x0F	; 15
    5fde:	80 93 e9 00 	sts	0x00E9, r24
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    5fe2:	80 91 e8 00 	lds	r24, 0x00E8
		#endif
	}

	Endpoint_SelectEndpoint(HIDInterfaceInfo->Config.ReportINEndpoint.Address);

	if (Endpoint_IsReadWriteAllowed())
    5fe6:	85 ff       	sbrs	r24, 5
    5fe8:	7b c0       	rjmp	.+246    	; 0x60e0 <HID_Device_USBTask+0x152>
    5fea:	8d b6       	in	r8, 0x3d	; 61
    5fec:	9e b6       	in	r9, 0x3e	; 62
	{
		uint8_t  ReportINData[HIDInterfaceInfo->Config.PrevReportINBufferSize];
    5fee:	40 85       	ldd	r20, Z+8	; 0x08
    5ff0:	50 e0       	ldi	r21, 0x00	; 0
    5ff2:	8d b7       	in	r24, 0x3d	; 61
    5ff4:	9e b7       	in	r25, 0x3e	; 62
    5ff6:	84 1b       	sub	r24, r20
    5ff8:	95 0b       	sbc	r25, r21
    5ffa:	0f b6       	in	r0, 0x3f	; 63
    5ffc:	f8 94       	cli
    5ffe:	9e bf       	out	0x3e, r25	; 62
    6000:	0f be       	out	0x3f, r0	; 63
    6002:	8d bf       	out	0x3d, r24	; 61
    6004:	ed b7       	in	r30, 0x3d	; 61
    6006:	fe b7       	in	r31, 0x3e	; 62
    6008:	31 96       	adiw	r30, 0x01	; 1
    600a:	6f 01       	movw	r12, r30
		uint8_t  ReportID     = 0;
    600c:	1b 82       	std	Y+3, r1	; 0x03
		uint16_t ReportINSize = 0;
    600e:	1a 82       	std	Y+2, r1	; 0x02
    6010:	19 82       	std	Y+1, r1	; 0x01

		memset(ReportINData, 0, sizeof(ReportINData));
    6012:	60 e0       	ldi	r22, 0x00	; 0
    6014:	70 e0       	ldi	r23, 0x00	; 0
    6016:	cf 01       	movw	r24, r30
    6018:	0e 94 e8 39 	call	0x73d0	; 0x73d0 <memset>

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
    601c:	8e 01       	movw	r16, r28
    601e:	0f 5f       	subi	r16, 0xFF	; 255
    6020:	1f 4f       	sbci	r17, 0xFF	; 255
    6022:	96 01       	movw	r18, r12
    6024:	40 e0       	ldi	r20, 0x00	; 0
    6026:	be 01       	movw	r22, r28
    6028:	6d 5f       	subi	r22, 0xFD	; 253
    602a:	7f 4f       	sbci	r23, 0xFF	; 255
    602c:	c7 01       	movw	r24, r14
    602e:	0e 94 7d 27 	call	0x4efa	; 0x4efa <CALLBACK_HID_Device_CreateHIDReport>
    6032:	58 2e       	mov	r5, r24
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
		bool IdlePeriodElapsed = (HIDInterfaceInfo->State.IdleCount && !(HIDInterfaceInfo->State.IdleMSRemaining));
    6034:	f7 01       	movw	r30, r14
    6036:	84 85       	ldd	r24, Z+12	; 0x0c
    6038:	95 85       	ldd	r25, Z+13	; 0x0d
    603a:	89 2b       	or	r24, r25
    603c:	41 f0       	breq	.+16     	; 0x604e <HID_Device_USBTask+0xc0>
    603e:	81 e0       	ldi	r24, 0x01	; 1
    6040:	26 85       	ldd	r18, Z+14	; 0x0e
    6042:	37 85       	ldd	r19, Z+15	; 0x0f
    6044:	23 2b       	or	r18, r19
    6046:	09 f0       	breq	.+2      	; 0x604a <HID_Device_USBTask+0xbc>
    6048:	80 e0       	ldi	r24, 0x00	; 0
    604a:	78 2e       	mov	r7, r24
    604c:	01 c0       	rjmp	.+2      	; 0x6050 <HID_Device_USBTask+0xc2>
    604e:	71 2c       	mov	r7, r1

		if (HIDInterfaceInfo->Config.PrevReportINBuffer != NULL)
    6050:	f7 01       	movw	r30, r14
    6052:	06 81       	ldd	r16, Z+6	; 0x06
    6054:	17 81       	ldd	r17, Z+7	; 0x07
    6056:	01 15       	cp	r16, r1
    6058:	11 05       	cpc	r17, r1
    605a:	99 f0       	breq	.+38     	; 0x6082 <HID_Device_USBTask+0xf4>
		{
			StatesChanged = (memcmp(ReportINData, HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINSize) != 0);
    605c:	49 81       	ldd	r20, Y+1	; 0x01
    605e:	5a 81       	ldd	r21, Y+2	; 0x02
    6060:	b8 01       	movw	r22, r16
    6062:	c6 01       	movw	r24, r12
    6064:	0e 94 d2 39 	call	0x73a4	; 0x73a4 <memcmp>
    6068:	66 24       	eor	r6, r6
    606a:	63 94       	inc	r6
    606c:	89 2b       	or	r24, r25
    606e:	09 f4       	brne	.+2      	; 0x6072 <HID_Device_USBTask+0xe4>
    6070:	61 2c       	mov	r6, r1
			memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINData, HIDInterfaceInfo->Config.PrevReportINBufferSize);
    6072:	f7 01       	movw	r30, r14
    6074:	40 85       	ldd	r20, Z+8	; 0x08
    6076:	50 e0       	ldi	r21, 0x00	; 0
    6078:	b6 01       	movw	r22, r12
    607a:	c8 01       	movw	r24, r16
    607c:	0e 94 df 39 	call	0x73be	; 0x73be <memcpy>
    6080:	01 c0       	rjmp	.+2      	; 0x6084 <HID_Device_USBTask+0xf6>

		memset(ReportINData, 0, sizeof(ReportINData));

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
    6082:	61 2c       	mov	r6, r1
		{
			StatesChanged = (memcmp(ReportINData, HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINSize) != 0);
			memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINData, HIDInterfaceInfo->Config.PrevReportINBufferSize);
		}

		if (ReportINSize && (ForceSend || StatesChanged || IdlePeriodElapsed))
    6084:	89 81       	ldd	r24, Y+1	; 0x01
    6086:	9a 81       	ldd	r25, Y+2	; 0x02
    6088:	89 2b       	or	r24, r25
    608a:	f1 f0       	breq	.+60     	; 0x60c8 <HID_Device_USBTask+0x13a>
    608c:	51 10       	cpse	r5, r1
    608e:	04 c0       	rjmp	.+8      	; 0x6098 <HID_Device_USBTask+0x10a>
    6090:	61 10       	cpse	r6, r1
    6092:	02 c0       	rjmp	.+4      	; 0x6098 <HID_Device_USBTask+0x10a>
    6094:	70 fe       	sbrs	r7, 0
    6096:	18 c0       	rjmp	.+48     	; 0x60c8 <HID_Device_USBTask+0x13a>
		{
			HIDInterfaceInfo->State.IdleMSRemaining = HIDInterfaceInfo->State.IdleCount;
    6098:	f7 01       	movw	r30, r14
    609a:	84 85       	ldd	r24, Z+12	; 0x0c
    609c:	95 85       	ldd	r25, Z+13	; 0x0d
    609e:	97 87       	std	Z+15, r25	; 0x0f
    60a0:	86 87       	std	Z+14, r24	; 0x0e
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    60a2:	81 81       	ldd	r24, Z+1	; 0x01
    60a4:	8f 70       	andi	r24, 0x0F	; 15
    60a6:	80 93 e9 00 	sts	0x00E9, r24

			Endpoint_SelectEndpoint(HIDInterfaceInfo->Config.ReportINEndpoint.Address);

			if (ReportID)
    60aa:	8b 81       	ldd	r24, Y+3	; 0x03
    60ac:	81 11       	cpse	r24, r1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    60ae:	80 93 f1 00 	sts	0x00F1, r24
			  Endpoint_Write_8(ReportID);

			Endpoint_Write_Stream_LE(ReportINData, ReportINSize, NULL);
    60b2:	69 81       	ldd	r22, Y+1	; 0x01
    60b4:	7a 81       	ldd	r23, Y+2	; 0x02
    60b6:	40 e0       	ldi	r20, 0x00	; 0
    60b8:	50 e0       	ldi	r21, 0x00	; 0
    60ba:	c6 01       	movw	r24, r12
    60bc:	0a d2       	rcall	.+1044   	; 0x64d2 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    60be:	e8 ee       	ldi	r30, 0xE8	; 232
    60c0:	f0 e0       	ldi	r31, 0x00	; 0
    60c2:	80 81       	ld	r24, Z
    60c4:	8e 77       	andi	r24, 0x7E	; 126
    60c6:	80 83       	st	Z, r24
    60c8:	80 91 e4 00 	lds	r24, 0x00E4
    60cc:	90 91 e5 00 	lds	r25, 0x00E5

			Endpoint_ClearIN();
		}

		HIDInterfaceInfo->State.PrevFrameNum = USB_Device_GetFrameNumber();
    60d0:	f7 01       	movw	r30, r14
    60d2:	93 87       	std	Z+11, r25	; 0x0b
    60d4:	82 87       	std	Z+10, r24	; 0x0a
    60d6:	0f b6       	in	r0, 0x3f	; 63
    60d8:	f8 94       	cli
    60da:	9e be       	out	0x3e, r9	; 62
    60dc:	0f be       	out	0x3f, r0	; 63
    60de:	8d be       	out	0x3d, r8	; 61
	}
}
    60e0:	0f b6       	in	r0, 0x3f	; 63
    60e2:	f8 94       	cli
    60e4:	be be       	out	0x3e, r11	; 62
    60e6:	0f be       	out	0x3f, r0	; 63
    60e8:	ad be       	out	0x3d, r10	; 61
    60ea:	0f 90       	pop	r0
    60ec:	0f 90       	pop	r0
    60ee:	0f 90       	pop	r0
    60f0:	df 91       	pop	r29
    60f2:	cf 91       	pop	r28
    60f4:	1f 91       	pop	r17
    60f6:	0f 91       	pop	r16
    60f8:	ff 90       	pop	r15
    60fa:	ef 90       	pop	r14
    60fc:	df 90       	pop	r13
    60fe:	cf 90       	pop	r12
    6100:	bf 90       	pop	r11
    6102:	af 90       	pop	r10
    6104:	9f 90       	pop	r9
    6106:	8f 90       	pop	r8
    6108:	7f 90       	pop	r7
    610a:	6f 90       	pop	r6
    610c:	5f 90       	pop	r5
    610e:	08 95       	ret

00006110 <MS_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_MS_DRIVER
#define  __INCLUDE_FROM_MASSSTORAGE_DEVICE_C
#include "MassStorageClassDevice.h"

void MS_Device_ProcessControlRequest(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    6110:	cf 93       	push	r28
    6112:	df 93       	push	r29
    6114:	fc 01       	movw	r30, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6116:	90 91 e8 00 	lds	r25, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    611a:	93 ff       	sbrs	r25, 3
    611c:	33 c0       	rjmp	.+102    	; 0x6184 <MS_Device_ProcessControlRequest+0x74>
	  return;

	if (USB_ControlRequest.wIndex != MSInterfaceInfo->Config.InterfaceNumber)
    611e:	20 81       	ld	r18, Z
    6120:	30 e0       	ldi	r19, 0x00	; 0
    6122:	80 91 53 0a 	lds	r24, 0x0A53
    6126:	90 91 54 0a 	lds	r25, 0x0A54
    612a:	82 17       	cp	r24, r18
    612c:	93 07       	cpc	r25, r19
    612e:	51 f5       	brne	.+84     	; 0x6184 <MS_Device_ProcessControlRequest+0x74>
    6130:	ef 01       	movw	r28, r30
	  return;

	switch (USB_ControlRequest.bRequest)
    6132:	80 91 50 0a 	lds	r24, 0x0A50
    6136:	8e 3f       	cpi	r24, 0xFE	; 254
    6138:	79 f0       	breq	.+30     	; 0x6158 <MS_Device_ProcessControlRequest+0x48>
    613a:	8f 3f       	cpi	r24, 0xFF	; 255
    613c:	19 f5       	brne	.+70     	; 0x6184 <MS_Device_ProcessControlRequest+0x74>
	{
		case MS_REQ_MassStorageReset:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    613e:	80 91 4f 0a 	lds	r24, 0x0A4F
    6142:	81 32       	cpi	r24, 0x21	; 33
    6144:	f9 f4       	brne	.+62     	; 0x6184 <MS_Device_ProcessControlRequest+0x74>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6146:	e8 ee       	ldi	r30, 0xE8	; 232
    6148:	f0 e0       	ldi	r31, 0x00	; 0
    614a:	80 81       	ld	r24, Z
    614c:	87 7f       	andi	r24, 0xF7	; 247
    614e:	80 83       	st	Z, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    6150:	28 d5       	rcall	.+2640   	; 0x6ba2 <Endpoint_ClearStatusStage>

				MSInterfaceInfo->State.IsMassStoreReset = true;
    6152:	81 e0       	ldi	r24, 0x01	; 1
    6154:	88 af       	std	Y+56, r24	; 0x38
    6156:	16 c0       	rjmp	.+44     	; 0x6184 <MS_Device_ProcessControlRequest+0x74>
			}

			break;
		case MS_REQ_GetMaxLUN:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    6158:	80 91 4f 0a 	lds	r24, 0x0A4F
    615c:	81 3a       	cpi	r24, 0xA1	; 161
    615e:	91 f4       	brne	.+36     	; 0x6184 <MS_Device_ProcessControlRequest+0x74>
    6160:	e8 ee       	ldi	r30, 0xE8	; 232
    6162:	f0 e0       	ldi	r31, 0x00	; 0
    6164:	80 81       	ld	r24, Z
    6166:	87 7f       	andi	r24, 0xF7	; 247
    6168:	80 83       	st	Z, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    616a:	80 81       	ld	r24, Z
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    616c:	80 ff       	sbrs	r24, 0
    616e:	fd cf       	rjmp	.-6      	; 0x616a <MS_Device_ProcessControlRequest+0x5a>
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
    6170:	8b 85       	ldd	r24, Y+11	; 0x0b
    6172:	81 50       	subi	r24, 0x01	; 1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    6174:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6178:	e8 ee       	ldi	r30, 0xE8	; 232
    617a:	f0 e0       	ldi	r31, 0x00	; 0
    617c:	80 81       	ld	r24, Z
    617e:	8e 77       	andi	r24, 0x7E	; 126
    6180:	80 83       	st	Z, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    6182:	0f d5       	rcall	.+2590   	; 0x6ba2 <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    6184:	df 91       	pop	r29
    6186:	cf 91       	pop	r28
    6188:	08 95       	ret

0000618a <MS_Device_ConfigureEndpoints>:

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    618a:	cf 93       	push	r28
    618c:	df 93       	push	r29
    618e:	ec 01       	movw	r28, r24
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));
    6190:	fc 01       	movw	r30, r24
    6192:	3c 96       	adiw	r30, 0x0c	; 12
    6194:	8d e2       	ldi	r24, 0x2D	; 45
    6196:	df 01       	movw	r26, r30
    6198:	1d 92       	st	X+, r1
    619a:	8a 95       	dec	r24
    619c:	e9 f7       	brne	.-6      	; 0x6198 <MS_Device_ConfigureEndpoints+0xe>

	MSInterfaceInfo->Config.DataINEndpoint.Type  = EP_TYPE_BULK;
    619e:	82 e0       	ldi	r24, 0x02	; 2
    61a0:	8c 83       	std	Y+4, r24	; 0x04
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;
    61a2:	89 87       	std	Y+9, r24	; 0x09

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
    61a4:	61 e0       	ldi	r22, 0x01	; 1
    61a6:	ce 01       	movw	r24, r28
    61a8:	01 96       	adiw	r24, 0x01	; 1
    61aa:	95 d4       	rcall	.+2346   	; 0x6ad6 <Endpoint_ConfigureEndpointTable>
    61ac:	88 23       	and	r24, r24
    61ae:	21 f0       	breq	.+8      	; 0x61b8 <MS_Device_ConfigureEndpoints+0x2e>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
    61b0:	61 e0       	ldi	r22, 0x01	; 1
    61b2:	ce 01       	movw	r24, r28
    61b4:	06 96       	adiw	r24, 0x06	; 6
    61b6:	8f d4       	rcall	.+2334   	; 0x6ad6 <Endpoint_ConfigureEndpointTable>
	  return false;

	return true;
}
    61b8:	df 91       	pop	r29
    61ba:	cf 91       	pop	r28
    61bc:	08 95       	ret

000061be <MS_Device_USBTask>:

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    61be:	ef 92       	push	r14
    61c0:	ff 92       	push	r15
    61c2:	0f 93       	push	r16
    61c4:	1f 93       	push	r17
    61c6:	cf 93       	push	r28
    61c8:	df 93       	push	r29
    61ca:	00 d0       	rcall	.+0      	; 0x61cc <MS_Device_USBTask+0xe>
    61cc:	cd b7       	in	r28, 0x3d	; 61
    61ce:	de b7       	in	r29, 0x3e	; 62
    61d0:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    61d2:	90 91 4e 0a 	lds	r25, 0x0A4E
    61d6:	94 30       	cpi	r25, 0x04	; 4
    61d8:	09 f0       	breq	.+2      	; 0x61dc <MS_Device_USBTask+0x1e>
    61da:	23 c1       	rjmp	.+582    	; 0x6422 <MS_Device_USBTask+0x264>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    61dc:	d8 01       	movw	r26, r16
    61de:	16 96       	adiw	r26, 0x06	; 6
    61e0:	8c 91       	ld	r24, X
    61e2:	16 97       	sbiw	r26, 0x06	; 6
    61e4:	8f 70       	andi	r24, 0x0F	; 15
    61e6:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    61ea:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	if (Endpoint_IsOUTReceived())
    61ee:	82 ff       	sbrs	r24, 2
    61f0:	dd c0       	rjmp	.+442    	; 0x63ac <MS_Device_USBTask+0x1ee>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    61f2:	16 96       	adiw	r26, 0x06	; 6
    61f4:	8c 91       	ld	r24, X
    61f6:	8f 70       	andi	r24, 0x0F	; 15
    61f8:	80 93 e9 00 	sts	0x00E9, r24
{
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	BytesProcessed = 0;
    61fc:	1a 82       	std	Y+2, r1	; 0x02
    61fe:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    6200:	78 01       	movw	r14, r16
    6202:	bc e0       	ldi	r27, 0x0C	; 12
    6204:	eb 0e       	add	r14, r27
    6206:	f1 1c       	adc	r15, r1
    6208:	04 c0       	rjmp	.+8      	; 0x6212 <MS_Device_USBTask+0x54>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    620a:	f8 01       	movw	r30, r16
    620c:	90 ad       	ldd	r25, Z+56	; 0x38
    620e:	91 11       	cpse	r25, r1
    6210:	cd c0       	rjmp	.+410    	; 0x63ac <MS_Device_USBTask+0x1ee>
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    6212:	ae 01       	movw	r20, r28
    6214:	4f 5f       	subi	r20, 0xFF	; 255
    6216:	5f 4f       	sbci	r21, 0xFF	; 255
    6218:	6f e0       	ldi	r22, 0x0F	; 15
    621a:	70 e0       	ldi	r23, 0x00	; 0
    621c:	c7 01       	movw	r24, r14
    621e:	18 d2       	rcall	.+1072   	; 0x6650 <Endpoint_Read_Stream_LE>
    6220:	85 30       	cpi	r24, 0x05	; 5
    6222:	99 f3       	breq	.-26     	; 0x620a <MS_Device_USBTask+0x4c>
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
    6224:	f8 01       	movw	r30, r16
    6226:	84 85       	ldd	r24, Z+12	; 0x0c
    6228:	95 85       	ldd	r25, Z+13	; 0x0d
    622a:	a6 85       	ldd	r26, Z+14	; 0x0e
    622c:	b7 85       	ldd	r27, Z+15	; 0x0f
    622e:	85 35       	cpi	r24, 0x55	; 85
    6230:	93 45       	sbci	r25, 0x53	; 83
    6232:	a2 44       	sbci	r26, 0x42	; 66
    6234:	b3 44       	sbci	r27, 0x43	; 67
    6236:	99 f4       	brne	.+38     	; 0x625e <MS_Device_USBTask+0xa0>
    6238:	d8 01       	movw	r26, r16
    623a:	59 96       	adiw	r26, 0x19	; 25
    623c:	9c 91       	ld	r25, X
    623e:	59 97       	sbiw	r26, 0x19	; 25
    6240:	1b 96       	adiw	r26, 0x0b	; 11
    6242:	8c 91       	ld	r24, X
    6244:	1b 97       	sbiw	r26, 0x0b	; 11
    6246:	98 17       	cp	r25, r24
    6248:	50 f4       	brcc	.+20     	; 0x625e <MS_Device_USBTask+0xa0>
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    624a:	58 96       	adiw	r26, 0x18	; 24
    624c:	8c 91       	ld	r24, X
    624e:	58 97       	sbiw	r26, 0x18	; 24
    6250:	8f 71       	andi	r24, 0x1F	; 31
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
    6252:	29 f4       	brne	.+10     	; 0x625e <MS_Device_USBTask+0xa0>
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    6254:	5a 96       	adiw	r26, 0x1a	; 26
    6256:	8c 91       	ld	r24, X
    6258:	81 50       	subi	r24, 0x01	; 1
    625a:	80 31       	cpi	r24, 0x10	; 16
    625c:	78 f0       	brcs	.+30     	; 0x627c <MS_Device_USBTask+0xbe>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    625e:	eb ee       	ldi	r30, 0xEB	; 235
    6260:	f0 e0       	ldi	r31, 0x00	; 0
    6262:	80 81       	ld	r24, Z
    6264:	80 62       	ori	r24, 0x20	; 32
    6266:	80 83       	st	Z, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6268:	d8 01       	movw	r26, r16
    626a:	11 96       	adiw	r26, 0x01	; 1
    626c:	8c 91       	ld	r24, X
    626e:	8f 70       	andi	r24, 0x0F	; 15
    6270:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6274:	80 81       	ld	r24, Z
    6276:	80 62       	ori	r24, 0x20	; 32
    6278:	80 83       	st	Z, r24
    627a:	98 c0       	rjmp	.+304    	; 0x63ac <MS_Device_USBTask+0x1ee>
		Endpoint_StallTransaction();

		return false;
	}

	BytesProcessed = 0;
    627c:	1a 82       	std	Y+2, r1	; 0x02
    627e:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    6280:	78 01       	movw	r14, r16
    6282:	bb e1       	ldi	r27, 0x1B	; 27
    6284:	eb 0e       	add	r14, r27
    6286:	f1 1c       	adc	r15, r1
    6288:	04 c0       	rjmp	.+8      	; 0x6292 <MS_Device_USBTask+0xd4>
	                                MSInterfaceInfo->State.CommandBlock.SCSICommandLength, &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    628a:	f8 01       	movw	r30, r16
    628c:	90 ad       	ldd	r25, Z+56	; 0x38
    628e:	91 11       	cpse	r25, r1
    6290:	8d c0       	rjmp	.+282    	; 0x63ac <MS_Device_USBTask+0x1ee>

		return false;
	}

	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    6292:	d8 01       	movw	r26, r16
    6294:	5a 96       	adiw	r26, 0x1a	; 26
    6296:	6c 91       	ld	r22, X
    6298:	70 e0       	ldi	r23, 0x00	; 0
    629a:	ae 01       	movw	r20, r28
    629c:	4f 5f       	subi	r20, 0xFF	; 255
    629e:	5f 4f       	sbci	r21, 0xFF	; 255
    62a0:	c7 01       	movw	r24, r14
    62a2:	d6 d1       	rcall	.+940    	; 0x6650 <Endpoint_Read_Stream_LE>
    62a4:	85 30       	cpi	r24, 0x05	; 5
    62a6:	89 f3       	breq	.-30     	; 0x628a <MS_Device_USBTask+0xcc>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    62a8:	e8 ee       	ldi	r30, 0xE8	; 232
    62aa:	f0 e0       	ldi	r31, 0x00	; 0
    62ac:	80 81       	ld	r24, Z
    62ae:	8b 77       	andi	r24, 0x7B	; 123
    62b0:	80 83       	st	Z, r24

	if (Endpoint_IsOUTReceived())
	{
		if (MS_Device_ReadInCommandBlock(MSInterfaceInfo))
		{
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
    62b2:	f8 01       	movw	r30, r16
    62b4:	80 8d       	ldd	r24, Z+24	; 0x18
    62b6:	88 23       	and	r24, r24
    62b8:	24 f4       	brge	.+8      	; 0x62c2 <MS_Device_USBTask+0x104>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    62ba:	81 81       	ldd	r24, Z+1	; 0x01
    62bc:	8f 70       	andi	r24, 0x0F	; 15
    62be:	80 93 e9 00 	sts	0x00E9, r24
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

			bool SCSICommandResult = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo);
    62c2:	c8 01       	movw	r24, r16
    62c4:	0e 94 7b 27 	call	0x4ef6	; 0x4ef6 <CALLBACK_MS_Device_SCSICommandReceived>

			MSInterfaceInfo->State.CommandStatus.Status              = (SCSICommandResult) ? MS_SCSI_COMMAND_Pass : MS_SCSI_COMMAND_Fail;
    62c8:	91 e0       	ldi	r25, 0x01	; 1
    62ca:	98 27       	eor	r25, r24
    62cc:	d8 01       	movw	r26, r16
    62ce:	d7 96       	adiw	r26, 0x37	; 55
    62d0:	9c 93       	st	X, r25
    62d2:	d7 97       	sbiw	r26, 0x37	; 55
			MSInterfaceInfo->State.CommandStatus.Signature           = CPU_TO_LE32(MS_CSW_SIGNATURE);
    62d4:	45 e5       	ldi	r20, 0x55	; 85
    62d6:	53 e5       	ldi	r21, 0x53	; 83
    62d8:	62 e4       	ldi	r22, 0x42	; 66
    62da:	73 e5       	ldi	r23, 0x53	; 83
    62dc:	f8 01       	movw	r30, r16
    62de:	43 a7       	std	Z+43, r20	; 0x2b
    62e0:	54 a7       	std	Z+44, r21	; 0x2c
    62e2:	65 a7       	std	Z+45, r22	; 0x2d
    62e4:	76 a7       	std	Z+46, r23	; 0x2e
			MSInterfaceInfo->State.CommandStatus.Tag                 = MSInterfaceInfo->State.CommandBlock.Tag;
    62e6:	40 89       	ldd	r20, Z+16	; 0x10
    62e8:	51 89       	ldd	r21, Z+17	; 0x11
    62ea:	62 89       	ldd	r22, Z+18	; 0x12
    62ec:	73 89       	ldd	r23, Z+19	; 0x13
    62ee:	9f 96       	adiw	r26, 0x2f	; 47
    62f0:	4d 93       	st	X+, r20
    62f2:	5d 93       	st	X+, r21
    62f4:	6d 93       	st	X+, r22
    62f6:	7c 93       	st	X, r23
    62f8:	d2 97       	sbiw	r26, 0x32	; 50
			MSInterfaceInfo->State.CommandStatus.DataTransferResidue = MSInterfaceInfo->State.CommandBlock.DataTransferLength;
    62fa:	54 96       	adiw	r26, 0x14	; 20
    62fc:	4d 91       	ld	r20, X+
    62fe:	5d 91       	ld	r21, X+
    6300:	6d 91       	ld	r22, X+
    6302:	7c 91       	ld	r23, X
    6304:	57 97       	sbiw	r26, 0x17	; 23
    6306:	43 ab       	std	Z+51, r20	; 0x33
    6308:	54 ab       	std	Z+52, r21	; 0x34
    630a:	65 ab       	std	Z+53, r22	; 0x35
    630c:	76 ab       	std	Z+54, r23	; 0x36

			if (!(SCSICommandResult) && (le32_to_cpu(MSInterfaceInfo->State.CommandStatus.DataTransferResidue)))
    630e:	81 11       	cpse	r24, r1
    6310:	09 c0       	rjmp	.+18     	; 0x6324 <MS_Device_USBTask+0x166>
    6312:	45 2b       	or	r20, r21
    6314:	46 2b       	or	r20, r22
    6316:	47 2b       	or	r20, r23
    6318:	29 f0       	breq	.+10     	; 0x6324 <MS_Device_USBTask+0x166>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    631a:	eb ee       	ldi	r30, 0xEB	; 235
    631c:	f0 e0       	ldi	r31, 0x00	; 0
    631e:	80 81       	ld	r24, Z
    6320:	80 62       	ori	r24, 0x20	; 32
    6322:	80 83       	st	Z, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6324:	d8 01       	movw	r26, r16
    6326:	16 96       	adiw	r26, 0x06	; 6
    6328:	8c 91       	ld	r24, X
    632a:	8f 70       	andi	r24, 0x0F	; 15
    632c:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    6330:	0f 2e       	mov	r0, r31
    6332:	fb ee       	ldi	r31, 0xEB	; 235
    6334:	ef 2e       	mov	r14, r31
    6336:	f1 2c       	mov	r15, r1
    6338:	f0 2d       	mov	r31, r0
    633a:	05 c0       	rjmp	.+10     	; 0x6346 <MS_Device_USBTask+0x188>
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	while (Endpoint_IsStalled())
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
    633c:	41 d7       	rcall	.+3714   	; 0x71c0 <USB_USBTask>
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    633e:	f8 01       	movw	r30, r16
    6340:	80 ad       	ldd	r24, Z+56	; 0x38
    6342:	81 11       	cpse	r24, r1
    6344:	33 c0       	rjmp	.+102    	; 0x63ac <MS_Device_USBTask+0x1ee>
    6346:	d7 01       	movw	r26, r14
    6348:	8c 91       	ld	r24, X

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	while (Endpoint_IsStalled())
    634a:	85 fd       	sbrc	r24, 5
    634c:	f7 cf       	rjmp	.-18     	; 0x633c <MS_Device_USBTask+0x17e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    634e:	f8 01       	movw	r30, r16
    6350:	81 81       	ldd	r24, Z+1	; 0x01
    6352:	8f 70       	andi	r24, 0x0F	; 15
    6354:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    6358:	0f 2e       	mov	r0, r31
    635a:	fb ee       	ldi	r31, 0xEB	; 235
    635c:	ef 2e       	mov	r14, r31
    635e:	f1 2c       	mov	r15, r1
    6360:	f0 2d       	mov	r31, r0
    6362:	06 c0       	rjmp	.+12     	; 0x6370 <MS_Device_USBTask+0x1b2>
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

	while (Endpoint_IsStalled())
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
    6364:	2d d7       	rcall	.+3674   	; 0x71c0 <USB_USBTask>
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    6366:	d8 01       	movw	r26, r16
    6368:	d8 96       	adiw	r26, 0x38	; 56
    636a:	8c 91       	ld	r24, X
    636c:	81 11       	cpse	r24, r1
    636e:	1e c0       	rjmp	.+60     	; 0x63ac <MS_Device_USBTask+0x1ee>
    6370:	f7 01       	movw	r30, r14
    6372:	80 81       	ld	r24, Z
		  return;
	}

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

	while (Endpoint_IsStalled())
    6374:	85 fd       	sbrc	r24, 5
    6376:	f6 cf       	rjmp	.-20     	; 0x6364 <MS_Device_USBTask+0x1a6>

		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	uint16_t BytesProcessed = 0;
    6378:	1a 82       	std	Y+2, r1	; 0x02
    637a:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    637c:	78 01       	movw	r14, r16
    637e:	fb e2       	ldi	r31, 0x2B	; 43
    6380:	ef 0e       	add	r14, r31
    6382:	f1 1c       	adc	r15, r1
    6384:	05 c0       	rjmp	.+10     	; 0x6390 <MS_Device_USBTask+0x1d2>
	                                sizeof(MS_CommandStatusWrapper_t), &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    6386:	d8 01       	movw	r26, r16
    6388:	d8 96       	adiw	r26, 0x38	; 56
    638a:	9c 91       	ld	r25, X
    638c:	91 11       	cpse	r25, r1
    638e:	0e c0       	rjmp	.+28     	; 0x63ac <MS_Device_USBTask+0x1ee>
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	uint16_t BytesProcessed = 0;
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    6390:	ae 01       	movw	r20, r28
    6392:	4f 5f       	subi	r20, 0xFF	; 255
    6394:	5f 4f       	sbci	r21, 0xFF	; 255
    6396:	6d e0       	ldi	r22, 0x0D	; 13
    6398:	70 e0       	ldi	r23, 0x00	; 0
    639a:	c7 01       	movw	r24, r14
    639c:	9a d0       	rcall	.+308    	; 0x64d2 <Endpoint_Write_Stream_LE>
    639e:	85 30       	cpi	r24, 0x05	; 5
    63a0:	91 f3       	breq	.-28     	; 0x6386 <MS_Device_USBTask+0x1c8>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    63a2:	e8 ee       	ldi	r30, 0xE8	; 232
    63a4:	f0 e0       	ldi	r31, 0x00	; 0
    63a6:	80 81       	ld	r24, Z
    63a8:	8e 77       	andi	r24, 0x7E	; 126
    63aa:	80 83       	st	Z, r24

			MS_Device_ReturnCommandStatus(MSInterfaceInfo);
		}
	}

	if (MSInterfaceInfo->State.IsMassStoreReset)
    63ac:	f8 01       	movw	r30, r16
    63ae:	80 ad       	ldd	r24, Z+56	; 0x38
    63b0:	88 23       	and	r24, r24
    63b2:	b9 f1       	breq	.+110    	; 0x6422 <MS_Device_USBTask+0x264>
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    63b4:	26 81       	ldd	r18, Z+6	; 0x06
    63b6:	2f 70       	andi	r18, 0x0F	; 15
    63b8:	81 e0       	ldi	r24, 0x01	; 1
    63ba:	90 e0       	ldi	r25, 0x00	; 0
    63bc:	ac 01       	movw	r20, r24
    63be:	02 c0       	rjmp	.+4      	; 0x63c4 <MS_Device_USBTask+0x206>
    63c0:	44 0f       	add	r20, r20
    63c2:	55 1f       	adc	r21, r21
    63c4:	2a 95       	dec	r18
    63c6:	e2 f7       	brpl	.-8      	; 0x63c0 <MS_Device_USBTask+0x202>
    63c8:	ea ee       	ldi	r30, 0xEA	; 234
    63ca:	f0 e0       	ldi	r31, 0x00	; 0
    63cc:	40 83       	st	Z, r20
				UERST = 0;
    63ce:	10 82       	st	Z, r1
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    63d0:	d8 01       	movw	r26, r16
    63d2:	11 96       	adiw	r26, 0x01	; 1
    63d4:	2c 91       	ld	r18, X
    63d6:	11 97       	sbiw	r26, 0x01	; 1
    63d8:	2f 70       	andi	r18, 0x0F	; 15
    63da:	02 c0       	rjmp	.+4      	; 0x63e0 <MS_Device_USBTask+0x222>
    63dc:	88 0f       	add	r24, r24
    63de:	99 1f       	adc	r25, r25
    63e0:	2a 95       	dec	r18
    63e2:	e2 f7       	brpl	.-8      	; 0x63dc <MS_Device_USBTask+0x21e>
    63e4:	80 83       	st	Z, r24
				UERST = 0;
    63e6:	10 82       	st	Z, r1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    63e8:	16 96       	adiw	r26, 0x06	; 6
    63ea:	8c 91       	ld	r24, X
    63ec:	16 97       	sbiw	r26, 0x06	; 6
    63ee:	8f 70       	andi	r24, 0x0F	; 15
    63f0:	29 ee       	ldi	r18, 0xE9	; 233
    63f2:	30 e0       	ldi	r19, 0x00	; 0
    63f4:	f9 01       	movw	r30, r18
    63f6:	80 83       	st	Z, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    63f8:	eb ee       	ldi	r30, 0xEB	; 235
    63fa:	f0 e0       	ldi	r31, 0x00	; 0
    63fc:	80 81       	ld	r24, Z
    63fe:	80 61       	ori	r24, 0x10	; 16
    6400:	80 83       	st	Z, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    6402:	80 81       	ld	r24, Z
    6404:	88 60       	ori	r24, 0x08	; 8
    6406:	80 83       	st	Z, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6408:	11 96       	adiw	r26, 0x01	; 1
    640a:	8c 91       	ld	r24, X
    640c:	8f 70       	andi	r24, 0x0F	; 15
    640e:	d9 01       	movw	r26, r18
    6410:	8c 93       	st	X, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6412:	80 81       	ld	r24, Z
    6414:	80 61       	ori	r24, 0x10	; 16
    6416:	80 83       	st	Z, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    6418:	80 81       	ld	r24, Z
    641a:	88 60       	ori	r24, 0x08	; 8
    641c:	80 83       	st	Z, r24
		Endpoint_ResetDataToggle();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);
		Endpoint_ClearStall();
		Endpoint_ResetDataToggle();

		MSInterfaceInfo->State.IsMassStoreReset = false;
    641e:	f8 01       	movw	r30, r16
    6420:	10 ae       	std	Z+56, r1	; 0x38
	}
}
    6422:	0f 90       	pop	r0
    6424:	0f 90       	pop	r0
    6426:	df 91       	pop	r29
    6428:	cf 91       	pop	r28
    642a:	1f 91       	pop	r17
    642c:	0f 91       	pop	r16
    642e:	ff 90       	pop	r15
    6430:	ef 90       	pop	r14
    6432:	08 95       	ret

00006434 <Endpoint_Null_Stream>:
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    6434:	af 92       	push	r10
    6436:	bf 92       	push	r11
    6438:	cf 92       	push	r12
    643a:	df 92       	push	r13
    643c:	ef 92       	push	r14
    643e:	ff 92       	push	r15
    6440:	0f 93       	push	r16
    6442:	1f 93       	push	r17
    6444:	cf 93       	push	r28
    6446:	df 93       	push	r29
    6448:	ec 01       	movw	r28, r24
    644a:	6b 01       	movw	r12, r22
    644c:	ce d3       	rcall	.+1948   	; 0x6bea <Endpoint_WaitUntilReady>
    644e:	81 11       	cpse	r24, r1
    6450:	35 c0       	rjmp	.+106    	; 0x64bc <Endpoint_Null_Stream+0x88>
    6452:	c1 14       	cp	r12, r1
    6454:	d1 04       	cpc	r13, r1
    6456:	29 f0       	breq	.+10     	; 0x6462 <Endpoint_Null_Stream+0x2e>
    6458:	f6 01       	movw	r30, r12
    645a:	80 81       	ld	r24, Z
    645c:	91 81       	ldd	r25, Z+1	; 0x01
    645e:	c8 1b       	sub	r28, r24
    6460:	d9 0b       	sbc	r29, r25
    6462:	20 97       	sbiw	r28, 0x00	; 0
    6464:	51 f1       	breq	.+84     	; 0x64ba <Endpoint_Null_Stream+0x86>
    6466:	e1 2c       	mov	r14, r1
    6468:	f1 2c       	mov	r15, r1
    646a:	08 ee       	ldi	r16, 0xE8	; 232
    646c:	10 e0       	ldi	r17, 0x00	; 0
    646e:	0f 2e       	mov	r0, r31
    6470:	f1 ef       	ldi	r31, 0xF1	; 241
    6472:	af 2e       	mov	r10, r31
    6474:	b1 2c       	mov	r11, r1
    6476:	f0 2d       	mov	r31, r0
    6478:	f8 01       	movw	r30, r16
    647a:	80 81       	ld	r24, Z
    647c:	85 fd       	sbrc	r24, 5
    647e:	13 c0       	rjmp	.+38     	; 0x64a6 <Endpoint_Null_Stream+0x72>
    6480:	80 81       	ld	r24, Z
    6482:	8e 77       	andi	r24, 0x7E	; 126
    6484:	80 83       	st	Z, r24
    6486:	c1 14       	cp	r12, r1
    6488:	d1 04       	cpc	r13, r1
    648a:	49 f0       	breq	.+18     	; 0x649e <Endpoint_Null_Stream+0x6a>
    648c:	f6 01       	movw	r30, r12
    648e:	80 81       	ld	r24, Z
    6490:	91 81       	ldd	r25, Z+1	; 0x01
    6492:	e8 0e       	add	r14, r24
    6494:	f9 1e       	adc	r15, r25
    6496:	f1 82       	std	Z+1, r15	; 0x01
    6498:	e0 82       	st	Z, r14
    649a:	85 e0       	ldi	r24, 0x05	; 5
    649c:	0f c0       	rjmp	.+30     	; 0x64bc <Endpoint_Null_Stream+0x88>
    649e:	a5 d3       	rcall	.+1866   	; 0x6bea <Endpoint_WaitUntilReady>
    64a0:	88 23       	and	r24, r24
    64a2:	39 f0       	breq	.+14     	; 0x64b2 <Endpoint_Null_Stream+0x7e>
    64a4:	0b c0       	rjmp	.+22     	; 0x64bc <Endpoint_Null_Stream+0x88>
    64a6:	f5 01       	movw	r30, r10
    64a8:	10 82       	st	Z, r1
    64aa:	21 97       	sbiw	r28, 0x01	; 1
    64ac:	ff ef       	ldi	r31, 0xFF	; 255
    64ae:	ef 1a       	sub	r14, r31
    64b0:	ff 0a       	sbc	r15, r31
    64b2:	20 97       	sbiw	r28, 0x00	; 0
    64b4:	09 f7       	brne	.-62     	; 0x6478 <Endpoint_Null_Stream+0x44>
    64b6:	80 e0       	ldi	r24, 0x00	; 0
    64b8:	01 c0       	rjmp	.+2      	; 0x64bc <Endpoint_Null_Stream+0x88>
    64ba:	80 e0       	ldi	r24, 0x00	; 0
    64bc:	df 91       	pop	r29
    64be:	cf 91       	pop	r28
    64c0:	1f 91       	pop	r17
    64c2:	0f 91       	pop	r16
    64c4:	ff 90       	pop	r15
    64c6:	ef 90       	pop	r14
    64c8:	df 90       	pop	r13
    64ca:	cf 90       	pop	r12
    64cc:	bf 90       	pop	r11
    64ce:	af 90       	pop	r10
    64d0:	08 95       	ret

000064d2 <Endpoint_Write_Stream_LE>:
    64d2:	8f 92       	push	r8
    64d4:	9f 92       	push	r9
    64d6:	af 92       	push	r10
    64d8:	bf 92       	push	r11
    64da:	cf 92       	push	r12
    64dc:	df 92       	push	r13
    64de:	ef 92       	push	r14
    64e0:	ff 92       	push	r15
    64e2:	0f 93       	push	r16
    64e4:	1f 93       	push	r17
    64e6:	cf 93       	push	r28
    64e8:	df 93       	push	r29
    64ea:	8c 01       	movw	r16, r24
    64ec:	eb 01       	movw	r28, r22
    64ee:	5a 01       	movw	r10, r20
    64f0:	7c d3       	rcall	.+1784   	; 0x6bea <Endpoint_WaitUntilReady>
    64f2:	81 11       	cpse	r24, r1
    64f4:	3e c0       	rjmp	.+124    	; 0x6572 <Endpoint_Write_Stream_LE+0xa0>
    64f6:	a1 14       	cp	r10, r1
    64f8:	b1 04       	cpc	r11, r1
    64fa:	39 f0       	breq	.+14     	; 0x650a <Endpoint_Write_Stream_LE+0x38>
    64fc:	f5 01       	movw	r30, r10
    64fe:	80 81       	ld	r24, Z
    6500:	91 81       	ldd	r25, Z+1	; 0x01
    6502:	c8 1b       	sub	r28, r24
    6504:	d9 0b       	sbc	r29, r25
    6506:	08 0f       	add	r16, r24
    6508:	19 1f       	adc	r17, r25
    650a:	20 97       	sbiw	r28, 0x00	; 0
    650c:	89 f1       	breq	.+98     	; 0x6570 <Endpoint_Write_Stream_LE+0x9e>
    650e:	e1 2c       	mov	r14, r1
    6510:	f1 2c       	mov	r15, r1
    6512:	0f 2e       	mov	r0, r31
    6514:	f8 ee       	ldi	r31, 0xE8	; 232
    6516:	8f 2e       	mov	r8, r31
    6518:	91 2c       	mov	r9, r1
    651a:	f0 2d       	mov	r31, r0
    651c:	0f 2e       	mov	r0, r31
    651e:	f1 ef       	ldi	r31, 0xF1	; 241
    6520:	cf 2e       	mov	r12, r31
    6522:	d1 2c       	mov	r13, r1
    6524:	f0 2d       	mov	r31, r0
    6526:	f4 01       	movw	r30, r8
    6528:	80 81       	ld	r24, Z
    652a:	85 fd       	sbrc	r24, 5
    652c:	14 c0       	rjmp	.+40     	; 0x6556 <Endpoint_Write_Stream_LE+0x84>
    652e:	80 81       	ld	r24, Z
    6530:	8e 77       	andi	r24, 0x7E	; 126
    6532:	80 83       	st	Z, r24
    6534:	45 d6       	rcall	.+3210   	; 0x71c0 <USB_USBTask>
    6536:	a1 14       	cp	r10, r1
    6538:	b1 04       	cpc	r11, r1
    653a:	49 f0       	breq	.+18     	; 0x654e <Endpoint_Write_Stream_LE+0x7c>
    653c:	f5 01       	movw	r30, r10
    653e:	80 81       	ld	r24, Z
    6540:	91 81       	ldd	r25, Z+1	; 0x01
    6542:	e8 0e       	add	r14, r24
    6544:	f9 1e       	adc	r15, r25
    6546:	f1 82       	std	Z+1, r15	; 0x01
    6548:	e0 82       	st	Z, r14
    654a:	85 e0       	ldi	r24, 0x05	; 5
    654c:	12 c0       	rjmp	.+36     	; 0x6572 <Endpoint_Write_Stream_LE+0xa0>
    654e:	4d d3       	rcall	.+1690   	; 0x6bea <Endpoint_WaitUntilReady>
    6550:	88 23       	and	r24, r24
    6552:	51 f0       	breq	.+20     	; 0x6568 <Endpoint_Write_Stream_LE+0x96>
    6554:	0e c0       	rjmp	.+28     	; 0x6572 <Endpoint_Write_Stream_LE+0xa0>
    6556:	f8 01       	movw	r30, r16
    6558:	81 91       	ld	r24, Z+
    655a:	8f 01       	movw	r16, r30
    655c:	f6 01       	movw	r30, r12
    655e:	80 83       	st	Z, r24
    6560:	21 97       	sbiw	r28, 0x01	; 1
    6562:	ff ef       	ldi	r31, 0xFF	; 255
    6564:	ef 1a       	sub	r14, r31
    6566:	ff 0a       	sbc	r15, r31
    6568:	20 97       	sbiw	r28, 0x00	; 0
    656a:	e9 f6       	brne	.-70     	; 0x6526 <Endpoint_Write_Stream_LE+0x54>
    656c:	80 e0       	ldi	r24, 0x00	; 0
    656e:	01 c0       	rjmp	.+2      	; 0x6572 <Endpoint_Write_Stream_LE+0xa0>
    6570:	80 e0       	ldi	r24, 0x00	; 0
    6572:	df 91       	pop	r29
    6574:	cf 91       	pop	r28
    6576:	1f 91       	pop	r17
    6578:	0f 91       	pop	r16
    657a:	ff 90       	pop	r15
    657c:	ef 90       	pop	r14
    657e:	df 90       	pop	r13
    6580:	cf 90       	pop	r12
    6582:	bf 90       	pop	r11
    6584:	af 90       	pop	r10
    6586:	9f 90       	pop	r9
    6588:	8f 90       	pop	r8
    658a:	08 95       	ret

0000658c <Endpoint_Write_Stream_BE>:
    658c:	8f 92       	push	r8
    658e:	9f 92       	push	r9
    6590:	af 92       	push	r10
    6592:	bf 92       	push	r11
    6594:	cf 92       	push	r12
    6596:	df 92       	push	r13
    6598:	ef 92       	push	r14
    659a:	ff 92       	push	r15
    659c:	0f 93       	push	r16
    659e:	1f 93       	push	r17
    65a0:	cf 93       	push	r28
    65a2:	df 93       	push	r29
    65a4:	8c 01       	movw	r16, r24
    65a6:	eb 01       	movw	r28, r22
    65a8:	5a 01       	movw	r10, r20
    65aa:	1f d3       	rcall	.+1598   	; 0x6bea <Endpoint_WaitUntilReady>
    65ac:	81 11       	cpse	r24, r1
    65ae:	43 c0       	rjmp	.+134    	; 0x6636 <Endpoint_Write_Stream_BE+0xaa>
    65b0:	ce 01       	movw	r24, r28
    65b2:	01 97       	sbiw	r24, 0x01	; 1
    65b4:	08 0f       	add	r16, r24
    65b6:	19 1f       	adc	r17, r25
    65b8:	a1 14       	cp	r10, r1
    65ba:	b1 04       	cpc	r11, r1
    65bc:	39 f0       	breq	.+14     	; 0x65cc <Endpoint_Write_Stream_BE+0x40>
    65be:	f5 01       	movw	r30, r10
    65c0:	80 81       	ld	r24, Z
    65c2:	91 81       	ldd	r25, Z+1	; 0x01
    65c4:	c8 1b       	sub	r28, r24
    65c6:	d9 0b       	sbc	r29, r25
    65c8:	08 1b       	sub	r16, r24
    65ca:	19 0b       	sbc	r17, r25
    65cc:	20 97       	sbiw	r28, 0x00	; 0
    65ce:	91 f1       	breq	.+100    	; 0x6634 <Endpoint_Write_Stream_BE+0xa8>
    65d0:	e1 2c       	mov	r14, r1
    65d2:	f1 2c       	mov	r15, r1
    65d4:	0f 2e       	mov	r0, r31
    65d6:	f8 ee       	ldi	r31, 0xE8	; 232
    65d8:	8f 2e       	mov	r8, r31
    65da:	91 2c       	mov	r9, r1
    65dc:	f0 2d       	mov	r31, r0
    65de:	0f 2e       	mov	r0, r31
    65e0:	f1 ef       	ldi	r31, 0xF1	; 241
    65e2:	cf 2e       	mov	r12, r31
    65e4:	d1 2c       	mov	r13, r1
    65e6:	f0 2d       	mov	r31, r0
    65e8:	f4 01       	movw	r30, r8
    65ea:	80 81       	ld	r24, Z
    65ec:	85 fd       	sbrc	r24, 5
    65ee:	14 c0       	rjmp	.+40     	; 0x6618 <Endpoint_Write_Stream_BE+0x8c>
    65f0:	80 81       	ld	r24, Z
    65f2:	8e 77       	andi	r24, 0x7E	; 126
    65f4:	80 83       	st	Z, r24
    65f6:	e4 d5       	rcall	.+3016   	; 0x71c0 <USB_USBTask>
    65f8:	a1 14       	cp	r10, r1
    65fa:	b1 04       	cpc	r11, r1
    65fc:	49 f0       	breq	.+18     	; 0x6610 <Endpoint_Write_Stream_BE+0x84>
    65fe:	f5 01       	movw	r30, r10
    6600:	80 81       	ld	r24, Z
    6602:	91 81       	ldd	r25, Z+1	; 0x01
    6604:	e8 0e       	add	r14, r24
    6606:	f9 1e       	adc	r15, r25
    6608:	f1 82       	std	Z+1, r15	; 0x01
    660a:	e0 82       	st	Z, r14
    660c:	85 e0       	ldi	r24, 0x05	; 5
    660e:	13 c0       	rjmp	.+38     	; 0x6636 <Endpoint_Write_Stream_BE+0xaa>
    6610:	ec d2       	rcall	.+1496   	; 0x6bea <Endpoint_WaitUntilReady>
    6612:	88 23       	and	r24, r24
    6614:	59 f0       	breq	.+22     	; 0x662c <Endpoint_Write_Stream_BE+0xa0>
    6616:	0f c0       	rjmp	.+30     	; 0x6636 <Endpoint_Write_Stream_BE+0xaa>
    6618:	f8 01       	movw	r30, r16
    661a:	80 81       	ld	r24, Z
    661c:	f6 01       	movw	r30, r12
    661e:	80 83       	st	Z, r24
    6620:	01 50       	subi	r16, 0x01	; 1
    6622:	11 09       	sbc	r17, r1
    6624:	21 97       	sbiw	r28, 0x01	; 1
    6626:	ff ef       	ldi	r31, 0xFF	; 255
    6628:	ef 1a       	sub	r14, r31
    662a:	ff 0a       	sbc	r15, r31
    662c:	20 97       	sbiw	r28, 0x00	; 0
    662e:	e1 f6       	brne	.-72     	; 0x65e8 <Endpoint_Write_Stream_BE+0x5c>
    6630:	80 e0       	ldi	r24, 0x00	; 0
    6632:	01 c0       	rjmp	.+2      	; 0x6636 <Endpoint_Write_Stream_BE+0xaa>
    6634:	80 e0       	ldi	r24, 0x00	; 0
    6636:	df 91       	pop	r29
    6638:	cf 91       	pop	r28
    663a:	1f 91       	pop	r17
    663c:	0f 91       	pop	r16
    663e:	ff 90       	pop	r15
    6640:	ef 90       	pop	r14
    6642:	df 90       	pop	r13
    6644:	cf 90       	pop	r12
    6646:	bf 90       	pop	r11
    6648:	af 90       	pop	r10
    664a:	9f 90       	pop	r9
    664c:	8f 90       	pop	r8
    664e:	08 95       	ret

00006650 <Endpoint_Read_Stream_LE>:
    6650:	8f 92       	push	r8
    6652:	9f 92       	push	r9
    6654:	af 92       	push	r10
    6656:	bf 92       	push	r11
    6658:	cf 92       	push	r12
    665a:	df 92       	push	r13
    665c:	ef 92       	push	r14
    665e:	ff 92       	push	r15
    6660:	0f 93       	push	r16
    6662:	1f 93       	push	r17
    6664:	cf 93       	push	r28
    6666:	df 93       	push	r29
    6668:	8c 01       	movw	r16, r24
    666a:	eb 01       	movw	r28, r22
    666c:	5a 01       	movw	r10, r20
    666e:	bd d2       	rcall	.+1402   	; 0x6bea <Endpoint_WaitUntilReady>
    6670:	81 11       	cpse	r24, r1
    6672:	3e c0       	rjmp	.+124    	; 0x66f0 <Endpoint_Read_Stream_LE+0xa0>
    6674:	a1 14       	cp	r10, r1
    6676:	b1 04       	cpc	r11, r1
    6678:	39 f0       	breq	.+14     	; 0x6688 <Endpoint_Read_Stream_LE+0x38>
    667a:	f5 01       	movw	r30, r10
    667c:	80 81       	ld	r24, Z
    667e:	91 81       	ldd	r25, Z+1	; 0x01
    6680:	c8 1b       	sub	r28, r24
    6682:	d9 0b       	sbc	r29, r25
    6684:	08 0f       	add	r16, r24
    6686:	19 1f       	adc	r17, r25
    6688:	20 97       	sbiw	r28, 0x00	; 0
    668a:	89 f1       	breq	.+98     	; 0x66ee <Endpoint_Read_Stream_LE+0x9e>
    668c:	e1 2c       	mov	r14, r1
    668e:	f1 2c       	mov	r15, r1
    6690:	0f 2e       	mov	r0, r31
    6692:	f8 ee       	ldi	r31, 0xE8	; 232
    6694:	8f 2e       	mov	r8, r31
    6696:	91 2c       	mov	r9, r1
    6698:	f0 2d       	mov	r31, r0
    669a:	0f 2e       	mov	r0, r31
    669c:	f1 ef       	ldi	r31, 0xF1	; 241
    669e:	cf 2e       	mov	r12, r31
    66a0:	d1 2c       	mov	r13, r1
    66a2:	f0 2d       	mov	r31, r0
    66a4:	f4 01       	movw	r30, r8
    66a6:	80 81       	ld	r24, Z
    66a8:	85 fd       	sbrc	r24, 5
    66aa:	14 c0       	rjmp	.+40     	; 0x66d4 <Endpoint_Read_Stream_LE+0x84>
    66ac:	80 81       	ld	r24, Z
    66ae:	8b 77       	andi	r24, 0x7B	; 123
    66b0:	80 83       	st	Z, r24
    66b2:	86 d5       	rcall	.+2828   	; 0x71c0 <USB_USBTask>
    66b4:	a1 14       	cp	r10, r1
    66b6:	b1 04       	cpc	r11, r1
    66b8:	49 f0       	breq	.+18     	; 0x66cc <Endpoint_Read_Stream_LE+0x7c>
    66ba:	f5 01       	movw	r30, r10
    66bc:	80 81       	ld	r24, Z
    66be:	91 81       	ldd	r25, Z+1	; 0x01
    66c0:	e8 0e       	add	r14, r24
    66c2:	f9 1e       	adc	r15, r25
    66c4:	f1 82       	std	Z+1, r15	; 0x01
    66c6:	e0 82       	st	Z, r14
    66c8:	85 e0       	ldi	r24, 0x05	; 5
    66ca:	12 c0       	rjmp	.+36     	; 0x66f0 <Endpoint_Read_Stream_LE+0xa0>
    66cc:	8e d2       	rcall	.+1308   	; 0x6bea <Endpoint_WaitUntilReady>
    66ce:	88 23       	and	r24, r24
    66d0:	51 f0       	breq	.+20     	; 0x66e6 <Endpoint_Read_Stream_LE+0x96>
    66d2:	0e c0       	rjmp	.+28     	; 0x66f0 <Endpoint_Read_Stream_LE+0xa0>
    66d4:	f6 01       	movw	r30, r12
    66d6:	80 81       	ld	r24, Z
    66d8:	f8 01       	movw	r30, r16
    66da:	81 93       	st	Z+, r24
    66dc:	8f 01       	movw	r16, r30
    66de:	21 97       	sbiw	r28, 0x01	; 1
    66e0:	ff ef       	ldi	r31, 0xFF	; 255
    66e2:	ef 1a       	sub	r14, r31
    66e4:	ff 0a       	sbc	r15, r31
    66e6:	20 97       	sbiw	r28, 0x00	; 0
    66e8:	e9 f6       	brne	.-70     	; 0x66a4 <Endpoint_Read_Stream_LE+0x54>
    66ea:	80 e0       	ldi	r24, 0x00	; 0
    66ec:	01 c0       	rjmp	.+2      	; 0x66f0 <Endpoint_Read_Stream_LE+0xa0>
    66ee:	80 e0       	ldi	r24, 0x00	; 0
    66f0:	df 91       	pop	r29
    66f2:	cf 91       	pop	r28
    66f4:	1f 91       	pop	r17
    66f6:	0f 91       	pop	r16
    66f8:	ff 90       	pop	r15
    66fa:	ef 90       	pop	r14
    66fc:	df 90       	pop	r13
    66fe:	cf 90       	pop	r12
    6700:	bf 90       	pop	r11
    6702:	af 90       	pop	r10
    6704:	9f 90       	pop	r9
    6706:	8f 90       	pop	r8
    6708:	08 95       	ret

0000670a <Endpoint_Write_Control_Stream_LE>:
    670a:	cf 92       	push	r12
    670c:	df 92       	push	r13
    670e:	ff 92       	push	r15
    6710:	0f 93       	push	r16
    6712:	1f 93       	push	r17
    6714:	cf 93       	push	r28
    6716:	df 93       	push	r29
    6718:	20 91 55 0a 	lds	r18, 0x0A55
    671c:	30 91 56 0a 	lds	r19, 0x0A56
    6720:	26 17       	cp	r18, r22
    6722:	37 07       	cpc	r19, r23
    6724:	58 f0       	brcs	.+22     	; 0x673c <Endpoint_Write_Control_Stream_LE+0x32>
    6726:	61 15       	cp	r22, r1
    6728:	71 05       	cpc	r23, r1
    672a:	39 f4       	brne	.+14     	; 0x673a <Endpoint_Write_Control_Stream_LE+0x30>
    672c:	e8 ee       	ldi	r30, 0xE8	; 232
    672e:	f0 e0       	ldi	r31, 0x00	; 0
    6730:	20 81       	ld	r18, Z
    6732:	2e 77       	andi	r18, 0x7E	; 126
    6734:	20 83       	st	Z, r18
    6736:	9b 01       	movw	r18, r22
    6738:	01 c0       	rjmp	.+2      	; 0x673c <Endpoint_Write_Control_Stream_LE+0x32>
    673a:	9b 01       	movw	r18, r22
    673c:	a8 2f       	mov	r26, r24
    673e:	b9 2f       	mov	r27, r25
    6740:	10 e0       	ldi	r17, 0x00	; 0
    6742:	e8 ee       	ldi	r30, 0xE8	; 232
    6744:	f0 e0       	ldi	r31, 0x00	; 0
    6746:	63 ef       	ldi	r22, 0xF3	; 243
    6748:	70 e0       	ldi	r23, 0x00	; 0
    674a:	42 ef       	ldi	r20, 0xF2	; 242
    674c:	50 e0       	ldi	r21, 0x00	; 0
    674e:	0f 2e       	mov	r0, r31
    6750:	f1 ef       	ldi	r31, 0xF1	; 241
    6752:	cf 2e       	mov	r12, r31
    6754:	d1 2c       	mov	r13, r1
    6756:	f0 2d       	mov	r31, r0
    6758:	01 e0       	ldi	r16, 0x01	; 1
    675a:	f1 2c       	mov	r15, r1
    675c:	30 c0       	rjmp	.+96     	; 0x67be <Endpoint_Write_Control_Stream_LE+0xb4>
    675e:	80 91 4e 0a 	lds	r24, 0x0A4E
    6762:	88 23       	and	r24, r24
    6764:	09 f4       	brne	.+2      	; 0x6768 <Endpoint_Write_Control_Stream_LE+0x5e>
    6766:	42 c0       	rjmp	.+132    	; 0x67ec <Endpoint_Write_Control_Stream_LE+0xe2>
    6768:	85 30       	cpi	r24, 0x05	; 5
    676a:	09 f4       	brne	.+2      	; 0x676e <Endpoint_Write_Control_Stream_LE+0x64>
    676c:	41 c0       	rjmp	.+130    	; 0x67f0 <Endpoint_Write_Control_Stream_LE+0xe6>
    676e:	80 81       	ld	r24, Z
    6770:	83 fd       	sbrc	r24, 3
    6772:	40 c0       	rjmp	.+128    	; 0x67f4 <Endpoint_Write_Control_Stream_LE+0xea>
    6774:	80 81       	ld	r24, Z
    6776:	82 fd       	sbrc	r24, 2
    6778:	32 c0       	rjmp	.+100    	; 0x67de <Endpoint_Write_Control_Stream_LE+0xd4>
    677a:	80 81       	ld	r24, Z
    677c:	80 ff       	sbrs	r24, 0
    677e:	1f c0       	rjmp	.+62     	; 0x67be <Endpoint_Write_Control_Stream_LE+0xb4>
    6780:	eb 01       	movw	r28, r22
    6782:	18 81       	ld	r17, Y
    6784:	ea 01       	movw	r28, r20
    6786:	88 81       	ld	r24, Y
    6788:	90 e0       	ldi	r25, 0x00	; 0
    678a:	91 2b       	or	r25, r17
    678c:	21 15       	cp	r18, r1
    678e:	31 05       	cpc	r19, r1
    6790:	79 f0       	breq	.+30     	; 0x67b0 <Endpoint_Write_Control_Stream_LE+0xa6>
    6792:	88 30       	cpi	r24, 0x08	; 8
    6794:	91 05       	cpc	r25, r1
    6796:	60 f4       	brcc	.+24     	; 0x67b0 <Endpoint_Write_Control_Stream_LE+0xa6>
    6798:	1d 91       	ld	r17, X+
    679a:	e6 01       	movw	r28, r12
    679c:	18 83       	st	Y, r17
    679e:	21 50       	subi	r18, 0x01	; 1
    67a0:	31 09       	sbc	r19, r1
    67a2:	01 96       	adiw	r24, 0x01	; 1
    67a4:	21 15       	cp	r18, r1
    67a6:	31 05       	cpc	r19, r1
    67a8:	19 f0       	breq	.+6      	; 0x67b0 <Endpoint_Write_Control_Stream_LE+0xa6>
    67aa:	88 30       	cpi	r24, 0x08	; 8
    67ac:	91 05       	cpc	r25, r1
    67ae:	a1 f7       	brne	.-24     	; 0x6798 <Endpoint_Write_Control_Stream_LE+0x8e>
    67b0:	10 2f       	mov	r17, r16
    67b2:	08 97       	sbiw	r24, 0x08	; 8
    67b4:	09 f0       	breq	.+2      	; 0x67b8 <Endpoint_Write_Control_Stream_LE+0xae>
    67b6:	1f 2d       	mov	r17, r15
    67b8:	80 81       	ld	r24, Z
    67ba:	8e 77       	andi	r24, 0x7E	; 126
    67bc:	80 83       	st	Z, r24
    67be:	21 15       	cp	r18, r1
    67c0:	31 05       	cpc	r19, r1
    67c2:	69 f6       	brne	.-102    	; 0x675e <Endpoint_Write_Control_Stream_LE+0x54>
    67c4:	11 11       	cpse	r17, r1
    67c6:	cb cf       	rjmp	.-106    	; 0x675e <Endpoint_Write_Control_Stream_LE+0x54>
    67c8:	0a c0       	rjmp	.+20     	; 0x67de <Endpoint_Write_Control_Stream_LE+0xd4>
    67ca:	80 91 4e 0a 	lds	r24, 0x0A4E
    67ce:	88 23       	and	r24, r24
    67d0:	99 f0       	breq	.+38     	; 0x67f8 <Endpoint_Write_Control_Stream_LE+0xee>
    67d2:	85 30       	cpi	r24, 0x05	; 5
    67d4:	99 f0       	breq	.+38     	; 0x67fc <Endpoint_Write_Control_Stream_LE+0xf2>
    67d6:	80 81       	ld	r24, Z
    67d8:	83 ff       	sbrs	r24, 3
    67da:	03 c0       	rjmp	.+6      	; 0x67e2 <Endpoint_Write_Control_Stream_LE+0xd8>
    67dc:	11 c0       	rjmp	.+34     	; 0x6800 <Endpoint_Write_Control_Stream_LE+0xf6>
    67de:	e8 ee       	ldi	r30, 0xE8	; 232
    67e0:	f0 e0       	ldi	r31, 0x00	; 0
    67e2:	80 81       	ld	r24, Z
    67e4:	82 ff       	sbrs	r24, 2
    67e6:	f1 cf       	rjmp	.-30     	; 0x67ca <Endpoint_Write_Control_Stream_LE+0xc0>
    67e8:	80 e0       	ldi	r24, 0x00	; 0
    67ea:	0b c0       	rjmp	.+22     	; 0x6802 <Endpoint_Write_Control_Stream_LE+0xf8>
    67ec:	82 e0       	ldi	r24, 0x02	; 2
    67ee:	09 c0       	rjmp	.+18     	; 0x6802 <Endpoint_Write_Control_Stream_LE+0xf8>
    67f0:	83 e0       	ldi	r24, 0x03	; 3
    67f2:	07 c0       	rjmp	.+14     	; 0x6802 <Endpoint_Write_Control_Stream_LE+0xf8>
    67f4:	81 e0       	ldi	r24, 0x01	; 1
    67f6:	05 c0       	rjmp	.+10     	; 0x6802 <Endpoint_Write_Control_Stream_LE+0xf8>
    67f8:	82 e0       	ldi	r24, 0x02	; 2
    67fa:	03 c0       	rjmp	.+6      	; 0x6802 <Endpoint_Write_Control_Stream_LE+0xf8>
    67fc:	83 e0       	ldi	r24, 0x03	; 3
    67fe:	01 c0       	rjmp	.+2      	; 0x6802 <Endpoint_Write_Control_Stream_LE+0xf8>
    6800:	81 e0       	ldi	r24, 0x01	; 1
    6802:	df 91       	pop	r29
    6804:	cf 91       	pop	r28
    6806:	1f 91       	pop	r17
    6808:	0f 91       	pop	r16
    680a:	ff 90       	pop	r15
    680c:	df 90       	pop	r13
    680e:	cf 90       	pop	r12
    6810:	08 95       	ret

00006812 <Endpoint_Read_Control_Stream_LE>:
    6812:	ef 92       	push	r14
    6814:	ff 92       	push	r15
    6816:	1f 93       	push	r17
    6818:	cf 93       	push	r28
    681a:	df 93       	push	r29
    681c:	61 15       	cp	r22, r1
    681e:	71 05       	cpc	r23, r1
    6820:	29 f4       	brne	.+10     	; 0x682c <Endpoint_Read_Control_Stream_LE+0x1a>
    6822:	e8 ee       	ldi	r30, 0xE8	; 232
    6824:	f0 e0       	ldi	r31, 0x00	; 0
    6826:	20 81       	ld	r18, Z
    6828:	2b 77       	andi	r18, 0x7B	; 123
    682a:	20 83       	st	Z, r18
    682c:	a8 2f       	mov	r26, r24
    682e:	b9 2f       	mov	r27, r25
    6830:	e8 ee       	ldi	r30, 0xE8	; 232
    6832:	f0 e0       	ldi	r31, 0x00	; 0
    6834:	23 ef       	ldi	r18, 0xF3	; 243
    6836:	30 e0       	ldi	r19, 0x00	; 0
    6838:	0f 2e       	mov	r0, r31
    683a:	f2 ef       	ldi	r31, 0xF2	; 242
    683c:	ef 2e       	mov	r14, r31
    683e:	f1 2c       	mov	r15, r1
    6840:	f0 2d       	mov	r31, r0
    6842:	41 ef       	ldi	r20, 0xF1	; 241
    6844:	50 e0       	ldi	r21, 0x00	; 0
    6846:	1e c0       	rjmp	.+60     	; 0x6884 <Endpoint_Read_Control_Stream_LE+0x72>
    6848:	80 91 4e 0a 	lds	r24, 0x0A4E
    684c:	88 23       	and	r24, r24
    684e:	c1 f1       	breq	.+112    	; 0x68c0 <Endpoint_Read_Control_Stream_LE+0xae>
    6850:	85 30       	cpi	r24, 0x05	; 5
    6852:	c1 f1       	breq	.+112    	; 0x68c4 <Endpoint_Read_Control_Stream_LE+0xb2>
    6854:	80 81       	ld	r24, Z
    6856:	83 fd       	sbrc	r24, 3
    6858:	37 c0       	rjmp	.+110    	; 0x68c8 <Endpoint_Read_Control_Stream_LE+0xb6>
    685a:	80 81       	ld	r24, Z
    685c:	82 ff       	sbrs	r24, 2
    685e:	f4 cf       	rjmp	.-24     	; 0x6848 <Endpoint_Read_Control_Stream_LE+0x36>
    6860:	3f c0       	rjmp	.+126    	; 0x68e0 <Endpoint_Read_Control_Stream_LE+0xce>
    6862:	ea 01       	movw	r28, r20
    6864:	88 81       	ld	r24, Y
    6866:	8d 93       	st	X+, r24
    6868:	61 50       	subi	r22, 0x01	; 1
    686a:	71 09       	sbc	r23, r1
    686c:	41 f0       	breq	.+16     	; 0x687e <Endpoint_Read_Control_Stream_LE+0x6c>
    686e:	e9 01       	movw	r28, r18
    6870:	18 81       	ld	r17, Y
    6872:	e7 01       	movw	r28, r14
    6874:	88 81       	ld	r24, Y
    6876:	90 e0       	ldi	r25, 0x00	; 0
    6878:	91 2b       	or	r25, r17
    687a:	89 2b       	or	r24, r25
    687c:	91 f7       	brne	.-28     	; 0x6862 <Endpoint_Read_Control_Stream_LE+0x50>
    687e:	80 81       	ld	r24, Z
    6880:	8b 77       	andi	r24, 0x7B	; 123
    6882:	80 83       	st	Z, r24
    6884:	61 15       	cp	r22, r1
    6886:	71 05       	cpc	r23, r1
    6888:	a1 f0       	breq	.+40     	; 0x68b2 <Endpoint_Read_Control_Stream_LE+0xa0>
    688a:	80 91 4e 0a 	lds	r24, 0x0A4E
    688e:	88 23       	and	r24, r24
    6890:	e9 f0       	breq	.+58     	; 0x68cc <Endpoint_Read_Control_Stream_LE+0xba>
    6892:	85 30       	cpi	r24, 0x05	; 5
    6894:	e9 f0       	breq	.+58     	; 0x68d0 <Endpoint_Read_Control_Stream_LE+0xbe>
    6896:	80 81       	ld	r24, Z
    6898:	83 fd       	sbrc	r24, 3
    689a:	1c c0       	rjmp	.+56     	; 0x68d4 <Endpoint_Read_Control_Stream_LE+0xc2>
    689c:	80 81       	ld	r24, Z
    689e:	82 fd       	sbrc	r24, 2
    68a0:	1f c0       	rjmp	.+62     	; 0x68e0 <Endpoint_Read_Control_Stream_LE+0xce>
    68a2:	d2 cf       	rjmp	.-92     	; 0x6848 <Endpoint_Read_Control_Stream_LE+0x36>
    68a4:	80 91 4e 0a 	lds	r24, 0x0A4E
    68a8:	88 23       	and	r24, r24
    68aa:	b1 f0       	breq	.+44     	; 0x68d8 <Endpoint_Read_Control_Stream_LE+0xc6>
    68ac:	85 30       	cpi	r24, 0x05	; 5
    68ae:	19 f4       	brne	.+6      	; 0x68b6 <Endpoint_Read_Control_Stream_LE+0xa4>
    68b0:	15 c0       	rjmp	.+42     	; 0x68dc <Endpoint_Read_Control_Stream_LE+0xca>
    68b2:	e8 ee       	ldi	r30, 0xE8	; 232
    68b4:	f0 e0       	ldi	r31, 0x00	; 0
    68b6:	80 81       	ld	r24, Z
    68b8:	80 ff       	sbrs	r24, 0
    68ba:	f4 cf       	rjmp	.-24     	; 0x68a4 <Endpoint_Read_Control_Stream_LE+0x92>
    68bc:	80 e0       	ldi	r24, 0x00	; 0
    68be:	1a c0       	rjmp	.+52     	; 0x68f4 <Endpoint_Read_Control_Stream_LE+0xe2>
    68c0:	82 e0       	ldi	r24, 0x02	; 2
    68c2:	18 c0       	rjmp	.+48     	; 0x68f4 <Endpoint_Read_Control_Stream_LE+0xe2>
    68c4:	83 e0       	ldi	r24, 0x03	; 3
    68c6:	16 c0       	rjmp	.+44     	; 0x68f4 <Endpoint_Read_Control_Stream_LE+0xe2>
    68c8:	81 e0       	ldi	r24, 0x01	; 1
    68ca:	14 c0       	rjmp	.+40     	; 0x68f4 <Endpoint_Read_Control_Stream_LE+0xe2>
    68cc:	82 e0       	ldi	r24, 0x02	; 2
    68ce:	12 c0       	rjmp	.+36     	; 0x68f4 <Endpoint_Read_Control_Stream_LE+0xe2>
    68d0:	83 e0       	ldi	r24, 0x03	; 3
    68d2:	10 c0       	rjmp	.+32     	; 0x68f4 <Endpoint_Read_Control_Stream_LE+0xe2>
    68d4:	81 e0       	ldi	r24, 0x01	; 1
    68d6:	0e c0       	rjmp	.+28     	; 0x68f4 <Endpoint_Read_Control_Stream_LE+0xe2>
    68d8:	82 e0       	ldi	r24, 0x02	; 2
    68da:	0c c0       	rjmp	.+24     	; 0x68f4 <Endpoint_Read_Control_Stream_LE+0xe2>
    68dc:	83 e0       	ldi	r24, 0x03	; 3
    68de:	0a c0       	rjmp	.+20     	; 0x68f4 <Endpoint_Read_Control_Stream_LE+0xe2>
    68e0:	e9 01       	movw	r28, r18
    68e2:	18 81       	ld	r17, Y
    68e4:	e7 01       	movw	r28, r14
    68e6:	88 81       	ld	r24, Y
    68e8:	90 e0       	ldi	r25, 0x00	; 0
    68ea:	91 2b       	or	r25, r17
    68ec:	89 2b       	or	r24, r25
    68ee:	09 f0       	breq	.+2      	; 0x68f2 <Endpoint_Read_Control_Stream_LE+0xe0>
    68f0:	b8 cf       	rjmp	.-144    	; 0x6862 <Endpoint_Read_Control_Stream_LE+0x50>
    68f2:	c5 cf       	rjmp	.-118    	; 0x687e <Endpoint_Read_Control_Stream_LE+0x6c>
    68f4:	df 91       	pop	r29
    68f6:	cf 91       	pop	r28
    68f8:	1f 91       	pop	r17
    68fa:	ff 90       	pop	r15
    68fc:	ef 90       	pop	r14
    68fe:	08 95       	ret

00006900 <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    6900:	cf 92       	push	r12
    6902:	df 92       	push	r13
    6904:	ff 92       	push	r15
    6906:	0f 93       	push	r16
    6908:	1f 93       	push	r17
    690a:	cf 93       	push	r28
    690c:	df 93       	push	r29
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    690e:	20 91 55 0a 	lds	r18, 0x0A55
    6912:	30 91 56 0a 	lds	r19, 0x0A56
    6916:	26 17       	cp	r18, r22
    6918:	37 07       	cpc	r19, r23
    691a:	58 f0       	brcs	.+22     	; 0x6932 <Endpoint_Write_Control_PStream_LE+0x32>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    691c:	61 15       	cp	r22, r1
    691e:	71 05       	cpc	r23, r1
    6920:	39 f4       	brne	.+14     	; 0x6930 <Endpoint_Write_Control_PStream_LE+0x30>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6922:	e8 ee       	ldi	r30, 0xE8	; 232
    6924:	f0 e0       	ldi	r31, 0x00	; 0
    6926:	20 81       	ld	r18, Z
    6928:	2e 77       	andi	r18, 0x7E	; 126
    692a:	20 83       	st	Z, r18
    692c:	9b 01       	movw	r18, r22
    692e:	01 c0       	rjmp	.+2      	; 0x6932 <Endpoint_Write_Control_PStream_LE+0x32>
    6930:	9b 01       	movw	r18, r22
    6932:	e8 2f       	mov	r30, r24
    6934:	f9 2f       	mov	r31, r25
    6936:	10 e0       	ldi	r17, 0x00	; 0
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6938:	a8 ee       	ldi	r26, 0xE8	; 232
    693a:	b0 e0       	ldi	r27, 0x00	; 0
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
    693c:	63 ef       	ldi	r22, 0xF3	; 243
    693e:	70 e0       	ldi	r23, 0x00	; 0
    6940:	42 ef       	ldi	r20, 0xF2	; 242
    6942:	50 e0       	ldi	r21, 0x00	; 0
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    6944:	0f 2e       	mov	r0, r31
    6946:	f1 ef       	ldi	r31, 0xF1	; 241
    6948:	cf 2e       	mov	r12, r31
    694a:	d1 2c       	mov	r13, r1
    694c:	f0 2d       	mov	r31, r0
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    694e:	01 e0       	ldi	r16, 0x01	; 1
    6950:	f1 2c       	mov	r15, r1
    6952:	31 c0       	rjmp	.+98     	; 0x69b6 <Endpoint_Write_Control_PStream_LE+0xb6>
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    6954:	80 91 4e 0a 	lds	r24, 0x0A4E

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    6958:	88 23       	and	r24, r24
    695a:	09 f4       	brne	.+2      	; 0x695e <Endpoint_Write_Control_PStream_LE+0x5e>
    695c:	43 c0       	rjmp	.+134    	; 0x69e4 <Endpoint_Write_Control_PStream_LE+0xe4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    695e:	85 30       	cpi	r24, 0x05	; 5
    6960:	09 f4       	brne	.+2      	; 0x6964 <Endpoint_Write_Control_PStream_LE+0x64>
    6962:	42 c0       	rjmp	.+132    	; 0x69e8 <Endpoint_Write_Control_PStream_LE+0xe8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6964:	8c 91       	ld	r24, X
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    6966:	83 fd       	sbrc	r24, 3
    6968:	41 c0       	rjmp	.+130    	; 0x69ec <Endpoint_Write_Control_PStream_LE+0xec>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    696a:	8c 91       	ld	r24, X
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    696c:	82 fd       	sbrc	r24, 2
    696e:	33 c0       	rjmp	.+102    	; 0x69d6 <Endpoint_Write_Control_PStream_LE+0xd6>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6970:	8c 91       	ld	r24, X
		  break;

		if (Endpoint_IsINReady())
    6972:	80 ff       	sbrs	r24, 0
    6974:	20 c0       	rjmp	.+64     	; 0x69b6 <Endpoint_Write_Control_PStream_LE+0xb6>
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
    6976:	eb 01       	movw	r28, r22
    6978:	18 81       	ld	r17, Y
    697a:	ea 01       	movw	r28, r20
    697c:	88 81       	ld	r24, Y
    697e:	90 e0       	ldi	r25, 0x00	; 0
    6980:	91 2b       	or	r25, r17
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    6982:	21 15       	cp	r18, r1
    6984:	31 05       	cpc	r19, r1
    6986:	81 f0       	breq	.+32     	; 0x69a8 <Endpoint_Write_Control_PStream_LE+0xa8>
    6988:	88 30       	cpi	r24, 0x08	; 8
    698a:	91 05       	cpc	r25, r1
    698c:	68 f4       	brcc	.+26     	; 0x69a8 <Endpoint_Write_Control_PStream_LE+0xa8>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    698e:	14 91       	lpm	r17, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    6990:	e6 01       	movw	r28, r12
    6992:	18 83       	st	Y, r17
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    6994:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    6996:	21 50       	subi	r18, 0x01	; 1
    6998:	31 09       	sbc	r19, r1
				BytesInEndpoint++;
    699a:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    699c:	21 15       	cp	r18, r1
    699e:	31 05       	cpc	r19, r1
    69a0:	19 f0       	breq	.+6      	; 0x69a8 <Endpoint_Write_Control_PStream_LE+0xa8>
    69a2:	88 30       	cpi	r24, 0x08	; 8
    69a4:	91 05       	cpc	r25, r1
    69a6:	99 f7       	brne	.-26     	; 0x698e <Endpoint_Write_Control_PStream_LE+0x8e>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    69a8:	10 2f       	mov	r17, r16
    69aa:	08 97       	sbiw	r24, 0x08	; 8
    69ac:	09 f0       	breq	.+2      	; 0x69b0 <Endpoint_Write_Control_PStream_LE+0xb0>
    69ae:	1f 2d       	mov	r17, r15
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    69b0:	8c 91       	ld	r24, X
    69b2:	8e 77       	andi	r24, 0x7E	; 126
    69b4:	8c 93       	st	X, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    69b6:	21 15       	cp	r18, r1
    69b8:	31 05       	cpc	r19, r1
    69ba:	61 f6       	brne	.-104    	; 0x6954 <Endpoint_Write_Control_PStream_LE+0x54>
    69bc:	11 11       	cpse	r17, r1
    69be:	ca cf       	rjmp	.-108    	; 0x6954 <Endpoint_Write_Control_PStream_LE+0x54>
    69c0:	0a c0       	rjmp	.+20     	; 0x69d6 <Endpoint_Write_Control_PStream_LE+0xd6>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    69c2:	80 91 4e 0a 	lds	r24, 0x0A4E

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    69c6:	88 23       	and	r24, r24
    69c8:	99 f0       	breq	.+38     	; 0x69f0 <Endpoint_Write_Control_PStream_LE+0xf0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    69ca:	85 30       	cpi	r24, 0x05	; 5
    69cc:	99 f0       	breq	.+38     	; 0x69f4 <Endpoint_Write_Control_PStream_LE+0xf4>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    69ce:	80 81       	ld	r24, Z
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    69d0:	83 ff       	sbrs	r24, 3
    69d2:	03 c0       	rjmp	.+6      	; 0x69da <Endpoint_Write_Control_PStream_LE+0xda>
    69d4:	11 c0       	rjmp	.+34     	; 0x69f8 <Endpoint_Write_Control_PStream_LE+0xf8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    69d6:	e8 ee       	ldi	r30, 0xE8	; 232
    69d8:	f0 e0       	ldi	r31, 0x00	; 0
    69da:	80 81       	ld	r24, Z
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    69dc:	82 ff       	sbrs	r24, 2
    69de:	f1 cf       	rjmp	.-30     	; 0x69c2 <Endpoint_Write_Control_PStream_LE+0xc2>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    69e0:	80 e0       	ldi	r24, 0x00	; 0
    69e2:	0b c0       	rjmp	.+22     	; 0x69fa <Endpoint_Write_Control_PStream_LE+0xfa>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    69e4:	82 e0       	ldi	r24, 0x02	; 2
    69e6:	09 c0       	rjmp	.+18     	; 0x69fa <Endpoint_Write_Control_PStream_LE+0xfa>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    69e8:	83 e0       	ldi	r24, 0x03	; 3
    69ea:	07 c0       	rjmp	.+14     	; 0x69fa <Endpoint_Write_Control_PStream_LE+0xfa>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    69ec:	81 e0       	ldi	r24, 0x01	; 1
    69ee:	05 c0       	rjmp	.+10     	; 0x69fa <Endpoint_Write_Control_PStream_LE+0xfa>
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    69f0:	82 e0       	ldi	r24, 0x02	; 2
    69f2:	03 c0       	rjmp	.+6      	; 0x69fa <Endpoint_Write_Control_PStream_LE+0xfa>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    69f4:	83 e0       	ldi	r24, 0x03	; 3
    69f6:	01 c0       	rjmp	.+2      	; 0x69fa <Endpoint_Write_Control_PStream_LE+0xfa>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    69f8:	81 e0       	ldi	r24, 0x01	; 1
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    69fa:	df 91       	pop	r29
    69fc:	cf 91       	pop	r28
    69fe:	1f 91       	pop	r17
    6a00:	0f 91       	pop	r16
    6a02:	ff 90       	pop	r15
    6a04:	df 90       	pop	r13
    6a06:	cf 90       	pop	r12
    6a08:	08 95       	ret

00006a0a <Endpoint_ConfigureEndpoint_Prv>:
		UEIENX  = 0;
		UEINTX  = 0;
		UECFG1X = 0;
		Endpoint_DisableEndpoint();
	}
}
    6a0a:	8f 92       	push	r8
    6a0c:	9f 92       	push	r9
    6a0e:	bf 92       	push	r11
    6a10:	cf 92       	push	r12
    6a12:	df 92       	push	r13
    6a14:	ef 92       	push	r14
    6a16:	ff 92       	push	r15
    6a18:	0f 93       	push	r16
    6a1a:	1f 93       	push	r17
    6a1c:	cf 93       	push	r28
    6a1e:	df 93       	push	r29
    6a20:	87 30       	cpi	r24, 0x07	; 7
    6a22:	70 f1       	brcs	.+92     	; 0x6a80 <Endpoint_ConfigureEndpoint_Prv+0x76>
    6a24:	26 c0       	rjmp	.+76     	; 0x6a72 <Endpoint_ConfigureEndpoint_Prv+0x68>
    6a26:	29 2f       	mov	r18, r25
    6a28:	2f 70       	andi	r18, 0x0F	; 15
    6a2a:	e7 01       	movw	r28, r14
    6a2c:	28 83       	st	Y, r18
    6a2e:	89 17       	cp	r24, r25
    6a30:	31 f0       	breq	.+12     	; 0x6a3e <Endpoint_ConfigureEndpoint_Prv+0x34>
    6a32:	e8 01       	movw	r28, r16
    6a34:	78 81       	ld	r23, Y
    6a36:	20 81       	ld	r18, Z
    6a38:	e4 01       	movw	r28, r8
    6a3a:	58 81       	ld	r21, Y
    6a3c:	03 c0       	rjmp	.+6      	; 0x6a44 <Endpoint_ConfigureEndpoint_Prv+0x3a>
    6a3e:	24 2f       	mov	r18, r20
    6a40:	76 2f       	mov	r23, r22
    6a42:	5b 2d       	mov	r21, r11
    6a44:	21 ff       	sbrs	r18, 1
    6a46:	12 c0       	rjmp	.+36     	; 0x6a6c <Endpoint_ConfigureEndpoint_Prv+0x62>
    6a48:	3c 91       	ld	r19, X
    6a4a:	3e 7f       	andi	r19, 0xFE	; 254
    6a4c:	3c 93       	st	X, r19
    6a4e:	30 81       	ld	r19, Z
    6a50:	3d 7f       	andi	r19, 0xFD	; 253
    6a52:	30 83       	st	Z, r19
    6a54:	3c 91       	ld	r19, X
    6a56:	31 60       	ori	r19, 0x01	; 1
    6a58:	3c 93       	st	X, r19
    6a5a:	e8 01       	movw	r28, r16
    6a5c:	78 83       	st	Y, r23
    6a5e:	20 83       	st	Z, r18
    6a60:	e4 01       	movw	r28, r8
    6a62:	58 83       	st	Y, r21
    6a64:	e6 01       	movw	r28, r12
    6a66:	28 81       	ld	r18, Y
    6a68:	22 23       	and	r18, r18
    6a6a:	44 f4       	brge	.+16     	; 0x6a7c <Endpoint_ConfigureEndpoint_Prv+0x72>
    6a6c:	9f 5f       	subi	r25, 0xFF	; 255
    6a6e:	97 30       	cpi	r25, 0x07	; 7
    6a70:	d1 f6       	brne	.-76     	; 0x6a26 <Endpoint_ConfigureEndpoint_Prv+0x1c>
    6a72:	8f 70       	andi	r24, 0x0F	; 15
    6a74:	80 93 e9 00 	sts	0x00E9, r24
    6a78:	81 e0       	ldi	r24, 0x01	; 1
    6a7a:	21 c0       	rjmp	.+66     	; 0x6abe <Endpoint_ConfigureEndpoint_Prv+0xb4>
    6a7c:	80 e0       	ldi	r24, 0x00	; 0
    6a7e:	1f c0       	rjmp	.+62     	; 0x6abe <Endpoint_ConfigureEndpoint_Prv+0xb4>
    6a80:	98 2f       	mov	r25, r24
    6a82:	9f 70       	andi	r25, 0x0F	; 15
    6a84:	90 93 e9 00 	sts	0x00E9, r25
    6a88:	98 2f       	mov	r25, r24
    6a8a:	24 2f       	mov	r18, r20
    6a8c:	76 2f       	mov	r23, r22
    6a8e:	50 e0       	ldi	r21, 0x00	; 0
    6a90:	ab ee       	ldi	r26, 0xEB	; 235
    6a92:	b0 e0       	ldi	r27, 0x00	; 0
    6a94:	ed ee       	ldi	r30, 0xED	; 237
    6a96:	f0 e0       	ldi	r31, 0x00	; 0
    6a98:	0c ee       	ldi	r16, 0xEC	; 236
    6a9a:	10 e0       	ldi	r17, 0x00	; 0
    6a9c:	0f 2e       	mov	r0, r31
    6a9e:	f0 ef       	ldi	r31, 0xF0	; 240
    6aa0:	8f 2e       	mov	r8, r31
    6aa2:	91 2c       	mov	r9, r1
    6aa4:	f0 2d       	mov	r31, r0
    6aa6:	0f 2e       	mov	r0, r31
    6aa8:	fe ee       	ldi	r31, 0xEE	; 238
    6aaa:	cf 2e       	mov	r12, r31
    6aac:	d1 2c       	mov	r13, r1
    6aae:	f0 2d       	mov	r31, r0
    6ab0:	0f 2e       	mov	r0, r31
    6ab2:	f9 ee       	ldi	r31, 0xE9	; 233
    6ab4:	ef 2e       	mov	r14, r31
    6ab6:	f1 2c       	mov	r15, r1
    6ab8:	f0 2d       	mov	r31, r0
    6aba:	b1 2c       	mov	r11, r1
    6abc:	c3 cf       	rjmp	.-122    	; 0x6a44 <Endpoint_ConfigureEndpoint_Prv+0x3a>
    6abe:	df 91       	pop	r29
    6ac0:	cf 91       	pop	r28
    6ac2:	1f 91       	pop	r17
    6ac4:	0f 91       	pop	r16
    6ac6:	ff 90       	pop	r15
    6ac8:	ef 90       	pop	r14
    6aca:	df 90       	pop	r13
    6acc:	cf 90       	pop	r12
    6ace:	bf 90       	pop	r11
    6ad0:	9f 90       	pop	r9
    6ad2:	8f 90       	pop	r8
    6ad4:	08 95       	ret

00006ad6 <Endpoint_ConfigureEndpointTable>:
    6ad6:	9f 92       	push	r9
    6ad8:	af 92       	push	r10
    6ada:	bf 92       	push	r11
    6adc:	cf 92       	push	r12
    6ade:	df 92       	push	r13
    6ae0:	ef 92       	push	r14
    6ae2:	ff 92       	push	r15
    6ae4:	0f 93       	push	r16
    6ae6:	1f 93       	push	r17
    6ae8:	cf 93       	push	r28
    6aea:	df 93       	push	r29
    6aec:	66 23       	and	r22, r22
    6aee:	09 f4       	brne	.+2      	; 0x6af2 <Endpoint_ConfigureEndpointTable+0x1c>
    6af0:	49 c0       	rjmp	.+146    	; 0x6b84 <Endpoint_ConfigureEndpointTable+0xae>
    6af2:	e6 2e       	mov	r14, r22
    6af4:	8c 01       	movw	r16, r24
    6af6:	ec 01       	movw	r28, r24
    6af8:	0c 5f       	subi	r16, 0xFC	; 252
    6afa:	1f 4f       	sbci	r17, 0xFF	; 255
    6afc:	f1 2c       	mov	r15, r1
    6afe:	d1 2c       	mov	r13, r1
    6b00:	68 94       	set
    6b02:	bb 24       	eor	r11, r11
    6b04:	b3 f8       	bld	r11, 3
    6b06:	c1 2c       	mov	r12, r1
    6b08:	0f 2e       	mov	r0, r31
    6b0a:	f6 e0       	ldi	r31, 0x06	; 6
    6b0c:	af 2e       	mov	r10, r31
    6b0e:	f0 2d       	mov	r31, r0
    6b10:	68 94       	set
    6b12:	99 24       	eor	r9, r9
    6b14:	91 f8       	bld	r9, 1
    6b16:	58 81       	ld	r21, Y
    6b18:	55 23       	and	r21, r21
    6b1a:	61 f1       	breq	.+88     	; 0x6b74 <Endpoint_ConfigureEndpointTable+0x9e>
    6b1c:	f8 01       	movw	r30, r16
    6b1e:	90 81       	ld	r25, Z
    6b20:	e9 81       	ldd	r30, Y+1	; 0x01
    6b22:	fa 81       	ldd	r31, Y+2	; 0x02
    6b24:	d8 01       	movw	r26, r16
    6b26:	11 97       	sbiw	r26, 0x01	; 1
    6b28:	6c 91       	ld	r22, X
    6b2a:	85 2f       	mov	r24, r21
    6b2c:	8f 70       	andi	r24, 0x0F	; 15
    6b2e:	87 30       	cpi	r24, 0x07	; 7
    6b30:	58 f5       	brcc	.+86     	; 0x6b88 <Endpoint_ConfigureEndpointTable+0xb2>
    6b32:	92 30       	cpi	r25, 0x02	; 2
    6b34:	10 f4       	brcc	.+4      	; 0x6b3a <Endpoint_ConfigureEndpointTable+0x64>
    6b36:	49 2d       	mov	r20, r9
    6b38:	01 c0       	rjmp	.+2      	; 0x6b3c <Endpoint_ConfigureEndpointTable+0x66>
    6b3a:	4a 2d       	mov	r20, r10
    6b3c:	e9 30       	cpi	r30, 0x09	; 9
    6b3e:	f1 05       	cpc	r31, r1
    6b40:	50 f0       	brcs	.+20     	; 0x6b56 <Endpoint_ConfigureEndpointTable+0x80>
    6b42:	2b 2d       	mov	r18, r11
    6b44:	3c 2d       	mov	r19, r12
    6b46:	9d 2d       	mov	r25, r13
    6b48:	9f 5f       	subi	r25, 0xFF	; 255
    6b4a:	22 0f       	add	r18, r18
    6b4c:	33 1f       	adc	r19, r19
    6b4e:	2e 17       	cp	r18, r30
    6b50:	3f 07       	cpc	r19, r31
    6b52:	d0 f3       	brcs	.-12     	; 0x6b48 <Endpoint_ConfigureEndpointTable+0x72>
    6b54:	01 c0       	rjmp	.+2      	; 0x6b58 <Endpoint_ConfigureEndpointTable+0x82>
    6b56:	9d 2d       	mov	r25, r13
    6b58:	92 95       	swap	r25
    6b5a:	90 7f       	andi	r25, 0xF0	; 240
    6b5c:	49 2b       	or	r20, r25
    6b5e:	f0 e4       	ldi	r31, 0x40	; 64
    6b60:	6f 9f       	mul	r22, r31
    6b62:	b0 01       	movw	r22, r0
    6b64:	11 24       	eor	r1, r1
    6b66:	55 1f       	adc	r21, r21
    6b68:	55 27       	eor	r21, r21
    6b6a:	55 1f       	adc	r21, r21
    6b6c:	65 2b       	or	r22, r21
    6b6e:	4d df       	rcall	.-358    	; 0x6a0a <Endpoint_ConfigureEndpoint_Prv>
    6b70:	88 23       	and	r24, r24
    6b72:	59 f0       	breq	.+22     	; 0x6b8a <Endpoint_ConfigureEndpointTable+0xb4>
    6b74:	f3 94       	inc	r15
    6b76:	25 96       	adiw	r28, 0x05	; 5
    6b78:	0b 5f       	subi	r16, 0xFB	; 251
    6b7a:	1f 4f       	sbci	r17, 0xFF	; 255
    6b7c:	fe 10       	cpse	r15, r14
    6b7e:	cb cf       	rjmp	.-106    	; 0x6b16 <Endpoint_ConfigureEndpointTable+0x40>
    6b80:	81 e0       	ldi	r24, 0x01	; 1
    6b82:	03 c0       	rjmp	.+6      	; 0x6b8a <Endpoint_ConfigureEndpointTable+0xb4>
    6b84:	81 e0       	ldi	r24, 0x01	; 1
    6b86:	01 c0       	rjmp	.+2      	; 0x6b8a <Endpoint_ConfigureEndpointTable+0xb4>
    6b88:	80 e0       	ldi	r24, 0x00	; 0
    6b8a:	df 91       	pop	r29
    6b8c:	cf 91       	pop	r28
    6b8e:	1f 91       	pop	r17
    6b90:	0f 91       	pop	r16
    6b92:	ff 90       	pop	r15
    6b94:	ef 90       	pop	r14
    6b96:	df 90       	pop	r13
    6b98:	cf 90       	pop	r12
    6b9a:	bf 90       	pop	r11
    6b9c:	af 90       	pop	r10
    6b9e:	9f 90       	pop	r9
    6ba0:	08 95       	ret

00006ba2 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    6ba2:	80 91 4f 0a 	lds	r24, 0x0A4F
    6ba6:	88 23       	and	r24, r24
    6ba8:	44 f0       	brlt	.+16     	; 0x6bba <Endpoint_ClearStatusStage+0x18>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6baa:	e8 ee       	ldi	r30, 0xE8	; 232
    6bac:	f0 e0       	ldi	r31, 0x00	; 0
    6bae:	14 c0       	rjmp	.+40     	; 0x6bd8 <Endpoint_ClearStatusStage+0x36>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    6bb0:	80 91 4e 0a 	lds	r24, 0x0A4E
    6bb4:	81 11       	cpse	r24, r1
    6bb6:	03 c0       	rjmp	.+6      	; 0x6bbe <Endpoint_ClearStatusStage+0x1c>
    6bb8:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6bba:	e8 ee       	ldi	r30, 0xE8	; 232
    6bbc:	f0 e0       	ldi	r31, 0x00	; 0
    6bbe:	80 81       	ld	r24, Z

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    6bc0:	82 ff       	sbrs	r24, 2
    6bc2:	f6 cf       	rjmp	.-20     	; 0x6bb0 <Endpoint_ClearStatusStage+0xe>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6bc4:	e8 ee       	ldi	r30, 0xE8	; 232
    6bc6:	f0 e0       	ldi	r31, 0x00	; 0
    6bc8:	80 81       	ld	r24, Z
    6bca:	8b 77       	andi	r24, 0x7B	; 123
    6bcc:	80 83       	st	Z, r24
    6bce:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    6bd0:	80 91 4e 0a 	lds	r24, 0x0A4E
    6bd4:	88 23       	and	r24, r24
    6bd6:	41 f0       	breq	.+16     	; 0x6be8 <Endpoint_ClearStatusStage+0x46>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6bd8:	80 81       	ld	r24, Z

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    6bda:	80 ff       	sbrs	r24, 0
    6bdc:	f9 cf       	rjmp	.-14     	; 0x6bd0 <Endpoint_ClearStatusStage+0x2e>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6bde:	e8 ee       	ldi	r30, 0xE8	; 232
    6be0:	f0 e0       	ldi	r31, 0x00	; 0
    6be2:	80 81       	ld	r24, Z
    6be4:	8e 77       	andi	r24, 0x7E	; 126
    6be6:	80 83       	st	Z, r24
    6be8:	08 95       	ret

00006bea <Endpoint_WaitUntilReady>:
	}
}

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
    6bea:	0f 93       	push	r16
    6bec:	1f 93       	push	r17
    6bee:	cf 93       	push	r28
    6bf0:	df 93       	push	r29
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    6bf2:	20 91 e4 00 	lds	r18, 0x00E4
    6bf6:	30 91 e5 00 	lds	r19, 0x00E5
    6bfa:	65 e6       	ldi	r22, 0x65	; 101
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    6bfc:	ac ee       	ldi	r26, 0xEC	; 236
    6bfe:	b0 e0       	ldi	r27, 0x00	; 0
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6c00:	e8 ee       	ldi	r30, 0xE8	; 232
    6c02:	f0 e0       	ldi	r31, 0x00	; 0
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    6c04:	0b ee       	ldi	r16, 0xEB	; 235
    6c06:	10 e0       	ldi	r17, 0x00	; 0
    6c08:	44 ee       	ldi	r20, 0xE4	; 228
    6c0a:	50 e0       	ldi	r21, 0x00	; 0
    6c0c:	01 c0       	rjmp	.+2      	; 0x6c10 <Endpoint_WaitUntilReady+0x26>
    6c0e:	9c 01       	movw	r18, r24
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    6c10:	9c 91       	ld	r25, X
    6c12:	89 2f       	mov	r24, r25
    6c14:	81 70       	andi	r24, 0x01	; 1
    6c16:	90 fd       	sbrc	r25, 0
    6c18:	1d c0       	rjmp	.+58     	; 0x6c54 <Endpoint_WaitUntilReady+0x6a>
    6c1a:	20 c0       	rjmp	.+64     	; 0x6c5c <Endpoint_WaitUntilReady+0x72>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    6c1c:	80 91 4e 0a 	lds	r24, 0x0A4E

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    6c20:	88 23       	and	r24, r24
    6c22:	81 f0       	breq	.+32     	; 0x6c44 <Endpoint_WaitUntilReady+0x5a>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    6c24:	85 30       	cpi	r24, 0x05	; 5
    6c26:	81 f0       	breq	.+32     	; 0x6c48 <Endpoint_WaitUntilReady+0x5e>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    6c28:	e8 01       	movw	r28, r16
    6c2a:	88 81       	ld	r24, Y
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    6c2c:	85 fd       	sbrc	r24, 5
    6c2e:	0e c0       	rjmp	.+28     	; 0x6c4c <Endpoint_WaitUntilReady+0x62>
    6c30:	ea 01       	movw	r28, r20
    6c32:	88 81       	ld	r24, Y
    6c34:	99 81       	ldd	r25, Y+1	; 0x01
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    6c36:	28 17       	cp	r18, r24
    6c38:	39 07       	cpc	r19, r25
    6c3a:	51 f3       	breq	.-44     	; 0x6c10 <Endpoint_WaitUntilReady+0x26>
    6c3c:	61 50       	subi	r22, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    6c3e:	39 f7       	brne	.-50     	; 0x6c0e <Endpoint_WaitUntilReady+0x24>
			  return ENDPOINT_READYWAIT_Timeout;
    6c40:	84 e0       	ldi	r24, 0x04	; 4
    6c42:	0f c0       	rjmp	.+30     	; 0x6c62 <Endpoint_WaitUntilReady+0x78>
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    6c44:	82 e0       	ldi	r24, 0x02	; 2
    6c46:	0d c0       	rjmp	.+26     	; 0x6c62 <Endpoint_WaitUntilReady+0x78>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    6c48:	83 e0       	ldi	r24, 0x03	; 3
    6c4a:	0b c0       	rjmp	.+22     	; 0x6c62 <Endpoint_WaitUntilReady+0x78>
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    6c4c:	81 e0       	ldi	r24, 0x01	; 1
    6c4e:	09 c0       	rjmp	.+18     	; 0x6c62 <Endpoint_WaitUntilReady+0x78>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    6c50:	80 e0       	ldi	r24, 0x00	; 0
    6c52:	07 c0       	rjmp	.+14     	; 0x6c62 <Endpoint_WaitUntilReady+0x78>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6c54:	80 81       	ld	r24, Z

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    6c56:	80 ff       	sbrs	r24, 0
    6c58:	e1 cf       	rjmp	.-62     	; 0x6c1c <Endpoint_WaitUntilReady+0x32>
    6c5a:	fa cf       	rjmp	.-12     	; 0x6c50 <Endpoint_WaitUntilReady+0x66>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6c5c:	90 81       	ld	r25, Z
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    6c5e:	92 ff       	sbrs	r25, 2
    6c60:	dd cf       	rjmp	.-70     	; 0x6c1c <Endpoint_WaitUntilReady+0x32>

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    6c62:	df 91       	pop	r29
    6c64:	cf 91       	pop	r28
    6c66:	1f 91       	pop	r17
    6c68:	0f 91       	pop	r16
    6c6a:	08 95       	ret

00006c6c <USB_Disable>:
	USB_ResetInterface();
}

void USB_Disable(void)
{
	USB_INT_DisableAllInterrupts();
    6c6c:	68 d0       	rcall	.+208    	; 0x6d3e <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    6c6e:	6f d0       	rcall	.+222    	; 0x6d4e <USB_INT_ClearAllInterrupts>
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    6c70:	e0 ee       	ldi	r30, 0xE0	; 224
    6c72:	f0 e0       	ldi	r31, 0x00	; 0
    6c74:	80 81       	ld	r24, Z
    6c76:	81 60       	ori	r24, 0x01	; 1
    6c78:	80 83       	st	Z, r24
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USBCON &= ~(1 << USBE);
    6c7a:	e8 ed       	ldi	r30, 0xD8	; 216
    6c7c:	f0 e0       	ldi	r31, 0x00	; 0
    6c7e:	80 81       	ld	r24, Z
    6c80:	8f 77       	andi	r24, 0x7F	; 127
    6c82:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    6c84:	19 bc       	out	0x29, r1	; 41

			static inline void USB_REG_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_Off(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON &= ~(1 << UVREGE);
    6c86:	a7 ed       	ldi	r26, 0xD7	; 215
    6c88:	b0 e0       	ldi	r27, 0x00	; 0
    6c8a:	8c 91       	ld	r24, X
    6c8c:	8e 7f       	andi	r24, 0xFE	; 254
    6c8e:	8c 93       	st	X, r24
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    6c90:	80 81       	ld	r24, Z
    6c92:	8f 7e       	andi	r24, 0xEF	; 239
    6c94:	80 83       	st	Z, r24

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
    6c96:	10 92 4d 0a 	sts	0x0A4D, r1
    6c9a:	08 95       	ret

00006c9c <USB_ResetInterface>:
}

void USB_ResetInterface(void)
{
    6c9c:	0f 93       	push	r16
    6c9e:	1f 93       	push	r17
    6ca0:	cf 93       	push	r28
    6ca2:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    6ca4:	4c d0       	rcall	.+152    	; 0x6d3e <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    6ca6:	53 d0       	rcall	.+166    	; 0x6d4e <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    6ca8:	c8 ed       	ldi	r28, 0xD8	; 216
    6caa:	d0 e0       	ldi	r29, 0x00	; 0
    6cac:	88 81       	ld	r24, Y
    6cae:	8f 77       	andi	r24, 0x7F	; 127
    6cb0:	88 83       	st	Y, r24
				USBCON |=  (1 << USBE);
    6cb2:	88 81       	ld	r24, Y
    6cb4:	80 68       	ori	r24, 0x80	; 128
    6cb6:	88 83       	st	Y, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    6cb8:	88 81       	ld	r24, Y
    6cba:	8f 7d       	andi	r24, 0xDF	; 223
    6cbc:	88 83       	st	Y, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    6cbe:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    6cc0:	10 92 4e 0a 	sts	0x0A4E, r1
	USB_Device_ConfigurationNumber  = 0;
    6cc4:	10 92 4a 0a 	sts	0x0A4A, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    6cc8:	10 92 4c 0a 	sts	0x0A4C, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    6ccc:	10 92 4b 0a 	sts	0x0A4B, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    6cd0:	00 ee       	ldi	r16, 0xE0	; 224
    6cd2:	10 e0       	ldi	r17, 0x00	; 0
    6cd4:	f8 01       	movw	r30, r16
    6cd6:	80 81       	ld	r24, Z
    6cd8:	8b 7f       	andi	r24, 0xFB	; 251
    6cda:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    6cdc:	88 81       	ld	r24, Y
    6cde:	81 60       	ori	r24, 0x01	; 1
    6ce0:	88 83       	st	Y, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    6ce2:	42 e0       	ldi	r20, 0x02	; 2
    6ce4:	60 e0       	ldi	r22, 0x00	; 0
    6ce6:	80 e0       	ldi	r24, 0x00	; 0
    6ce8:	90 de       	rcall	.-736    	; 0x6a0a <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    6cea:	e1 ee       	ldi	r30, 0xE1	; 225
    6cec:	f0 e0       	ldi	r31, 0x00	; 0
    6cee:	80 81       	ld	r24, Z
    6cf0:	8e 7f       	andi	r24, 0xFE	; 254
    6cf2:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    6cf4:	e2 ee       	ldi	r30, 0xE2	; 226
    6cf6:	f0 e0       	ldi	r31, 0x00	; 0
    6cf8:	80 81       	ld	r24, Z
    6cfa:	81 60       	ori	r24, 0x01	; 1
    6cfc:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    6cfe:	80 81       	ld	r24, Z
    6d00:	88 60       	ori	r24, 0x08	; 8
    6d02:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    6d04:	f8 01       	movw	r30, r16
    6d06:	80 81       	ld	r24, Z
    6d08:	8e 7f       	andi	r24, 0xFE	; 254
    6d0a:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    6d0c:	88 81       	ld	r24, Y
    6d0e:	80 61       	ori	r24, 0x10	; 16
    6d10:	88 83       	st	Y, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    6d12:	df 91       	pop	r29
    6d14:	cf 91       	pop	r28
    6d16:	1f 91       	pop	r17
    6d18:	0f 91       	pop	r16
    6d1a:	08 95       	ret

00006d1c <USB_Init>:
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    6d1c:	e8 ed       	ldi	r30, 0xD8	; 216
    6d1e:	f0 e0       	ldi	r31, 0x00	; 0
    6d20:	80 81       	ld	r24, Z
    6d22:	8f 7e       	andi	r24, 0xEF	; 239
    6d24:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    6d26:	e7 ed       	ldi	r30, 0xD7	; 215
    6d28:	f0 e0       	ldi	r31, 0x00	; 0
    6d2a:	80 81       	ld	r24, Z
    6d2c:	81 60       	ori	r24, 0x01	; 1
    6d2e:	80 83       	st	Z, r24
	  USB_REG_Off();

	if (!(USB_Options & USB_OPT_MANUAL_PLL))
	{
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = (1 << PDIV2);
    6d30:	84 e0       	ldi	r24, 0x04	; 4
    6d32:	82 bf       	out	0x32, r24	; 50
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    6d34:	81 e0       	ldi	r24, 0x01	; 1
    6d36:	80 93 4d 0a 	sts	0x0A4D, r24

	USB_ResetInterface();
    6d3a:	b0 cf       	rjmp	.-160    	; 0x6c9c <USB_ResetInterface>
    6d3c:	08 95       	ret

00006d3e <USB_INT_DisableAllInterrupts>:
void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
    6d3e:	e8 ed       	ldi	r30, 0xD8	; 216
    6d40:	f0 e0       	ldi	r31, 0x00	; 0
    6d42:	80 81       	ld	r24, Z
    6d44:	8e 7f       	andi	r24, 0xFE	; 254
    6d46:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    6d48:	10 92 e2 00 	sts	0x00E2, r1
    6d4c:	08 95       	ret

00006d4e <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    6d4e:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    6d52:	10 92 e1 00 	sts	0x00E1, r1
    6d56:	08 95       	ret

00006d58 <__vector_10>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    6d58:	1f 92       	push	r1
    6d5a:	0f 92       	push	r0
    6d5c:	0f b6       	in	r0, 0x3f	; 63
    6d5e:	0f 92       	push	r0
    6d60:	11 24       	eor	r1, r1
    6d62:	2f 93       	push	r18
    6d64:	3f 93       	push	r19
    6d66:	4f 93       	push	r20
    6d68:	5f 93       	push	r21
    6d6a:	6f 93       	push	r22
    6d6c:	7f 93       	push	r23
    6d6e:	8f 93       	push	r24
    6d70:	9f 93       	push	r25
    6d72:	af 93       	push	r26
    6d74:	bf 93       	push	r27
    6d76:	ef 93       	push	r30
    6d78:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    6d7a:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    6d7e:	82 ff       	sbrs	r24, 2
    6d80:	0b c0       	rjmp	.+22     	; 0x6d98 <__vector_10+0x40>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    6d82:	80 91 e2 00 	lds	r24, 0x00E2
    6d86:	82 ff       	sbrs	r24, 2
    6d88:	07 c0       	rjmp	.+14     	; 0x6d98 <__vector_10+0x40>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    6d8a:	e1 ee       	ldi	r30, 0xE1	; 225
    6d8c:	f0 e0       	ldi	r31, 0x00	; 0
    6d8e:	80 81       	ld	r24, Z
    6d90:	8b 7f       	andi	r24, 0xFB	; 251
    6d92:	80 83       	st	Z, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    6d94:	0e 94 6f 27 	call	0x4ede	; 0x4ede <EVENT_USB_Device_StartOfFrame>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    6d98:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    6d9c:	80 ff       	sbrs	r24, 0
    6d9e:	1e c0       	rjmp	.+60     	; 0x6ddc <__vector_10+0x84>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    6da0:	80 91 d8 00 	lds	r24, 0x00D8
    6da4:	80 ff       	sbrs	r24, 0
    6da6:	1a c0       	rjmp	.+52     	; 0x6ddc <__vector_10+0x84>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    6da8:	ea ed       	ldi	r30, 0xDA	; 218
    6daa:	f0 e0       	ldi	r31, 0x00	; 0
    6dac:	80 81       	ld	r24, Z
    6dae:	8e 7f       	andi	r24, 0xFE	; 254
    6db0:	80 83       	st	Z, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    6db2:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    6db6:	80 ff       	sbrs	r24, 0
    6db8:	0c c0       	rjmp	.+24     	; 0x6dd2 <__vector_10+0x7a>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    6dba:	19 bc       	out	0x29, r1	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    6dbc:	82 e0       	ldi	r24, 0x02	; 2
    6dbe:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    6dc0:	09 b4       	in	r0, 0x29	; 41
    6dc2:	00 fe       	sbrs	r0, 0
    6dc4:	fd cf       	rjmp	.-6      	; 0x6dc0 <__vector_10+0x68>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    6dc6:	81 e0       	ldi	r24, 0x01	; 1
    6dc8:	80 93 4e 0a 	sts	0x0A4E, r24
			EVENT_USB_Device_Connect();
    6dcc:	0e 94 4f 27 	call	0x4e9e	; 0x4e9e <EVENT_USB_Device_Connect>
    6dd0:	05 c0       	rjmp	.+10     	; 0x6ddc <__vector_10+0x84>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    6dd2:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    6dd4:	10 92 4e 0a 	sts	0x0A4E, r1
			EVENT_USB_Device_Disconnect();
    6dd8:	0e 94 50 27 	call	0x4ea0	; 0x4ea0 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    6ddc:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    6de0:	80 ff       	sbrs	r24, 0
    6de2:	17 c0       	rjmp	.+46     	; 0x6e12 <__vector_10+0xba>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    6de4:	80 91 e2 00 	lds	r24, 0x00E2
    6de8:	80 ff       	sbrs	r24, 0
    6dea:	13 c0       	rjmp	.+38     	; 0x6e12 <__vector_10+0xba>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    6dec:	e2 ee       	ldi	r30, 0xE2	; 226
    6dee:	f0 e0       	ldi	r31, 0x00	; 0
    6df0:	80 81       	ld	r24, Z
    6df2:	8e 7f       	andi	r24, 0xFE	; 254
    6df4:	80 83       	st	Z, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    6df6:	80 81       	ld	r24, Z
    6df8:	80 61       	ori	r24, 0x10	; 16
    6dfa:	80 83       	st	Z, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    6dfc:	e8 ed       	ldi	r30, 0xD8	; 216
    6dfe:	f0 e0       	ldi	r31, 0x00	; 0
    6e00:	80 81       	ld	r24, Z
    6e02:	80 62       	ori	r24, 0x20	; 32
    6e04:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    6e06:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    6e08:	85 e0       	ldi	r24, 0x05	; 5
    6e0a:	80 93 4e 0a 	sts	0x0A4E, r24
		EVENT_USB_Device_Suspend();
    6e0e:	0e 94 57 27 	call	0x4eae	; 0x4eae <EVENT_USB_Device_Suspend>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    6e12:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    6e16:	84 ff       	sbrs	r24, 4
    6e18:	2f c0       	rjmp	.+94     	; 0x6e78 <__vector_10+0x120>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    6e1a:	80 91 e2 00 	lds	r24, 0x00E2
    6e1e:	84 ff       	sbrs	r24, 4
    6e20:	2b c0       	rjmp	.+86     	; 0x6e78 <__vector_10+0x120>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    6e22:	19 bc       	out	0x29, r1	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    6e24:	82 e0       	ldi	r24, 0x02	; 2
    6e26:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    6e28:	09 b4       	in	r0, 0x29	; 41
    6e2a:	00 fe       	sbrs	r0, 0
    6e2c:	fd cf       	rjmp	.-6      	; 0x6e28 <__vector_10+0xd0>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    6e2e:	e8 ed       	ldi	r30, 0xD8	; 216
    6e30:	f0 e0       	ldi	r31, 0x00	; 0
    6e32:	80 81       	ld	r24, Z
    6e34:	8f 7d       	andi	r24, 0xDF	; 223
    6e36:	80 83       	st	Z, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    6e38:	e1 ee       	ldi	r30, 0xE1	; 225
    6e3a:	f0 e0       	ldi	r31, 0x00	; 0
    6e3c:	80 81       	ld	r24, Z
    6e3e:	8f 7e       	andi	r24, 0xEF	; 239
    6e40:	80 83       	st	Z, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    6e42:	e2 ee       	ldi	r30, 0xE2	; 226
    6e44:	f0 e0       	ldi	r31, 0x00	; 0
    6e46:	80 81       	ld	r24, Z
    6e48:	8f 7e       	andi	r24, 0xEF	; 239
    6e4a:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    6e4c:	80 81       	ld	r24, Z
    6e4e:	81 60       	ori	r24, 0x01	; 1
    6e50:	80 83       	st	Z, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    6e52:	80 91 4a 0a 	lds	r24, 0x0A4A
    6e56:	88 23       	and	r24, r24
    6e58:	21 f0       	breq	.+8      	; 0x6e62 <__vector_10+0x10a>
		  USB_DeviceState = DEVICE_STATE_Configured;
    6e5a:	84 e0       	ldi	r24, 0x04	; 4
    6e5c:	80 93 4e 0a 	sts	0x0A4E, r24
    6e60:	09 c0       	rjmp	.+18     	; 0x6e74 <__vector_10+0x11c>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    6e62:	80 91 e3 00 	lds	r24, 0x00E3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    6e66:	88 23       	and	r24, r24
    6e68:	14 f0       	brlt	.+4      	; 0x6e6e <__vector_10+0x116>
    6e6a:	81 e0       	ldi	r24, 0x01	; 1
    6e6c:	01 c0       	rjmp	.+2      	; 0x6e70 <__vector_10+0x118>
    6e6e:	83 e0       	ldi	r24, 0x03	; 3
    6e70:	80 93 4e 0a 	sts	0x0A4E, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    6e74:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <EVENT_USB_Device_WakeUp>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    6e78:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    6e7c:	83 ff       	sbrs	r24, 3
    6e7e:	1e c0       	rjmp	.+60     	; 0x6ebc <__vector_10+0x164>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    6e80:	80 91 e2 00 	lds	r24, 0x00E2
    6e84:	83 ff       	sbrs	r24, 3
    6e86:	1a c0       	rjmp	.+52     	; 0x6ebc <__vector_10+0x164>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    6e88:	e1 ee       	ldi	r30, 0xE1	; 225
    6e8a:	f0 e0       	ldi	r31, 0x00	; 0
    6e8c:	80 81       	ld	r24, Z
    6e8e:	87 7f       	andi	r24, 0xF7	; 247
    6e90:	80 83       	st	Z, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    6e92:	82 e0       	ldi	r24, 0x02	; 2
    6e94:	80 93 4e 0a 	sts	0x0A4E, r24
		USB_Device_ConfigurationNumber = 0;
    6e98:	10 92 4a 0a 	sts	0x0A4A, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    6e9c:	80 81       	ld	r24, Z
    6e9e:	8e 7f       	andi	r24, 0xFE	; 254
    6ea0:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    6ea2:	e2 ee       	ldi	r30, 0xE2	; 226
    6ea4:	f0 e0       	ldi	r31, 0x00	; 0
    6ea6:	80 81       	ld	r24, Z
    6ea8:	8e 7f       	andi	r24, 0xFE	; 254
    6eaa:	80 83       	st	Z, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    6eac:	80 81       	ld	r24, Z
    6eae:	80 61       	ori	r24, 0x10	; 16
    6eb0:	80 83       	st	Z, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    6eb2:	42 e0       	ldi	r20, 0x02	; 2
    6eb4:	60 e0       	ldi	r22, 0x00	; 0
    6eb6:	80 e0       	ldi	r24, 0x00	; 0
    6eb8:	a8 dd       	rcall	.-1200   	; 0x6a0a <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    6eba:	81 d1       	rcall	.+770    	; 0x71be <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    6ebc:	ff 91       	pop	r31
    6ebe:	ef 91       	pop	r30
    6ec0:	bf 91       	pop	r27
    6ec2:	af 91       	pop	r26
    6ec4:	9f 91       	pop	r25
    6ec6:	8f 91       	pop	r24
    6ec8:	7f 91       	pop	r23
    6eca:	6f 91       	pop	r22
    6ecc:	5f 91       	pop	r21
    6ece:	4f 91       	pop	r20
    6ed0:	3f 91       	pop	r19
    6ed2:	2f 91       	pop	r18
    6ed4:	0f 90       	pop	r0
    6ed6:	0f be       	out	0x3f, r0	; 63
    6ed8:	0f 90       	pop	r0
    6eda:	1f 90       	pop	r1
    6edc:	18 95       	reti

00006ede <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    6ede:	0f 93       	push	r16
    6ee0:	1f 93       	push	r17
    6ee2:	cf 93       	push	r28
    6ee4:	df 93       	push	r29
    6ee6:	cd b7       	in	r28, 0x3d	; 61
    6ee8:	de b7       	in	r29, 0x3e	; 62
    6eea:	aa 97       	sbiw	r28, 0x2a	; 42
    6eec:	0f b6       	in	r0, 0x3f	; 63
    6eee:	f8 94       	cli
    6ef0:	de bf       	out	0x3e, r29	; 62
    6ef2:	0f be       	out	0x3f, r0	; 63
    6ef4:	cd bf       	out	0x3d, r28	; 61
    6ef6:	ef e4       	ldi	r30, 0x4F	; 79
    6ef8:	fa e0       	ldi	r31, 0x0A	; 10
    6efa:	27 e5       	ldi	r18, 0x57	; 87
    6efc:	3a e0       	ldi	r19, 0x0A	; 10
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    6efe:	a1 ef       	ldi	r26, 0xF1	; 241
    6f00:	b0 e0       	ldi	r27, 0x00	; 0
    6f02:	8c 91       	ld	r24, X
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    6f04:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    6f06:	e2 17       	cp	r30, r18
    6f08:	f3 07       	cpc	r31, r19
    6f0a:	d9 f7       	brne	.-10     	; 0x6f02 <USB_Device_ProcessControlRequest+0x24>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    6f0c:	0e 94 67 27 	call	0x4ece	; 0x4ece <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6f10:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    6f14:	83 ff       	sbrs	r24, 3
    6f16:	2e c1       	rjmp	.+604    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    6f18:	ef e4       	ldi	r30, 0x4F	; 79
    6f1a:	fa e0       	ldi	r31, 0x0A	; 10
    6f1c:	90 81       	ld	r25, Z

		switch (USB_ControlRequest.bRequest)
    6f1e:	81 81       	ldd	r24, Z+1	; 0x01
    6f20:	85 30       	cpi	r24, 0x05	; 5
    6f22:	09 f4       	brne	.+2      	; 0x6f26 <USB_Device_ProcessControlRequest+0x48>
    6f24:	79 c0       	rjmp	.+242    	; 0x7018 <USB_Device_ProcessControlRequest+0x13a>
    6f26:	30 f4       	brcc	.+12     	; 0x6f34 <USB_Device_ProcessControlRequest+0x56>
    6f28:	81 30       	cpi	r24, 0x01	; 1
    6f2a:	b1 f1       	breq	.+108    	; 0x6f98 <USB_Device_ProcessControlRequest+0xba>
    6f2c:	68 f0       	brcs	.+26     	; 0x6f48 <USB_Device_ProcessControlRequest+0x6a>
    6f2e:	83 30       	cpi	r24, 0x03	; 3
    6f30:	99 f1       	breq	.+102    	; 0x6f98 <USB_Device_ProcessControlRequest+0xba>
    6f32:	20 c1       	rjmp	.+576    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
    6f34:	88 30       	cpi	r24, 0x08	; 8
    6f36:	09 f4       	brne	.+2      	; 0x6f3a <USB_Device_ProcessControlRequest+0x5c>
    6f38:	ea c0       	rjmp	.+468    	; 0x710e <USB_Device_ProcessControlRequest+0x230>
    6f3a:	89 30       	cpi	r24, 0x09	; 9
    6f3c:	09 f4       	brne	.+2      	; 0x6f40 <USB_Device_ProcessControlRequest+0x62>
    6f3e:	f7 c0       	rjmp	.+494    	; 0x712e <USB_Device_ProcessControlRequest+0x250>
    6f40:	86 30       	cpi	r24, 0x06	; 6
    6f42:	09 f0       	breq	.+2      	; 0x6f46 <USB_Device_ProcessControlRequest+0x68>
    6f44:	17 c1       	rjmp	.+558    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
    6f46:	8b c0       	rjmp	.+278    	; 0x705e <USB_Device_ProcessControlRequest+0x180>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    6f48:	90 38       	cpi	r25, 0x80	; 128
    6f4a:	21 f0       	breq	.+8      	; 0x6f54 <USB_Device_ProcessControlRequest+0x76>
    6f4c:	92 38       	cpi	r25, 0x82	; 130
    6f4e:	09 f0       	breq	.+2      	; 0x6f52 <USB_Device_ProcessControlRequest+0x74>
    6f50:	11 c1       	rjmp	.+546    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
    6f52:	08 c0       	rjmp	.+16     	; 0x6f64 <USB_Device_ProcessControlRequest+0x86>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    6f54:	80 91 4b 0a 	lds	r24, 0x0A4B
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    6f58:	90 91 4c 0a 	lds	r25, 0x0A4C
    6f5c:	99 23       	and	r25, r25
    6f5e:	71 f0       	breq	.+28     	; 0x6f7c <USB_Device_ProcessControlRequest+0x9e>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    6f60:	82 60       	ori	r24, 0x02	; 2
    6f62:	0c c0       	rjmp	.+24     	; 0x6f7c <USB_Device_ProcessControlRequest+0x9e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6f64:	80 91 53 0a 	lds	r24, 0x0A53
    6f68:	8f 70       	andi	r24, 0x0F	; 15
    6f6a:	e9 ee       	ldi	r30, 0xE9	; 233
    6f6c:	f0 e0       	ldi	r31, 0x00	; 0
    6f6e:	80 83       	st	Z, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    6f70:	80 91 eb 00 	lds	r24, 0x00EB
    6f74:	85 fb       	bst	r24, 5
    6f76:	88 27       	eor	r24, r24
    6f78:	80 f9       	bld	r24, 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6f7a:	10 82       	st	Z, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6f7c:	e8 ee       	ldi	r30, 0xE8	; 232
    6f7e:	f0 e0       	ldi	r31, 0x00	; 0
    6f80:	90 81       	ld	r25, Z
    6f82:	97 7f       	andi	r25, 0xF7	; 247
    6f84:	90 83       	st	Z, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    6f86:	a1 ef       	ldi	r26, 0xF1	; 241
    6f88:	b0 e0       	ldi	r27, 0x00	; 0
    6f8a:	8c 93       	st	X, r24
				UEDATX = (Data >> 8);
    6f8c:	1c 92       	st	X, r1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6f8e:	80 81       	ld	r24, Z
    6f90:	8e 77       	andi	r24, 0x7E	; 126
    6f92:	80 83       	st	Z, r24
	Endpoint_ClearSETUP();

	Endpoint_Write_16_LE(CurrentStatus);
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    6f94:	06 de       	rcall	.-1012   	; 0x6ba2 <Endpoint_ClearStatusStage>
    6f96:	ee c0       	rjmp	.+476    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    6f98:	99 23       	and	r25, r25
    6f9a:	09 f4       	brne	.+2      	; 0x6f9e <USB_Device_ProcessControlRequest+0xc0>
    6f9c:	fa c0       	rjmp	.+500    	; 0x7192 <USB_Device_ProcessControlRequest+0x2b4>
    6f9e:	92 30       	cpi	r25, 0x02	; 2
    6fa0:	09 f0       	breq	.+2      	; 0x6fa4 <USB_Device_ProcessControlRequest+0xc6>
    6fa2:	e8 c0       	rjmp	.+464    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
    6fa4:	fb c0       	rjmp	.+502    	; 0x719c <USB_Device_ProcessControlRequest+0x2be>
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    6fa6:	91 e0       	ldi	r25, 0x01	; 1
    6fa8:	83 30       	cpi	r24, 0x03	; 3
    6faa:	09 f0       	breq	.+2      	; 0x6fae <USB_Device_ProcessControlRequest+0xd0>
    6fac:	90 e0       	ldi	r25, 0x00	; 0
    6fae:	90 93 4c 0a 	sts	0x0A4C, r25
    6fb2:	29 c0       	rjmp	.+82     	; 0x7006 <USB_Device_ProcessControlRequest+0x128>
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    6fb4:	80 91 53 0a 	lds	r24, 0x0A53
    6fb8:	8f 70       	andi	r24, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    6fba:	09 f4       	brne	.+2      	; 0x6fbe <USB_Device_ProcessControlRequest+0xe0>
    6fbc:	db c0       	rjmp	.+438    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6fbe:	80 93 e9 00 	sts	0x00E9, r24
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    6fc2:	90 91 eb 00 	lds	r25, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    6fc6:	90 ff       	sbrs	r25, 0
    6fc8:	1e c0       	rjmp	.+60     	; 0x7006 <USB_Device_ProcessControlRequest+0x128>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    6fca:	90 91 50 0a 	lds	r25, 0x0A50
    6fce:	93 30       	cpi	r25, 0x03	; 3
    6fd0:	31 f4       	brne	.+12     	; 0x6fde <USB_Device_ProcessControlRequest+0x100>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6fd2:	eb ee       	ldi	r30, 0xEB	; 235
    6fd4:	f0 e0       	ldi	r31, 0x00	; 0
    6fd6:	80 81       	ld	r24, Z
    6fd8:	80 62       	ori	r24, 0x20	; 32
    6fda:	80 83       	st	Z, r24
    6fdc:	14 c0       	rjmp	.+40     	; 0x7006 <USB_Device_ProcessControlRequest+0x128>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6fde:	eb ee       	ldi	r30, 0xEB	; 235
    6fe0:	f0 e0       	ldi	r31, 0x00	; 0
    6fe2:	90 81       	ld	r25, Z
    6fe4:	90 61       	ori	r25, 0x10	; 16
    6fe6:	90 83       	st	Z, r25
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    6fe8:	21 e0       	ldi	r18, 0x01	; 1
    6fea:	30 e0       	ldi	r19, 0x00	; 0
    6fec:	a9 01       	movw	r20, r18
    6fee:	02 c0       	rjmp	.+4      	; 0x6ff4 <USB_Device_ProcessControlRequest+0x116>
    6ff0:	44 0f       	add	r20, r20
    6ff2:	55 1f       	adc	r21, r21
    6ff4:	8a 95       	dec	r24
    6ff6:	e2 f7       	brpl	.-8      	; 0x6ff0 <USB_Device_ProcessControlRequest+0x112>
    6ff8:	aa ee       	ldi	r26, 0xEA	; 234
    6ffa:	b0 e0       	ldi	r27, 0x00	; 0
    6ffc:	4c 93       	st	X, r20
				UERST = 0;
    6ffe:	1c 92       	st	X, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    7000:	80 81       	ld	r24, Z
    7002:	88 60       	ori	r24, 0x08	; 8
    7004:	80 83       	st	Z, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    7006:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    700a:	e8 ee       	ldi	r30, 0xE8	; 232
    700c:	f0 e0       	ldi	r31, 0x00	; 0
    700e:	80 81       	ld	r24, Z
    7010:	87 7f       	andi	r24, 0xF7	; 247
    7012:	80 83       	st	Z, r24

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    7014:	c6 dd       	rcall	.-1140   	; 0x6ba2 <Endpoint_ClearStatusStage>
    7016:	ae c0       	rjmp	.+348    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    7018:	91 11       	cpse	r25, r1
    701a:	ac c0       	rjmp	.+344    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    701c:	10 91 51 0a 	lds	r17, 0x0A51
    7020:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    7022:	e3 ee       	ldi	r30, 0xE3	; 227
    7024:	f0 e0       	ldi	r31, 0x00	; 0
    7026:	80 81       	ld	r24, Z
    7028:	80 78       	andi	r24, 0x80	; 128
    702a:	81 2b       	or	r24, r17
    702c:	80 83       	st	Z, r24
    702e:	e8 ee       	ldi	r30, 0xE8	; 232
    7030:	f0 e0       	ldi	r31, 0x00	; 0
    7032:	80 81       	ld	r24, Z
    7034:	87 7f       	andi	r24, 0xF7	; 247
    7036:	80 83       	st	Z, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    7038:	b4 dd       	rcall	.-1176   	; 0x6ba2 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    703a:	e8 ee       	ldi	r30, 0xE8	; 232
    703c:	f0 e0       	ldi	r31, 0x00	; 0
    703e:	80 81       	ld	r24, Z

	while (!(Endpoint_IsINReady()));
    7040:	80 ff       	sbrs	r24, 0
    7042:	fd cf       	rjmp	.-6      	; 0x703e <USB_Device_ProcessControlRequest+0x160>
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;

				UDADDR |= (1 << ADDEN);
    7044:	e3 ee       	ldi	r30, 0xE3	; 227
    7046:	f0 e0       	ldi	r31, 0x00	; 0
    7048:	80 81       	ld	r24, Z
    704a:	80 68       	ori	r24, 0x80	; 128
    704c:	80 83       	st	Z, r24

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    704e:	11 11       	cpse	r17, r1
    7050:	02 c0       	rjmp	.+4      	; 0x7056 <USB_Device_ProcessControlRequest+0x178>
    7052:	82 e0       	ldi	r24, 0x02	; 2
    7054:	01 c0       	rjmp	.+2      	; 0x7058 <USB_Device_ProcessControlRequest+0x17a>
    7056:	83 e0       	ldi	r24, 0x03	; 3
    7058:	80 93 4e 0a 	sts	0x0A4E, r24
    705c:	8b c0       	rjmp	.+278    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    705e:	90 58       	subi	r25, 0x80	; 128
    7060:	92 30       	cpi	r25, 0x02	; 2
    7062:	08 f0       	brcs	.+2      	; 0x7066 <USB_Device_ProcessControlRequest+0x188>
    7064:	87 c0       	rjmp	.+270    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    7066:	80 91 51 0a 	lds	r24, 0x0A51
    706a:	90 91 52 0a 	lds	r25, 0x0A52
    706e:	8c 3d       	cpi	r24, 0xDC	; 220
    7070:	53 e0       	ldi	r21, 0x03	; 3
    7072:	95 07       	cpc	r25, r21
    7074:	99 f5       	brne	.+102    	; 0x70dc <USB_Device_ProcessControlRequest+0x1fe>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    7076:	83 e0       	ldi	r24, 0x03	; 3
    7078:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    707a:	8a e2       	ldi	r24, 0x2A	; 42
    707c:	89 83       	std	Y+1, r24	; 0x01
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    707e:	5f b7       	in	r21, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    7080:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    7082:	de 01       	movw	r26, r28
    7084:	13 96       	adiw	r26, 0x03	; 3
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    7086:	20 e0       	ldi	r18, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    7088:	3e e0       	ldi	r19, 0x0E	; 14

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    708a:	41 e2       	ldi	r20, 0x21	; 33
    708c:	e3 2f       	mov	r30, r19
    708e:	f0 e0       	ldi	r31, 0x00	; 0
    7090:	40 93 57 00 	sts	0x0057, r20
    7094:	84 91       	lpm	r24, Z

					if (SerialCharNum & 0x01)
    7096:	20 ff       	sbrs	r18, 0
    7098:	03 c0       	rjmp	.+6      	; 0x70a0 <USB_Device_ProcessControlRequest+0x1c2>
					{
						SerialByte >>= 4;
    709a:	82 95       	swap	r24
    709c:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    709e:	3f 5f       	subi	r19, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    70a0:	8f 70       	andi	r24, 0x0F	; 15

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    70a2:	8a 30       	cpi	r24, 0x0A	; 10
    70a4:	18 f0       	brcs	.+6      	; 0x70ac <USB_Device_ProcessControlRequest+0x1ce>
    70a6:	90 e0       	ldi	r25, 0x00	; 0
    70a8:	c7 96       	adiw	r24, 0x37	; 55
    70aa:	02 c0       	rjmp	.+4      	; 0x70b0 <USB_Device_ProcessControlRequest+0x1d2>
    70ac:	90 e0       	ldi	r25, 0x00	; 0
    70ae:	c0 96       	adiw	r24, 0x30	; 48
    70b0:	8d 93       	st	X+, r24
    70b2:	9d 93       	st	X+, r25
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    70b4:	2f 5f       	subi	r18, 0xFF	; 255
    70b6:	24 31       	cpi	r18, 0x14	; 20
    70b8:	49 f7       	brne	.-46     	; 0x708c <USB_Device_ProcessControlRequest+0x1ae>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    70ba:	5f bf       	out	0x3f, r21	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    70bc:	08 ee       	ldi	r16, 0xE8	; 232
    70be:	10 e0       	ldi	r17, 0x00	; 0
    70c0:	f8 01       	movw	r30, r16
    70c2:	80 81       	ld	r24, Z
    70c4:	87 7f       	andi	r24, 0xF7	; 247
    70c6:	80 83       	st	Z, r24

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    70c8:	6a e2       	ldi	r22, 0x2A	; 42
    70ca:	70 e0       	ldi	r23, 0x00	; 0
    70cc:	ce 01       	movw	r24, r28
    70ce:	01 96       	adiw	r24, 0x01	; 1
    70d0:	1c db       	rcall	.-2504   	; 0x670a <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    70d2:	f8 01       	movw	r30, r16
    70d4:	80 81       	ld	r24, Z
    70d6:	8b 77       	andi	r24, 0x7B	; 123
    70d8:	80 83       	st	Z, r24
    70da:	4c c0       	rjmp	.+152    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    70dc:	ae 01       	movw	r20, r28
    70de:	4f 5f       	subi	r20, 0xFF	; 255
    70e0:	5f 4f       	sbci	r21, 0xFF	; 255
    70e2:	60 91 53 0a 	lds	r22, 0x0A53
    70e6:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <CALLBACK_USB_GetDescriptor>
    70ea:	bc 01       	movw	r22, r24
    70ec:	89 2b       	or	r24, r25
    70ee:	09 f4       	brne	.+2      	; 0x70f2 <USB_Device_ProcessControlRequest+0x214>
    70f0:	41 c0       	rjmp	.+130    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    70f2:	08 ee       	ldi	r16, 0xE8	; 232
    70f4:	10 e0       	ldi	r17, 0x00	; 0
    70f6:	f8 01       	movw	r30, r16
    70f8:	90 81       	ld	r25, Z
    70fa:	97 7f       	andi	r25, 0xF7	; 247
    70fc:	90 83       	st	Z, r25
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    70fe:	89 81       	ldd	r24, Y+1	; 0x01
    7100:	9a 81       	ldd	r25, Y+2	; 0x02
    7102:	fe db       	rcall	.-2052   	; 0x6900 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    7104:	f8 01       	movw	r30, r16
    7106:	80 81       	ld	r24, Z
    7108:	8b 77       	andi	r24, 0x7B	; 123
    710a:	80 83       	st	Z, r24
    710c:	33 c0       	rjmp	.+102    	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    710e:	90 38       	cpi	r25, 0x80	; 128
    7110:	89 f5       	brne	.+98     	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7112:	e8 ee       	ldi	r30, 0xE8	; 232
    7114:	f0 e0       	ldi	r31, 0x00	; 0
    7116:	80 81       	ld	r24, Z
    7118:	87 7f       	andi	r24, 0xF7	; 247
    711a:	80 83       	st	Z, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    711c:	80 91 4a 0a 	lds	r24, 0x0A4A
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    7120:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    7124:	80 81       	ld	r24, Z
    7126:	8e 77       	andi	r24, 0x7E	; 126
    7128:	80 83       	st	Z, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    712a:	3b dd       	rcall	.-1418   	; 0x6ba2 <Endpoint_ClearStatusStage>
    712c:	23 c0       	rjmp	.+70     	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    712e:	91 11       	cpse	r25, r1
    7130:	21 c0       	rjmp	.+66     	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    7132:	80 91 51 0a 	lds	r24, 0x0A51
    7136:	82 30       	cpi	r24, 0x02	; 2
    7138:	e8 f4       	brcc	.+58     	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    713a:	e8 ee       	ldi	r30, 0xE8	; 232
    713c:	f0 e0       	ldi	r31, 0x00	; 0
    713e:	80 81       	ld	r24, Z
    7140:	87 7f       	andi	r24, 0xF7	; 247
    7142:	80 83       	st	Z, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    7144:	80 91 51 0a 	lds	r24, 0x0A51
    7148:	80 93 4a 0a 	sts	0x0A4A, r24

	Endpoint_ClearStatusStage();
    714c:	2a dd       	rcall	.-1452   	; 0x6ba2 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    714e:	80 91 4a 0a 	lds	r24, 0x0A4A
    7152:	88 23       	and	r24, r24
    7154:	21 f0       	breq	.+8      	; 0x715e <USB_Device_ProcessControlRequest+0x280>
	  USB_DeviceState = DEVICE_STATE_Configured;
    7156:	84 e0       	ldi	r24, 0x04	; 4
    7158:	80 93 4e 0a 	sts	0x0A4E, r24
    715c:	09 c0       	rjmp	.+18     	; 0x7170 <USB_Device_ProcessControlRequest+0x292>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    715e:	80 91 e3 00 	lds	r24, 0x00E3
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    7162:	88 23       	and	r24, r24
    7164:	14 f0       	brlt	.+4      	; 0x716a <USB_Device_ProcessControlRequest+0x28c>
    7166:	81 e0       	ldi	r24, 0x01	; 1
    7168:	01 c0       	rjmp	.+2      	; 0x716c <USB_Device_ProcessControlRequest+0x28e>
    716a:	84 e0       	ldi	r24, 0x04	; 4
    716c:	80 93 4e 0a 	sts	0x0A4E, r24

	EVENT_USB_Device_ConfigurationChanged();
    7170:	0e 94 59 27 	call	0x4eb2	; 0x4eb2 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    7174:	80 91 e8 00 	lds	r24, 0x00E8
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    7178:	83 ff       	sbrs	r24, 3
    717a:	16 c0       	rjmp	.+44     	; 0x71a8 <USB_Device_ProcessControlRequest+0x2ca>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    717c:	e8 ee       	ldi	r30, 0xE8	; 232
    717e:	f0 e0       	ldi	r31, 0x00	; 0
    7180:	80 81       	ld	r24, Z
    7182:	87 7f       	andi	r24, 0xF7	; 247
    7184:	80 83       	st	Z, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    7186:	eb ee       	ldi	r30, 0xEB	; 235
    7188:	f0 e0       	ldi	r31, 0x00	; 0
    718a:	80 81       	ld	r24, Z
    718c:	80 62       	ori	r24, 0x20	; 32
    718e:	80 83       	st	Z, r24
    7190:	0b c0       	rjmp	.+22     	; 0x71a8 <USB_Device_ProcessControlRequest+0x2ca>
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    7192:	90 91 51 0a 	lds	r25, 0x0A51
    7196:	91 30       	cpi	r25, 0x01	; 1
    7198:	69 f7       	brne	.-38     	; 0x7174 <USB_Device_ProcessControlRequest+0x296>
    719a:	05 cf       	rjmp	.-502    	; 0x6fa6 <USB_Device_ProcessControlRequest+0xc8>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    719c:	80 91 51 0a 	lds	r24, 0x0A51
    71a0:	88 23       	and	r24, r24
    71a2:	09 f4       	brne	.+2      	; 0x71a6 <USB_Device_ProcessControlRequest+0x2c8>
    71a4:	07 cf       	rjmp	.-498    	; 0x6fb4 <USB_Device_ProcessControlRequest+0xd6>
    71a6:	2f cf       	rjmp	.-418    	; 0x7006 <USB_Device_ProcessControlRequest+0x128>
	if (Endpoint_IsSETUPReceived())
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    71a8:	aa 96       	adiw	r28, 0x2a	; 42
    71aa:	0f b6       	in	r0, 0x3f	; 63
    71ac:	f8 94       	cli
    71ae:	de bf       	out	0x3e, r29	; 62
    71b0:	0f be       	out	0x3f, r0	; 63
    71b2:	cd bf       	out	0x3d, r28	; 61
    71b4:	df 91       	pop	r29
    71b6:	cf 91       	pop	r28
    71b8:	1f 91       	pop	r17
    71ba:	0f 91       	pop	r16
    71bc:	08 95       	ret

000071be <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    71be:	08 95       	ret

000071c0 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    71c0:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    71c2:	80 91 4e 0a 	lds	r24, 0x0A4E
    71c6:	88 23       	and	r24, r24
    71c8:	99 f0       	breq	.+38     	; 0x71f0 <USB_USBTask+0x30>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    71ca:	c0 91 e9 00 	lds	r28, 0x00E9
    71ce:	cf 70       	andi	r28, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    71d0:	80 91 ec 00 	lds	r24, 0x00EC
    71d4:	98 2f       	mov	r25, r24
    71d6:	91 70       	andi	r25, 0x01	; 1
    71d8:	80 fd       	sbrc	r24, 0
    71da:	90 e8       	ldi	r25, 0x80	; 128
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    71dc:	c9 2b       	or	r28, r25
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    71de:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    71e2:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    71e6:	83 fd       	sbrc	r24, 3
	  USB_Device_ProcessControlRequest();
    71e8:	7a de       	rcall	.-780    	; 0x6ede <USB_Device_ProcessControlRequest>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    71ea:	cf 70       	andi	r28, 0x0F	; 15
    71ec:	c0 93 e9 00 	sts	0x00E9, r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    71f0:	cf 91       	pop	r28
    71f2:	08 95       	ret

000071f4 <__divmodhi4>:
    71f4:	97 fb       	bst	r25, 7
    71f6:	07 2e       	mov	r0, r23
    71f8:	16 f4       	brtc	.+4      	; 0x71fe <__divmodhi4+0xa>
    71fa:	00 94       	com	r0
    71fc:	06 d0       	rcall	.+12     	; 0x720a <__divmodhi4_neg1>
    71fe:	77 fd       	sbrc	r23, 7
    7200:	08 d0       	rcall	.+16     	; 0x7212 <__divmodhi4_neg2>
    7202:	82 d0       	rcall	.+260    	; 0x7308 <__udivmodhi4>
    7204:	07 fc       	sbrc	r0, 7
    7206:	05 d0       	rcall	.+10     	; 0x7212 <__divmodhi4_neg2>
    7208:	3e f4       	brtc	.+14     	; 0x7218 <__divmodhi4_exit>

0000720a <__divmodhi4_neg1>:
    720a:	90 95       	com	r25
    720c:	81 95       	neg	r24
    720e:	9f 4f       	sbci	r25, 0xFF	; 255
    7210:	08 95       	ret

00007212 <__divmodhi4_neg2>:
    7212:	70 95       	com	r23
    7214:	61 95       	neg	r22
    7216:	7f 4f       	sbci	r23, 0xFF	; 255

00007218 <__divmodhi4_exit>:
    7218:	08 95       	ret

0000721a <__udivmodsi4>:
    721a:	a1 e2       	ldi	r26, 0x21	; 33
    721c:	1a 2e       	mov	r1, r26
    721e:	aa 1b       	sub	r26, r26
    7220:	bb 1b       	sub	r27, r27
    7222:	fd 01       	movw	r30, r26
    7224:	0d c0       	rjmp	.+26     	; 0x7240 <__udivmodsi4_ep>

00007226 <__udivmodsi4_loop>:
    7226:	aa 1f       	adc	r26, r26
    7228:	bb 1f       	adc	r27, r27
    722a:	ee 1f       	adc	r30, r30
    722c:	ff 1f       	adc	r31, r31
    722e:	a2 17       	cp	r26, r18
    7230:	b3 07       	cpc	r27, r19
    7232:	e4 07       	cpc	r30, r20
    7234:	f5 07       	cpc	r31, r21
    7236:	20 f0       	brcs	.+8      	; 0x7240 <__udivmodsi4_ep>
    7238:	a2 1b       	sub	r26, r18
    723a:	b3 0b       	sbc	r27, r19
    723c:	e4 0b       	sbc	r30, r20
    723e:	f5 0b       	sbc	r31, r21

00007240 <__udivmodsi4_ep>:
    7240:	66 1f       	adc	r22, r22
    7242:	77 1f       	adc	r23, r23
    7244:	88 1f       	adc	r24, r24
    7246:	99 1f       	adc	r25, r25
    7248:	1a 94       	dec	r1
    724a:	69 f7       	brne	.-38     	; 0x7226 <__udivmodsi4_loop>
    724c:	60 95       	com	r22
    724e:	70 95       	com	r23
    7250:	80 95       	com	r24
    7252:	90 95       	com	r25
    7254:	9b 01       	movw	r18, r22
    7256:	ac 01       	movw	r20, r24
    7258:	bd 01       	movw	r22, r26
    725a:	cf 01       	movw	r24, r30
    725c:	08 95       	ret

0000725e <__muluhisi3>:
    725e:	81 d0       	rcall	.+258    	; 0x7362 <__umulhisi3>
    7260:	a5 9f       	mul	r26, r21
    7262:	90 0d       	add	r25, r0
    7264:	b4 9f       	mul	r27, r20
    7266:	90 0d       	add	r25, r0
    7268:	a4 9f       	mul	r26, r20
    726a:	80 0d       	add	r24, r0
    726c:	91 1d       	adc	r25, r1
    726e:	11 24       	eor	r1, r1
    7270:	08 95       	ret

00007272 <__clzdi2>:
    7272:	5e d0       	rcall	.+188    	; 0x7330 <__clzsi2>
    7274:	85 ff       	sbrs	r24, 5
    7276:	08 95       	ret
    7278:	b9 01       	movw	r22, r18
    727a:	ca 01       	movw	r24, r20
    727c:	59 d0       	rcall	.+178    	; 0x7330 <__clzsi2>
    727e:	80 5e       	subi	r24, 0xE0	; 224
    7280:	08 95       	ret

00007282 <__ashldi3>:
    7282:	0f 93       	push	r16
    7284:	08 30       	cpi	r16, 0x08	; 8
    7286:	90 f0       	brcs	.+36     	; 0x72ac <__ashldi3+0x2a>
    7288:	98 2f       	mov	r25, r24
    728a:	87 2f       	mov	r24, r23
    728c:	76 2f       	mov	r23, r22
    728e:	65 2f       	mov	r22, r21
    7290:	54 2f       	mov	r21, r20
    7292:	43 2f       	mov	r20, r19
    7294:	32 2f       	mov	r19, r18
    7296:	22 27       	eor	r18, r18
    7298:	08 50       	subi	r16, 0x08	; 8
    729a:	f4 cf       	rjmp	.-24     	; 0x7284 <__ashldi3+0x2>
    729c:	22 0f       	add	r18, r18
    729e:	33 1f       	adc	r19, r19
    72a0:	44 1f       	adc	r20, r20
    72a2:	55 1f       	adc	r21, r21
    72a4:	66 1f       	adc	r22, r22
    72a6:	77 1f       	adc	r23, r23
    72a8:	88 1f       	adc	r24, r24
    72aa:	99 1f       	adc	r25, r25
    72ac:	0a 95       	dec	r16
    72ae:	b2 f7       	brpl	.-20     	; 0x729c <__ashldi3+0x1a>
    72b0:	0f 91       	pop	r16
    72b2:	08 95       	ret

000072b4 <__ashrdi3>:
    72b4:	97 fb       	bst	r25, 7
    72b6:	10 f8       	bld	r1, 0

000072b8 <__lshrdi3>:
    72b8:	16 94       	lsr	r1
    72ba:	00 08       	sbc	r0, r0
    72bc:	0f 93       	push	r16
    72be:	08 30       	cpi	r16, 0x08	; 8
    72c0:	98 f0       	brcs	.+38     	; 0x72e8 <__lshrdi3+0x30>
    72c2:	08 50       	subi	r16, 0x08	; 8
    72c4:	23 2f       	mov	r18, r19
    72c6:	34 2f       	mov	r19, r20
    72c8:	45 2f       	mov	r20, r21
    72ca:	56 2f       	mov	r21, r22
    72cc:	67 2f       	mov	r22, r23
    72ce:	78 2f       	mov	r23, r24
    72d0:	89 2f       	mov	r24, r25
    72d2:	90 2d       	mov	r25, r0
    72d4:	f4 cf       	rjmp	.-24     	; 0x72be <__lshrdi3+0x6>
    72d6:	05 94       	asr	r0
    72d8:	97 95       	ror	r25
    72da:	87 95       	ror	r24
    72dc:	77 95       	ror	r23
    72de:	67 95       	ror	r22
    72e0:	57 95       	ror	r21
    72e2:	47 95       	ror	r20
    72e4:	37 95       	ror	r19
    72e6:	27 95       	ror	r18
    72e8:	0a 95       	dec	r16
    72ea:	aa f7       	brpl	.-22     	; 0x72d6 <__lshrdi3+0x1e>
    72ec:	0f 91       	pop	r16
    72ee:	08 95       	ret

000072f0 <__cmpdi2_s8>:
    72f0:	00 24       	eor	r0, r0
    72f2:	a7 fd       	sbrc	r26, 7
    72f4:	00 94       	com	r0
    72f6:	2a 17       	cp	r18, r26
    72f8:	30 05       	cpc	r19, r0
    72fa:	40 05       	cpc	r20, r0
    72fc:	50 05       	cpc	r21, r0
    72fe:	60 05       	cpc	r22, r0
    7300:	70 05       	cpc	r23, r0
    7302:	80 05       	cpc	r24, r0
    7304:	90 05       	cpc	r25, r0
    7306:	08 95       	ret

00007308 <__udivmodhi4>:
    7308:	aa 1b       	sub	r26, r26
    730a:	bb 1b       	sub	r27, r27
    730c:	51 e1       	ldi	r21, 0x11	; 17
    730e:	07 c0       	rjmp	.+14     	; 0x731e <__udivmodhi4_ep>

00007310 <__udivmodhi4_loop>:
    7310:	aa 1f       	adc	r26, r26
    7312:	bb 1f       	adc	r27, r27
    7314:	a6 17       	cp	r26, r22
    7316:	b7 07       	cpc	r27, r23
    7318:	10 f0       	brcs	.+4      	; 0x731e <__udivmodhi4_ep>
    731a:	a6 1b       	sub	r26, r22
    731c:	b7 0b       	sbc	r27, r23

0000731e <__udivmodhi4_ep>:
    731e:	88 1f       	adc	r24, r24
    7320:	99 1f       	adc	r25, r25
    7322:	5a 95       	dec	r21
    7324:	a9 f7       	brne	.-22     	; 0x7310 <__udivmodhi4_loop>
    7326:	80 95       	com	r24
    7328:	90 95       	com	r25
    732a:	bc 01       	movw	r22, r24
    732c:	cd 01       	movw	r24, r26
    732e:	08 95       	ret

00007330 <__clzsi2>:
    7330:	06 d0       	rcall	.+12     	; 0x733e <__clzhi2>
    7332:	84 ff       	sbrs	r24, 4
    7334:	08 95       	ret
    7336:	cb 01       	movw	r24, r22
    7338:	02 d0       	rcall	.+4      	; 0x733e <__clzhi2>
    733a:	80 5f       	subi	r24, 0xF0	; 240
    733c:	08 95       	ret

0000733e <__clzhi2>:
    733e:	aa 27       	eor	r26, r26
    7340:	99 23       	and	r25, r25
    7342:	29 f4       	brne	.+10     	; 0x734e <__clzhi2+0x10>
    7344:	a8 5f       	subi	r26, 0xF8	; 248
    7346:	98 2b       	or	r25, r24
    7348:	11 f4       	brne	.+4      	; 0x734e <__clzhi2+0x10>
    734a:	80 e1       	ldi	r24, 0x10	; 16
    734c:	08 95       	ret
    734e:	90 31       	cpi	r25, 0x10	; 16
    7350:	18 f4       	brcc	.+6      	; 0x7358 <__clzhi2+0x1a>
    7352:	ad 5f       	subi	r26, 0xFD	; 253
    7354:	92 95       	swap	r25
    7356:	a3 95       	inc	r26
    7358:	99 0f       	add	r25, r25
    735a:	e8 f7       	brcc	.-6      	; 0x7356 <__clzhi2+0x18>
    735c:	8a 2f       	mov	r24, r26
    735e:	99 27       	eor	r25, r25
    7360:	08 95       	ret

00007362 <__umulhisi3>:
    7362:	a2 9f       	mul	r26, r18
    7364:	b0 01       	movw	r22, r0
    7366:	b3 9f       	mul	r27, r19
    7368:	c0 01       	movw	r24, r0
    736a:	a3 9f       	mul	r26, r19
    736c:	70 0d       	add	r23, r0
    736e:	81 1d       	adc	r24, r1
    7370:	11 24       	eor	r1, r1
    7372:	91 1d       	adc	r25, r1
    7374:	b2 9f       	mul	r27, r18
    7376:	70 0d       	add	r23, r0
    7378:	81 1d       	adc	r24, r1
    737a:	11 24       	eor	r1, r1
    737c:	91 1d       	adc	r25, r1
    737e:	08 95       	ret

00007380 <toupper>:
    7380:	91 11       	cpse	r25, r1
    7382:	08 95       	ret
    7384:	81 56       	subi	r24, 0x61	; 97
    7386:	8a 51       	subi	r24, 0x1A	; 26
    7388:	08 f4       	brcc	.+2      	; 0x738c <toupper+0xc>
    738a:	80 52       	subi	r24, 0x20	; 32
    738c:	85 58       	subi	r24, 0x85	; 133
    738e:	08 95       	ret

00007390 <strcpy_P>:
    7390:	fb 01       	movw	r30, r22
    7392:	dc 01       	movw	r26, r24
    7394:	05 90       	lpm	r0, Z+
    7396:	0d 92       	st	X+, r0
    7398:	00 20       	and	r0, r0
    739a:	e1 f7       	brne	.-8      	; 0x7394 <strcpy_P+0x4>
    739c:	08 95       	ret

0000739e <strtok>:
    739e:	40 eb       	ldi	r20, 0xB0	; 176
    73a0:	53 e0       	ldi	r21, 0x03	; 3
    73a2:	1d c0       	rjmp	.+58     	; 0x73de <strtok_r>

000073a4 <memcmp>:
    73a4:	fb 01       	movw	r30, r22
    73a6:	dc 01       	movw	r26, r24
    73a8:	04 c0       	rjmp	.+8      	; 0x73b2 <memcmp+0xe>
    73aa:	8d 91       	ld	r24, X+
    73ac:	01 90       	ld	r0, Z+
    73ae:	80 19       	sub	r24, r0
    73b0:	21 f4       	brne	.+8      	; 0x73ba <memcmp+0x16>
    73b2:	41 50       	subi	r20, 0x01	; 1
    73b4:	50 40       	sbci	r21, 0x00	; 0
    73b6:	c8 f7       	brcc	.-14     	; 0x73aa <memcmp+0x6>
    73b8:	88 1b       	sub	r24, r24
    73ba:	99 0b       	sbc	r25, r25
    73bc:	08 95       	ret

000073be <memcpy>:
    73be:	fb 01       	movw	r30, r22
    73c0:	dc 01       	movw	r26, r24
    73c2:	02 c0       	rjmp	.+4      	; 0x73c8 <memcpy+0xa>
    73c4:	01 90       	ld	r0, Z+
    73c6:	0d 92       	st	X+, r0
    73c8:	41 50       	subi	r20, 0x01	; 1
    73ca:	50 40       	sbci	r21, 0x00	; 0
    73cc:	d8 f7       	brcc	.-10     	; 0x73c4 <memcpy+0x6>
    73ce:	08 95       	ret

000073d0 <memset>:
    73d0:	dc 01       	movw	r26, r24
    73d2:	01 c0       	rjmp	.+2      	; 0x73d6 <memset+0x6>
    73d4:	6d 93       	st	X+, r22
    73d6:	41 50       	subi	r20, 0x01	; 1
    73d8:	50 40       	sbci	r21, 0x00	; 0
    73da:	e0 f7       	brcc	.-8      	; 0x73d4 <memset+0x4>
    73dc:	08 95       	ret

000073de <strtok_r>:
    73de:	fa 01       	movw	r30, r20
    73e0:	a1 91       	ld	r26, Z+
    73e2:	b0 81       	ld	r27, Z
    73e4:	00 97       	sbiw	r24, 0x00	; 0
    73e6:	19 f4       	brne	.+6      	; 0x73ee <strtok_r+0x10>
    73e8:	10 97       	sbiw	r26, 0x00	; 0
    73ea:	e1 f0       	breq	.+56     	; 0x7424 <strtok_r+0x46>
    73ec:	cd 01       	movw	r24, r26
    73ee:	dc 01       	movw	r26, r24
    73f0:	cd 01       	movw	r24, r26
    73f2:	0d 90       	ld	r0, X+
    73f4:	00 20       	and	r0, r0
    73f6:	11 f4       	brne	.+4      	; 0x73fc <strtok_r+0x1e>
    73f8:	c0 01       	movw	r24, r0
    73fa:	13 c0       	rjmp	.+38     	; 0x7422 <strtok_r+0x44>
    73fc:	fb 01       	movw	r30, r22
    73fe:	21 91       	ld	r18, Z+
    7400:	22 23       	and	r18, r18
    7402:	19 f0       	breq	.+6      	; 0x740a <strtok_r+0x2c>
    7404:	20 15       	cp	r18, r0
    7406:	d9 f7       	brne	.-10     	; 0x73fe <strtok_r+0x20>
    7408:	f3 cf       	rjmp	.-26     	; 0x73f0 <strtok_r+0x12>
    740a:	fb 01       	movw	r30, r22
    740c:	21 91       	ld	r18, Z+
    740e:	20 15       	cp	r18, r0
    7410:	19 f4       	brne	.+6      	; 0x7418 <strtok_r+0x3a>
    7412:	1e 92       	st	-X, r1
    7414:	11 96       	adiw	r26, 0x01	; 1
    7416:	06 c0       	rjmp	.+12     	; 0x7424 <strtok_r+0x46>
    7418:	22 23       	and	r18, r18
    741a:	c1 f7       	brne	.-16     	; 0x740c <strtok_r+0x2e>
    741c:	0d 90       	ld	r0, X+
    741e:	00 20       	and	r0, r0
    7420:	a1 f7       	brne	.-24     	; 0x740a <strtok_r+0x2c>
    7422:	d0 01       	movw	r26, r0
    7424:	fa 01       	movw	r30, r20
    7426:	a1 93       	st	Z+, r26
    7428:	b0 83       	st	Z, r27
    742a:	08 95       	ret

0000742c <sprintf>:
    742c:	ae e0       	ldi	r26, 0x0E	; 14
    742e:	b0 e0       	ldi	r27, 0x00	; 0
    7430:	eb e1       	ldi	r30, 0x1B	; 27
    7432:	fa e3       	ldi	r31, 0x3A	; 58
    7434:	e1 c2       	rjmp	.+1474   	; 0x79f8 <__prologue_saves__+0x1c>
    7436:	0d 89       	ldd	r16, Y+21	; 0x15
    7438:	1e 89       	ldd	r17, Y+22	; 0x16
    743a:	86 e0       	ldi	r24, 0x06	; 6
    743c:	8c 83       	std	Y+4, r24	; 0x04
    743e:	1a 83       	std	Y+2, r17	; 0x02
    7440:	09 83       	std	Y+1, r16	; 0x01
    7442:	8f ef       	ldi	r24, 0xFF	; 255
    7444:	9f e7       	ldi	r25, 0x7F	; 127
    7446:	9e 83       	std	Y+6, r25	; 0x06
    7448:	8d 83       	std	Y+5, r24	; 0x05
    744a:	ae 01       	movw	r20, r28
    744c:	47 5e       	subi	r20, 0xE7	; 231
    744e:	5f 4f       	sbci	r21, 0xFF	; 255
    7450:	6f 89       	ldd	r22, Y+23	; 0x17
    7452:	78 8d       	ldd	r23, Y+24	; 0x18
    7454:	ce 01       	movw	r24, r28
    7456:	01 96       	adiw	r24, 0x01	; 1
    7458:	09 d0       	rcall	.+18     	; 0x746c <vfprintf>
    745a:	2f 81       	ldd	r18, Y+7	; 0x07
    745c:	38 85       	ldd	r19, Y+8	; 0x08
    745e:	f8 01       	movw	r30, r16
    7460:	e2 0f       	add	r30, r18
    7462:	f3 1f       	adc	r31, r19
    7464:	10 82       	st	Z, r1
    7466:	2e 96       	adiw	r28, 0x0e	; 14
    7468:	e4 e0       	ldi	r30, 0x04	; 4
    746a:	e2 c2       	rjmp	.+1476   	; 0x7a30 <__epilogue_restores__+0x1c>

0000746c <vfprintf>:
    746c:	ac e0       	ldi	r26, 0x0C	; 12
    746e:	b0 e0       	ldi	r27, 0x00	; 0
    7470:	eb e3       	ldi	r30, 0x3B	; 59
    7472:	fa e3       	ldi	r31, 0x3A	; 58
    7474:	b3 c2       	rjmp	.+1382   	; 0x79dc <__prologue_saves__>
    7476:	7c 01       	movw	r14, r24
    7478:	6b 01       	movw	r12, r22
    747a:	8a 01       	movw	r16, r20
    747c:	fc 01       	movw	r30, r24
    747e:	17 82       	std	Z+7, r1	; 0x07
    7480:	16 82       	std	Z+6, r1	; 0x06
    7482:	83 81       	ldd	r24, Z+3	; 0x03
    7484:	81 ff       	sbrs	r24, 1
    7486:	b0 c1       	rjmp	.+864    	; 0x77e8 <vfprintf+0x37c>
    7488:	ce 01       	movw	r24, r28
    748a:	01 96       	adiw	r24, 0x01	; 1
    748c:	4c 01       	movw	r8, r24
    748e:	f7 01       	movw	r30, r14
    7490:	93 81       	ldd	r25, Z+3	; 0x03
    7492:	f6 01       	movw	r30, r12
    7494:	93 fd       	sbrc	r25, 3
    7496:	85 91       	lpm	r24, Z+
    7498:	93 ff       	sbrs	r25, 3
    749a:	81 91       	ld	r24, Z+
    749c:	6f 01       	movw	r12, r30
    749e:	88 23       	and	r24, r24
    74a0:	09 f4       	brne	.+2      	; 0x74a4 <vfprintf+0x38>
    74a2:	9e c1       	rjmp	.+828    	; 0x77e0 <vfprintf+0x374>
    74a4:	85 32       	cpi	r24, 0x25	; 37
    74a6:	39 f4       	brne	.+14     	; 0x74b6 <vfprintf+0x4a>
    74a8:	93 fd       	sbrc	r25, 3
    74aa:	85 91       	lpm	r24, Z+
    74ac:	93 ff       	sbrs	r25, 3
    74ae:	81 91       	ld	r24, Z+
    74b0:	6f 01       	movw	r12, r30
    74b2:	85 32       	cpi	r24, 0x25	; 37
    74b4:	21 f4       	brne	.+8      	; 0x74be <vfprintf+0x52>
    74b6:	b7 01       	movw	r22, r14
    74b8:	90 e0       	ldi	r25, 0x00	; 0
    74ba:	b1 d1       	rcall	.+866    	; 0x781e <fputc>
    74bc:	e8 cf       	rjmp	.-48     	; 0x748e <vfprintf+0x22>
    74be:	51 2c       	mov	r5, r1
    74c0:	31 2c       	mov	r3, r1
    74c2:	20 e0       	ldi	r18, 0x00	; 0
    74c4:	20 32       	cpi	r18, 0x20	; 32
    74c6:	a0 f4       	brcc	.+40     	; 0x74f0 <vfprintf+0x84>
    74c8:	8b 32       	cpi	r24, 0x2B	; 43
    74ca:	69 f0       	breq	.+26     	; 0x74e6 <vfprintf+0x7a>
    74cc:	30 f4       	brcc	.+12     	; 0x74da <vfprintf+0x6e>
    74ce:	80 32       	cpi	r24, 0x20	; 32
    74d0:	59 f0       	breq	.+22     	; 0x74e8 <vfprintf+0x7c>
    74d2:	83 32       	cpi	r24, 0x23	; 35
    74d4:	69 f4       	brne	.+26     	; 0x74f0 <vfprintf+0x84>
    74d6:	20 61       	ori	r18, 0x10	; 16
    74d8:	2c c0       	rjmp	.+88     	; 0x7532 <vfprintf+0xc6>
    74da:	8d 32       	cpi	r24, 0x2D	; 45
    74dc:	39 f0       	breq	.+14     	; 0x74ec <vfprintf+0x80>
    74de:	80 33       	cpi	r24, 0x30	; 48
    74e0:	39 f4       	brne	.+14     	; 0x74f0 <vfprintf+0x84>
    74e2:	21 60       	ori	r18, 0x01	; 1
    74e4:	26 c0       	rjmp	.+76     	; 0x7532 <vfprintf+0xc6>
    74e6:	22 60       	ori	r18, 0x02	; 2
    74e8:	24 60       	ori	r18, 0x04	; 4
    74ea:	23 c0       	rjmp	.+70     	; 0x7532 <vfprintf+0xc6>
    74ec:	28 60       	ori	r18, 0x08	; 8
    74ee:	21 c0       	rjmp	.+66     	; 0x7532 <vfprintf+0xc6>
    74f0:	27 fd       	sbrc	r18, 7
    74f2:	27 c0       	rjmp	.+78     	; 0x7542 <vfprintf+0xd6>
    74f4:	30 ed       	ldi	r19, 0xD0	; 208
    74f6:	38 0f       	add	r19, r24
    74f8:	3a 30       	cpi	r19, 0x0A	; 10
    74fa:	78 f4       	brcc	.+30     	; 0x751a <vfprintf+0xae>
    74fc:	26 ff       	sbrs	r18, 6
    74fe:	06 c0       	rjmp	.+12     	; 0x750c <vfprintf+0xa0>
    7500:	fa e0       	ldi	r31, 0x0A	; 10
    7502:	5f 9e       	mul	r5, r31
    7504:	30 0d       	add	r19, r0
    7506:	11 24       	eor	r1, r1
    7508:	53 2e       	mov	r5, r19
    750a:	13 c0       	rjmp	.+38     	; 0x7532 <vfprintf+0xc6>
    750c:	8a e0       	ldi	r24, 0x0A	; 10
    750e:	38 9e       	mul	r3, r24
    7510:	30 0d       	add	r19, r0
    7512:	11 24       	eor	r1, r1
    7514:	33 2e       	mov	r3, r19
    7516:	20 62       	ori	r18, 0x20	; 32
    7518:	0c c0       	rjmp	.+24     	; 0x7532 <vfprintf+0xc6>
    751a:	8e 32       	cpi	r24, 0x2E	; 46
    751c:	21 f4       	brne	.+8      	; 0x7526 <vfprintf+0xba>
    751e:	26 fd       	sbrc	r18, 6
    7520:	5f c1       	rjmp	.+702    	; 0x77e0 <vfprintf+0x374>
    7522:	20 64       	ori	r18, 0x40	; 64
    7524:	06 c0       	rjmp	.+12     	; 0x7532 <vfprintf+0xc6>
    7526:	8c 36       	cpi	r24, 0x6C	; 108
    7528:	11 f4       	brne	.+4      	; 0x752e <vfprintf+0xc2>
    752a:	20 68       	ori	r18, 0x80	; 128
    752c:	02 c0       	rjmp	.+4      	; 0x7532 <vfprintf+0xc6>
    752e:	88 36       	cpi	r24, 0x68	; 104
    7530:	41 f4       	brne	.+16     	; 0x7542 <vfprintf+0xd6>
    7532:	f6 01       	movw	r30, r12
    7534:	93 fd       	sbrc	r25, 3
    7536:	85 91       	lpm	r24, Z+
    7538:	93 ff       	sbrs	r25, 3
    753a:	81 91       	ld	r24, Z+
    753c:	6f 01       	movw	r12, r30
    753e:	81 11       	cpse	r24, r1
    7540:	c1 cf       	rjmp	.-126    	; 0x74c4 <vfprintf+0x58>
    7542:	98 2f       	mov	r25, r24
    7544:	9f 7d       	andi	r25, 0xDF	; 223
    7546:	95 54       	subi	r25, 0x45	; 69
    7548:	93 30       	cpi	r25, 0x03	; 3
    754a:	28 f4       	brcc	.+10     	; 0x7556 <vfprintf+0xea>
    754c:	0c 5f       	subi	r16, 0xFC	; 252
    754e:	1f 4f       	sbci	r17, 0xFF	; 255
    7550:	ff e3       	ldi	r31, 0x3F	; 63
    7552:	f9 83       	std	Y+1, r31	; 0x01
    7554:	0d c0       	rjmp	.+26     	; 0x7570 <vfprintf+0x104>
    7556:	83 36       	cpi	r24, 0x63	; 99
    7558:	31 f0       	breq	.+12     	; 0x7566 <vfprintf+0xfa>
    755a:	83 37       	cpi	r24, 0x73	; 115
    755c:	71 f0       	breq	.+28     	; 0x757a <vfprintf+0x10e>
    755e:	83 35       	cpi	r24, 0x53	; 83
    7560:	09 f0       	breq	.+2      	; 0x7564 <vfprintf+0xf8>
    7562:	57 c0       	rjmp	.+174    	; 0x7612 <vfprintf+0x1a6>
    7564:	21 c0       	rjmp	.+66     	; 0x75a8 <vfprintf+0x13c>
    7566:	f8 01       	movw	r30, r16
    7568:	80 81       	ld	r24, Z
    756a:	89 83       	std	Y+1, r24	; 0x01
    756c:	0e 5f       	subi	r16, 0xFE	; 254
    756e:	1f 4f       	sbci	r17, 0xFF	; 255
    7570:	44 24       	eor	r4, r4
    7572:	43 94       	inc	r4
    7574:	51 2c       	mov	r5, r1
    7576:	54 01       	movw	r10, r8
    7578:	14 c0       	rjmp	.+40     	; 0x75a2 <vfprintf+0x136>
    757a:	38 01       	movw	r6, r16
    757c:	f2 e0       	ldi	r31, 0x02	; 2
    757e:	6f 0e       	add	r6, r31
    7580:	71 1c       	adc	r7, r1
    7582:	f8 01       	movw	r30, r16
    7584:	a0 80       	ld	r10, Z
    7586:	b1 80       	ldd	r11, Z+1	; 0x01
    7588:	26 ff       	sbrs	r18, 6
    758a:	03 c0       	rjmp	.+6      	; 0x7592 <vfprintf+0x126>
    758c:	65 2d       	mov	r22, r5
    758e:	70 e0       	ldi	r23, 0x00	; 0
    7590:	02 c0       	rjmp	.+4      	; 0x7596 <vfprintf+0x12a>
    7592:	6f ef       	ldi	r22, 0xFF	; 255
    7594:	7f ef       	ldi	r23, 0xFF	; 255
    7596:	c5 01       	movw	r24, r10
    7598:	2c 87       	std	Y+12, r18	; 0x0c
    759a:	36 d1       	rcall	.+620    	; 0x7808 <strnlen>
    759c:	2c 01       	movw	r4, r24
    759e:	83 01       	movw	r16, r6
    75a0:	2c 85       	ldd	r18, Y+12	; 0x0c
    75a2:	2f 77       	andi	r18, 0x7F	; 127
    75a4:	22 2e       	mov	r2, r18
    75a6:	16 c0       	rjmp	.+44     	; 0x75d4 <vfprintf+0x168>
    75a8:	38 01       	movw	r6, r16
    75aa:	f2 e0       	ldi	r31, 0x02	; 2
    75ac:	6f 0e       	add	r6, r31
    75ae:	71 1c       	adc	r7, r1
    75b0:	f8 01       	movw	r30, r16
    75b2:	a0 80       	ld	r10, Z
    75b4:	b1 80       	ldd	r11, Z+1	; 0x01
    75b6:	26 ff       	sbrs	r18, 6
    75b8:	03 c0       	rjmp	.+6      	; 0x75c0 <vfprintf+0x154>
    75ba:	65 2d       	mov	r22, r5
    75bc:	70 e0       	ldi	r23, 0x00	; 0
    75be:	02 c0       	rjmp	.+4      	; 0x75c4 <vfprintf+0x158>
    75c0:	6f ef       	ldi	r22, 0xFF	; 255
    75c2:	7f ef       	ldi	r23, 0xFF	; 255
    75c4:	c5 01       	movw	r24, r10
    75c6:	2c 87       	std	Y+12, r18	; 0x0c
    75c8:	14 d1       	rcall	.+552    	; 0x77f2 <strnlen_P>
    75ca:	2c 01       	movw	r4, r24
    75cc:	2c 85       	ldd	r18, Y+12	; 0x0c
    75ce:	20 68       	ori	r18, 0x80	; 128
    75d0:	22 2e       	mov	r2, r18
    75d2:	83 01       	movw	r16, r6
    75d4:	23 fc       	sbrc	r2, 3
    75d6:	19 c0       	rjmp	.+50     	; 0x760a <vfprintf+0x19e>
    75d8:	83 2d       	mov	r24, r3
    75da:	90 e0       	ldi	r25, 0x00	; 0
    75dc:	48 16       	cp	r4, r24
    75de:	59 06       	cpc	r5, r25
    75e0:	a0 f4       	brcc	.+40     	; 0x760a <vfprintf+0x19e>
    75e2:	b7 01       	movw	r22, r14
    75e4:	80 e2       	ldi	r24, 0x20	; 32
    75e6:	90 e0       	ldi	r25, 0x00	; 0
    75e8:	1a d1       	rcall	.+564    	; 0x781e <fputc>
    75ea:	3a 94       	dec	r3
    75ec:	f5 cf       	rjmp	.-22     	; 0x75d8 <vfprintf+0x16c>
    75ee:	f5 01       	movw	r30, r10
    75f0:	27 fc       	sbrc	r2, 7
    75f2:	85 91       	lpm	r24, Z+
    75f4:	27 fe       	sbrs	r2, 7
    75f6:	81 91       	ld	r24, Z+
    75f8:	5f 01       	movw	r10, r30
    75fa:	b7 01       	movw	r22, r14
    75fc:	90 e0       	ldi	r25, 0x00	; 0
    75fe:	0f d1       	rcall	.+542    	; 0x781e <fputc>
    7600:	31 10       	cpse	r3, r1
    7602:	3a 94       	dec	r3
    7604:	f1 e0       	ldi	r31, 0x01	; 1
    7606:	4f 1a       	sub	r4, r31
    7608:	51 08       	sbc	r5, r1
    760a:	41 14       	cp	r4, r1
    760c:	51 04       	cpc	r5, r1
    760e:	79 f7       	brne	.-34     	; 0x75ee <vfprintf+0x182>
    7610:	de c0       	rjmp	.+444    	; 0x77ce <vfprintf+0x362>
    7612:	84 36       	cpi	r24, 0x64	; 100
    7614:	11 f0       	breq	.+4      	; 0x761a <vfprintf+0x1ae>
    7616:	89 36       	cpi	r24, 0x69	; 105
    7618:	31 f5       	brne	.+76     	; 0x7666 <vfprintf+0x1fa>
    761a:	f8 01       	movw	r30, r16
    761c:	27 ff       	sbrs	r18, 7
    761e:	07 c0       	rjmp	.+14     	; 0x762e <vfprintf+0x1c2>
    7620:	60 81       	ld	r22, Z
    7622:	71 81       	ldd	r23, Z+1	; 0x01
    7624:	82 81       	ldd	r24, Z+2	; 0x02
    7626:	93 81       	ldd	r25, Z+3	; 0x03
    7628:	0c 5f       	subi	r16, 0xFC	; 252
    762a:	1f 4f       	sbci	r17, 0xFF	; 255
    762c:	08 c0       	rjmp	.+16     	; 0x763e <vfprintf+0x1d2>
    762e:	60 81       	ld	r22, Z
    7630:	71 81       	ldd	r23, Z+1	; 0x01
    7632:	07 2e       	mov	r0, r23
    7634:	00 0c       	add	r0, r0
    7636:	88 0b       	sbc	r24, r24
    7638:	99 0b       	sbc	r25, r25
    763a:	0e 5f       	subi	r16, 0xFE	; 254
    763c:	1f 4f       	sbci	r17, 0xFF	; 255
    763e:	2f 76       	andi	r18, 0x6F	; 111
    7640:	72 2e       	mov	r7, r18
    7642:	97 ff       	sbrs	r25, 7
    7644:	09 c0       	rjmp	.+18     	; 0x7658 <vfprintf+0x1ec>
    7646:	90 95       	com	r25
    7648:	80 95       	com	r24
    764a:	70 95       	com	r23
    764c:	61 95       	neg	r22
    764e:	7f 4f       	sbci	r23, 0xFF	; 255
    7650:	8f 4f       	sbci	r24, 0xFF	; 255
    7652:	9f 4f       	sbci	r25, 0xFF	; 255
    7654:	20 68       	ori	r18, 0x80	; 128
    7656:	72 2e       	mov	r7, r18
    7658:	2a e0       	ldi	r18, 0x0A	; 10
    765a:	30 e0       	ldi	r19, 0x00	; 0
    765c:	a4 01       	movw	r20, r8
    765e:	17 d1       	rcall	.+558    	; 0x788e <__ultoa_invert>
    7660:	a8 2e       	mov	r10, r24
    7662:	a8 18       	sub	r10, r8
    7664:	43 c0       	rjmp	.+134    	; 0x76ec <vfprintf+0x280>
    7666:	85 37       	cpi	r24, 0x75	; 117
    7668:	29 f4       	brne	.+10     	; 0x7674 <vfprintf+0x208>
    766a:	2f 7e       	andi	r18, 0xEF	; 239
    766c:	b2 2e       	mov	r11, r18
    766e:	2a e0       	ldi	r18, 0x0A	; 10
    7670:	30 e0       	ldi	r19, 0x00	; 0
    7672:	25 c0       	rjmp	.+74     	; 0x76be <vfprintf+0x252>
    7674:	f2 2f       	mov	r31, r18
    7676:	f9 7f       	andi	r31, 0xF9	; 249
    7678:	bf 2e       	mov	r11, r31
    767a:	8f 36       	cpi	r24, 0x6F	; 111
    767c:	c1 f0       	breq	.+48     	; 0x76ae <vfprintf+0x242>
    767e:	18 f4       	brcc	.+6      	; 0x7686 <vfprintf+0x21a>
    7680:	88 35       	cpi	r24, 0x58	; 88
    7682:	79 f0       	breq	.+30     	; 0x76a2 <vfprintf+0x236>
    7684:	ad c0       	rjmp	.+346    	; 0x77e0 <vfprintf+0x374>
    7686:	80 37       	cpi	r24, 0x70	; 112
    7688:	19 f0       	breq	.+6      	; 0x7690 <vfprintf+0x224>
    768a:	88 37       	cpi	r24, 0x78	; 120
    768c:	21 f0       	breq	.+8      	; 0x7696 <vfprintf+0x22a>
    768e:	a8 c0       	rjmp	.+336    	; 0x77e0 <vfprintf+0x374>
    7690:	2f 2f       	mov	r18, r31
    7692:	20 61       	ori	r18, 0x10	; 16
    7694:	b2 2e       	mov	r11, r18
    7696:	b4 fe       	sbrs	r11, 4
    7698:	0d c0       	rjmp	.+26     	; 0x76b4 <vfprintf+0x248>
    769a:	8b 2d       	mov	r24, r11
    769c:	84 60       	ori	r24, 0x04	; 4
    769e:	b8 2e       	mov	r11, r24
    76a0:	09 c0       	rjmp	.+18     	; 0x76b4 <vfprintf+0x248>
    76a2:	24 ff       	sbrs	r18, 4
    76a4:	0a c0       	rjmp	.+20     	; 0x76ba <vfprintf+0x24e>
    76a6:	9f 2f       	mov	r25, r31
    76a8:	96 60       	ori	r25, 0x06	; 6
    76aa:	b9 2e       	mov	r11, r25
    76ac:	06 c0       	rjmp	.+12     	; 0x76ba <vfprintf+0x24e>
    76ae:	28 e0       	ldi	r18, 0x08	; 8
    76b0:	30 e0       	ldi	r19, 0x00	; 0
    76b2:	05 c0       	rjmp	.+10     	; 0x76be <vfprintf+0x252>
    76b4:	20 e1       	ldi	r18, 0x10	; 16
    76b6:	30 e0       	ldi	r19, 0x00	; 0
    76b8:	02 c0       	rjmp	.+4      	; 0x76be <vfprintf+0x252>
    76ba:	20 e1       	ldi	r18, 0x10	; 16
    76bc:	32 e0       	ldi	r19, 0x02	; 2
    76be:	f8 01       	movw	r30, r16
    76c0:	b7 fe       	sbrs	r11, 7
    76c2:	07 c0       	rjmp	.+14     	; 0x76d2 <vfprintf+0x266>
    76c4:	60 81       	ld	r22, Z
    76c6:	71 81       	ldd	r23, Z+1	; 0x01
    76c8:	82 81       	ldd	r24, Z+2	; 0x02
    76ca:	93 81       	ldd	r25, Z+3	; 0x03
    76cc:	0c 5f       	subi	r16, 0xFC	; 252
    76ce:	1f 4f       	sbci	r17, 0xFF	; 255
    76d0:	06 c0       	rjmp	.+12     	; 0x76de <vfprintf+0x272>
    76d2:	60 81       	ld	r22, Z
    76d4:	71 81       	ldd	r23, Z+1	; 0x01
    76d6:	80 e0       	ldi	r24, 0x00	; 0
    76d8:	90 e0       	ldi	r25, 0x00	; 0
    76da:	0e 5f       	subi	r16, 0xFE	; 254
    76dc:	1f 4f       	sbci	r17, 0xFF	; 255
    76de:	a4 01       	movw	r20, r8
    76e0:	d6 d0       	rcall	.+428    	; 0x788e <__ultoa_invert>
    76e2:	a8 2e       	mov	r10, r24
    76e4:	a8 18       	sub	r10, r8
    76e6:	fb 2d       	mov	r31, r11
    76e8:	ff 77       	andi	r31, 0x7F	; 127
    76ea:	7f 2e       	mov	r7, r31
    76ec:	76 fe       	sbrs	r7, 6
    76ee:	0b c0       	rjmp	.+22     	; 0x7706 <vfprintf+0x29a>
    76f0:	37 2d       	mov	r19, r7
    76f2:	3e 7f       	andi	r19, 0xFE	; 254
    76f4:	a5 14       	cp	r10, r5
    76f6:	50 f4       	brcc	.+20     	; 0x770c <vfprintf+0x2a0>
    76f8:	74 fe       	sbrs	r7, 4
    76fa:	0a c0       	rjmp	.+20     	; 0x7710 <vfprintf+0x2a4>
    76fc:	72 fc       	sbrc	r7, 2
    76fe:	08 c0       	rjmp	.+16     	; 0x7710 <vfprintf+0x2a4>
    7700:	37 2d       	mov	r19, r7
    7702:	3e 7e       	andi	r19, 0xEE	; 238
    7704:	05 c0       	rjmp	.+10     	; 0x7710 <vfprintf+0x2a4>
    7706:	ba 2c       	mov	r11, r10
    7708:	37 2d       	mov	r19, r7
    770a:	03 c0       	rjmp	.+6      	; 0x7712 <vfprintf+0x2a6>
    770c:	ba 2c       	mov	r11, r10
    770e:	01 c0       	rjmp	.+2      	; 0x7712 <vfprintf+0x2a6>
    7710:	b5 2c       	mov	r11, r5
    7712:	34 ff       	sbrs	r19, 4
    7714:	0d c0       	rjmp	.+26     	; 0x7730 <vfprintf+0x2c4>
    7716:	fe 01       	movw	r30, r28
    7718:	ea 0d       	add	r30, r10
    771a:	f1 1d       	adc	r31, r1
    771c:	80 81       	ld	r24, Z
    771e:	80 33       	cpi	r24, 0x30	; 48
    7720:	11 f4       	brne	.+4      	; 0x7726 <vfprintf+0x2ba>
    7722:	39 7e       	andi	r19, 0xE9	; 233
    7724:	09 c0       	rjmp	.+18     	; 0x7738 <vfprintf+0x2cc>
    7726:	32 ff       	sbrs	r19, 2
    7728:	06 c0       	rjmp	.+12     	; 0x7736 <vfprintf+0x2ca>
    772a:	b3 94       	inc	r11
    772c:	b3 94       	inc	r11
    772e:	04 c0       	rjmp	.+8      	; 0x7738 <vfprintf+0x2cc>
    7730:	83 2f       	mov	r24, r19
    7732:	86 78       	andi	r24, 0x86	; 134
    7734:	09 f0       	breq	.+2      	; 0x7738 <vfprintf+0x2cc>
    7736:	b3 94       	inc	r11
    7738:	33 fd       	sbrc	r19, 3
    773a:	12 c0       	rjmp	.+36     	; 0x7760 <vfprintf+0x2f4>
    773c:	30 ff       	sbrs	r19, 0
    773e:	06 c0       	rjmp	.+12     	; 0x774c <vfprintf+0x2e0>
    7740:	5a 2c       	mov	r5, r10
    7742:	b3 14       	cp	r11, r3
    7744:	18 f4       	brcc	.+6      	; 0x774c <vfprintf+0x2e0>
    7746:	53 0c       	add	r5, r3
    7748:	5b 18       	sub	r5, r11
    774a:	b3 2c       	mov	r11, r3
    774c:	b3 14       	cp	r11, r3
    774e:	60 f4       	brcc	.+24     	; 0x7768 <vfprintf+0x2fc>
    7750:	b7 01       	movw	r22, r14
    7752:	80 e2       	ldi	r24, 0x20	; 32
    7754:	90 e0       	ldi	r25, 0x00	; 0
    7756:	3c 87       	std	Y+12, r19	; 0x0c
    7758:	62 d0       	rcall	.+196    	; 0x781e <fputc>
    775a:	b3 94       	inc	r11
    775c:	3c 85       	ldd	r19, Y+12	; 0x0c
    775e:	f6 cf       	rjmp	.-20     	; 0x774c <vfprintf+0x2e0>
    7760:	b3 14       	cp	r11, r3
    7762:	10 f4       	brcc	.+4      	; 0x7768 <vfprintf+0x2fc>
    7764:	3b 18       	sub	r3, r11
    7766:	01 c0       	rjmp	.+2      	; 0x776a <vfprintf+0x2fe>
    7768:	31 2c       	mov	r3, r1
    776a:	34 ff       	sbrs	r19, 4
    776c:	11 c0       	rjmp	.+34     	; 0x7790 <vfprintf+0x324>
    776e:	b7 01       	movw	r22, r14
    7770:	80 e3       	ldi	r24, 0x30	; 48
    7772:	90 e0       	ldi	r25, 0x00	; 0
    7774:	3c 87       	std	Y+12, r19	; 0x0c
    7776:	53 d0       	rcall	.+166    	; 0x781e <fputc>
    7778:	3c 85       	ldd	r19, Y+12	; 0x0c
    777a:	32 ff       	sbrs	r19, 2
    777c:	16 c0       	rjmp	.+44     	; 0x77aa <vfprintf+0x33e>
    777e:	31 fd       	sbrc	r19, 1
    7780:	03 c0       	rjmp	.+6      	; 0x7788 <vfprintf+0x31c>
    7782:	88 e7       	ldi	r24, 0x78	; 120
    7784:	90 e0       	ldi	r25, 0x00	; 0
    7786:	02 c0       	rjmp	.+4      	; 0x778c <vfprintf+0x320>
    7788:	88 e5       	ldi	r24, 0x58	; 88
    778a:	90 e0       	ldi	r25, 0x00	; 0
    778c:	b7 01       	movw	r22, r14
    778e:	0c c0       	rjmp	.+24     	; 0x77a8 <vfprintf+0x33c>
    7790:	83 2f       	mov	r24, r19
    7792:	86 78       	andi	r24, 0x86	; 134
    7794:	51 f0       	breq	.+20     	; 0x77aa <vfprintf+0x33e>
    7796:	31 ff       	sbrs	r19, 1
    7798:	02 c0       	rjmp	.+4      	; 0x779e <vfprintf+0x332>
    779a:	8b e2       	ldi	r24, 0x2B	; 43
    779c:	01 c0       	rjmp	.+2      	; 0x77a0 <vfprintf+0x334>
    779e:	80 e2       	ldi	r24, 0x20	; 32
    77a0:	37 fd       	sbrc	r19, 7
    77a2:	8d e2       	ldi	r24, 0x2D	; 45
    77a4:	b7 01       	movw	r22, r14
    77a6:	90 e0       	ldi	r25, 0x00	; 0
    77a8:	3a d0       	rcall	.+116    	; 0x781e <fputc>
    77aa:	a5 14       	cp	r10, r5
    77ac:	30 f4       	brcc	.+12     	; 0x77ba <vfprintf+0x34e>
    77ae:	b7 01       	movw	r22, r14
    77b0:	80 e3       	ldi	r24, 0x30	; 48
    77b2:	90 e0       	ldi	r25, 0x00	; 0
    77b4:	34 d0       	rcall	.+104    	; 0x781e <fputc>
    77b6:	5a 94       	dec	r5
    77b8:	f8 cf       	rjmp	.-16     	; 0x77aa <vfprintf+0x33e>
    77ba:	aa 94       	dec	r10
    77bc:	f4 01       	movw	r30, r8
    77be:	ea 0d       	add	r30, r10
    77c0:	f1 1d       	adc	r31, r1
    77c2:	80 81       	ld	r24, Z
    77c4:	b7 01       	movw	r22, r14
    77c6:	90 e0       	ldi	r25, 0x00	; 0
    77c8:	2a d0       	rcall	.+84     	; 0x781e <fputc>
    77ca:	a1 10       	cpse	r10, r1
    77cc:	f6 cf       	rjmp	.-20     	; 0x77ba <vfprintf+0x34e>
    77ce:	33 20       	and	r3, r3
    77d0:	09 f4       	brne	.+2      	; 0x77d4 <vfprintf+0x368>
    77d2:	5d ce       	rjmp	.-838    	; 0x748e <vfprintf+0x22>
    77d4:	b7 01       	movw	r22, r14
    77d6:	80 e2       	ldi	r24, 0x20	; 32
    77d8:	90 e0       	ldi	r25, 0x00	; 0
    77da:	21 d0       	rcall	.+66     	; 0x781e <fputc>
    77dc:	3a 94       	dec	r3
    77de:	f7 cf       	rjmp	.-18     	; 0x77ce <vfprintf+0x362>
    77e0:	f7 01       	movw	r30, r14
    77e2:	86 81       	ldd	r24, Z+6	; 0x06
    77e4:	97 81       	ldd	r25, Z+7	; 0x07
    77e6:	02 c0       	rjmp	.+4      	; 0x77ec <vfprintf+0x380>
    77e8:	8f ef       	ldi	r24, 0xFF	; 255
    77ea:	9f ef       	ldi	r25, 0xFF	; 255
    77ec:	2c 96       	adiw	r28, 0x0c	; 12
    77ee:	e2 e1       	ldi	r30, 0x12	; 18
    77f0:	11 c1       	rjmp	.+546    	; 0x7a14 <__epilogue_restores__>

000077f2 <strnlen_P>:
    77f2:	fc 01       	movw	r30, r24
    77f4:	05 90       	lpm	r0, Z+
    77f6:	61 50       	subi	r22, 0x01	; 1
    77f8:	70 40       	sbci	r23, 0x00	; 0
    77fa:	01 10       	cpse	r0, r1
    77fc:	d8 f7       	brcc	.-10     	; 0x77f4 <strnlen_P+0x2>
    77fe:	80 95       	com	r24
    7800:	90 95       	com	r25
    7802:	8e 0f       	add	r24, r30
    7804:	9f 1f       	adc	r25, r31
    7806:	08 95       	ret

00007808 <strnlen>:
    7808:	fc 01       	movw	r30, r24
    780a:	61 50       	subi	r22, 0x01	; 1
    780c:	70 40       	sbci	r23, 0x00	; 0
    780e:	01 90       	ld	r0, Z+
    7810:	01 10       	cpse	r0, r1
    7812:	d8 f7       	brcc	.-10     	; 0x780a <strnlen+0x2>
    7814:	80 95       	com	r24
    7816:	90 95       	com	r25
    7818:	8e 0f       	add	r24, r30
    781a:	9f 1f       	adc	r25, r31
    781c:	08 95       	ret

0000781e <fputc>:
    781e:	0f 93       	push	r16
    7820:	1f 93       	push	r17
    7822:	cf 93       	push	r28
    7824:	df 93       	push	r29
    7826:	fb 01       	movw	r30, r22
    7828:	23 81       	ldd	r18, Z+3	; 0x03
    782a:	21 fd       	sbrc	r18, 1
    782c:	03 c0       	rjmp	.+6      	; 0x7834 <fputc+0x16>
    782e:	8f ef       	ldi	r24, 0xFF	; 255
    7830:	9f ef       	ldi	r25, 0xFF	; 255
    7832:	28 c0       	rjmp	.+80     	; 0x7884 <fputc+0x66>
    7834:	22 ff       	sbrs	r18, 2
    7836:	16 c0       	rjmp	.+44     	; 0x7864 <fputc+0x46>
    7838:	46 81       	ldd	r20, Z+6	; 0x06
    783a:	57 81       	ldd	r21, Z+7	; 0x07
    783c:	24 81       	ldd	r18, Z+4	; 0x04
    783e:	35 81       	ldd	r19, Z+5	; 0x05
    7840:	42 17       	cp	r20, r18
    7842:	53 07       	cpc	r21, r19
    7844:	44 f4       	brge	.+16     	; 0x7856 <fputc+0x38>
    7846:	a0 81       	ld	r26, Z
    7848:	b1 81       	ldd	r27, Z+1	; 0x01
    784a:	9d 01       	movw	r18, r26
    784c:	2f 5f       	subi	r18, 0xFF	; 255
    784e:	3f 4f       	sbci	r19, 0xFF	; 255
    7850:	31 83       	std	Z+1, r19	; 0x01
    7852:	20 83       	st	Z, r18
    7854:	8c 93       	st	X, r24
    7856:	26 81       	ldd	r18, Z+6	; 0x06
    7858:	37 81       	ldd	r19, Z+7	; 0x07
    785a:	2f 5f       	subi	r18, 0xFF	; 255
    785c:	3f 4f       	sbci	r19, 0xFF	; 255
    785e:	37 83       	std	Z+7, r19	; 0x07
    7860:	26 83       	std	Z+6, r18	; 0x06
    7862:	10 c0       	rjmp	.+32     	; 0x7884 <fputc+0x66>
    7864:	eb 01       	movw	r28, r22
    7866:	09 2f       	mov	r16, r25
    7868:	18 2f       	mov	r17, r24
    786a:	00 84       	ldd	r0, Z+8	; 0x08
    786c:	f1 85       	ldd	r31, Z+9	; 0x09
    786e:	e0 2d       	mov	r30, r0
    7870:	09 95       	icall
    7872:	89 2b       	or	r24, r25
    7874:	e1 f6       	brne	.-72     	; 0x782e <fputc+0x10>
    7876:	8e 81       	ldd	r24, Y+6	; 0x06
    7878:	9f 81       	ldd	r25, Y+7	; 0x07
    787a:	01 96       	adiw	r24, 0x01	; 1
    787c:	9f 83       	std	Y+7, r25	; 0x07
    787e:	8e 83       	std	Y+6, r24	; 0x06
    7880:	81 2f       	mov	r24, r17
    7882:	90 2f       	mov	r25, r16
    7884:	df 91       	pop	r29
    7886:	cf 91       	pop	r28
    7888:	1f 91       	pop	r17
    788a:	0f 91       	pop	r16
    788c:	08 95       	ret

0000788e <__ultoa_invert>:
    788e:	fa 01       	movw	r30, r20
    7890:	aa 27       	eor	r26, r26
    7892:	28 30       	cpi	r18, 0x08	; 8
    7894:	51 f1       	breq	.+84     	; 0x78ea <__ultoa_invert+0x5c>
    7896:	20 31       	cpi	r18, 0x10	; 16
    7898:	81 f1       	breq	.+96     	; 0x78fa <__ultoa_invert+0x6c>
    789a:	e8 94       	clt
    789c:	6f 93       	push	r22
    789e:	6e 7f       	andi	r22, 0xFE	; 254
    78a0:	6e 5f       	subi	r22, 0xFE	; 254
    78a2:	7f 4f       	sbci	r23, 0xFF	; 255
    78a4:	8f 4f       	sbci	r24, 0xFF	; 255
    78a6:	9f 4f       	sbci	r25, 0xFF	; 255
    78a8:	af 4f       	sbci	r26, 0xFF	; 255
    78aa:	b1 e0       	ldi	r27, 0x01	; 1
    78ac:	3e d0       	rcall	.+124    	; 0x792a <__ultoa_invert+0x9c>
    78ae:	b4 e0       	ldi	r27, 0x04	; 4
    78b0:	3c d0       	rcall	.+120    	; 0x792a <__ultoa_invert+0x9c>
    78b2:	67 0f       	add	r22, r23
    78b4:	78 1f       	adc	r23, r24
    78b6:	89 1f       	adc	r24, r25
    78b8:	9a 1f       	adc	r25, r26
    78ba:	a1 1d       	adc	r26, r1
    78bc:	68 0f       	add	r22, r24
    78be:	79 1f       	adc	r23, r25
    78c0:	8a 1f       	adc	r24, r26
    78c2:	91 1d       	adc	r25, r1
    78c4:	a1 1d       	adc	r26, r1
    78c6:	6a 0f       	add	r22, r26
    78c8:	71 1d       	adc	r23, r1
    78ca:	81 1d       	adc	r24, r1
    78cc:	91 1d       	adc	r25, r1
    78ce:	a1 1d       	adc	r26, r1
    78d0:	20 d0       	rcall	.+64     	; 0x7912 <__ultoa_invert+0x84>
    78d2:	09 f4       	brne	.+2      	; 0x78d6 <__ultoa_invert+0x48>
    78d4:	68 94       	set
    78d6:	3f 91       	pop	r19
    78d8:	2a e0       	ldi	r18, 0x0A	; 10
    78da:	26 9f       	mul	r18, r22
    78dc:	11 24       	eor	r1, r1
    78de:	30 19       	sub	r19, r0
    78e0:	30 5d       	subi	r19, 0xD0	; 208
    78e2:	31 93       	st	Z+, r19
    78e4:	de f6       	brtc	.-74     	; 0x789c <__ultoa_invert+0xe>
    78e6:	cf 01       	movw	r24, r30
    78e8:	08 95       	ret
    78ea:	46 2f       	mov	r20, r22
    78ec:	47 70       	andi	r20, 0x07	; 7
    78ee:	40 5d       	subi	r20, 0xD0	; 208
    78f0:	41 93       	st	Z+, r20
    78f2:	b3 e0       	ldi	r27, 0x03	; 3
    78f4:	0f d0       	rcall	.+30     	; 0x7914 <__ultoa_invert+0x86>
    78f6:	c9 f7       	brne	.-14     	; 0x78ea <__ultoa_invert+0x5c>
    78f8:	f6 cf       	rjmp	.-20     	; 0x78e6 <__ultoa_invert+0x58>
    78fa:	46 2f       	mov	r20, r22
    78fc:	4f 70       	andi	r20, 0x0F	; 15
    78fe:	40 5d       	subi	r20, 0xD0	; 208
    7900:	4a 33       	cpi	r20, 0x3A	; 58
    7902:	18 f0       	brcs	.+6      	; 0x790a <__ultoa_invert+0x7c>
    7904:	49 5d       	subi	r20, 0xD9	; 217
    7906:	31 fd       	sbrc	r19, 1
    7908:	40 52       	subi	r20, 0x20	; 32
    790a:	41 93       	st	Z+, r20
    790c:	02 d0       	rcall	.+4      	; 0x7912 <__ultoa_invert+0x84>
    790e:	a9 f7       	brne	.-22     	; 0x78fa <__ultoa_invert+0x6c>
    7910:	ea cf       	rjmp	.-44     	; 0x78e6 <__ultoa_invert+0x58>
    7912:	b4 e0       	ldi	r27, 0x04	; 4
    7914:	a6 95       	lsr	r26
    7916:	97 95       	ror	r25
    7918:	87 95       	ror	r24
    791a:	77 95       	ror	r23
    791c:	67 95       	ror	r22
    791e:	ba 95       	dec	r27
    7920:	c9 f7       	brne	.-14     	; 0x7914 <__ultoa_invert+0x86>
    7922:	00 97       	sbiw	r24, 0x00	; 0
    7924:	61 05       	cpc	r22, r1
    7926:	71 05       	cpc	r23, r1
    7928:	08 95       	ret
    792a:	9b 01       	movw	r18, r22
    792c:	ac 01       	movw	r20, r24
    792e:	0a 2e       	mov	r0, r26
    7930:	06 94       	lsr	r0
    7932:	57 95       	ror	r21
    7934:	47 95       	ror	r20
    7936:	37 95       	ror	r19
    7938:	27 95       	ror	r18
    793a:	ba 95       	dec	r27
    793c:	c9 f7       	brne	.-14     	; 0x7930 <__ultoa_invert+0xa2>
    793e:	62 0f       	add	r22, r18
    7940:	73 1f       	adc	r23, r19
    7942:	84 1f       	adc	r24, r20
    7944:	95 1f       	adc	r25, r21
    7946:	a0 1d       	adc	r26, r0
    7948:	08 95       	ret

0000794a <eeprom_read_block>:
    794a:	dc 01       	movw	r26, r24
    794c:	cb 01       	movw	r24, r22

0000794e <eeprom_read_blraw>:
    794e:	fc 01       	movw	r30, r24
    7950:	f9 99       	sbic	0x1f, 1	; 31
    7952:	fe cf       	rjmp	.-4      	; 0x7950 <eeprom_read_blraw+0x2>
    7954:	06 c0       	rjmp	.+12     	; 0x7962 <eeprom_read_blraw+0x14>
    7956:	f2 bd       	out	0x22, r31	; 34
    7958:	e1 bd       	out	0x21, r30	; 33
    795a:	f8 9a       	sbi	0x1f, 0	; 31
    795c:	31 96       	adiw	r30, 0x01	; 1
    795e:	00 b4       	in	r0, 0x20	; 32
    7960:	0d 92       	st	X+, r0
    7962:	41 50       	subi	r20, 0x01	; 1
    7964:	50 40       	sbci	r21, 0x00	; 0
    7966:	b8 f7       	brcc	.-18     	; 0x7956 <eeprom_read_blraw+0x8>
    7968:	08 95       	ret

0000796a <eeprom_read_byte>:
    796a:	f9 99       	sbic	0x1f, 1	; 31
    796c:	fe cf       	rjmp	.-4      	; 0x796a <eeprom_read_byte>
    796e:	92 bd       	out	0x22, r25	; 34
    7970:	81 bd       	out	0x21, r24	; 33
    7972:	f8 9a       	sbi	0x1f, 0	; 31
    7974:	99 27       	eor	r25, r25
    7976:	80 b5       	in	r24, 0x20	; 32
    7978:	08 95       	ret

0000797a <eeprom_read_word>:
    797a:	a8 e1       	ldi	r26, 0x18	; 24
    797c:	b0 e0       	ldi	r27, 0x00	; 0
    797e:	42 e0       	ldi	r20, 0x02	; 2
    7980:	50 e0       	ldi	r21, 0x00	; 0
    7982:	e5 cf       	rjmp	.-54     	; 0x794e <eeprom_read_blraw>

00007984 <eeprom_update_byte>:
    7984:	26 2f       	mov	r18, r22

00007986 <eeprom_update_r18>:
    7986:	f9 99       	sbic	0x1f, 1	; 31
    7988:	fe cf       	rjmp	.-4      	; 0x7986 <eeprom_update_r18>
    798a:	92 bd       	out	0x22, r25	; 34
    798c:	81 bd       	out	0x21, r24	; 33
    798e:	f8 9a       	sbi	0x1f, 0	; 31
    7990:	01 97       	sbiw	r24, 0x01	; 1
    7992:	00 b4       	in	r0, 0x20	; 32
    7994:	02 16       	cp	r0, r18
    7996:	39 f0       	breq	.+14     	; 0x79a6 <eeprom_update_r18+0x20>
    7998:	1f ba       	out	0x1f, r1	; 31
    799a:	20 bd       	out	0x20, r18	; 32
    799c:	0f b6       	in	r0, 0x3f	; 63
    799e:	f8 94       	cli
    79a0:	fa 9a       	sbi	0x1f, 2	; 31
    79a2:	f9 9a       	sbi	0x1f, 1	; 31
    79a4:	0f be       	out	0x3f, r0	; 63
    79a6:	08 95       	ret

000079a8 <eeprom_write_block>:
    79a8:	dc 01       	movw	r26, r24
    79aa:	cb 01       	movw	r24, r22
    79ac:	02 c0       	rjmp	.+4      	; 0x79b2 <eeprom_write_block+0xa>
    79ae:	2d 91       	ld	r18, X+
    79b0:	05 d0       	rcall	.+10     	; 0x79bc <eeprom_write_r18>
    79b2:	41 50       	subi	r20, 0x01	; 1
    79b4:	50 40       	sbci	r21, 0x00	; 0
    79b6:	d8 f7       	brcc	.-10     	; 0x79ae <eeprom_write_block+0x6>
    79b8:	08 95       	ret

000079ba <eeprom_write_byte>:
    79ba:	26 2f       	mov	r18, r22

000079bc <eeprom_write_r18>:
    79bc:	f9 99       	sbic	0x1f, 1	; 31
    79be:	fe cf       	rjmp	.-4      	; 0x79bc <eeprom_write_r18>
    79c0:	1f ba       	out	0x1f, r1	; 31
    79c2:	92 bd       	out	0x22, r25	; 34
    79c4:	81 bd       	out	0x21, r24	; 33
    79c6:	20 bd       	out	0x20, r18	; 32
    79c8:	0f b6       	in	r0, 0x3f	; 63
    79ca:	f8 94       	cli
    79cc:	fa 9a       	sbi	0x1f, 2	; 31
    79ce:	f9 9a       	sbi	0x1f, 1	; 31
    79d0:	0f be       	out	0x3f, r0	; 63
    79d2:	01 96       	adiw	r24, 0x01	; 1
    79d4:	08 95       	ret

000079d6 <eeprom_write_word>:
    79d6:	f1 df       	rcall	.-30     	; 0x79ba <eeprom_write_byte>
    79d8:	27 2f       	mov	r18, r23
    79da:	f0 cf       	rjmp	.-32     	; 0x79bc <eeprom_write_r18>

000079dc <__prologue_saves__>:
    79dc:	2f 92       	push	r2
    79de:	3f 92       	push	r3
    79e0:	4f 92       	push	r4
    79e2:	5f 92       	push	r5
    79e4:	6f 92       	push	r6
    79e6:	7f 92       	push	r7
    79e8:	8f 92       	push	r8
    79ea:	9f 92       	push	r9
    79ec:	af 92       	push	r10
    79ee:	bf 92       	push	r11
    79f0:	cf 92       	push	r12
    79f2:	df 92       	push	r13
    79f4:	ef 92       	push	r14
    79f6:	ff 92       	push	r15
    79f8:	0f 93       	push	r16
    79fa:	1f 93       	push	r17
    79fc:	cf 93       	push	r28
    79fe:	df 93       	push	r29
    7a00:	cd b7       	in	r28, 0x3d	; 61
    7a02:	de b7       	in	r29, 0x3e	; 62
    7a04:	ca 1b       	sub	r28, r26
    7a06:	db 0b       	sbc	r29, r27
    7a08:	0f b6       	in	r0, 0x3f	; 63
    7a0a:	f8 94       	cli
    7a0c:	de bf       	out	0x3e, r29	; 62
    7a0e:	0f be       	out	0x3f, r0	; 63
    7a10:	cd bf       	out	0x3d, r28	; 61
    7a12:	09 94       	ijmp

00007a14 <__epilogue_restores__>:
    7a14:	2a 88       	ldd	r2, Y+18	; 0x12
    7a16:	39 88       	ldd	r3, Y+17	; 0x11
    7a18:	48 88       	ldd	r4, Y+16	; 0x10
    7a1a:	5f 84       	ldd	r5, Y+15	; 0x0f
    7a1c:	6e 84       	ldd	r6, Y+14	; 0x0e
    7a1e:	7d 84       	ldd	r7, Y+13	; 0x0d
    7a20:	8c 84       	ldd	r8, Y+12	; 0x0c
    7a22:	9b 84       	ldd	r9, Y+11	; 0x0b
    7a24:	aa 84       	ldd	r10, Y+10	; 0x0a
    7a26:	b9 84       	ldd	r11, Y+9	; 0x09
    7a28:	c8 84       	ldd	r12, Y+8	; 0x08
    7a2a:	df 80       	ldd	r13, Y+7	; 0x07
    7a2c:	ee 80       	ldd	r14, Y+6	; 0x06
    7a2e:	fd 80       	ldd	r15, Y+5	; 0x05
    7a30:	0c 81       	ldd	r16, Y+4	; 0x04
    7a32:	1b 81       	ldd	r17, Y+3	; 0x03
    7a34:	aa 81       	ldd	r26, Y+2	; 0x02
    7a36:	b9 81       	ldd	r27, Y+1	; 0x01
    7a38:	ce 0f       	add	r28, r30
    7a3a:	d1 1d       	adc	r29, r1
    7a3c:	0f b6       	in	r0, 0x3f	; 63
    7a3e:	f8 94       	cli
    7a40:	de bf       	out	0x3e, r29	; 62
    7a42:	0f be       	out	0x3f, r0	; 63
    7a44:	cd bf       	out	0x3d, r28	; 61
    7a46:	ed 01       	movw	r28, r26
    7a48:	08 95       	ret

00007a4a <_exit>:
    7a4a:	f8 94       	cli

00007a4c <__stop_program>:
    7a4c:	ff cf       	rjmp	.-2      	; 0x7a4c <__stop_program>
