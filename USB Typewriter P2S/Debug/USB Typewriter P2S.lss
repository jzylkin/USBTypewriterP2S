
USB Typewriter P2S.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000002ce  00800100  00007a42  00007ad6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007a42  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006a8  008003ce  008003ce  00007da4  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00007da4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00007e00  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007a0  00000000  00000000  00007e40  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00010a4c  00000000  00000000  000085e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000321b  00000000  00000000  0001902c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00015e08  00000000  00000000  0001c247  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00002000  00000000  00000000  00032050  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0001b7d5  00000000  00000000  00034050  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000dc92  00000000  00000000  0004f825  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001318  00000000  00000000  0005d4b7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000b9da  00000000  00000000  0005e7cf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	4c c2       	rjmp	.+1176   	; 0x49a <__ctors_end>
       2:	00 00       	nop
       4:	67 c2       	rjmp	.+1230   	; 0x4d4 <__bad_interrupt>
       6:	00 00       	nop
       8:	65 c2       	rjmp	.+1226   	; 0x4d4 <__bad_interrupt>
       a:	00 00       	nop
       c:	63 c2       	rjmp	.+1222   	; 0x4d4 <__bad_interrupt>
       e:	00 00       	nop
      10:	61 c2       	rjmp	.+1218   	; 0x4d4 <__bad_interrupt>
      12:	00 00       	nop
      14:	5f c2       	rjmp	.+1214   	; 0x4d4 <__bad_interrupt>
      16:	00 00       	nop
      18:	5d c2       	rjmp	.+1210   	; 0x4d4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	5b c2       	rjmp	.+1206   	; 0x4d4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	59 c2       	rjmp	.+1202   	; 0x4d4 <__bad_interrupt>
      22:	00 00       	nop
      24:	57 c2       	rjmp	.+1198   	; 0x4d4 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 a6 36 	jmp	0x6d4c	; 0x6d4c <__vector_10>
      2c:	53 c2       	rjmp	.+1190   	; 0x4d4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	51 c2       	rjmp	.+1186   	; 0x4d4 <__bad_interrupt>
      32:	00 00       	nop
      34:	4f c2       	rjmp	.+1182   	; 0x4d4 <__bad_interrupt>
      36:	00 00       	nop
      38:	4d c2       	rjmp	.+1178   	; 0x4d4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	4b c2       	rjmp	.+1174   	; 0x4d4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	49 c2       	rjmp	.+1170   	; 0x4d4 <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 8e 26 	jmp	0x4d1c	; 0x4d1c <__vector_17>
      48:	45 c2       	rjmp	.+1162   	; 0x4d4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	43 c2       	rjmp	.+1158   	; 0x4d4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	41 c2       	rjmp	.+1154   	; 0x4d4 <__bad_interrupt>
      52:	00 00       	nop
      54:	3f c2       	rjmp	.+1150   	; 0x4d4 <__bad_interrupt>
      56:	00 00       	nop
      58:	3d c2       	rjmp	.+1146   	; 0x4d4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	3b c2       	rjmp	.+1142   	; 0x4d4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	39 c2       	rjmp	.+1138   	; 0x4d4 <__bad_interrupt>
      62:	00 00       	nop
      64:	0c 94 ea 25 	jmp	0x4bd4	; 0x4bd4 <__vector_25>
      68:	0c 94 18 26 	jmp	0x4c30	; 0x4c30 <__vector_26>
      6c:	33 c2       	rjmp	.+1126   	; 0x4d4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	31 c2       	rjmp	.+1122   	; 0x4d4 <__bad_interrupt>
      72:	00 00       	nop
      74:	2f c2       	rjmp	.+1118   	; 0x4d4 <__bad_interrupt>
      76:	00 00       	nop
      78:	2d c2       	rjmp	.+1114   	; 0x4d4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	2b c2       	rjmp	.+1110   	; 0x4d4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	29 c2       	rjmp	.+1106   	; 0x4d4 <__bad_interrupt>
      82:	00 00       	nop
      84:	27 c2       	rjmp	.+1102   	; 0x4d4 <__bad_interrupt>
      86:	00 00       	nop
      88:	25 c2       	rjmp	.+1098   	; 0x4d4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	23 c2       	rjmp	.+1094   	; 0x4d4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	21 c2       	rjmp	.+1090   	; 0x4d4 <__bad_interrupt>
      92:	00 00       	nop
      94:	1f c2       	rjmp	.+1086   	; 0x4d4 <__bad_interrupt>
      96:	00 00       	nop
      98:	1d c2       	rjmp	.+1082   	; 0x4d4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	1b c2       	rjmp	.+1078   	; 0x4d4 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	19 c2       	rjmp	.+1074   	; 0x4d4 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	0c 94 4d 0a 	jmp	0x149a	; 0x149a <__vector_41>
      a8:	15 c2       	rjmp	.+1066   	; 0x4d4 <__bad_interrupt>
	...

000000ac <Str_Settings_Saved>:
      ac:	53 45 54 54 49 4e 47 53 20 53 41 56 45 44 21 0d     SETTINGS SAVED!.
	...

000000bd <Str_Spacebar_Blocks_Enter>:
      bd:	0d 49 47 4e 4f 52 45 20 45 4e 54 45 52 20 4b 45     .IGNORE ENTER KE
      cd:	59 20 57 48 45 4e 20 53 50 41 43 45 42 41 52 20     Y WHEN SPACEBAR 
      dd:	49 53 20 48 45 4c 44 3f 0d 00                       IS HELD?..

000000e7 <Str_Set_Reed_Time>:
      e7:	0d 4e 4f 57 20 53 45 54 20 52 45 45 44 20 52 45     .NOW SET REED RE
      f7:	41 43 54 49 4f 4e 20 54 49 4d 45 2e 2e 2e 0d 00     ACTION TIME.....

00000107 <Str_Set_Double_Time>:
     107:	0d 4e 4f 57 20 53 45 54 20 44 45 4c 41 59 20 42     .NOW SET DELAY B
     117:	45 54 57 45 45 4e 20 44 4f 55 42 4c 45 20 4b 45     ETWEEN DOUBLE KE
     127:	59 20 50 52 45 53 53 45 53 2e 2e 2e 0d 00           Y PRESSES.....

00000135 <Str_Set_Release_Time>:
     135:	0d 4e 4f 57 20 53 45 54 20 4b 45 59 20 52 45 4c     .NOW SET KEY REL
     145:	45 41 53 45 20 54 49 4d 45 2e 2e 2e 0d 00           EASE TIME.....

00000153 <Str_Set_Reaction_Time>:
     153:	50 52 45 53 53 20 43 54 52 4c 20 41 4e 44 20 41     PRESS CTRL AND A
     163:	4c 54 20 54 4f 20 53 45 54 20 4b 45 59 20 52 45     LT TO SET KEY RE
     173:	41 43 54 49 4f 4e 20 54 49 4d 45 2e 2e 2e 0d 00     ACTION TIME.....

00000183 <Str_Press_CMD>:
     183:	50 52 45 53 53 20 43 4d 44 20 4b 45 59 20 54 4f     PRESS CMD KEY TO
     193:	20 43 4f 4e 54 49 4e 55 45 2e 2e 2e 0d 00            CONTINUE.....

000001a1 <Str_Adj_Sensitivity>:
     1a1:	41 44 4a 55 53 54 49 4e 47 20 4b 45 59 20 53 45     ADJUSTING KEY SE
     1b1:	4e 53 49 54 49 56 49 54 59 2e 0d 00                 NSITIVITY...

000001bd <Str_No_Hall>:
     1bd:	4e 4f 20 48 41 4c 4c 20 45 46 46 45 43 54 20 53     NO HALL EFFECT S
     1cd:	45 4e 53 4f 52 20 44 45 54 45 43 54 45 44 2e 20     ENSOR DETECTED. 
     1dd:	28 4e 4f 54 20 41 20 50 52 4f 42 4c 45 4d 29 0d     (NOT A PROBLEM).
	...

000001ee <Str_Calibrate_Hall>:
     1ee:	48 4f 4c 44 20 44 4f 57 4e 20 41 4e 59 20 4b 45     HOLD DOWN ANY KE
     1fe:	59 20 54 4f 20 43 41 4c 49 42 52 41 54 45 20 48     Y TO CALIBRATE H
     20e:	41 4c 4c 20 45 46 46 45 43 54 20 53 45 4e 53 4f     ALL EFFECT SENSO
     21e:	52 2e 2e 2e 0d 00                                   R.....

00000224 <Str_Backspace>:
     224:	42 41 43 4b 53 50 41 43 45 00                       BACKSPACE.

0000022e <Str_Post>:
     22e:	53 45 4e 44 00                                      SEND.

00000233 <Str_Second_Enter>:
     233:	53 45 43 4f 4e 44 41 52 59 20 45 4e 54 45 52 00     SECONDARY ENTER.

00000243 <Str_Enter>:
     243:	45 4e 54 45 52 00                                   ENTER.

00000249 <Str_Spacebar>:
     249:	53 50 41 43 45 42 41 52 00                          SPACEBAR.

00000252 <Str_Quick_Calibrate>:
     252:	51 55 49 43 4b 20 43 41 4c 49 42 52 41 54 49 4f     QUICK CALIBRATIO
     262:	4e 20 4d 4f 44 45 2e 2e 2e 0d 00                    N MODE.....

0000026d <Str_No_Dummy_Load>:
     26d:	44 55 4d 4d 59 20 4c 4f 41 44 20 44 45 41 43 54     DUMMY LOAD DEACT
     27d:	49 56 41 54 45 44 0d 00                             IVATED..

00000285 <Str_Dummy_Load>:
     285:	44 55 4d 4d 59 20 4c 4f 41 44 20 41 43 54 49 56     DUMMY LOAD ACTIV
     295:	41 54 45 44 0d 00                                   ATED..

0000029b <Str_Shift_Error>:
     29b:	45 52 52 4f 52 2e 2e 2e 53 48 49 46 54 20 4d 55     ERROR...SHIFT MU
     2ab:	53 54 20 42 45 20 41 20 52 45 45 44 20 53 57 49     ST BE A REED SWI
     2bb:	54 43 48 2e 0d 00                                   TCH...

000002c1 <Str_Type_The_Following>:
     2c1:	54 59 50 45 20 54 48 45 20 46 4f 4c 4c 4f 57 49     TYPE THE FOLLOWI
     2d1:	4e 47 20 4b 45 59 53 20 28 50 52 45 53 53 20 53     NG KEYS (PRESS S
     2e1:	50 41 43 45 20 54 4f 20 53 4b 49 50 29 2e 2e 2e     PACE TO SKIP)...
     2f1:	0d 00                                               ..

000002f3 <Str_Calibrating>:
     2f3:	43 41 4c 49 42 52 41 54 49 4e 47 2e 2e 2e 0d 00     CALIBRATING.....

00000303 <Str_SD_Mode>:
     303:	53 44 20 43 41 52 44 20 53 54 4f 52 41 47 45 20     SD CARD STORAGE 
     313:	4d 4f 44 45 0d 00                                   MODE..

00000319 <Str_Combo_Mode>:
     319:	55 53 42 20 4b 45 59 42 4f 41 52 44 2f 43 41 52     USB KEYBOARD/CAR
     329:	44 20 52 45 41 44 45 52 20 4d 4f 44 45 0d 00        D READER MODE..

00000338 <Str_Light_Mode>:
     338:	4c 49 47 48 54 20 4d 4f 44 45 20 28 53 44 20 43     LIGHT MODE (SD C
     348:	41 52 44 20 52 45 41 44 45 52 20 44 49 53 41 42     ARD READER DISAB
     358:	4c 45 44 29 0d 00                                   LED)..

0000035e <Str_BT_Mode>:
     35e:	42 4c 55 45 54 4f 4f 54 48 20 4b 45 59 42 4f 41     BLUETOOTH KEYBOA
     36e:	52 44 20 4d 4f 44 45 0d 00                          RD MODE..

00000377 <Str_Typewriter_Mode>:
     377:	44 45 46 41 55 4c 54 20 53 45 54 54 49 4e 47 3a     DEFAULT SETTING:
     387:	20 00                                                .

00000389 <Str_Firmware_Ver>:
     389:	46 49 52 4d 57 41 52 45 20 56 45 52 20 35 2e 32     FIRMWARE VER 5.2
     399:	2e 31 33 00                                         .13.

0000039d <Str_USB_Typewriter>:
     39d:	55 53 42 20 54 59 50 45 57 52 49 54 45 52 20 28     USB TYPEWRITER (
     3ad:	54 4d 29 0d 00                                      TM)..

000003b2 <ProductString>:
     3b2:	30 03 55 00 53 00 42 00 20 00 54 00 79 00 70 00     0.U.S.B. .T.y.p.
     3c2:	65 00 77 00 72 00 69 00 74 00 65 00 72 00 20 00     e.w.r.i.t.e.r. .
     3d2:	4b 00 65 00 79 00 62 00 6f 00 61 00 72 00 64 00     K.e.y.b.o.a.r.d.
	...

000003e4 <ManufacturerString>:
     3e4:	26 03 55 00 53 00 42 00 20 00 54 00 59 00 50 00     &.U.S.B. .T.Y.P.
     3f4:	45 00 57 00 52 00 49 00 54 00 45 00 52 00 20 00     E.W.R.I.T.E.R. .
     404:	4c 00 4c 00 43 00 00 00                             L.L.C...

0000040c <LanguageString>:
     40c:	04 03 09 04                                         ....

00000410 <ConfigurationDescriptor>:
     410:	09 02 39 00 02 01 00 80 07 09 04 00 00 02 08 06     ..9.............
     420:	50 00 07 05 83 02 40 00 05 07 05 04 02 40 00 05     P.....@......@..
     430:	09 04 01 00 01 03 01 01 00 09 21 11 01 00 01 22     ..........!...."
     440:	3f 00 07 05 81 03 08 00 05                          ?........

00000449 <DeviceDescriptor>:
     449:	12 01 10 01 00 00 00 08 eb 03 61 20 86 00 01 02     ..........a ....
     459:	dc 01                                               ..

0000045b <KeyboardReport>:
     45b:	05 01 09 06 a1 01 05 07 19 e0 29 e7 15 00 25 01     ..........)...%.
     46b:	75 01 95 08 81 02 95 01 75 08 81 01 05 08 19 01     u.......u.......
     47b:	29 05 95 05 75 01 91 02 95 01 75 03 91 01 15 00     )...u.....u.....
     48b:	25 ff 05 07 19 00 29 ff 95 06 75 08 81 00 c0        %.....)...u....

0000049a <__ctors_end>:
     49a:	11 24       	eor	r1, r1
     49c:	1f be       	out	0x3f, r1	; 63
     49e:	cf ef       	ldi	r28, 0xFF	; 255
     4a0:	da e0       	ldi	r29, 0x0A	; 10
     4a2:	de bf       	out	0x3e, r29	; 62
     4a4:	cd bf       	out	0x3d, r28	; 61

000004a6 <__do_copy_data>:
     4a6:	13 e0       	ldi	r17, 0x03	; 3
     4a8:	a0 e0       	ldi	r26, 0x00	; 0
     4aa:	b1 e0       	ldi	r27, 0x01	; 1
     4ac:	e2 e4       	ldi	r30, 0x42	; 66
     4ae:	fa e7       	ldi	r31, 0x7A	; 122
     4b0:	02 c0       	rjmp	.+4      	; 0x4b6 <__do_copy_data+0x10>
     4b2:	05 90       	lpm	r0, Z+
     4b4:	0d 92       	st	X+, r0
     4b6:	ae 3c       	cpi	r26, 0xCE	; 206
     4b8:	b1 07       	cpc	r27, r17
     4ba:	d9 f7       	brne	.-10     	; 0x4b2 <__do_copy_data+0xc>

000004bc <__do_clear_bss>:
     4bc:	2a e0       	ldi	r18, 0x0A	; 10
     4be:	ae ec       	ldi	r26, 0xCE	; 206
     4c0:	b3 e0       	ldi	r27, 0x03	; 3
     4c2:	01 c0       	rjmp	.+2      	; 0x4c6 <.do_clear_bss_start>

000004c4 <.do_clear_bss_loop>:
     4c4:	1d 92       	st	X+, r1

000004c6 <.do_clear_bss_start>:
     4c6:	a6 37       	cpi	r26, 0x76	; 118
     4c8:	b2 07       	cpc	r27, r18
     4ca:	e1 f7       	brne	.-8      	; 0x4c4 <.do_clear_bss_loop>
     4cc:	0e 94 78 28 	call	0x50f0	; 0x50f0 <main>
     4d0:	0c 94 1f 3d 	jmp	0x7a3e	; 0x7a3e <_exit>

000004d4 <__bad_interrupt>:
     4d4:	95 cd       	rjmp	.-1238   	; 0x0 <__vectors>

000004d6 <Bluetooth_Reset>:
	return Get_Response(verbose);
}

	
void Bluetooth_Reset(){
	set_low(BT_RESET);//reset the bluetooth module
     4d6:	8f 98       	cbi	0x11, 7	; 17
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     4d8:	2f e7       	ldi	r18, 0x7F	; 127
     4da:	88 e3       	ldi	r24, 0x38	; 56
     4dc:	91 e0       	ldi	r25, 0x01	; 1
     4de:	21 50       	subi	r18, 0x01	; 1
     4e0:	80 40       	sbci	r24, 0x00	; 0
     4e2:	90 40       	sbci	r25, 0x00	; 0
     4e4:	e1 f7       	brne	.-8      	; 0x4de <Bluetooth_Reset+0x8>
     4e6:	00 c0       	rjmp	.+0      	; 0x4e8 <Bluetooth_Reset+0x12>
     4e8:	00 00       	nop
	Delay_MS(50); //hold in reset for 50ms
	set_high(BT_RESET); //reactivate bluetooth module
     4ea:	8f 9a       	sbi	0x11, 7	; 17
     4ec:	2f ef       	ldi	r18, 0xFF	; 255
     4ee:	84 e3       	ldi	r24, 0x34	; 52
     4f0:	9c e0       	ldi	r25, 0x0C	; 12
     4f2:	21 50       	subi	r18, 0x01	; 1
     4f4:	80 40       	sbci	r24, 0x00	; 0
     4f6:	90 40       	sbci	r25, 0x00	; 0
     4f8:	e1 f7       	brne	.-8      	; 0x4f2 <Bluetooth_Reset+0x1c>
     4fa:	00 c0       	rjmp	.+0      	; 0x4fc <Bluetooth_Reset+0x26>
     4fc:	00 00       	nop
	Delay_MS(BLUETOOTH_RESET_DELAY);//takes 500ms from power on for module to be able to receive commands.
	
	set_low(BT_CTS);//this wakes the buetooth module
     4fe:	76 98       	cbi	0x0e, 6	; 14
     500:	8f e0       	ldi	r24, 0x0F	; 15
     502:	97 e2       	ldi	r25, 0x27	; 39
     504:	01 97       	sbiw	r24, 0x01	; 1
     506:	f1 f7       	brne	.-4      	; 0x504 <Bluetooth_Reset+0x2e>
     508:	00 c0       	rjmp	.+0      	; 0x50a <Bluetooth_Reset+0x34>
     50a:	00 00       	nop
     50c:	08 95       	ret

0000050e <Get_Response>:
	Delay_MS(5);//it takes 5ms to wake up from low-power state
	
}


bool Get_Response(bool verbose){
     50e:	cf 92       	push	r12
     510:	df 92       	push	r13
     512:	ef 92       	push	r14
     514:	ff 92       	push	r15
     516:	1f 93       	push	r17
     518:	cf 93       	push	r28
     51a:	df 93       	push	r29
	uint16_t tmpchar;
	if(verbose){
     51c:	88 23       	and	r24, r24
     51e:	c1 f1       	breq	.+112    	; 0x590 <Get_Response+0x82>
     520:	2f ef       	ldi	r18, 0xFF	; 255
     522:	80 e7       	ldi	r24, 0x70	; 112
     524:	92 e0       	ldi	r25, 0x02	; 2
     526:	21 50       	subi	r18, 0x01	; 1
     528:	80 40       	sbci	r24, 0x00	; 0
     52a:	90 40       	sbci	r25, 0x00	; 0
     52c:	e1 f7       	brne	.-8      	; 0x526 <Get_Response+0x18>
     52e:	00 c0       	rjmp	.+0      	; 0x530 <Get_Response+0x22>
     530:	00 00       	nop
		Delay_MS(BLUETOOTH_RESPONSE_DELAY); //wait for the response to be sent.
		response[0] = '\0'; //clear response string
     532:	e3 e9       	ldi	r30, 0x93	; 147
     534:	f6 e0       	ldi	r31, 0x06	; 6
     536:	10 82       	st	Z, r1
		response[1] = '\0';
     538:	11 82       	std	Z+1, r1	; 0x01
		response[2] = '\0';
     53a:	12 82       	std	Z+2, r1	; 0x02
		response[4] = '\0';
     53c:	14 82       	std	Z+4, r1	; 0x04
     53e:	7f 01       	movw	r14, r30
     540:	0f 2e       	mov	r0, r31
     542:	f3 ed       	ldi	r31, 0xD3	; 211
     544:	cf 2e       	mov	r12, r31
     546:	f6 e0       	ldi	r31, 0x06	; 6
     548:	df 2e       	mov	r13, r31
     54a:	f0 2d       	mov	r31, r0
     54c:	ef 01       	movw	r28, r30
     54e:	1c 2f       	mov	r17, r28
     550:	1e 19       	sub	r17, r14
	
		for(uint8_t i=0; i<response_buffer_len; i++){
			tmpchar = uart_getc();
     552:	0e 94 5b 26 	call	0x4cb6	; 0x4cb6 <uart_getc>
			if ((tmpchar & 0xFF00) != 0){ //check upper byte of getc for error code -- most commonly this would be "buffer empty"
     556:	9c 01       	movw	r18, r24
     558:	22 27       	eor	r18, r18
     55a:	23 2b       	or	r18, r19
     55c:	31 f0       	breq	.+12     	; 0x56a <Get_Response+0x5c>
				response[i]='\0'; //mark the string as having ended.
     55e:	e1 2f       	mov	r30, r17
     560:	f0 e0       	ldi	r31, 0x00	; 0
     562:	ed 56       	subi	r30, 0x6D	; 109
     564:	f9 4f       	sbci	r31, 0xF9	; 249
     566:	10 82       	st	Z, r1
				break; // reception is complete -- no more characters to retrieve.
     568:	04 c0       	rjmp	.+8      	; 0x572 <Get_Response+0x64>
			}
			
			response[i] = tmpchar & 0xFF; //store lower byte of getc as a uart character received
     56a:	89 93       	st	Y+, r24
		response[0] = '\0'; //clear response string
		response[1] = '\0';
		response[2] = '\0';
		response[4] = '\0';
	
		for(uint8_t i=0; i<response_buffer_len; i++){
     56c:	cc 15       	cp	r28, r12
     56e:	dd 05       	cpc	r29, r13
     570:	71 f7       	brne	.-36     	; 0x54e <Get_Response+0x40>
			
			response[i] = tmpchar & 0xFF; //store lower byte of getc as a uart character received
			
		}
		#ifdef DEBUG
			USBSendString(response);
     572:	83 e9       	ldi	r24, 0x93	; 147
     574:	96 e0       	ldi	r25, 0x06	; 6
     576:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
		#endif
		
		if ((response[0] == 'O')||(response[2] == '=')){  //if response is "OK" or "XX=...", bt module has received command successfully
     57a:	80 91 93 06 	lds	r24, 0x0693
     57e:	8f 34       	cpi	r24, 0x4F	; 79
     580:	49 f0       	breq	.+18     	; 0x594 <Get_Response+0x86>
     582:	81 e0       	ldi	r24, 0x01	; 1
     584:	90 91 95 06 	lds	r25, 0x0695
     588:	9d 33       	cpi	r25, 0x3D	; 61
     58a:	29 f0       	breq	.+10     	; 0x596 <Get_Response+0x88>
     58c:	80 e0       	ldi	r24, 0x00	; 0
     58e:	03 c0       	rjmp	.+6      	; 0x596 <Get_Response+0x88>
		else{
			return false;
		}
	}
	else{
		return true;
     590:	81 e0       	ldi	r24, 0x01	; 1
     592:	01 c0       	rjmp	.+2      	; 0x596 <Get_Response+0x88>
		#ifdef DEBUG
			USBSendString(response);
		#endif
		
		if ((response[0] == 'O')||(response[2] == '=')){  //if response is "OK" or "XX=...", bt module has received command successfully
			return true;
     594:	81 e0       	ldi	r24, 0x01	; 1
	else{
		return true;
	}

		
}
     596:	df 91       	pop	r29
     598:	cf 91       	pop	r28
     59a:	1f 91       	pop	r17
     59c:	ff 90       	pop	r15
     59e:	ef 90       	pop	r14
     5a0:	df 90       	pop	r13
     5a2:	cf 90       	pop	r12
     5a4:	08 95       	ret

000005a6 <Bluetooth_Send_CMD>:
 * 
 * \param command -- string containing formatted command to send to bluetooth module
 * 
 * \return void
 */
bool Bluetooth_Send_CMD(char* command, bool verbose){
     5a6:	1f 93       	push	r17
     5a8:	cf 93       	push	r28
     5aa:	df 93       	push	r29
     5ac:	ec 01       	movw	r28, r24
     5ae:	16 2f       	mov	r17, r22
	
	int i = 0;
	
	uart_clear_rx_buffer();
     5b0:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <uart_clear_rx_buffer>
	#ifdef DEBUG
	if(verbose){USBSendString("sending command\n");}
     5b4:	11 23       	and	r17, r17
     5b6:	21 f0       	breq	.+8      	; 0x5c0 <Bluetooth_Send_CMD+0x1a>
     5b8:	89 e6       	ldi	r24, 0x69	; 105
     5ba:	91 e0       	ldi	r25, 0x01	; 1
     5bc:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
	#endif
	
	while (command[i] != '\0'){//loop until end of string
     5c0:	88 81       	ld	r24, Y
     5c2:	88 23       	and	r24, r24
     5c4:	31 f0       	breq	.+12     	; 0x5d2 <Bluetooth_Send_CMD+0x2c>
     5c6:	21 96       	adiw	r28, 0x01	; 1
		uart_putc(command[i]); //send first character of command
     5c8:	0e 94 79 26 	call	0x4cf2	; 0x4cf2 <uart_putc>
	uart_clear_rx_buffer();
	#ifdef DEBUG
	if(verbose){USBSendString("sending command\n");}
	#endif
	
	while (command[i] != '\0'){//loop until end of string
     5cc:	89 91       	ld	r24, Y+
     5ce:	81 11       	cpse	r24, r1
     5d0:	fb cf       	rjmp	.-10     	; 0x5c8 <Bluetooth_Send_CMD+0x22>
		uart_putc(command[i]); //send first character of command
		i++;
	}
	uart_putc('\r');
     5d2:	8d e0       	ldi	r24, 0x0D	; 13
     5d4:	0e 94 79 26 	call	0x4cf2	; 0x4cf2 <uart_putc>
	uart_putc('\n'); //send return carriage
     5d8:	8a e0       	ldi	r24, 0x0A	; 10
     5da:	0e 94 79 26 	call	0x4cf2	; 0x4cf2 <uart_putc>

	return Get_Response(verbose);
     5de:	81 2f       	mov	r24, r17
     5e0:	96 df       	rcall	.-212    	; 0x50e <Get_Response>
}
     5e2:	df 91       	pop	r29
     5e4:	cf 91       	pop	r28
     5e6:	1f 91       	pop	r17
     5e8:	08 95       	ret

000005ea <Bluetooth_Send>:
 * \param key 
 * \param modifier
 * 
 * \return void
 */
void Bluetooth_Send(uint8_t key, uint8_t modifier){
     5ea:	ef 92       	push	r14
     5ec:	ff 92       	push	r15
     5ee:	0f 93       	push	r16
     5f0:	1f 93       	push	r17
     5f2:	cf 93       	push	r28
     5f4:	df 93       	push	r29
     5f6:	cd b7       	in	r28, 0x3d	; 61
     5f8:	de b7       	in	r29, 0x3e	; 62
     5fa:	a4 97       	sbiw	r28, 0x24	; 36
     5fc:	0f b6       	in	r0, 0x3f	; 63
     5fe:	f8 94       	cli
     600:	de bf       	out	0x3e, r29	; 62
     602:	0f be       	out	0x3f, r0	; 63
     604:	cd bf       	out	0x3d, r28	; 61
     606:	18 2f       	mov	r17, r24
     608:	06 2f       	mov	r16, r22
	char cmd_buffer[] = "AT+KR=A1,01,00,00,00,00,00,00,00,00";
     60a:	84 e2       	ldi	r24, 0x24	; 36
     60c:	eb ea       	ldi	r30, 0xAB	; 171
     60e:	f1 e0       	ldi	r31, 0x01	; 1
     610:	de 01       	movw	r26, r28
     612:	11 96       	adiw	r26, 0x01	; 1
     614:	01 90       	ld	r0, Z+
     616:	0d 92       	st	X+, r0
     618:	8a 95       	dec	r24
     61a:	e1 f7       	brne	.-8      	; 0x614 <Bluetooth_Send+0x2a>
//	set_high(BT_CTS);//toggle cts to wake module from deep sleep.
//	_delay_us(100);

	Bluetooth_Send_CMD("AT+UI=01",false);
     61c:	60 e0       	ldi	r22, 0x00	; 0
     61e:	8a e7       	ldi	r24, 0x7A	; 122
     620:	91 e0       	ldi	r25, 0x01	; 1
     622:	c1 df       	rcall	.-126    	; 0x5a6 <Bluetooth_Send_CMD>
     624:	8f ec       	ldi	r24, 0xCF	; 207
     626:	97 e0       	ldi	r25, 0x07	; 7
     628:	01 97       	sbiw	r24, 0x01	; 1
     62a:	f1 f7       	brne	.-4      	; 0x628 <Bluetooth_Send+0x3e>
     62c:	00 c0       	rjmp	.+0      	; 0x62e <Bluetooth_Send+0x44>
     62e:	00 00       	nop
	Delay_MS(1);
		if (key&FORCE_UPPER){ //in this program, we use the MSB of code to indicate that this key MUST be sent as upper case.
     630:	11 23       	and	r17, r17
     632:	14 f4       	brge	.+4      	; 0x638 <Bluetooth_Send+0x4e>
			reg_clr(key,FORCE_UPPER); //clear the MSB,
     634:	1f 77       	andi	r17, 0x7F	; 127
			modifier = UPPER; //and set the modifier to upper case.
     636:	02 e0       	ldi	r16, 0x02	; 2
		}
		
		if(key == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
     638:	14 37       	cpi	r17, 0x74	; 116
     63a:	11 f4       	brne	.+4      	; 0x640 <Bluetooth_Send+0x56>
			key = KEY_ENTER;
			modifier = HID_KEYBOARD_MODIFIER_LEFTCTRL;
     63c:	01 e0       	ldi	r16, 0x01	; 1
			reg_clr(key,FORCE_UPPER); //clear the MSB,
			modifier = UPPER; //and set the modifier to upper case.
		}
		
		if(key == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
			key = KEY_ENTER;
     63e:	18 e2       	ldi	r17, 0x28	; 40
			modifier = HID_KEYBOARD_MODIFIER_LEFTCTRL;
		}
		sprintf(cmd_buffer,"AT+KR=A1,01,%02x,00,%02x,00,00,00,00,00",modifier,key);
     640:	1f 92       	push	r1
     642:	1f 93       	push	r17
     644:	1f 92       	push	r1
     646:	0f 93       	push	r16
     648:	0f 2e       	mov	r0, r31
     64a:	f3 e8       	ldi	r31, 0x83	; 131
     64c:	ef 2e       	mov	r14, r31
     64e:	f1 e0       	ldi	r31, 0x01	; 1
     650:	ff 2e       	mov	r15, r31
     652:	f0 2d       	mov	r31, r0
     654:	ff 92       	push	r15
     656:	ef 92       	push	r14
     658:	8e 01       	movw	r16, r28
     65a:	0f 5f       	subi	r16, 0xFF	; 255
     65c:	1f 4f       	sbci	r17, 0xFF	; 255
     65e:	1f 93       	push	r17
     660:	0f 93       	push	r16
     662:	0e 94 10 3a 	call	0x7420	; 0x7420 <sprintf>
		Bluetooth_Send_CMD(cmd_buffer, false);
     666:	60 e0       	ldi	r22, 0x00	; 0
     668:	c8 01       	movw	r24, r16
     66a:	9d df       	rcall	.-198    	; 0x5a6 <Bluetooth_Send_CMD>
     66c:	8f ec       	ldi	r24, 0xCF	; 207
     66e:	97 e0       	ldi	r25, 0x07	; 7
     670:	01 97       	sbiw	r24, 0x01	; 1
     672:	f1 f7       	brne	.-4      	; 0x670 <Bluetooth_Send+0x86>
     674:	00 c0       	rjmp	.+0      	; 0x676 <Bluetooth_Send+0x8c>
     676:	00 00       	nop
			//clear the keystroke
		Delay_MS(1);
		sprintf(cmd_buffer,"AT+KR=A1,01,%02x,00,%02x,00,00,00,00,00",0,0);
     678:	1f 92       	push	r1
     67a:	1f 92       	push	r1
     67c:	1f 92       	push	r1
     67e:	1f 92       	push	r1
     680:	ff 92       	push	r15
     682:	ef 92       	push	r14
     684:	1f 93       	push	r17
     686:	0f 93       	push	r16
     688:	0e 94 10 3a 	call	0x7420	; 0x7420 <sprintf>
		Bluetooth_Send_CMD(cmd_buffer, false);
     68c:	60 e0       	ldi	r22, 0x00	; 0
     68e:	c8 01       	movw	r24, r16
     690:	8a df       	rcall	.-236    	; 0x5a6 <Bluetooth_Send_CMD>
     692:	0f b6       	in	r0, 0x3f	; 63
     694:	f8 94       	cli
     696:	de bf       	out	0x3e, r29	; 62
     698:	0f be       	out	0x3f, r0	; 63
     69a:	cd bf       	out	0x3d, r28	; 61

}
     69c:	a4 96       	adiw	r28, 0x24	; 36
     69e:	0f b6       	in	r0, 0x3f	; 63
     6a0:	f8 94       	cli
     6a2:	de bf       	out	0x3e, r29	; 62
     6a4:	0f be       	out	0x3f, r0	; 63
     6a6:	cd bf       	out	0x3d, r28	; 61
     6a8:	df 91       	pop	r29
     6aa:	cf 91       	pop	r28
     6ac:	1f 91       	pop	r17
     6ae:	0f 91       	pop	r16
     6b0:	ff 90       	pop	r15
     6b2:	ef 90       	pop	r14
     6b4:	08 95       	ret

000006b6 <Bluetooth_Init>:
 * reset, enter command mode, set parameters, reset again to lock in parameters.
 * 
 * \return void
 */
void Bluetooth_Init(){
	Bluetooth_Reset(); //reset the module
     6b6:	0f df       	rcall	.-482    	; 0x4d6 <Bluetooth_Reset>
     6b8:	2f ef       	ldi	r18, 0xFF	; 255
     6ba:	89 e6       	ldi	r24, 0x69	; 105
     6bc:	98 e1       	ldi	r25, 0x18	; 24
     6be:	21 50       	subi	r18, 0x01	; 1
     6c0:	80 40       	sbci	r24, 0x00	; 0
     6c2:	90 40       	sbci	r25, 0x00	; 0
     6c4:	e1 f7       	brne	.-8      	; 0x6be <Bluetooth_Init+0x8>
     6c6:	00 c0       	rjmp	.+0      	; 0x6c8 <Bluetooth_Init+0x12>
     6c8:	00 00       	nop
	Delay_MS(1000);
	Get_Response(true);
     6ca:	81 e0       	ldi	r24, 0x01	; 1
     6cc:	20 df       	rcall	.-448    	; 0x50e <Get_Response>
	Bluetooth_Send_CMD("AT+BP=00,00", true); //get into proxy mode so that commands work correctly.
     6ce:	61 e0       	ldi	r22, 0x01	; 1
     6d0:	8f ec       	ldi	r24, 0xCF	; 207
     6d2:	91 e0       	ldi	r25, 0x01	; 1
     6d4:	68 df       	rcall	.-304    	; 0x5a6 <Bluetooth_Send_CMD>
     6d6:	2f ef       	ldi	r18, 0xFF	; 255
     6d8:	89 e6       	ldi	r24, 0x69	; 105
     6da:	98 e1       	ldi	r25, 0x18	; 24
     6dc:	21 50       	subi	r18, 0x01	; 1
     6de:	80 40       	sbci	r24, 0x00	; 0
     6e0:	90 40       	sbci	r25, 0x00	; 0
     6e2:	e1 f7       	brne	.-8      	; 0x6dc <Bluetooth_Init+0x26>
     6e4:	00 c0       	rjmp	.+0      	; 0x6e6 <Bluetooth_Init+0x30>
     6e6:	00 00       	nop
	Delay_MS(1000);
	BT_State = INITIALIZED;
     6e8:	81 e0       	ldi	r24, 0x01	; 1
     6ea:	80 93 d3 06 	sts	0x06D3, r24
     6ee:	08 95       	ret

000006f0 <Bluetooth_Configure>:
}

bool Bluetooth_Configure(){
     6f0:	cf 93       	push	r28
	bool success;
	success = true;
	
	#ifdef DEBUG
		while(USB_DeviceState != DEVICE_STATE_Configured){;} //usb must be connected for debug to work
     6f2:	80 91 6d 0a 	lds	r24, 0x0A6D
     6f6:	84 30       	cpi	r24, 0x04	; 4
     6f8:	e1 f7       	brne	.-8      	; 0x6f2 <Bluetooth_Configure+0x2>
     6fa:	2f ef       	ldi	r18, 0xFF	; 255
     6fc:	84 e3       	ldi	r24, 0x34	; 52
     6fe:	9c e0       	ldi	r25, 0x0C	; 12
     700:	21 50       	subi	r18, 0x01	; 1
     702:	80 40       	sbci	r24, 0x00	; 0
     704:	90 40       	sbci	r25, 0x00	; 0
     706:	e1 f7       	brne	.-8      	; 0x700 <Bluetooth_Configure+0x10>
     708:	00 c0       	rjmp	.+0      	; 0x70a <Bluetooth_Configure+0x1a>
     70a:	00 00       	nop
		Delay_MS(500);
		USBSendString("BT DEBUG MODE");
     70c:	8b ed       	ldi	r24, 0xDB	; 219
     70e:	91 e0       	ldi	r25, 0x01	; 1
     710:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
	#endif
	
	Bluetooth_Init();
     714:	d0 df       	rcall	.-96     	; 0x6b6 <Bluetooth_Init>

	success &= Bluetooth_Send_CMD("AT+UI=01",true); //enable responses from bluetooth module -- if response is "OK" then bluetooth module is present and responsive.		
     716:	61 e0       	ldi	r22, 0x01	; 1
     718:	8a e7       	ldi	r24, 0x7A	; 122
     71a:	91 e0       	ldi	r25, 0x01	; 1
     71c:	44 df       	rcall	.-376    	; 0x5a6 <Bluetooth_Send_CMD>
     71e:	c8 2f       	mov	r28, r24
	Bluetooth_Send_CMD("AT+NM=USBTYPE",true); //set friendly name
     720:	61 e0       	ldi	r22, 0x01	; 1
     722:	89 ee       	ldi	r24, 0xE9	; 233
     724:	91 e0       	ldi	r25, 0x01	; 1
     726:	3f df       	rcall	.-386    	; 0x5a6 <Bluetooth_Send_CMD>
	Bluetooth_Send_CMD("AT+BP=00,00",true); //bypass channel is proxy
     728:	61 e0       	ldi	r22, 0x01	; 1
     72a:	8f ec       	ldi	r24, 0xCF	; 207
     72c:	91 e0       	ldi	r25, 0x01	; 1
     72e:	3b df       	rcall	.-394    	; 0x5a6 <Bluetooth_Send_CMD>
	Bluetooth_Send_CMD("AT+PF=00,01,00,00,00",true);//set hid parameters
     730:	61 e0       	ldi	r22, 0x01	; 1
     732:	87 ef       	ldi	r24, 0xF7	; 247
     734:	91 e0       	ldi	r25, 0x01	; 1
     736:	37 df       	rcall	.-402    	; 0x5a6 <Bluetooth_Send_CMD>
     738:	2f ef       	ldi	r18, 0xFF	; 255
     73a:	84 e3       	ldi	r24, 0x34	; 52
     73c:	9c e0       	ldi	r25, 0x0C	; 12
     73e:	21 50       	subi	r18, 0x01	; 1
     740:	80 40       	sbci	r24, 0x00	; 0
     742:	90 40       	sbci	r25, 0x00	; 0
     744:	e1 f7       	brne	.-8      	; 0x73e <Bluetooth_Configure+0x4e>
     746:	00 c0       	rjmp	.+0      	; 0x748 <Bluetooth_Configure+0x58>
     748:	00 00       	nop
	Delay_MS(500);
	Bluetooth_Send_CMD("AT+FT=00,01,FF,05,01,0258",true); //configure module features (see manual):
     74a:	61 e0       	ldi	r22, 0x01	; 1
     74c:	8c e0       	ldi	r24, 0x0C	; 12
     74e:	92 e0       	ldi	r25, 0x02	; 2
     750:	2a df       	rcall	.-428    	; 0x5a6 <Bluetooth_Send_CMD>
	set the interval of auto reconnect to 5s.
	configure the discover mode as 01: auto discoverable when empty.
	configure the timeout of discoverable as 600 seconds (10 min).
	This command is only needed when the first time use this Bluetooth module.*/
	
	Bluetooth_Send_CMD("AT+CP",true); //clear paired device list, which forces the device to go into discovery mode.
     752:	61 e0       	ldi	r22, 0x01	; 1
     754:	86 e2       	ldi	r24, 0x26	; 38
     756:	92 e0       	ldi	r25, 0x02	; 2
     758:	26 df       	rcall	.-436    	; 0x5a6 <Bluetooth_Send_CMD>
	
	return success; //if any of the commands failed, success will be false.
}
     75a:	8c 2f       	mov	r24, r28
     75c:	cf 91       	pop	r28
     75e:	08 95       	ret

00000760 <BluetoothInquire>:
		
}

bool BluetoothInquire(){
	bool success = true;
	success &= Bluetooth_Send_CMD("AT+CP",true); //clear the paired device list.  This makes bluetooth enter discoverable state by default.
     760:	61 e0       	ldi	r22, 0x01	; 1
     762:	86 e2       	ldi	r24, 0x26	; 38
     764:	92 e0       	ldi	r25, 0x02	; 2
     766:	1f cf       	rjmp	.-450    	; 0x5a6 <Bluetooth_Send_CMD>
	return success;
}
     768:	08 95       	ret

0000076a <Get_Bluetooth_State>:

uint8_t Get_Bluetooth_State(){
	return BT_State;
}
     76a:	80 91 d3 06 	lds	r24, 0x06D3
     76e:	08 95       	ret

00000770 <Bluetooth_Connect>:

bool Bluetooth_Connect(){
     770:	cf 93       	push	r28
     772:	df 93       	push	r29
     774:	00 d0       	rcall	.+0      	; 0x776 <Bluetooth_Connect+0x6>
     776:	00 d0       	rcall	.+0      	; 0x778 <Bluetooth_Connect+0x8>
     778:	cd b7       	in	r28, 0x3d	; 61
     77a:	de b7       	in	r29, 0x3e	; 62
//	if (is_low(BT_CONNECTED)) // if bluetooth is not already connected:
	const char s[4] = "MD=";
     77c:	8d e4       	ldi	r24, 0x4D	; 77
     77e:	94 e4       	ldi	r25, 0x44	; 68
     780:	ad e3       	ldi	r26, 0x3D	; 61
     782:	b0 e0       	ldi	r27, 0x00	; 0
     784:	89 83       	std	Y+1, r24	; 0x01
     786:	9a 83       	std	Y+2, r25	; 0x02
     788:	ab 83       	std	Y+3, r26	; 0x03
     78a:	bc 83       	std	Y+4, r27	; 0x04
	USBSendString("connect\n");
     78c:	8c e2       	ldi	r24, 0x2C	; 44
     78e:	92 e0       	ldi	r25, 0x02	; 2
     790:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     794:	2f ef       	ldi	r18, 0xFF	; 255
     796:	89 e6       	ldi	r24, 0x69	; 105
     798:	98 e1       	ldi	r25, 0x18	; 24
     79a:	21 50       	subi	r18, 0x01	; 1
     79c:	80 40       	sbci	r24, 0x00	; 0
     79e:	90 40       	sbci	r25, 0x00	; 0
     7a0:	e1 f7       	brne	.-8      	; 0x79a <Bluetooth_Connect+0x2a>
     7a2:	00 c0       	rjmp	.+0      	; 0x7a4 <Bluetooth_Connect+0x34>
     7a4:	00 00       	nop
	Delay_MS(1000);
	Bluetooth_Send_CMD("AT+UI=01",false); //enable ui
     7a6:	60 e0       	ldi	r22, 0x00	; 0
     7a8:	8a e7       	ldi	r24, 0x7A	; 122
     7aa:	91 e0       	ldi	r25, 0x01	; 1
     7ac:	fc de       	rcall	.-520    	; 0x5a6 <Bluetooth_Send_CMD>
	Bluetooth_Send_CMD("AT+MD",true);
     7ae:	61 e0       	ldi	r22, 0x01	; 1
     7b0:	85 e3       	ldi	r24, 0x35	; 53
     7b2:	92 e0       	ldi	r25, 0x02	; 2
     7b4:	f8 de       	rcall	.-528    	; 0x5a6 <Bluetooth_Send_CMD>
	char* numericalresponse = strtok(response,s); //parse result so we only get the part after MD=
     7b6:	be 01       	movw	r22, r28
     7b8:	6f 5f       	subi	r22, 0xFF	; 255
     7ba:	7f 4f       	sbci	r23, 0xFF	; 255
     7bc:	83 e9       	ldi	r24, 0x93	; 147
     7be:	96 e0       	ldi	r25, 0x06	; 6
     7c0:	0e 94 c9 39 	call	0x7392	; 0x7392 <strtok>
	numericalresponse = strtok(NULL, s); // calling function again accesses everything after the delimiter
     7c4:	be 01       	movw	r22, r28
     7c6:	6f 5f       	subi	r22, 0xFF	; 255
     7c8:	7f 4f       	sbci	r23, 0xFF	; 255
     7ca:	80 e0       	ldi	r24, 0x00	; 0
     7cc:	90 e0       	ldi	r25, 0x00	; 0
     7ce:	0e 94 c9 39 	call	0x7392	; 0x7392 <strtok>
	if (numericalresponse != NULL){ //if there is anything to report.
     7d2:	00 97       	sbiw	r24, 0x00	; 0
     7d4:	41 f0       	breq	.+16     	; 0x7e6 <Bluetooth_Connect+0x76>
		if((numericalresponse[1] == '0')){ //if this is not discoverable mode...
     7d6:	fc 01       	movw	r30, r24
     7d8:	81 81       	ldd	r24, Z+1	; 0x01
     7da:	80 33       	cpi	r24, 0x30	; 48
     7dc:	21 f4       	brne	.+8      	; 0x7e6 <Bluetooth_Connect+0x76>
			Bluetooth_Send_CMD("AT+CI",true); //then attempt a new connection.
     7de:	61 e0       	ldi	r22, 0x01	; 1
     7e0:	8b e3       	ldi	r24, 0x3B	; 59
     7e2:	92 e0       	ldi	r25, 0x02	; 2
     7e4:	e0 de       	rcall	.-576    	; 0x5a6 <Bluetooth_Send_CMD>
		}
	}
	return true;
}
     7e6:	81 e0       	ldi	r24, 0x01	; 1
     7e8:	0f 90       	pop	r0
     7ea:	0f 90       	pop	r0
     7ec:	0f 90       	pop	r0
     7ee:	0f 90       	pop	r0
     7f0:	df 91       	pop	r29
     7f2:	cf 91       	pop	r28
     7f4:	08 95       	ret

000007f6 <SaveCalibration>:
	if (Modifier == UPPER){
		ASCIIShiftLookUpTable[keypressed] = teachkey;
	}
	else if (Modifier & FN_MODIFIER){}//do nothing -- sd cards do not use fn key.
	else{
		ASCIILookUpTable[keypressed] = teachkey;
     7f6:	81 e4       	ldi	r24, 0x41	; 65
     7f8:	92 e0       	ldi	r25, 0x02	; 2
     7fa:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     7fe:	40 e4       	ldi	r20, 0x40	; 64
     800:	50 e0       	ldi	r21, 0x00	; 0
     802:	60 e0       	ldi	r22, 0x00	; 0
     804:	70 e0       	ldi	r23, 0x00	; 0
     806:	8b ed       	ldi	r24, 0xDB	; 219
     808:	96 e0       	ldi	r25, 0x06	; 6
     80a:	0e 94 ce 3c 	call	0x799c	; 0x799c <eeprom_write_block>
     80e:	40 e4       	ldi	r20, 0x40	; 64
     810:	50 e0       	ldi	r21, 0x00	; 0
     812:	60 e4       	ldi	r22, 0x40	; 64
     814:	70 e0       	ldi	r23, 0x00	; 0
     816:	89 e2       	ldi	r24, 0x29	; 41
     818:	9a e0       	ldi	r25, 0x0A	; 10
     81a:	0e 94 ce 3c 	call	0x799c	; 0x799c <eeprom_write_block>
     81e:	40 e4       	ldi	r20, 0x40	; 64
     820:	50 e0       	ldi	r21, 0x00	; 0
     822:	60 e8       	ldi	r22, 0x80	; 128
     824:	70 e0       	ldi	r23, 0x00	; 0
     826:	86 e2       	ldi	r24, 0x26	; 38
     828:	97 e0       	ldi	r25, 0x07	; 7
     82a:	0e 94 ce 3c 	call	0x799c	; 0x799c <eeprom_write_block>
     82e:	40 e4       	ldi	r20, 0x40	; 64
     830:	50 e0       	ldi	r21, 0x00	; 0
     832:	60 ec       	ldi	r22, 0xC0	; 192
     834:	70 e0       	ldi	r23, 0x00	; 0
     836:	86 ee       	ldi	r24, 0xE6	; 230
     838:	97 e0       	ldi	r25, 0x07	; 7
     83a:	0e 94 ce 3c 	call	0x799c	; 0x799c <eeprom_write_block>
     83e:	40 e4       	ldi	r20, 0x40	; 64
     840:	50 e0       	ldi	r21, 0x00	; 0
     842:	60 e0       	ldi	r22, 0x00	; 0
     844:	71 e0       	ldi	r23, 0x01	; 1
     846:	87 e6       	ldi	r24, 0x67	; 103
     848:	97 e0       	ldi	r25, 0x07	; 7
     84a:	0e 94 ce 3c 	call	0x799c	; 0x799c <eeprom_write_block>
     84e:	60 91 1e 07 	lds	r22, 0x071E
     852:	85 e0       	ldi	r24, 0x05	; 5
     854:	92 e0       	ldi	r25, 0x02	; 2
     856:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
     85a:	60 91 25 07 	lds	r22, 0x0725
     85e:	86 e0       	ldi	r24, 0x06	; 6
     860:	92 e0       	ldi	r25, 0x02	; 2
     862:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
     866:	60 91 d5 06 	lds	r22, 0x06D5
     86a:	87 e0       	ldi	r24, 0x07	; 7
     86c:	92 e0       	ldi	r25, 0x02	; 2
     86e:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
     872:	60 91 a7 07 	lds	r22, 0x07A7
     876:	88 e0       	ldi	r24, 0x08	; 8
     878:	92 e0       	ldi	r25, 0x02	; 2
     87a:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
     87e:	60 91 e5 07 	lds	r22, 0x07E5
     882:	89 e0       	ldi	r24, 0x09	; 9
     884:	92 e0       	ldi	r25, 0x02	; 2
     886:	0c 94 bc 3c 	jmp	0x7978	; 0x7978 <eeprom_update_byte>
     88a:	08 95       	ret

0000088c <DetectHallSensor>:
     88c:	cf 93       	push	r28
     88e:	df 93       	push	r29
     890:	10 92 a8 07 	sts	0x07A8, r1
     894:	0e 94 76 2d 	call	0x5aec	; 0x5aec <getHallState>
     898:	d8 2f       	mov	r29, r24
     89a:	8e ee       	ldi	r24, 0xEE	; 238
     89c:	91 e0       	ldi	r25, 0x01	; 1
     89e:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     8a2:	2f ef       	ldi	r18, 0xFF	; 255
     8a4:	87 ea       	ldi	r24, 0xA7	; 167
     8a6:	91 e6       	ldi	r25, 0x61	; 97
     8a8:	21 50       	subi	r18, 0x01	; 1
     8aa:	80 40       	sbci	r24, 0x00	; 0
     8ac:	90 40       	sbci	r25, 0x00	; 0
     8ae:	e1 f7       	brne	.-8      	; 0x8a8 <DetectHallSensor+0x1c>
     8b0:	00 c0       	rjmp	.+0      	; 0x8b2 <DetectHallSensor+0x26>
     8b2:	00 00       	nop
     8b4:	0e 94 76 2d 	call	0x5aec	; 0x5aec <getHallState>
     8b8:	c8 2f       	mov	r28, r24
     8ba:	d8 13       	cpse	r29, r24
     8bc:	07 c0       	rjmp	.+14     	; 0x8cc <DetectHallSensor+0x40>
     8be:	8d eb       	ldi	r24, 0xBD	; 189
     8c0:	91 e0       	ldi	r25, 0x01	; 1
     8c2:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     8c6:	10 92 a8 07 	sts	0x07A8, r1
     8ca:	23 c0       	rjmp	.+70     	; 0x912 <DetectHallSensor+0x86>
     8cc:	8c e4       	ldi	r24, 0x4C	; 76
     8ce:	92 e0       	ldi	r25, 0x02	; 2
     8d0:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	80 93 a8 07 	sts	0x07A8, r24
     8da:	c0 93 24 07 	sts	0x0724, r28
     8de:	83 e6       	ldi	r24, 0x63	; 99
     8e0:	92 e0       	ldi	r25, 0x02	; 2
     8e2:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     8e6:	83 e6       	ldi	r24, 0x63	; 99
     8e8:	90 e0       	ldi	r25, 0x00	; 0
     8ea:	22 e0       	ldi	r18, 0x02	; 2
     8ec:	7c 9b       	sbis	0x0f, 4	; 15
     8ee:	20 93 a8 07 	sts	0x07A8, r18
     8f2:	ef e5       	ldi	r30, 0x5F	; 95
     8f4:	fa ee       	ldi	r31, 0xEA	; 234
     8f6:	31 97       	sbiw	r30, 0x01	; 1
     8f8:	f1 f7       	brne	.-4      	; 0x8f6 <DetectHallSensor+0x6a>
     8fa:	00 c0       	rjmp	.+0      	; 0x8fc <DetectHallSensor+0x70>
     8fc:	00 00       	nop
     8fe:	01 97       	sbiw	r24, 0x01	; 1
     900:	a9 f7       	brne	.-22     	; 0x8ec <DetectHallSensor+0x60>
     902:	80 91 a8 07 	lds	r24, 0x07A8
     906:	82 30       	cpi	r24, 0x02	; 2
     908:	21 f4       	brne	.+8      	; 0x912 <DetectHallSensor+0x86>
     90a:	81 e9       	ldi	r24, 0x91	; 145
     90c:	92 e0       	ldi	r25, 0x02	; 2
     90e:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     912:	7e 99       	sbic	0x0f, 6	; 15
     914:	03 c0       	rjmp	.+6      	; 0x91c <DetectHallSensor+0x90>
     916:	81 e0       	ldi	r24, 0x01	; 1
     918:	80 93 a8 07 	sts	0x07A8, r24
     91c:	60 91 a8 07 	lds	r22, 0x07A8
     920:	83 e0       	ldi	r24, 0x03	; 3
     922:	92 e0       	ldi	r25, 0x02	; 2
     924:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
     928:	60 91 24 07 	lds	r22, 0x0724
     92c:	84 e0       	ldi	r24, 0x04	; 4
     92e:	92 e0       	ldi	r25, 0x02	; 2
     930:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
     934:	81 e0       	ldi	r24, 0x01	; 1
     936:	90 91 a8 07 	lds	r25, 0x07A8
     93a:	91 11       	cpse	r25, r1
     93c:	01 c0       	rjmp	.+2      	; 0x940 <DetectHallSensor+0xb4>
     93e:	80 e0       	ldi	r24, 0x00	; 0
     940:	df 91       	pop	r29
     942:	cf 91       	pop	r28
     944:	08 95       	ret

00000946 <WaitForKeypress>:
     946:	2f ef       	ldi	r18, 0xFF	; 255
     948:	81 ee       	ldi	r24, 0xE1	; 225
     94a:	94 e0       	ldi	r25, 0x04	; 4
     94c:	21 50       	subi	r18, 0x01	; 1
     94e:	80 40       	sbci	r24, 0x00	; 0
     950:	90 40       	sbci	r25, 0x00	; 0
     952:	e1 f7       	brne	.-8      	; 0x94c <WaitForKeypress+0x6>
     954:	00 c0       	rjmp	.+0      	; 0x956 <WaitForKeypress+0x10>
     956:	00 00       	nop
     958:	0e 94 a3 2b 	call	0x5746	; 0x5746 <GetKeySimple>
     95c:	90 e0       	ldi	r25, 0x00	; 0
     95e:	00 97       	sbiw	r24, 0x00	; 0
     960:	d9 f3       	breq	.-10     	; 0x958 <WaitForKeypress+0x12>
     962:	08 95       	ret

00000964 <TeachHIDKey>:
     964:	cf 93       	push	r28
     966:	df 93       	push	r29
     968:	eb 01       	movw	r28, r22
     96a:	42 30       	cpi	r20, 0x02	; 2
     96c:	81 f4       	brne	.+32     	; 0x98e <TeachHIDKey+0x2a>
     96e:	fb 01       	movw	r30, r22
     970:	ea 5d       	subi	r30, 0xDA	; 218
     972:	f8 4f       	sbci	r31, 0xF8	; 248
     974:	80 83       	st	Z, r24
     976:	8a ea       	ldi	r24, 0xAA	; 170
     978:	92 e0       	ldi	r25, 0x02	; 2
     97a:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     97e:	62 e0       	ldi	r22, 0x02	; 2
     980:	8e e2       	ldi	r24, 0x2E	; 46
     982:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     986:	8c 2f       	mov	r24, r28
     988:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
     98c:	19 c0       	rjmp	.+50     	; 0x9c0 <TeachHIDKey+0x5c>
     98e:	44 30       	cpi	r20, 0x04	; 4
     990:	81 f4       	brne	.+32     	; 0x9b2 <TeachHIDKey+0x4e>
     992:	fb 01       	movw	r30, r22
     994:	e7 5d       	subi	r30, 0xD7	; 215
     996:	f5 4f       	sbci	r31, 0xF5	; 245
     998:	80 83       	st	Z, r24
     99a:	80 eb       	ldi	r24, 0xB0	; 176
     99c:	92 e0       	ldi	r25, 0x02	; 2
     99e:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     9a2:	62 e0       	ldi	r22, 0x02	; 2
     9a4:	8e e2       	ldi	r24, 0x2E	; 46
     9a6:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     9aa:	8c 2f       	mov	r24, r28
     9ac:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
     9b0:	07 c0       	rjmp	.+14     	; 0x9c0 <TeachHIDKey+0x5c>
     9b2:	fb 01       	movw	r30, r22
     9b4:	e5 52       	subi	r30, 0x25	; 37
     9b6:	f9 4f       	sbci	r31, 0xF9	; 249
     9b8:	80 83       	st	Z, r24
     9ba:	86 2f       	mov	r24, r22
     9bc:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
     9c0:	2f ef       	ldi	r18, 0xFF	; 255
     9c2:	84 e3       	ldi	r24, 0x34	; 52
     9c4:	9c e0       	ldi	r25, 0x0C	; 12
     9c6:	21 50       	subi	r18, 0x01	; 1
     9c8:	80 40       	sbci	r24, 0x00	; 0
     9ca:	90 40       	sbci	r25, 0x00	; 0
     9cc:	e1 f7       	brne	.-8      	; 0x9c6 <TeachHIDKey+0x62>
     9ce:	00 c0       	rjmp	.+0      	; 0x9d0 <TeachHIDKey+0x6c>
     9d0:	00 00       	nop
     9d2:	df 91       	pop	r29
     9d4:	cf 91       	pop	r28
     9d6:	08 95       	ret

000009d8 <CalibrateReeds>:
     9d8:	1f 93       	push	r17
     9da:	cf 93       	push	r28
     9dc:	df 93       	push	r29
     9de:	84 e2       	ldi	r24, 0x24	; 36
     9e0:	92 e0       	ldi	r25, 0x02	; 2
     9e2:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     9e6:	60 e0       	ldi	r22, 0x00	; 0
     9e8:	8c e2       	ldi	r24, 0x2C	; 44
     9ea:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     9ee:	ab df       	rcall	.-170    	; 0x946 <WaitForKeypress>
     9f0:	ec 01       	movw	r28, r24
     9f2:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
     9f6:	18 2f       	mov	r17, r24
     9f8:	dd 27       	eor	r29, r29
     9fa:	48 2f       	mov	r20, r24
     9fc:	be 01       	movw	r22, r28
     9fe:	8a e2       	ldi	r24, 0x2A	; 42
     a00:	b1 df       	rcall	.-158    	; 0x964 <TeachHIDKey>
     a02:	12 fd       	sbrc	r17, 2
     a04:	04 c0       	rjmp	.+8      	; 0xa0e <CalibrateReeds+0x36>
     a06:	ca 51       	subi	r28, 0x1A	; 26
     a08:	d8 4f       	sbci	r29, 0xF8	; 248
     a0a:	88 e0       	ldi	r24, 0x08	; 8
     a0c:	88 83       	st	Y, r24
     a0e:	60 e0       	ldi	r22, 0x00	; 0
     a10:	88 e2       	ldi	r24, 0x28	; 40
     a12:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     a16:	83 eb       	ldi	r24, 0xB3	; 179
     a18:	92 e0       	ldi	r25, 0x02	; 2
     a1a:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     a1e:	60 e0       	ldi	r22, 0x00	; 0
     a20:	8c e2       	ldi	r24, 0x2C	; 44
     a22:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     a26:	8f df       	rcall	.-226    	; 0x946 <WaitForKeypress>
     a28:	ec 01       	movw	r28, r24
     a2a:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
     a2e:	be 01       	movw	r22, r28
     a30:	77 27       	eor	r23, r23
     a32:	48 2f       	mov	r20, r24
     a34:	89 e2       	ldi	r24, 0x29	; 41
     a36:	96 df       	rcall	.-212    	; 0x964 <TeachHIDKey>
     a38:	60 e0       	ldi	r22, 0x00	; 0
     a3a:	88 e2       	ldi	r24, 0x28	; 40
     a3c:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     a40:	87 eb       	ldi	r24, 0xB7	; 183
     a42:	92 e0       	ldi	r25, 0x02	; 2
     a44:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     a48:	60 e0       	ldi	r22, 0x00	; 0
     a4a:	8c e2       	ldi	r24, 0x2C	; 44
     a4c:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     a50:	7a df       	rcall	.-268    	; 0x946 <WaitForKeypress>
     a52:	ec 01       	movw	r28, r24
     a54:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
     a58:	18 2f       	mov	r17, r24
     a5a:	dd 27       	eor	r29, r29
     a5c:	48 2f       	mov	r20, r24
     a5e:	be 01       	movw	r22, r28
     a60:	8b e2       	ldi	r24, 0x2B	; 43
     a62:	80 df       	rcall	.-256    	; 0x964 <TeachHIDKey>
     a64:	12 fd       	sbrc	r17, 2
     a66:	09 c0       	rjmp	.+18     	; 0xa7a <CalibrateReeds+0xa2>
     a68:	fe 01       	movw	r30, r28
     a6a:	ea 51       	subi	r30, 0x1A	; 26
     a6c:	f8 4f       	sbci	r31, 0xF8	; 248
     a6e:	89 e0       	ldi	r24, 0x09	; 9
     a70:	80 83       	st	Z, r24
     a72:	c9 59       	subi	r28, 0x99	; 153
     a74:	d8 4f       	sbci	r29, 0xF8	; 248
     a76:	84 e7       	ldi	r24, 0x74	; 116
     a78:	88 83       	st	Y, r24
     a7a:	60 e0       	ldi	r22, 0x00	; 0
     a7c:	88 e2       	ldi	r24, 0x28	; 40
     a7e:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     a82:	83 e4       	ldi	r24, 0x43	; 67
     a84:	92 e0       	ldi	r25, 0x02	; 2
     a86:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     a8a:	60 e0       	ldi	r22, 0x00	; 0
     a8c:	8c e2       	ldi	r24, 0x2C	; 44
     a8e:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     a92:	59 df       	rcall	.-334    	; 0x946 <WaitForKeypress>
     a94:	ec 01       	movw	r28, r24
     a96:	dd 27       	eor	r29, r29
     a98:	40 e0       	ldi	r20, 0x00	; 0
     a9a:	be 01       	movw	r22, r28
     a9c:	88 e2       	ldi	r24, 0x28	; 40
     a9e:	62 df       	rcall	.-316    	; 0x964 <TeachHIDKey>
     aa0:	ca 51       	subi	r28, 0x1A	; 26
     aa2:	d8 4f       	sbci	r29, 0xF8	; 248
     aa4:	8d e0       	ldi	r24, 0x0D	; 13
     aa6:	88 83       	st	Y, r24
     aa8:	60 e0       	ldi	r22, 0x00	; 0
     aaa:	88 e2       	ldi	r24, 0x28	; 40
     aac:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     ab0:	83 e3       	ldi	r24, 0x33	; 51
     ab2:	92 e0       	ldi	r25, 0x02	; 2
     ab4:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     ab8:	60 e0       	ldi	r22, 0x00	; 0
     aba:	8c e2       	ldi	r24, 0x2C	; 44
     abc:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     ac0:	84 e7       	ldi	r24, 0x74	; 116
     ac2:	90 e0       	ldi	r25, 0x00	; 0
     ac4:	40 df       	rcall	.-384    	; 0x946 <WaitForKeypress>
     ac6:	bc 01       	movw	r22, r24
     ac8:	77 27       	eor	r23, r23
     aca:	40 e0       	ldi	r20, 0x00	; 0
     acc:	88 e2       	ldi	r24, 0x28	; 40
     ace:	4a df       	rcall	.-364    	; 0x964 <TeachHIDKey>
     ad0:	60 e0       	ldi	r22, 0x00	; 0
     ad2:	88 e2       	ldi	r24, 0x28	; 40
     ad4:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     ad8:	8e e2       	ldi	r24, 0x2E	; 46
     ada:	92 e0       	ldi	r25, 0x02	; 2
     adc:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     ae0:	60 e0       	ldi	r22, 0x00	; 0
     ae2:	8c e2       	ldi	r24, 0x2C	; 44
     ae4:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     ae8:	2e df       	rcall	.-420    	; 0x946 <WaitForKeypress>
     aea:	bc 01       	movw	r22, r24
     aec:	77 27       	eor	r23, r23
     aee:	40 e0       	ldi	r20, 0x00	; 0
     af0:	84 e7       	ldi	r24, 0x74	; 116
     af2:	38 df       	rcall	.-400    	; 0x964 <TeachHIDKey>
     af4:	60 e0       	ldi	r22, 0x00	; 0
     af6:	88 e2       	ldi	r24, 0x28	; 40
     af8:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     afc:	89 e4       	ldi	r24, 0x49	; 73
     afe:	92 e0       	ldi	r25, 0x02	; 2
     b00:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     b04:	60 e0       	ldi	r22, 0x00	; 0
     b06:	8c e2       	ldi	r24, 0x2C	; 44
     b08:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     b0c:	1c df       	rcall	.-456    	; 0x946 <WaitForKeypress>
     b0e:	ec 01       	movw	r28, r24
     b10:	dd 27       	eor	r29, r29
     b12:	40 e0       	ldi	r20, 0x00	; 0
     b14:	be 01       	movw	r22, r28
     b16:	8c e2       	ldi	r24, 0x2C	; 44
     b18:	25 df       	rcall	.-438    	; 0x964 <TeachHIDKey>
     b1a:	ca 51       	subi	r28, 0x1A	; 26
     b1c:	d8 4f       	sbci	r29, 0xF8	; 248
     b1e:	80 e2       	ldi	r24, 0x20	; 32
     b20:	88 83       	st	Y, r24
     b22:	60 e0       	ldi	r22, 0x00	; 0
     b24:	88 e2       	ldi	r24, 0x28	; 40
     b26:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     b2a:	df 91       	pop	r29
     b2c:	cf 91       	pop	r28
     b2e:	1f 91       	pop	r17
     b30:	08 95       	ret

00000b32 <QuickCalibrate>:
     b32:	80 91 6d 0a 	lds	r24, 0x0A6D
     b36:	84 30       	cpi	r24, 0x04	; 4
     b38:	e1 f7       	brne	.-8      	; 0xb32 <QuickCalibrate>
     b3a:	2f ef       	ldi	r18, 0xFF	; 255
     b3c:	89 e6       	ldi	r24, 0x69	; 105
     b3e:	98 e1       	ldi	r25, 0x18	; 24
     b40:	21 50       	subi	r18, 0x01	; 1
     b42:	80 40       	sbci	r24, 0x00	; 0
     b44:	90 40       	sbci	r25, 0x00	; 0
     b46:	e1 f7       	brne	.-8      	; 0xb40 <QuickCalibrate+0xe>
     b48:	00 c0       	rjmp	.+0      	; 0xb4a <QuickCalibrate+0x18>
     b4a:	00 00       	nop
     b4c:	82 e5       	ldi	r24, 0x52	; 82
     b4e:	92 e0       	ldi	r25, 0x02	; 2
     b50:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     b54:	99 b1       	in	r25, 0x09	; 9
     b56:	81 e0       	ldi	r24, 0x01	; 1
     b58:	92 95       	swap	r25
     b5a:	91 70       	andi	r25, 0x01	; 1
     b5c:	98 27       	eor	r25, r24
     b5e:	90 93 25 07 	sts	0x0725, r25
     b62:	99 b1       	in	r25, 0x09	; 9
     b64:	96 fb       	bst	r25, 6
     b66:	99 27       	eor	r25, r25
     b68:	90 f9       	bld	r25, 0
     b6a:	98 27       	eor	r25, r24
     b6c:	90 93 d5 06 	sts	0x06D5, r25
     b70:	99 b1       	in	r25, 0x09	; 9
     b72:	90 95       	com	r25
     b74:	99 1f       	adc	r25, r25
     b76:	99 27       	eor	r25, r25
     b78:	99 1f       	adc	r25, r25
     b7a:	90 93 a7 07 	sts	0x07A7, r25
     b7e:	93 b1       	in	r25, 0x03	; 3
     b80:	92 95       	swap	r25
     b82:	91 70       	andi	r25, 0x01	; 1
     b84:	89 27       	eor	r24, r25
     b86:	80 93 e5 07 	sts	0x07E5, r24
     b8a:	80 de       	rcall	.-768    	; 0x88c <DetectHallSensor>
     b8c:	81 ec       	ldi	r24, 0xC1	; 193
     b8e:	92 e0       	ldi	r25, 0x02	; 2
     b90:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     b94:	8a ea       	ldi	r24, 0xAA	; 170
     b96:	92 e0       	ldi	r25, 0x02	; 2
     b98:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     b9c:	10 92 1e 07 	sts	0x071E, r1
     ba0:	60 e0       	ldi	r22, 0x00	; 0
     ba2:	8c e2       	ldi	r24, 0x2C	; 44
     ba4:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     ba8:	ce de       	rcall	.-612    	; 0x946 <WaitForKeypress>
     baa:	9f ef       	ldi	r25, 0xFF	; 255
     bac:	98 0f       	add	r25, r24
     bae:	98 30       	cpi	r25, 0x08	; 8
     bb0:	28 f4       	brcc	.+10     	; 0xbbc <QuickCalibrate+0x8a>
     bb2:	80 93 1e 07 	sts	0x071E, r24
     bb6:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
     bba:	04 c0       	rjmp	.+8      	; 0xbc4 <QuickCalibrate+0x92>
     bbc:	8b e9       	ldi	r24, 0x9B	; 155
     bbe:	92 e0       	ldi	r25, 0x02	; 2
     bc0:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     bc4:	60 e0       	ldi	r22, 0x00	; 0
     bc6:	88 e2       	ldi	r24, 0x28	; 40
     bc8:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     bcc:	05 df       	rcall	.-502    	; 0x9d8 <CalibrateReeds>
     bce:	13 de       	rcall	.-986    	; 0x7f6 <SaveCalibration>
     bd0:	8c ea       	ldi	r24, 0xAC	; 172
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	0c 94 39 2a 	jmp	0x5472	; 0x5472 <USBSendPROGString>
     bd8:	08 95       	ret

00000bda <Calibrate>:
     bda:	4f 92       	push	r4
     bdc:	5f 92       	push	r5
     bde:	6f 92       	push	r6
     be0:	7f 92       	push	r7
     be2:	8f 92       	push	r8
     be4:	9f 92       	push	r9
     be6:	af 92       	push	r10
     be8:	bf 92       	push	r11
     bea:	cf 92       	push	r12
     bec:	df 92       	push	r13
     bee:	ef 92       	push	r14
     bf0:	ff 92       	push	r15
     bf2:	0f 93       	push	r16
     bf4:	1f 93       	push	r17
     bf6:	cf 93       	push	r28
     bf8:	df 93       	push	r29
     bfa:	0e 94 e5 2d 	call	0x5bca	; 0x5bca <ClearKeyCodeTables>
     bfe:	c0 91 6d 0a 	lds	r28, 0x0A6D
     c02:	c4 30       	cpi	r28, 0x04	; 4
     c04:	e1 f7       	brne	.-8      	; 0xbfe <Calibrate+0x24>
     c06:	2f ef       	ldi	r18, 0xFF	; 255
     c08:	89 e6       	ldi	r24, 0x69	; 105
     c0a:	98 e1       	ldi	r25, 0x18	; 24
     c0c:	21 50       	subi	r18, 0x01	; 1
     c0e:	80 40       	sbci	r24, 0x00	; 0
     c10:	90 40       	sbci	r25, 0x00	; 0
     c12:	e1 f7       	brne	.-8      	; 0xc0c <Calibrate+0x32>
     c14:	00 c0       	rjmp	.+0      	; 0xc16 <Calibrate+0x3c>
     c16:	00 00       	nop
     c18:	8d e9       	ldi	r24, 0x9D	; 157
     c1a:	93 e0       	ldi	r25, 0x03	; 3
     c1c:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     c20:	89 e8       	ldi	r24, 0x89	; 137
     c22:	93 e0       	ldi	r25, 0x03	; 3
     c24:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     c28:	60 e0       	ldi	r22, 0x00	; 0
     c2a:	88 e2       	ldi	r24, 0x28	; 40
     c2c:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     c30:	8d e0       	ldi	r24, 0x0D	; 13
     c32:	92 e0       	ldi	r25, 0x02	; 2
     c34:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
     c38:	d8 2f       	mov	r29, r24
     c3a:	87 e7       	ldi	r24, 0x77	; 119
     c3c:	93 e0       	ldi	r25, 0x03	; 3
     c3e:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     c42:	d2 30       	cpi	r29, 0x02	; 2
     c44:	99 f0       	breq	.+38     	; 0xc6c <Calibrate+0x92>
     c46:	18 f4       	brcc	.+6      	; 0xc4e <Calibrate+0x74>
     c48:	d1 30       	cpi	r29, 0x01	; 1
     c4a:	31 f0       	breq	.+12     	; 0xc58 <Calibrate+0x7e>
     c4c:	19 c0       	rjmp	.+50     	; 0xc80 <Calibrate+0xa6>
     c4e:	d9 30       	cpi	r29, 0x09	; 9
     c50:	41 f0       	breq	.+16     	; 0xc62 <Calibrate+0x88>
     c52:	dd 30       	cpi	r29, 0x0D	; 13
     c54:	81 f0       	breq	.+32     	; 0xc76 <Calibrate+0x9c>
     c56:	14 c0       	rjmp	.+40     	; 0xc80 <Calibrate+0xa6>
     c58:	89 e1       	ldi	r24, 0x19	; 25
     c5a:	93 e0       	ldi	r25, 0x03	; 3
     c5c:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     c60:	13 c0       	rjmp	.+38     	; 0xc88 <Calibrate+0xae>
     c62:	8e e5       	ldi	r24, 0x5E	; 94
     c64:	93 e0       	ldi	r25, 0x03	; 3
     c66:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     c6a:	0e c0       	rjmp	.+28     	; 0xc88 <Calibrate+0xae>
     c6c:	83 e0       	ldi	r24, 0x03	; 3
     c6e:	93 e0       	ldi	r25, 0x03	; 3
     c70:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     c74:	09 c0       	rjmp	.+18     	; 0xc88 <Calibrate+0xae>
     c76:	88 e3       	ldi	r24, 0x38	; 56
     c78:	93 e0       	ldi	r25, 0x03	; 3
     c7a:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     c7e:	04 c0       	rjmp	.+8      	; 0xc88 <Calibrate+0xae>
     c80:	8b eb       	ldi	r24, 0xBB	; 187
     c82:	92 e0       	ldi	r25, 0x02	; 2
     c84:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     c88:	83 ef       	ldi	r24, 0xF3	; 243
     c8a:	92 e0       	ldi	r25, 0x02	; 2
     c8c:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     c90:	99 b1       	in	r25, 0x09	; 9
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	92 95       	swap	r25
     c96:	91 70       	andi	r25, 0x01	; 1
     c98:	98 27       	eor	r25, r24
     c9a:	90 93 25 07 	sts	0x0725, r25
     c9e:	99 b1       	in	r25, 0x09	; 9
     ca0:	96 fb       	bst	r25, 6
     ca2:	99 27       	eor	r25, r25
     ca4:	90 f9       	bld	r25, 0
     ca6:	98 27       	eor	r25, r24
     ca8:	90 93 d5 06 	sts	0x06D5, r25
     cac:	99 b1       	in	r25, 0x09	; 9
     cae:	90 95       	com	r25
     cb0:	99 1f       	adc	r25, r25
     cb2:	99 27       	eor	r25, r25
     cb4:	99 1f       	adc	r25, r25
     cb6:	90 93 a7 07 	sts	0x07A7, r25
     cba:	93 b1       	in	r25, 0x03	; 3
     cbc:	92 95       	swap	r25
     cbe:	91 70       	andi	r25, 0x01	; 1
     cc0:	89 27       	eor	r24, r25
     cc2:	80 93 e5 07 	sts	0x07E5, r24
     cc6:	e2 dd       	rcall	.-1084   	; 0x88c <DetectHallSensor>
     cc8:	7d 99       	sbic	0x0f, 5	; 15
     cca:	18 c0       	rjmp	.+48     	; 0xcfc <Calibrate+0x122>
     ccc:	80 91 d6 06 	lds	r24, 0x06D6
     cd0:	88 23       	and	r24, r24
     cd2:	39 f0       	breq	.+14     	; 0xce2 <Calibrate+0x108>
     cd4:	10 92 d6 06 	sts	0x06D6, r1
     cd8:	8d e6       	ldi	r24, 0x6D	; 109
     cda:	92 e0       	ldi	r25, 0x02	; 2
     cdc:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     ce0:	07 c0       	rjmp	.+14     	; 0xcf0 <Calibrate+0x116>
     ce2:	81 e0       	ldi	r24, 0x01	; 1
     ce4:	80 93 d6 06 	sts	0x06D6, r24
     ce8:	85 e8       	ldi	r24, 0x85	; 133
     cea:	92 e0       	ldi	r25, 0x02	; 2
     cec:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     cf0:	60 91 d6 06 	lds	r22, 0x06D6
     cf4:	8f e0       	ldi	r24, 0x0F	; 15
     cf6:	92 e0       	ldi	r25, 0x02	; 2
     cf8:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
     cfc:	81 ec       	ldi	r24, 0xC1	; 193
     cfe:	92 e0       	ldi	r25, 0x02	; 2
     d00:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     d04:	d5 e0       	ldi	r29, 0x05	; 5
     d06:	0f 2e       	mov	r0, r31
     d08:	fe e1       	ldi	r31, 0x1E	; 30
     d0a:	ef 2e       	mov	r14, r31
     d0c:	f0 2d       	mov	r31, r0
     d0e:	02 c0       	rjmp	.+4      	; 0xd14 <Calibrate+0x13a>
     d10:	cf 5f       	subi	r28, 0xFF	; 255
     d12:	df 5f       	subi	r29, 0xFF	; 255
     d14:	62 e0       	ldi	r22, 0x02	; 2
     d16:	8c 2f       	mov	r24, r28
     d18:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     d1c:	60 e0       	ldi	r22, 0x00	; 0
     d1e:	8c e2       	ldi	r24, 0x2C	; 44
     d20:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     d24:	10 de       	rcall	.-992    	; 0x946 <WaitForKeypress>
     d26:	8c 01       	movw	r16, r24
     d28:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
     d2c:	f8 2e       	mov	r15, r24
     d2e:	11 27       	eor	r17, r17
     d30:	48 2f       	mov	r20, r24
     d32:	4d 7f       	andi	r20, 0xFD	; 253
     d34:	b8 01       	movw	r22, r16
     d36:	8c 2f       	mov	r24, r28
     d38:	15 de       	rcall	.-982    	; 0x964 <TeachHIDKey>
     d3a:	cf 30       	cpi	r28, 0x0F	; 15
     d3c:	39 f4       	brne	.+14     	; 0xd4c <Calibrate+0x172>
     d3e:	f8 01       	movw	r30, r16
     d40:	e7 5d       	subi	r30, 0xD7	; 215
     d42:	f5 4f       	sbci	r31, 0xF5	; 245
     d44:	e0 82       	st	Z, r14
     d46:	f2 fc       	sbrc	r15, 2
     d48:	e1 c1       	rjmp	.+962    	; 0x110c <Calibrate+0x532>
     d4a:	02 c0       	rjmp	.+4      	; 0xd50 <Calibrate+0x176>
     d4c:	f2 fc       	sbrc	r15, 2
     d4e:	0c c0       	rjmp	.+24     	; 0xd68 <Calibrate+0x18e>
     d50:	f8 01       	movw	r30, r16
     d52:	e9 59       	subi	r30, 0x99	; 153
     d54:	f8 4f       	sbci	r31, 0xF8	; 248
     d56:	8c e3       	ldi	r24, 0x3C	; 60
     d58:	8d 0f       	add	r24, r29
     d5a:	80 83       	st	Z, r24
     d5c:	f8 01       	movw	r30, r16
     d5e:	ea 51       	subi	r30, 0x1A	; 26
     d60:	f8 4f       	sbci	r31, 0xF8	; 248
     d62:	8c e5       	ldi	r24, 0x5C	; 92
     d64:	8d 0f       	add	r24, r29
     d66:	80 83       	st	Z, r24
     d68:	60 e0       	ldi	r22, 0x00	; 0
     d6a:	88 e2       	ldi	r24, 0x28	; 40
     d6c:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     d70:	de 31       	cpi	r29, 0x1E	; 30
     d72:	70 f2       	brcs	.-100    	; 0xd10 <Calibrate+0x136>
     d74:	0f 2e       	mov	r0, r31
     d76:	fb ee       	ldi	r31, 0xEB	; 235
     d78:	cf 2e       	mov	r12, r31
     d7a:	f2 e0       	ldi	r31, 0x02	; 2
     d7c:	df 2e       	mov	r13, r31
     d7e:	f0 2d       	mov	r31, r0
     d80:	00 e0       	ldi	r16, 0x00	; 0
     d82:	10 e0       	ldi	r17, 0x00	; 0
     d84:	f6 01       	movw	r30, r12
     d86:	e1 90       	ld	r14, Z+
     d88:	6f 01       	movw	r12, r30
     d8a:	60 e0       	ldi	r22, 0x00	; 0
     d8c:	8e 2d       	mov	r24, r14
     d8e:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     d92:	60 e0       	ldi	r22, 0x00	; 0
     d94:	8c e2       	ldi	r24, 0x2C	; 44
     d96:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     d9a:	d5 dd       	rcall	.-1110   	; 0x946 <WaitForKeypress>
     d9c:	ec 01       	movw	r28, r24
     d9e:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
     da2:	f8 2e       	mov	r15, r24
     da4:	dd 27       	eor	r29, r29
     da6:	48 2f       	mov	r20, r24
     da8:	4d 7f       	andi	r20, 0xFD	; 253
     daa:	be 01       	movw	r22, r28
     dac:	8e 2d       	mov	r24, r14
     dae:	da dd       	rcall	.-1100   	; 0x964 <TeachHIDKey>
     db0:	f2 fc       	sbrc	r15, 2
     db2:	15 c0       	rjmp	.+42     	; 0xdde <Calibrate+0x204>
     db4:	fe 01       	movw	r30, r28
     db6:	ea 51       	subi	r30, 0x1A	; 26
     db8:	f8 4f       	sbci	r31, 0xF8	; 248
     dba:	d8 01       	movw	r26, r16
     dbc:	af 51       	subi	r26, 0x1F	; 31
     dbe:	bd 4f       	sbci	r27, 0xFD	; 253
     dc0:	8c 91       	ld	r24, X
     dc2:	80 83       	st	Z, r24
     dc4:	fe 01       	movw	r30, r28
     dc6:	e9 59       	subi	r30, 0x99	; 153
     dc8:	f8 4f       	sbci	r31, 0xF8	; 248
     dca:	d8 01       	movw	r26, r16
     dcc:	a9 52       	subi	r26, 0x29	; 41
     dce:	bd 4f       	sbci	r27, 0xFD	; 253
     dd0:	8c 91       	ld	r24, X
     dd2:	80 83       	st	Z, r24
     dd4:	c7 5d       	subi	r28, 0xD7	; 215
     dd6:	d5 4f       	sbci	r29, 0xF5	; 245
     dd8:	8a e3       	ldi	r24, 0x3A	; 58
     dda:	80 0f       	add	r24, r16
     ddc:	88 83       	st	Y, r24
     dde:	60 e0       	ldi	r22, 0x00	; 0
     de0:	88 e2       	ldi	r24, 0x28	; 40
     de2:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     de6:	0f 5f       	subi	r16, 0xFF	; 255
     de8:	1f 4f       	sbci	r17, 0xFF	; 255
     dea:	0a 30       	cpi	r16, 0x0A	; 10
     dec:	11 05       	cpc	r17, r1
     dee:	51 f6       	brne	.-108    	; 0xd84 <Calibrate+0x1aa>
     df0:	83 ec       	ldi	r24, 0xC3	; 195
     df2:	92 e0       	ldi	r25, 0x02	; 2
     df4:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     df8:	60 e0       	ldi	r22, 0x00	; 0
     dfa:	8c e2       	ldi	r24, 0x2C	; 44
     dfc:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     e00:	a2 dd       	rcall	.-1212   	; 0x946 <WaitForKeypress>
     e02:	ec 01       	movw	r28, r24
     e04:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
     e08:	be 01       	movw	r22, r28
     e0a:	77 27       	eor	r23, r23
     e0c:	48 2f       	mov	r20, r24
     e0e:	8a e3       	ldi	r24, 0x3A	; 58
     e10:	a9 dd       	rcall	.-1198   	; 0x964 <TeachHIDKey>
     e12:	60 e0       	ldi	r22, 0x00	; 0
     e14:	88 e2       	ldi	r24, 0x28	; 40
     e16:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     e1a:	86 ec       	ldi	r24, 0xC6	; 198
     e1c:	92 e0       	ldi	r25, 0x02	; 2
     e1e:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     e22:	60 e0       	ldi	r22, 0x00	; 0
     e24:	8c e2       	ldi	r24, 0x2C	; 44
     e26:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     e2a:	8d dd       	rcall	.-1254   	; 0x946 <WaitForKeypress>
     e2c:	ec 01       	movw	r28, r24
     e2e:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
     e32:	be 01       	movw	r22, r28
     e34:	77 27       	eor	r23, r23
     e36:	48 2f       	mov	r20, r24
     e38:	84 e4       	ldi	r24, 0x44	; 68
     e3a:	94 dd       	rcall	.-1240   	; 0x964 <TeachHIDKey>
     e3c:	60 e0       	ldi	r22, 0x00	; 0
     e3e:	88 e2       	ldi	r24, 0x28	; 40
     e40:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     e44:	8a ec       	ldi	r24, 0xCA	; 202
     e46:	92 e0       	ldi	r25, 0x02	; 2
     e48:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     e4c:	60 e0       	ldi	r22, 0x00	; 0
     e4e:	8c e2       	ldi	r24, 0x2C	; 44
     e50:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     e54:	78 dd       	rcall	.-1296   	; 0x946 <WaitForKeypress>
     e56:	ec 01       	movw	r28, r24
     e58:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
     e5c:	be 01       	movw	r22, r28
     e5e:	77 27       	eor	r23, r23
     e60:	48 2f       	mov	r20, r24
     e62:	85 e4       	ldi	r24, 0x45	; 69
     e64:	7f dd       	rcall	.-1282   	; 0x964 <TeachHIDKey>
     e66:	60 e0       	ldi	r22, 0x00	; 0
     e68:	88 e2       	ldi	r24, 0x28	; 40
     e6a:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     e6e:	8a ea       	ldi	r24, 0xAA	; 170
     e70:	92 e0       	ldi	r25, 0x02	; 2
     e72:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
     e76:	60 e0       	ldi	r22, 0x00	; 0
     e78:	8c e2       	ldi	r24, 0x2C	; 44
     e7a:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     e7e:	63 dd       	rcall	.-1338   	; 0x946 <WaitForKeypress>
     e80:	9f ef       	ldi	r25, 0xFF	; 255
     e82:	98 0f       	add	r25, r24
     e84:	98 30       	cpi	r25, 0x08	; 8
     e86:	28 f4       	brcc	.+10     	; 0xe92 <Calibrate+0x2b8>
     e88:	80 93 1e 07 	sts	0x071E, r24
     e8c:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
     e90:	04 c0       	rjmp	.+8      	; 0xe9a <Calibrate+0x2c0>
     e92:	8b e9       	ldi	r24, 0x9B	; 155
     e94:	92 e0       	ldi	r25, 0x02	; 2
     e96:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
     e9a:	ff ef       	ldi	r31, 0xFF	; 255
     e9c:	24 e3       	ldi	r18, 0x34	; 52
     e9e:	8c e0       	ldi	r24, 0x0C	; 12
     ea0:	f1 50       	subi	r31, 0x01	; 1
     ea2:	20 40       	sbci	r18, 0x00	; 0
     ea4:	80 40       	sbci	r24, 0x00	; 0
     ea6:	e1 f7       	brne	.-8      	; 0xea0 <Calibrate+0x2c6>
     ea8:	00 c0       	rjmp	.+0      	; 0xeaa <Calibrate+0x2d0>
     eaa:	00 00       	nop
     eac:	60 e0       	ldi	r22, 0x00	; 0
     eae:	88 e2       	ldi	r24, 0x28	; 40
     eb0:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     eb4:	1e e2       	ldi	r17, 0x2E	; 46
     eb6:	cd e2       	ldi	r28, 0x2D	; 45
     eb8:	0f 2e       	mov	r0, r31
     eba:	fe e2       	ldi	r31, 0x2E	; 46
     ebc:	df 2e       	mov	r13, r31
     ebe:	f0 2d       	mov	r31, r0
     ec0:	0f e3       	ldi	r16, 0x3F	; 63
     ec2:	0f 2e       	mov	r0, r31
     ec4:	ff e2       	ldi	r31, 0x2F	; 47
     ec6:	4f 2e       	mov	r4, r31
     ec8:	f0 2d       	mov	r31, r0
     eca:	0f 2e       	mov	r0, r31
     ecc:	fd e2       	ldi	r31, 0x2D	; 45
     ece:	5f 2e       	mov	r5, r31
     ed0:	f0 2d       	mov	r31, r0
     ed2:	0f 2e       	mov	r0, r31
     ed4:	fa e2       	ldi	r31, 0x2A	; 42
     ed6:	6f 2e       	mov	r6, r31
     ed8:	f0 2d       	mov	r31, r0
     eda:	0f 2e       	mov	r0, r31
     edc:	f0 e6       	ldi	r31, 0x60	; 96
     ede:	7f 2e       	mov	r7, r31
     ee0:	f0 2d       	mov	r31, r0
     ee2:	0f 2e       	mov	r0, r31
     ee4:	fe e7       	ldi	r31, 0x7E	; 126
     ee6:	8f 2e       	mov	r8, r31
     ee8:	f0 2d       	mov	r31, r0
     eea:	0f 2e       	mov	r0, r31
     eec:	fd e3       	ldi	r31, 0x3D	; 61
     eee:	9f 2e       	mov	r9, r31
     ef0:	f0 2d       	mov	r31, r0
     ef2:	0f 2e       	mov	r0, r31
     ef4:	fb e2       	ldi	r31, 0x2B	; 43
     ef6:	af 2e       	mov	r10, r31
     ef8:	f0 2d       	mov	r31, r0
     efa:	0f 2e       	mov	r0, r31
     efc:	fb e3       	ldi	r31, 0x3B	; 59
     efe:	bf 2e       	mov	r11, r31
     f00:	f0 2d       	mov	r31, r0
     f02:	0f 2e       	mov	r0, r31
     f04:	fa e3       	ldi	r31, 0x3A	; 58
     f06:	cf 2e       	mov	r12, r31
     f08:	f0 2d       	mov	r31, r0
     f0a:	02 c0       	rjmp	.+4      	; 0xf10 <Calibrate+0x336>
     f0c:	cf 5f       	subi	r28, 0xFF	; 255
     f0e:	1f 5f       	subi	r17, 0xFF	; 255
     f10:	c2 33       	cpi	r28, 0x32	; 50
     f12:	e1 f3       	breq	.-8      	; 0xf0c <Calibrate+0x332>
     f14:	60 e0       	ldi	r22, 0x00	; 0
     f16:	8c 2f       	mov	r24, r28
     f18:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     f1c:	60 e0       	ldi	r22, 0x00	; 0
     f1e:	8c e2       	ldi	r24, 0x2C	; 44
     f20:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     f24:	10 dd       	rcall	.-1504   	; 0x946 <WaitForKeypress>
     f26:	7c 01       	movw	r14, r24
     f28:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
     f2c:	d8 2f       	mov	r29, r24
     f2e:	ff 24       	eor	r15, r15
     f30:	48 2f       	mov	r20, r24
     f32:	b7 01       	movw	r22, r14
     f34:	8c 2f       	mov	r24, r28
     f36:	16 dd       	rcall	.-1492   	; 0x964 <TeachHIDKey>
     f38:	d2 fd       	sbrc	r29, 2
     f3a:	4d c0       	rjmp	.+154    	; 0xfd6 <Calibrate+0x3fc>
     f3c:	c3 33       	cpi	r28, 0x33	; 51
     f3e:	49 f4       	brne	.+18     	; 0xf52 <Calibrate+0x378>
     f40:	f7 01       	movw	r30, r14
     f42:	ea 51       	subi	r30, 0x1A	; 26
     f44:	f8 4f       	sbci	r31, 0xF8	; 248
     f46:	b0 82       	st	Z, r11
     f48:	f7 01       	movw	r30, r14
     f4a:	e9 59       	subi	r30, 0x99	; 153
     f4c:	f8 4f       	sbci	r31, 0xF8	; 248
     f4e:	c0 82       	st	Z, r12
     f50:	16 c0       	rjmp	.+44     	; 0xf7e <Calibrate+0x3a4>
     f52:	ce 32       	cpi	r28, 0x2E	; 46
     f54:	49 f4       	brne	.+18     	; 0xf68 <Calibrate+0x38e>
     f56:	f7 01       	movw	r30, r14
     f58:	ea 51       	subi	r30, 0x1A	; 26
     f5a:	f8 4f       	sbci	r31, 0xF8	; 248
     f5c:	90 82       	st	Z, r9
     f5e:	f7 01       	movw	r30, r14
     f60:	e9 59       	subi	r30, 0x99	; 153
     f62:	f8 4f       	sbci	r31, 0xF8	; 248
     f64:	a0 82       	st	Z, r10
     f66:	16 c0       	rjmp	.+44     	; 0xf94 <Calibrate+0x3ba>
     f68:	c5 33       	cpi	r28, 0x35	; 53
     f6a:	49 f4       	brne	.+18     	; 0xf7e <Calibrate+0x3a4>
     f6c:	f7 01       	movw	r30, r14
     f6e:	ea 51       	subi	r30, 0x1A	; 26
     f70:	f8 4f       	sbci	r31, 0xF8	; 248
     f72:	70 82       	st	Z, r7
     f74:	f7 01       	movw	r30, r14
     f76:	e9 59       	subi	r30, 0x99	; 153
     f78:	f8 4f       	sbci	r31, 0xF8	; 248
     f7a:	80 82       	st	Z, r8
     f7c:	16 c0       	rjmp	.+44     	; 0xfaa <Calibrate+0x3d0>
     f7e:	cd 32       	cpi	r28, 0x2D	; 45
     f80:	49 f4       	brne	.+18     	; 0xf94 <Calibrate+0x3ba>
     f82:	f7 01       	movw	r30, r14
     f84:	ea 51       	subi	r30, 0x1A	; 26
     f86:	f8 4f       	sbci	r31, 0xF8	; 248
     f88:	50 82       	st	Z, r5
     f8a:	f7 01       	movw	r30, r14
     f8c:	e9 59       	subi	r30, 0x99	; 153
     f8e:	f8 4f       	sbci	r31, 0xF8	; 248
     f90:	60 82       	st	Z, r6
     f92:	17 c0       	rjmp	.+46     	; 0xfc2 <Calibrate+0x3e8>
     f94:	c8 33       	cpi	r28, 0x38	; 56
     f96:	49 f4       	brne	.+18     	; 0xfaa <Calibrate+0x3d0>
     f98:	f7 01       	movw	r30, r14
     f9a:	ea 51       	subi	r30, 0x1A	; 26
     f9c:	f8 4f       	sbci	r31, 0xF8	; 248
     f9e:	40 82       	st	Z, r4
     fa0:	f7 01       	movw	r30, r14
     fa2:	e9 59       	subi	r30, 0x99	; 153
     fa4:	f8 4f       	sbci	r31, 0xF8	; 248
     fa6:	00 83       	st	Z, r16
     fa8:	16 c0       	rjmp	.+44     	; 0xfd6 <Calibrate+0x3fc>
     faa:	c6 33       	cpi	r28, 0x36	; 54
     fac:	51 f4       	brne	.+20     	; 0xfc2 <Calibrate+0x3e8>
     fae:	f7 01       	movw	r30, r14
     fb0:	ea 51       	subi	r30, 0x1A	; 26
     fb2:	f8 4f       	sbci	r31, 0xF8	; 248
     fb4:	8c e2       	ldi	r24, 0x2C	; 44
     fb6:	80 83       	st	Z, r24
     fb8:	f7 01       	movw	r30, r14
     fba:	e9 59       	subi	r30, 0x99	; 153
     fbc:	f8 4f       	sbci	r31, 0xF8	; 248
     fbe:	00 83       	st	Z, r16
     fc0:	0a c0       	rjmp	.+20     	; 0xfd6 <Calibrate+0x3fc>
     fc2:	c7 33       	cpi	r28, 0x37	; 55
     fc4:	41 f4       	brne	.+16     	; 0xfd6 <Calibrate+0x3fc>
     fc6:	f7 01       	movw	r30, r14
     fc8:	ea 51       	subi	r30, 0x1A	; 26
     fca:	f8 4f       	sbci	r31, 0xF8	; 248
     fcc:	d0 82       	st	Z, r13
     fce:	f7 01       	movw	r30, r14
     fd0:	e9 59       	subi	r30, 0x99	; 153
     fd2:	f8 4f       	sbci	r31, 0xF8	; 248
     fd4:	d0 82       	st	Z, r13
     fd6:	60 e0       	ldi	r22, 0x00	; 0
     fd8:	88 e2       	ldi	r24, 0x28	; 40
     fda:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     fde:	19 33       	cpi	r17, 0x39	; 57
     fe0:	08 f4       	brcc	.+2      	; 0xfe4 <Calibrate+0x40a>
     fe2:	94 cf       	rjmp	.-216    	; 0xf0c <Calibrate+0x332>
     fe4:	62 e0       	ldi	r22, 0x02	; 2
     fe6:	8f e1       	ldi	r24, 0x1F	; 31
     fe8:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     fec:	60 e0       	ldi	r22, 0x00	; 0
     fee:	8c e2       	ldi	r24, 0x2C	; 44
     ff0:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
     ff4:	a8 dc       	rcall	.-1712   	; 0x946 <WaitForKeypress>
     ff6:	ec 01       	movw	r28, r24
     ff8:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
     ffc:	9e 01       	movw	r18, r28
     ffe:	33 27       	eor	r19, r19
    1000:	82 30       	cpi	r24, 0x02	; 2
    1002:	71 f4       	brne	.+28     	; 0x1020 <Calibrate+0x446>
    1004:	f9 01       	movw	r30, r18
    1006:	e9 59       	subi	r30, 0x99	; 153
    1008:	f8 4f       	sbci	r31, 0xF8	; 248
    100a:	80 e4       	ldi	r24, 0x40	; 64
    100c:	80 83       	st	Z, r24
    100e:	8a ea       	ldi	r24, 0xAA	; 170
    1010:	92 e0       	ldi	r25, 0x02	; 2
    1012:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
    1016:	62 e0       	ldi	r22, 0x02	; 2
    1018:	8e e2       	ldi	r24, 0x2E	; 46
    101a:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
    101e:	07 c0       	rjmp	.+14     	; 0x102e <Calibrate+0x454>
    1020:	82 fd       	sbrc	r24, 2
    1022:	05 c0       	rjmp	.+10     	; 0x102e <Calibrate+0x454>
    1024:	f9 01       	movw	r30, r18
    1026:	ea 51       	subi	r30, 0x1A	; 26
    1028:	f8 4f       	sbci	r31, 0xF8	; 248
    102a:	80 e4       	ldi	r24, 0x40	; 64
    102c:	80 83       	st	Z, r24
    102e:	8c 2f       	mov	r24, r28
    1030:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
    1034:	60 e0       	ldi	r22, 0x00	; 0
    1036:	88 e2       	ldi	r24, 0x28	; 40
    1038:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
    103c:	9f ef       	ldi	r25, 0xFF	; 255
    103e:	e4 e3       	ldi	r30, 0x34	; 52
    1040:	fc e0       	ldi	r31, 0x0C	; 12
    1042:	91 50       	subi	r25, 0x01	; 1
    1044:	e0 40       	sbci	r30, 0x00	; 0
    1046:	f0 40       	sbci	r31, 0x00	; 0
    1048:	e1 f7       	brne	.-8      	; 0x1042 <Calibrate+0x468>
    104a:	00 c0       	rjmp	.+0      	; 0x104c <Calibrate+0x472>
    104c:	00 00       	nop
    104e:	62 e0       	ldi	r22, 0x02	; 2
    1050:	88 e3       	ldi	r24, 0x38	; 56
    1052:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
    1056:	60 e0       	ldi	r22, 0x00	; 0
    1058:	8c e2       	ldi	r24, 0x2C	; 44
    105a:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
    105e:	73 dc       	rcall	.-1818   	; 0x946 <WaitForKeypress>
    1060:	ec 01       	movw	r28, r24
    1062:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
    1066:	9e 01       	movw	r18, r28
    1068:	33 27       	eor	r19, r19
    106a:	82 30       	cpi	r24, 0x02	; 2
    106c:	71 f4       	brne	.+28     	; 0x108a <Calibrate+0x4b0>
    106e:	f9 01       	movw	r30, r18
    1070:	e9 59       	subi	r30, 0x99	; 153
    1072:	f8 4f       	sbci	r31, 0xF8	; 248
    1074:	8f e3       	ldi	r24, 0x3F	; 63
    1076:	80 83       	st	Z, r24
    1078:	8a ea       	ldi	r24, 0xAA	; 170
    107a:	92 e0       	ldi	r25, 0x02	; 2
    107c:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
    1080:	62 e0       	ldi	r22, 0x02	; 2
    1082:	8e e2       	ldi	r24, 0x2E	; 46
    1084:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
    1088:	07 c0       	rjmp	.+14     	; 0x1098 <Calibrate+0x4be>
    108a:	82 fd       	sbrc	r24, 2
    108c:	05 c0       	rjmp	.+10     	; 0x1098 <Calibrate+0x4be>
    108e:	f9 01       	movw	r30, r18
    1090:	ea 51       	subi	r30, 0x1A	; 26
    1092:	f8 4f       	sbci	r31, 0xF8	; 248
    1094:	8f e3       	ldi	r24, 0x3F	; 63
    1096:	80 83       	st	Z, r24
    1098:	8c 2f       	mov	r24, r28
    109a:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
    109e:	60 e0       	ldi	r22, 0x00	; 0
    10a0:	88 e2       	ldi	r24, 0x28	; 40
    10a2:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
    10a6:	2f ef       	ldi	r18, 0xFF	; 255
    10a8:	84 e3       	ldi	r24, 0x34	; 52
    10aa:	9c e0       	ldi	r25, 0x0C	; 12
    10ac:	21 50       	subi	r18, 0x01	; 1
    10ae:	80 40       	sbci	r24, 0x00	; 0
    10b0:	90 40       	sbci	r25, 0x00	; 0
    10b2:	e1 f7       	brne	.-8      	; 0x10ac <Calibrate+0x4d2>
    10b4:	00 c0       	rjmp	.+0      	; 0x10b6 <Calibrate+0x4dc>
    10b6:	00 00       	nop
    10b8:	62 e0       	ldi	r22, 0x02	; 2
    10ba:	8e e9       	ldi	r24, 0x9E	; 158
    10bc:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
    10c0:	60 e0       	ldi	r22, 0x00	; 0
    10c2:	8c e2       	ldi	r24, 0x2C	; 44
    10c4:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
    10c8:	3e dc       	rcall	.-1924   	; 0x946 <WaitForKeypress>
    10ca:	ec 01       	movw	r28, r24
    10cc:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
    10d0:	18 2f       	mov	r17, r24
    10d2:	dd 27       	eor	r29, r29
    10d4:	48 2f       	mov	r20, r24
    10d6:	be 01       	movw	r22, r28
    10d8:	8e e9       	ldi	r24, 0x9E	; 158
    10da:	44 dc       	rcall	.-1912   	; 0x964 <TeachHIDKey>
    10dc:	12 30       	cpi	r17, 0x02	; 2
    10de:	29 f4       	brne	.+10     	; 0x10ea <Calibrate+0x510>
    10e0:	c9 59       	subi	r28, 0x99	; 153
    10e2:	d8 4f       	sbci	r29, 0xF8	; 248
    10e4:	81 e2       	ldi	r24, 0x21	; 33
    10e6:	88 83       	st	Y, r24
    10e8:	06 c0       	rjmp	.+12     	; 0x10f6 <Calibrate+0x51c>
    10ea:	12 fd       	sbrc	r17, 2
    10ec:	04 c0       	rjmp	.+8      	; 0x10f6 <Calibrate+0x51c>
    10ee:	ca 51       	subi	r28, 0x1A	; 26
    10f0:	d8 4f       	sbci	r29, 0xF8	; 248
    10f2:	81 e2       	ldi	r24, 0x21	; 33
    10f4:	88 83       	st	Y, r24
    10f6:	60 e0       	ldi	r22, 0x00	; 0
    10f8:	88 e2       	ldi	r24, 0x28	; 40
    10fa:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
    10fe:	6c dc       	rcall	.-1832   	; 0x9d8 <CalibrateReeds>
    1100:	7a db       	rcall	.-2316   	; 0x7f6 <SaveCalibration>
    1102:	8c ea       	ldi	r24, 0xAC	; 172
    1104:	90 e0       	ldi	r25, 0x00	; 0
    1106:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
    110a:	05 c0       	rjmp	.+10     	; 0x1116 <Calibrate+0x53c>
    110c:	60 e0       	ldi	r22, 0x00	; 0
    110e:	88 e2       	ldi	r24, 0x28	; 40
    1110:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
    1114:	fd cd       	rjmp	.-1030   	; 0xd10 <Calibrate+0x136>
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	1f 91       	pop	r17
    111c:	0f 91       	pop	r16
    111e:	ff 90       	pop	r15
    1120:	ef 90       	pop	r14
    1122:	df 90       	pop	r13
    1124:	cf 90       	pop	r12
    1126:	bf 90       	pop	r11
    1128:	af 90       	pop	r10
    112a:	9f 90       	pop	r9
    112c:	8f 90       	pop	r8
    112e:	7f 90       	pop	r7
    1130:	6f 90       	pop	r6
    1132:	5f 90       	pop	r5
    1134:	4f 90       	pop	r4
    1136:	08 95       	ret

00001138 <Adjust_Sensitivity>:
	}
}

void Adjust_Sensitivity(){
    1138:	cf 93       	push	r28
	KeyHoldTime = eeprom_read_byte((uint8_t*)HOLD_TIME_ADDR);
    113a:	81 e0       	ldi	r24, 0x01	; 1
    113c:	92 e0       	ldi	r25, 0x02	; 2
    113e:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    1142:	80 93 66 07 	sts	0x0766, r24
	KeyReleaseTime = eeprom_read_byte((uint8_t*)RELEASE_TIME_ADDR);
    1146:	82 e0       	ldi	r24, 0x02	; 2
    1148:	92 e0       	ldi	r25, 0x02	; 2
    114a:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    114e:	80 93 d9 06 	sts	0x06D9, r24
	DoubleTapTime= eeprom_read_byte((uint8_t*)DOUBLE_TAP_ADDR);
    1152:	80 e0       	ldi	r24, 0x00	; 0
    1154:	92 e0       	ldi	r25, 0x02	; 2
    1156:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    115a:	80 93 1d 07 	sts	0x071D, r24
	
	while(USB_DeviceState != DEVICE_STATE_Configured){;}//wait for configuration to complete
    115e:	80 91 6d 0a 	lds	r24, 0x0A6D
    1162:	84 30       	cpi	r24, 0x04	; 4
    1164:	e1 f7       	brne	.-8      	; 0x115e <Adjust_Sensitivity+0x26>
    1166:	2f ef       	ldi	r18, 0xFF	; 255
    1168:	89 e6       	ldi	r24, 0x69	; 105
    116a:	98 e1       	ldi	r25, 0x18	; 24
    116c:	21 50       	subi	r18, 0x01	; 1
    116e:	80 40       	sbci	r24, 0x00	; 0
    1170:	90 40       	sbci	r25, 0x00	; 0
    1172:	e1 f7       	brne	.-8      	; 0x116c <Adjust_Sensitivity+0x34>
    1174:	00 c0       	rjmp	.+0      	; 0x1176 <Adjust_Sensitivity+0x3e>
    1176:	00 00       	nop
	Delay_MS(1000);//wait 1 second.
	
	USBSendPROGString(Str_Adj_Sensitivity);
    1178:	81 ea       	ldi	r24, 0xA1	; 161
    117a:	91 e0       	ldi	r25, 0x01	; 1
    117c:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
	USBSendPROGString(Str_Press_CMD);
    1180:	83 e8       	ldi	r24, 0x83	; 131
    1182:	91 e0       	ldi	r25, 0x01	; 1
    1184:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
	while(is_high(S3)){;}
    1188:	7e 99       	sbic	0x0f, 6	; 15
    118a:	fe cf       	rjmp	.-4      	; 0x1188 <Adjust_Sensitivity+0x50>
	
	USBSendPROGString(Str_Set_Reaction_Time);
    118c:	83 e5       	ldi	r24, 0x53	; 83
    118e:	91 e0       	ldi	r25, 0x01	; 1
    1190:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
	USBSendNumber(KeyHoldTime);
    1194:	80 91 66 07 	lds	r24, 0x0766
    1198:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    119c:	60 e0       	ldi	r22, 0x00	; 0
    119e:	88 e2       	ldi	r24, 0x28	; 40
    11a0:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
	while(is_high(S3)){
    11a4:	1a c0       	rjmp	.+52     	; 0x11da <Adjust_Sensitivity+0xa2>
		if(is_low(S1)){KeyHoldTime++;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
    11a6:	7c 99       	sbic	0x0f, 4	; 15
    11a8:	0b c0       	rjmp	.+22     	; 0x11c0 <Adjust_Sensitivity+0x88>
    11aa:	80 91 66 07 	lds	r24, 0x0766
    11ae:	8f 5f       	subi	r24, 0xFF	; 255
    11b0:	80 93 66 07 	sts	0x0766, r24
    11b4:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
    11b8:	60 e0       	ldi	r22, 0x00	; 0
    11ba:	88 e2       	ldi	r24, 0x28	; 40
    11bc:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
		if(is_low(S2)){KeyHoldTime--;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
    11c0:	7d 99       	sbic	0x0f, 5	; 15
    11c2:	0b c0       	rjmp	.+22     	; 0x11da <Adjust_Sensitivity+0xa2>
    11c4:	80 91 66 07 	lds	r24, 0x0766
    11c8:	81 50       	subi	r24, 0x01	; 1
    11ca:	80 93 66 07 	sts	0x0766, r24
    11ce:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
    11d2:	60 e0       	ldi	r22, 0x00	; 0
    11d4:	88 e2       	ldi	r24, 0x28	; 40
    11d6:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
	while(is_high(S3)){;}
	
	USBSendPROGString(Str_Set_Reaction_Time);
	USBSendNumber(KeyHoldTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    11da:	7e 99       	sbic	0x0f, 6	; 15
    11dc:	e4 cf       	rjmp	.-56     	; 0x11a6 <Adjust_Sensitivity+0x6e>
		if(is_low(S1)){KeyHoldTime++;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){KeyHoldTime--;USBSendNumber(KeyHoldTime);USBSend(KEY_ENTER,LOWER);}
	}
	
	USBSendPROGString(Str_Set_Release_Time);
    11de:	85 e3       	ldi	r24, 0x35	; 53
    11e0:	91 e0       	ldi	r25, 0x01	; 1
    11e2:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
	USBSendNumber(KeyReleaseTime);
    11e6:	80 91 d9 06 	lds	r24, 0x06D9
    11ea:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    11ee:	60 e0       	ldi	r22, 0x00	; 0
    11f0:	88 e2       	ldi	r24, 0x28	; 40
    11f2:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
	while(is_high(S3)){
    11f6:	1a c0       	rjmp	.+52     	; 0x122c <Adjust_Sensitivity+0xf4>
		if(is_low(S1)){KeyReleaseTime++;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
    11f8:	7c 99       	sbic	0x0f, 4	; 15
    11fa:	0b c0       	rjmp	.+22     	; 0x1212 <Adjust_Sensitivity+0xda>
    11fc:	80 91 d9 06 	lds	r24, 0x06D9
    1200:	8f 5f       	subi	r24, 0xFF	; 255
    1202:	80 93 d9 06 	sts	0x06D9, r24
    1206:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
    120a:	60 e0       	ldi	r22, 0x00	; 0
    120c:	88 e2       	ldi	r24, 0x28	; 40
    120e:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
		if(is_low(S2)){KeyReleaseTime--;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
    1212:	7d 99       	sbic	0x0f, 5	; 15
    1214:	0b c0       	rjmp	.+22     	; 0x122c <Adjust_Sensitivity+0xf4>
    1216:	80 91 d9 06 	lds	r24, 0x06D9
    121a:	81 50       	subi	r24, 0x01	; 1
    121c:	80 93 d9 06 	sts	0x06D9, r24
    1220:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
    1224:	60 e0       	ldi	r22, 0x00	; 0
    1226:	88 e2       	ldi	r24, 0x28	; 40
    1228:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
	}
	
	USBSendPROGString(Str_Set_Release_Time);
	USBSendNumber(KeyReleaseTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    122c:	7e 99       	sbic	0x0f, 6	; 15
    122e:	e4 cf       	rjmp	.-56     	; 0x11f8 <Adjust_Sensitivity+0xc0>
		if(is_low(S1)){KeyReleaseTime++;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){KeyReleaseTime--;USBSendNumber(KeyReleaseTime);USBSend(KEY_ENTER,LOWER);}
	}
	
	USBSendPROGString(Str_Set_Double_Time);
    1230:	87 e0       	ldi	r24, 0x07	; 7
    1232:	91 e0       	ldi	r25, 0x01	; 1
    1234:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
	USBSendNumber(DoubleTapTime);
    1238:	80 91 1d 07 	lds	r24, 0x071D
    123c:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    1240:	60 e0       	ldi	r22, 0x00	; 0
    1242:	88 e2       	ldi	r24, 0x28	; 40
    1244:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
	while(is_high(S3)){
    1248:	1a c0       	rjmp	.+52     	; 0x127e <Adjust_Sensitivity+0x146>
		if(is_low(S1)){DoubleTapTime++;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
    124a:	7c 99       	sbic	0x0f, 4	; 15
    124c:	0b c0       	rjmp	.+22     	; 0x1264 <Adjust_Sensitivity+0x12c>
    124e:	80 91 1d 07 	lds	r24, 0x071D
    1252:	8f 5f       	subi	r24, 0xFF	; 255
    1254:	80 93 1d 07 	sts	0x071D, r24
    1258:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
    125c:	60 e0       	ldi	r22, 0x00	; 0
    125e:	88 e2       	ldi	r24, 0x28	; 40
    1260:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
		if(is_low(S2)){DoubleTapTime--;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
    1264:	7d 99       	sbic	0x0f, 5	; 15
    1266:	0b c0       	rjmp	.+22     	; 0x127e <Adjust_Sensitivity+0x146>
    1268:	80 91 1d 07 	lds	r24, 0x071D
    126c:	81 50       	subi	r24, 0x01	; 1
    126e:	80 93 1d 07 	sts	0x071D, r24
    1272:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
    1276:	60 e0       	ldi	r22, 0x00	; 0
    1278:	88 e2       	ldi	r24, 0x28	; 40
    127a:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
	}
	
	USBSendPROGString(Str_Set_Double_Time);
	USBSendNumber(DoubleTapTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    127e:	7e 99       	sbic	0x0f, 6	; 15
    1280:	e4 cf       	rjmp	.-56     	; 0x124a <Adjust_Sensitivity+0x112>
		if(is_low(S1)){DoubleTapTime++;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){DoubleTapTime--;USBSendNumber(DoubleTapTime);USBSend(KEY_ENTER,LOWER);}
	}
	
	USBSendPROGString(Str_Set_Reed_Time);
    1282:	87 ee       	ldi	r24, 0xE7	; 231
    1284:	90 e0       	ldi	r25, 0x00	; 0
    1286:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
	USBSendNumber(ReedHoldTime);
    128a:	80 91 1c 07 	lds	r24, 0x071C
    128e:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
	USBSend(KEY_ENTER,LOWER);
    1292:	60 e0       	ldi	r22, 0x00	; 0
    1294:	88 e2       	ldi	r24, 0x28	; 40
    1296:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
	while(is_high(S3)){
    129a:	1a c0       	rjmp	.+52     	; 0x12d0 <Adjust_Sensitivity+0x198>
		if(is_low(S1)){ReedHoldTime++;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
    129c:	7c 99       	sbic	0x0f, 4	; 15
    129e:	0b c0       	rjmp	.+22     	; 0x12b6 <Adjust_Sensitivity+0x17e>
    12a0:	80 91 1c 07 	lds	r24, 0x071C
    12a4:	8f 5f       	subi	r24, 0xFF	; 255
    12a6:	80 93 1c 07 	sts	0x071C, r24
    12aa:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
    12ae:	60 e0       	ldi	r22, 0x00	; 0
    12b0:	88 e2       	ldi	r24, 0x28	; 40
    12b2:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
    12b6:	7d 99       	sbic	0x0f, 5	; 15
    12b8:	0b c0       	rjmp	.+22     	; 0x12d0 <Adjust_Sensitivity+0x198>
    12ba:	80 91 1c 07 	lds	r24, 0x071C
    12be:	81 50       	subi	r24, 0x01	; 1
    12c0:	80 93 1c 07 	sts	0x071C, r24
    12c4:	0e 94 42 2a 	call	0x5484	; 0x5484 <USBSendNumber>
    12c8:	60 e0       	ldi	r22, 0x00	; 0
    12ca:	88 e2       	ldi	r24, 0x28	; 40
    12cc:	0e 94 76 29 	call	0x52ec	; 0x52ec <USBSend>
	}
	
	USBSendPROGString(Str_Set_Reed_Time);
	USBSendNumber(ReedHoldTime);
	USBSend(KEY_ENTER,LOWER);
	while(is_high(S3)){
    12d0:	7e 99       	sbic	0x0f, 6	; 15
    12d2:	e4 cf       	rjmp	.-56     	; 0x129c <Adjust_Sensitivity+0x164>
		if(is_low(S1)){ReedHoldTime++;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
	}	
	
	USBSendPROGString(Str_Spacebar_Blocks_Enter);
    12d4:	8d eb       	ldi	r24, 0xBD	; 189
    12d6:	90 e0       	ldi	r25, 0x00	; 0
    12d8:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
	Reeds_Are_Independent ? USBSendString("NO\r") : USBSendString("YES\r");
    12dc:	80 91 d7 06 	lds	r24, 0x06D7
    12e0:	88 23       	and	r24, r24
    12e2:	29 f0       	breq	.+10     	; 0x12ee <Adjust_Sensitivity+0x1b6>
    12e4:	8e ec       	ldi	r24, 0xCE	; 206
    12e6:	92 e0       	ldi	r25, 0x02	; 2
    12e8:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
    12ec:	1a c0       	rjmp	.+52     	; 0x1322 <Adjust_Sensitivity+0x1ea>
    12ee:	82 ed       	ldi	r24, 0xD2	; 210
    12f0:	92 e0       	ldi	r25, 0x02	; 2
    12f2:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
    12f6:	15 c0       	rjmp	.+42     	; 0x1322 <Adjust_Sensitivity+0x1ea>
	while(is_high(S3)){
		if(is_low(S1)){Reeds_Are_Independent = false; USBSendString("YES\r");}
    12f8:	7c 99       	sbic	0x0f, 4	; 15
    12fa:	06 c0       	rjmp	.+12     	; 0x1308 <Adjust_Sensitivity+0x1d0>
    12fc:	10 92 d7 06 	sts	0x06D7, r1
    1300:	82 ed       	ldi	r24, 0xD2	; 210
    1302:	92 e0       	ldi	r25, 0x02	; 2
    1304:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
		if(is_low(S2)){Reeds_Are_Independent = true; USBSendString("NO\r");}
    1308:	7d 99       	sbic	0x0f, 5	; 15
    130a:	06 c0       	rjmp	.+12     	; 0x1318 <Adjust_Sensitivity+0x1e0>
    130c:	c0 93 d7 06 	sts	0x06D7, r28
    1310:	8e ec       	ldi	r24, 0xCE	; 206
    1312:	92 e0       	ldi	r25, 0x02	; 2
    1314:	0e 94 ba 29 	call	0x5374	; 0x5374 <USBSendString>
		while(is_low(S1)||is_low(S2)){;}//wait until one of the switches is released before looping.
    1318:	7c 9b       	sbis	0x0f, 4	; 15
    131a:	fe cf       	rjmp	.-4      	; 0x1318 <Adjust_Sensitivity+0x1e0>
    131c:	7d 9b       	sbis	0x0f, 5	; 15
    131e:	fc cf       	rjmp	.-8      	; 0x1318 <Adjust_Sensitivity+0x1e0>
    1320:	01 c0       	rjmp	.+2      	; 0x1324 <Adjust_Sensitivity+0x1ec>
	
	USBSendPROGString(Str_Spacebar_Blocks_Enter);
	Reeds_Are_Independent ? USBSendString("NO\r") : USBSendString("YES\r");
	while(is_high(S3)){
		if(is_low(S1)){Reeds_Are_Independent = false; USBSendString("YES\r");}
		if(is_low(S2)){Reeds_Are_Independent = true; USBSendString("NO\r");}
    1322:	c1 e0       	ldi	r28, 0x01	; 1
		if(is_low(S2)){ReedHoldTime--;USBSendNumber(ReedHoldTime);USBSend(KEY_ENTER,LOWER);}
	}	
	
	USBSendPROGString(Str_Spacebar_Blocks_Enter);
	Reeds_Are_Independent ? USBSendString("NO\r") : USBSendString("YES\r");
	while(is_high(S3)){
    1324:	7e 99       	sbic	0x0f, 6	; 15
    1326:	e8 cf       	rjmp	.-48     	; 0x12f8 <Adjust_Sensitivity+0x1c0>
		if(is_low(S1)){Reeds_Are_Independent = false; USBSendString("YES\r");}
		if(is_low(S2)){Reeds_Are_Independent = true; USBSendString("NO\r");}
		while(is_low(S1)||is_low(S2)){;}//wait until one of the switches is released before looping.
	}
	
	eeprom_update_byte((uint8_t*)DOUBLE_TAP_ADDR,DoubleTapTime);
    1328:	60 91 1d 07 	lds	r22, 0x071D
    132c:	80 e0       	ldi	r24, 0x00	; 0
    132e:	92 e0       	ldi	r25, 0x02	; 2
    1330:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)RELEASE_TIME_ADDR,KeyReleaseTime);
    1334:	60 91 d9 06 	lds	r22, 0x06D9
    1338:	82 e0       	ldi	r24, 0x02	; 2
    133a:	92 e0       	ldi	r25, 0x02	; 2
    133c:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)HOLD_TIME_ADDR,KeyHoldTime);
    1340:	60 91 66 07 	lds	r22, 0x0766
    1344:	81 e0       	ldi	r24, 0x01	; 1
    1346:	92 e0       	ldi	r25, 0x02	; 2
    1348:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)REED_HOLD_TIME_ADDR,ReedHoldTime);
    134c:	60 91 1c 07 	lds	r22, 0x071C
    1350:	8c e0       	ldi	r24, 0x0C	; 12
    1352:	92 e0       	ldi	r25, 0x02	; 2
    1354:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
	eeprom_update_byte((uint8_t*)REEDS_INDEPENDENT_ADDR,Reeds_Are_Independent);
    1358:	60 91 d7 06 	lds	r22, 0x06D7
    135c:	8e e0       	ldi	r24, 0x0E	; 14
    135e:	92 e0       	ldi	r25, 0x02	; 2
    1360:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
	
	USBSendPROGString(Str_Settings_Saved);
    1364:	8c ea       	ldi	r24, 0xAC	; 172
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	0e 94 39 2a 	call	0x5472	; 0x5472 <USBSendPROGString>
}
    136c:	cf 91       	pop	r28
    136e:	08 95       	ret

00001370 <Config_Interrupts>:


void Config_Interrupts(){

	
	bit_clr(PRR0,PRTIM1); // clear power-reduction bit for timer1
    1370:	e4 e6       	ldi	r30, 0x64	; 100
    1372:	f0 e0       	ldi	r31, 0x00	; 0
    1374:	80 81       	ld	r24, Z
    1376:	87 7f       	andi	r24, 0xF7	; 247
    1378:	80 83       	st	Z, r24
	TCCR1B = BIT(CTC1) | BIT(CS11); //set CTC (clear timer on compare equal mode) and set tmr prescaler to 8 -- page 125 of datasheet
    137a:	8a e0       	ldi	r24, 0x0A	; 10
    137c:	80 93 81 00 	sts	0x0081, r24
	
	OCR1AH = TIMER1_COMPARE_HIGH;//high register MUST be written before low register.  Datasheet says so!
    1380:	87 e2       	ldi	r24, 0x27	; 39
    1382:	80 93 89 00 	sts	0x0089, r24
	OCR1AL = UINT8_C(TIMER1_COMPARE_LOW); //we only want the first 8 bits of the "low" variable.
    1386:	80 e1       	ldi	r24, 0x10	; 16
    1388:	80 93 88 00 	sts	0x0088, r24
	
	bit_set(TIMSK1,OCIE1A); //enable output compare interrupt for timer1
    138c:	ef e6       	ldi	r30, 0x6F	; 111
    138e:	f0 e0       	ldi	r31, 0x00	; 0
    1390:	80 81       	ld	r24, Z
    1392:	82 60       	ori	r24, 0x02	; 2
    1394:	80 83       	st	Z, r24
    1396:	08 95       	ret

00001398 <Config_IO>:
volatile uint8_t GlowDirection; //global variable that sets direction of led glow (fade up or down)


void Config_IO(){
	
	configure_as_input(SD_DETECT);
    1398:	20 98       	cbi	0x04, 0	; 4
	pullup_on(SD_DETECT);
    139a:	28 9a       	sbi	0x05, 0	; 5
	
	configure_as_input(REED_1);
    139c:	54 98       	cbi	0x0a, 4	; 10
	pullup_on(REED_1);
    139e:	5c 9a       	sbi	0x0b, 4	; 11
	
	configure_as_input(REED_2);
    13a0:	56 98       	cbi	0x0a, 6	; 10
	pullup_on(REED_2);	
    13a2:	5e 9a       	sbi	0x0b, 6	; 11

	configure_as_input(REED_3);
    13a4:	57 98       	cbi	0x0a, 7	; 10
	pullup_on(REED_3);	
    13a6:	5f 9a       	sbi	0x0b, 7	; 11
	
	configure_as_input(REED_4);
    13a8:	24 98       	cbi	0x04, 4	; 4
	pullup_on(REED_4);	
    13aa:	2c 9a       	sbi	0x05, 4	; 5
	
	
	set_high(SD_MISO);
    13ac:	2b 9a       	sbi	0x05, 3	; 5
	configure_as_input(SD_MISO);
    13ae:	23 98       	cbi	0x04, 3	; 4
	pullup_on(SD_MISO);
    13b0:	2b 9a       	sbi	0x05, 3	; 5
	
	set_high(SD_MOSI);
    13b2:	2a 9a       	sbi	0x05, 2	; 5
	configure_as_input(SD_MOSI);
    13b4:	22 98       	cbi	0x04, 2	; 4
	pullup_on(SD_MOSI);
    13b6:	2a 9a       	sbi	0x05, 2	; 5
	
	configure_as_output(SENSE_CLK);
    13b8:	6a 9a       	sbi	0x0d, 2	; 13
	
	configure_as_input(SENSE_SER);
    13ba:	25 98       	cbi	0x04, 5	; 4
	pullup_on(SENSE_SER);
    13bc:	2d 9a       	sbi	0x05, 5	; 5

	set_high(SD_CLK);
    13be:	29 9a       	sbi	0x05, 1	; 5
	configure_as_input(SD_CLK);
    13c0:	21 98       	cbi	0x04, 1	; 4
	pullup_on(SD_CLK);
    13c2:	29 9a       	sbi	0x05, 1	; 5
	
	set_high(SD_CHIP_SELECT);
    13c4:	59 9a       	sbi	0x0b, 1	; 11
	configure_as_output(SD_CHIP_SELECT);
    13c6:	51 9a       	sbi	0x0a, 1	; 10
	
	configure_as_input(DUMMY_LOAD);
    13c8:	55 98       	cbi	0x0a, 5	; 10
	//no pullup;
	
	set_high(TX);
    13ca:	5b 9a       	sbi	0x0b, 3	; 11
	configure_as_output(TX);
    13cc:	53 9a       	sbi	0x0a, 3	; 10
	
	configure_as_input(RX);
    13ce:	52 98       	cbi	0x0a, 2	; 10
	pullup_on(RX);
    13d0:	5a 9a       	sbi	0x0b, 2	; 11
	
	configure_as_input(S1);
    13d2:	84 98       	cbi	0x10, 4	; 16
	pullup_on(S1);
    13d4:	8c 9a       	sbi	0x11, 4	; 17
	
	configure_as_input(S2);
    13d6:	85 98       	cbi	0x10, 5	; 16
	pullup_on(S2);
    13d8:	8d 9a       	sbi	0x11, 5	; 17
	
	configure_as_input(S3);
    13da:	86 98       	cbi	0x10, 6	; 16
	pullup_on(S3);
    13dc:	8e 9a       	sbi	0x11, 6	; 17
	
	set_low(BT_RESET);// bt is off by default
    13de:	8f 98       	cbi	0x11, 7	; 17
	configure_as_output(BT_RESET); 
    13e0:	87 9a       	sbi	0x10, 7	; 16
	
	set_high(BT_BAUD);
    13e2:	47 9a       	sbi	0x08, 7	; 8
	configure_as_output(BT_BAUD);
    13e4:	3f 9a       	sbi	0x07, 7	; 7
	
	configure_as_input(BT_CONNECTED);
    13e6:	81 98       	cbi	0x10, 1	; 16
	pullup_on(BT_CONNECTED);
    13e8:	89 9a       	sbi	0x11, 1	; 17
	
	set_high(BT_CTS);
    13ea:	76 9a       	sbi	0x0e, 6	; 14
	configure_as_output(BT_CTS);
    13ec:	6e 9a       	sbi	0x0d, 6	; 13
	
	set_high(LED1);
    13ee:	46 9a       	sbi	0x08, 6	; 8
	configure_as_output(LED1);
    13f0:	3e 9a       	sbi	0x07, 6	; 7
	
	set_high(LED2);
    13f2:	2e 9a       	sbi	0x05, 6	; 5
	configure_as_output(LED2);
    13f4:	26 9a       	sbi	0x04, 6	; 4
    13f6:	08 95       	ret

000013f8 <GlowGreenLED>:
}

void GlowGreenLED(uint8_t speed, uint8_t mode){

	//green led is also called the ~OC4A pin
	cli();//disable interrupts;
    13f8:	f8 94       	cli
	OCR4C = 0xFF; //clear tmr4 when reaching this value
    13fa:	9f ef       	ldi	r25, 0xFF	; 255
    13fc:	90 93 d1 00 	sts	0x00D1, r25
	TC4H = 0x00; //clearing this register sets timer4 to 8-bit mode
    1400:	10 92 bf 00 	sts	0x00BF, r1
	OCR4A = 0x20; //when counter reaches this value, it triggers LED.
    1404:	90 e2       	ldi	r25, 0x20	; 32
    1406:	90 93 cf 00 	sts	0x00CF, r25
	
	if(mode == SOLID){
    140a:	61 30       	cpi	r22, 0x01	; 1
    140c:	61 f4       	brne	.+24     	; 0x1426 <GlowGreenLED+0x2e>
		bit_clr(TCCR4E,OC4OE0);//disconnect ~oc4a output
    140e:	e4 ec       	ldi	r30, 0xC4	; 196
    1410:	f0 e0       	ldi	r31, 0x00	; 0
    1412:	90 81       	ld	r25, Z
    1414:	9e 7f       	andi	r25, 0xFE	; 254
    1416:	90 83       	st	Z, r25
		bit_clr(TCCR4A,COM4A0); //clear the bit for ~OC4A pin to be active in fast pwm mode
    1418:	e0 ec       	ldi	r30, 0xC0	; 192
    141a:	f0 e0       	ldi	r31, 0x00	; 0
    141c:	90 81       	ld	r25, Z
    141e:	9f 7b       	andi	r25, 0xBF	; 191
    1420:	90 83       	st	Z, r25
		set_low(GREEN_LED);	//manually pull led low
    1422:	46 98       	cbi	0x08, 6	; 8
    1424:	0a c0       	rjmp	.+20     	; 0x143a <GlowGreenLED+0x42>
	}
	else{
		bit_set(TCCR4E,OC4OE0);//enable the ~oc4a output
    1426:	e4 ec       	ldi	r30, 0xC4	; 196
    1428:	f0 e0       	ldi	r31, 0x00	; 0
    142a:	90 81       	ld	r25, Z
    142c:	91 60       	ori	r25, 0x01	; 1
    142e:	90 83       	st	Z, r25
		bit_set(TCCR4A,COM4A0); //set the bit for ~OC4A pin to be active in fast pwm mode
    1430:	e0 ec       	ldi	r30, 0xC0	; 192
    1432:	f0 e0       	ldi	r31, 0x00	; 0
    1434:	90 81       	ld	r25, Z
    1436:	90 64       	ori	r25, 0x40	; 64
    1438:	90 83       	st	Z, r25
	}
	
	
	bit_set(TCCR4A,PWM4A);//activate fast pwm mode
    143a:	e0 ec       	ldi	r30, 0xC0	; 192
    143c:	f0 e0       	ldi	r31, 0x00	; 0
    143e:	90 81       	ld	r25, Z
    1440:	92 60       	ori	r25, 0x02	; 2
    1442:	90 83       	st	Z, r25
	bit_set(TIMSK4,TOIE4);//enable timer overflow interrupts.
    1444:	e2 e7       	ldi	r30, 0x72	; 114
    1446:	f0 e0       	ldi	r31, 0x00	; 0
    1448:	90 81       	ld	r25, Z
    144a:	94 60       	ori	r25, 0x04	; 4
    144c:	90 83       	st	Z, r25
	switch(speed){
    144e:	81 30       	cpi	r24, 0x01	; 1
    1450:	49 f0       	breq	.+18     	; 0x1464 <GlowGreenLED+0x6c>
    1452:	28 f0       	brcs	.+10     	; 0x145e <GlowGreenLED+0x66>
    1454:	82 30       	cpi	r24, 0x02	; 2
    1456:	61 f0       	breq	.+24     	; 0x1470 <GlowGreenLED+0x78>
    1458:	83 30       	cpi	r24, 0x03	; 3
    145a:	71 f0       	breq	.+28     	; 0x1478 <GlowGreenLED+0x80>
    145c:	11 c0       	rjmp	.+34     	; 0x1480 <GlowGreenLED+0x88>
		case 0:
			TCCR4B = BIT(CS43)|BIT(CS40);
    145e:	89 e0       	ldi	r24, 0x09	; 9
    1460:	80 93 c1 00 	sts	0x00C1, r24
		case 1:
			bit_set(TCCR4B,CS43);//enable 1:128 prescaler (should make each tick worth about 10khZ).
    1464:	e1 ec       	ldi	r30, 0xC1	; 193
    1466:	f0 e0       	ldi	r31, 0x00	; 0
    1468:	80 81       	ld	r24, Z
    146a:	88 60       	ori	r24, 0x08	; 8
    146c:	80 83       	st	Z, r24
		break;
    146e:	0d c0       	rjmp	.+26     	; 0x148a <GlowGreenLED+0x92>
		case 2:
			TCCR4B = BIT(CS42)|BIT(CS41)|BIT(CS40);
    1470:	87 e0       	ldi	r24, 0x07	; 7
    1472:	80 93 c1 00 	sts	0x00C1, r24
		break;
    1476:	09 c0       	rjmp	.+18     	; 0x148a <GlowGreenLED+0x92>
		case 3:
			TCCR4B = BIT(CS42)|BIT(CS41);
    1478:	86 e0       	ldi	r24, 0x06	; 6
    147a:	80 93 c1 00 	sts	0x00C1, r24
		break;
    147e:	05 c0       	rjmp	.+10     	; 0x148a <GlowGreenLED+0x92>
		default:
			bit_set(TCCR4B,CS43);
    1480:	e1 ec       	ldi	r30, 0xC1	; 193
    1482:	f0 e0       	ldi	r31, 0x00	; 0
    1484:	80 81       	ld	r24, Z
    1486:	88 60       	ori	r24, 0x08	; 8
    1488:	80 83       	st	Z, r24
		break;
	}
		
		GlowDirection = BRIGHTEN;
    148a:	10 92 d4 06 	sts	0x06D4, r1
		TCNT4 = 0;//clear the timer to 0;}
    148e:	10 92 bf 00 	sts	0x00BF, r1
    1492:	10 92 be 00 	sts	0x00BE, r1

	sei();//enable interrupts again.
    1496:	78 94       	sei
    1498:	08 95       	ret

0000149a <__vector_41>:
}

ISR(TIMER4_OVF_vect){ //called each time timer1 counts up to the OCR1A register (every couple ms)
    149a:	1f 92       	push	r1
    149c:	0f 92       	push	r0
    149e:	0f b6       	in	r0, 0x3f	; 63
    14a0:	0f 92       	push	r0
    14a2:	11 24       	eor	r1, r1
    14a4:	8f 93       	push	r24
    14a6:	9f 93       	push	r25
    14a8:	ef 93       	push	r30
    14aa:	ff 93       	push	r31

	uint8_t temp;
	temp = OCR4A;
    14ac:	80 91 cf 00 	lds	r24, 0x00CF
	switch(GlowDirection){
    14b0:	90 91 d4 06 	lds	r25, 0x06D4
    14b4:	99 23       	and	r25, r25
    14b6:	19 f0       	breq	.+6      	; 0x14be <__vector_41+0x24>
    14b8:	92 30       	cpi	r25, 0x02	; 2
    14ba:	49 f0       	breq	.+18     	; 0x14ce <__vector_41+0x34>
    14bc:	0c c0       	rjmp	.+24     	; 0x14d6 <__vector_41+0x3c>
	case BRIGHTEN:
		if(temp==0xFF) GlowDirection = DIM;
    14be:	8f 3f       	cpi	r24, 0xFF	; 255
    14c0:	21 f4       	brne	.+8      	; 0x14ca <__vector_41+0x30>
    14c2:	91 e0       	ldi	r25, 0x01	; 1
    14c4:	90 93 d4 06 	sts	0x06D4, r25
    14c8:	12 c0       	rjmp	.+36     	; 0x14ee <__vector_41+0x54>
		else temp++;
    14ca:	8f 5f       	subi	r24, 0xFF	; 255
    14cc:	10 c0       	rjmp	.+32     	; 0x14ee <__vector_41+0x54>
	break;
	case BRIGHTEN_ONLY:
			if(temp!=0xFF) temp++;
    14ce:	8f 3f       	cpi	r24, 0xFF	; 255
    14d0:	71 f0       	breq	.+28     	; 0x14ee <__vector_41+0x54>
    14d2:	8f 5f       	subi	r24, 0xFF	; 255
    14d4:	0c c0       	rjmp	.+24     	; 0x14ee <__vector_41+0x54>
	break;
	case DIM:
	default:
		if(temp == 0x00){
    14d6:	81 11       	cpse	r24, r1
    14d8:	09 c0       	rjmp	.+18     	; 0x14ec <__vector_41+0x52>
			bit_clr(TCCR4A,COM4A0); //disconnect green led output pin
    14da:	e0 ec       	ldi	r30, 0xC0	; 192
    14dc:	f0 e0       	ldi	r31, 0x00	; 0
    14de:	90 81       	ld	r25, Z
    14e0:	9f 7b       	andi	r25, 0xBF	; 191
    14e2:	90 83       	st	Z, r25
			TCCR4B = 0;//clear the timer4 register (disable the timer);
    14e4:	10 92 c1 00 	sts	0x00C1, r1
			set_high(GREEN_LED); //turn off led
    14e8:	46 9a       	sbi	0x08, 6	; 8
    14ea:	01 c0       	rjmp	.+2      	; 0x14ee <__vector_41+0x54>
		}
		else{
			temp--;
    14ec:	81 50       	subi	r24, 0x01	; 1
		}
	break;
	}
	OCR4A = temp;
    14ee:	80 93 cf 00 	sts	0x00CF, r24
}
    14f2:	ff 91       	pop	r31
    14f4:	ef 91       	pop	r30
    14f6:	9f 91       	pop	r25
    14f8:	8f 91       	pop	r24
    14fa:	0f 90       	pop	r0
    14fc:	0f be       	out	0x3f, r0	; 63
    14fe:	0f 90       	pop	r0
    1500:	1f 90       	pop	r1
    1502:	18 95       	reti

00001504 <CALLBACK_USB_GetDescriptor>:
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
    1504:	29 2f       	mov	r18, r25
    1506:	33 27       	eor	r19, r19
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
    1508:	23 30       	cpi	r18, 0x03	; 3
    150a:	31 05       	cpc	r19, r1
    150c:	c9 f0       	breq	.+50     	; 0x1540 <CALLBACK_USB_GetDescriptor+0x3c>
    150e:	3c f4       	brge	.+14     	; 0x151e <CALLBACK_USB_GetDescriptor+0x1a>
    1510:	21 30       	cpi	r18, 0x01	; 1
    1512:	31 05       	cpc	r19, r1
    1514:	59 f0       	breq	.+22     	; 0x152c <CALLBACK_USB_GetDescriptor+0x28>
    1516:	22 30       	cpi	r18, 0x02	; 2
    1518:	31 05       	cpc	r19, r1
    151a:	69 f0       	breq	.+26     	; 0x1536 <CALLBACK_USB_GetDescriptor+0x32>
    151c:	36 c0       	rjmp	.+108    	; 0x158a <CALLBACK_USB_GetDescriptor+0x86>
    151e:	21 32       	cpi	r18, 0x21	; 33
    1520:	31 05       	cpc	r19, r1
    1522:	49 f1       	breq	.+82     	; 0x1576 <CALLBACK_USB_GetDescriptor+0x72>
    1524:	22 32       	cpi	r18, 0x22	; 34
    1526:	31 05       	cpc	r19, r1
    1528:	59 f1       	breq	.+86     	; 0x1580 <CALLBACK_USB_GetDescriptor+0x7c>
    152a:	2f c0       	rjmp	.+94     	; 0x158a <CALLBACK_USB_GetDescriptor+0x86>
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
    152c:	82 e1       	ldi	r24, 0x12	; 18
    152e:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
    1530:	29 e4       	ldi	r18, 0x49	; 73
    1532:	34 e0       	ldi	r19, 0x04	; 4
    1534:	33 c0       	rjmp	.+102    	; 0x159c <CALLBACK_USB_GetDescriptor+0x98>
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
    1536:	89 e3       	ldi	r24, 0x39	; 57
    1538:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
    153a:	20 e1       	ldi	r18, 0x10	; 16
    153c:	34 e0       	ldi	r19, 0x04	; 4
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
    153e:	2e c0       	rjmp	.+92     	; 0x159c <CALLBACK_USB_GetDescriptor+0x98>
    1540:	99 27       	eor	r25, r25
		case DTYPE_String:
			switch (DescriptorNumber)
    1542:	81 30       	cpi	r24, 0x01	; 1
    1544:	91 05       	cpc	r25, r1
    1546:	59 f0       	breq	.+22     	; 0x155e <CALLBACK_USB_GetDescriptor+0x5a>
    1548:	82 30       	cpi	r24, 0x02	; 2
    154a:	91 05       	cpc	r25, r1
    154c:	71 f0       	breq	.+28     	; 0x156a <CALLBACK_USB_GetDescriptor+0x66>
    154e:	89 2b       	or	r24, r25
    1550:	09 f5       	brne	.+66     	; 0x1594 <CALLBACK_USB_GetDescriptor+0x90>
			{
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
    1552:	ec e0       	ldi	r30, 0x0C	; 12
    1554:	f4 e0       	ldi	r31, 0x04	; 4
    1556:	84 91       	lpm	r24, Z
    1558:	90 e0       	ldi	r25, 0x00	; 0
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
			{
				case STRING_ID_Language:
					Address = &LanguageString;
    155a:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&LanguageString.Header.Size);
					break;
    155c:	1f c0       	rjmp	.+62     	; 0x159c <CALLBACK_USB_GetDescriptor+0x98>
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
    155e:	e4 ee       	ldi	r30, 0xE4	; 228
    1560:	f3 e0       	ldi	r31, 0x03	; 3
    1562:	84 91       	lpm	r24, Z
    1564:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Language:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
					break;
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
    1566:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
    1568:	19 c0       	rjmp	.+50     	; 0x159c <CALLBACK_USB_GetDescriptor+0x98>
				case STRING_ID_Product:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
    156a:	e2 eb       	ldi	r30, 0xB2	; 178
    156c:	f3 e0       	ldi	r31, 0x03	; 3
    156e:	84 91       	lpm	r24, Z
    1570:	90 e0       	ldi	r25, 0x00	; 0
				case STRING_ID_Manufacturer:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case STRING_ID_Product:
					Address = &ProductString;
    1572:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
    1574:	13 c0       	rjmp	.+38     	; 0x159c <CALLBACK_USB_GetDescriptor+0x98>
			}

			break;
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
    1576:	89 e0       	ldi	r24, 0x09	; 9
    1578:	90 e0       	ldi	r25, 0x00	; 0
					break;
			}

			break;
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
    157a:	29 e3       	ldi	r18, 0x39	; 57
    157c:	34 e0       	ldi	r19, 0x04	; 4
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
    157e:	0e c0       	rjmp	.+28     	; 0x159c <CALLBACK_USB_GetDescriptor+0x98>
		case HID_DTYPE_Report:
			Address = &KeyboardReport;
			Size    = sizeof(KeyboardReport);
    1580:	8f e3       	ldi	r24, 0x3F	; 63
    1582:	90 e0       	ldi	r25, 0x00	; 0
		case HID_DTYPE_HID:
			Address = &ConfigurationDescriptor.HID_KeyboardHID;
			Size    = sizeof(USB_HID_Descriptor_HID_t);
			break;
		case HID_DTYPE_Report:
			Address = &KeyboardReport;
    1584:	2b e5       	ldi	r18, 0x5B	; 91
    1586:	34 e0       	ldi	r19, 0x04	; 4
			Size    = sizeof(KeyboardReport);
			break;
    1588:	09 c0       	rjmp	.+18     	; 0x159c <CALLBACK_USB_GetDescriptor+0x98>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
    158a:	80 e0       	ldi	r24, 0x00	; 0
    158c:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
    158e:	20 e0       	ldi	r18, 0x00	; 0
    1590:	30 e0       	ldi	r19, 0x00	; 0
    1592:	04 c0       	rjmp	.+8      	; 0x159c <CALLBACK_USB_GetDescriptor+0x98>
	uint16_t    Size    = NO_DESCRIPTOR;
    1594:	80 e0       	ldi	r24, 0x00	; 0
    1596:	90 e0       	ldi	r25, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
    1598:	20 e0       	ldi	r18, 0x00	; 0
    159a:	30 e0       	ldi	r19, 0x00	; 0
			Address = &KeyboardReport;
			Size    = sizeof(KeyboardReport);
			break;
	}

	*DescriptorAddress = Address;
    159c:	fa 01       	movw	r30, r20
    159e:	31 83       	std	Z+1, r19	; 0x01
    15a0:	20 83       	st	Z, r18
	return Size;
}
    15a2:	08 95       	ret

000015a4 <OpenLogFile>:
			CloseLogFile(); // close log file so a new one can be opened later.
}

/** Opens the log file on the Dataflash's FAT formatted partition according to the current date */
FRESULT OpenLogFile(void)
{
    15a4:	cf 93       	push	r28
	
//	if (USB_DeviceState == DEVICE_STATE_Configured){
//		return FR_LOCKED; //the disk is locked if the USB is engaged.  This prevents collision with filesystem read/writes
//	}
	
		diskstatus = f_open(&LogFile, FileName, FA_OPEN_ALWAYS | FA_WRITE);
    15a6:	42 e1       	ldi	r20, 0x12	; 18
    15a8:	60 e0       	ldi	r22, 0x00	; 0
    15aa:	71 e0       	ldi	r23, 0x01	; 1
    15ac:	85 ed       	ldi	r24, 0xD5	; 213
    15ae:	93 e0       	ldi	r25, 0x03	; 3
    15b0:	0e 94 9f 1d 	call	0x3b3e	; 0x3b3e <f_open>
		f_sync(&LogFile);
    15b4:	85 ed       	ldi	r24, 0xD5	; 213
    15b6:	93 e0       	ldi	r25, 0x03	; 3
    15b8:	0e 94 54 20 	call	0x40a8	; 0x40a8 <f_sync>
		f_close(&LogFile);
    15bc:	85 ed       	ldi	r24, 0xD5	; 213
    15be:	93 e0       	ldi	r25, 0x03	; 3
    15c0:	0e 94 95 20 	call	0x412a	; 0x412a <f_close>
		diskstatus = f_open(&LogFile, FileName, FA_OPEN_ALWAYS | FA_WRITE);
    15c4:	42 e1       	ldi	r20, 0x12	; 18
    15c6:	60 e0       	ldi	r22, 0x00	; 0
    15c8:	71 e0       	ldi	r23, 0x01	; 1
    15ca:	85 ed       	ldi	r24, 0xD5	; 213
    15cc:	93 e0       	ldi	r25, 0x03	; 3
    15ce:	0e 94 9f 1d 	call	0x3b3e	; 0x3b3e <f_open>
    15d2:	c8 2f       	mov	r28, r24
		
		f_lseek(&LogFile, LogFile.fsize);
    15d4:	40 91 df 03 	lds	r20, 0x03DF
    15d8:	50 91 e0 03 	lds	r21, 0x03E0
    15dc:	60 91 e1 03 	lds	r22, 0x03E1
    15e0:	70 91 e2 03 	lds	r23, 0x03E2
    15e4:	85 ed       	ldi	r24, 0xD5	; 213
    15e6:	93 e0       	ldi	r25, 0x03	; 3
    15e8:	0e 94 a5 20 	call	0x414a	; 0x414a <f_lseek>
	
	return diskstatus;
}
    15ec:	8c 2f       	mov	r24, r28
    15ee:	cf 91       	pop	r28
    15f0:	08 95       	ret

000015f2 <CloseLogFile>:

/** Closes the open data log file on the Dataflash's FAT formatted partition */
void CloseLogFile(void)
{
	/* Sync any data waiting to be written, unmount the storage device */
	f_sync(&LogFile);
    15f2:	85 ed       	ldi	r24, 0xD5	; 213
    15f4:	93 e0       	ldi	r25, 0x03	; 3
    15f6:	0e 94 54 20 	call	0x40a8	; 0x40a8 <f_sync>
	f_close(&LogFile);
    15fa:	85 ed       	ldi	r24, 0xD5	; 213
    15fc:	93 e0       	ldi	r25, 0x03	; 3
    15fe:	0c 94 95 20 	jmp	0x412a	; 0x412a <f_close>
    1602:	08 95       	ret

00001604 <MountFilesystem>:
}

bool MountFilesystem(){
	bool diskstatus;
	diskstatus = f_mount(&DiskFATState,"",1);
    1604:	41 e0       	ldi	r20, 0x01	; 1
    1606:	69 e7       	ldi	r22, 0x79	; 121
    1608:	71 e0       	ldi	r23, 0x01	; 1
    160a:	85 ef       	ldi	r24, 0xF5	; 245
    160c:	93 e0       	ldi	r25, 0x03	; 3
    160e:	0e 94 4c 1d 	call	0x3a98	; 0x3a98 <f_mount>
    1612:	91 e0       	ldi	r25, 0x01	; 1
    1614:	81 11       	cpse	r24, r1
    1616:	01 c0       	rjmp	.+2      	; 0x161a <MountFilesystem+0x16>
    1618:	90 e0       	ldi	r25, 0x00	; 0
	return diskstatus;
}
    161a:	89 2f       	mov	r24, r25
    161c:	08 95       	ret

0000161e <get_num_of_sectors>:

uint32_t get_num_of_sectors(){
	static uint32_t tot_sect;
	if(!tot_sect){ //if we have not yet read a valid value into totsect
    161e:	80 91 d1 03 	lds	r24, 0x03D1
    1622:	90 91 d2 03 	lds	r25, 0x03D2
    1626:	a0 91 d3 03 	lds	r26, 0x03D3
    162a:	b0 91 d4 03 	lds	r27, 0x03D4
    162e:	89 2b       	or	r24, r25
    1630:	8a 2b       	or	r24, r26
    1632:	8b 2b       	or	r24, r27
    1634:	c1 f4       	brne	.+48     	; 0x1666 <get_num_of_sectors+0x48>
		tot_sect = (DiskFATState.n_fatent - 2) * DiskFATState.csize;
    1636:	e5 ef       	ldi	r30, 0xF5	; 245
    1638:	f3 e0       	ldi	r31, 0x03	; 3
    163a:	a2 81       	ldd	r26, Z+2	; 0x02
    163c:	42 89       	ldd	r20, Z+18	; 0x12
    163e:	53 89       	ldd	r21, Z+19	; 0x13
    1640:	64 89       	ldd	r22, Z+20	; 0x14
    1642:	75 89       	ldd	r23, Z+21	; 0x15
    1644:	9a 01       	movw	r18, r20
    1646:	ab 01       	movw	r20, r22
    1648:	22 50       	subi	r18, 0x02	; 2
    164a:	31 09       	sbc	r19, r1
    164c:	41 09       	sbc	r20, r1
    164e:	51 09       	sbc	r21, r1
    1650:	b0 e0       	ldi	r27, 0x00	; 0
    1652:	0e 94 29 39 	call	0x7252	; 0x7252 <__muluhisi3>
    1656:	60 93 d1 03 	sts	0x03D1, r22
    165a:	70 93 d2 03 	sts	0x03D2, r23
    165e:	80 93 d3 03 	sts	0x03D3, r24
    1662:	90 93 d4 03 	sts	0x03D4, r25
	}
	return 	tot_sect;
    1666:	60 91 d1 03 	lds	r22, 0x03D1
    166a:	70 91 d2 03 	lds	r23, 0x03D2
    166e:	80 91 d3 03 	lds	r24, 0x03D3
    1672:	90 91 d4 03 	lds	r25, 0x03D4
}
    1676:	08 95       	ret

00001678 <WriteToLogFile>:

bool WriteToLogFile(){
    1678:	ff 92       	push	r15
    167a:	0f 93       	push	r16
    167c:	1f 93       	push	r17
    167e:	cf 93       	push	r28
    1680:	df 93       	push	r29
    1682:	00 d0       	rcall	.+0      	; 0x1684 <WriteToLogFile+0xc>
    1684:	cd b7       	in	r28, 0x3d	; 61
    1686:	de b7       	in	r29, 0x3e	; 62
	UINT BytesWritten;
	uint8_t result;
	
	
	BytesWritten = strlen((char*)SD_Buffer);
    1688:	09 e2       	ldi	r16, 0x29	; 41
    168a:	18 e0       	ldi	r17, 0x08	; 8
    168c:	f8 01       	movw	r30, r16
    168e:	01 90       	ld	r0, Z+
    1690:	00 20       	and	r0, r0
    1692:	e9 f7       	brne	.-6      	; 0x168e <WriteToLogFile+0x16>
    1694:	31 97       	sbiw	r30, 0x01	; 1
    1696:	e9 52       	subi	r30, 0x29	; 41
    1698:	f8 40       	sbci	r31, 0x08	; 8
    169a:	fa 83       	std	Y+2, r31	; 0x02
    169c:	e9 83       	std	Y+1, r30	; 0x01
//	BytesWritten = sprintf(SD_Buffer, "TESTINGTESTING/r/n");//debug 
	f_lseek(&LogFile, LogFile.fsize);
    169e:	40 91 df 03 	lds	r20, 0x03DF
    16a2:	50 91 e0 03 	lds	r21, 0x03E0
    16a6:	60 91 e1 03 	lds	r22, 0x03E1
    16aa:	70 91 e2 03 	lds	r23, 0x03E2
    16ae:	85 ed       	ldi	r24, 0xD5	; 213
    16b0:	93 e0       	ldi	r25, 0x03	; 3
    16b2:	0e 94 a5 20 	call	0x414a	; 0x414a <f_lseek>
	result = f_write(&LogFile, (void *) SD_Buffer, BytesWritten, &BytesWritten);
    16b6:	49 81       	ldd	r20, Y+1	; 0x01
    16b8:	5a 81       	ldd	r21, Y+2	; 0x02
    16ba:	9e 01       	movw	r18, r28
    16bc:	2f 5f       	subi	r18, 0xFF	; 255
    16be:	3f 4f       	sbci	r19, 0xFF	; 255
    16c0:	b8 01       	movw	r22, r16
    16c2:	85 ed       	ldi	r24, 0xD5	; 213
    16c4:	93 e0       	ldi	r25, 0x03	; 3
    16c6:	0e 94 b9 1e 	call	0x3d72	; 0x3d72 <f_write>
    16ca:	f8 2e       	mov	r15, r24
	SD_Buffer[0] = '\0'; //a simple way to clear the buffer (equivalent to saving an empty string into the buffer)
    16cc:	f8 01       	movw	r30, r16
    16ce:	10 82       	st	Z, r1
	f_sync(&LogFile);
    16d0:	85 ed       	ldi	r24, 0xD5	; 213
    16d2:	93 e0       	ldi	r25, 0x03	; 3
    16d4:	0e 94 54 20 	call	0x40a8	; 0x40a8 <f_sync>
	
	return result;
    16d8:	81 e0       	ldi	r24, 0x01	; 1
    16da:	f1 10       	cpse	r15, r1
    16dc:	01 c0       	rjmp	.+2      	; 0x16e0 <WriteToLogFile+0x68>
    16de:	80 e0       	ldi	r24, 0x00	; 0
	
}
    16e0:	0f 90       	pop	r0
    16e2:	0f 90       	pop	r0
    16e4:	df 91       	pop	r29
    16e6:	cf 91       	pop	r28
    16e8:	1f 91       	pop	r17
    16ea:	0f 91       	pop	r16
    16ec:	ff 90       	pop	r15
    16ee:	08 95       	ret

000016f0 <TestSDHardware>:

void TestSDHardware(){
    16f0:	cf 93       	push	r28
		FRESULT diskstatus;
		
		diskstatus = MountFilesystem();
    16f2:	88 df       	rcall	.-240    	; 0x1604 <MountFilesystem>
		
		if (diskstatus != FR_OK){
    16f4:	88 23       	and	r24, r24
    16f6:	21 f0       	breq	.+8      	; 0x1700 <TestSDHardware+0x10>
			Typewriter_Mode = PANIC_MODE;
    16f8:	8a e0       	ldi	r24, 0x0A	; 10
    16fa:	80 93 28 08 	sts	0x0828, r24
    16fe:	20 c0       	rjmp	.+64     	; 0x1740 <TestSDHardware+0x50>
			return;
		}
		
		strcpy(FileName, "SDHW.TXT");
    1700:	89 e0       	ldi	r24, 0x09	; 9
    1702:	e5 ef       	ldi	r30, 0xF5	; 245
    1704:	f2 e0       	ldi	r31, 0x02	; 2
    1706:	a0 e0       	ldi	r26, 0x00	; 0
    1708:	b1 e0       	ldi	r27, 0x01	; 1
    170a:	01 90       	ld	r0, Z+
    170c:	0d 92       	st	X+, r0
    170e:	8a 95       	dec	r24
    1710:	e1 f7       	brne	.-8      	; 0x170a <TestSDHardware+0x1a>
		while(1){
		OpenLogFile();
		strcpy((CHAR*)SD_Buffer,"testphrase\n");
    1712:	cc e0       	ldi	r28, 0x0C	; 12
			return;
		}
		
		strcpy(FileName, "SDHW.TXT");
		while(1){
		OpenLogFile();
    1714:	47 df       	rcall	.-370    	; 0x15a4 <OpenLogFile>
		strcpy((CHAR*)SD_Buffer,"testphrase\n");
    1716:	ee ef       	ldi	r30, 0xFE	; 254
    1718:	f2 e0       	ldi	r31, 0x02	; 2
    171a:	a9 e2       	ldi	r26, 0x29	; 41
    171c:	b8 e0       	ldi	r27, 0x08	; 8
    171e:	8c 2f       	mov	r24, r28
    1720:	01 90       	ld	r0, Z+
    1722:	0d 92       	st	X+, r0
    1724:	8a 95       	dec	r24
    1726:	e1 f7       	brne	.-8      	; 0x1720 <TestSDHardware+0x30>
		WriteToLogFile();
    1728:	a7 df       	rcall	.-178    	; 0x1678 <WriteToLogFile>
		CloseLogFile();
    172a:	63 df       	rcall	.-314    	; 0x15f2 <CloseLogFile>
    172c:	2f ef       	ldi	r18, 0xFF	; 255
    172e:	80 e7       	ldi	r24, 0x70	; 112
    1730:	92 e0       	ldi	r25, 0x02	; 2
    1732:	21 50       	subi	r18, 0x01	; 1
    1734:	80 40       	sbci	r24, 0x00	; 0
    1736:	90 40       	sbci	r25, 0x00	; 0
    1738:	e1 f7       	brne	.-8      	; 0x1732 <TestSDHardware+0x42>
    173a:	00 c0       	rjmp	.+0      	; 0x173c <TestSDHardware+0x4c>
    173c:	00 00       	nop
    173e:	ea cf       	rjmp	.-44     	; 0x1714 <TestSDHardware+0x24>
		Delay_MS(100);
		}
		
}
    1740:	cf 91       	pop	r28
    1742:	08 95       	ret

00001744 <AddToSDBuffer>:

void AddToSDBuffer(char character){
	UINT index;
	static char prevcharacter;
	
	index = strlen((char*)SD_Buffer); //index is moved to the end of the string saved in the SD_Buffer.
    1744:	e9 e2       	ldi	r30, 0x29	; 41
    1746:	f8 e0       	ldi	r31, 0x08	; 8
    1748:	01 90       	ld	r0, Z+
    174a:	00 20       	and	r0, r0
    174c:	e9 f7       	brne	.-6      	; 0x1748 <AddToSDBuffer+0x4>
    174e:	31 97       	sbiw	r30, 0x01	; 1
    1750:	e9 52       	subi	r30, 0x29	; 41
    1752:	f8 40       	sbci	r31, 0x08	; 8
	if (index >= SD_BUFFER_LENGTH-10){
    1754:	e6 3f       	cpi	r30, 0xF6	; 246
    1756:	91 e0       	ldi	r25, 0x01	; 1
    1758:	f9 07       	cpc	r31, r25
    175a:	08 f0       	brcs	.+2      	; 0x175e <AddToSDBuffer+0x1a>
    175c:	4b c0       	rjmp	.+150    	; 0x17f4 <AddToSDBuffer+0xb0>
		return; //take no action if SD_Buffer is nearly full.  this could over-write other variables and cause a mess.
	}
	
	if (character == '\r'){ //special treatment for return character
    175e:	8d 30       	cpi	r24, 0x0D	; 13
    1760:	d1 f5       	brne	.+116    	; 0x17d6 <AddToSDBuffer+0x92>
		if(prevcharacter != '\r'){ //if this is first time \r is pressed, insert a space instead, and save to file.
    1762:	90 91 d0 03 	lds	r25, 0x03D0
    1766:	9d 30       	cpi	r25, 0x0D	; 13
    1768:	49 f0       	breq	.+18     	; 0x177c <AddToSDBuffer+0x38>
			SD_Buffer[index] = ' ';
    176a:	df 01       	movw	r26, r30
    176c:	a7 5d       	subi	r26, 0xD7	; 215
    176e:	b7 4f       	sbci	r27, 0xF7	; 247
    1770:	90 e2       	ldi	r25, 0x20	; 32
    1772:	9c 93       	st	X, r25
			SD_Buffer[index+1] = '\0';
    1774:	e6 5d       	subi	r30, 0xD6	; 214
    1776:	f7 4f       	sbci	r31, 0xF7	; 247
    1778:	10 82       	st	Z, r1
    177a:	3a c0       	rjmp	.+116    	; 0x17f0 <AddToSDBuffer+0xac>
		}
		else if (SD_Buffer[index-1] == ' '){//if a space was inserted last time in place of \r\n, user has pressed return twice.
    177c:	9f 01       	movw	r18, r30
    177e:	21 50       	subi	r18, 0x01	; 1
    1780:	31 09       	sbc	r19, r1
    1782:	d9 01       	movw	r26, r18
    1784:	a7 5d       	subi	r26, 0xD7	; 215
    1786:	b7 4f       	sbci	r27, 0xF7	; 247
    1788:	9c 91       	ld	r25, X
    178a:	90 32       	cpi	r25, 0x20	; 32
    178c:	b1 f4       	brne	.+44     	; 0x17ba <AddToSDBuffer+0x76>
			SD_Buffer[index-1] = '\r'; //so put the missing \r\n in now
    178e:	d9 01       	movw	r26, r18
    1790:	a7 5d       	subi	r26, 0xD7	; 215
    1792:	b7 4f       	sbci	r27, 0xF7	; 247
    1794:	4d e0       	ldi	r20, 0x0D	; 13
    1796:	4c 93       	st	X, r20
			SD_Buffer[index] = '\n';
    1798:	df 01       	movw	r26, r30
    179a:	a7 5d       	subi	r26, 0xD7	; 215
    179c:	b7 4f       	sbci	r27, 0xF7	; 247
    179e:	9a e0       	ldi	r25, 0x0A	; 10
    17a0:	9c 93       	st	X, r25
			SD_Buffer[index+1] = '\r';
    17a2:	df 01       	movw	r26, r30
    17a4:	a6 5d       	subi	r26, 0xD6	; 214
    17a6:	b7 4f       	sbci	r27, 0xF7	; 247
    17a8:	4c 93       	st	X, r20
			SD_Buffer[index+2] = '\n';
    17aa:	df 01       	movw	r26, r30
    17ac:	a5 5d       	subi	r26, 0xD5	; 213
    17ae:	b7 4f       	sbci	r27, 0xF7	; 247
    17b0:	9c 93       	st	X, r25
			SD_Buffer[index+3] = '\0';
    17b2:	e4 5d       	subi	r30, 0xD4	; 212
    17b4:	f7 4f       	sbci	r31, 0xF7	; 247
    17b6:	10 82       	st	Z, r1
    17b8:	1b c0       	rjmp	.+54     	; 0x17f0 <AddToSDBuffer+0xac>
		}
		else { //but if the last character entered was not recorded as a space (\r has already been pressed several times), then call a spade a spade.
			SD_Buffer[index] = '\r';
    17ba:	df 01       	movw	r26, r30
    17bc:	a7 5d       	subi	r26, 0xD7	; 215
    17be:	b7 4f       	sbci	r27, 0xF7	; 247
    17c0:	9d e0       	ldi	r25, 0x0D	; 13
    17c2:	9c 93       	st	X, r25
			SD_Buffer[index+1] = '\n';
    17c4:	df 01       	movw	r26, r30
    17c6:	a6 5d       	subi	r26, 0xD6	; 214
    17c8:	b7 4f       	sbci	r27, 0xF7	; 247
    17ca:	9a e0       	ldi	r25, 0x0A	; 10
    17cc:	9c 93       	st	X, r25
			SD_Buffer[index+2] = '\0';
    17ce:	e5 5d       	subi	r30, 0xD5	; 213
    17d0:	f7 4f       	sbci	r31, 0xF7	; 247
    17d2:	10 82       	st	Z, r1
    17d4:	0d c0       	rjmp	.+26     	; 0x17f0 <AddToSDBuffer+0xac>
		}
	}
	else if (character == '\b'){ //for a backspace character,
    17d6:	88 30       	cpi	r24, 0x08	; 8
    17d8:	21 f4       	brne	.+8      	; 0x17e2 <AddToSDBuffer+0x9e>
		SD_Buffer[index-1] = '\0'; //turn the previous character into an "end of string" character 
    17da:	e8 5d       	subi	r30, 0xD8	; 216
    17dc:	f7 4f       	sbci	r31, 0xF7	; 247
    17de:	10 82       	st	Z, r1
    17e0:	07 c0       	rjmp	.+14     	; 0x17f0 <AddToSDBuffer+0xac>
	}
	else{ //the most common scenario -- put a character at the end of the buffer, then follow with a \0;
		SD_Buffer[index] = character;
    17e2:	df 01       	movw	r26, r30
    17e4:	a7 5d       	subi	r26, 0xD7	; 215
    17e6:	b7 4f       	sbci	r27, 0xF7	; 247
    17e8:	8c 93       	st	X, r24
		SD_Buffer[index+1] = '\0';
    17ea:	e6 5d       	subi	r30, 0xD6	; 214
    17ec:	f7 4f       	sbci	r31, 0xF7	; 247
    17ee:	10 82       	st	Z, r1
	}
	
	prevcharacter = character; // save the character just pressed.
    17f0:	80 93 d0 03 	sts	0x03D0, r24
    17f4:	08 95       	ret

000017f6 <LogKeystrokes>:
static FATFS DiskFATState;

/** FAT Fs structure to hold a FAT file handle for the log data write destination. */
static FIL LogFile;

void LogKeystrokes(){
    17f6:	cf 92       	push	r12
    17f8:	df 92       	push	r13
    17fa:	ef 92       	push	r14
    17fc:	ff 92       	push	r15
    17fe:	0f 93       	push	r16
    1800:	1f 93       	push	r17
    1802:	cf 93       	push	r28
    1804:	df 93       	push	r29
    1806:	cd b7       	in	r28, 0x3d	; 61
    1808:	de b7       	in	r29, 0x3e	; 62
    180a:	66 97       	sbiw	r28, 0x16	; 22
    180c:	0f b6       	in	r0, 0x3f	; 63
    180e:	f8 94       	cli
    1810:	de bf       	out	0x3e, r29	; 62
    1812:	0f be       	out	0x3f, r0	; 63
    1814:	cd bf       	out	0x3d, r28	; 61
	uint16_t filenum;
	uint8_t code = 0;
	uint8_t modifier;
	uint8_t key;
	
	SD_Buffer[0] = '\0'; // A simple way to erase the SD_Buffer string -- first character is now the end of the string;
    1816:	10 92 29 08 	sts	0x0829, r1

	diskstatus = MountFilesystem();
    181a:	f4 de       	rcall	.-536    	; 0x1604 <MountFilesystem>
	
	if (diskstatus != FR_OK){
    181c:	88 23       	and	r24, r24
    181e:	21 f0       	breq	.+8      	; 0x1828 <LogKeystrokes+0x32>
		Typewriter_Mode = PANIC_MODE;
    1820:	8a e0       	ldi	r24, 0x0A	; 10
    1822:	80 93 28 08 	sts	0x0828, r24
		return;
    1826:	bb c0       	rjmp	.+374    	; 0x199e <LogKeystrokes+0x1a8>
	}
	else{
		GlowGreenLED(VERY_SLOW,SOLID);
    1828:	61 e0       	ldi	r22, 0x01	; 1
    182a:	80 e0       	ldi	r24, 0x00	; 0
    182c:	e5 dd       	rcall	.-1078   	; 0x13f8 <GlowGreenLED>
	}
	
	filenum = eeprom_read_word((uint16_t *)FILENUM_ADDR); //filenum is the last used filenum, plus 1;
    182e:	8a e0       	ldi	r24, 0x0A	; 10
    1830:	92 e0       	ldi	r25, 0x02	; 2
    1832:	0e 94 b7 3c 	call	0x796e	; 0x796e <eeprom_read_word>
    1836:	8c 01       	movw	r16, r24
	
	if (filenum>9999){
    1838:	80 31       	cpi	r24, 0x10	; 16
    183a:	97 42       	sbci	r25, 0x27	; 39
    183c:	10 f0       	brcs	.+4      	; 0x1842 <LogKeystrokes+0x4c>
		filenum = 0;
    183e:	00 e0       	ldi	r16, 0x00	; 0
    1840:	10 e0       	ldi	r17, 0x00	; 0
	} //filenum can only be 4 digits long.

	do{ //increment filenum until a file name is found that does not already exist ("no file" error)
		filenum++; //increment file number
		sprintf(FileName,"PAGE%04d.TXT",filenum); //filename can only be 8 characters long (not including .TXT).
    1842:	0f 2e       	mov	r0, r31
    1844:	fa e0       	ldi	r31, 0x0A	; 10
    1846:	cf 2e       	mov	r12, r31
    1848:	f3 e0       	ldi	r31, 0x03	; 3
    184a:	df 2e       	mov	r13, r31
    184c:	f0 2d       	mov	r31, r0
    184e:	0f 2e       	mov	r0, r31
    1850:	f0 e0       	ldi	r31, 0x00	; 0
    1852:	ef 2e       	mov	r14, r31
    1854:	f1 e0       	ldi	r31, 0x01	; 1
    1856:	ff 2e       	mov	r15, r31
    1858:	f0 2d       	mov	r31, r0
	if (filenum>9999){
		filenum = 0;
	} //filenum can only be 4 digits long.

	do{ //increment filenum until a file name is found that does not already exist ("no file" error)
		filenum++; //increment file number
    185a:	0f 5f       	subi	r16, 0xFF	; 255
    185c:	1f 4f       	sbci	r17, 0xFF	; 255
		sprintf(FileName,"PAGE%04d.TXT",filenum); //filename can only be 8 characters long (not including .TXT).
    185e:	1f 93       	push	r17
    1860:	0f 93       	push	r16
    1862:	df 92       	push	r13
    1864:	cf 92       	push	r12
    1866:	ff 92       	push	r15
    1868:	ef 92       	push	r14
    186a:	0e 94 10 3a 	call	0x7420	; 0x7420 <sprintf>
		filestatus = f_stat(FileName, &fileinfo);
    186e:	be 01       	movw	r22, r28
    1870:	6f 5f       	subi	r22, 0xFF	; 255
    1872:	7f 4f       	sbci	r23, 0xFF	; 255
    1874:	c7 01       	movw	r24, r14
    1876:	0e 94 5c 22 	call	0x44b8	; 0x44b8 <f_stat>
	}while(filestatus == FR_OK); //at the end of this loop, FileName is unique
    187a:	0f 90       	pop	r0
    187c:	0f 90       	pop	r0
    187e:	0f 90       	pop	r0
    1880:	0f 90       	pop	r0
    1882:	0f 90       	pop	r0
    1884:	0f 90       	pop	r0
    1886:	88 23       	and	r24, r24
    1888:	41 f3       	breq	.-48     	; 0x185a <LogKeystrokes+0x64>
	
	if (filestatus != FR_NO_FILE){ //if the error was not "no file" something went wrong
    188a:	84 30       	cpi	r24, 0x04	; 4
    188c:	21 f0       	breq	.+8      	; 0x1896 <LogKeystrokes+0xa0>
		Typewriter_Mode = PANIC_MODE; // go into panic mode
    188e:	8a e0       	ldi	r24, 0x0A	; 10
    1890:	80 93 28 08 	sts	0x0828, r24
		return;
    1894:	84 c0       	rjmp	.+264    	; 0x199e <LogKeystrokes+0x1a8>
	}
	
	while(!code){ // wait for a key to be pressed before actually opening the file -- this stops lots of empty files from being created
		key = GetKey();
    1896:	0e 94 cb 2b 	call	0x5796	; 0x5796 <GetKey>
    189a:	f8 2e       	mov	r15, r24
		modifier = GetModifier();
    189c:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
		code = GetASCIIKeyCode(key,modifier);
    18a0:	68 2f       	mov	r22, r24
    18a2:	8f 2d       	mov	r24, r15
    18a4:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <GetASCIIKeyCode>
	if (filestatus != FR_NO_FILE){ //if the error was not "no file" something went wrong
		Typewriter_Mode = PANIC_MODE; // go into panic mode
		return;
	}
	
	while(!code){ // wait for a key to be pressed before actually opening the file -- this stops lots of empty files from being created
    18a8:	88 23       	and	r24, r24
    18aa:	a9 f3       	breq	.-22     	; 0x1896 <LogKeystrokes+0xa0>
		key = GetKey();
		modifier = GetModifier();
		code = GetASCIIKeyCode(key,modifier);
	}
	
	AddToSDBuffer(code); //save this first key pressed to the buffer.  there will be more, and those will be handled in the main loop
    18ac:	4b df       	rcall	.-362    	; 0x1744 <AddToSDBuffer>

	if (OpenLogFile()!=FR_OK){ //open the new log file.
    18ae:	7a de       	rcall	.-780    	; 0x15a4 <OpenLogFile>
    18b0:	88 23       	and	r24, r24
    18b2:	21 f0       	breq	.+8      	; 0x18bc <LogKeystrokes+0xc6>
		Typewriter_Mode = PANIC_MODE; // go into panic mode
    18b4:	8a e0       	ldi	r24, 0x0A	; 10
    18b6:	80 93 28 08 	sts	0x0828, r24
		return;
    18ba:	71 c0       	rjmp	.+226    	; 0x199e <LogKeystrokes+0x1a8>
	}
	
	eeprom_write_word((uint16_t *)FILENUM_ADDR,filenum); // save the new filenumber for next time
    18bc:	b8 01       	movw	r22, r16
    18be:	8a e0       	ldi	r24, 0x0A	; 10
    18c0:	92 e0       	ldi	r25, 0x02	; 2
    18c2:	0e 94 e5 3c 	call	0x79ca	; 0x79ca <eeprom_write_word>
	
	TimeoutCounter = 0; //reset timeout
    18c6:	10 92 27 08 	sts	0x0827, r1
    18ca:	10 92 26 08 	sts	0x0826, r1
				GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
				WriteToLogFile(); //save your work every time enter key is pressed.
			}
			Delay_MS(SENSE_DELAY);
			
			if ((TimeoutCounter > SD_SAVE_TIME) && (SD_Buffer[0] != '\0')){
    18ce:	0f 2e       	mov	r0, r31
    18d0:	f9 e2       	ldi	r31, 0x29	; 41
    18d2:	ef 2e       	mov	r14, r31
    18d4:	f8 e0       	ldi	r31, 0x08	; 8
    18d6:	ff 2e       	mov	r15, r31
    18d8:	f0 2d       	mov	r31, r0
	
	eeprom_write_word((uint16_t *)FILENUM_ADDR,filenum); // save the new filenumber for next time
	
	TimeoutCounter = 0; //reset timeout

	while(TimeoutCounter < (SD_TIMEOUT)){ //keep listening for keys and adding them to buffer. Clear buffer occassionally.
    18da:	49 c0       	rjmp	.+146    	; 0x196e <LogKeystrokes+0x178>
			key = GetKey();
    18dc:	0e 94 cb 2b 	call	0x5796	; 0x5796 <GetKey>
    18e0:	18 2f       	mov	r17, r24
			modifier = GetModifier();
    18e2:	0e 94 98 2a 	call	0x5530	; 0x5530 <GetModifier>
			
			code = GetASCIIKeyCode(key, modifier);
    18e6:	68 2f       	mov	r22, r24
    18e8:	81 2f       	mov	r24, r17
    18ea:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <GetASCIIKeyCode>
    18ee:	18 2f       	mov	r17, r24
			
			if(code){
    18f0:	88 23       	and	r24, r24
    18f2:	01 f1       	breq	.+64     	; 0x1934 <LogKeystrokes+0x13e>
				if ((code == 's') && Ignore_Flag) code = 0; //if user is holding down S on startup, don't add this to file.
    18f4:	83 37       	cpi	r24, 0x73	; 115
    18f6:	29 f4       	brne	.+10     	; 0x1902 <LogKeystrokes+0x10c>
    18f8:	80 91 21 07 	lds	r24, 0x0721
    18fc:	81 11       	cpse	r24, r1
    18fe:	45 c0       	rjmp	.+138    	; 0x198a <LogKeystrokes+0x194>
    1900:	45 c0       	rjmp	.+138    	; 0x198c <LogKeystrokes+0x196>
				Ignore_Flag = 0;
    1902:	10 92 21 07 	sts	0x0721, r1
				AddToSDBuffer(code); //this adds the character to the sd write buffer.
    1906:	1e df       	rcall	.-452    	; 0x1744 <AddToSDBuffer>
				TimeoutCounter = 0; //reset timeout every time a key is pressed.
    1908:	10 92 27 08 	sts	0x0827, r1
    190c:	10 92 26 08 	sts	0x0826, r1
			}
			if((code == '\r')||(code == '.')||(code == ',')||(code == '!')||(code == '?')||(code == ':')||(code == '\"')){
    1910:	1d 30       	cpi	r17, 0x0D	; 13
    1912:	61 f0       	breq	.+24     	; 0x192c <LogKeystrokes+0x136>
    1914:	81 2f       	mov	r24, r17
    1916:	8d 7f       	andi	r24, 0xFD	; 253
    1918:	8c 32       	cpi	r24, 0x2C	; 44
    191a:	41 f0       	breq	.+16     	; 0x192c <LogKeystrokes+0x136>
    191c:	8f ed       	ldi	r24, 0xDF	; 223
    191e:	81 0f       	add	r24, r17
    1920:	82 30       	cpi	r24, 0x02	; 2
    1922:	20 f0       	brcs	.+8      	; 0x192c <LogKeystrokes+0x136>
    1924:	1f 33       	cpi	r17, 0x3F	; 63
    1926:	11 f0       	breq	.+4      	; 0x192c <LogKeystrokes+0x136>
    1928:	1a 33       	cpi	r17, 0x3A	; 58
    192a:	21 f4       	brne	.+8      	; 0x1934 <LogKeystrokes+0x13e>
				GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
    192c:	60 e0       	ldi	r22, 0x00	; 0
    192e:	82 e0       	ldi	r24, 0x02	; 2
    1930:	63 dd       	rcall	.-1338   	; 0x13f8 <GlowGreenLED>
				WriteToLogFile(); //save your work every time enter key is pressed.
    1932:	a2 de       	rcall	.-700    	; 0x1678 <WriteToLogFile>
    1934:	8f ec       	ldi	r24, 0xCF	; 207
    1936:	97 e0       	ldi	r25, 0x07	; 7
    1938:	01 97       	sbiw	r24, 0x01	; 1
    193a:	f1 f7       	brne	.-4      	; 0x1938 <LogKeystrokes+0x142>
    193c:	00 c0       	rjmp	.+0      	; 0x193e <LogKeystrokes+0x148>
    193e:	00 00       	nop
			}
			Delay_MS(SENSE_DELAY);
			
			if ((TimeoutCounter > SD_SAVE_TIME) && (SD_Buffer[0] != '\0')){
    1940:	80 91 26 08 	lds	r24, 0x0826
    1944:	90 91 27 08 	lds	r25, 0x0827
    1948:	81 37       	cpi	r24, 0x71	; 113
    194a:	97 41       	sbci	r25, 0x17	; 23
    194c:	80 f0       	brcs	.+32     	; 0x196e <LogKeystrokes+0x178>
    194e:	f7 01       	movw	r30, r14
    1950:	80 81       	ld	r24, Z
    1952:	88 23       	and	r24, r24
    1954:	61 f0       	breq	.+24     	; 0x196e <LogKeystrokes+0x178>
				set_low(GREEN_LED);
    1956:	46 98       	cbi	0x08, 6	; 8
    1958:	ff ef       	ldi	r31, 0xFF	; 255
    195a:	2d e3       	ldi	r18, 0x3D	; 61
    195c:	89 e4       	ldi	r24, 0x49	; 73
    195e:	f1 50       	subi	r31, 0x01	; 1
    1960:	20 40       	sbci	r18, 0x00	; 0
    1962:	80 40       	sbci	r24, 0x00	; 0
    1964:	e1 f7       	brne	.-8      	; 0x195e <LogKeystrokes+0x168>
    1966:	00 c0       	rjmp	.+0      	; 0x1968 <LogKeystrokes+0x172>
    1968:	00 00       	nop
				Delay_MS(3000);
				WriteToLogFile();
    196a:	86 de       	rcall	.-756    	; 0x1678 <WriteToLogFile>
				set_high(GREEN_LED);
    196c:	46 9a       	sbi	0x08, 6	; 8
	
	eeprom_write_word((uint16_t *)FILENUM_ADDR,filenum); // save the new filenumber for next time
	
	TimeoutCounter = 0; //reset timeout

	while(TimeoutCounter < (SD_TIMEOUT)){ //keep listening for keys and adding them to buffer. Clear buffer occassionally.
    196e:	80 91 26 08 	lds	r24, 0x0826
    1972:	90 91 27 08 	lds	r25, 0x0827
    1976:	80 32       	cpi	r24, 0x20	; 32
    1978:	9f 4b       	sbci	r25, 0xBF	; 191
    197a:	08 f4       	brcc	.+2      	; 0x197e <LogKeystrokes+0x188>
    197c:	af cf       	rjmp	.-162    	; 0x18dc <LogKeystrokes+0xe6>
				WriteToLogFile();
				set_high(GREEN_LED);
			}
	}
	
			GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
    197e:	60 e0       	ldi	r22, 0x00	; 0
    1980:	82 e0       	ldi	r24, 0x02	; 2
    1982:	3a dd       	rcall	.-1420   	; 0x13f8 <GlowGreenLED>
			WriteToLogFile(); //save your work then "sleep" -- stop recording keystrokes
    1984:	79 de       	rcall	.-782    	; 0x1678 <WriteToLogFile>
			CloseLogFile(); // close log file so a new one can be opened later.
    1986:	35 de       	rcall	.-918    	; 0x15f2 <CloseLogFile>
    1988:	0a c0       	rjmp	.+20     	; 0x199e <LogKeystrokes+0x1a8>
			modifier = GetModifier();
			
			code = GetASCIIKeyCode(key, modifier);
			
			if(code){
				if ((code == 's') && Ignore_Flag) code = 0; //if user is holding down S on startup, don't add this to file.
    198a:	10 e0       	ldi	r17, 0x00	; 0
				Ignore_Flag = 0;
    198c:	10 92 21 07 	sts	0x0721, r1
				AddToSDBuffer(code); //this adds the character to the sd write buffer.
    1990:	81 2f       	mov	r24, r17
    1992:	d8 de       	rcall	.-592    	; 0x1744 <AddToSDBuffer>
				TimeoutCounter = 0; //reset timeout every time a key is pressed.
    1994:	10 92 27 08 	sts	0x0827, r1
    1998:	10 92 26 08 	sts	0x0826, r1
    199c:	bb cf       	rjmp	.-138    	; 0x1914 <LogKeystrokes+0x11e>
	}
	
			GlowGreenLED(MEDIUM, GLOWING);//glow a green led to indicate write in progress.
			WriteToLogFile(); //save your work then "sleep" -- stop recording keystrokes
			CloseLogFile(); // close log file so a new one can be opened later.
}
    199e:	66 96       	adiw	r28, 0x16	; 22
    19a0:	0f b6       	in	r0, 0x3f	; 63
    19a2:	f8 94       	cli
    19a4:	de bf       	out	0x3e, r29	; 62
    19a6:	0f be       	out	0x3f, r0	; 63
    19a8:	cd bf       	out	0x3d, r28	; 61
    19aa:	df 91       	pop	r29
    19ac:	cf 91       	pop	r28
    19ae:	1f 91       	pop	r17
    19b0:	0f 91       	pop	r16
    19b2:	ff 90       	pop	r15
    19b4:	ef 90       	pop	r14
    19b6:	df 90       	pop	r13
    19b8:	cf 90       	pop	r12
    19ba:	08 95       	ret

000019bc <dly_us>:

static
void dly_us (UINT n)	/* Delay n microseconds (avr-gcc -Os) */
{
	do {
		PINB;
    19bc:	23 b1       	in	r18, 0x03	; 3
		PINB;
    19be:	23 b1       	in	r18, 0x03	; 3
		 //PINB is a throwaway command that wastes one op cycle.  1 PINB commands is recommended for 8MHZ clock.  We can lengthen this or randomize this for EMC reasons.
	} while (--n);
    19c0:	01 97       	sbiw	r24, 0x01	; 1
    19c2:	e1 f7       	brne	.-8      	; 0x19bc <dly_us>
}
    19c4:	08 95       	ret

000019c6 <xmit_mmc>:
static
void xmit_mmc (
	const BYTE* buff,	/* Data to be sent */
	UINT bc				/* Number of bytes to send */
)
{
    19c6:	fc 01       	movw	r30, r24
    19c8:	68 0f       	add	r22, r24
    19ca:	79 1f       	adc	r23, r25
	BYTE d;


	do {
		d = *buff++;	/* Get a byte to be sent */
    19cc:	91 91       	ld	r25, Z+
		if (d & 0x80) DI_H(); else DI_L();	/* bit7 */
    19ce:	99 23       	and	r25, r25
    19d0:	14 f4       	brge	.+4      	; 0x19d6 <xmit_mmc+0x10>
    19d2:	2a 9a       	sbi	0x05, 2	; 5
    19d4:	01 c0       	rjmp	.+2      	; 0x19d8 <xmit_mmc+0x12>
    19d6:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    19d8:	29 9a       	sbi	0x05, 1	; 5
    19da:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x40) DI_H(); else DI_L();	/* bit6 */
    19dc:	96 ff       	sbrs	r25, 6
    19de:	02 c0       	rjmp	.+4      	; 0x19e4 <xmit_mmc+0x1e>
    19e0:	2a 9a       	sbi	0x05, 2	; 5
    19e2:	01 c0       	rjmp	.+2      	; 0x19e6 <xmit_mmc+0x20>
    19e4:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    19e6:	29 9a       	sbi	0x05, 1	; 5
    19e8:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x20) DI_H(); else DI_L();	/* bit5 */
    19ea:	95 ff       	sbrs	r25, 5
    19ec:	02 c0       	rjmp	.+4      	; 0x19f2 <xmit_mmc+0x2c>
    19ee:	2a 9a       	sbi	0x05, 2	; 5
    19f0:	01 c0       	rjmp	.+2      	; 0x19f4 <xmit_mmc+0x2e>
    19f2:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    19f4:	29 9a       	sbi	0x05, 1	; 5
    19f6:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x10) DI_H(); else DI_L();	/* bit4 */
    19f8:	94 ff       	sbrs	r25, 4
    19fa:	02 c0       	rjmp	.+4      	; 0x1a00 <xmit_mmc+0x3a>
    19fc:	2a 9a       	sbi	0x05, 2	; 5
    19fe:	01 c0       	rjmp	.+2      	; 0x1a02 <xmit_mmc+0x3c>
    1a00:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1a02:	29 9a       	sbi	0x05, 1	; 5
    1a04:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x08) DI_H(); else DI_L();	/* bit3 */
    1a06:	93 ff       	sbrs	r25, 3
    1a08:	02 c0       	rjmp	.+4      	; 0x1a0e <xmit_mmc+0x48>
    1a0a:	2a 9a       	sbi	0x05, 2	; 5
    1a0c:	01 c0       	rjmp	.+2      	; 0x1a10 <xmit_mmc+0x4a>
    1a0e:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1a10:	29 9a       	sbi	0x05, 1	; 5
    1a12:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x04) DI_H(); else DI_L();	/* bit2 */
    1a14:	92 ff       	sbrs	r25, 2
    1a16:	02 c0       	rjmp	.+4      	; 0x1a1c <xmit_mmc+0x56>
    1a18:	2a 9a       	sbi	0x05, 2	; 5
    1a1a:	01 c0       	rjmp	.+2      	; 0x1a1e <xmit_mmc+0x58>
    1a1c:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1a1e:	29 9a       	sbi	0x05, 1	; 5
    1a20:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x02) DI_H(); else DI_L();	/* bit1 */
    1a22:	91 ff       	sbrs	r25, 1
    1a24:	02 c0       	rjmp	.+4      	; 0x1a2a <xmit_mmc+0x64>
    1a26:	2a 9a       	sbi	0x05, 2	; 5
    1a28:	01 c0       	rjmp	.+2      	; 0x1a2c <xmit_mmc+0x66>
    1a2a:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1a2c:	29 9a       	sbi	0x05, 1	; 5
    1a2e:	29 98       	cbi	0x05, 1	; 5
		if (d & 0x01) DI_H(); else DI_L();	/* bit0 */
    1a30:	90 ff       	sbrs	r25, 0
    1a32:	02 c0       	rjmp	.+4      	; 0x1a38 <xmit_mmc+0x72>
    1a34:	2a 9a       	sbi	0x05, 2	; 5
    1a36:	01 c0       	rjmp	.+2      	; 0x1a3a <xmit_mmc+0x74>
    1a38:	2a 98       	cbi	0x05, 2	; 5
		CK_H(); CK_L();
    1a3a:	29 9a       	sbi	0x05, 1	; 5
    1a3c:	29 98       	cbi	0x05, 1	; 5
	} while (--bc);
    1a3e:	e6 17       	cp	r30, r22
    1a40:	f7 07       	cpc	r31, r23
    1a42:	21 f6       	brne	.-120    	; 0x19cc <xmit_mmc+0x6>
}
    1a44:	08 95       	ret

00001a46 <rcvr_mmc>:
)
{
	BYTE r;


	DI_H();	/* Send 0xFF */
    1a46:	2a 9a       	sbi	0x05, 2	; 5
    1a48:	fc 01       	movw	r30, r24
    1a4a:	68 0f       	add	r22, r24
    1a4c:	79 1f       	adc	r23, r25

	do {
		r = 0;	 if (DO) r++;	/* bit7 */
    1a4e:	93 b1       	in	r25, 0x03	; 3
		CK_H(); CK_L();
    1a50:	29 9a       	sbi	0x05, 1	; 5
    1a52:	29 98       	cbi	0x05, 1	; 5


	DI_H();	/* Send 0xFF */

	do {
		r = 0;	 if (DO) r++;	/* bit7 */
    1a54:	93 fb       	bst	r25, 3
    1a56:	99 27       	eor	r25, r25
    1a58:	90 f9       	bld	r25, 0
		CK_H(); CK_L();
		r <<= 1; if (DO) r++;	/* bit6 */
    1a5a:	99 0f       	add	r25, r25
    1a5c:	1b 99       	sbic	0x03, 3	; 3
    1a5e:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a60:	29 9a       	sbi	0x05, 1	; 5
    1a62:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit5 */
    1a64:	99 0f       	add	r25, r25
    1a66:	1b 99       	sbic	0x03, 3	; 3
    1a68:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a6a:	29 9a       	sbi	0x05, 1	; 5
    1a6c:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit4 */
    1a6e:	99 0f       	add	r25, r25
    1a70:	1b 99       	sbic	0x03, 3	; 3
    1a72:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a74:	29 9a       	sbi	0x05, 1	; 5
    1a76:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit3 */
    1a78:	99 0f       	add	r25, r25
    1a7a:	1b 99       	sbic	0x03, 3	; 3
    1a7c:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a7e:	29 9a       	sbi	0x05, 1	; 5
    1a80:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit2 */
    1a82:	99 0f       	add	r25, r25
    1a84:	1b 99       	sbic	0x03, 3	; 3
    1a86:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a88:	29 9a       	sbi	0x05, 1	; 5
    1a8a:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit1 */
    1a8c:	99 0f       	add	r25, r25
    1a8e:	1b 99       	sbic	0x03, 3	; 3
    1a90:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a92:	29 9a       	sbi	0x05, 1	; 5
    1a94:	29 98       	cbi	0x05, 1	; 5
		r <<= 1; if (DO) r++;	/* bit0 */
    1a96:	99 0f       	add	r25, r25
    1a98:	1b 99       	sbic	0x03, 3	; 3
    1a9a:	9f 5f       	subi	r25, 0xFF	; 255
		CK_H(); CK_L();
    1a9c:	29 9a       	sbi	0x05, 1	; 5
    1a9e:	29 98       	cbi	0x05, 1	; 5
		*buff++ = r;			/* Store a received byte */
    1aa0:	91 93       	st	Z+, r25
	} while (--bc);
    1aa2:	e6 17       	cp	r30, r22
    1aa4:	f7 07       	cpc	r31, r23
    1aa6:	99 f6       	brne	.-90     	; 0x1a4e <rcvr_mmc+0x8>
}
    1aa8:	08 95       	ret

00001aaa <wait_ready>:
/* Wait for card ready                                                   */
/*-----------------------------------------------------------------------*/

static
int wait_ready (void)	/* 1:OK, 0:Timeout */
{
    1aaa:	0f 93       	push	r16
    1aac:	1f 93       	push	r17
    1aae:	cf 93       	push	r28
    1ab0:	df 93       	push	r29
    1ab2:	1f 92       	push	r1
    1ab4:	cd b7       	in	r28, 0x3d	; 61
    1ab6:	de b7       	in	r29, 0x3e	; 62
	BYTE d;
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
    1ab8:	08 e8       	ldi	r16, 0x88	; 136
    1aba:	13 e1       	ldi	r17, 0x13	; 19
		rcvr_mmc(&d, 1);
    1abc:	61 e0       	ldi	r22, 0x01	; 1
    1abe:	70 e0       	ldi	r23, 0x00	; 0
    1ac0:	ce 01       	movw	r24, r28
    1ac2:	01 96       	adiw	r24, 0x01	; 1
    1ac4:	c0 df       	rcall	.-128    	; 0x1a46 <rcvr_mmc>
		if (d == 0xFF) break;
    1ac6:	89 81       	ldd	r24, Y+1	; 0x01
    1ac8:	8f 3f       	cpi	r24, 0xFF	; 255
    1aca:	31 f0       	breq	.+12     	; 0x1ad8 <wait_ready+0x2e>
		dly_us(100);
    1acc:	84 e6       	ldi	r24, 0x64	; 100
    1ace:	90 e0       	ldi	r25, 0x00	; 0
    1ad0:	75 df       	rcall	.-278    	; 0x19bc <dly_us>
{
	BYTE d;
	UINT tmr;


	for (tmr = 5000; tmr; tmr--) {	/* Wait for ready in timeout of 500ms */
    1ad2:	01 50       	subi	r16, 0x01	; 1
    1ad4:	11 09       	sbc	r17, r1
    1ad6:	91 f7       	brne	.-28     	; 0x1abc <wait_ready+0x12>
		rcvr_mmc(&d, 1);
		if (d == 0xFF) break;
		dly_us(100);
	}

	return tmr ? 1 : 0;
    1ad8:	81 e0       	ldi	r24, 0x01	; 1
    1ada:	90 e0       	ldi	r25, 0x00	; 0
    1adc:	01 2b       	or	r16, r17
    1ade:	11 f4       	brne	.+4      	; 0x1ae4 <wait_ready+0x3a>
    1ae0:	80 e0       	ldi	r24, 0x00	; 0
    1ae2:	90 e0       	ldi	r25, 0x00	; 0
}
    1ae4:	0f 90       	pop	r0
    1ae6:	df 91       	pop	r29
    1ae8:	cf 91       	pop	r28
    1aea:	1f 91       	pop	r17
    1aec:	0f 91       	pop	r16
    1aee:	08 95       	ret

00001af0 <deselect>:
/* Deselect the card and release SPI bus                                 */
/*-----------------------------------------------------------------------*/

static
void deselect (void)
{
    1af0:	cf 93       	push	r28
    1af2:	df 93       	push	r29
    1af4:	1f 92       	push	r1
    1af6:	cd b7       	in	r28, 0x3d	; 61
    1af8:	de b7       	in	r29, 0x3e	; 62
	BYTE d;

	CS_H();
    1afa:	59 9a       	sbi	0x0b, 1	; 11
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO hi-z for multiple slave SPI) */
    1afc:	61 e0       	ldi	r22, 0x01	; 1
    1afe:	70 e0       	ldi	r23, 0x00	; 0
    1b00:	ce 01       	movw	r24, r28
    1b02:	01 96       	adiw	r24, 0x01	; 1
    1b04:	a0 df       	rcall	.-192    	; 0x1a46 <rcvr_mmc>
}
    1b06:	0f 90       	pop	r0
    1b08:	df 91       	pop	r29
    1b0a:	cf 91       	pop	r28
    1b0c:	08 95       	ret

00001b0e <select>:
/* Select the card and wait for ready                                    */
/*-----------------------------------------------------------------------*/

static
int select (void)	/* 1:OK, 0:Timeout */
{
    1b0e:	0f 93       	push	r16
    1b10:	1f 93       	push	r17
    1b12:	cf 93       	push	r28
    1b14:	df 93       	push	r29
    1b16:	1f 92       	push	r1
    1b18:	cd b7       	in	r28, 0x3d	; 61
    1b1a:	de b7       	in	r29, 0x3e	; 62
	BYTE d;

	CS_L();
    1b1c:	59 98       	cbi	0x0b, 1	; 11
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO enabled) */
    1b1e:	61 e0       	ldi	r22, 0x01	; 1
    1b20:	70 e0       	ldi	r23, 0x00	; 0
    1b22:	ce 01       	movw	r24, r28
    1b24:	01 96       	adiw	r24, 0x01	; 1
    1b26:	8f df       	rcall	.-226    	; 0x1a46 <rcvr_mmc>

	if (wait_ready()) return 1;	/* OK */
    1b28:	c0 df       	rcall	.-128    	; 0x1aaa <wait_ready>
    1b2a:	8c 01       	movw	r16, r24
    1b2c:	89 2b       	or	r24, r25
    1b2e:	11 f4       	brne	.+4      	; 0x1b34 <select+0x26>
	deselect();
    1b30:	df df       	rcall	.-66     	; 0x1af0 <deselect>
	return 0;			/* Failed */
    1b32:	02 c0       	rjmp	.+4      	; 0x1b38 <select+0x2a>
	BYTE d;

	CS_L();
	rcvr_mmc(&d, 1);	/* Dummy clock (force DO enabled) */

	if (wait_ready()) return 1;	/* OK */
    1b34:	01 e0       	ldi	r16, 0x01	; 1
    1b36:	10 e0       	ldi	r17, 0x00	; 0
	deselect();
	return 0;			/* Failed */
}
    1b38:	c8 01       	movw	r24, r16
    1b3a:	0f 90       	pop	r0
    1b3c:	df 91       	pop	r29
    1b3e:	cf 91       	pop	r28
    1b40:	1f 91       	pop	r17
    1b42:	0f 91       	pop	r16
    1b44:	08 95       	ret

00001b46 <rcvr_datablock>:
static
int rcvr_datablock (	/* 1:OK, 0:Failed */
	BYTE *buff,			/* Data buffer to store received data */
	UINT btr			/* Byte count */
)
{
    1b46:	cf 92       	push	r12
    1b48:	df 92       	push	r13
    1b4a:	ef 92       	push	r14
    1b4c:	ff 92       	push	r15
    1b4e:	0f 93       	push	r16
    1b50:	1f 93       	push	r17
    1b52:	cf 93       	push	r28
    1b54:	df 93       	push	r29
    1b56:	00 d0       	rcall	.+0      	; 0x1b58 <rcvr_datablock+0x12>
    1b58:	cd b7       	in	r28, 0x3d	; 61
    1b5a:	de b7       	in	r29, 0x3e	; 62
    1b5c:	7c 01       	movw	r14, r24
    1b5e:	6b 01       	movw	r12, r22
    1b60:	08 ee       	ldi	r16, 0xE8	; 232
    1b62:	13 e0       	ldi	r17, 0x03	; 3
	BYTE d[2];
	UINT tmr;


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
		rcvr_mmc(d, 1);
    1b64:	61 e0       	ldi	r22, 0x01	; 1
    1b66:	70 e0       	ldi	r23, 0x00	; 0
    1b68:	ce 01       	movw	r24, r28
    1b6a:	01 96       	adiw	r24, 0x01	; 1
    1b6c:	6c df       	rcall	.-296    	; 0x1a46 <rcvr_mmc>
		if (d[0] != 0xFF) break;
    1b6e:	99 81       	ldd	r25, Y+1	; 0x01
    1b70:	9f 3f       	cpi	r25, 0xFF	; 255
    1b72:	31 f4       	brne	.+12     	; 0x1b80 <rcvr_datablock+0x3a>
		dly_us(100);
    1b74:	84 e6       	ldi	r24, 0x64	; 100
    1b76:	90 e0       	ldi	r25, 0x00	; 0
    1b78:	21 df       	rcall	.-446    	; 0x19bc <dly_us>
    1b7a:	01 50       	subi	r16, 0x01	; 1
    1b7c:	11 09       	sbc	r17, r1
{
	BYTE d[2];
	UINT tmr;


	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
    1b7e:	91 f7       	brne	.-28     	; 0x1b64 <rcvr_datablock+0x1e>
		rcvr_mmc(d, 1);
		if (d[0] != 0xFF) break;
		dly_us(100);
	}
	if (d[0] != 0xFE) return 0;		/* If not valid data token, return with error */
    1b80:	99 81       	ldd	r25, Y+1	; 0x01
    1b82:	9e 3f       	cpi	r25, 0xFE	; 254
    1b84:	59 f4       	brne	.+22     	; 0x1b9c <rcvr_datablock+0x56>

	rcvr_mmc(buff, btr);			/* Receive the data block into buffer */
    1b86:	b6 01       	movw	r22, r12
    1b88:	c7 01       	movw	r24, r14
    1b8a:	5d df       	rcall	.-326    	; 0x1a46 <rcvr_mmc>
	rcvr_mmc(d, 2);					/* Discard CRC */
    1b8c:	62 e0       	ldi	r22, 0x02	; 2
    1b8e:	70 e0       	ldi	r23, 0x00	; 0
    1b90:	ce 01       	movw	r24, r28
    1b92:	01 96       	adiw	r24, 0x01	; 1
    1b94:	58 df       	rcall	.-336    	; 0x1a46 <rcvr_mmc>

	return 1;						/* Return with success */
    1b96:	81 e0       	ldi	r24, 0x01	; 1
    1b98:	90 e0       	ldi	r25, 0x00	; 0
    1b9a:	02 c0       	rjmp	.+4      	; 0x1ba0 <rcvr_datablock+0x5a>
	for (tmr = 1000; tmr; tmr--) {	/* Wait for data packet in timeout of 100ms */
		rcvr_mmc(d, 1);
		if (d[0] != 0xFF) break;
		dly_us(100);
	}
	if (d[0] != 0xFE) return 0;		/* If not valid data token, return with error */
    1b9c:	80 e0       	ldi	r24, 0x00	; 0
    1b9e:	90 e0       	ldi	r25, 0x00	; 0

	rcvr_mmc(buff, btr);			/* Receive the data block into buffer */
	rcvr_mmc(d, 2);					/* Discard CRC */

	return 1;						/* Return with success */
}
    1ba0:	0f 90       	pop	r0
    1ba2:	0f 90       	pop	r0
    1ba4:	df 91       	pop	r29
    1ba6:	cf 91       	pop	r28
    1ba8:	1f 91       	pop	r17
    1baa:	0f 91       	pop	r16
    1bac:	ff 90       	pop	r15
    1bae:	ef 90       	pop	r14
    1bb0:	df 90       	pop	r13
    1bb2:	cf 90       	pop	r12
    1bb4:	08 95       	ret

00001bb6 <xmit_datablock>:
static
int xmit_datablock (	/* 1:OK, 0:Failed */
	const BYTE *buff,	/* 512 byte data block to be transmitted */
	BYTE token			/* Data/Stop token */
)
{
    1bb6:	ef 92       	push	r14
    1bb8:	ff 92       	push	r15
    1bba:	1f 93       	push	r17
    1bbc:	cf 93       	push	r28
    1bbe:	df 93       	push	r29
    1bc0:	00 d0       	rcall	.+0      	; 0x1bc2 <xmit_datablock+0xc>
    1bc2:	cd b7       	in	r28, 0x3d	; 61
    1bc4:	de b7       	in	r29, 0x3e	; 62
    1bc6:	7c 01       	movw	r14, r24
    1bc8:	16 2f       	mov	r17, r22
	BYTE d[2];


	if (!wait_ready()) return 0;
    1bca:	6f df       	rcall	.-290    	; 0x1aaa <wait_ready>
    1bcc:	00 97       	sbiw	r24, 0x00	; 0
    1bce:	11 f1       	breq	.+68     	; 0x1c14 <xmit_datablock+0x5e>

	d[0] = token;
    1bd0:	19 83       	std	Y+1, r17	; 0x01
	xmit_mmc(d, 1);				/* Xmit a token */
    1bd2:	61 e0       	ldi	r22, 0x01	; 1
    1bd4:	70 e0       	ldi	r23, 0x00	; 0
    1bd6:	ce 01       	movw	r24, r28
    1bd8:	01 96       	adiw	r24, 0x01	; 1
    1bda:	f5 de       	rcall	.-534    	; 0x19c6 <xmit_mmc>
	if (token != 0xFD) {		/* Is it data token? */
    1bdc:	1d 3f       	cpi	r17, 0xFD	; 253
    1bde:	c1 f0       	breq	.+48     	; 0x1c10 <xmit_datablock+0x5a>
		xmit_mmc(buff, 512);	/* Xmit the 512 byte data block to MMC */
    1be0:	60 e0       	ldi	r22, 0x00	; 0
    1be2:	72 e0       	ldi	r23, 0x02	; 2
    1be4:	c7 01       	movw	r24, r14
    1be6:	ef de       	rcall	.-546    	; 0x19c6 <xmit_mmc>
		rcvr_mmc(d, 2);			/* Xmit dummy CRC (0xFF,0xFF) */
    1be8:	62 e0       	ldi	r22, 0x02	; 2
    1bea:	70 e0       	ldi	r23, 0x00	; 0
    1bec:	ce 01       	movw	r24, r28
    1bee:	01 96       	adiw	r24, 0x01	; 1
    1bf0:	2a df       	rcall	.-428    	; 0x1a46 <rcvr_mmc>
		rcvr_mmc(d, 1);			/* Receive data response */
    1bf2:	61 e0       	ldi	r22, 0x01	; 1
    1bf4:	70 e0       	ldi	r23, 0x00	; 0
    1bf6:	ce 01       	movw	r24, r28
    1bf8:	01 96       	adiw	r24, 0x01	; 1
    1bfa:	25 df       	rcall	.-438    	; 0x1a46 <rcvr_mmc>
		if ((d[0] & 0x1F) != 0x05)	/* If not accepted, return with error */
    1bfc:	89 81       	ldd	r24, Y+1	; 0x01
    1bfe:	8f 71       	andi	r24, 0x1F	; 31
    1c00:	31 e0       	ldi	r19, 0x01	; 1
    1c02:	20 e0       	ldi	r18, 0x00	; 0
    1c04:	85 30       	cpi	r24, 0x05	; 5
    1c06:	09 f0       	breq	.+2      	; 0x1c0a <xmit_datablock+0x54>
    1c08:	30 e0       	ldi	r19, 0x00	; 0
)
{
	BYTE d[2];


	if (!wait_ready()) return 0;
    1c0a:	83 2f       	mov	r24, r19
    1c0c:	92 2f       	mov	r25, r18
    1c0e:	02 c0       	rjmp	.+4      	; 0x1c14 <xmit_datablock+0x5e>
		rcvr_mmc(d, 1);			/* Receive data response */
		if ((d[0] & 0x1F) != 0x05)	/* If not accepted, return with error */
			return 0;
	}

	return 1;
    1c10:	81 e0       	ldi	r24, 0x01	; 1
    1c12:	90 e0       	ldi	r25, 0x00	; 0
}
    1c14:	0f 90       	pop	r0
    1c16:	0f 90       	pop	r0
    1c18:	df 91       	pop	r29
    1c1a:	cf 91       	pop	r28
    1c1c:	1f 91       	pop	r17
    1c1e:	ff 90       	pop	r15
    1c20:	ef 90       	pop	r14
    1c22:	08 95       	ret

00001c24 <send_cmd>:
static
BYTE send_cmd (		/* Returns command response (bit7==1:Send failed)*/
	BYTE cmd,		/* Command byte */
	DWORD arg		/* Argument */
)
{
    1c24:	df 92       	push	r13
    1c26:	ef 92       	push	r14
    1c28:	ff 92       	push	r15
    1c2a:	0f 93       	push	r16
    1c2c:	1f 93       	push	r17
    1c2e:	cf 93       	push	r28
    1c30:	df 93       	push	r29
    1c32:	cd b7       	in	r28, 0x3d	; 61
    1c34:	de b7       	in	r29, 0x3e	; 62
    1c36:	27 97       	sbiw	r28, 0x07	; 7
    1c38:	0f b6       	in	r0, 0x3f	; 63
    1c3a:	f8 94       	cli
    1c3c:	de bf       	out	0x3e, r29	; 62
    1c3e:	0f be       	out	0x3f, r0	; 63
    1c40:	cd bf       	out	0x3d, r28	; 61
    1c42:	18 2f       	mov	r17, r24
    1c44:	04 2f       	mov	r16, r20
    1c46:	f5 2e       	mov	r15, r21
    1c48:	e6 2e       	mov	r14, r22
    1c4a:	d7 2e       	mov	r13, r23
	BYTE n, d, buf[6];


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
    1c4c:	88 23       	and	r24, r24
    1c4e:	4c f4       	brge	.+18     	; 0x1c62 <send_cmd+0x3e>
		cmd &= 0x7F;
		n = send_cmd(CMD55, 0);
    1c50:	40 e0       	ldi	r20, 0x00	; 0
    1c52:	50 e0       	ldi	r21, 0x00	; 0
    1c54:	ba 01       	movw	r22, r20
    1c56:	87 e3       	ldi	r24, 0x37	; 55
    1c58:	e5 df       	rcall	.-54     	; 0x1c24 <send_cmd>
		if (n > 1) return n;
    1c5a:	82 30       	cpi	r24, 0x02	; 2
    1c5c:	08 f0       	brcs	.+2      	; 0x1c60 <send_cmd+0x3c>
    1c5e:	4f c0       	rjmp	.+158    	; 0x1cfe <send_cmd+0xda>
{
	BYTE n, d, buf[6];


	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
    1c60:	1f 77       	andi	r17, 0x7F	; 127
		n = send_cmd(CMD55, 0);
		if (n > 1) return n;
	}

	/* Select the card and wait for ready except to stop multiple block read */
	if (cmd != CMD12) {
    1c62:	1c 30       	cpi	r17, 0x0C	; 12
    1c64:	09 f1       	breq	.+66     	; 0x1ca8 <send_cmd+0x84>
		deselect();
    1c66:	44 df       	rcall	.-376    	; 0x1af0 <deselect>
		if (!select()) return 0xFF;
    1c68:	52 df       	rcall	.-348    	; 0x1b0e <select>
    1c6a:	89 2b       	or	r24, r25
    1c6c:	d9 f0       	breq	.+54     	; 0x1ca4 <send_cmd+0x80>
	}

	/* Send a command packet */
	buf[0] = 0x40 | cmd;			/* Start + Command index */
    1c6e:	81 2f       	mov	r24, r17
    1c70:	80 64       	ori	r24, 0x40	; 64
    1c72:	8a 83       	std	Y+2, r24	; 0x02
	buf[1] = (BYTE)(arg >> 24);		/* Argument[31..24] */
    1c74:	db 82       	std	Y+3, r13	; 0x03
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
    1c76:	ec 82       	std	Y+4, r14	; 0x04
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
    1c78:	fd 82       	std	Y+5, r15	; 0x05
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
    1c7a:	0e 83       	std	Y+6, r16	; 0x06
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
    1c7c:	11 23       	and	r17, r17
    1c7e:	b9 f1       	breq	.+110    	; 0x1cee <send_cmd+0xca>
    1c80:	33 c0       	rjmp	.+102    	; 0x1ce8 <send_cmd+0xc4>
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
	buf[5] = n;
	xmit_mmc(buf, 6);

	/* Receive command response */
	if (cmd == CMD12) rcvr_mmc(&d, 1);	/* Skip a stuff byte when stop reading */
    1c82:	61 e0       	ldi	r22, 0x01	; 1
    1c84:	70 e0       	ldi	r23, 0x00	; 0
    1c86:	ce 01       	movw	r24, r28
    1c88:	01 96       	adiw	r24, 0x01	; 1
    1c8a:	dd de       	rcall	.-582    	; 0x1a46 <rcvr_mmc>
static
BYTE send_cmd (		/* Returns command response (bit7==1:Send failed)*/
	BYTE cmd,		/* Command byte */
	DWORD arg		/* Argument */
)
{
    1c8c:	1a e0       	ldi	r17, 0x0A	; 10

	/* Receive command response */
	if (cmd == CMD12) rcvr_mmc(&d, 1);	/* Skip a stuff byte when stop reading */
	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do
		rcvr_mmc(&d, 1);
    1c8e:	61 e0       	ldi	r22, 0x01	; 1
    1c90:	70 e0       	ldi	r23, 0x00	; 0
    1c92:	ce 01       	movw	r24, r28
    1c94:	01 96       	adiw	r24, 0x01	; 1
    1c96:	d7 de       	rcall	.-594    	; 0x1a46 <rcvr_mmc>
	while ((d & 0x80) && --n);
    1c98:	89 81       	ldd	r24, Y+1	; 0x01
    1c9a:	88 23       	and	r24, r24
    1c9c:	84 f5       	brge	.+96     	; 0x1cfe <send_cmd+0xda>
    1c9e:	11 50       	subi	r17, 0x01	; 1
    1ca0:	b1 f7       	brne	.-20     	; 0x1c8e <send_cmd+0x6a>
    1ca2:	2d c0       	rjmp	.+90     	; 0x1cfe <send_cmd+0xda>
	}

	/* Select the card and wait for ready except to stop multiple block read */
	if (cmd != CMD12) {
		deselect();
		if (!select()) return 0xFF;
    1ca4:	8f ef       	ldi	r24, 0xFF	; 255
    1ca6:	2b c0       	rjmp	.+86     	; 0x1cfe <send_cmd+0xda>
	}

	/* Send a command packet */
	buf[0] = 0x40 | cmd;			/* Start + Command index */
    1ca8:	8c e4       	ldi	r24, 0x4C	; 76
    1caa:	8a 83       	std	Y+2, r24	; 0x02
	buf[1] = (BYTE)(arg >> 24);		/* Argument[31..24] */
    1cac:	db 82       	std	Y+3, r13	; 0x03
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
    1cae:	ec 82       	std	Y+4, r14	; 0x04
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
    1cb0:	fd 82       	std	Y+5, r15	; 0x05
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
    1cb2:	0e 83       	std	Y+6, r16	; 0x06
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
	buf[5] = n;
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	8f 83       	std	Y+7, r24	; 0x07
	xmit_mmc(buf, 6);
    1cb8:	66 e0       	ldi	r22, 0x06	; 6
    1cba:	70 e0       	ldi	r23, 0x00	; 0
    1cbc:	ce 01       	movw	r24, r28
    1cbe:	02 96       	adiw	r24, 0x02	; 2
    1cc0:	82 de       	rcall	.-764    	; 0x19c6 <xmit_mmc>

	/* Receive command response */
	if (cmd == CMD12) rcvr_mmc(&d, 1);	/* Skip a stuff byte when stop reading */
    1cc2:	1c 30       	cpi	r17, 0x0C	; 12
    1cc4:	19 f7       	brne	.-58     	; 0x1c8c <send_cmd+0x68>
    1cc6:	dd cf       	rjmp	.-70     	; 0x1c82 <send_cmd+0x5e>
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
	buf[5] = n;
    1cc8:	87 e8       	ldi	r24, 0x87	; 135
    1cca:	8f 83       	std	Y+7, r24	; 0x07
	xmit_mmc(buf, 6);
    1ccc:	66 e0       	ldi	r22, 0x06	; 6
    1cce:	70 e0       	ldi	r23, 0x00	; 0
    1cd0:	ce 01       	movw	r24, r28
    1cd2:	02 96       	adiw	r24, 0x02	; 2
    1cd4:	78 de       	rcall	.-784    	; 0x19c6 <xmit_mmc>
    1cd6:	da cf       	rjmp	.-76     	; 0x1c8c <send_cmd+0x68>
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
	buf[5] = n;
    1cd8:	81 e0       	ldi	r24, 0x01	; 1
    1cda:	8f 83       	std	Y+7, r24	; 0x07
	xmit_mmc(buf, 6);
    1cdc:	66 e0       	ldi	r22, 0x06	; 6
    1cde:	70 e0       	ldi	r23, 0x00	; 0
    1ce0:	ce 01       	movw	r24, r28
    1ce2:	02 96       	adiw	r24, 0x02	; 2
    1ce4:	70 de       	rcall	.-800    	; 0x19c6 <xmit_mmc>
    1ce6:	d2 cf       	rjmp	.-92     	; 0x1c8c <send_cmd+0x68>
	buf[2] = (BYTE)(arg >> 16);		/* Argument[23..16] */
	buf[3] = (BYTE)(arg >> 8);		/* Argument[15..8] */
	buf[4] = (BYTE)arg;				/* Argument[7..0] */
	n = 0x01;						/* Dummy CRC + Stop */
	if (cmd == CMD0) n = 0x95;		/* (valid CRC for CMD0(0)) */
	if (cmd == CMD8) n = 0x87;		/* (valid CRC for CMD8(0x1AA)) */
    1ce8:	18 30       	cpi	r17, 0x08	; 8
    1cea:	71 f3       	breq	.-36     	; 0x1cc8 <send_cmd+0xa4>
    1cec:	f5 cf       	rjmp	.-22     	; 0x1cd8 <send_cmd+0xb4>
	buf[5] = n;
    1cee:	85 e9       	ldi	r24, 0x95	; 149
    1cf0:	8f 83       	std	Y+7, r24	; 0x07
	xmit_mmc(buf, 6);
    1cf2:	66 e0       	ldi	r22, 0x06	; 6
    1cf4:	70 e0       	ldi	r23, 0x00	; 0
    1cf6:	ce 01       	movw	r24, r28
    1cf8:	02 96       	adiw	r24, 0x02	; 2
    1cfa:	65 de       	rcall	.-822    	; 0x19c6 <xmit_mmc>
    1cfc:	c7 cf       	rjmp	.-114    	; 0x1c8c <send_cmd+0x68>
	do
		rcvr_mmc(&d, 1);
	while ((d & 0x80) && --n);

	return d;			/* Return with the response value */
}
    1cfe:	27 96       	adiw	r28, 0x07	; 7
    1d00:	0f b6       	in	r0, 0x3f	; 63
    1d02:	f8 94       	cli
    1d04:	de bf       	out	0x3e, r29	; 62
    1d06:	0f be       	out	0x3f, r0	; 63
    1d08:	cd bf       	out	0x3d, r28	; 61
    1d0a:	df 91       	pop	r29
    1d0c:	cf 91       	pop	r28
    1d0e:	1f 91       	pop	r17
    1d10:	0f 91       	pop	r16
    1d12:	ff 90       	pop	r15
    1d14:	ef 90       	pop	r14
    1d16:	df 90       	pop	r13
    1d18:	08 95       	ret

00001d1a <disk_status>:

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    1d1a:	81 11       	cpse	r24, r1
    1d1c:	03 c0       	rjmp	.+6      	; 0x1d24 <disk_status+0xa>

	return Stat;
    1d1e:	80 91 0d 01 	lds	r24, 0x010D
    1d22:	08 95       	ret

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    1d24:	81 e0       	ldi	r24, 0x01	; 1

	return Stat;
}
    1d26:	08 95       	ret

00001d28 <disk_initialize>:
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE drv		/* Physical drive nmuber (0) */
)
{
    1d28:	ef 92       	push	r14
    1d2a:	ff 92       	push	r15
    1d2c:	0f 93       	push	r16
    1d2e:	1f 93       	push	r17
    1d30:	cf 93       	push	r28
    1d32:	df 93       	push	r29
    1d34:	00 d0       	rcall	.+0      	; 0x1d36 <disk_initialize+0xe>
    1d36:	00 d0       	rcall	.+0      	; 0x1d38 <disk_initialize+0x10>
    1d38:	cd b7       	in	r28, 0x3d	; 61
    1d3a:	de b7       	in	r29, 0x3e	; 62
	BYTE n, ty, cmd, buf[4];
	UINT tmr;
	DSTATUS s;


	if (drv) return RES_NOTRDY;
    1d3c:	81 11       	cpse	r24, r1
    1d3e:	a1 c0       	rjmp	.+322    	; 0x1e82 <disk_initialize+0x15a>

	dly_us(10000);			/* 10ms */
    1d40:	80 e1       	ldi	r24, 0x10	; 16
    1d42:	97 e2       	ldi	r25, 0x27	; 39
    1d44:	3b de       	rcall	.-906    	; 0x19bc <dly_us>
	CS_INIT(); CS_H();		/* Initialize port pin tied to CS */
    1d46:	51 9a       	sbi	0x0a, 1	; 10
    1d48:	59 9a       	sbi	0x0b, 1	; 11
	CK_INIT(); CK_L();		/* Initialize port pin tied to SCLK */
    1d4a:	29 98       	cbi	0x05, 1	; 5
    1d4c:	21 9a       	sbi	0x04, 1	; 4
    1d4e:	29 98       	cbi	0x05, 1	; 5
	DI_INIT();				/* Initialize port pin tied to DI */
    1d50:	22 9a       	sbi	0x04, 2	; 4
	DO_INIT();				/* Initialize port pin tied to DO */
    1d52:	2b 9a       	sbi	0x05, 3	; 5
    1d54:	1a e0       	ldi	r17, 0x0A	; 10

	for (n = 10; n; n--) rcvr_mmc(buf, 1);	/* Apply 80 dummy clocks and the card gets ready to receive command */
    1d56:	61 e0       	ldi	r22, 0x01	; 1
    1d58:	70 e0       	ldi	r23, 0x00	; 0
    1d5a:	ce 01       	movw	r24, r28
    1d5c:	01 96       	adiw	r24, 0x01	; 1
    1d5e:	73 de       	rcall	.-794    	; 0x1a46 <rcvr_mmc>
    1d60:	11 50       	subi	r17, 0x01	; 1
    1d62:	c9 f7       	brne	.-14     	; 0x1d56 <disk_initialize+0x2e>

	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
    1d64:	40 e0       	ldi	r20, 0x00	; 0
    1d66:	50 e0       	ldi	r21, 0x00	; 0
    1d68:	ba 01       	movw	r22, r20
    1d6a:	80 e0       	ldi	r24, 0x00	; 0
    1d6c:	5b df       	rcall	.-330    	; 0x1c24 <send_cmd>
    1d6e:	81 30       	cpi	r24, 0x01	; 1
    1d70:	09 f0       	breq	.+2      	; 0x1d74 <disk_initialize+0x4c>
    1d72:	6d c0       	rjmp	.+218    	; 0x1e4e <disk_initialize+0x126>
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
    1d74:	4a ea       	ldi	r20, 0xAA	; 170
    1d76:	51 e0       	ldi	r21, 0x01	; 1
    1d78:	60 e0       	ldi	r22, 0x00	; 0
    1d7a:	70 e0       	ldi	r23, 0x00	; 0
    1d7c:	88 e0       	ldi	r24, 0x08	; 8
    1d7e:	52 df       	rcall	.-348    	; 0x1c24 <send_cmd>
    1d80:	81 30       	cpi	r24, 0x01	; 1
    1d82:	a9 f5       	brne	.+106    	; 0x1dee <disk_initialize+0xc6>
			rcvr_mmc(buf, 4);							/* Get trailing return value of R7 resp */
    1d84:	64 e0       	ldi	r22, 0x04	; 4
    1d86:	70 e0       	ldi	r23, 0x00	; 0
    1d88:	ce 01       	movw	r24, r28
    1d8a:	01 96       	adiw	r24, 0x01	; 1
    1d8c:	5c de       	rcall	.-840    	; 0x1a46 <rcvr_mmc>
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
    1d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d90:	81 30       	cpi	r24, 0x01	; 1
    1d92:	09 f0       	breq	.+2      	; 0x1d96 <disk_initialize+0x6e>
    1d94:	5e c0       	rjmp	.+188    	; 0x1e52 <disk_initialize+0x12a>
    1d96:	8c 81       	ldd	r24, Y+4	; 0x04
    1d98:	8a 3a       	cpi	r24, 0xAA	; 170
    1d9a:	09 f0       	breq	.+2      	; 0x1d9e <disk_initialize+0x76>
    1d9c:	5c c0       	rjmp	.+184    	; 0x1e56 <disk_initialize+0x12e>
    1d9e:	08 ee       	ldi	r16, 0xE8	; 232
    1da0:	13 e0       	ldi	r17, 0x03	; 3
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
    1da2:	40 e0       	ldi	r20, 0x00	; 0
    1da4:	50 e0       	ldi	r21, 0x00	; 0
    1da6:	60 e0       	ldi	r22, 0x00	; 0
    1da8:	70 e4       	ldi	r23, 0x40	; 64
    1daa:	89 ea       	ldi	r24, 0xA9	; 169
    1dac:	3b df       	rcall	.-394    	; 0x1c24 <send_cmd>
    1dae:	88 23       	and	r24, r24
    1db0:	41 f0       	breq	.+16     	; 0x1dc2 <disk_initialize+0x9a>
					dly_us(1000);
    1db2:	88 ee       	ldi	r24, 0xE8	; 232
    1db4:	93 e0       	ldi	r25, 0x03	; 3
    1db6:	02 de       	rcall	.-1020   	; 0x19bc <dly_us>
	ty = 0;
	if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
		if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2? */
			rcvr_mmc(buf, 4);							/* Get trailing return value of R7 resp */
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
    1db8:	01 50       	subi	r16, 0x01	; 1
    1dba:	11 09       	sbc	r17, r1
    1dbc:	91 f7       	brne	.-28     	; 0x1da2 <disk_initialize+0x7a>
	DI_INIT();				/* Initialize port pin tied to DI */
	DO_INIT();				/* Initialize port pin tied to DO */

	for (n = 10; n; n--) rcvr_mmc(buf, 1);	/* Apply 80 dummy clocks and the card gets ready to receive command */

	ty = 0;
    1dbe:	f1 2c       	mov	r15, r1
    1dc0:	56 c0       	rjmp	.+172    	; 0x1e6e <disk_initialize+0x146>
			if (buf[2] == 0x01 && buf[3] == 0xAA) {		/* The card can work at vdd range of 2.7-3.6V */
				for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state (ACMD41 with HCS bit) */
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
					dly_us(1000);
				}
				if (tmr && send_cmd(CMD58, 0) == 0) {	/* Check CCS bit in the OCR */
    1dc2:	01 2b       	or	r16, r17
    1dc4:	09 f4       	brne	.+2      	; 0x1dc8 <disk_initialize+0xa0>
    1dc6:	49 c0       	rjmp	.+146    	; 0x1e5a <disk_initialize+0x132>
    1dc8:	40 e0       	ldi	r20, 0x00	; 0
    1dca:	50 e0       	ldi	r21, 0x00	; 0
    1dcc:	ba 01       	movw	r22, r20
    1dce:	8a e3       	ldi	r24, 0x3A	; 58
    1dd0:	29 df       	rcall	.-430    	; 0x1c24 <send_cmd>
    1dd2:	81 11       	cpse	r24, r1
    1dd4:	44 c0       	rjmp	.+136    	; 0x1e5e <disk_initialize+0x136>
					rcvr_mmc(buf, 4);
    1dd6:	64 e0       	ldi	r22, 0x04	; 4
    1dd8:	70 e0       	ldi	r23, 0x00	; 0
    1dda:	ce 01       	movw	r24, r28
    1ddc:	01 96       	adiw	r24, 0x01	; 1
    1dde:	33 de       	rcall	.-922    	; 0x1a46 <rcvr_mmc>
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
    1de0:	89 81       	ldd	r24, Y+1	; 0x01
    1de2:	86 fd       	sbrc	r24, 6
    1de4:	3e c0       	rjmp	.+124    	; 0x1e62 <disk_initialize+0x13a>
    1de6:	68 94       	set
    1de8:	ff 24       	eor	r15, r15
    1dea:	f2 f8       	bld	r15, 2
    1dec:	40 c0       	rjmp	.+128    	; 0x1e6e <disk_initialize+0x146>
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
    1dee:	40 e0       	ldi	r20, 0x00	; 0
    1df0:	50 e0       	ldi	r21, 0x00	; 0
    1df2:	ba 01       	movw	r22, r20
    1df4:	89 ea       	ldi	r24, 0xA9	; 169
    1df6:	16 df       	rcall	.-468    	; 0x1c24 <send_cmd>
    1df8:	82 30       	cpi	r24, 0x02	; 2
    1dfa:	28 f0       	brcs	.+10     	; 0x1e06 <disk_initialize+0xde>
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
    1dfc:	ee 24       	eor	r14, r14
    1dfe:	e3 94       	inc	r14
    1e00:	ff 24       	eor	r15, r15
    1e02:	f3 94       	inc	r15
    1e04:	07 c0       	rjmp	.+14     	; 0x1e14 <disk_initialize+0xec>
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
				}
			}
		} else {							/* SDv1 or MMCv3 */
			if (send_cmd(ACMD41, 0) <= 1) 	{
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
    1e06:	0f 2e       	mov	r0, r31
    1e08:	f9 ea       	ldi	r31, 0xA9	; 169
    1e0a:	ef 2e       	mov	r14, r31
    1e0c:	f0 2d       	mov	r31, r0
    1e0e:	68 94       	set
    1e10:	ff 24       	eor	r15, r15
    1e12:	f1 f8       	bld	r15, 1
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
    1e14:	08 ee       	ldi	r16, 0xE8	; 232
    1e16:	13 e0       	ldi	r17, 0x03	; 3
				if (send_cmd(cmd, 0) == 0) break;
    1e18:	40 e0       	ldi	r20, 0x00	; 0
    1e1a:	50 e0       	ldi	r21, 0x00	; 0
    1e1c:	ba 01       	movw	r22, r20
    1e1e:	8e 2d       	mov	r24, r14
    1e20:	01 df       	rcall	.-510    	; 0x1c24 <send_cmd>
    1e22:	88 23       	and	r24, r24
    1e24:	41 f0       	breq	.+16     	; 0x1e36 <disk_initialize+0x10e>
				dly_us(1000);
    1e26:	88 ee       	ldi	r24, 0xE8	; 232
    1e28:	93 e0       	ldi	r25, 0x03	; 3
    1e2a:	c8 dd       	rcall	.-1136   	; 0x19bc <dly_us>
			if (send_cmd(ACMD41, 0) <= 1) 	{
				ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
			} else {
				ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
    1e2c:	01 50       	subi	r16, 0x01	; 1
    1e2e:	11 09       	sbc	r17, r1
    1e30:	99 f7       	brne	.-26     	; 0x1e18 <disk_initialize+0xf0>
				if (send_cmd(cmd, 0) == 0) break;
				dly_us(1000);
			}
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
    1e32:	f1 2c       	mov	r15, r1
    1e34:	1c c0       	rjmp	.+56     	; 0x1e6e <disk_initialize+0x146>
			}
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
				if (send_cmd(cmd, 0) == 0) break;
				dly_us(1000);
			}
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
    1e36:	01 2b       	or	r16, r17
    1e38:	c9 f0       	breq	.+50     	; 0x1e6c <disk_initialize+0x144>
    1e3a:	40 e0       	ldi	r20, 0x00	; 0
    1e3c:	52 e0       	ldi	r21, 0x02	; 2
    1e3e:	60 e0       	ldi	r22, 0x00	; 0
    1e40:	70 e0       	ldi	r23, 0x00	; 0
    1e42:	80 e1       	ldi	r24, 0x10	; 16
    1e44:	ef de       	rcall	.-546    	; 0x1c24 <send_cmd>
    1e46:	88 23       	and	r24, r24
    1e48:	91 f0       	breq	.+36     	; 0x1e6e <disk_initialize+0x146>
				ty = 0;
    1e4a:	f1 2c       	mov	r15, r1
    1e4c:	10 c0       	rjmp	.+32     	; 0x1e6e <disk_initialize+0x146>
	DI_INIT();				/* Initialize port pin tied to DI */
	DO_INIT();				/* Initialize port pin tied to DO */

	for (n = 10; n; n--) rcvr_mmc(buf, 1);	/* Apply 80 dummy clocks and the card gets ready to receive command */

	ty = 0;
    1e4e:	f1 2c       	mov	r15, r1
    1e50:	0e c0       	rjmp	.+28     	; 0x1e6e <disk_initialize+0x146>
    1e52:	f1 2c       	mov	r15, r1
    1e54:	0c c0       	rjmp	.+24     	; 0x1e6e <disk_initialize+0x146>
    1e56:	f1 2c       	mov	r15, r1
    1e58:	0a c0       	rjmp	.+20     	; 0x1e6e <disk_initialize+0x146>
    1e5a:	f1 2c       	mov	r15, r1
    1e5c:	08 c0       	rjmp	.+16     	; 0x1e6e <disk_initialize+0x146>
    1e5e:	f1 2c       	mov	r15, r1
    1e60:	06 c0       	rjmp	.+12     	; 0x1e6e <disk_initialize+0x146>
					if (send_cmd(ACMD41, 1UL << 30) == 0) break;
					dly_us(1000);
				}
				if (tmr && send_cmd(CMD58, 0) == 0) {	/* Check CCS bit in the OCR */
					rcvr_mmc(buf, 4);
					ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
    1e62:	0f 2e       	mov	r0, r31
    1e64:	fc e0       	ldi	r31, 0x0C	; 12
    1e66:	ff 2e       	mov	r15, r31
    1e68:	f0 2d       	mov	r31, r0
    1e6a:	01 c0       	rjmp	.+2      	; 0x1e6e <disk_initialize+0x146>
			for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
				if (send_cmd(cmd, 0) == 0) break;
				dly_us(1000);
			}
			if (!tmr || send_cmd(CMD16, 512) != 0)	/* Set R/W block length to 512 */
				ty = 0;
    1e6c:	f1 2c       	mov	r15, r1
		}
	}
	CardType = ty;
    1e6e:	f0 92 23 06 	sts	0x0623, r15
	
				
	s = ty ? 0 : STA_NOINIT;
    1e72:	11 e0       	ldi	r17, 0x01	; 1
    1e74:	f1 10       	cpse	r15, r1
    1e76:	10 e0       	ldi	r17, 0x00	; 0
	Stat = s;
    1e78:	10 93 0d 01 	sts	0x010D, r17

	deselect();
    1e7c:	39 de       	rcall	.-910    	; 0x1af0 <deselect>

	return s;
    1e7e:	81 2f       	mov	r24, r17
    1e80:	01 c0       	rjmp	.+2      	; 0x1e84 <disk_initialize+0x15c>
	BYTE n, ty, cmd, buf[4];
	UINT tmr;
	DSTATUS s;


	if (drv) return RES_NOTRDY;
    1e82:	83 e0       	ldi	r24, 0x03	; 3
	Stat = s;

	deselect();

	return s;
}
    1e84:	0f 90       	pop	r0
    1e86:	0f 90       	pop	r0
    1e88:	0f 90       	pop	r0
    1e8a:	0f 90       	pop	r0
    1e8c:	df 91       	pop	r29
    1e8e:	cf 91       	pop	r28
    1e90:	1f 91       	pop	r17
    1e92:	0f 91       	pop	r16
    1e94:	ff 90       	pop	r15
    1e96:	ef 90       	pop	r14
    1e98:	08 95       	ret

00001e9a <disk_read>:
	BYTE drv,			/* Physical drive nmuber (0) */
	BYTE *buff,			/* Pointer to the data buffer to store read data */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
    1e9a:	ff 92       	push	r15
    1e9c:	0f 93       	push	r16
    1e9e:	1f 93       	push	r17
    1ea0:	cf 93       	push	r28
    1ea2:	df 93       	push	r29
    1ea4:	eb 01       	movw	r28, r22

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    1ea6:	81 11       	cpse	r24, r1
    1ea8:	3b c0       	rjmp	.+118    	; 0x1f20 <disk_read+0x86>
)
{
	BYTE cmd;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    1eaa:	80 91 0d 01 	lds	r24, 0x010D
    1eae:	80 fd       	sbrc	r24, 0
    1eb0:	39 c0       	rjmp	.+114    	; 0x1f24 <disk_read+0x8a>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
    1eb2:	80 91 23 06 	lds	r24, 0x0623
    1eb6:	83 fd       	sbrc	r24, 3
    1eb8:	09 c0       	rjmp	.+18     	; 0x1ecc <disk_read+0x32>
    1eba:	01 2e       	mov	r0, r17
    1ebc:	19 e0       	ldi	r17, 0x09	; 9
    1ebe:	22 0f       	add	r18, r18
    1ec0:	33 1f       	adc	r19, r19
    1ec2:	44 1f       	adc	r20, r20
    1ec4:	55 1f       	adc	r21, r21
    1ec6:	1a 95       	dec	r17
    1ec8:	d1 f7       	brne	.-12     	; 0x1ebe <disk_read+0x24>
    1eca:	10 2d       	mov	r17, r0

	cmd = count > 1 ? CMD18 : CMD17;			/*  READ_MULTIPLE_BLOCK : READ_SINGLE_BLOCK */
    1ecc:	02 30       	cpi	r16, 0x02	; 2
    1ece:	11 05       	cpc	r17, r1
    1ed0:	28 f4       	brcc	.+10     	; 0x1edc <disk_read+0x42>
    1ed2:	0f 2e       	mov	r0, r31
    1ed4:	f1 e1       	ldi	r31, 0x11	; 17
    1ed6:	ff 2e       	mov	r15, r31
    1ed8:	f0 2d       	mov	r31, r0
    1eda:	04 c0       	rjmp	.+8      	; 0x1ee4 <disk_read+0x4a>
    1edc:	0f 2e       	mov	r0, r31
    1ede:	f2 e1       	ldi	r31, 0x12	; 18
    1ee0:	ff 2e       	mov	r15, r31
    1ee2:	f0 2d       	mov	r31, r0
	if (send_cmd(cmd, sector) == 0) {
    1ee4:	ba 01       	movw	r22, r20
    1ee6:	a9 01       	movw	r20, r18
    1ee8:	8f 2d       	mov	r24, r15
    1eea:	9c de       	rcall	.-712    	; 0x1c24 <send_cmd>
    1eec:	81 11       	cpse	r24, r1
    1eee:	12 c0       	rjmp	.+36     	; 0x1f14 <disk_read+0x7a>
		do {
			if (!rcvr_datablock(buff, 512)) break;
    1ef0:	60 e0       	ldi	r22, 0x00	; 0
    1ef2:	72 e0       	ldi	r23, 0x02	; 2
    1ef4:	ce 01       	movw	r24, r28
    1ef6:	27 de       	rcall	.-946    	; 0x1b46 <rcvr_datablock>
    1ef8:	89 2b       	or	r24, r25
    1efa:	21 f0       	breq	.+8      	; 0x1f04 <disk_read+0x6a>
			buff += 512;
    1efc:	de 5f       	subi	r29, 0xFE	; 254
		} while (--count);
    1efe:	01 50       	subi	r16, 0x01	; 1
    1f00:	11 09       	sbc	r17, r1
    1f02:	b1 f7       	brne	.-20     	; 0x1ef0 <disk_read+0x56>
		if (cmd == CMD18) send_cmd(CMD12, 0);	/* STOP_TRANSMISSION */
    1f04:	82 e1       	ldi	r24, 0x12	; 18
    1f06:	f8 12       	cpse	r15, r24
    1f08:	05 c0       	rjmp	.+10     	; 0x1f14 <disk_read+0x7a>
    1f0a:	40 e0       	ldi	r20, 0x00	; 0
    1f0c:	50 e0       	ldi	r21, 0x00	; 0
    1f0e:	ba 01       	movw	r22, r20
    1f10:	8c e0       	ldi	r24, 0x0C	; 12
    1f12:	88 de       	rcall	.-752    	; 0x1c24 <send_cmd>
	}
	deselect();
    1f14:	ed dd       	rcall	.-1062   	; 0x1af0 <deselect>

	return count ? RES_ERROR : RES_OK;
    1f16:	81 e0       	ldi	r24, 0x01	; 1
    1f18:	01 2b       	or	r16, r17
    1f1a:	29 f4       	brne	.+10     	; 0x1f26 <disk_read+0x8c>
    1f1c:	80 e0       	ldi	r24, 0x00	; 0
    1f1e:	03 c0       	rjmp	.+6      	; 0x1f26 <disk_read+0x8c>
)
{
	BYTE cmd;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    1f20:	83 e0       	ldi	r24, 0x03	; 3
    1f22:	01 c0       	rjmp	.+2      	; 0x1f26 <disk_read+0x8c>
    1f24:	83 e0       	ldi	r24, 0x03	; 3
		if (cmd == CMD18) send_cmd(CMD12, 0);	/* STOP_TRANSMISSION */
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
    1f26:	df 91       	pop	r29
    1f28:	cf 91       	pop	r28
    1f2a:	1f 91       	pop	r17
    1f2c:	0f 91       	pop	r16
    1f2e:	ff 90       	pop	r15
    1f30:	08 95       	ret

00001f32 <disk_write>:
	BYTE drv,			/* Physical drive nmuber (0) */
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
    1f32:	cf 92       	push	r12
    1f34:	df 92       	push	r13
    1f36:	ef 92       	push	r14
    1f38:	ff 92       	push	r15
    1f3a:	0f 93       	push	r16
    1f3c:	1f 93       	push	r17
    1f3e:	cf 93       	push	r28
    1f40:	df 93       	push	r29
    1f42:	eb 01       	movw	r28, r22
    1f44:	69 01       	movw	r12, r18
    1f46:	7a 01       	movw	r14, r20

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    1f48:	81 11       	cpse	r24, r1
    1f4a:	49 c0       	rjmp	.+146    	; 0x1fde <disk_write+0xac>
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    1f4c:	80 91 0d 01 	lds	r24, 0x010D
    1f50:	80 fd       	sbrc	r24, 0
    1f52:	47 c0       	rjmp	.+142    	; 0x1fe2 <disk_write+0xb0>
	if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert LBA to byte address if needed */
    1f54:	80 91 23 06 	lds	r24, 0x0623
    1f58:	83 fd       	sbrc	r24, 3
    1f5a:	09 c0       	rjmp	.+18     	; 0x1f6e <disk_write+0x3c>
    1f5c:	0b 2e       	mov	r0, r27
    1f5e:	b9 e0       	ldi	r27, 0x09	; 9
    1f60:	cc 0c       	add	r12, r12
    1f62:	dd 1c       	adc	r13, r13
    1f64:	ee 1c       	adc	r14, r14
    1f66:	ff 1c       	adc	r15, r15
    1f68:	ba 95       	dec	r27
    1f6a:	d1 f7       	brne	.-12     	; 0x1f60 <disk_write+0x2e>
    1f6c:	b0 2d       	mov	r27, r0

	if (count == 1) {	/* Single block write */
    1f6e:	01 30       	cpi	r16, 0x01	; 1
    1f70:	11 05       	cpc	r17, r1
    1f72:	89 f4       	brne	.+34     	; 0x1f96 <disk_write+0x64>
		if ((send_cmd(CMD24, sector) == 0)	/* WRITE_BLOCK */
    1f74:	b7 01       	movw	r22, r14
    1f76:	a6 01       	movw	r20, r12
    1f78:	88 e1       	ldi	r24, 0x18	; 24
    1f7a:	54 de       	rcall	.-856    	; 0x1c24 <send_cmd>
    1f7c:	81 11       	cpse	r24, r1
    1f7e:	29 c0       	rjmp	.+82     	; 0x1fd2 <disk_write+0xa0>
			&& xmit_datablock(buff, 0xFE))
    1f80:	6e ef       	ldi	r22, 0xFE	; 254
    1f82:	ce 01       	movw	r24, r28
    1f84:	18 de       	rcall	.-976    	; 0x1bb6 <xmit_datablock>
    1f86:	31 e0       	ldi	r19, 0x01	; 1
    1f88:	20 e0       	ldi	r18, 0x00	; 0
    1f8a:	89 2b       	or	r24, r25
    1f8c:	09 f0       	breq	.+2      	; 0x1f90 <disk_write+0x5e>
    1f8e:	30 e0       	ldi	r19, 0x00	; 0
    1f90:	03 2f       	mov	r16, r19
    1f92:	12 2f       	mov	r17, r18
    1f94:	1e c0       	rjmp	.+60     	; 0x1fd2 <disk_write+0xa0>
			count = 0;
	}
	else {				/* Multiple block write */
		if (CardType & CT_SDC) send_cmd(ACMD23, count);
    1f96:	86 70       	andi	r24, 0x06	; 6
    1f98:	29 f0       	breq	.+10     	; 0x1fa4 <disk_write+0x72>
    1f9a:	a8 01       	movw	r20, r16
    1f9c:	60 e0       	ldi	r22, 0x00	; 0
    1f9e:	70 e0       	ldi	r23, 0x00	; 0
    1fa0:	87 e9       	ldi	r24, 0x97	; 151
    1fa2:	40 de       	rcall	.-896    	; 0x1c24 <send_cmd>
		if (send_cmd(CMD25, sector) == 0) {	/* WRITE_MULTIPLE_BLOCK */
    1fa4:	b7 01       	movw	r22, r14
    1fa6:	a6 01       	movw	r20, r12
    1fa8:	89 e1       	ldi	r24, 0x19	; 25
    1faa:	3c de       	rcall	.-904    	; 0x1c24 <send_cmd>
    1fac:	81 11       	cpse	r24, r1
    1fae:	11 c0       	rjmp	.+34     	; 0x1fd2 <disk_write+0xa0>
			do {
				if (!xmit_datablock(buff, 0xFC)) break;
    1fb0:	6c ef       	ldi	r22, 0xFC	; 252
    1fb2:	ce 01       	movw	r24, r28
    1fb4:	00 de       	rcall	.-1024   	; 0x1bb6 <xmit_datablock>
    1fb6:	89 2b       	or	r24, r25
    1fb8:	21 f0       	breq	.+8      	; 0x1fc2 <disk_write+0x90>
				buff += 512;
    1fba:	de 5f       	subi	r29, 0xFE	; 254
			} while (--count);
    1fbc:	01 50       	subi	r16, 0x01	; 1
    1fbe:	11 09       	sbc	r17, r1
    1fc0:	b9 f7       	brne	.-18     	; 0x1fb0 <disk_write+0x7e>
			if (!xmit_datablock(0, 0xFD))	/* STOP_TRAN token */
    1fc2:	6d ef       	ldi	r22, 0xFD	; 253
    1fc4:	80 e0       	ldi	r24, 0x00	; 0
    1fc6:	90 e0       	ldi	r25, 0x00	; 0
    1fc8:	f6 dd       	rcall	.-1044   	; 0x1bb6 <xmit_datablock>
    1fca:	89 2b       	or	r24, r25
    1fcc:	11 f4       	brne	.+4      	; 0x1fd2 <disk_write+0xa0>
				count = 1;
    1fce:	01 e0       	ldi	r16, 0x01	; 1
    1fd0:	10 e0       	ldi	r17, 0x00	; 0
		}
	}
	deselect();
    1fd2:	8e dd       	rcall	.-1252   	; 0x1af0 <deselect>

	return count ? RES_ERROR : RES_OK;
    1fd4:	81 e0       	ldi	r24, 0x01	; 1
    1fd6:	01 2b       	or	r16, r17
    1fd8:	29 f4       	brne	.+10     	; 0x1fe4 <disk_write+0xb2>
    1fda:	80 e0       	ldi	r24, 0x00	; 0
    1fdc:	03 c0       	rjmp	.+6      	; 0x1fe4 <disk_write+0xb2>
	const BYTE *buff,	/* Pointer to the data to be written */
	DWORD sector,		/* Start sector number (LBA) */
	UINT count			/* Sector count (1..128) */
)
{
	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;
    1fde:	83 e0       	ldi	r24, 0x03	; 3
    1fe0:	01 c0       	rjmp	.+2      	; 0x1fe4 <disk_write+0xb2>
    1fe2:	83 e0       	ldi	r24, 0x03	; 3
		}
	}
	deselect();

	return count ? RES_ERROR : RES_OK;
}
    1fe4:	df 91       	pop	r29
    1fe6:	cf 91       	pop	r28
    1fe8:	1f 91       	pop	r17
    1fea:	0f 91       	pop	r16
    1fec:	ff 90       	pop	r15
    1fee:	ef 90       	pop	r14
    1ff0:	df 90       	pop	r13
    1ff2:	cf 90       	pop	r12
    1ff4:	08 95       	ret

00001ff6 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE drv,		/* Physical drive nmuber (0) */
	BYTE ctrl,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
    1ff6:	0f 93       	push	r16
    1ff8:	1f 93       	push	r17
    1ffa:	cf 93       	push	r28
    1ffc:	df 93       	push	r29
    1ffe:	cd b7       	in	r28, 0x3d	; 61
    2000:	de b7       	in	r29, 0x3e	; 62
    2002:	60 97       	sbiw	r28, 0x10	; 16
    2004:	0f b6       	in	r0, 0x3f	; 63
    2006:	f8 94       	cli
    2008:	de bf       	out	0x3e, r29	; 62
    200a:	0f be       	out	0x3f, r0	; 63
    200c:	cd bf       	out	0x3d, r28	; 61

DSTATUS disk_status (
	BYTE drv			/* Drive number (always 0) */
)
{
	if (drv) return STA_NOINIT;
    200e:	81 11       	cpse	r24, r1
    2010:	98 c0       	rjmp	.+304    	; 0x2142 <disk_ioctl+0x14c>
	DRESULT res;
	BYTE n, csd[16];
	DWORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */
    2012:	80 91 0d 01 	lds	r24, 0x010D
    2016:	80 fd       	sbrc	r24, 0
    2018:	96 c0       	rjmp	.+300    	; 0x2146 <disk_ioctl+0x150>
    201a:	8a 01       	movw	r16, r20

	res = RES_ERROR;
	switch (ctrl) {
    201c:	61 30       	cpi	r22, 0x01	; 1
    201e:	61 f0       	breq	.+24     	; 0x2038 <disk_ioctl+0x42>
    2020:	20 f0       	brcs	.+8      	; 0x202a <disk_ioctl+0x34>
    2022:	63 30       	cpi	r22, 0x03	; 3
    2024:	09 f4       	brne	.+2      	; 0x2028 <disk_ioctl+0x32>
    2026:	7a c0       	rjmp	.+244    	; 0x211c <disk_ioctl+0x126>
    2028:	84 c0       	rjmp	.+264    	; 0x2132 <disk_ioctl+0x13c>
		case CTRL_SYNC :		/* Make sure that no pending write process */
			if (select()) res = RES_OK;
    202a:	71 dd       	rcall	.-1310   	; 0x1b0e <select>
    202c:	11 e0       	ldi	r17, 0x01	; 1
    202e:	89 2b       	or	r24, r25
    2030:	09 f4       	brne	.+2      	; 0x2034 <disk_ioctl+0x3e>
    2032:	84 c0       	rjmp	.+264    	; 0x213c <disk_ioctl+0x146>
    2034:	10 e0       	ldi	r17, 0x00	; 0
    2036:	82 c0       	rjmp	.+260    	; 0x213c <disk_ioctl+0x146>
			break;

		case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
    2038:	40 e0       	ldi	r20, 0x00	; 0
    203a:	50 e0       	ldi	r21, 0x00	; 0
    203c:	ba 01       	movw	r22, r20
    203e:	89 e0       	ldi	r24, 0x09	; 9
    2040:	f1 dd       	rcall	.-1054   	; 0x1c24 <send_cmd>
    2042:	81 11       	cpse	r24, r1
    2044:	78 c0       	rjmp	.+240    	; 0x2136 <disk_ioctl+0x140>
    2046:	60 e1       	ldi	r22, 0x10	; 16
    2048:	70 e0       	ldi	r23, 0x00	; 0
    204a:	ce 01       	movw	r24, r28
    204c:	01 96       	adiw	r24, 0x01	; 1
    204e:	7b dd       	rcall	.-1290   	; 0x1b46 <rcvr_datablock>
    2050:	89 2b       	or	r24, r25
    2052:	09 f4       	brne	.+2      	; 0x2056 <disk_ioctl+0x60>
    2054:	72 c0       	rjmp	.+228    	; 0x213a <disk_ioctl+0x144>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
    2056:	89 81       	ldd	r24, Y+1	; 0x01
    2058:	82 95       	swap	r24
    205a:	86 95       	lsr	r24
    205c:	86 95       	lsr	r24
    205e:	83 70       	andi	r24, 0x03	; 3
    2060:	81 30       	cpi	r24, 0x01	; 1
    2062:	31 f5       	brne	.+76     	; 0x20b0 <disk_ioctl+0xba>
					cs = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
    2064:	88 85       	ldd	r24, Y+8	; 0x08
    2066:	8f 73       	andi	r24, 0x3F	; 63
    2068:	90 e0       	ldi	r25, 0x00	; 0
    206a:	a0 e0       	ldi	r26, 0x00	; 0
    206c:	b0 e0       	ldi	r27, 0x00	; 0
    206e:	dc 01       	movw	r26, r24
    2070:	99 27       	eor	r25, r25
    2072:	88 27       	eor	r24, r24
    2074:	01 96       	adiw	r24, 0x01	; 1
    2076:	a1 1d       	adc	r26, r1
    2078:	b1 1d       	adc	r27, r1
    207a:	29 85       	ldd	r18, Y+9	; 0x09
    207c:	30 e0       	ldi	r19, 0x00	; 0
    207e:	32 2f       	mov	r19, r18
    2080:	22 27       	eor	r18, r18
    2082:	4a 85       	ldd	r20, Y+10	; 0x0a
    2084:	24 0f       	add	r18, r20
    2086:	31 1d       	adc	r19, r1
    2088:	82 0f       	add	r24, r18
    208a:	93 1f       	adc	r25, r19
    208c:	a1 1d       	adc	r26, r1
    208e:	b1 1d       	adc	r27, r1
					*(DWORD*)buff = cs << 10;
    2090:	07 2e       	mov	r0, r23
    2092:	7a e0       	ldi	r23, 0x0A	; 10
    2094:	88 0f       	add	r24, r24
    2096:	99 1f       	adc	r25, r25
    2098:	aa 1f       	adc	r26, r26
    209a:	bb 1f       	adc	r27, r27
    209c:	7a 95       	dec	r23
    209e:	d1 f7       	brne	.-12     	; 0x2094 <disk_ioctl+0x9e>
    20a0:	70 2d       	mov	r23, r0
    20a2:	f8 01       	movw	r30, r16
    20a4:	80 83       	st	Z, r24
    20a6:	91 83       	std	Z+1, r25	; 0x01
    20a8:	a2 83       	std	Z+2, r26	; 0x02
    20aa:	b3 83       	std	Z+3, r27	; 0x03
				} else {					/* SDC ver 1.XX or MMC */
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = cs << (n - 9);
				}
				res = RES_OK;
    20ac:	10 e0       	ldi	r17, 0x00	; 0
    20ae:	46 c0       	rjmp	.+140    	; 0x213c <disk_ioctl+0x146>
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					cs = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = cs << 10;
				} else {					/* SDC ver 1.XX or MMC */
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
    20b0:	89 85       	ldd	r24, Y+9	; 0x09
    20b2:	82 95       	swap	r24
    20b4:	86 95       	lsr	r24
    20b6:	86 95       	lsr	r24
    20b8:	83 70       	andi	r24, 0x03	; 3
    20ba:	28 85       	ldd	r18, Y+8	; 0x08
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	f4 e0       	ldi	r31, 0x04	; 4
    20c0:	2f 9f       	mul	r18, r31
    20c2:	80 0d       	add	r24, r0
    20c4:	91 1d       	adc	r25, r1
    20c6:	11 24       	eor	r1, r1
    20c8:	9c 01       	movw	r18, r24
    20ca:	2f 5f       	subi	r18, 0xFF	; 255
    20cc:	3f 4f       	sbci	r19, 0xFF	; 255
    20ce:	9f 81       	ldd	r25, Y+7	; 0x07
    20d0:	93 70       	andi	r25, 0x03	; 3
    20d2:	89 2f       	mov	r24, r25
    20d4:	90 e0       	ldi	r25, 0x00	; 0
    20d6:	98 2f       	mov	r25, r24
    20d8:	88 27       	eor	r24, r24
    20da:	99 0f       	add	r25, r25
    20dc:	99 0f       	add	r25, r25
    20de:	82 0f       	add	r24, r18
    20e0:	93 1f       	adc	r25, r19
    20e2:	a0 e0       	ldi	r26, 0x00	; 0
    20e4:	b0 e0       	ldi	r27, 0x00	; 0
			if ((send_cmd(CMD9, 0) == 0) && rcvr_datablock(csd, 16)) {
				if ((csd[0] >> 6) == 1) {	/* SDC ver 2.00 */
					cs = csd[9] + ((WORD)csd[8] << 8) + ((DWORD)(csd[7] & 63) << 16) + 1;
					*(DWORD*)buff = cs << 10;
				} else {					/* SDC ver 1.XX or MMC */
					n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
    20e6:	2e 81       	ldd	r18, Y+6	; 0x06
    20e8:	32 2f       	mov	r19, r18
    20ea:	3f 70       	andi	r19, 0x0F	; 15
    20ec:	2b 85       	ldd	r18, Y+11	; 0x0b
    20ee:	22 1f       	adc	r18, r18
    20f0:	22 27       	eor	r18, r18
    20f2:	22 1f       	adc	r18, r18
    20f4:	23 0f       	add	r18, r19
    20f6:	3a 85       	ldd	r19, Y+10	; 0x0a
    20f8:	33 70       	andi	r19, 0x03	; 3
    20fa:	33 0f       	add	r19, r19
    20fc:	23 0f       	add	r18, r19
					cs = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1;
					*(DWORD*)buff = cs << (n - 9);
    20fe:	27 50       	subi	r18, 0x07	; 7
    2100:	04 c0       	rjmp	.+8      	; 0x210a <disk_ioctl+0x114>
    2102:	88 0f       	add	r24, r24
    2104:	99 1f       	adc	r25, r25
    2106:	aa 1f       	adc	r26, r26
    2108:	bb 1f       	adc	r27, r27
    210a:	2a 95       	dec	r18
    210c:	d2 f7       	brpl	.-12     	; 0x2102 <disk_ioctl+0x10c>
    210e:	f8 01       	movw	r30, r16
    2110:	80 83       	st	Z, r24
    2112:	91 83       	std	Z+1, r25	; 0x01
    2114:	a2 83       	std	Z+2, r26	; 0x02
    2116:	b3 83       	std	Z+3, r27	; 0x03
				}
				res = RES_OK;
    2118:	10 e0       	ldi	r17, 0x00	; 0
    211a:	10 c0       	rjmp	.+32     	; 0x213c <disk_ioctl+0x146>
			}
			break;

		case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
			*(DWORD*)buff = 128;
    211c:	80 e8       	ldi	r24, 0x80	; 128
    211e:	90 e0       	ldi	r25, 0x00	; 0
    2120:	a0 e0       	ldi	r26, 0x00	; 0
    2122:	b0 e0       	ldi	r27, 0x00	; 0
    2124:	fa 01       	movw	r30, r20
    2126:	80 83       	st	Z, r24
    2128:	91 83       	std	Z+1, r25	; 0x01
    212a:	a2 83       	std	Z+2, r26	; 0x02
    212c:	b3 83       	std	Z+3, r27	; 0x03
			res = RES_OK;
    212e:	10 e0       	ldi	r17, 0x00	; 0
			break;
    2130:	05 c0       	rjmp	.+10     	; 0x213c <disk_ioctl+0x146>

		default:
			res = RES_PARERR;
    2132:	14 e0       	ldi	r17, 0x04	; 4
    2134:	03 c0       	rjmp	.+6      	; 0x213c <disk_ioctl+0x146>
	DWORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */

	res = RES_ERROR;
    2136:	11 e0       	ldi	r17, 0x01	; 1
    2138:	01 c0       	rjmp	.+2      	; 0x213c <disk_ioctl+0x146>
    213a:	11 e0       	ldi	r17, 0x01	; 1

		default:
			res = RES_PARERR;
	}

	deselect();
    213c:	d9 dc       	rcall	.-1614   	; 0x1af0 <deselect>

	return res;
    213e:	81 2f       	mov	r24, r17
    2140:	03 c0       	rjmp	.+6      	; 0x2148 <disk_ioctl+0x152>
	DRESULT res;
	BYTE n, csd[16];
	DWORD cs;


	if (disk_status(drv) & STA_NOINIT) return RES_NOTRDY;	/* Check if card is in the socket */
    2142:	83 e0       	ldi	r24, 0x03	; 3
    2144:	01 c0       	rjmp	.+2      	; 0x2148 <disk_ioctl+0x152>
    2146:	83 e0       	ldi	r24, 0x03	; 3
	}

	deselect();

	return res;
}
    2148:	60 96       	adiw	r28, 0x10	; 16
    214a:	0f b6       	in	r0, 0x3f	; 63
    214c:	f8 94       	cli
    214e:	de bf       	out	0x3e, r29	; 62
    2150:	0f be       	out	0x3f, r0	; 63
    2152:	cd bf       	out	0x3d, r28	; 61
    2154:	df 91       	pop	r29
    2156:	cf 91       	pop	r28
    2158:	1f 91       	pop	r17
    215a:	0f 91       	pop	r16
    215c:	08 95       	ret

0000215e <mem_cpy>:
			FREE_BUF();
		}
	}

	LEAVE_FF(dp->fs, res);
}
    215e:	cf 93       	push	r28
    2160:	df 93       	push	r29
    2162:	42 30       	cpi	r20, 0x02	; 2
    2164:	51 05       	cpc	r21, r1
    2166:	c0 f0       	brcs	.+48     	; 0x2198 <mem_cpy+0x3a>
    2168:	db 01       	movw	r26, r22
    216a:	fc 01       	movw	r30, r24
    216c:	9a 01       	movw	r18, r20
    216e:	cd 91       	ld	r28, X+
    2170:	dd 91       	ld	r29, X+
    2172:	c1 93       	st	Z+, r28
    2174:	d1 93       	st	Z+, r29
    2176:	22 50       	subi	r18, 0x02	; 2
    2178:	31 09       	sbc	r19, r1
    217a:	22 30       	cpi	r18, 0x02	; 2
    217c:	31 05       	cpc	r19, r1
    217e:	b8 f7       	brcc	.-18     	; 0x216e <mem_cpy+0x10>
    2180:	9a 01       	movw	r18, r20
    2182:	22 50       	subi	r18, 0x02	; 2
    2184:	31 09       	sbc	r19, r1
    2186:	2e 7f       	andi	r18, 0xFE	; 254
    2188:	2e 5f       	subi	r18, 0xFE	; 254
    218a:	3f 4f       	sbci	r19, 0xFF	; 255
    218c:	82 0f       	add	r24, r18
    218e:	93 1f       	adc	r25, r19
    2190:	62 0f       	add	r22, r18
    2192:	73 1f       	adc	r23, r19
    2194:	41 70       	andi	r20, 0x01	; 1
    2196:	55 27       	eor	r21, r21
    2198:	41 15       	cp	r20, r1
    219a:	51 05       	cpc	r21, r1
    219c:	49 f0       	breq	.+18     	; 0x21b0 <mem_cpy+0x52>
    219e:	db 01       	movw	r26, r22
    21a0:	fc 01       	movw	r30, r24
    21a2:	48 0f       	add	r20, r24
    21a4:	59 1f       	adc	r21, r25
    21a6:	9d 91       	ld	r25, X+
    21a8:	91 93       	st	Z+, r25
    21aa:	e4 17       	cp	r30, r20
    21ac:	f5 07       	cpc	r31, r21
    21ae:	d9 f7       	brne	.-10     	; 0x21a6 <mem_cpy+0x48>
    21b0:	df 91       	pop	r29
    21b2:	cf 91       	pop	r28
    21b4:	08 95       	ret

000021b6 <ld_clust>:
    21b6:	0f 93       	push	r16
    21b8:	1f 93       	push	r17
    21ba:	dc 01       	movw	r26, r24
    21bc:	fb 01       	movw	r30, r22
    21be:	62 8d       	ldd	r22, Z+26	; 0x1a
    21c0:	73 8d       	ldd	r23, Z+27	; 0x1b
    21c2:	80 e0       	ldi	r24, 0x00	; 0
    21c4:	90 e0       	ldi	r25, 0x00	; 0
    21c6:	2c 91       	ld	r18, X
    21c8:	23 30       	cpi	r18, 0x03	; 3
    21ca:	59 f4       	brne	.+22     	; 0x21e2 <ld_clust+0x2c>
    21cc:	04 89       	ldd	r16, Z+20	; 0x14
    21ce:	15 89       	ldd	r17, Z+21	; 0x15
    21d0:	20 e0       	ldi	r18, 0x00	; 0
    21d2:	30 e0       	ldi	r19, 0x00	; 0
    21d4:	98 01       	movw	r18, r16
    21d6:	11 27       	eor	r17, r17
    21d8:	00 27       	eor	r16, r16
    21da:	60 2b       	or	r22, r16
    21dc:	71 2b       	or	r23, r17
    21de:	82 2b       	or	r24, r18
    21e0:	93 2b       	or	r25, r19
    21e2:	1f 91       	pop	r17
    21e4:	0f 91       	pop	r16
    21e6:	08 95       	ret

000021e8 <get_fileinfo>:
    21e8:	0f 93       	push	r16
    21ea:	1f 93       	push	r17
    21ec:	cf 93       	push	r28
    21ee:	df 93       	push	r29
    21f0:	eb 01       	movw	r28, r22
    21f2:	fb 01       	movw	r30, r22
    21f4:	39 96       	adiw	r30, 0x09	; 9
    21f6:	dc 01       	movw	r26, r24
    21f8:	1e 96       	adiw	r26, 0x0e	; 14
    21fa:	4d 91       	ld	r20, X+
    21fc:	5d 91       	ld	r21, X+
    21fe:	6d 91       	ld	r22, X+
    2200:	7c 91       	ld	r23, X
    2202:	51 97       	sbiw	r26, 0x11	; 17
    2204:	45 2b       	or	r20, r21
    2206:	46 2b       	or	r20, r22
    2208:	47 2b       	or	r20, r23
    220a:	a9 f1       	breq	.+106    	; 0x2276 <get_fileinfo+0x8e>
    220c:	52 96       	adiw	r26, 0x12	; 18
    220e:	4d 91       	ld	r20, X+
    2210:	5c 91       	ld	r21, X
    2212:	53 97       	sbiw	r26, 0x13	; 19
    2214:	da 01       	movw	r26, r20
    2216:	80 e0       	ldi	r24, 0x00	; 0
    2218:	90 e0       	ldi	r25, 0x00	; 0
    221a:	6e e2       	ldi	r22, 0x2E	; 46
    221c:	35 ee       	ldi	r19, 0xE5	; 229
    221e:	01 96       	adiw	r24, 0x01	; 1
    2220:	2d 91       	ld	r18, X+
    2222:	20 32       	cpi	r18, 0x20	; 32
    2224:	51 f0       	breq	.+20     	; 0x223a <get_fileinfo+0x52>
    2226:	25 30       	cpi	r18, 0x05	; 5
    2228:	09 f4       	brne	.+2      	; 0x222c <get_fileinfo+0x44>
    222a:	23 2f       	mov	r18, r19
    222c:	89 30       	cpi	r24, 0x09	; 9
    222e:	91 05       	cpc	r25, r1
    2230:	11 f4       	brne	.+4      	; 0x2236 <get_fileinfo+0x4e>
    2232:	60 83       	st	Z, r22
    2234:	31 96       	adiw	r30, 0x01	; 1
    2236:	20 83       	st	Z, r18
    2238:	31 96       	adiw	r30, 0x01	; 1
    223a:	8b 30       	cpi	r24, 0x0B	; 11
    223c:	91 05       	cpc	r25, r1
    223e:	79 f7       	brne	.-34     	; 0x221e <get_fileinfo+0x36>
    2240:	da 01       	movw	r26, r20
    2242:	1b 96       	adiw	r26, 0x0b	; 11
    2244:	8c 91       	ld	r24, X
    2246:	1b 97       	sbiw	r26, 0x0b	; 11
    2248:	88 87       	std	Y+8, r24	; 0x08
    224a:	5c 96       	adiw	r26, 0x1c	; 28
    224c:	0d 91       	ld	r16, X+
    224e:	1d 91       	ld	r17, X+
    2250:	2d 91       	ld	r18, X+
    2252:	3c 91       	ld	r19, X
    2254:	5f 97       	sbiw	r26, 0x1f	; 31
    2256:	08 83       	st	Y, r16
    2258:	19 83       	std	Y+1, r17	; 0x01
    225a:	2a 83       	std	Y+2, r18	; 0x02
    225c:	3b 83       	std	Y+3, r19	; 0x03
    225e:	58 96       	adiw	r26, 0x18	; 24
    2260:	8d 91       	ld	r24, X+
    2262:	9c 91       	ld	r25, X
    2264:	59 97       	sbiw	r26, 0x19	; 25
    2266:	9d 83       	std	Y+5, r25	; 0x05
    2268:	8c 83       	std	Y+4, r24	; 0x04
    226a:	56 96       	adiw	r26, 0x16	; 22
    226c:	8d 91       	ld	r24, X+
    226e:	9c 91       	ld	r25, X
    2270:	57 97       	sbiw	r26, 0x17	; 23
    2272:	9f 83       	std	Y+7, r25	; 0x07
    2274:	8e 83       	std	Y+6, r24	; 0x06
    2276:	10 82       	st	Z, r1
    2278:	df 91       	pop	r29
    227a:	cf 91       	pop	r28
    227c:	1f 91       	pop	r17
    227e:	0f 91       	pop	r16
    2280:	08 95       	ret

00002282 <get_ldnumber>:
    2282:	cf 93       	push	r28
    2284:	df 93       	push	r29
    2286:	ec 01       	movw	r28, r24
    2288:	a8 81       	ld	r26, Y
    228a:	b9 81       	ldd	r27, Y+1	; 0x01
    228c:	10 97       	sbiw	r26, 0x00	; 0
    228e:	f9 f0       	breq	.+62     	; 0x22ce <get_ldnumber+0x4c>
    2290:	4c 91       	ld	r20, X
    2292:	41 32       	cpi	r20, 0x21	; 33
    2294:	58 f0       	brcs	.+22     	; 0x22ac <get_ldnumber+0x2a>
    2296:	4a 33       	cpi	r20, 0x3A	; 58
    2298:	31 f1       	breq	.+76     	; 0x22e6 <get_ldnumber+0x64>
    229a:	fd 01       	movw	r30, r26
    229c:	31 96       	adiw	r30, 0x01	; 1
    229e:	9f 01       	movw	r18, r30
    22a0:	91 91       	ld	r25, Z+
    22a2:	91 32       	cpi	r25, 0x21	; 33
    22a4:	28 f0       	brcs	.+10     	; 0x22b0 <get_ldnumber+0x2e>
    22a6:	9a 33       	cpi	r25, 0x3A	; 58
    22a8:	d1 f7       	brne	.-12     	; 0x229e <get_ldnumber+0x1c>
    22aa:	04 c0       	rjmp	.+8      	; 0x22b4 <get_ldnumber+0x32>
    22ac:	94 2f       	mov	r25, r20
    22ae:	9d 01       	movw	r18, r26
    22b0:	9a 33       	cpi	r25, 0x3A	; 58
    22b2:	81 f4       	brne	.+32     	; 0x22d4 <get_ldnumber+0x52>
    22b4:	cd 01       	movw	r24, r26
    22b6:	01 96       	adiw	r24, 0x01	; 1
    22b8:	28 17       	cp	r18, r24
    22ba:	39 07       	cpc	r19, r25
    22bc:	71 f4       	brne	.+28     	; 0x22da <get_ldnumber+0x58>
    22be:	40 33       	cpi	r20, 0x30	; 48
    22c0:	79 f4       	brne	.+30     	; 0x22e0 <get_ldnumber+0x5e>
    22c2:	12 96       	adiw	r26, 0x02	; 2
    22c4:	b9 83       	std	Y+1, r27	; 0x01
    22c6:	a8 83       	st	Y, r26
    22c8:	80 e0       	ldi	r24, 0x00	; 0
    22ca:	90 e0       	ldi	r25, 0x00	; 0
    22cc:	0e c0       	rjmp	.+28     	; 0x22ea <get_ldnumber+0x68>
    22ce:	8f ef       	ldi	r24, 0xFF	; 255
    22d0:	9f ef       	ldi	r25, 0xFF	; 255
    22d2:	0b c0       	rjmp	.+22     	; 0x22ea <get_ldnumber+0x68>
    22d4:	80 e0       	ldi	r24, 0x00	; 0
    22d6:	90 e0       	ldi	r25, 0x00	; 0
    22d8:	08 c0       	rjmp	.+16     	; 0x22ea <get_ldnumber+0x68>
    22da:	8f ef       	ldi	r24, 0xFF	; 255
    22dc:	9f ef       	ldi	r25, 0xFF	; 255
    22de:	05 c0       	rjmp	.+10     	; 0x22ea <get_ldnumber+0x68>
    22e0:	8f ef       	ldi	r24, 0xFF	; 255
    22e2:	9f ef       	ldi	r25, 0xFF	; 255
    22e4:	02 c0       	rjmp	.+4      	; 0x22ea <get_ldnumber+0x68>
    22e6:	9d 01       	movw	r18, r26
    22e8:	e5 cf       	rjmp	.-54     	; 0x22b4 <get_ldnumber+0x32>
    22ea:	df 91       	pop	r29
    22ec:	cf 91       	pop	r28
    22ee:	08 95       	ret

000022f0 <sync_window>:
    22f0:	8f 92       	push	r8
    22f2:	9f 92       	push	r9
    22f4:	af 92       	push	r10
    22f6:	bf 92       	push	r11
    22f8:	cf 92       	push	r12
    22fa:	df 92       	push	r13
    22fc:	ef 92       	push	r14
    22fe:	ff 92       	push	r15
    2300:	0f 93       	push	r16
    2302:	1f 93       	push	r17
    2304:	cf 93       	push	r28
    2306:	df 93       	push	r29
    2308:	fc 01       	movw	r30, r24
    230a:	24 81       	ldd	r18, Z+4	; 0x04
    230c:	22 23       	and	r18, r18
    230e:	09 f4       	brne	.+2      	; 0x2312 <sync_window+0x22>
    2310:	44 c0       	rjmp	.+136    	; 0x239a <sync_window+0xaa>
    2312:	ec 01       	movw	r28, r24
    2314:	c2 a4       	ldd	r12, Z+42	; 0x2a
    2316:	d3 a4       	ldd	r13, Z+43	; 0x2b
    2318:	e4 a4       	ldd	r14, Z+44	; 0x2c
    231a:	f5 a4       	ldd	r15, Z+45	; 0x2d
    231c:	5c 01       	movw	r10, r24
    231e:	fe e2       	ldi	r31, 0x2E	; 46
    2320:	af 0e       	add	r10, r31
    2322:	b1 1c       	adc	r11, r1
    2324:	01 e0       	ldi	r16, 0x01	; 1
    2326:	10 e0       	ldi	r17, 0x00	; 0
    2328:	a7 01       	movw	r20, r14
    232a:	96 01       	movw	r18, r12
    232c:	b5 01       	movw	r22, r10
    232e:	89 81       	ldd	r24, Y+1	; 0x01
    2330:	00 de       	rcall	.-1024   	; 0x1f32 <disk_write>
    2332:	81 11       	cpse	r24, r1
    2334:	34 c0       	rjmp	.+104    	; 0x239e <sync_window+0xae>
    2336:	1c 82       	std	Y+4, r1	; 0x04
    2338:	8e 8d       	ldd	r24, Y+30	; 0x1e
    233a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    233c:	a8 a1       	ldd	r26, Y+32	; 0x20
    233e:	b9 a1       	ldd	r27, Y+33	; 0x21
    2340:	b7 01       	movw	r22, r14
    2342:	a6 01       	movw	r20, r12
    2344:	48 1b       	sub	r20, r24
    2346:	59 0b       	sbc	r21, r25
    2348:	6a 0b       	sbc	r22, r26
    234a:	7b 0b       	sbc	r23, r27
    234c:	8e 89       	ldd	r24, Y+22	; 0x16
    234e:	9f 89       	ldd	r25, Y+23	; 0x17
    2350:	a8 8d       	ldd	r26, Y+24	; 0x18
    2352:	b9 8d       	ldd	r27, Y+25	; 0x19
    2354:	48 17       	cp	r20, r24
    2356:	59 07       	cpc	r21, r25
    2358:	6a 07       	cpc	r22, r26
    235a:	7b 07       	cpc	r23, r27
    235c:	10 f5       	brcc	.+68     	; 0x23a2 <sync_window+0xb2>
    235e:	8b 80       	ldd	r8, Y+3	; 0x03
    2360:	91 2c       	mov	r9, r1
    2362:	82 e0       	ldi	r24, 0x02	; 2
    2364:	88 16       	cp	r8, r24
    2366:	91 04       	cpc	r9, r1
    2368:	f0 f0       	brcs	.+60     	; 0x23a6 <sync_window+0xb6>
    236a:	8e 89       	ldd	r24, Y+22	; 0x16
    236c:	9f 89       	ldd	r25, Y+23	; 0x17
    236e:	a8 8d       	ldd	r26, Y+24	; 0x18
    2370:	b9 8d       	ldd	r27, Y+25	; 0x19
    2372:	c8 0e       	add	r12, r24
    2374:	d9 1e       	adc	r13, r25
    2376:	ea 1e       	adc	r14, r26
    2378:	fb 1e       	adc	r15, r27
    237a:	01 e0       	ldi	r16, 0x01	; 1
    237c:	10 e0       	ldi	r17, 0x00	; 0
    237e:	a7 01       	movw	r20, r14
    2380:	96 01       	movw	r18, r12
    2382:	b5 01       	movw	r22, r10
    2384:	89 81       	ldd	r24, Y+1	; 0x01
    2386:	d5 dd       	rcall	.-1110   	; 0x1f32 <disk_write>
    2388:	e1 e0       	ldi	r30, 0x01	; 1
    238a:	8e 1a       	sub	r8, r30
    238c:	91 08       	sbc	r9, r1
    238e:	f1 e0       	ldi	r31, 0x01	; 1
    2390:	8f 16       	cp	r8, r31
    2392:	91 04       	cpc	r9, r1
    2394:	51 f7       	brne	.-44     	; 0x236a <sync_window+0x7a>
    2396:	80 e0       	ldi	r24, 0x00	; 0
    2398:	07 c0       	rjmp	.+14     	; 0x23a8 <sync_window+0xb8>
    239a:	80 e0       	ldi	r24, 0x00	; 0
    239c:	05 c0       	rjmp	.+10     	; 0x23a8 <sync_window+0xb8>
    239e:	81 e0       	ldi	r24, 0x01	; 1
    23a0:	03 c0       	rjmp	.+6      	; 0x23a8 <sync_window+0xb8>
    23a2:	80 e0       	ldi	r24, 0x00	; 0
    23a4:	01 c0       	rjmp	.+2      	; 0x23a8 <sync_window+0xb8>
    23a6:	80 e0       	ldi	r24, 0x00	; 0
    23a8:	df 91       	pop	r29
    23aa:	cf 91       	pop	r28
    23ac:	1f 91       	pop	r17
    23ae:	0f 91       	pop	r16
    23b0:	ff 90       	pop	r15
    23b2:	ef 90       	pop	r14
    23b4:	df 90       	pop	r13
    23b6:	cf 90       	pop	r12
    23b8:	bf 90       	pop	r11
    23ba:	af 90       	pop	r10
    23bc:	9f 90       	pop	r9
    23be:	8f 90       	pop	r8
    23c0:	08 95       	ret

000023c2 <move_window>:
    23c2:	8f 92       	push	r8
    23c4:	9f 92       	push	r9
    23c6:	af 92       	push	r10
    23c8:	bf 92       	push	r11
    23ca:	ff 92       	push	r15
    23cc:	0f 93       	push	r16
    23ce:	1f 93       	push	r17
    23d0:	cf 93       	push	r28
    23d2:	df 93       	push	r29
    23d4:	ec 01       	movw	r28, r24
    23d6:	4a 01       	movw	r8, r20
    23d8:	5b 01       	movw	r10, r22
    23da:	8a a5       	ldd	r24, Y+42	; 0x2a
    23dc:	9b a5       	ldd	r25, Y+43	; 0x2b
    23de:	ac a5       	ldd	r26, Y+44	; 0x2c
    23e0:	bd a5       	ldd	r27, Y+45	; 0x2d
    23e2:	84 17       	cp	r24, r20
    23e4:	95 07       	cpc	r25, r21
    23e6:	a6 07       	cpc	r26, r22
    23e8:	b7 07       	cpc	r27, r23
    23ea:	d9 f0       	breq	.+54     	; 0x2422 <move_window+0x60>
    23ec:	ce 01       	movw	r24, r28
    23ee:	80 df       	rcall	.-256    	; 0x22f0 <sync_window>
    23f0:	f8 2e       	mov	r15, r24
    23f2:	81 11       	cpse	r24, r1
    23f4:	17 c0       	rjmp	.+46     	; 0x2424 <move_window+0x62>
    23f6:	01 e0       	ldi	r16, 0x01	; 1
    23f8:	10 e0       	ldi	r17, 0x00	; 0
    23fa:	a5 01       	movw	r20, r10
    23fc:	94 01       	movw	r18, r8
    23fe:	be 01       	movw	r22, r28
    2400:	62 5d       	subi	r22, 0xD2	; 210
    2402:	7f 4f       	sbci	r23, 0xFF	; 255
    2404:	89 81       	ldd	r24, Y+1	; 0x01
    2406:	49 dd       	rcall	.-1390   	; 0x1e9a <disk_read>
    2408:	88 23       	and	r24, r24
    240a:	31 f0       	breq	.+12     	; 0x2418 <move_window+0x56>
    240c:	ff 24       	eor	r15, r15
    240e:	f3 94       	inc	r15
    2410:	88 24       	eor	r8, r8
    2412:	8a 94       	dec	r8
    2414:	98 2c       	mov	r9, r8
    2416:	54 01       	movw	r10, r8
    2418:	8a a6       	std	Y+42, r8	; 0x2a
    241a:	9b a6       	std	Y+43, r9	; 0x2b
    241c:	ac a6       	std	Y+44, r10	; 0x2c
    241e:	bd a6       	std	Y+45, r11	; 0x2d
    2420:	01 c0       	rjmp	.+2      	; 0x2424 <move_window+0x62>
    2422:	f1 2c       	mov	r15, r1
    2424:	8f 2d       	mov	r24, r15
    2426:	df 91       	pop	r29
    2428:	cf 91       	pop	r28
    242a:	1f 91       	pop	r17
    242c:	0f 91       	pop	r16
    242e:	ff 90       	pop	r15
    2430:	bf 90       	pop	r11
    2432:	af 90       	pop	r10
    2434:	9f 90       	pop	r9
    2436:	8f 90       	pop	r8
    2438:	08 95       	ret

0000243a <check_fs>:
    243a:	cf 93       	push	r28
    243c:	df 93       	push	r29
    243e:	ec 01       	movw	r28, r24
    2440:	1c 82       	std	Y+4, r1	; 0x04
    2442:	8f ef       	ldi	r24, 0xFF	; 255
    2444:	9f ef       	ldi	r25, 0xFF	; 255
    2446:	dc 01       	movw	r26, r24
    2448:	8a a7       	std	Y+42, r24	; 0x2a
    244a:	9b a7       	std	Y+43, r25	; 0x2b
    244c:	ac a7       	std	Y+44, r26	; 0x2c
    244e:	bd a7       	std	Y+45, r27	; 0x2d
    2450:	ce 01       	movw	r24, r28
    2452:	b7 df       	rcall	.-146    	; 0x23c2 <move_window>
    2454:	81 11       	cpse	r24, r1
    2456:	23 c0       	rjmp	.+70     	; 0x249e <check_fs+0x64>
    2458:	fe 01       	movw	r30, r28
    245a:	e4 5d       	subi	r30, 0xD4	; 212
    245c:	fd 4f       	sbci	r31, 0xFD	; 253
    245e:	80 81       	ld	r24, Z
    2460:	91 81       	ldd	r25, Z+1	; 0x01
    2462:	85 35       	cpi	r24, 0x55	; 85
    2464:	9a 4a       	sbci	r25, 0xAA	; 170
    2466:	e9 f4       	brne	.+58     	; 0x24a2 <check_fs+0x68>
    2468:	e8 5c       	subi	r30, 0xC8	; 200
    246a:	f1 40       	sbci	r31, 0x01	; 1
    246c:	80 81       	ld	r24, Z
    246e:	91 81       	ldd	r25, Z+1	; 0x01
    2470:	a2 81       	ldd	r26, Z+2	; 0x02
    2472:	b3 81       	ldd	r27, Z+3	; 0x03
    2474:	bb 27       	eor	r27, r27
    2476:	86 34       	cpi	r24, 0x46	; 70
    2478:	91 44       	sbci	r25, 0x41	; 65
    247a:	a4 45       	sbci	r26, 0x54	; 84
    247c:	b1 05       	cpc	r27, r1
    247e:	99 f0       	breq	.+38     	; 0x24a6 <check_fs+0x6c>
    2480:	c0 58       	subi	r28, 0x80	; 128
    2482:	df 4f       	sbci	r29, 0xFF	; 255
    2484:	48 81       	ld	r20, Y
    2486:	59 81       	ldd	r21, Y+1	; 0x01
    2488:	6a 81       	ldd	r22, Y+2	; 0x02
    248a:	7b 81       	ldd	r23, Y+3	; 0x03
    248c:	77 27       	eor	r23, r23
    248e:	81 e0       	ldi	r24, 0x01	; 1
    2490:	46 34       	cpi	r20, 0x46	; 70
    2492:	51 44       	sbci	r21, 0x41	; 65
    2494:	64 45       	sbci	r22, 0x54	; 84
    2496:	71 05       	cpc	r23, r1
    2498:	39 f4       	brne	.+14     	; 0x24a8 <check_fs+0x6e>
    249a:	80 e0       	ldi	r24, 0x00	; 0
    249c:	05 c0       	rjmp	.+10     	; 0x24a8 <check_fs+0x6e>
    249e:	83 e0       	ldi	r24, 0x03	; 3
    24a0:	03 c0       	rjmp	.+6      	; 0x24a8 <check_fs+0x6e>
    24a2:	82 e0       	ldi	r24, 0x02	; 2
    24a4:	01 c0       	rjmp	.+2      	; 0x24a8 <check_fs+0x6e>
    24a6:	80 e0       	ldi	r24, 0x00	; 0
    24a8:	df 91       	pop	r29
    24aa:	cf 91       	pop	r28
    24ac:	08 95       	ret

000024ae <validate>:
    24ae:	00 97       	sbiw	r24, 0x00	; 0
    24b0:	c1 f0       	breq	.+48     	; 0x24e2 <validate+0x34>
    24b2:	dc 01       	movw	r26, r24
    24b4:	ed 91       	ld	r30, X+
    24b6:	fc 91       	ld	r31, X
    24b8:	11 97       	sbiw	r26, 0x01	; 1
    24ba:	30 97       	sbiw	r30, 0x00	; 0
    24bc:	a1 f0       	breq	.+40     	; 0x24e6 <validate+0x38>
    24be:	20 81       	ld	r18, Z
    24c0:	22 23       	and	r18, r18
    24c2:	99 f0       	breq	.+38     	; 0x24ea <validate+0x3c>
    24c4:	26 81       	ldd	r18, Z+6	; 0x06
    24c6:	37 81       	ldd	r19, Z+7	; 0x07
    24c8:	12 96       	adiw	r26, 0x02	; 2
    24ca:	8d 91       	ld	r24, X+
    24cc:	9c 91       	ld	r25, X
    24ce:	13 97       	sbiw	r26, 0x03	; 3
    24d0:	28 17       	cp	r18, r24
    24d2:	39 07       	cpc	r19, r25
    24d4:	61 f4       	brne	.+24     	; 0x24ee <validate+0x40>
    24d6:	81 81       	ldd	r24, Z+1	; 0x01
    24d8:	20 dc       	rcall	.-1984   	; 0x1d1a <disk_status>
    24da:	80 fd       	sbrc	r24, 0
    24dc:	0a c0       	rjmp	.+20     	; 0x24f2 <validate+0x44>
    24de:	80 e0       	ldi	r24, 0x00	; 0
    24e0:	08 95       	ret
    24e2:	89 e0       	ldi	r24, 0x09	; 9
    24e4:	08 95       	ret
    24e6:	89 e0       	ldi	r24, 0x09	; 9
    24e8:	08 95       	ret
    24ea:	89 e0       	ldi	r24, 0x09	; 9
    24ec:	08 95       	ret
    24ee:	89 e0       	ldi	r24, 0x09	; 9
    24f0:	08 95       	ret
    24f2:	83 e0       	ldi	r24, 0x03	; 3
    24f4:	08 95       	ret

000024f6 <find_volume>:
    24f6:	2f 92       	push	r2
    24f8:	3f 92       	push	r3
    24fa:	4f 92       	push	r4
    24fc:	5f 92       	push	r5
    24fe:	6f 92       	push	r6
    2500:	7f 92       	push	r7
    2502:	8f 92       	push	r8
    2504:	9f 92       	push	r9
    2506:	af 92       	push	r10
    2508:	bf 92       	push	r11
    250a:	cf 92       	push	r12
    250c:	df 92       	push	r13
    250e:	ef 92       	push	r14
    2510:	ff 92       	push	r15
    2512:	0f 93       	push	r16
    2514:	1f 93       	push	r17
    2516:	cf 93       	push	r28
    2518:	df 93       	push	r29
    251a:	cd b7       	in	r28, 0x3d	; 61
    251c:	de b7       	in	r29, 0x3e	; 62
    251e:	6d 97       	sbiw	r28, 0x1d	; 29
    2520:	0f b6       	in	r0, 0x3f	; 63
    2522:	f8 94       	cli
    2524:	de bf       	out	0x3e, r29	; 62
    2526:	0f be       	out	0x3f, r0	; 63
    2528:	cd bf       	out	0x3d, r28	; 61
    252a:	6c 01       	movw	r12, r24
    252c:	cb 01       	movw	r24, r22
    252e:	b4 2e       	mov	r11, r20
    2530:	d6 01       	movw	r26, r12
    2532:	1d 92       	st	X+, r1
    2534:	1c 92       	st	X, r1
    2536:	a5 de       	rcall	.-694    	; 0x2282 <get_ldnumber>
    2538:	7c 01       	movw	r14, r24
    253a:	99 23       	and	r25, r25
    253c:	0c f4       	brge	.+2      	; 0x2540 <find_volume+0x4a>
    253e:	00 c2       	rjmp	.+1024   	; 0x2940 <find_volume+0x44a>
    2540:	fc 01       	movw	r30, r24
    2542:	ee 0f       	add	r30, r30
    2544:	ff 1f       	adc	r31, r31
    2546:	ea 5d       	subi	r30, 0xDA	; 218
    2548:	f9 4f       	sbci	r31, 0xF9	; 249
    254a:	00 81       	ld	r16, Z
    254c:	11 81       	ldd	r17, Z+1	; 0x01
    254e:	01 15       	cp	r16, r1
    2550:	11 05       	cpc	r17, r1
    2552:	09 f4       	brne	.+2      	; 0x2556 <find_volume+0x60>
    2554:	f7 c1       	rjmp	.+1006   	; 0x2944 <find_volume+0x44e>
    2556:	f6 01       	movw	r30, r12
    2558:	11 83       	std	Z+1, r17	; 0x01
    255a:	00 83       	st	Z, r16
    255c:	d8 01       	movw	r26, r16
    255e:	8c 91       	ld	r24, X
    2560:	88 23       	and	r24, r24
    2562:	61 f0       	breq	.+24     	; 0x257c <find_volume+0x86>
    2564:	11 96       	adiw	r26, 0x01	; 1
    2566:	8c 91       	ld	r24, X
    2568:	d8 db       	rcall	.-2128   	; 0x1d1a <disk_status>
    256a:	80 fd       	sbrc	r24, 0
    256c:	07 c0       	rjmp	.+14     	; 0x257c <find_volume+0x86>
    256e:	bb 20       	and	r11, r11
    2570:	09 f4       	brne	.+2      	; 0x2574 <find_volume+0x7e>
    2572:	ea c1       	rjmp	.+980    	; 0x2948 <find_volume+0x452>
    2574:	82 ff       	sbrs	r24, 2
    2576:	ea c1       	rjmp	.+980    	; 0x294c <find_volume+0x456>
    2578:	8a e0       	ldi	r24, 0x0A	; 10
    257a:	8a c2       	rjmp	.+1300   	; 0x2a90 <find_volume+0x59a>
    257c:	f8 01       	movw	r30, r16
    257e:	10 82       	st	Z, r1
    2580:	e1 82       	std	Z+1, r14	; 0x01
    2582:	8e 2d       	mov	r24, r14
    2584:	d1 db       	rcall	.-2142   	; 0x1d28 <disk_initialize>
    2586:	80 fd       	sbrc	r24, 0
    2588:	e3 c1       	rjmp	.+966    	; 0x2950 <find_volume+0x45a>
    258a:	bb 20       	and	r11, r11
    258c:	09 f4       	brne	.+2      	; 0x2590 <find_volume+0x9a>
    258e:	00 c2       	rjmp	.+1024   	; 0x2990 <find_volume+0x49a>
    2590:	82 fd       	sbrc	r24, 2
    2592:	e0 c1       	rjmp	.+960    	; 0x2954 <find_volume+0x45e>
    2594:	fd c1       	rjmp	.+1018   	; 0x2990 <find_volume+0x49a>
    2596:	80 81       	ld	r24, Z
    2598:	88 23       	and	r24, r24
    259a:	29 f0       	breq	.+10     	; 0x25a6 <find_volume+0xb0>
    259c:	44 80       	ldd	r4, Z+4	; 0x04
    259e:	55 80       	ldd	r5, Z+5	; 0x05
    25a0:	66 80       	ldd	r6, Z+6	; 0x06
    25a2:	77 80       	ldd	r7, Z+7	; 0x07
    25a4:	04 c0       	rjmp	.+8      	; 0x25ae <find_volume+0xb8>
    25a6:	4e 2c       	mov	r4, r14
    25a8:	5f 2c       	mov	r5, r15
    25aa:	67 2e       	mov	r6, r23
    25ac:	76 2e       	mov	r7, r22
    25ae:	d9 01       	movw	r26, r18
    25b0:	4d 92       	st	X+, r4
    25b2:	5d 92       	st	X+, r5
    25b4:	6d 92       	st	X+, r6
    25b6:	7d 92       	st	X+, r7
    25b8:	9d 01       	movw	r18, r26
    25ba:	70 96       	adiw	r30, 0x10	; 16
    25bc:	e4 17       	cp	r30, r20
    25be:	f5 07       	cpc	r31, r21
    25c0:	51 f7       	brne	.-44     	; 0x2596 <find_volume+0xa0>
    25c2:	4e 01       	movw	r8, r28
    25c4:	b1 e1       	ldi	r27, 0x11	; 17
    25c6:	8b 0e       	add	r8, r27
    25c8:	91 1c       	adc	r9, r1
    25ca:	68 94       	set
    25cc:	77 24       	eor	r7, r7
    25ce:	71 f8       	bld	r7, 1
    25d0:	f5 01       	movw	r30, r10
    25d2:	c1 90       	ld	r12, Z+
    25d4:	d1 90       	ld	r13, Z+
    25d6:	e1 90       	ld	r14, Z+
    25d8:	f1 90       	ld	r15, Z+
    25da:	5f 01       	movw	r10, r30
    25dc:	c1 14       	cp	r12, r1
    25de:	d1 04       	cpc	r13, r1
    25e0:	e1 04       	cpc	r14, r1
    25e2:	f1 04       	cpc	r15, r1
    25e4:	39 f0       	breq	.+14     	; 0x25f4 <find_volume+0xfe>
    25e6:	b7 01       	movw	r22, r14
    25e8:	a6 01       	movw	r20, r12
    25ea:	c8 01       	movw	r24, r16
    25ec:	26 df       	rcall	.-436    	; 0x243a <check_fs>
    25ee:	81 11       	cpse	r24, r1
    25f0:	02 c0       	rjmp	.+4      	; 0x25f6 <find_volume+0x100>
    25f2:	08 c0       	rjmp	.+16     	; 0x2604 <find_volume+0x10e>
    25f4:	87 2d       	mov	r24, r7
    25f6:	a8 14       	cp	r10, r8
    25f8:	b9 04       	cpc	r11, r9
    25fa:	51 f7       	brne	.-44     	; 0x25d0 <find_volume+0xda>
    25fc:	03 c0       	rjmp	.+6      	; 0x2604 <find_volume+0x10e>
    25fe:	c1 2c       	mov	r12, r1
    2600:	d1 2c       	mov	r13, r1
    2602:	76 01       	movw	r14, r12
    2604:	83 30       	cpi	r24, 0x03	; 3
    2606:	09 f4       	brne	.+2      	; 0x260a <find_volume+0x114>
    2608:	a7 c1       	rjmp	.+846    	; 0x2958 <find_volume+0x462>
    260a:	81 11       	cpse	r24, r1
    260c:	a7 c1       	rjmp	.+846    	; 0x295c <find_volume+0x466>
    260e:	d8 01       	movw	r26, r16
    2610:	d9 96       	adiw	r26, 0x39	; 57
    2612:	8d 91       	ld	r24, X+
    2614:	9c 91       	ld	r25, X
    2616:	da 97       	sbiw	r26, 0x3a	; 58
    2618:	81 15       	cp	r24, r1
    261a:	92 40       	sbci	r25, 0x02	; 2
    261c:	09 f0       	breq	.+2      	; 0x2620 <find_volume+0x12a>
    261e:	a0 c1       	rjmp	.+832    	; 0x2960 <find_volume+0x46a>
    2620:	f8 01       	movw	r30, r16
    2622:	ec 5b       	subi	r30, 0xBC	; 188
    2624:	ff 4f       	sbci	r31, 0xFF	; 255
    2626:	40 80       	ld	r4, Z
    2628:	51 80       	ldd	r5, Z+1	; 0x01
    262a:	61 2c       	mov	r6, r1
    262c:	71 2c       	mov	r7, r1
    262e:	41 14       	cp	r4, r1
    2630:	51 04       	cpc	r5, r1
    2632:	61 04       	cpc	r6, r1
    2634:	71 04       	cpc	r7, r1
    2636:	29 f4       	brne	.+10     	; 0x2642 <find_volume+0x14c>
    2638:	3e 96       	adiw	r30, 0x0e	; 14
    263a:	40 80       	ld	r4, Z
    263c:	51 80       	ldd	r5, Z+1	; 0x01
    263e:	62 80       	ldd	r6, Z+2	; 0x02
    2640:	73 80       	ldd	r7, Z+3	; 0x03
    2642:	f8 01       	movw	r30, r16
    2644:	46 8a       	std	Z+22, r4	; 0x16
    2646:	57 8a       	std	Z+23, r5	; 0x17
    2648:	60 8e       	std	Z+24, r6	; 0x18
    264a:	71 8e       	std	Z+25, r7	; 0x19
    264c:	a6 ad       	ldd	r26, Z+62	; 0x3e
    264e:	a3 83       	std	Z+3, r26	; 0x03
    2650:	8f ef       	ldi	r24, 0xFF	; 255
    2652:	8a 0f       	add	r24, r26
    2654:	82 30       	cpi	r24, 0x02	; 2
    2656:	08 f0       	brcs	.+2      	; 0x265a <find_volume+0x164>
    2658:	85 c1       	rjmp	.+778    	; 0x2964 <find_volume+0x46e>
    265a:	f3 ad       	ldd	r31, Z+59	; 0x3b
    265c:	f9 8b       	std	Y+17, r31	; 0x11
    265e:	2f 2f       	mov	r18, r31
    2660:	f8 01       	movw	r30, r16
    2662:	22 83       	std	Z+2, r18	; 0x02
    2664:	22 23       	and	r18, r18
    2666:	09 f4       	brne	.+2      	; 0x266a <find_volume+0x174>
    2668:	7f c1       	rjmp	.+766    	; 0x2968 <find_volume+0x472>
    266a:	82 2f       	mov	r24, r18
    266c:	90 e0       	ldi	r25, 0x00	; 0
    266e:	9c 01       	movw	r18, r24
    2670:	21 50       	subi	r18, 0x01	; 1
    2672:	31 09       	sbc	r19, r1
    2674:	82 23       	and	r24, r18
    2676:	93 23       	and	r25, r19
    2678:	89 2b       	or	r24, r25
    267a:	09 f0       	breq	.+2      	; 0x267e <find_volume+0x188>
    267c:	77 c1       	rjmp	.+750    	; 0x296c <find_volume+0x476>
    267e:	ff 96       	adiw	r30, 0x3f	; 63
    2680:	20 80       	ld	r2, Z
    2682:	31 80       	ldd	r3, Z+1	; 0x01
    2684:	f8 01       	movw	r30, r16
    2686:	31 86       	std	Z+9, r3	; 0x09
    2688:	20 86       	std	Z+8, r2	; 0x08
    268a:	c1 01       	movw	r24, r2
    268c:	8f 70       	andi	r24, 0x0F	; 15
    268e:	99 27       	eor	r25, r25
    2690:	89 2b       	or	r24, r25
    2692:	09 f0       	breq	.+2      	; 0x2696 <find_volume+0x1a0>
    2694:	6d c1       	rjmp	.+730    	; 0x2970 <find_volume+0x47a>
    2696:	ef 5b       	subi	r30, 0xBF	; 191
    2698:	ff 4f       	sbci	r31, 0xFF	; 255
    269a:	80 80       	ld	r8, Z
    269c:	91 80       	ldd	r9, Z+1	; 0x01
    269e:	a1 2c       	mov	r10, r1
    26a0:	b1 2c       	mov	r11, r1
    26a2:	81 14       	cp	r8, r1
    26a4:	91 04       	cpc	r9, r1
    26a6:	a1 04       	cpc	r10, r1
    26a8:	b1 04       	cpc	r11, r1
    26aa:	29 f4       	brne	.+10     	; 0x26b6 <find_volume+0x1c0>
    26ac:	3d 96       	adiw	r30, 0x0d	; 13
    26ae:	80 80       	ld	r8, Z
    26b0:	91 80       	ldd	r9, Z+1	; 0x01
    26b2:	a2 80       	ldd	r10, Z+2	; 0x02
    26b4:	b3 80       	ldd	r11, Z+3	; 0x03
    26b6:	f8 01       	movw	r30, r16
    26b8:	04 ac       	ldd	r0, Z+60	; 0x3c
    26ba:	f5 ad       	ldd	r31, Z+61	; 0x3d
    26bc:	e0 2d       	mov	r30, r0
    26be:	30 97       	sbiw	r30, 0x00	; 0
    26c0:	09 f4       	brne	.+2      	; 0x26c4 <find_volume+0x1ce>
    26c2:	58 c1       	rjmp	.+688    	; 0x2974 <find_volume+0x47e>
    26c4:	b0 e0       	ldi	r27, 0x00	; 0
    26c6:	a3 01       	movw	r20, r6
    26c8:	92 01       	movw	r18, r4
    26ca:	0e 94 29 39 	call	0x7252	; 0x7252 <__muluhisi3>
    26ce:	6a 8f       	std	Y+26, r22	; 0x1a
    26d0:	7b 8f       	std	Y+27, r23	; 0x1b
    26d2:	8c 8f       	std	Y+28, r24	; 0x1c
    26d4:	9d 8f       	std	Y+29, r25	; 0x1d
    26d6:	9f 01       	movw	r18, r30
    26d8:	40 e0       	ldi	r20, 0x00	; 0
    26da:	50 e0       	ldi	r21, 0x00	; 0
    26dc:	2e 8b       	std	Y+22, r18	; 0x16
    26de:	3f 8b       	std	Y+23, r19	; 0x17
    26e0:	48 8f       	std	Y+24, r20	; 0x18
    26e2:	59 8f       	std	Y+25, r21	; 0x19
    26e4:	c1 01       	movw	r24, r2
    26e6:	92 95       	swap	r25
    26e8:	82 95       	swap	r24
    26ea:	8f 70       	andi	r24, 0x0F	; 15
    26ec:	89 27       	eor	r24, r25
    26ee:	9f 70       	andi	r25, 0x0F	; 15
    26f0:	89 27       	eor	r24, r25
    26f2:	28 0f       	add	r18, r24
    26f4:	39 1f       	adc	r19, r25
    26f6:	41 1d       	adc	r20, r1
    26f8:	51 1d       	adc	r21, r1
    26fa:	da 01       	movw	r26, r20
    26fc:	c9 01       	movw	r24, r18
    26fe:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2700:	3b 8d       	ldd	r19, Y+27	; 0x1b
    2702:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2704:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2706:	28 0f       	add	r18, r24
    2708:	39 1f       	adc	r19, r25
    270a:	4a 1f       	adc	r20, r26
    270c:	5b 1f       	adc	r21, r27
    270e:	2a 8b       	std	Y+18, r18	; 0x12
    2710:	3b 8b       	std	Y+19, r19	; 0x13
    2712:	4c 8b       	std	Y+20, r20	; 0x14
    2714:	5d 8b       	std	Y+21, r21	; 0x15
    2716:	82 16       	cp	r8, r18
    2718:	93 06       	cpc	r9, r19
    271a:	a4 06       	cpc	r10, r20
    271c:	b5 06       	cpc	r11, r21
    271e:	08 f4       	brcc	.+2      	; 0x2722 <find_volume+0x22c>
    2720:	2b c1       	rjmp	.+598    	; 0x2978 <find_volume+0x482>
    2722:	c5 01       	movw	r24, r10
    2724:	b4 01       	movw	r22, r8
    2726:	62 1b       	sub	r22, r18
    2728:	73 0b       	sbc	r23, r19
    272a:	84 0b       	sbc	r24, r20
    272c:	95 0b       	sbc	r25, r21
    272e:	e9 89       	ldd	r30, Y+17	; 0x11
    2730:	2e 2f       	mov	r18, r30
    2732:	30 e0       	ldi	r19, 0x00	; 0
    2734:	40 e0       	ldi	r20, 0x00	; 0
    2736:	50 e0       	ldi	r21, 0x00	; 0
    2738:	0e 94 07 39 	call	0x720e	; 0x720e <__udivmodsi4>
    273c:	da 01       	movw	r26, r20
    273e:	c9 01       	movw	r24, r18
    2740:	21 15       	cp	r18, r1
    2742:	31 05       	cpc	r19, r1
    2744:	41 05       	cpc	r20, r1
    2746:	51 05       	cpc	r21, r1
    2748:	09 f4       	brne	.+2      	; 0x274c <find_volume+0x256>
    274a:	18 c1       	rjmp	.+560    	; 0x297c <find_volume+0x486>
    274c:	26 3f       	cpi	r18, 0xF6	; 246
    274e:	ff e0       	ldi	r31, 0x0F	; 15
    2750:	3f 07       	cpc	r19, r31
    2752:	41 05       	cpc	r20, r1
    2754:	51 05       	cpc	r21, r1
    2756:	18 f0       	brcs	.+6      	; 0x275e <find_volume+0x268>
    2758:	e2 e0       	ldi	r30, 0x02	; 2
    275a:	e9 8b       	std	Y+17, r30	; 0x11
    275c:	02 c0       	rjmp	.+4      	; 0x2762 <find_volume+0x26c>
    275e:	f1 e0       	ldi	r31, 0x01	; 1
    2760:	f9 8b       	std	Y+17, r31	; 0x11
    2762:	86 3f       	cpi	r24, 0xF6	; 246
    2764:	9f 4f       	sbci	r25, 0xFF	; 255
    2766:	a1 05       	cpc	r26, r1
    2768:	b1 05       	cpc	r27, r1
    276a:	08 f0       	brcs	.+2      	; 0x276e <find_volume+0x278>
    276c:	28 c1       	rjmp	.+592    	; 0x29be <find_volume+0x4c8>
    276e:	49 01       	movw	r8, r18
    2770:	5a 01       	movw	r10, r20
    2772:	82 e0       	ldi	r24, 0x02	; 2
    2774:	88 0e       	add	r8, r24
    2776:	91 1c       	adc	r9, r1
    2778:	a1 1c       	adc	r10, r1
    277a:	b1 1c       	adc	r11, r1
    277c:	d8 01       	movw	r26, r16
    277e:	52 96       	adiw	r26, 0x12	; 18
    2780:	8d 92       	st	X+, r8
    2782:	9d 92       	st	X+, r9
    2784:	ad 92       	st	X+, r10
    2786:	bc 92       	st	X, r11
    2788:	55 97       	sbiw	r26, 0x15	; 21
    278a:	f8 01       	movw	r30, r16
    278c:	c2 8e       	std	Z+26, r12	; 0x1a
    278e:	d3 8e       	std	Z+27, r13	; 0x1b
    2790:	e4 8e       	std	Z+28, r14	; 0x1c
    2792:	f5 8e       	std	Z+29, r15	; 0x1d
    2794:	8e 89       	ldd	r24, Y+22	; 0x16
    2796:	9f 89       	ldd	r25, Y+23	; 0x17
    2798:	a8 8d       	ldd	r26, Y+24	; 0x18
    279a:	b9 8d       	ldd	r27, Y+25	; 0x19
    279c:	8c 0d       	add	r24, r12
    279e:	9d 1d       	adc	r25, r13
    27a0:	ae 1d       	adc	r26, r14
    27a2:	bf 1d       	adc	r27, r15
    27a4:	86 8f       	std	Z+30, r24	; 0x1e
    27a6:	97 8f       	std	Z+31, r25	; 0x1f
    27a8:	a0 a3       	std	Z+32, r26	; 0x20
    27aa:	b1 a3       	std	Z+33, r27	; 0x21
    27ac:	4a 89       	ldd	r20, Y+18	; 0x12
    27ae:	5b 89       	ldd	r21, Y+19	; 0x13
    27b0:	6c 89       	ldd	r22, Y+20	; 0x14
    27b2:	7d 89       	ldd	r23, Y+21	; 0x15
    27b4:	4c 0d       	add	r20, r12
    27b6:	5d 1d       	adc	r21, r13
    27b8:	6e 1d       	adc	r22, r14
    27ba:	7f 1d       	adc	r23, r15
    27bc:	46 a3       	std	Z+38, r20	; 0x26
    27be:	57 a3       	std	Z+39, r21	; 0x27
    27c0:	60 a7       	std	Z+40, r22	; 0x28
    27c2:	71 a7       	std	Z+41, r23	; 0x29
    27c4:	f9 89       	ldd	r31, Y+17	; 0x11
    27c6:	f3 30       	cpi	r31, 0x03	; 3
    27c8:	69 f5       	brne	.+90     	; 0x2824 <find_volume+0x32e>
    27ca:	23 28       	or	r2, r3
    27cc:	09 f0       	breq	.+2      	; 0x27d0 <find_volume+0x2da>
    27ce:	d8 c0       	rjmp	.+432    	; 0x2980 <find_volume+0x48a>
    27d0:	f8 01       	movw	r30, r16
    27d2:	e6 5a       	subi	r30, 0xA6	; 166
    27d4:	ff 4f       	sbci	r31, 0xFF	; 255
    27d6:	80 81       	ld	r24, Z
    27d8:	91 81       	ldd	r25, Z+1	; 0x01
    27da:	a2 81       	ldd	r26, Z+2	; 0x02
    27dc:	b3 81       	ldd	r27, Z+3	; 0x03
    27de:	f8 01       	movw	r30, r16
    27e0:	82 a3       	std	Z+34, r24	; 0x22
    27e2:	93 a3       	std	Z+35, r25	; 0x23
    27e4:	a4 a3       	std	Z+36, r26	; 0x24
    27e6:	b5 a3       	std	Z+37, r27	; 0x25
    27e8:	88 0c       	add	r8, r8
    27ea:	99 1c       	adc	r9, r9
    27ec:	aa 1c       	adc	r10, r10
    27ee:	bb 1c       	adc	r11, r11
    27f0:	88 0c       	add	r8, r8
    27f2:	99 1c       	adc	r9, r9
    27f4:	aa 1c       	adc	r10, r10
    27f6:	bb 1c       	adc	r11, r11
    27f8:	ff ef       	ldi	r31, 0xFF	; 255
    27fa:	8f 0e       	add	r8, r31
    27fc:	f1 e0       	ldi	r31, 0x01	; 1
    27fe:	9f 1e       	adc	r9, r31
    2800:	a1 1c       	adc	r10, r1
    2802:	b1 1c       	adc	r11, r1
    2804:	07 2e       	mov	r0, r23
    2806:	79 e0       	ldi	r23, 0x09	; 9
    2808:	b6 94       	lsr	r11
    280a:	a7 94       	ror	r10
    280c:	97 94       	ror	r9
    280e:	87 94       	ror	r8
    2810:	7a 95       	dec	r23
    2812:	d1 f7       	brne	.-12     	; 0x2808 <find_volume+0x312>
    2814:	70 2d       	mov	r23, r0
    2816:	48 14       	cp	r4, r8
    2818:	59 04       	cpc	r5, r9
    281a:	6a 04       	cpc	r6, r10
    281c:	7b 04       	cpc	r7, r11
    281e:	08 f4       	brcc	.+2      	; 0x2822 <find_volume+0x32c>
    2820:	b1 c0       	rjmp	.+354    	; 0x2984 <find_volume+0x48e>
    2822:	1e c1       	rjmp	.+572    	; 0x2a60 <find_volume+0x56a>
    2824:	23 28       	or	r2, r3
    2826:	09 f4       	brne	.+2      	; 0x282a <find_volume+0x334>
    2828:	af c0       	rjmp	.+350    	; 0x2988 <find_volume+0x492>
    282a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    282c:	3b 8d       	ldd	r19, Y+27	; 0x1b
    282e:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2830:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2832:	82 0f       	add	r24, r18
    2834:	93 1f       	adc	r25, r19
    2836:	a4 1f       	adc	r26, r20
    2838:	b5 1f       	adc	r27, r21
    283a:	f8 01       	movw	r30, r16
    283c:	82 a3       	std	Z+34, r24	; 0x22
    283e:	93 a3       	std	Z+35, r25	; 0x23
    2840:	a4 a3       	std	Z+36, r26	; 0x24
    2842:	b5 a3       	std	Z+37, r27	; 0x25
    2844:	f9 89       	ldd	r31, Y+17	; 0x11
    2846:	f2 30       	cpi	r31, 0x02	; 2
    2848:	29 f4       	brne	.+10     	; 0x2854 <find_volume+0x35e>
    284a:	88 0c       	add	r8, r8
    284c:	99 1c       	adc	r9, r9
    284e:	aa 1c       	adc	r10, r10
    2850:	bb 1c       	adc	r11, r11
    2852:	f0 c0       	rjmp	.+480    	; 0x2a34 <find_volume+0x53e>
    2854:	a3 e0       	ldi	r26, 0x03	; 3
    2856:	b0 e0       	ldi	r27, 0x00	; 0
    2858:	a5 01       	movw	r20, r10
    285a:	94 01       	movw	r18, r8
    285c:	0e 94 29 39 	call	0x7252	; 0x7252 <__muluhisi3>
    2860:	dc 01       	movw	r26, r24
    2862:	cb 01       	movw	r24, r22
    2864:	b6 95       	lsr	r27
    2866:	a7 95       	ror	r26
    2868:	97 95       	ror	r25
    286a:	87 95       	ror	r24
    286c:	21 e0       	ldi	r18, 0x01	; 1
    286e:	82 22       	and	r8, r18
    2870:	99 24       	eor	r9, r9
    2872:	aa 24       	eor	r10, r10
    2874:	bb 24       	eor	r11, r11
    2876:	88 0e       	add	r8, r24
    2878:	99 1e       	adc	r9, r25
    287a:	aa 1e       	adc	r10, r26
    287c:	bb 1e       	adc	r11, r27
    287e:	da c0       	rjmp	.+436    	; 0x2a34 <find_volume+0x53e>
    2880:	b7 01       	movw	r22, r14
    2882:	a6 01       	movw	r20, r12
    2884:	4f 5f       	subi	r20, 0xFF	; 255
    2886:	5f 4f       	sbci	r21, 0xFF	; 255
    2888:	6f 4f       	sbci	r22, 0xFF	; 255
    288a:	7f 4f       	sbci	r23, 0xFF	; 255
    288c:	c8 01       	movw	r24, r16
    288e:	99 dd       	rcall	.-1230   	; 0x23c2 <move_window>
    2890:	81 11       	cpse	r24, r1
    2892:	39 c0       	rjmp	.+114    	; 0x2906 <find_volume+0x410>
    2894:	d8 01       	movw	r26, r16
    2896:	15 96       	adiw	r26, 0x05	; 5
    2898:	1c 92       	st	X, r1
    289a:	f8 01       	movw	r30, r16
    289c:	e4 5d       	subi	r30, 0xD4	; 212
    289e:	fd 4f       	sbci	r31, 0xFD	; 253
    28a0:	80 81       	ld	r24, Z
    28a2:	91 81       	ldd	r25, Z+1	; 0x01
    28a4:	85 35       	cpi	r24, 0x55	; 85
    28a6:	9a 4a       	sbci	r25, 0xAA	; 170
    28a8:	89 f5       	brne	.+98     	; 0x290c <find_volume+0x416>
    28aa:	f8 01       	movw	r30, r16
    28ac:	86 a5       	ldd	r24, Z+46	; 0x2e
    28ae:	97 a5       	ldd	r25, Z+47	; 0x2f
    28b0:	a0 a9       	ldd	r26, Z+48	; 0x30
    28b2:	b1 a9       	ldd	r27, Z+49	; 0x31
    28b4:	82 35       	cpi	r24, 0x52	; 82
    28b6:	92 45       	sbci	r25, 0x52	; 82
    28b8:	a1 46       	sbci	r26, 0x61	; 97
    28ba:	b1 44       	sbci	r27, 0x41	; 65
    28bc:	51 f5       	brne	.+84     	; 0x2912 <find_volume+0x41c>
    28be:	f8 01       	movw	r30, r16
    28c0:	ee 5e       	subi	r30, 0xEE	; 238
    28c2:	fd 4f       	sbci	r31, 0xFD	; 253
    28c4:	80 81       	ld	r24, Z
    28c6:	91 81       	ldd	r25, Z+1	; 0x01
    28c8:	a2 81       	ldd	r26, Z+2	; 0x02
    28ca:	b3 81       	ldd	r27, Z+3	; 0x03
    28cc:	82 37       	cpi	r24, 0x72	; 114
    28ce:	92 47       	sbci	r25, 0x72	; 114
    28d0:	a1 44       	sbci	r26, 0x41	; 65
    28d2:	b1 46       	sbci	r27, 0x61	; 97
    28d4:	09 f5       	brne	.+66     	; 0x2918 <find_volume+0x422>
    28d6:	34 96       	adiw	r30, 0x04	; 4
    28d8:	80 81       	ld	r24, Z
    28da:	91 81       	ldd	r25, Z+1	; 0x01
    28dc:	a2 81       	ldd	r26, Z+2	; 0x02
    28de:	b3 81       	ldd	r27, Z+3	; 0x03
    28e0:	f8 01       	movw	r30, r16
    28e2:	86 87       	std	Z+14, r24	; 0x0e
    28e4:	97 87       	std	Z+15, r25	; 0x0f
    28e6:	a0 8b       	std	Z+16, r26	; 0x10
    28e8:	b1 8b       	std	Z+17, r27	; 0x11
    28ea:	e6 5e       	subi	r30, 0xE6	; 230
    28ec:	fd 4f       	sbci	r31, 0xFD	; 253
    28ee:	80 81       	ld	r24, Z
    28f0:	91 81       	ldd	r25, Z+1	; 0x01
    28f2:	a2 81       	ldd	r26, Z+2	; 0x02
    28f4:	b3 81       	ldd	r27, Z+3	; 0x03
    28f6:	f8 01       	movw	r30, r16
    28f8:	82 87       	std	Z+10, r24	; 0x0a
    28fa:	93 87       	std	Z+11, r25	; 0x0b
    28fc:	a4 87       	std	Z+12, r26	; 0x0c
    28fe:	b5 87       	std	Z+13, r27	; 0x0d
    2900:	f3 e0       	ldi	r31, 0x03	; 3
    2902:	f9 8b       	std	Y+17, r31	; 0x11
    2904:	0b c0       	rjmp	.+22     	; 0x291c <find_volume+0x426>
    2906:	e3 e0       	ldi	r30, 0x03	; 3
    2908:	e9 8b       	std	Y+17, r30	; 0x11
    290a:	08 c0       	rjmp	.+16     	; 0x291c <find_volume+0x426>
    290c:	f3 e0       	ldi	r31, 0x03	; 3
    290e:	f9 8b       	std	Y+17, r31	; 0x11
    2910:	05 c0       	rjmp	.+10     	; 0x291c <find_volume+0x426>
    2912:	e3 e0       	ldi	r30, 0x03	; 3
    2914:	e9 8b       	std	Y+17, r30	; 0x11
    2916:	02 c0       	rjmp	.+4      	; 0x291c <find_volume+0x426>
    2918:	f3 e0       	ldi	r31, 0x03	; 3
    291a:	f9 8b       	std	Y+17, r31	; 0x11
    291c:	e9 89       	ldd	r30, Y+17	; 0x11
    291e:	d8 01       	movw	r26, r16
    2920:	ec 93       	st	X, r30
    2922:	80 91 24 06 	lds	r24, 0x0624
    2926:	90 91 25 06 	lds	r25, 0x0625
    292a:	01 96       	adiw	r24, 0x01	; 1
    292c:	90 93 25 06 	sts	0x0625, r25
    2930:	80 93 24 06 	sts	0x0624, r24
    2934:	17 96       	adiw	r26, 0x07	; 7
    2936:	9c 93       	st	X, r25
    2938:	8e 93       	st	-X, r24
    293a:	16 97       	sbiw	r26, 0x06	; 6
    293c:	80 e0       	ldi	r24, 0x00	; 0
    293e:	a8 c0       	rjmp	.+336    	; 0x2a90 <find_volume+0x59a>
    2940:	8b e0       	ldi	r24, 0x0B	; 11
    2942:	a6 c0       	rjmp	.+332    	; 0x2a90 <find_volume+0x59a>
    2944:	8c e0       	ldi	r24, 0x0C	; 12
    2946:	a4 c0       	rjmp	.+328    	; 0x2a90 <find_volume+0x59a>
    2948:	80 e0       	ldi	r24, 0x00	; 0
    294a:	a2 c0       	rjmp	.+324    	; 0x2a90 <find_volume+0x59a>
    294c:	80 e0       	ldi	r24, 0x00	; 0
    294e:	a0 c0       	rjmp	.+320    	; 0x2a90 <find_volume+0x59a>
    2950:	83 e0       	ldi	r24, 0x03	; 3
    2952:	9e c0       	rjmp	.+316    	; 0x2a90 <find_volume+0x59a>
    2954:	8a e0       	ldi	r24, 0x0A	; 10
    2956:	9c c0       	rjmp	.+312    	; 0x2a90 <find_volume+0x59a>
    2958:	81 e0       	ldi	r24, 0x01	; 1
    295a:	9a c0       	rjmp	.+308    	; 0x2a90 <find_volume+0x59a>
    295c:	8d e0       	ldi	r24, 0x0D	; 13
    295e:	98 c0       	rjmp	.+304    	; 0x2a90 <find_volume+0x59a>
    2960:	8d e0       	ldi	r24, 0x0D	; 13
    2962:	96 c0       	rjmp	.+300    	; 0x2a90 <find_volume+0x59a>
    2964:	8d e0       	ldi	r24, 0x0D	; 13
    2966:	94 c0       	rjmp	.+296    	; 0x2a90 <find_volume+0x59a>
    2968:	8d e0       	ldi	r24, 0x0D	; 13
    296a:	92 c0       	rjmp	.+292    	; 0x2a90 <find_volume+0x59a>
    296c:	8d e0       	ldi	r24, 0x0D	; 13
    296e:	90 c0       	rjmp	.+288    	; 0x2a90 <find_volume+0x59a>
    2970:	8d e0       	ldi	r24, 0x0D	; 13
    2972:	8e c0       	rjmp	.+284    	; 0x2a90 <find_volume+0x59a>
    2974:	8d e0       	ldi	r24, 0x0D	; 13
    2976:	8c c0       	rjmp	.+280    	; 0x2a90 <find_volume+0x59a>
    2978:	8d e0       	ldi	r24, 0x0D	; 13
    297a:	8a c0       	rjmp	.+276    	; 0x2a90 <find_volume+0x59a>
    297c:	8d e0       	ldi	r24, 0x0D	; 13
    297e:	88 c0       	rjmp	.+272    	; 0x2a90 <find_volume+0x59a>
    2980:	8d e0       	ldi	r24, 0x0D	; 13
    2982:	86 c0       	rjmp	.+268    	; 0x2a90 <find_volume+0x59a>
    2984:	8d e0       	ldi	r24, 0x0D	; 13
    2986:	84 c0       	rjmp	.+264    	; 0x2a90 <find_volume+0x59a>
    2988:	8d e0       	ldi	r24, 0x0D	; 13
    298a:	82 c0       	rjmp	.+260    	; 0x2a90 <find_volume+0x59a>
    298c:	8d e0       	ldi	r24, 0x0D	; 13
    298e:	80 c0       	rjmp	.+256    	; 0x2a90 <find_volume+0x59a>
    2990:	40 e0       	ldi	r20, 0x00	; 0
    2992:	50 e0       	ldi	r21, 0x00	; 0
    2994:	ba 01       	movw	r22, r20
    2996:	c8 01       	movw	r24, r16
    2998:	50 dd       	rcall	.-1376   	; 0x243a <check_fs>
    299a:	81 30       	cpi	r24, 0x01	; 1
    299c:	09 f0       	breq	.+2      	; 0x29a0 <find_volume+0x4aa>
    299e:	2f ce       	rjmp	.-930    	; 0x25fe <find_volume+0x108>
    29a0:	f8 01       	movw	r30, r16
    29a2:	e0 51       	subi	r30, 0x10	; 16
    29a4:	fe 4f       	sbci	r31, 0xFE	; 254
    29a6:	9e 01       	movw	r18, r28
    29a8:	2f 5f       	subi	r18, 0xFF	; 255
    29aa:	3f 4f       	sbci	r19, 0xFF	; 255
    29ac:	59 01       	movw	r10, r18
    29ae:	a8 01       	movw	r20, r16
    29b0:	40 5d       	subi	r20, 0xD0	; 208
    29b2:	5d 4f       	sbci	r21, 0xFD	; 253
    29b4:	e1 2c       	mov	r14, r1
    29b6:	f1 2c       	mov	r15, r1
    29b8:	70 e0       	ldi	r23, 0x00	; 0
    29ba:	60 e0       	ldi	r22, 0x00	; 0
    29bc:	ec cd       	rjmp	.-1064   	; 0x2596 <find_volume+0xa0>
    29be:	49 01       	movw	r8, r18
    29c0:	5a 01       	movw	r10, r20
    29c2:	62 e0       	ldi	r22, 0x02	; 2
    29c4:	86 0e       	add	r8, r22
    29c6:	91 1c       	adc	r9, r1
    29c8:	a1 1c       	adc	r10, r1
    29ca:	b1 1c       	adc	r11, r1
    29cc:	d8 01       	movw	r26, r16
    29ce:	52 96       	adiw	r26, 0x12	; 18
    29d0:	8d 92       	st	X+, r8
    29d2:	9d 92       	st	X+, r9
    29d4:	ad 92       	st	X+, r10
    29d6:	bc 92       	st	X, r11
    29d8:	55 97       	sbiw	r26, 0x15	; 21
    29da:	f8 01       	movw	r30, r16
    29dc:	c2 8e       	std	Z+26, r12	; 0x1a
    29de:	d3 8e       	std	Z+27, r13	; 0x1b
    29e0:	e4 8e       	std	Z+28, r14	; 0x1c
    29e2:	f5 8e       	std	Z+29, r15	; 0x1d
    29e4:	8e 89       	ldd	r24, Y+22	; 0x16
    29e6:	9f 89       	ldd	r25, Y+23	; 0x17
    29e8:	a8 8d       	ldd	r26, Y+24	; 0x18
    29ea:	b9 8d       	ldd	r27, Y+25	; 0x19
    29ec:	8c 0d       	add	r24, r12
    29ee:	9d 1d       	adc	r25, r13
    29f0:	ae 1d       	adc	r26, r14
    29f2:	bf 1d       	adc	r27, r15
    29f4:	86 8f       	std	Z+30, r24	; 0x1e
    29f6:	97 8f       	std	Z+31, r25	; 0x1f
    29f8:	a0 a3       	std	Z+32, r26	; 0x20
    29fa:	b1 a3       	std	Z+33, r27	; 0x21
    29fc:	8a 89       	ldd	r24, Y+18	; 0x12
    29fe:	9b 89       	ldd	r25, Y+19	; 0x13
    2a00:	ac 89       	ldd	r26, Y+20	; 0x14
    2a02:	bd 89       	ldd	r27, Y+21	; 0x15
    2a04:	8c 0d       	add	r24, r12
    2a06:	9d 1d       	adc	r25, r13
    2a08:	ae 1d       	adc	r26, r14
    2a0a:	bf 1d       	adc	r27, r15
    2a0c:	86 a3       	std	Z+38, r24	; 0x26
    2a0e:	97 a3       	std	Z+39, r25	; 0x27
    2a10:	a0 a7       	std	Z+40, r26	; 0x28
    2a12:	b1 a7       	std	Z+41, r27	; 0x29
    2a14:	da ce       	rjmp	.-588    	; 0x27ca <find_volume+0x2d4>
    2a16:	8f ef       	ldi	r24, 0xFF	; 255
    2a18:	9f ef       	ldi	r25, 0xFF	; 255
    2a1a:	dc 01       	movw	r26, r24
    2a1c:	f8 01       	movw	r30, r16
    2a1e:	86 87       	std	Z+14, r24	; 0x0e
    2a20:	97 87       	std	Z+15, r25	; 0x0f
    2a22:	a0 8b       	std	Z+16, r26	; 0x10
    2a24:	b1 8b       	std	Z+17, r27	; 0x11
    2a26:	82 87       	std	Z+10, r24	; 0x0a
    2a28:	93 87       	std	Z+11, r25	; 0x0b
    2a2a:	a4 87       	std	Z+12, r26	; 0x0c
    2a2c:	b5 87       	std	Z+13, r27	; 0x0d
    2a2e:	80 e8       	ldi	r24, 0x80	; 128
    2a30:	85 83       	std	Z+5, r24	; 0x05
    2a32:	74 cf       	rjmp	.-280    	; 0x291c <find_volume+0x426>
    2a34:	ff ef       	ldi	r31, 0xFF	; 255
    2a36:	8f 0e       	add	r8, r31
    2a38:	f1 e0       	ldi	r31, 0x01	; 1
    2a3a:	9f 1e       	adc	r9, r31
    2a3c:	a1 1c       	adc	r10, r1
    2a3e:	b1 1c       	adc	r11, r1
    2a40:	07 2e       	mov	r0, r23
    2a42:	79 e0       	ldi	r23, 0x09	; 9
    2a44:	b6 94       	lsr	r11
    2a46:	a7 94       	ror	r10
    2a48:	97 94       	ror	r9
    2a4a:	87 94       	ror	r8
    2a4c:	7a 95       	dec	r23
    2a4e:	d1 f7       	brne	.-12     	; 0x2a44 <find_volume+0x54e>
    2a50:	70 2d       	mov	r23, r0
    2a52:	48 14       	cp	r4, r8
    2a54:	59 04       	cpc	r5, r9
    2a56:	6a 04       	cpc	r6, r10
    2a58:	7b 04       	cpc	r7, r11
    2a5a:	08 f4       	brcc	.+2      	; 0x2a5e <find_volume+0x568>
    2a5c:	97 cf       	rjmp	.-210    	; 0x298c <find_volume+0x496>
    2a5e:	db cf       	rjmp	.-74     	; 0x2a16 <find_volume+0x520>
    2a60:	8f ef       	ldi	r24, 0xFF	; 255
    2a62:	9f ef       	ldi	r25, 0xFF	; 255
    2a64:	dc 01       	movw	r26, r24
    2a66:	f8 01       	movw	r30, r16
    2a68:	86 87       	std	Z+14, r24	; 0x0e
    2a6a:	97 87       	std	Z+15, r25	; 0x0f
    2a6c:	a0 8b       	std	Z+16, r26	; 0x10
    2a6e:	b1 8b       	std	Z+17, r27	; 0x11
    2a70:	82 87       	std	Z+10, r24	; 0x0a
    2a72:	93 87       	std	Z+11, r25	; 0x0b
    2a74:	a4 87       	std	Z+12, r26	; 0x0c
    2a76:	b5 87       	std	Z+13, r27	; 0x0d
    2a78:	80 e8       	ldi	r24, 0x80	; 128
    2a7a:	85 83       	std	Z+5, r24	; 0x05
    2a7c:	e2 5a       	subi	r30, 0xA2	; 162
    2a7e:	ff 4f       	sbci	r31, 0xFF	; 255
    2a80:	80 81       	ld	r24, Z
    2a82:	91 81       	ldd	r25, Z+1	; 0x01
    2a84:	01 97       	sbiw	r24, 0x01	; 1
    2a86:	09 f4       	brne	.+2      	; 0x2a8a <find_volume+0x594>
    2a88:	fb ce       	rjmp	.-522    	; 0x2880 <find_volume+0x38a>
    2a8a:	f3 e0       	ldi	r31, 0x03	; 3
    2a8c:	f9 8b       	std	Y+17, r31	; 0x11
    2a8e:	46 cf       	rjmp	.-372    	; 0x291c <find_volume+0x426>
    2a90:	6d 96       	adiw	r28, 0x1d	; 29
    2a92:	0f b6       	in	r0, 0x3f	; 63
    2a94:	f8 94       	cli
    2a96:	de bf       	out	0x3e, r29	; 62
    2a98:	0f be       	out	0x3f, r0	; 63
    2a9a:	cd bf       	out	0x3d, r28	; 61
    2a9c:	df 91       	pop	r29
    2a9e:	cf 91       	pop	r28
    2aa0:	1f 91       	pop	r17
    2aa2:	0f 91       	pop	r16
    2aa4:	ff 90       	pop	r15
    2aa6:	ef 90       	pop	r14
    2aa8:	df 90       	pop	r13
    2aaa:	cf 90       	pop	r12
    2aac:	bf 90       	pop	r11
    2aae:	af 90       	pop	r10
    2ab0:	9f 90       	pop	r9
    2ab2:	8f 90       	pop	r8
    2ab4:	7f 90       	pop	r7
    2ab6:	6f 90       	pop	r6
    2ab8:	5f 90       	pop	r5
    2aba:	4f 90       	pop	r4
    2abc:	3f 90       	pop	r3
    2abe:	2f 90       	pop	r2
    2ac0:	08 95       	ret

00002ac2 <sync_fs>:
    2ac2:	0f 93       	push	r16
    2ac4:	1f 93       	push	r17
    2ac6:	cf 93       	push	r28
    2ac8:	df 93       	push	r29
    2aca:	ec 01       	movw	r28, r24
    2acc:	11 dc       	rcall	.-2014   	; 0x22f0 <sync_window>
    2ace:	98 2f       	mov	r25, r24
    2ad0:	81 11       	cpse	r24, r1
    2ad2:	59 c0       	rjmp	.+178    	; 0x2b86 <sync_fs+0xc4>
    2ad4:	88 81       	ld	r24, Y
    2ad6:	83 30       	cpi	r24, 0x03	; 3
    2ad8:	09 f0       	breq	.+2      	; 0x2adc <sync_fs+0x1a>
    2ada:	4c c0       	rjmp	.+152    	; 0x2b74 <sync_fs+0xb2>
    2adc:	8d 81       	ldd	r24, Y+5	; 0x05
    2ade:	81 30       	cpi	r24, 0x01	; 1
    2ae0:	09 f0       	breq	.+2      	; 0x2ae4 <sync_fs+0x22>
    2ae2:	48 c0       	rjmp	.+144    	; 0x2b74 <sync_fs+0xb2>
    2ae4:	be 01       	movw	r22, r28
    2ae6:	62 5d       	subi	r22, 0xD2	; 210
    2ae8:	7f 4f       	sbci	r23, 0xFF	; 255
    2aea:	fb 01       	movw	r30, r22
    2aec:	ce 01       	movw	r24, r28
    2aee:	82 5d       	subi	r24, 0xD2	; 210
    2af0:	9d 4f       	sbci	r25, 0xFD	; 253
    2af2:	11 92       	st	Z+, r1
    2af4:	e8 17       	cp	r30, r24
    2af6:	f9 07       	cpc	r31, r25
    2af8:	e1 f7       	brne	.-8      	; 0x2af2 <sync_fs+0x30>
    2afa:	85 e5       	ldi	r24, 0x55	; 85
    2afc:	9a ea       	ldi	r25, 0xAA	; 170
    2afe:	fe 01       	movw	r30, r28
    2b00:	e4 5d       	subi	r30, 0xD4	; 212
    2b02:	fd 4f       	sbci	r31, 0xFD	; 253
    2b04:	91 83       	std	Z+1, r25	; 0x01
    2b06:	80 83       	st	Z, r24
    2b08:	82 e5       	ldi	r24, 0x52	; 82
    2b0a:	92 e5       	ldi	r25, 0x52	; 82
    2b0c:	a1 e6       	ldi	r26, 0x61	; 97
    2b0e:	b1 e4       	ldi	r27, 0x41	; 65
    2b10:	8e a7       	std	Y+46, r24	; 0x2e
    2b12:	9f a7       	std	Y+47, r25	; 0x2f
    2b14:	a8 ab       	std	Y+48, r26	; 0x30
    2b16:	b9 ab       	std	Y+49, r27	; 0x31
    2b18:	82 e7       	ldi	r24, 0x72	; 114
    2b1a:	92 e7       	ldi	r25, 0x72	; 114
    2b1c:	a1 e4       	ldi	r26, 0x41	; 65
    2b1e:	b1 e6       	ldi	r27, 0x61	; 97
    2b20:	7a 97       	sbiw	r30, 0x1a	; 26
    2b22:	80 83       	st	Z, r24
    2b24:	91 83       	std	Z+1, r25	; 0x01
    2b26:	a2 83       	std	Z+2, r26	; 0x02
    2b28:	b3 83       	std	Z+3, r27	; 0x03
    2b2a:	8e 85       	ldd	r24, Y+14	; 0x0e
    2b2c:	9f 85       	ldd	r25, Y+15	; 0x0f
    2b2e:	a8 89       	ldd	r26, Y+16	; 0x10
    2b30:	b9 89       	ldd	r27, Y+17	; 0x11
    2b32:	34 96       	adiw	r30, 0x04	; 4
    2b34:	80 83       	st	Z, r24
    2b36:	91 83       	std	Z+1, r25	; 0x01
    2b38:	a2 83       	std	Z+2, r26	; 0x02
    2b3a:	b3 83       	std	Z+3, r27	; 0x03
    2b3c:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b3e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b40:	ac 85       	ldd	r26, Y+12	; 0x0c
    2b42:	bd 85       	ldd	r27, Y+13	; 0x0d
    2b44:	34 96       	adiw	r30, 0x04	; 4
    2b46:	80 83       	st	Z, r24
    2b48:	91 83       	std	Z+1, r25	; 0x01
    2b4a:	a2 83       	std	Z+2, r26	; 0x02
    2b4c:	b3 83       	std	Z+3, r27	; 0x03
    2b4e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b50:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2b52:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2b54:	bd 8d       	ldd	r27, Y+29	; 0x1d
    2b56:	9c 01       	movw	r18, r24
    2b58:	ad 01       	movw	r20, r26
    2b5a:	2f 5f       	subi	r18, 0xFF	; 255
    2b5c:	3f 4f       	sbci	r19, 0xFF	; 255
    2b5e:	4f 4f       	sbci	r20, 0xFF	; 255
    2b60:	5f 4f       	sbci	r21, 0xFF	; 255
    2b62:	2a a7       	std	Y+42, r18	; 0x2a
    2b64:	3b a7       	std	Y+43, r19	; 0x2b
    2b66:	4c a7       	std	Y+44, r20	; 0x2c
    2b68:	5d a7       	std	Y+45, r21	; 0x2d
    2b6a:	01 e0       	ldi	r16, 0x01	; 1
    2b6c:	10 e0       	ldi	r17, 0x00	; 0
    2b6e:	89 81       	ldd	r24, Y+1	; 0x01
    2b70:	e0 d9       	rcall	.-3136   	; 0x1f32 <disk_write>
    2b72:	1d 82       	std	Y+5, r1	; 0x05
    2b74:	40 e0       	ldi	r20, 0x00	; 0
    2b76:	50 e0       	ldi	r21, 0x00	; 0
    2b78:	60 e0       	ldi	r22, 0x00	; 0
    2b7a:	89 81       	ldd	r24, Y+1	; 0x01
    2b7c:	3c da       	rcall	.-2952   	; 0x1ff6 <disk_ioctl>
    2b7e:	91 e0       	ldi	r25, 0x01	; 1
    2b80:	81 11       	cpse	r24, r1
    2b82:	01 c0       	rjmp	.+2      	; 0x2b86 <sync_fs+0xc4>
    2b84:	90 e0       	ldi	r25, 0x00	; 0
    2b86:	89 2f       	mov	r24, r25
    2b88:	df 91       	pop	r29
    2b8a:	cf 91       	pop	r28
    2b8c:	1f 91       	pop	r17
    2b8e:	0f 91       	pop	r16
    2b90:	08 95       	ret

00002b92 <clust2sect>:
    2b92:	cf 92       	push	r12
    2b94:	df 92       	push	r13
    2b96:	ef 92       	push	r14
    2b98:	ff 92       	push	r15
    2b9a:	fc 01       	movw	r30, r24
    2b9c:	9a 01       	movw	r18, r20
    2b9e:	ab 01       	movw	r20, r22
    2ba0:	22 50       	subi	r18, 0x02	; 2
    2ba2:	31 09       	sbc	r19, r1
    2ba4:	41 09       	sbc	r20, r1
    2ba6:	51 09       	sbc	r21, r1
    2ba8:	c2 88       	ldd	r12, Z+18	; 0x12
    2baa:	d3 88       	ldd	r13, Z+19	; 0x13
    2bac:	e4 88       	ldd	r14, Z+20	; 0x14
    2bae:	f5 88       	ldd	r15, Z+21	; 0x15
    2bb0:	82 e0       	ldi	r24, 0x02	; 2
    2bb2:	c8 1a       	sub	r12, r24
    2bb4:	d1 08       	sbc	r13, r1
    2bb6:	e1 08       	sbc	r14, r1
    2bb8:	f1 08       	sbc	r15, r1
    2bba:	2c 15       	cp	r18, r12
    2bbc:	3d 05       	cpc	r19, r13
    2bbe:	4e 05       	cpc	r20, r14
    2bc0:	5f 05       	cpc	r21, r15
    2bc2:	68 f4       	brcc	.+26     	; 0x2bde <clust2sect+0x4c>
    2bc4:	a2 81       	ldd	r26, Z+2	; 0x02
    2bc6:	b0 e0       	ldi	r27, 0x00	; 0
    2bc8:	0e 94 29 39 	call	0x7252	; 0x7252 <__muluhisi3>
    2bcc:	c6 a0       	ldd	r12, Z+38	; 0x26
    2bce:	d7 a0       	ldd	r13, Z+39	; 0x27
    2bd0:	e0 a4       	ldd	r14, Z+40	; 0x28
    2bd2:	f1 a4       	ldd	r15, Z+41	; 0x29
    2bd4:	6c 0d       	add	r22, r12
    2bd6:	7d 1d       	adc	r23, r13
    2bd8:	8e 1d       	adc	r24, r14
    2bda:	9f 1d       	adc	r25, r15
    2bdc:	03 c0       	rjmp	.+6      	; 0x2be4 <clust2sect+0x52>
    2bde:	60 e0       	ldi	r22, 0x00	; 0
    2be0:	70 e0       	ldi	r23, 0x00	; 0
    2be2:	cb 01       	movw	r24, r22
    2be4:	ff 90       	pop	r15
    2be6:	ef 90       	pop	r14
    2be8:	df 90       	pop	r13
    2bea:	cf 90       	pop	r12
    2bec:	08 95       	ret

00002bee <get_fat>:
    2bee:	af 92       	push	r10
    2bf0:	bf 92       	push	r11
    2bf2:	cf 92       	push	r12
    2bf4:	df 92       	push	r13
    2bf6:	ef 92       	push	r14
    2bf8:	ff 92       	push	r15
    2bfa:	0f 93       	push	r16
    2bfc:	1f 93       	push	r17
    2bfe:	cf 93       	push	r28
    2c00:	df 93       	push	r29
    2c02:	ec 01       	movw	r28, r24
    2c04:	6a 01       	movw	r12, r20
    2c06:	7b 01       	movw	r14, r22
    2c08:	42 30       	cpi	r20, 0x02	; 2
    2c0a:	51 05       	cpc	r21, r1
    2c0c:	61 05       	cpc	r22, r1
    2c0e:	71 05       	cpc	r23, r1
    2c10:	08 f4       	brcc	.+2      	; 0x2c14 <get_fat+0x26>
    2c12:	a7 c0       	rjmp	.+334    	; 0x2d62 <get_fat+0x174>
    2c14:	8a 89       	ldd	r24, Y+18	; 0x12
    2c16:	9b 89       	ldd	r25, Y+19	; 0x13
    2c18:	ac 89       	ldd	r26, Y+20	; 0x14
    2c1a:	bd 89       	ldd	r27, Y+21	; 0x15
    2c1c:	48 17       	cp	r20, r24
    2c1e:	59 07       	cpc	r21, r25
    2c20:	6a 07       	cpc	r22, r26
    2c22:	7b 07       	cpc	r23, r27
    2c24:	08 f0       	brcs	.+2      	; 0x2c28 <get_fat+0x3a>
    2c26:	a2 c0       	rjmp	.+324    	; 0x2d6c <get_fat+0x17e>
    2c28:	88 81       	ld	r24, Y
    2c2a:	82 30       	cpi	r24, 0x02	; 2
    2c2c:	09 f4       	brne	.+2      	; 0x2c30 <get_fat+0x42>
    2c2e:	4b c0       	rjmp	.+150    	; 0x2cc6 <get_fat+0xd8>
    2c30:	83 30       	cpi	r24, 0x03	; 3
    2c32:	09 f4       	brne	.+2      	; 0x2c36 <get_fat+0x48>
    2c34:	69 c0       	rjmp	.+210    	; 0x2d08 <get_fat+0x11a>
    2c36:	81 30       	cpi	r24, 0x01	; 1
    2c38:	09 f0       	breq	.+2      	; 0x2c3c <get_fat+0x4e>
    2c3a:	9d c0       	rjmp	.+314    	; 0x2d76 <get_fat+0x188>
    2c3c:	8a 01       	movw	r16, r20
    2c3e:	16 95       	lsr	r17
    2c40:	07 95       	ror	r16
    2c42:	04 0f       	add	r16, r20
    2c44:	15 1f       	adc	r17, r21
    2c46:	c8 01       	movw	r24, r16
    2c48:	89 2f       	mov	r24, r25
    2c4a:	99 27       	eor	r25, r25
    2c4c:	86 95       	lsr	r24
    2c4e:	4e 8d       	ldd	r20, Y+30	; 0x1e
    2c50:	5f 8d       	ldd	r21, Y+31	; 0x1f
    2c52:	68 a1       	ldd	r22, Y+32	; 0x20
    2c54:	79 a1       	ldd	r23, Y+33	; 0x21
    2c56:	48 0f       	add	r20, r24
    2c58:	59 1f       	adc	r21, r25
    2c5a:	61 1d       	adc	r22, r1
    2c5c:	71 1d       	adc	r23, r1
    2c5e:	ce 01       	movw	r24, r28
    2c60:	b0 db       	rcall	.-2208   	; 0x23c2 <move_window>
    2c62:	81 11       	cpse	r24, r1
    2c64:	8d c0       	rjmp	.+282    	; 0x2d80 <get_fat+0x192>
    2c66:	58 01       	movw	r10, r16
    2c68:	8f ef       	ldi	r24, 0xFF	; 255
    2c6a:	a8 1a       	sub	r10, r24
    2c6c:	b8 0a       	sbc	r11, r24
    2c6e:	11 70       	andi	r17, 0x01	; 1
    2c70:	fe 01       	movw	r30, r28
    2c72:	e0 0f       	add	r30, r16
    2c74:	f1 1f       	adc	r31, r17
    2c76:	16 a5       	ldd	r17, Z+46	; 0x2e
    2c78:	c5 01       	movw	r24, r10
    2c7a:	89 2f       	mov	r24, r25
    2c7c:	99 27       	eor	r25, r25
    2c7e:	86 95       	lsr	r24
    2c80:	4e 8d       	ldd	r20, Y+30	; 0x1e
    2c82:	5f 8d       	ldd	r21, Y+31	; 0x1f
    2c84:	68 a1       	ldd	r22, Y+32	; 0x20
    2c86:	79 a1       	ldd	r23, Y+33	; 0x21
    2c88:	48 0f       	add	r20, r24
    2c8a:	59 1f       	adc	r21, r25
    2c8c:	61 1d       	adc	r22, r1
    2c8e:	71 1d       	adc	r23, r1
    2c90:	ce 01       	movw	r24, r28
    2c92:	97 db       	rcall	.-2258   	; 0x23c2 <move_window>
    2c94:	81 11       	cpse	r24, r1
    2c96:	78 c0       	rjmp	.+240    	; 0x2d88 <get_fat+0x19a>
    2c98:	81 e0       	ldi	r24, 0x01	; 1
    2c9a:	b8 22       	and	r11, r24
    2c9c:	ca 0d       	add	r28, r10
    2c9e:	db 1d       	adc	r29, r11
    2ca0:	8e a5       	ldd	r24, Y+46	; 0x2e
    2ca2:	61 2f       	mov	r22, r17
    2ca4:	70 e0       	ldi	r23, 0x00	; 0
    2ca6:	78 2b       	or	r23, r24
    2ca8:	c0 fe       	sbrs	r12, 0
    2caa:	09 c0       	rjmp	.+18     	; 0x2cbe <get_fat+0xd0>
    2cac:	72 95       	swap	r23
    2cae:	62 95       	swap	r22
    2cb0:	6f 70       	andi	r22, 0x0F	; 15
    2cb2:	67 27       	eor	r22, r23
    2cb4:	7f 70       	andi	r23, 0x0F	; 15
    2cb6:	67 27       	eor	r22, r23
    2cb8:	80 e0       	ldi	r24, 0x00	; 0
    2cba:	90 e0       	ldi	r25, 0x00	; 0
    2cbc:	70 c0       	rjmp	.+224    	; 0x2d9e <get_fat+0x1b0>
    2cbe:	7f 70       	andi	r23, 0x0F	; 15
    2cc0:	80 e0       	ldi	r24, 0x00	; 0
    2cc2:	90 e0       	ldi	r25, 0x00	; 0
    2cc4:	6c c0       	rjmp	.+216    	; 0x2d9e <get_fat+0x1b0>
    2cc6:	45 2f       	mov	r20, r21
    2cc8:	56 2f       	mov	r21, r22
    2cca:	67 2f       	mov	r22, r23
    2ccc:	77 27       	eor	r23, r23
    2cce:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2cd0:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2cd2:	a8 a1       	ldd	r26, Y+32	; 0x20
    2cd4:	b9 a1       	ldd	r27, Y+33	; 0x21
    2cd6:	48 0f       	add	r20, r24
    2cd8:	59 1f       	adc	r21, r25
    2cda:	6a 1f       	adc	r22, r26
    2cdc:	7b 1f       	adc	r23, r27
    2cde:	ce 01       	movw	r24, r28
    2ce0:	70 db       	rcall	.-2336   	; 0x23c2 <move_window>
    2ce2:	81 11       	cpse	r24, r1
    2ce4:	55 c0       	rjmp	.+170    	; 0x2d90 <get_fat+0x1a2>
    2ce6:	cc 0c       	add	r12, r12
    2ce8:	dd 1c       	adc	r13, r13
    2cea:	ee 1c       	adc	r14, r14
    2cec:	ff 1c       	adc	r15, r15
    2cee:	e8 94       	clt
    2cf0:	c0 f8       	bld	r12, 0
    2cf2:	81 e0       	ldi	r24, 0x01	; 1
    2cf4:	d8 22       	and	r13, r24
    2cf6:	ee 24       	eor	r14, r14
    2cf8:	ff 24       	eor	r15, r15
    2cfa:	cc 0d       	add	r28, r12
    2cfc:	dd 1d       	adc	r29, r13
    2cfe:	6e a5       	ldd	r22, Y+46	; 0x2e
    2d00:	7f a5       	ldd	r23, Y+47	; 0x2f
    2d02:	80 e0       	ldi	r24, 0x00	; 0
    2d04:	90 e0       	ldi	r25, 0x00	; 0
    2d06:	4b c0       	rjmp	.+150    	; 0x2d9e <get_fat+0x1b0>
    2d08:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2d0a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2d0c:	a8 a1       	ldd	r26, Y+32	; 0x20
    2d0e:	b9 a1       	ldd	r27, Y+33	; 0x21
    2d10:	68 94       	set
    2d12:	16 f8       	bld	r1, 6
    2d14:	76 95       	lsr	r23
    2d16:	67 95       	ror	r22
    2d18:	57 95       	ror	r21
    2d1a:	47 95       	ror	r20
    2d1c:	16 94       	lsr	r1
    2d1e:	d1 f7       	brne	.-12     	; 0x2d14 <get_fat+0x126>
    2d20:	48 0f       	add	r20, r24
    2d22:	59 1f       	adc	r21, r25
    2d24:	6a 1f       	adc	r22, r26
    2d26:	7b 1f       	adc	r23, r27
    2d28:	ce 01       	movw	r24, r28
    2d2a:	4b db       	rcall	.-2410   	; 0x23c2 <move_window>
    2d2c:	81 11       	cpse	r24, r1
    2d2e:	34 c0       	rjmp	.+104    	; 0x2d98 <get_fat+0x1aa>
    2d30:	cc 0c       	add	r12, r12
    2d32:	dd 1c       	adc	r13, r13
    2d34:	ee 1c       	adc	r14, r14
    2d36:	ff 1c       	adc	r15, r15
    2d38:	cc 0c       	add	r12, r12
    2d3a:	dd 1c       	adc	r13, r13
    2d3c:	ee 1c       	adc	r14, r14
    2d3e:	ff 1c       	adc	r15, r15
    2d40:	8c ef       	ldi	r24, 0xFC	; 252
    2d42:	c8 22       	and	r12, r24
    2d44:	81 e0       	ldi	r24, 0x01	; 1
    2d46:	d8 22       	and	r13, r24
    2d48:	ee 24       	eor	r14, r14
    2d4a:	ff 24       	eor	r15, r15
    2d4c:	fe 01       	movw	r30, r28
    2d4e:	ec 0d       	add	r30, r12
    2d50:	fd 1d       	adc	r31, r13
    2d52:	86 a5       	ldd	r24, Z+46	; 0x2e
    2d54:	97 a5       	ldd	r25, Z+47	; 0x2f
    2d56:	a0 a9       	ldd	r26, Z+48	; 0x30
    2d58:	b1 a9       	ldd	r27, Z+49	; 0x31
    2d5a:	bc 01       	movw	r22, r24
    2d5c:	cd 01       	movw	r24, r26
    2d5e:	9f 70       	andi	r25, 0x0F	; 15
    2d60:	1e c0       	rjmp	.+60     	; 0x2d9e <get_fat+0x1b0>
    2d62:	61 e0       	ldi	r22, 0x01	; 1
    2d64:	70 e0       	ldi	r23, 0x00	; 0
    2d66:	80 e0       	ldi	r24, 0x00	; 0
    2d68:	90 e0       	ldi	r25, 0x00	; 0
    2d6a:	19 c0       	rjmp	.+50     	; 0x2d9e <get_fat+0x1b0>
    2d6c:	61 e0       	ldi	r22, 0x01	; 1
    2d6e:	70 e0       	ldi	r23, 0x00	; 0
    2d70:	80 e0       	ldi	r24, 0x00	; 0
    2d72:	90 e0       	ldi	r25, 0x00	; 0
    2d74:	14 c0       	rjmp	.+40     	; 0x2d9e <get_fat+0x1b0>
    2d76:	61 e0       	ldi	r22, 0x01	; 1
    2d78:	70 e0       	ldi	r23, 0x00	; 0
    2d7a:	80 e0       	ldi	r24, 0x00	; 0
    2d7c:	90 e0       	ldi	r25, 0x00	; 0
    2d7e:	0f c0       	rjmp	.+30     	; 0x2d9e <get_fat+0x1b0>
    2d80:	6f ef       	ldi	r22, 0xFF	; 255
    2d82:	7f ef       	ldi	r23, 0xFF	; 255
    2d84:	cb 01       	movw	r24, r22
    2d86:	0b c0       	rjmp	.+22     	; 0x2d9e <get_fat+0x1b0>
    2d88:	6f ef       	ldi	r22, 0xFF	; 255
    2d8a:	7f ef       	ldi	r23, 0xFF	; 255
    2d8c:	cb 01       	movw	r24, r22
    2d8e:	07 c0       	rjmp	.+14     	; 0x2d9e <get_fat+0x1b0>
    2d90:	6f ef       	ldi	r22, 0xFF	; 255
    2d92:	7f ef       	ldi	r23, 0xFF	; 255
    2d94:	cb 01       	movw	r24, r22
    2d96:	03 c0       	rjmp	.+6      	; 0x2d9e <get_fat+0x1b0>
    2d98:	6f ef       	ldi	r22, 0xFF	; 255
    2d9a:	7f ef       	ldi	r23, 0xFF	; 255
    2d9c:	cb 01       	movw	r24, r22
    2d9e:	df 91       	pop	r29
    2da0:	cf 91       	pop	r28
    2da2:	1f 91       	pop	r17
    2da4:	0f 91       	pop	r16
    2da6:	ff 90       	pop	r15
    2da8:	ef 90       	pop	r14
    2daa:	df 90       	pop	r13
    2dac:	cf 90       	pop	r12
    2dae:	bf 90       	pop	r11
    2db0:	af 90       	pop	r10
    2db2:	08 95       	ret

00002db4 <dir_sdi>:
    2db4:	af 92       	push	r10
    2db6:	bf 92       	push	r11
    2db8:	cf 92       	push	r12
    2dba:	df 92       	push	r13
    2dbc:	ef 92       	push	r14
    2dbe:	ff 92       	push	r15
    2dc0:	0f 93       	push	r16
    2dc2:	1f 93       	push	r17
    2dc4:	cf 93       	push	r28
    2dc6:	df 93       	push	r29
    2dc8:	ec 01       	movw	r28, r24
    2dca:	8b 01       	movw	r16, r22
    2dcc:	7d 83       	std	Y+5, r23	; 0x05
    2dce:	6c 83       	std	Y+4, r22	; 0x04
    2dd0:	ce 80       	ldd	r12, Y+6	; 0x06
    2dd2:	df 80       	ldd	r13, Y+7	; 0x07
    2dd4:	e8 84       	ldd	r14, Y+8	; 0x08
    2dd6:	f9 84       	ldd	r15, Y+9	; 0x09
    2dd8:	81 e0       	ldi	r24, 0x01	; 1
    2dda:	c8 16       	cp	r12, r24
    2ddc:	d1 04       	cpc	r13, r1
    2dde:	e1 04       	cpc	r14, r1
    2de0:	f1 04       	cpc	r15, r1
    2de2:	09 f4       	brne	.+2      	; 0x2de6 <dir_sdi+0x32>
    2de4:	8a c0       	rjmp	.+276    	; 0x2efa <dir_sdi+0x146>
    2de6:	e8 81       	ld	r30, Y
    2de8:	f9 81       	ldd	r31, Y+1	; 0x01
    2dea:	82 89       	ldd	r24, Z+18	; 0x12
    2dec:	93 89       	ldd	r25, Z+19	; 0x13
    2dee:	a4 89       	ldd	r26, Z+20	; 0x14
    2df0:	b5 89       	ldd	r27, Z+21	; 0x15
    2df2:	c8 16       	cp	r12, r24
    2df4:	d9 06       	cpc	r13, r25
    2df6:	ea 06       	cpc	r14, r26
    2df8:	fb 06       	cpc	r15, r27
    2dfa:	08 f0       	brcs	.+2      	; 0x2dfe <dir_sdi+0x4a>
    2dfc:	80 c0       	rjmp	.+256    	; 0x2efe <dir_sdi+0x14a>
    2dfe:	c1 14       	cp	r12, r1
    2e00:	d1 04       	cpc	r13, r1
    2e02:	e1 04       	cpc	r14, r1
    2e04:	f1 04       	cpc	r15, r1
    2e06:	c1 f4       	brne	.+48     	; 0x2e38 <dir_sdi+0x84>
    2e08:	80 81       	ld	r24, Z
    2e0a:	83 30       	cpi	r24, 0x03	; 3
    2e0c:	41 f4       	brne	.+16     	; 0x2e1e <dir_sdi+0x6a>
    2e0e:	82 a1       	ldd	r24, Z+34	; 0x22
    2e10:	93 a1       	ldd	r25, Z+35	; 0x23
    2e12:	a4 a1       	ldd	r26, Z+36	; 0x24
    2e14:	b5 a1       	ldd	r27, Z+37	; 0x25
    2e16:	00 97       	sbiw	r24, 0x00	; 0
    2e18:	a1 05       	cpc	r26, r1
    2e1a:	b1 05       	cpc	r27, r1
    2e1c:	59 f4       	brne	.+22     	; 0x2e34 <dir_sdi+0x80>
    2e1e:	80 85       	ldd	r24, Z+8	; 0x08
    2e20:	91 85       	ldd	r25, Z+9	; 0x09
    2e22:	08 17       	cp	r16, r24
    2e24:	19 07       	cpc	r17, r25
    2e26:	08 f0       	brcs	.+2      	; 0x2e2a <dir_sdi+0x76>
    2e28:	6c c0       	rjmp	.+216    	; 0x2f02 <dir_sdi+0x14e>
    2e2a:	62 a1       	ldd	r22, Z+34	; 0x22
    2e2c:	73 a1       	ldd	r23, Z+35	; 0x23
    2e2e:	84 a1       	ldd	r24, Z+36	; 0x24
    2e30:	95 a1       	ldd	r25, Z+37	; 0x25
    2e32:	35 c0       	rjmp	.+106    	; 0x2e9e <dir_sdi+0xea>
    2e34:	6c 01       	movw	r12, r24
    2e36:	7d 01       	movw	r14, r26
    2e38:	a2 80       	ldd	r10, Z+2	; 0x02
    2e3a:	80 e1       	ldi	r24, 0x10	; 16
    2e3c:	a8 9e       	mul	r10, r24
    2e3e:	50 01       	movw	r10, r0
    2e40:	11 24       	eor	r1, r1
    2e42:	0a 15       	cp	r16, r10
    2e44:	1b 05       	cpc	r17, r11
    2e46:	30 f1       	brcs	.+76     	; 0x2e94 <dir_sdi+0xe0>
    2e48:	b7 01       	movw	r22, r14
    2e4a:	a6 01       	movw	r20, r12
    2e4c:	88 81       	ld	r24, Y
    2e4e:	99 81       	ldd	r25, Y+1	; 0x01
    2e50:	ce de       	rcall	.-612    	; 0x2bee <get_fat>
    2e52:	6b 01       	movw	r12, r22
    2e54:	7c 01       	movw	r14, r24
    2e56:	8f ef       	ldi	r24, 0xFF	; 255
    2e58:	c8 16       	cp	r12, r24
    2e5a:	d8 06       	cpc	r13, r24
    2e5c:	e8 06       	cpc	r14, r24
    2e5e:	f8 06       	cpc	r15, r24
    2e60:	09 f4       	brne	.+2      	; 0x2e64 <dir_sdi+0xb0>
    2e62:	51 c0       	rjmp	.+162    	; 0x2f06 <dir_sdi+0x152>
    2e64:	82 e0       	ldi	r24, 0x02	; 2
    2e66:	c8 16       	cp	r12, r24
    2e68:	d1 04       	cpc	r13, r1
    2e6a:	e1 04       	cpc	r14, r1
    2e6c:	f1 04       	cpc	r15, r1
    2e6e:	08 f4       	brcc	.+2      	; 0x2e72 <dir_sdi+0xbe>
    2e70:	4c c0       	rjmp	.+152    	; 0x2f0a <dir_sdi+0x156>
    2e72:	e8 81       	ld	r30, Y
    2e74:	f9 81       	ldd	r31, Y+1	; 0x01
    2e76:	82 89       	ldd	r24, Z+18	; 0x12
    2e78:	93 89       	ldd	r25, Z+19	; 0x13
    2e7a:	a4 89       	ldd	r26, Z+20	; 0x14
    2e7c:	b5 89       	ldd	r27, Z+21	; 0x15
    2e7e:	c8 16       	cp	r12, r24
    2e80:	d9 06       	cpc	r13, r25
    2e82:	ea 06       	cpc	r14, r26
    2e84:	fb 06       	cpc	r15, r27
    2e86:	08 f0       	brcs	.+2      	; 0x2e8a <dir_sdi+0xd6>
    2e88:	42 c0       	rjmp	.+132    	; 0x2f0e <dir_sdi+0x15a>
    2e8a:	0a 19       	sub	r16, r10
    2e8c:	1b 09       	sbc	r17, r11
    2e8e:	0a 15       	cp	r16, r10
    2e90:	1b 05       	cpc	r17, r11
    2e92:	d0 f6       	brcc	.-76     	; 0x2e48 <dir_sdi+0x94>
    2e94:	b7 01       	movw	r22, r14
    2e96:	a6 01       	movw	r20, r12
    2e98:	88 81       	ld	r24, Y
    2e9a:	99 81       	ldd	r25, Y+1	; 0x01
    2e9c:	7a de       	rcall	.-780    	; 0x2b92 <clust2sect>
    2e9e:	ca 86       	std	Y+10, r12	; 0x0a
    2ea0:	db 86       	std	Y+11, r13	; 0x0b
    2ea2:	ec 86       	std	Y+12, r14	; 0x0c
    2ea4:	fd 86       	std	Y+13, r15	; 0x0d
    2ea6:	61 15       	cp	r22, r1
    2ea8:	71 05       	cpc	r23, r1
    2eaa:	81 05       	cpc	r24, r1
    2eac:	91 05       	cpc	r25, r1
    2eae:	89 f1       	breq	.+98     	; 0x2f12 <dir_sdi+0x15e>
    2eb0:	98 01       	movw	r18, r16
    2eb2:	32 95       	swap	r19
    2eb4:	22 95       	swap	r18
    2eb6:	2f 70       	andi	r18, 0x0F	; 15
    2eb8:	23 27       	eor	r18, r19
    2eba:	3f 70       	andi	r19, 0x0F	; 15
    2ebc:	23 27       	eor	r18, r19
    2ebe:	dc 01       	movw	r26, r24
    2ec0:	cb 01       	movw	r24, r22
    2ec2:	82 0f       	add	r24, r18
    2ec4:	93 1f       	adc	r25, r19
    2ec6:	a1 1d       	adc	r26, r1
    2ec8:	b1 1d       	adc	r27, r1
    2eca:	8e 87       	std	Y+14, r24	; 0x0e
    2ecc:	9f 87       	std	Y+15, r25	; 0x0f
    2ece:	a8 8b       	std	Y+16, r26	; 0x10
    2ed0:	b9 8b       	std	Y+17, r27	; 0x11
    2ed2:	0f 70       	andi	r16, 0x0F	; 15
    2ed4:	11 27       	eor	r17, r17
    2ed6:	00 0f       	add	r16, r16
    2ed8:	11 1f       	adc	r17, r17
    2eda:	02 95       	swap	r16
    2edc:	12 95       	swap	r17
    2ede:	10 7f       	andi	r17, 0xF0	; 240
    2ee0:	10 27       	eor	r17, r16
    2ee2:	00 7f       	andi	r16, 0xF0	; 240
    2ee4:	10 27       	eor	r17, r16
    2ee6:	02 5d       	subi	r16, 0xD2	; 210
    2ee8:	1f 4f       	sbci	r17, 0xFF	; 255
    2eea:	88 81       	ld	r24, Y
    2eec:	99 81       	ldd	r25, Y+1	; 0x01
    2eee:	80 0f       	add	r24, r16
    2ef0:	91 1f       	adc	r25, r17
    2ef2:	9b 8b       	std	Y+19, r25	; 0x13
    2ef4:	8a 8b       	std	Y+18, r24	; 0x12
    2ef6:	80 e0       	ldi	r24, 0x00	; 0
    2ef8:	0d c0       	rjmp	.+26     	; 0x2f14 <dir_sdi+0x160>
    2efa:	82 e0       	ldi	r24, 0x02	; 2
    2efc:	0b c0       	rjmp	.+22     	; 0x2f14 <dir_sdi+0x160>
    2efe:	82 e0       	ldi	r24, 0x02	; 2
    2f00:	09 c0       	rjmp	.+18     	; 0x2f14 <dir_sdi+0x160>
    2f02:	82 e0       	ldi	r24, 0x02	; 2
    2f04:	07 c0       	rjmp	.+14     	; 0x2f14 <dir_sdi+0x160>
    2f06:	81 e0       	ldi	r24, 0x01	; 1
    2f08:	05 c0       	rjmp	.+10     	; 0x2f14 <dir_sdi+0x160>
    2f0a:	82 e0       	ldi	r24, 0x02	; 2
    2f0c:	03 c0       	rjmp	.+6      	; 0x2f14 <dir_sdi+0x160>
    2f0e:	82 e0       	ldi	r24, 0x02	; 2
    2f10:	01 c0       	rjmp	.+2      	; 0x2f14 <dir_sdi+0x160>
    2f12:	82 e0       	ldi	r24, 0x02	; 2
    2f14:	df 91       	pop	r29
    2f16:	cf 91       	pop	r28
    2f18:	1f 91       	pop	r17
    2f1a:	0f 91       	pop	r16
    2f1c:	ff 90       	pop	r15
    2f1e:	ef 90       	pop	r14
    2f20:	df 90       	pop	r13
    2f22:	cf 90       	pop	r12
    2f24:	bf 90       	pop	r11
    2f26:	af 90       	pop	r10
    2f28:	08 95       	ret

00002f2a <put_fat>:
    2f2a:	4f 92       	push	r4
    2f2c:	5f 92       	push	r5
    2f2e:	6f 92       	push	r6
    2f30:	7f 92       	push	r7
    2f32:	8f 92       	push	r8
    2f34:	9f 92       	push	r9
    2f36:	af 92       	push	r10
    2f38:	bf 92       	push	r11
    2f3a:	cf 92       	push	r12
    2f3c:	df 92       	push	r13
    2f3e:	ef 92       	push	r14
    2f40:	ff 92       	push	r15
    2f42:	0f 93       	push	r16
    2f44:	1f 93       	push	r17
    2f46:	cf 93       	push	r28
    2f48:	df 93       	push	r29
    2f4a:	ec 01       	movw	r28, r24
    2f4c:	6a 01       	movw	r12, r20
    2f4e:	7b 01       	movw	r14, r22
    2f50:	28 01       	movw	r4, r16
    2f52:	39 01       	movw	r6, r18
    2f54:	42 30       	cpi	r20, 0x02	; 2
    2f56:	51 05       	cpc	r21, r1
    2f58:	61 05       	cpc	r22, r1
    2f5a:	71 05       	cpc	r23, r1
    2f5c:	08 f4       	brcc	.+2      	; 0x2f60 <put_fat+0x36>
    2f5e:	d2 c0       	rjmp	.+420    	; 0x3104 <put_fat+0x1da>
    2f60:	8a 89       	ldd	r24, Y+18	; 0x12
    2f62:	9b 89       	ldd	r25, Y+19	; 0x13
    2f64:	ac 89       	ldd	r26, Y+20	; 0x14
    2f66:	bd 89       	ldd	r27, Y+21	; 0x15
    2f68:	48 17       	cp	r20, r24
    2f6a:	59 07       	cpc	r21, r25
    2f6c:	6a 07       	cpc	r22, r26
    2f6e:	7b 07       	cpc	r23, r27
    2f70:	08 f0       	brcs	.+2      	; 0x2f74 <put_fat+0x4a>
    2f72:	ca c0       	rjmp	.+404    	; 0x3108 <put_fat+0x1de>
    2f74:	88 81       	ld	r24, Y
    2f76:	82 30       	cpi	r24, 0x02	; 2
    2f78:	09 f4       	brne	.+2      	; 0x2f7c <put_fat+0x52>
    2f7a:	62 c0       	rjmp	.+196    	; 0x3040 <put_fat+0x116>
    2f7c:	83 30       	cpi	r24, 0x03	; 3
    2f7e:	09 f4       	brne	.+2      	; 0x2f82 <put_fat+0x58>
    2f80:	85 c0       	rjmp	.+266    	; 0x308c <put_fat+0x162>
    2f82:	81 30       	cpi	r24, 0x01	; 1
    2f84:	09 f0       	breq	.+2      	; 0x2f88 <put_fat+0x5e>
    2f86:	c2 c0       	rjmp	.+388    	; 0x310c <put_fat+0x1e2>
    2f88:	5a 01       	movw	r10, r20
    2f8a:	b6 94       	lsr	r11
    2f8c:	a7 94       	ror	r10
    2f8e:	a4 0e       	add	r10, r20
    2f90:	b5 1e       	adc	r11, r21
    2f92:	c5 01       	movw	r24, r10
    2f94:	89 2f       	mov	r24, r25
    2f96:	99 27       	eor	r25, r25
    2f98:	86 95       	lsr	r24
    2f9a:	4e 8d       	ldd	r20, Y+30	; 0x1e
    2f9c:	5f 8d       	ldd	r21, Y+31	; 0x1f
    2f9e:	68 a1       	ldd	r22, Y+32	; 0x20
    2fa0:	79 a1       	ldd	r23, Y+33	; 0x21
    2fa2:	48 0f       	add	r20, r24
    2fa4:	59 1f       	adc	r21, r25
    2fa6:	61 1d       	adc	r22, r1
    2fa8:	71 1d       	adc	r23, r1
    2faa:	ce 01       	movw	r24, r28
    2fac:	0a da       	rcall	.-3052   	; 0x23c2 <move_window>
    2fae:	18 2f       	mov	r17, r24
    2fb0:	81 11       	cpse	r24, r1
    2fb2:	ca c0       	rjmp	.+404    	; 0x3148 <put_fat+0x21e>
    2fb4:	45 01       	movw	r8, r10
    2fb6:	8f ef       	ldi	r24, 0xFF	; 255
    2fb8:	88 1a       	sub	r8, r24
    2fba:	98 0a       	sbc	r9, r24
    2fbc:	31 e0       	ldi	r19, 0x01	; 1
    2fbe:	b3 22       	and	r11, r19
    2fc0:	c0 fe       	sbrs	r12, 0
    2fc2:	20 c0       	rjmp	.+64     	; 0x3004 <put_fat+0xda>
    2fc4:	fe 01       	movw	r30, r28
    2fc6:	ea 0d       	add	r30, r10
    2fc8:	fb 1d       	adc	r31, r11
    2fca:	86 a5       	ldd	r24, Z+46	; 0x2e
    2fcc:	28 2f       	mov	r18, r24
    2fce:	2f 70       	andi	r18, 0x0F	; 15
    2fd0:	30 e1       	ldi	r19, 0x10	; 16
    2fd2:	43 9e       	mul	r4, r19
    2fd4:	c0 01       	movw	r24, r0
    2fd6:	11 24       	eor	r1, r1
    2fd8:	82 2b       	or	r24, r18
    2fda:	86 a7       	std	Z+46, r24	; 0x2e
    2fdc:	81 e0       	ldi	r24, 0x01	; 1
    2fde:	8c 83       	std	Y+4, r24	; 0x04
    2fe0:	4e 8d       	ldd	r20, Y+30	; 0x1e
    2fe2:	5f 8d       	ldd	r21, Y+31	; 0x1f
    2fe4:	68 a1       	ldd	r22, Y+32	; 0x20
    2fe6:	79 a1       	ldd	r23, Y+33	; 0x21
    2fe8:	c4 01       	movw	r24, r8
    2fea:	89 2f       	mov	r24, r25
    2fec:	99 27       	eor	r25, r25
    2fee:	86 95       	lsr	r24
    2ff0:	48 0f       	add	r20, r24
    2ff2:	59 1f       	adc	r21, r25
    2ff4:	61 1d       	adc	r22, r1
    2ff6:	71 1d       	adc	r23, r1
    2ff8:	ce 01       	movw	r24, r28
    2ffa:	e3 d9       	rcall	.-3130   	; 0x23c2 <move_window>
    2ffc:	88 23       	and	r24, r24
    2ffe:	09 f4       	brne	.+2      	; 0x3002 <put_fat+0xd8>
    3000:	8b c0       	rjmp	.+278    	; 0x3118 <put_fat+0x1ee>
    3002:	86 c0       	rjmp	.+268    	; 0x3110 <put_fat+0x1e6>
    3004:	fe 01       	movw	r30, r28
    3006:	ea 0d       	add	r30, r10
    3008:	fb 1d       	adc	r31, r11
    300a:	46 a6       	std	Z+46, r4	; 0x2e
    300c:	81 e0       	ldi	r24, 0x01	; 1
    300e:	8c 83       	std	Y+4, r24	; 0x04
    3010:	4e 8d       	ldd	r20, Y+30	; 0x1e
    3012:	5f 8d       	ldd	r21, Y+31	; 0x1f
    3014:	68 a1       	ldd	r22, Y+32	; 0x20
    3016:	79 a1       	ldd	r23, Y+33	; 0x21
    3018:	c4 01       	movw	r24, r8
    301a:	89 2f       	mov	r24, r25
    301c:	99 27       	eor	r25, r25
    301e:	86 95       	lsr	r24
    3020:	48 0f       	add	r20, r24
    3022:	59 1f       	adc	r21, r25
    3024:	61 1d       	adc	r22, r1
    3026:	71 1d       	adc	r23, r1
    3028:	ce 01       	movw	r24, r28
    302a:	cb d9       	rcall	.-3178   	; 0x23c2 <move_window>
    302c:	88 23       	and	r24, r24
    302e:	09 f4       	brne	.+2      	; 0x3032 <put_fat+0x108>
    3030:	7e c0       	rjmp	.+252    	; 0x312e <put_fat+0x204>
    3032:	70 c0       	rjmp	.+224    	; 0x3114 <put_fat+0x1ea>
    3034:	ec 0f       	add	r30, r28
    3036:	fd 1f       	adc	r31, r29
    3038:	46 a6       	std	Z+46, r4	; 0x2e
    303a:	81 e0       	ldi	r24, 0x01	; 1
    303c:	8c 83       	std	Y+4, r24	; 0x04
    303e:	84 c0       	rjmp	.+264    	; 0x3148 <put_fat+0x21e>
    3040:	45 2f       	mov	r20, r21
    3042:	56 2f       	mov	r21, r22
    3044:	67 2f       	mov	r22, r23
    3046:	77 27       	eor	r23, r23
    3048:	8e 8d       	ldd	r24, Y+30	; 0x1e
    304a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    304c:	a8 a1       	ldd	r26, Y+32	; 0x20
    304e:	b9 a1       	ldd	r27, Y+33	; 0x21
    3050:	48 0f       	add	r20, r24
    3052:	59 1f       	adc	r21, r25
    3054:	6a 1f       	adc	r22, r26
    3056:	7b 1f       	adc	r23, r27
    3058:	ce 01       	movw	r24, r28
    305a:	b3 d9       	rcall	.-3226   	; 0x23c2 <move_window>
    305c:	18 2f       	mov	r17, r24
    305e:	81 11       	cpse	r24, r1
    3060:	73 c0       	rjmp	.+230    	; 0x3148 <put_fat+0x21e>
    3062:	cc 0c       	add	r12, r12
    3064:	dd 1c       	adc	r13, r13
    3066:	ee 1c       	adc	r14, r14
    3068:	ff 1c       	adc	r15, r15
    306a:	e8 94       	clt
    306c:	c0 f8       	bld	r12, 0
    306e:	81 e0       	ldi	r24, 0x01	; 1
    3070:	d8 22       	and	r13, r24
    3072:	ee 24       	eor	r14, r14
    3074:	ff 24       	eor	r15, r15
    3076:	3e e2       	ldi	r19, 0x2E	; 46
    3078:	c3 0e       	add	r12, r19
    307a:	d1 1c       	adc	r13, r1
    307c:	fe 01       	movw	r30, r28
    307e:	ec 0d       	add	r30, r12
    3080:	fd 1d       	adc	r31, r13
    3082:	51 82       	std	Z+1, r5	; 0x01
    3084:	40 82       	st	Z, r4
    3086:	81 e0       	ldi	r24, 0x01	; 1
    3088:	8c 83       	std	Y+4, r24	; 0x04
    308a:	5e c0       	rjmp	.+188    	; 0x3148 <put_fat+0x21e>
    308c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    308e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3090:	a8 a1       	ldd	r26, Y+32	; 0x20
    3092:	b9 a1       	ldd	r27, Y+33	; 0x21
    3094:	68 94       	set
    3096:	16 f8       	bld	r1, 6
    3098:	76 95       	lsr	r23
    309a:	67 95       	ror	r22
    309c:	57 95       	ror	r21
    309e:	47 95       	ror	r20
    30a0:	16 94       	lsr	r1
    30a2:	d1 f7       	brne	.-12     	; 0x3098 <put_fat+0x16e>
    30a4:	48 0f       	add	r20, r24
    30a6:	59 1f       	adc	r21, r25
    30a8:	6a 1f       	adc	r22, r26
    30aa:	7b 1f       	adc	r23, r27
    30ac:	ce 01       	movw	r24, r28
    30ae:	89 d9       	rcall	.-3310   	; 0x23c2 <move_window>
    30b0:	18 2f       	mov	r17, r24
    30b2:	81 11       	cpse	r24, r1
    30b4:	49 c0       	rjmp	.+146    	; 0x3148 <put_fat+0x21e>
    30b6:	cc 0c       	add	r12, r12
    30b8:	dd 1c       	adc	r13, r13
    30ba:	ee 1c       	adc	r14, r14
    30bc:	ff 1c       	adc	r15, r15
    30be:	cc 0c       	add	r12, r12
    30c0:	dd 1c       	adc	r13, r13
    30c2:	ee 1c       	adc	r14, r14
    30c4:	ff 1c       	adc	r15, r15
    30c6:	8c ef       	ldi	r24, 0xFC	; 252
    30c8:	c8 22       	and	r12, r24
    30ca:	81 e0       	ldi	r24, 0x01	; 1
    30cc:	d8 22       	and	r13, r24
    30ce:	ee 24       	eor	r14, r14
    30d0:	ff 24       	eor	r15, r15
    30d2:	3e e2       	ldi	r19, 0x2E	; 46
    30d4:	c3 0e       	add	r12, r19
    30d6:	d1 1c       	adc	r13, r1
    30d8:	fe 01       	movw	r30, r28
    30da:	ec 0d       	add	r30, r12
    30dc:	fd 1d       	adc	r31, r13
    30de:	80 81       	ld	r24, Z
    30e0:	91 81       	ldd	r25, Z+1	; 0x01
    30e2:	a2 81       	ldd	r26, Z+2	; 0x02
    30e4:	b3 81       	ldd	r27, Z+3	; 0x03
    30e6:	88 27       	eor	r24, r24
    30e8:	99 27       	eor	r25, r25
    30ea:	aa 27       	eor	r26, r26
    30ec:	b0 7f       	andi	r27, 0xF0	; 240
    30ee:	48 2a       	or	r4, r24
    30f0:	59 2a       	or	r5, r25
    30f2:	6a 2a       	or	r6, r26
    30f4:	7b 2a       	or	r7, r27
    30f6:	40 82       	st	Z, r4
    30f8:	51 82       	std	Z+1, r5	; 0x01
    30fa:	62 82       	std	Z+2, r6	; 0x02
    30fc:	73 82       	std	Z+3, r7	; 0x03
    30fe:	81 e0       	ldi	r24, 0x01	; 1
    3100:	8c 83       	std	Y+4, r24	; 0x04
    3102:	22 c0       	rjmp	.+68     	; 0x3148 <put_fat+0x21e>
    3104:	12 e0       	ldi	r17, 0x02	; 2
    3106:	20 c0       	rjmp	.+64     	; 0x3148 <put_fat+0x21e>
    3108:	12 e0       	ldi	r17, 0x02	; 2
    310a:	1e c0       	rjmp	.+60     	; 0x3148 <put_fat+0x21e>
    310c:	12 e0       	ldi	r17, 0x02	; 2
    310e:	1c c0       	rjmp	.+56     	; 0x3148 <put_fat+0x21e>
    3110:	18 2f       	mov	r17, r24
    3112:	1a c0       	rjmp	.+52     	; 0x3148 <put_fat+0x21e>
    3114:	18 2f       	mov	r17, r24
    3116:	18 c0       	rjmp	.+48     	; 0x3148 <put_fat+0x21e>
    3118:	f4 01       	movw	r30, r8
    311a:	f1 70       	andi	r31, 0x01	; 1
    311c:	68 94       	set
    311e:	13 f8       	bld	r1, 3
    3120:	76 94       	lsr	r7
    3122:	67 94       	ror	r6
    3124:	57 94       	ror	r5
    3126:	47 94       	ror	r4
    3128:	16 94       	lsr	r1
    312a:	d1 f7       	brne	.-12     	; 0x3120 <put_fat+0x1f6>
    312c:	83 cf       	rjmp	.-250    	; 0x3034 <put_fat+0x10a>
    312e:	f4 01       	movw	r30, r8
    3130:	f1 70       	andi	r31, 0x01	; 1
    3132:	de 01       	movw	r26, r28
    3134:	ae 0f       	add	r26, r30
    3136:	bf 1f       	adc	r27, r31
    3138:	9e 96       	adiw	r26, 0x2e	; 46
    313a:	9c 91       	ld	r25, X
    313c:	90 7f       	andi	r25, 0xF0	; 240
    313e:	85 2d       	mov	r24, r5
    3140:	8f 70       	andi	r24, 0x0F	; 15
    3142:	49 2e       	mov	r4, r25
    3144:	48 2a       	or	r4, r24
    3146:	76 cf       	rjmp	.-276    	; 0x3034 <put_fat+0x10a>
    3148:	81 2f       	mov	r24, r17
    314a:	df 91       	pop	r29
    314c:	cf 91       	pop	r28
    314e:	1f 91       	pop	r17
    3150:	0f 91       	pop	r16
    3152:	ff 90       	pop	r15
    3154:	ef 90       	pop	r14
    3156:	df 90       	pop	r13
    3158:	cf 90       	pop	r12
    315a:	bf 90       	pop	r11
    315c:	af 90       	pop	r10
    315e:	9f 90       	pop	r9
    3160:	8f 90       	pop	r8
    3162:	7f 90       	pop	r7
    3164:	6f 90       	pop	r6
    3166:	5f 90       	pop	r5
    3168:	4f 90       	pop	r4
    316a:	08 95       	ret

0000316c <create_chain>:
    316c:	2f 92       	push	r2
    316e:	3f 92       	push	r3
    3170:	4f 92       	push	r4
    3172:	5f 92       	push	r5
    3174:	6f 92       	push	r6
    3176:	7f 92       	push	r7
    3178:	8f 92       	push	r8
    317a:	9f 92       	push	r9
    317c:	af 92       	push	r10
    317e:	bf 92       	push	r11
    3180:	cf 92       	push	r12
    3182:	df 92       	push	r13
    3184:	ef 92       	push	r14
    3186:	ff 92       	push	r15
    3188:	0f 93       	push	r16
    318a:	1f 93       	push	r17
    318c:	cf 93       	push	r28
    318e:	df 93       	push	r29
    3190:	ec 01       	movw	r28, r24
    3192:	2a 01       	movw	r4, r20
    3194:	3b 01       	movw	r6, r22
    3196:	41 15       	cp	r20, r1
    3198:	51 05       	cpc	r21, r1
    319a:	61 05       	cpc	r22, r1
    319c:	71 05       	cpc	r23, r1
    319e:	b9 f4       	brne	.+46     	; 0x31ce <create_chain+0x62>
    31a0:	8a 84       	ldd	r8, Y+10	; 0x0a
    31a2:	9b 84       	ldd	r9, Y+11	; 0x0b
    31a4:	ac 84       	ldd	r10, Y+12	; 0x0c
    31a6:	bd 84       	ldd	r11, Y+13	; 0x0d
    31a8:	81 14       	cp	r8, r1
    31aa:	91 04       	cpc	r9, r1
    31ac:	a1 04       	cpc	r10, r1
    31ae:	b1 04       	cpc	r11, r1
    31b0:	59 f1       	breq	.+86     	; 0x3208 <create_chain+0x9c>
    31b2:	8a 89       	ldd	r24, Y+18	; 0x12
    31b4:	9b 89       	ldd	r25, Y+19	; 0x13
    31b6:	ac 89       	ldd	r26, Y+20	; 0x14
    31b8:	bd 89       	ldd	r27, Y+21	; 0x15
    31ba:	88 16       	cp	r8, r24
    31bc:	99 06       	cpc	r9, r25
    31be:	aa 06       	cpc	r10, r26
    31c0:	bb 06       	cpc	r11, r27
    31c2:	30 f1       	brcs	.+76     	; 0x3210 <create_chain+0xa4>
    31c4:	81 2c       	mov	r8, r1
    31c6:	91 2c       	mov	r9, r1
    31c8:	54 01       	movw	r10, r8
    31ca:	83 94       	inc	r8
    31cc:	21 c0       	rjmp	.+66     	; 0x3210 <create_chain+0xa4>
    31ce:	0f dd       	rcall	.-1506   	; 0x2bee <get_fat>
    31d0:	6b 01       	movw	r12, r22
    31d2:	7c 01       	movw	r14, r24
    31d4:	62 30       	cpi	r22, 0x02	; 2
    31d6:	71 05       	cpc	r23, r1
    31d8:	81 05       	cpc	r24, r1
    31da:	91 05       	cpc	r25, r1
    31dc:	08 f4       	brcc	.+2      	; 0x31e0 <create_chain+0x74>
    31de:	96 c0       	rjmp	.+300    	; 0x330c <create_chain+0x1a0>
    31e0:	8f ef       	ldi	r24, 0xFF	; 255
    31e2:	c8 16       	cp	r12, r24
    31e4:	d8 06       	cpc	r13, r24
    31e6:	e8 06       	cpc	r14, r24
    31e8:	f8 06       	cpc	r15, r24
    31ea:	09 f4       	brne	.+2      	; 0x31ee <create_chain+0x82>
    31ec:	94 c0       	rjmp	.+296    	; 0x3316 <create_chain+0x1aa>
    31ee:	8a 89       	ldd	r24, Y+18	; 0x12
    31f0:	9b 89       	ldd	r25, Y+19	; 0x13
    31f2:	ac 89       	ldd	r26, Y+20	; 0x14
    31f4:	bd 89       	ldd	r27, Y+21	; 0x15
    31f6:	c8 16       	cp	r12, r24
    31f8:	d9 06       	cpc	r13, r25
    31fa:	ea 06       	cpc	r14, r26
    31fc:	fb 06       	cpc	r15, r27
    31fe:	08 f4       	brcc	.+2      	; 0x3202 <create_chain+0x96>
    3200:	8f c0       	rjmp	.+286    	; 0x3320 <create_chain+0x1b4>
    3202:	53 01       	movw	r10, r6
    3204:	42 01       	movw	r8, r4
    3206:	04 c0       	rjmp	.+8      	; 0x3210 <create_chain+0xa4>
    3208:	81 2c       	mov	r8, r1
    320a:	91 2c       	mov	r9, r1
    320c:	54 01       	movw	r10, r8
    320e:	83 94       	inc	r8
    3210:	75 01       	movw	r14, r10
    3212:	64 01       	movw	r12, r8
    3214:	68 94       	set
    3216:	22 24       	eor	r2, r2
    3218:	21 f8       	bld	r2, 1
    321a:	31 2c       	mov	r3, r1
    321c:	00 e0       	ldi	r16, 0x00	; 0
    321e:	10 e0       	ldi	r17, 0x00	; 0
    3220:	2f ef       	ldi	r18, 0xFF	; 255
    3222:	c2 1a       	sub	r12, r18
    3224:	d2 0a       	sbc	r13, r18
    3226:	e2 0a       	sbc	r14, r18
    3228:	f2 0a       	sbc	r15, r18
    322a:	8a 89       	ldd	r24, Y+18	; 0x12
    322c:	9b 89       	ldd	r25, Y+19	; 0x13
    322e:	ac 89       	ldd	r26, Y+20	; 0x14
    3230:	bd 89       	ldd	r27, Y+21	; 0x15
    3232:	c8 16       	cp	r12, r24
    3234:	d9 06       	cpc	r13, r25
    3236:	ea 06       	cpc	r14, r26
    3238:	fb 06       	cpc	r15, r27
    323a:	58 f0       	brcs	.+22     	; 0x3252 <create_chain+0xe6>
    323c:	82 e0       	ldi	r24, 0x02	; 2
    323e:	88 16       	cp	r8, r24
    3240:	91 04       	cpc	r9, r1
    3242:	a1 04       	cpc	r10, r1
    3244:	b1 04       	cpc	r11, r1
    3246:	08 f4       	brcc	.+2      	; 0x324a <create_chain+0xde>
    3248:	70 c0       	rjmp	.+224    	; 0x332a <create_chain+0x1be>
    324a:	c2 2c       	mov	r12, r2
    324c:	d3 2c       	mov	r13, r3
    324e:	e0 2e       	mov	r14, r16
    3250:	f1 2e       	mov	r15, r17
    3252:	b7 01       	movw	r22, r14
    3254:	a6 01       	movw	r20, r12
    3256:	ce 01       	movw	r24, r28
    3258:	ca dc       	rcall	.-1644   	; 0x2bee <get_fat>
    325a:	61 15       	cp	r22, r1
    325c:	71 05       	cpc	r23, r1
    325e:	81 05       	cpc	r24, r1
    3260:	91 05       	cpc	r25, r1
    3262:	99 f0       	breq	.+38     	; 0x328a <create_chain+0x11e>
    3264:	6f 3f       	cpi	r22, 0xFF	; 255
    3266:	2f ef       	ldi	r18, 0xFF	; 255
    3268:	72 07       	cpc	r23, r18
    326a:	82 07       	cpc	r24, r18
    326c:	92 07       	cpc	r25, r18
    326e:	09 f4       	brne	.+2      	; 0x3272 <create_chain+0x106>
    3270:	61 c0       	rjmp	.+194    	; 0x3334 <create_chain+0x1c8>
    3272:	61 30       	cpi	r22, 0x01	; 1
    3274:	71 05       	cpc	r23, r1
    3276:	81 05       	cpc	r24, r1
    3278:	91 05       	cpc	r25, r1
    327a:	09 f4       	brne	.+2      	; 0x327e <create_chain+0x112>
    327c:	60 c0       	rjmp	.+192    	; 0x333e <create_chain+0x1d2>
    327e:	c8 14       	cp	r12, r8
    3280:	d9 04       	cpc	r13, r9
    3282:	ea 04       	cpc	r14, r10
    3284:	fb 04       	cpc	r15, r11
    3286:	61 f6       	brne	.-104    	; 0x3220 <create_chain+0xb4>
    3288:	5f c0       	rjmp	.+190    	; 0x3348 <create_chain+0x1dc>
    328a:	8c 2c       	mov	r8, r12
    328c:	9d 2c       	mov	r9, r13
    328e:	ae 2c       	mov	r10, r14
    3290:	bf 2c       	mov	r11, r15
    3292:	0f ef       	ldi	r16, 0xFF	; 255
    3294:	1f ef       	ldi	r17, 0xFF	; 255
    3296:	2f ef       	ldi	r18, 0xFF	; 255
    3298:	3f e0       	ldi	r19, 0x0F	; 15
    329a:	b7 01       	movw	r22, r14
    329c:	a6 01       	movw	r20, r12
    329e:	ce 01       	movw	r24, r28
    32a0:	44 de       	rcall	.-888    	; 0x2f2a <put_fat>
    32a2:	81 11       	cpse	r24, r1
    32a4:	2c c0       	rjmp	.+88     	; 0x32fe <create_chain+0x192>
    32a6:	41 14       	cp	r4, r1
    32a8:	51 04       	cpc	r5, r1
    32aa:	61 04       	cpc	r6, r1
    32ac:	71 04       	cpc	r7, r1
    32ae:	51 f0       	breq	.+20     	; 0x32c4 <create_chain+0x158>
    32b0:	0c 2d       	mov	r16, r12
    32b2:	1d 2d       	mov	r17, r13
    32b4:	2e 2d       	mov	r18, r14
    32b6:	3f 2d       	mov	r19, r15
    32b8:	b3 01       	movw	r22, r6
    32ba:	a2 01       	movw	r20, r4
    32bc:	ce 01       	movw	r24, r28
    32be:	35 de       	rcall	.-918    	; 0x2f2a <put_fat>
    32c0:	81 11       	cpse	r24, r1
    32c2:	1d c0       	rjmp	.+58     	; 0x32fe <create_chain+0x192>
    32c4:	8a 86       	std	Y+10, r8	; 0x0a
    32c6:	9b 86       	std	Y+11, r9	; 0x0b
    32c8:	ac 86       	std	Y+12, r10	; 0x0c
    32ca:	bd 86       	std	Y+13, r11	; 0x0d
    32cc:	8e 85       	ldd	r24, Y+14	; 0x0e
    32ce:	9f 85       	ldd	r25, Y+15	; 0x0f
    32d0:	a8 89       	ldd	r26, Y+16	; 0x10
    32d2:	b9 89       	ldd	r27, Y+17	; 0x11
    32d4:	8f 3f       	cpi	r24, 0xFF	; 255
    32d6:	2f ef       	ldi	r18, 0xFF	; 255
    32d8:	92 07       	cpc	r25, r18
    32da:	a2 07       	cpc	r26, r18
    32dc:	b2 07       	cpc	r27, r18
    32de:	c9 f1       	breq	.+114    	; 0x3352 <create_chain+0x1e6>
    32e0:	01 97       	sbiw	r24, 0x01	; 1
    32e2:	a1 09       	sbc	r26, r1
    32e4:	b1 09       	sbc	r27, r1
    32e6:	8e 87       	std	Y+14, r24	; 0x0e
    32e8:	9f 87       	std	Y+15, r25	; 0x0f
    32ea:	a8 8b       	std	Y+16, r26	; 0x10
    32ec:	b9 8b       	std	Y+17, r27	; 0x11
    32ee:	8d 81       	ldd	r24, Y+5	; 0x05
    32f0:	81 60       	ori	r24, 0x01	; 1
    32f2:	8d 83       	std	Y+5, r24	; 0x05
    32f4:	6c 2d       	mov	r22, r12
    32f6:	7d 2d       	mov	r23, r13
    32f8:	8e 2d       	mov	r24, r14
    32fa:	9f 2d       	mov	r25, r15
    32fc:	33 c0       	rjmp	.+102    	; 0x3364 <create_chain+0x1f8>
    32fe:	81 30       	cpi	r24, 0x01	; 1
    3300:	69 f1       	breq	.+90     	; 0x335c <create_chain+0x1f0>
    3302:	61 e0       	ldi	r22, 0x01	; 1
    3304:	70 e0       	ldi	r23, 0x00	; 0
    3306:	80 e0       	ldi	r24, 0x00	; 0
    3308:	90 e0       	ldi	r25, 0x00	; 0
    330a:	2c c0       	rjmp	.+88     	; 0x3364 <create_chain+0x1f8>
    330c:	61 e0       	ldi	r22, 0x01	; 1
    330e:	70 e0       	ldi	r23, 0x00	; 0
    3310:	80 e0       	ldi	r24, 0x00	; 0
    3312:	90 e0       	ldi	r25, 0x00	; 0
    3314:	27 c0       	rjmp	.+78     	; 0x3364 <create_chain+0x1f8>
    3316:	6f ef       	ldi	r22, 0xFF	; 255
    3318:	7f ef       	ldi	r23, 0xFF	; 255
    331a:	8f ef       	ldi	r24, 0xFF	; 255
    331c:	9f ef       	ldi	r25, 0xFF	; 255
    331e:	22 c0       	rjmp	.+68     	; 0x3364 <create_chain+0x1f8>
    3320:	6c 2d       	mov	r22, r12
    3322:	7d 2d       	mov	r23, r13
    3324:	8e 2d       	mov	r24, r14
    3326:	9f 2d       	mov	r25, r15
    3328:	1d c0       	rjmp	.+58     	; 0x3364 <create_chain+0x1f8>
    332a:	60 e0       	ldi	r22, 0x00	; 0
    332c:	70 e0       	ldi	r23, 0x00	; 0
    332e:	80 e0       	ldi	r24, 0x00	; 0
    3330:	90 e0       	ldi	r25, 0x00	; 0
    3332:	18 c0       	rjmp	.+48     	; 0x3364 <create_chain+0x1f8>
    3334:	6f ef       	ldi	r22, 0xFF	; 255
    3336:	7f ef       	ldi	r23, 0xFF	; 255
    3338:	8f ef       	ldi	r24, 0xFF	; 255
    333a:	9f ef       	ldi	r25, 0xFF	; 255
    333c:	13 c0       	rjmp	.+38     	; 0x3364 <create_chain+0x1f8>
    333e:	61 e0       	ldi	r22, 0x01	; 1
    3340:	70 e0       	ldi	r23, 0x00	; 0
    3342:	80 e0       	ldi	r24, 0x00	; 0
    3344:	90 e0       	ldi	r25, 0x00	; 0
    3346:	0e c0       	rjmp	.+28     	; 0x3364 <create_chain+0x1f8>
    3348:	60 e0       	ldi	r22, 0x00	; 0
    334a:	70 e0       	ldi	r23, 0x00	; 0
    334c:	80 e0       	ldi	r24, 0x00	; 0
    334e:	90 e0       	ldi	r25, 0x00	; 0
    3350:	09 c0       	rjmp	.+18     	; 0x3364 <create_chain+0x1f8>
    3352:	6c 2d       	mov	r22, r12
    3354:	7d 2d       	mov	r23, r13
    3356:	8e 2d       	mov	r24, r14
    3358:	9f 2d       	mov	r25, r15
    335a:	04 c0       	rjmp	.+8      	; 0x3364 <create_chain+0x1f8>
    335c:	6f ef       	ldi	r22, 0xFF	; 255
    335e:	7f ef       	ldi	r23, 0xFF	; 255
    3360:	8f ef       	ldi	r24, 0xFF	; 255
    3362:	9f ef       	ldi	r25, 0xFF	; 255
    3364:	df 91       	pop	r29
    3366:	cf 91       	pop	r28
    3368:	1f 91       	pop	r17
    336a:	0f 91       	pop	r16
    336c:	ff 90       	pop	r15
    336e:	ef 90       	pop	r14
    3370:	df 90       	pop	r13
    3372:	cf 90       	pop	r12
    3374:	bf 90       	pop	r11
    3376:	af 90       	pop	r10
    3378:	9f 90       	pop	r9
    337a:	8f 90       	pop	r8
    337c:	7f 90       	pop	r7
    337e:	6f 90       	pop	r6
    3380:	5f 90       	pop	r5
    3382:	4f 90       	pop	r4
    3384:	3f 90       	pop	r3
    3386:	2f 90       	pop	r2
    3388:	08 95       	ret

0000338a <dir_next>:
    338a:	7f 92       	push	r7
    338c:	8f 92       	push	r8
    338e:	9f 92       	push	r9
    3390:	af 92       	push	r10
    3392:	bf 92       	push	r11
    3394:	cf 92       	push	r12
    3396:	df 92       	push	r13
    3398:	ef 92       	push	r14
    339a:	ff 92       	push	r15
    339c:	0f 93       	push	r16
    339e:	1f 93       	push	r17
    33a0:	cf 93       	push	r28
    33a2:	df 93       	push	r29
    33a4:	dc 01       	movw	r26, r24
    33a6:	14 96       	adiw	r26, 0x04	; 4
    33a8:	cd 91       	ld	r28, X+
    33aa:	dc 91       	ld	r29, X
    33ac:	15 97       	sbiw	r26, 0x05	; 5
    33ae:	21 96       	adiw	r28, 0x01	; 1
    33b0:	09 f4       	brne	.+2      	; 0x33b4 <dir_next+0x2a>
    33b2:	03 c1       	rjmp	.+518    	; 0x35ba <dir_next+0x230>
    33b4:	1e 96       	adiw	r26, 0x0e	; 14
    33b6:	8d 90       	ld	r8, X+
    33b8:	9d 90       	ld	r9, X+
    33ba:	ad 90       	ld	r10, X+
    33bc:	bc 90       	ld	r11, X
    33be:	51 97       	sbiw	r26, 0x11	; 17
    33c0:	81 14       	cp	r8, r1
    33c2:	91 04       	cpc	r9, r1
    33c4:	a1 04       	cpc	r10, r1
    33c6:	b1 04       	cpc	r11, r1
    33c8:	09 f4       	brne	.+2      	; 0x33cc <dir_next+0x42>
    33ca:	f9 c0       	rjmp	.+498    	; 0x35be <dir_next+0x234>
    33cc:	7b 01       	movw	r14, r22
    33ce:	8c 01       	movw	r16, r24
    33d0:	6e 01       	movw	r12, r28
    33d2:	bf e0       	ldi	r27, 0x0F	; 15
    33d4:	cb 22       	and	r12, r27
    33d6:	dd 24       	eor	r13, r13
    33d8:	c1 14       	cp	r12, r1
    33da:	d1 04       	cpc	r13, r1
    33dc:	09 f0       	breq	.+2      	; 0x33e0 <dir_next+0x56>
    33de:	d1 c0       	rjmp	.+418    	; 0x3582 <dir_next+0x1f8>
    33e0:	ef ef       	ldi	r30, 0xFF	; 255
    33e2:	8e 1a       	sub	r8, r30
    33e4:	9e 0a       	sbc	r9, r30
    33e6:	ae 0a       	sbc	r10, r30
    33e8:	be 0a       	sbc	r11, r30
    33ea:	dc 01       	movw	r26, r24
    33ec:	1e 96       	adiw	r26, 0x0e	; 14
    33ee:	8d 92       	st	X+, r8
    33f0:	9d 92       	st	X+, r9
    33f2:	ad 92       	st	X+, r10
    33f4:	bc 92       	st	X, r11
    33f6:	51 97       	sbiw	r26, 0x11	; 17
    33f8:	1a 96       	adiw	r26, 0x0a	; 10
    33fa:	4d 91       	ld	r20, X+
    33fc:	5d 91       	ld	r21, X+
    33fe:	6d 91       	ld	r22, X+
    3400:	7c 91       	ld	r23, X
    3402:	1d 97       	sbiw	r26, 0x0d	; 13
    3404:	41 15       	cp	r20, r1
    3406:	51 05       	cpc	r21, r1
    3408:	61 05       	cpc	r22, r1
    340a:	71 05       	cpc	r23, r1
    340c:	49 f4       	brne	.+18     	; 0x3420 <dir_next+0x96>
    340e:	ed 91       	ld	r30, X+
    3410:	fc 91       	ld	r31, X
    3412:	80 85       	ldd	r24, Z+8	; 0x08
    3414:	91 85       	ldd	r25, Z+9	; 0x09
    3416:	c8 17       	cp	r28, r24
    3418:	d9 07       	cpc	r29, r25
    341a:	08 f0       	brcs	.+2      	; 0x341e <dir_next+0x94>
    341c:	d2 c0       	rjmp	.+420    	; 0x35c2 <dir_next+0x238>
    341e:	b1 c0       	rjmp	.+354    	; 0x3582 <dir_next+0x1f8>
    3420:	dc 01       	movw	r26, r24
    3422:	ed 91       	ld	r30, X+
    3424:	fc 91       	ld	r31, X
    3426:	22 81       	ldd	r18, Z+2	; 0x02
    3428:	30 e0       	ldi	r19, 0x00	; 0
    342a:	21 50       	subi	r18, 0x01	; 1
    342c:	31 09       	sbc	r19, r1
    342e:	ce 01       	movw	r24, r28
    3430:	92 95       	swap	r25
    3432:	82 95       	swap	r24
    3434:	8f 70       	andi	r24, 0x0F	; 15
    3436:	89 27       	eor	r24, r25
    3438:	9f 70       	andi	r25, 0x0F	; 15
    343a:	89 27       	eor	r24, r25
    343c:	28 23       	and	r18, r24
    343e:	39 23       	and	r19, r25
    3440:	23 2b       	or	r18, r19
    3442:	09 f0       	breq	.+2      	; 0x3446 <dir_next+0xbc>
    3444:	9e c0       	rjmp	.+316    	; 0x3582 <dir_next+0x1f8>
    3446:	cf 01       	movw	r24, r30
    3448:	d2 db       	rcall	.-2140   	; 0x2bee <get_fat>
    344a:	4b 01       	movw	r8, r22
    344c:	5c 01       	movw	r10, r24
    344e:	62 30       	cpi	r22, 0x02	; 2
    3450:	71 05       	cpc	r23, r1
    3452:	81 05       	cpc	r24, r1
    3454:	91 05       	cpc	r25, r1
    3456:	08 f4       	brcc	.+2      	; 0x345a <dir_next+0xd0>
    3458:	b6 c0       	rjmp	.+364    	; 0x35c6 <dir_next+0x23c>
    345a:	6f 3f       	cpi	r22, 0xFF	; 255
    345c:	7f 4f       	sbci	r23, 0xFF	; 255
    345e:	8f 4f       	sbci	r24, 0xFF	; 255
    3460:	9f 4f       	sbci	r25, 0xFF	; 255
    3462:	09 f4       	brne	.+2      	; 0x3466 <dir_next+0xdc>
    3464:	b2 c0       	rjmp	.+356    	; 0x35ca <dir_next+0x240>
    3466:	d8 01       	movw	r26, r16
    3468:	ed 91       	ld	r30, X+
    346a:	fc 91       	ld	r31, X
    346c:	82 89       	ldd	r24, Z+18	; 0x12
    346e:	93 89       	ldd	r25, Z+19	; 0x13
    3470:	a4 89       	ldd	r26, Z+20	; 0x14
    3472:	b5 89       	ldd	r27, Z+21	; 0x15
    3474:	88 16       	cp	r8, r24
    3476:	99 06       	cpc	r9, r25
    3478:	aa 06       	cpc	r10, r26
    347a:	bb 06       	cpc	r11, r27
    347c:	08 f4       	brcc	.+2      	; 0x3480 <dir_next+0xf6>
    347e:	70 c0       	rjmp	.+224    	; 0x3560 <dir_next+0x1d6>
    3480:	ef 28       	or	r14, r15
    3482:	09 f4       	brne	.+2      	; 0x3486 <dir_next+0xfc>
    3484:	a4 c0       	rjmp	.+328    	; 0x35ce <dir_next+0x244>
    3486:	d8 01       	movw	r26, r16
    3488:	1a 96       	adiw	r26, 0x0a	; 10
    348a:	4d 91       	ld	r20, X+
    348c:	5d 91       	ld	r21, X+
    348e:	6d 91       	ld	r22, X+
    3490:	7c 91       	ld	r23, X
    3492:	1d 97       	sbiw	r26, 0x0d	; 13
    3494:	cf 01       	movw	r24, r30
    3496:	6a de       	rcall	.-812    	; 0x316c <create_chain>
    3498:	4b 01       	movw	r8, r22
    349a:	5c 01       	movw	r10, r24
    349c:	61 15       	cp	r22, r1
    349e:	71 05       	cpc	r23, r1
    34a0:	81 05       	cpc	r24, r1
    34a2:	91 05       	cpc	r25, r1
    34a4:	09 f4       	brne	.+2      	; 0x34a8 <dir_next+0x11e>
    34a6:	95 c0       	rjmp	.+298    	; 0x35d2 <dir_next+0x248>
    34a8:	61 30       	cpi	r22, 0x01	; 1
    34aa:	71 05       	cpc	r23, r1
    34ac:	81 05       	cpc	r24, r1
    34ae:	91 05       	cpc	r25, r1
    34b0:	09 f4       	brne	.+2      	; 0x34b4 <dir_next+0x12a>
    34b2:	91 c0       	rjmp	.+290    	; 0x35d6 <dir_next+0x24c>
    34b4:	6f 3f       	cpi	r22, 0xFF	; 255
    34b6:	7f 4f       	sbci	r23, 0xFF	; 255
    34b8:	8f 4f       	sbci	r24, 0xFF	; 255
    34ba:	9f 4f       	sbci	r25, 0xFF	; 255
    34bc:	09 f4       	brne	.+2      	; 0x34c0 <dir_next+0x136>
    34be:	8d c0       	rjmp	.+282    	; 0x35da <dir_next+0x250>
    34c0:	d8 01       	movw	r26, r16
    34c2:	8d 91       	ld	r24, X+
    34c4:	9c 91       	ld	r25, X
    34c6:	0e 94 78 11 	call	0x22f0	; 0x22f0 <sync_window>
    34ca:	81 11       	cpse	r24, r1
    34cc:	88 c0       	rjmp	.+272    	; 0x35de <dir_next+0x254>
    34ce:	f8 01       	movw	r30, r16
    34d0:	80 81       	ld	r24, Z
    34d2:	91 81       	ldd	r25, Z+1	; 0x01
    34d4:	fc 01       	movw	r30, r24
    34d6:	be 96       	adiw	r30, 0x2e	; 46
    34d8:	82 5d       	subi	r24, 0xD2	; 210
    34da:	9d 4f       	sbci	r25, 0xFD	; 253
    34dc:	11 92       	st	Z+, r1
    34de:	e8 17       	cp	r30, r24
    34e0:	f9 07       	cpc	r31, r25
    34e2:	e1 f7       	brne	.-8      	; 0x34dc <dir_next+0x152>
    34e4:	d8 01       	movw	r26, r16
    34e6:	ed 90       	ld	r14, X+
    34e8:	fc 90       	ld	r15, X
    34ea:	b5 01       	movw	r22, r10
    34ec:	a4 01       	movw	r20, r8
    34ee:	c7 01       	movw	r24, r14
    34f0:	50 db       	rcall	.-2400   	; 0x2b92 <clust2sect>
    34f2:	f7 01       	movw	r30, r14
    34f4:	62 a7       	std	Z+42, r22	; 0x2a
    34f6:	73 a7       	std	Z+43, r23	; 0x2b
    34f8:	84 a7       	std	Z+44, r24	; 0x2c
    34fa:	95 a7       	std	Z+45, r25	; 0x2d
    34fc:	e1 2c       	mov	r14, r1
    34fe:	f1 2c       	mov	r15, r1
    3500:	77 24       	eor	r7, r7
    3502:	73 94       	inc	r7
    3504:	19 c0       	rjmp	.+50     	; 0x3538 <dir_next+0x1ae>
    3506:	74 82       	std	Z+4, r7	; 0x04
    3508:	d8 01       	movw	r26, r16
    350a:	8d 91       	ld	r24, X+
    350c:	9c 91       	ld	r25, X
    350e:	0e 94 78 11 	call	0x22f0	; 0x22f0 <sync_window>
    3512:	81 11       	cpse	r24, r1
    3514:	66 c0       	rjmp	.+204    	; 0x35e2 <dir_next+0x258>
    3516:	d8 01       	movw	r26, r16
    3518:	ed 91       	ld	r30, X+
    351a:	fc 91       	ld	r31, X
    351c:	82 a5       	ldd	r24, Z+42	; 0x2a
    351e:	93 a5       	ldd	r25, Z+43	; 0x2b
    3520:	a4 a5       	ldd	r26, Z+44	; 0x2c
    3522:	b5 a5       	ldd	r27, Z+45	; 0x2d
    3524:	01 96       	adiw	r24, 0x01	; 1
    3526:	a1 1d       	adc	r26, r1
    3528:	b1 1d       	adc	r27, r1
    352a:	82 a7       	std	Z+42, r24	; 0x2a
    352c:	93 a7       	std	Z+43, r25	; 0x2b
    352e:	a4 a7       	std	Z+44, r26	; 0x2c
    3530:	b5 a7       	std	Z+45, r27	; 0x2d
    3532:	bf ef       	ldi	r27, 0xFF	; 255
    3534:	eb 1a       	sub	r14, r27
    3536:	fb 0a       	sbc	r15, r27
    3538:	d8 01       	movw	r26, r16
    353a:	ed 91       	ld	r30, X+
    353c:	fc 91       	ld	r31, X
    353e:	82 81       	ldd	r24, Z+2	; 0x02
    3540:	90 e0       	ldi	r25, 0x00	; 0
    3542:	e8 16       	cp	r14, r24
    3544:	f9 06       	cpc	r15, r25
    3546:	f8 f2       	brcs	.-66     	; 0x3506 <dir_next+0x17c>
    3548:	82 a5       	ldd	r24, Z+42	; 0x2a
    354a:	93 a5       	ldd	r25, Z+43	; 0x2b
    354c:	a4 a5       	ldd	r26, Z+44	; 0x2c
    354e:	b5 a5       	ldd	r27, Z+45	; 0x2d
    3550:	8e 19       	sub	r24, r14
    3552:	9f 09       	sbc	r25, r15
    3554:	a1 09       	sbc	r26, r1
    3556:	b1 09       	sbc	r27, r1
    3558:	82 a7       	std	Z+42, r24	; 0x2a
    355a:	93 a7       	std	Z+43, r25	; 0x2b
    355c:	a4 a7       	std	Z+44, r26	; 0x2c
    355e:	b5 a7       	std	Z+45, r27	; 0x2d
    3560:	f8 01       	movw	r30, r16
    3562:	82 86       	std	Z+10, r8	; 0x0a
    3564:	93 86       	std	Z+11, r9	; 0x0b
    3566:	a4 86       	std	Z+12, r10	; 0x0c
    3568:	b5 86       	std	Z+13, r11	; 0x0d
    356a:	b5 01       	movw	r22, r10
    356c:	a4 01       	movw	r20, r8
    356e:	80 81       	ld	r24, Z
    3570:	91 81       	ldd	r25, Z+1	; 0x01
    3572:	0f db       	rcall	.-2530   	; 0x2b92 <clust2sect>
    3574:	d8 01       	movw	r26, r16
    3576:	1e 96       	adiw	r26, 0x0e	; 14
    3578:	6d 93       	st	X+, r22
    357a:	7d 93       	st	X+, r23
    357c:	8d 93       	st	X+, r24
    357e:	9c 93       	st	X, r25
    3580:	51 97       	sbiw	r26, 0x11	; 17
    3582:	f8 01       	movw	r30, r16
    3584:	d5 83       	std	Z+5, r29	; 0x05
    3586:	c4 83       	std	Z+4, r28	; 0x04
    3588:	cc 0c       	add	r12, r12
    358a:	dd 1c       	adc	r13, r13
    358c:	cc 0c       	add	r12, r12
    358e:	dd 1c       	adc	r13, r13
    3590:	cc 0c       	add	r12, r12
    3592:	dd 1c       	adc	r13, r13
    3594:	cc 0c       	add	r12, r12
    3596:	dd 1c       	adc	r13, r13
    3598:	cc 0c       	add	r12, r12
    359a:	dd 1c       	adc	r13, r13
    359c:	fe e2       	ldi	r31, 0x2E	; 46
    359e:	cf 0e       	add	r12, r31
    35a0:	d1 1c       	adc	r13, r1
    35a2:	d8 01       	movw	r26, r16
    35a4:	8d 91       	ld	r24, X+
    35a6:	9c 91       	ld	r25, X
    35a8:	11 97       	sbiw	r26, 0x01	; 1
    35aa:	c8 0e       	add	r12, r24
    35ac:	d9 1e       	adc	r13, r25
    35ae:	53 96       	adiw	r26, 0x13	; 19
    35b0:	dc 92       	st	X, r13
    35b2:	ce 92       	st	-X, r12
    35b4:	52 97       	sbiw	r26, 0x12	; 18
    35b6:	80 e0       	ldi	r24, 0x00	; 0
    35b8:	15 c0       	rjmp	.+42     	; 0x35e4 <dir_next+0x25a>
    35ba:	84 e0       	ldi	r24, 0x04	; 4
    35bc:	13 c0       	rjmp	.+38     	; 0x35e4 <dir_next+0x25a>
    35be:	84 e0       	ldi	r24, 0x04	; 4
    35c0:	11 c0       	rjmp	.+34     	; 0x35e4 <dir_next+0x25a>
    35c2:	84 e0       	ldi	r24, 0x04	; 4
    35c4:	0f c0       	rjmp	.+30     	; 0x35e4 <dir_next+0x25a>
    35c6:	82 e0       	ldi	r24, 0x02	; 2
    35c8:	0d c0       	rjmp	.+26     	; 0x35e4 <dir_next+0x25a>
    35ca:	81 e0       	ldi	r24, 0x01	; 1
    35cc:	0b c0       	rjmp	.+22     	; 0x35e4 <dir_next+0x25a>
    35ce:	84 e0       	ldi	r24, 0x04	; 4
    35d0:	09 c0       	rjmp	.+18     	; 0x35e4 <dir_next+0x25a>
    35d2:	87 e0       	ldi	r24, 0x07	; 7
    35d4:	07 c0       	rjmp	.+14     	; 0x35e4 <dir_next+0x25a>
    35d6:	82 e0       	ldi	r24, 0x02	; 2
    35d8:	05 c0       	rjmp	.+10     	; 0x35e4 <dir_next+0x25a>
    35da:	81 e0       	ldi	r24, 0x01	; 1
    35dc:	03 c0       	rjmp	.+6      	; 0x35e4 <dir_next+0x25a>
    35de:	81 e0       	ldi	r24, 0x01	; 1
    35e0:	01 c0       	rjmp	.+2      	; 0x35e4 <dir_next+0x25a>
    35e2:	81 e0       	ldi	r24, 0x01	; 1
    35e4:	df 91       	pop	r29
    35e6:	cf 91       	pop	r28
    35e8:	1f 91       	pop	r17
    35ea:	0f 91       	pop	r16
    35ec:	ff 90       	pop	r15
    35ee:	ef 90       	pop	r14
    35f0:	df 90       	pop	r13
    35f2:	cf 90       	pop	r12
    35f4:	bf 90       	pop	r11
    35f6:	af 90       	pop	r10
    35f8:	9f 90       	pop	r9
    35fa:	8f 90       	pop	r8
    35fc:	7f 90       	pop	r7
    35fe:	08 95       	ret

00003600 <follow_path>:
    3600:	2f 92       	push	r2
    3602:	3f 92       	push	r3
    3604:	4f 92       	push	r4
    3606:	5f 92       	push	r5
    3608:	6f 92       	push	r6
    360a:	7f 92       	push	r7
    360c:	8f 92       	push	r8
    360e:	9f 92       	push	r9
    3610:	af 92       	push	r10
    3612:	bf 92       	push	r11
    3614:	cf 92       	push	r12
    3616:	df 92       	push	r13
    3618:	ef 92       	push	r14
    361a:	ff 92       	push	r15
    361c:	0f 93       	push	r16
    361e:	1f 93       	push	r17
    3620:	cf 93       	push	r28
    3622:	df 93       	push	r29
    3624:	00 d0       	rcall	.+0      	; 0x3626 <follow_path+0x26>
    3626:	00 d0       	rcall	.+0      	; 0x3628 <follow_path+0x28>
    3628:	1f 92       	push	r1
    362a:	cd b7       	in	r28, 0x3d	; 61
    362c:	de b7       	in	r29, 0x3e	; 62
    362e:	8c 01       	movw	r16, r24
    3630:	7b 01       	movw	r14, r22
    3632:	db 01       	movw	r26, r22
    3634:	8c 91       	ld	r24, X
    3636:	8f 32       	cpi	r24, 0x2F	; 47
    3638:	11 f0       	breq	.+4      	; 0x363e <follow_path+0x3e>
    363a:	8c 35       	cpi	r24, 0x5C	; 92
    363c:	19 f4       	brne	.+6      	; 0x3644 <follow_path+0x44>
    363e:	bf ef       	ldi	r27, 0xFF	; 255
    3640:	eb 1a       	sub	r14, r27
    3642:	fb 0a       	sbc	r15, r27
    3644:	f8 01       	movw	r30, r16
    3646:	16 82       	std	Z+6, r1	; 0x06
    3648:	17 82       	std	Z+7, r1	; 0x07
    364a:	10 86       	std	Z+8, r1	; 0x08
    364c:	11 86       	std	Z+9, r1	; 0x09
    364e:	d7 01       	movw	r26, r14
    3650:	8c 91       	ld	r24, X
    3652:	80 32       	cpi	r24, 0x20	; 32
    3654:	40 f4       	brcc	.+16     	; 0x3666 <follow_path+0x66>
    3656:	60 e0       	ldi	r22, 0x00	; 0
    3658:	70 e0       	ldi	r23, 0x00	; 0
    365a:	c8 01       	movw	r24, r16
    365c:	ab db       	rcall	.-2218   	; 0x2db4 <dir_sdi>
    365e:	f8 01       	movw	r30, r16
    3660:	13 8a       	std	Z+19, r1	; 0x13
    3662:	12 8a       	std	Z+18, r1	; 0x12
    3664:	32 c1       	rjmp	.+612    	; 0x38ca <follow_path+0x2ca>
    3666:	68 94       	set
    3668:	bb 24       	eor	r11, r11
    366a:	b5 f8       	bld	r11, 5
    366c:	a1 2c       	mov	r10, r1
    366e:	81 2c       	mov	r8, r1
    3670:	68 94       	set
    3672:	77 24       	eor	r7, r7
    3674:	73 f8       	bld	r7, 3
    3676:	51 2c       	mov	r5, r1
    3678:	61 2c       	mov	r6, r1
    367a:	7a 82       	std	Y+2, r7	; 0x02
    367c:	5b 82       	std	Y+3, r5	; 0x03
    367e:	0f 2e       	mov	r0, r31
    3680:	f8 e1       	ldi	r31, 0x18	; 24
    3682:	2f 2e       	mov	r2, r31
    3684:	f3 e0       	ldi	r31, 0x03	; 3
    3686:	3f 2e       	mov	r3, r31
    3688:	f0 2d       	mov	r31, r0
    368a:	1d 83       	std	Y+5, r17	; 0x05
    368c:	0c 83       	std	Y+4, r16	; 0x04
    368e:	59 82       	std	Y+1, r5	; 0x01
    3690:	f7 01       	movw	r30, r14
    3692:	2c 81       	ldd	r18, Y+4	; 0x04
    3694:	3d 81       	ldd	r19, Y+5	; 0x05
    3696:	af 01       	movw	r20, r30
    3698:	81 91       	ld	r24, Z+
    369a:	8f 32       	cpi	r24, 0x2F	; 47
    369c:	e1 f3       	breq	.-8      	; 0x3696 <follow_path+0x96>
    369e:	8c 35       	cpi	r24, 0x5C	; 92
    36a0:	d1 f3       	breq	.-12     	; 0x3696 <follow_path+0x96>
    36a2:	3d 83       	std	Y+5, r19	; 0x05
    36a4:	2c 83       	std	Y+4, r18	; 0x04
    36a6:	f9 01       	movw	r30, r18
    36a8:	a4 89       	ldd	r26, Z+20	; 0x14
    36aa:	b5 89       	ldd	r27, Z+21	; 0x15
    36ac:	fd 01       	movw	r30, r26
    36ae:	cd 01       	movw	r24, r26
    36b0:	0b 96       	adiw	r24, 0x0b	; 11
    36b2:	b1 92       	st	Z+, r11
    36b4:	e8 17       	cp	r30, r24
    36b6:	f9 07       	cpc	r31, r25
    36b8:	e1 f7       	brne	.-8      	; 0x36b2 <follow_path+0xb2>
    36ba:	3d 83       	std	Y+5, r19	; 0x05
    36bc:	2c 83       	std	Y+4, r18	; 0x04
    36be:	ca 2c       	mov	r12, r10
    36c0:	d8 2c       	mov	r13, r8
    36c2:	2a 2d       	mov	r18, r10
    36c4:	38 2d       	mov	r19, r8
    36c6:	47 2c       	mov	r4, r7
    36c8:	59 80       	ldd	r5, Y+1	; 0x01
    36ca:	96 2c       	mov	r9, r6
    36cc:	8a 01       	movw	r16, r20
    36ce:	8c 81       	ldd	r24, Y+4	; 0x04
    36d0:	9d 81       	ldd	r25, Y+5	; 0x05
    36d2:	5d 83       	std	Y+5, r21	; 0x05
    36d4:	4c 83       	std	Y+4, r20	; 0x04
    36d6:	7c 01       	movw	r14, r24
    36d8:	2f 5f       	subi	r18, 0xFF	; 255
    36da:	3f 4f       	sbci	r19, 0xFF	; 255
    36dc:	ec 81       	ldd	r30, Y+4	; 0x04
    36de:	fd 81       	ldd	r31, Y+5	; 0x05
    36e0:	61 91       	ld	r22, Z+
    36e2:	fd 83       	std	Y+5, r31	; 0x05
    36e4:	ec 83       	std	Y+4, r30	; 0x04
    36e6:	61 32       	cpi	r22, 0x21	; 33
    36e8:	08 f4       	brcc	.+2      	; 0x36ec <follow_path+0xec>
    36ea:	d5 c0       	rjmp	.+426    	; 0x3896 <follow_path+0x296>
    36ec:	6f 32       	cpi	r22, 0x2F	; 47
    36ee:	09 f4       	brne	.+2      	; 0x36f2 <follow_path+0xf2>
    36f0:	cb c0       	rjmp	.+406    	; 0x3888 <follow_path+0x288>
    36f2:	6c 35       	cpi	r22, 0x5C	; 92
    36f4:	09 f4       	brne	.+2      	; 0x36f8 <follow_path+0xf8>
    36f6:	c8 c0       	rjmp	.+400    	; 0x3888 <follow_path+0x288>
    36f8:	6e 32       	cpi	r22, 0x2E	; 46
    36fa:	09 f4       	brne	.+2      	; 0x36fe <follow_path+0xfe>
    36fc:	b2 c0       	rjmp	.+356    	; 0x3862 <follow_path+0x262>
    36fe:	c4 14       	cp	r12, r4
    3700:	d5 04       	cpc	r13, r5
    3702:	08 f0       	brcs	.+2      	; 0x3706 <follow_path+0x106>
    3704:	a2 c0       	rjmp	.+324    	; 0x384a <follow_path+0x24a>
    3706:	0a c0       	rjmp	.+20     	; 0x371c <follow_path+0x11c>
    3708:	99 0c       	add	r9, r9
    370a:	99 0c       	add	r9, r9
    370c:	ca 80       	ldd	r12, Y+2	; 0x02
    370e:	db 80       	ldd	r13, Y+3	; 0x03
    3710:	0f 2e       	mov	r0, r31
    3712:	fb e0       	ldi	r31, 0x0B	; 11
    3714:	4f 2e       	mov	r4, r31
    3716:	f0 2d       	mov	r31, r0
    3718:	51 2c       	mov	r5, r1
    371a:	de cf       	rjmp	.-68     	; 0x36d8 <follow_path+0xd8>
    371c:	66 23       	and	r22, r22
    371e:	0c f0       	brlt	.+2      	; 0x3722 <follow_path+0x122>
    3720:	a6 c0       	rjmp	.+332    	; 0x386e <follow_path+0x26e>
    3722:	f9 2d       	mov	r31, r9
    3724:	f3 60       	ori	r31, 0x03	; 3
    3726:	9f 2e       	mov	r9, r31
    3728:	e6 2f       	mov	r30, r22
    372a:	f0 e0       	ldi	r31, 0x00	; 0
    372c:	ea 55       	subi	r30, 0x5A	; 90
    372e:	fd 4f       	sbci	r31, 0xFD	; 253
    3730:	60 81       	ld	r22, Z
    3732:	9d c0       	rjmp	.+314    	; 0x386e <follow_path+0x26e>
    3734:	81 91       	ld	r24, Z+
    3736:	88 23       	and	r24, r24
    3738:	09 f4       	brne	.+2      	; 0x373c <follow_path+0x13c>
    373a:	a0 c0       	rjmp	.+320    	; 0x387c <follow_path+0x27c>
    373c:	90 e0       	ldi	r25, 0x00	; 0
    373e:	48 17       	cp	r20, r24
    3740:	59 07       	cpc	r21, r25
    3742:	c1 f7       	brne	.-16     	; 0x3734 <follow_path+0x134>
    3744:	86 e0       	ldi	r24, 0x06	; 6
    3746:	c1 c0       	rjmp	.+386    	; 0x38ca <follow_path+0x2ca>
    3748:	89 2d       	mov	r24, r9
    374a:	82 60       	ori	r24, 0x02	; 2
    374c:	98 2e       	mov	r9, r24
    374e:	08 c0       	rjmp	.+16     	; 0x3760 <follow_path+0x160>
    3750:	8f e9       	ldi	r24, 0x9F	; 159
    3752:	86 0f       	add	r24, r22
    3754:	8a 31       	cpi	r24, 0x1A	; 26
    3756:	20 f4       	brcc	.+8      	; 0x3760 <follow_path+0x160>
    3758:	99 2d       	mov	r25, r9
    375a:	91 60       	ori	r25, 0x01	; 1
    375c:	99 2e       	mov	r9, r25
    375e:	60 52       	subi	r22, 0x20	; 32
    3760:	fd 01       	movw	r30, r26
    3762:	ec 0d       	add	r30, r12
    3764:	fd 1d       	adc	r31, r13
    3766:	60 83       	st	Z, r22
    3768:	f6 01       	movw	r30, r12
    376a:	31 96       	adiw	r30, 0x01	; 1
    376c:	6f 01       	movw	r12, r30
    376e:	b4 cf       	rjmp	.-152    	; 0x36d8 <follow_path+0xd8>
    3770:	cd 28       	or	r12, r13
    3772:	09 f4       	brne	.+2      	; 0x3776 <follow_path+0x176>
    3774:	6c c0       	rjmp	.+216    	; 0x384e <follow_path+0x24e>
    3776:	9c 91       	ld	r25, X
    3778:	95 3e       	cpi	r25, 0xE5	; 229
    377a:	11 f4       	brne	.+4      	; 0x3780 <follow_path+0x180>
    377c:	f5 e0       	ldi	r31, 0x05	; 5
    377e:	fc 93       	st	X, r31
    3780:	98 e0       	ldi	r25, 0x08	; 8
    3782:	49 16       	cp	r4, r25
    3784:	51 04       	cpc	r5, r1
    3786:	11 f4       	brne	.+4      	; 0x378c <follow_path+0x18c>
    3788:	99 0c       	add	r9, r9
    378a:	99 0c       	add	r9, r9
    378c:	99 2d       	mov	r25, r9
    378e:	93 70       	andi	r25, 0x03	; 3
    3790:	91 30       	cpi	r25, 0x01	; 1
    3792:	09 f4       	brne	.+2      	; 0x3796 <follow_path+0x196>
    3794:	80 61       	ori	r24, 0x10	; 16
    3796:	99 2d       	mov	r25, r9
    3798:	9c 70       	andi	r25, 0x0C	; 12
    379a:	94 30       	cpi	r25, 0x04	; 4
    379c:	09 f4       	brne	.+2      	; 0x37a0 <follow_path+0x1a0>
    379e:	88 60       	ori	r24, 0x08	; 8
    37a0:	1b 96       	adiw	r26, 0x0b	; 11
    37a2:	8c 93       	st	X, r24
    37a4:	6a 2d       	mov	r22, r10
    37a6:	78 2d       	mov	r23, r8
    37a8:	8c 81       	ldd	r24, Y+4	; 0x04
    37aa:	9d 81       	ldd	r25, Y+5	; 0x05
    37ac:	03 db       	rcall	.-2554   	; 0x2db4 <dir_sdi>
    37ae:	81 11       	cpse	r24, r1
    37b0:	81 c0       	rjmp	.+258    	; 0x38b4 <follow_path+0x2b4>
    37b2:	0c 81       	ldd	r16, Y+4	; 0x04
    37b4:	1d 81       	ldd	r17, Y+5	; 0x05
    37b6:	d8 01       	movw	r26, r16
    37b8:	1e 96       	adiw	r26, 0x0e	; 14
    37ba:	4d 91       	ld	r20, X+
    37bc:	5d 91       	ld	r21, X+
    37be:	6d 91       	ld	r22, X+
    37c0:	7c 91       	ld	r23, X
    37c2:	51 97       	sbiw	r26, 0x11	; 17
    37c4:	8d 91       	ld	r24, X+
    37c6:	9c 91       	ld	r25, X
    37c8:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <move_window>
    37cc:	81 11       	cpse	r24, r1
    37ce:	74 c0       	rjmp	.+232    	; 0x38b8 <follow_path+0x2b8>
    37d0:	f8 01       	movw	r30, r16
    37d2:	62 89       	ldd	r22, Z+18	; 0x12
    37d4:	73 89       	ldd	r23, Z+19	; 0x13
    37d6:	db 01       	movw	r26, r22
    37d8:	9c 91       	ld	r25, X
    37da:	99 23       	and	r25, r25
    37dc:	e9 f0       	breq	.+58     	; 0x3818 <follow_path+0x218>
    37de:	1b 96       	adiw	r26, 0x0b	; 11
    37e0:	9c 91       	ld	r25, X
    37e2:	93 fd       	sbrc	r25, 3
    37e4:	12 c0       	rjmp	.+36     	; 0x380a <follow_path+0x20a>
    37e6:	44 89       	ldd	r20, Z+20	; 0x14
    37e8:	55 89       	ldd	r21, Z+21	; 0x15
    37ea:	fb 01       	movw	r30, r22
    37ec:	da 01       	movw	r26, r20
    37ee:	9b 01       	movw	r18, r22
    37f0:	25 5f       	subi	r18, 0xF5	; 245
    37f2:	3f 4f       	sbci	r19, 0xFF	; 255
    37f4:	68 01       	movw	r12, r16
    37f6:	04 c0       	rjmp	.+8      	; 0x3800 <follow_path+0x200>
    37f8:	e2 17       	cp	r30, r18
    37fa:	f3 07       	cpc	r31, r19
    37fc:	09 f4       	brne	.+2      	; 0x3800 <follow_path+0x200>
    37fe:	52 c0       	rjmp	.+164    	; 0x38a4 <follow_path+0x2a4>
    3800:	11 91       	ld	r17, Z+
    3802:	9d 91       	ld	r25, X+
    3804:	19 17       	cp	r17, r25
    3806:	c1 f3       	breq	.-16     	; 0x37f8 <follow_path+0x1f8>
    3808:	86 01       	movw	r16, r12
    380a:	6a 2d       	mov	r22, r10
    380c:	78 2d       	mov	r23, r8
    380e:	c8 01       	movw	r24, r16
    3810:	bc dd       	rcall	.-1160   	; 0x338a <dir_next>
    3812:	88 23       	and	r24, r24
    3814:	81 f2       	breq	.-96     	; 0x37b6 <follow_path+0x1b6>
    3816:	50 c0       	rjmp	.+160    	; 0x38b8 <follow_path+0x2b8>
    3818:	04 88       	ldd	r0, Z+20	; 0x14
    381a:	f5 89       	ldd	r31, Z+21	; 0x15
    381c:	e0 2d       	mov	r30, r0
    381e:	93 85       	ldd	r25, Z+11	; 0x0b
    3820:	92 fd       	sbrc	r25, 2
    3822:	17 c0       	rjmp	.+46     	; 0x3852 <follow_path+0x252>
    3824:	85 e0       	ldi	r24, 0x05	; 5
    3826:	51 c0       	rjmp	.+162    	; 0x38ca <follow_path+0x2ca>
    3828:	fb 01       	movw	r30, r22
    382a:	83 85       	ldd	r24, Z+11	; 0x0b
    382c:	84 ff       	sbrs	r24, 4
    382e:	13 c0       	rjmp	.+38     	; 0x3856 <follow_path+0x256>
    3830:	ac 81       	ldd	r26, Y+4	; 0x04
    3832:	bd 81       	ldd	r27, Y+5	; 0x05
    3834:	8d 91       	ld	r24, X+
    3836:	9c 91       	ld	r25, X
    3838:	0e 94 db 10 	call	0x21b6	; 0x21b6 <ld_clust>
    383c:	ec 81       	ldd	r30, Y+4	; 0x04
    383e:	fd 81       	ldd	r31, Y+5	; 0x05
    3840:	66 83       	std	Z+6, r22	; 0x06
    3842:	77 83       	std	Z+7, r23	; 0x07
    3844:	80 87       	std	Z+8, r24	; 0x08
    3846:	91 87       	std	Z+9, r25	; 0x09
    3848:	23 cf       	rjmp	.-442    	; 0x3690 <follow_path+0x90>
    384a:	86 e0       	ldi	r24, 0x06	; 6
    384c:	3e c0       	rjmp	.+124    	; 0x38ca <follow_path+0x2ca>
    384e:	86 e0       	ldi	r24, 0x06	; 6
    3850:	3c c0       	rjmp	.+120    	; 0x38ca <follow_path+0x2ca>
    3852:	84 e0       	ldi	r24, 0x04	; 4
    3854:	3a c0       	rjmp	.+116    	; 0x38ca <follow_path+0x2ca>
    3856:	85 e0       	ldi	r24, 0x05	; 5
    3858:	38 c0       	rjmp	.+112    	; 0x38ca <follow_path+0x2ca>
    385a:	86 e0       	ldi	r24, 0x06	; 6
    385c:	36 c0       	rjmp	.+108    	; 0x38ca <follow_path+0x2ca>
    385e:	86 e0       	ldi	r24, 0x06	; 6
    3860:	34 c0       	rjmp	.+104    	; 0x38ca <follow_path+0x2ca>
    3862:	f8 e0       	ldi	r31, 0x08	; 8
    3864:	4f 16       	cp	r4, r31
    3866:	51 04       	cpc	r5, r1
    3868:	09 f4       	brne	.+2      	; 0x386c <follow_path+0x26c>
    386a:	4e cf       	rjmp	.-356    	; 0x3708 <follow_path+0x108>
    386c:	f6 cf       	rjmp	.-20     	; 0x385a <follow_path+0x25a>
    386e:	46 2f       	mov	r20, r22
    3870:	50 e0       	ldi	r21, 0x00	; 0
    3872:	42 32       	cpi	r20, 0x22	; 34
    3874:	51 05       	cpc	r21, r1
    3876:	99 f3       	breq	.-26     	; 0x385e <follow_path+0x25e>
    3878:	f1 01       	movw	r30, r2
    387a:	5c cf       	rjmp	.-328    	; 0x3734 <follow_path+0x134>
    387c:	8f eb       	ldi	r24, 0xBF	; 191
    387e:	86 0f       	add	r24, r22
    3880:	8a 31       	cpi	r24, 0x1A	; 26
    3882:	08 f4       	brcc	.+2      	; 0x3886 <follow_path+0x286>
    3884:	61 cf       	rjmp	.-318    	; 0x3748 <follow_path+0x148>
    3886:	64 cf       	rjmp	.-312    	; 0x3750 <follow_path+0x150>
    3888:	fd 82       	std	Y+5, r15	; 0x05
    388a:	ec 82       	std	Y+4, r14	; 0x04
    388c:	78 01       	movw	r14, r16
    388e:	e2 0e       	add	r14, r18
    3890:	f3 1e       	adc	r15, r19
    3892:	86 2d       	mov	r24, r6
    3894:	6d cf       	rjmp	.-294    	; 0x3770 <follow_path+0x170>
    3896:	fd 82       	std	Y+5, r15	; 0x05
    3898:	ec 82       	std	Y+4, r14	; 0x04
    389a:	78 01       	movw	r14, r16
    389c:	e2 0e       	add	r14, r18
    389e:	f3 1e       	adc	r15, r19
    38a0:	84 e0       	ldi	r24, 0x04	; 4
    38a2:	66 cf       	rjmp	.-308    	; 0x3770 <follow_path+0x170>
    38a4:	dd 82       	std	Y+5, r13	; 0x05
    38a6:	cc 82       	std	Y+4, r12	; 0x04
    38a8:	da 01       	movw	r26, r20
    38aa:	1b 96       	adiw	r26, 0x0b	; 11
    38ac:	9c 91       	ld	r25, X
    38ae:	92 ff       	sbrs	r25, 2
    38b0:	bb cf       	rjmp	.-138    	; 0x3828 <follow_path+0x228>
    38b2:	0b c0       	rjmp	.+22     	; 0x38ca <follow_path+0x2ca>
    38b4:	0c 81       	ldd	r16, Y+4	; 0x04
    38b6:	1d 81       	ldd	r17, Y+5	; 0x05
    38b8:	d8 01       	movw	r26, r16
    38ba:	54 96       	adiw	r26, 0x14	; 20
    38bc:	ed 91       	ld	r30, X+
    38be:	fc 91       	ld	r31, X
    38c0:	55 97       	sbiw	r26, 0x15	; 21
    38c2:	93 85       	ldd	r25, Z+11	; 0x0b
    38c4:	84 30       	cpi	r24, 0x04	; 4
    38c6:	09 f4       	brne	.+2      	; 0x38ca <follow_path+0x2ca>
    38c8:	ab cf       	rjmp	.-170    	; 0x3820 <follow_path+0x220>
    38ca:	0f 90       	pop	r0
    38cc:	0f 90       	pop	r0
    38ce:	0f 90       	pop	r0
    38d0:	0f 90       	pop	r0
    38d2:	0f 90       	pop	r0
    38d4:	df 91       	pop	r29
    38d6:	cf 91       	pop	r28
    38d8:	1f 91       	pop	r17
    38da:	0f 91       	pop	r16
    38dc:	ff 90       	pop	r15
    38de:	ef 90       	pop	r14
    38e0:	df 90       	pop	r13
    38e2:	cf 90       	pop	r12
    38e4:	bf 90       	pop	r11
    38e6:	af 90       	pop	r10
    38e8:	9f 90       	pop	r9
    38ea:	8f 90       	pop	r8
    38ec:	7f 90       	pop	r7
    38ee:	6f 90       	pop	r6
    38f0:	5f 90       	pop	r5
    38f2:	4f 90       	pop	r4
    38f4:	3f 90       	pop	r3
    38f6:	2f 90       	pop	r2
    38f8:	08 95       	ret

000038fa <dir_register>:
    38fa:	0f 93       	push	r16
    38fc:	1f 93       	push	r17
    38fe:	cf 93       	push	r28
    3900:	8c 01       	movw	r16, r24
    3902:	60 e0       	ldi	r22, 0x00	; 0
    3904:	70 e0       	ldi	r23, 0x00	; 0
    3906:	56 da       	rcall	.-2900   	; 0x2db4 <dir_sdi>
    3908:	c8 2f       	mov	r28, r24
    390a:	81 11       	cpse	r24, r1
    390c:	46 c0       	rjmp	.+140    	; 0x399a <dir_register+0xa0>
    390e:	d8 01       	movw	r26, r16
    3910:	1e 96       	adiw	r26, 0x0e	; 14
    3912:	4d 91       	ld	r20, X+
    3914:	5d 91       	ld	r21, X+
    3916:	6d 91       	ld	r22, X+
    3918:	7c 91       	ld	r23, X
    391a:	51 97       	sbiw	r26, 0x11	; 17
    391c:	8d 91       	ld	r24, X+
    391e:	9c 91       	ld	r25, X
    3920:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <move_window>
    3924:	c8 2f       	mov	r28, r24
    3926:	81 11       	cpse	r24, r1
    3928:	38 c0       	rjmp	.+112    	; 0x399a <dir_register+0xa0>
    392a:	d8 01       	movw	r26, r16
    392c:	52 96       	adiw	r26, 0x12	; 18
    392e:	ed 91       	ld	r30, X+
    3930:	fc 91       	ld	r31, X
    3932:	53 97       	sbiw	r26, 0x13	; 19
    3934:	80 81       	ld	r24, Z
    3936:	85 3e       	cpi	r24, 0xE5	; 229
    3938:	51 f0       	breq	.+20     	; 0x394e <dir_register+0x54>
    393a:	88 23       	and	r24, r24
    393c:	41 f0       	breq	.+16     	; 0x394e <dir_register+0x54>
    393e:	61 e0       	ldi	r22, 0x01	; 1
    3940:	70 e0       	ldi	r23, 0x00	; 0
    3942:	c8 01       	movw	r24, r16
    3944:	22 dd       	rcall	.-1468   	; 0x338a <dir_next>
    3946:	c8 2f       	mov	r28, r24
    3948:	88 23       	and	r24, r24
    394a:	09 f3       	breq	.-62     	; 0x390e <dir_register+0x14>
    394c:	26 c0       	rjmp	.+76     	; 0x399a <dir_register+0xa0>
    394e:	f8 01       	movw	r30, r16
    3950:	46 85       	ldd	r20, Z+14	; 0x0e
    3952:	57 85       	ldd	r21, Z+15	; 0x0f
    3954:	60 89       	ldd	r22, Z+16	; 0x10
    3956:	71 89       	ldd	r23, Z+17	; 0x11
    3958:	80 81       	ld	r24, Z
    395a:	91 81       	ldd	r25, Z+1	; 0x01
    395c:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <move_window>
    3960:	c8 2f       	mov	r28, r24
    3962:	81 11       	cpse	r24, r1
    3964:	1d c0       	rjmp	.+58     	; 0x39a0 <dir_register+0xa6>
    3966:	d8 01       	movw	r26, r16
    3968:	52 96       	adiw	r26, 0x12	; 18
    396a:	ed 91       	ld	r30, X+
    396c:	fc 91       	ld	r31, X
    396e:	53 97       	sbiw	r26, 0x13	; 19
    3970:	cf 01       	movw	r24, r30
    3972:	80 96       	adiw	r24, 0x20	; 32
    3974:	11 92       	st	Z+, r1
    3976:	e8 17       	cp	r30, r24
    3978:	f9 07       	cpc	r31, r25
    397a:	e1 f7       	brne	.-8      	; 0x3974 <dir_register+0x7a>
    397c:	f8 01       	movw	r30, r16
    397e:	64 89       	ldd	r22, Z+20	; 0x14
    3980:	75 89       	ldd	r23, Z+21	; 0x15
    3982:	4b e0       	ldi	r20, 0x0B	; 11
    3984:	50 e0       	ldi	r21, 0x00	; 0
    3986:	82 89       	ldd	r24, Z+18	; 0x12
    3988:	93 89       	ldd	r25, Z+19	; 0x13
    398a:	0e 94 af 10 	call	0x215e	; 0x215e <mem_cpy>
    398e:	d8 01       	movw	r26, r16
    3990:	ed 91       	ld	r30, X+
    3992:	fc 91       	ld	r31, X
    3994:	81 e0       	ldi	r24, 0x01	; 1
    3996:	84 83       	std	Z+4, r24	; 0x04
    3998:	03 c0       	rjmp	.+6      	; 0x39a0 <dir_register+0xa6>
    399a:	c4 30       	cpi	r28, 0x04	; 4
    399c:	09 f4       	brne	.+2      	; 0x39a0 <dir_register+0xa6>
    399e:	c7 e0       	ldi	r28, 0x07	; 7
    39a0:	8c 2f       	mov	r24, r28
    39a2:	cf 91       	pop	r28
    39a4:	1f 91       	pop	r17
    39a6:	0f 91       	pop	r16
    39a8:	08 95       	ret

000039aa <remove_chain>:
    39aa:	8f 92       	push	r8
    39ac:	9f 92       	push	r9
    39ae:	af 92       	push	r10
    39b0:	bf 92       	push	r11
    39b2:	cf 92       	push	r12
    39b4:	df 92       	push	r13
    39b6:	ef 92       	push	r14
    39b8:	ff 92       	push	r15
    39ba:	0f 93       	push	r16
    39bc:	1f 93       	push	r17
    39be:	cf 93       	push	r28
    39c0:	df 93       	push	r29
    39c2:	ec 01       	movw	r28, r24
    39c4:	6a 01       	movw	r12, r20
    39c6:	7b 01       	movw	r14, r22
    39c8:	42 30       	cpi	r20, 0x02	; 2
    39ca:	51 05       	cpc	r21, r1
    39cc:	61 05       	cpc	r22, r1
    39ce:	71 05       	cpc	r23, r1
    39d0:	08 f4       	brcc	.+2      	; 0x39d4 <remove_chain+0x2a>
    39d2:	4c c0       	rjmp	.+152    	; 0x3a6c <remove_chain+0xc2>
    39d4:	8a 89       	ldd	r24, Y+18	; 0x12
    39d6:	9b 89       	ldd	r25, Y+19	; 0x13
    39d8:	ac 89       	ldd	r26, Y+20	; 0x14
    39da:	bd 89       	ldd	r27, Y+21	; 0x15
    39dc:	48 17       	cp	r20, r24
    39de:	59 07       	cpc	r21, r25
    39e0:	6a 07       	cpc	r22, r26
    39e2:	7b 07       	cpc	r23, r27
    39e4:	08 f0       	brcs	.+2      	; 0x39e8 <remove_chain+0x3e>
    39e6:	44 c0       	rjmp	.+136    	; 0x3a70 <remove_chain+0xc6>
    39e8:	35 c0       	rjmp	.+106    	; 0x3a54 <remove_chain+0xaa>
    39ea:	b7 01       	movw	r22, r14
    39ec:	a6 01       	movw	r20, r12
    39ee:	ce 01       	movw	r24, r28
    39f0:	fe d8       	rcall	.-3588   	; 0x2bee <get_fat>
    39f2:	4b 01       	movw	r8, r22
    39f4:	5c 01       	movw	r10, r24
    39f6:	67 2b       	or	r22, r23
    39f8:	68 2b       	or	r22, r24
    39fa:	69 2b       	or	r22, r25
    39fc:	d9 f1       	breq	.+118    	; 0x3a74 <remove_chain+0xca>
    39fe:	81 e0       	ldi	r24, 0x01	; 1
    3a00:	88 16       	cp	r8, r24
    3a02:	91 04       	cpc	r9, r1
    3a04:	a1 04       	cpc	r10, r1
    3a06:	b1 04       	cpc	r11, r1
    3a08:	b9 f1       	breq	.+110    	; 0x3a78 <remove_chain+0xce>
    3a0a:	2f ef       	ldi	r18, 0xFF	; 255
    3a0c:	82 16       	cp	r8, r18
    3a0e:	92 06       	cpc	r9, r18
    3a10:	a2 06       	cpc	r10, r18
    3a12:	b2 06       	cpc	r11, r18
    3a14:	99 f1       	breq	.+102    	; 0x3a7c <remove_chain+0xd2>
    3a16:	00 e0       	ldi	r16, 0x00	; 0
    3a18:	10 e0       	ldi	r17, 0x00	; 0
    3a1a:	98 01       	movw	r18, r16
    3a1c:	b7 01       	movw	r22, r14
    3a1e:	a6 01       	movw	r20, r12
    3a20:	ce 01       	movw	r24, r28
    3a22:	83 da       	rcall	.-2810   	; 0x2f2a <put_fat>
    3a24:	81 11       	cpse	r24, r1
    3a26:	2b c0       	rjmp	.+86     	; 0x3a7e <remove_chain+0xd4>
    3a28:	8e 85       	ldd	r24, Y+14	; 0x0e
    3a2a:	9f 85       	ldd	r25, Y+15	; 0x0f
    3a2c:	a8 89       	ldd	r26, Y+16	; 0x10
    3a2e:	b9 89       	ldd	r27, Y+17	; 0x11
    3a30:	8f 3f       	cpi	r24, 0xFF	; 255
    3a32:	2f ef       	ldi	r18, 0xFF	; 255
    3a34:	92 07       	cpc	r25, r18
    3a36:	a2 07       	cpc	r26, r18
    3a38:	b2 07       	cpc	r27, r18
    3a3a:	51 f0       	breq	.+20     	; 0x3a50 <remove_chain+0xa6>
    3a3c:	01 96       	adiw	r24, 0x01	; 1
    3a3e:	a1 1d       	adc	r26, r1
    3a40:	b1 1d       	adc	r27, r1
    3a42:	8e 87       	std	Y+14, r24	; 0x0e
    3a44:	9f 87       	std	Y+15, r25	; 0x0f
    3a46:	a8 8b       	std	Y+16, r26	; 0x10
    3a48:	b9 8b       	std	Y+17, r27	; 0x11
    3a4a:	8d 81       	ldd	r24, Y+5	; 0x05
    3a4c:	81 60       	ori	r24, 0x01	; 1
    3a4e:	8d 83       	std	Y+5, r24	; 0x05
    3a50:	75 01       	movw	r14, r10
    3a52:	64 01       	movw	r12, r8
    3a54:	8a 89       	ldd	r24, Y+18	; 0x12
    3a56:	9b 89       	ldd	r25, Y+19	; 0x13
    3a58:	ac 89       	ldd	r26, Y+20	; 0x14
    3a5a:	bd 89       	ldd	r27, Y+21	; 0x15
    3a5c:	c8 16       	cp	r12, r24
    3a5e:	d9 06       	cpc	r13, r25
    3a60:	ea 06       	cpc	r14, r26
    3a62:	fb 06       	cpc	r15, r27
    3a64:	08 f4       	brcc	.+2      	; 0x3a68 <remove_chain+0xbe>
    3a66:	c1 cf       	rjmp	.-126    	; 0x39ea <remove_chain+0x40>
    3a68:	80 e0       	ldi	r24, 0x00	; 0
    3a6a:	09 c0       	rjmp	.+18     	; 0x3a7e <remove_chain+0xd4>
    3a6c:	82 e0       	ldi	r24, 0x02	; 2
    3a6e:	07 c0       	rjmp	.+14     	; 0x3a7e <remove_chain+0xd4>
    3a70:	82 e0       	ldi	r24, 0x02	; 2
    3a72:	05 c0       	rjmp	.+10     	; 0x3a7e <remove_chain+0xd4>
    3a74:	80 e0       	ldi	r24, 0x00	; 0
    3a76:	03 c0       	rjmp	.+6      	; 0x3a7e <remove_chain+0xd4>
    3a78:	82 e0       	ldi	r24, 0x02	; 2
    3a7a:	01 c0       	rjmp	.+2      	; 0x3a7e <remove_chain+0xd4>
    3a7c:	81 e0       	ldi	r24, 0x01	; 1
    3a7e:	df 91       	pop	r29
    3a80:	cf 91       	pop	r28
    3a82:	1f 91       	pop	r17
    3a84:	0f 91       	pop	r16
    3a86:	ff 90       	pop	r15
    3a88:	ef 90       	pop	r14
    3a8a:	df 90       	pop	r13
    3a8c:	cf 90       	pop	r12
    3a8e:	bf 90       	pop	r11
    3a90:	af 90       	pop	r10
    3a92:	9f 90       	pop	r9
    3a94:	8f 90       	pop	r8
    3a96:	08 95       	ret

00003a98 <f_mount>:
    3a98:	1f 93       	push	r17
    3a9a:	cf 93       	push	r28
    3a9c:	df 93       	push	r29
    3a9e:	00 d0       	rcall	.+0      	; 0x3aa0 <f_mount+0x8>
    3aa0:	00 d0       	rcall	.+0      	; 0x3aa2 <f_mount+0xa>
    3aa2:	00 d0       	rcall	.+0      	; 0x3aa4 <f_mount+0xc>
    3aa4:	cd b7       	in	r28, 0x3d	; 61
    3aa6:	de b7       	in	r29, 0x3e	; 62
    3aa8:	9c 83       	std	Y+4, r25	; 0x04
    3aaa:	8b 83       	std	Y+3, r24	; 0x03
    3aac:	7e 83       	std	Y+6, r23	; 0x06
    3aae:	6d 83       	std	Y+5, r22	; 0x05
    3ab0:	14 2f       	mov	r17, r20
    3ab2:	7a 83       	std	Y+2, r23	; 0x02
    3ab4:	69 83       	std	Y+1, r22	; 0x01
    3ab6:	ce 01       	movw	r24, r28
    3ab8:	01 96       	adiw	r24, 0x01	; 1
    3aba:	0e 94 41 11 	call	0x2282	; 0x2282 <get_ldnumber>
    3abe:	99 23       	and	r25, r25
    3ac0:	34 f1       	brlt	.+76     	; 0x3b0e <f_mount+0x76>
    3ac2:	fc 01       	movw	r30, r24
    3ac4:	ee 0f       	add	r30, r30
    3ac6:	ff 1f       	adc	r31, r31
    3ac8:	ea 5d       	subi	r30, 0xDA	; 218
    3aca:	f9 4f       	sbci	r31, 0xF9	; 249
    3acc:	01 90       	ld	r0, Z+
    3ace:	f0 81       	ld	r31, Z
    3ad0:	e0 2d       	mov	r30, r0
    3ad2:	30 97       	sbiw	r30, 0x00	; 0
    3ad4:	09 f0       	breq	.+2      	; 0x3ad8 <f_mount+0x40>
    3ad6:	10 82       	st	Z, r1
    3ad8:	eb 81       	ldd	r30, Y+3	; 0x03
    3ada:	fc 81       	ldd	r31, Y+4	; 0x04
    3adc:	30 97       	sbiw	r30, 0x00	; 0
    3ade:	e9 f0       	breq	.+58     	; 0x3b1a <f_mount+0x82>
    3ae0:	10 82       	st	Z, r1
    3ae2:	2b 81       	ldd	r18, Y+3	; 0x03
    3ae4:	3c 81       	ldd	r19, Y+4	; 0x04
    3ae6:	88 0f       	add	r24, r24
    3ae8:	99 1f       	adc	r25, r25
    3aea:	fc 01       	movw	r30, r24
    3aec:	ea 5d       	subi	r30, 0xDA	; 218
    3aee:	f9 4f       	sbci	r31, 0xF9	; 249
    3af0:	31 83       	std	Z+1, r19	; 0x01
    3af2:	20 83       	st	Z, r18
    3af4:	23 2b       	or	r18, r19
    3af6:	69 f0       	breq	.+26     	; 0x3b12 <f_mount+0x7a>
    3af8:	11 30       	cpi	r17, 0x01	; 1
    3afa:	69 f4       	brne	.+26     	; 0x3b16 <f_mount+0x7e>
    3afc:	40 e0       	ldi	r20, 0x00	; 0
    3afe:	be 01       	movw	r22, r28
    3b00:	6b 5f       	subi	r22, 0xFB	; 251
    3b02:	7f 4f       	sbci	r23, 0xFF	; 255
    3b04:	ce 01       	movw	r24, r28
    3b06:	03 96       	adiw	r24, 0x03	; 3
    3b08:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <find_volume>
    3b0c:	0e c0       	rjmp	.+28     	; 0x3b2a <f_mount+0x92>
    3b0e:	8b e0       	ldi	r24, 0x0B	; 11
    3b10:	0c c0       	rjmp	.+24     	; 0x3b2a <f_mount+0x92>
    3b12:	80 e0       	ldi	r24, 0x00	; 0
    3b14:	0a c0       	rjmp	.+20     	; 0x3b2a <f_mount+0x92>
    3b16:	80 e0       	ldi	r24, 0x00	; 0
    3b18:	08 c0       	rjmp	.+16     	; 0x3b2a <f_mount+0x92>
    3b1a:	88 0f       	add	r24, r24
    3b1c:	99 1f       	adc	r25, r25
    3b1e:	fc 01       	movw	r30, r24
    3b20:	ea 5d       	subi	r30, 0xDA	; 218
    3b22:	f9 4f       	sbci	r31, 0xF9	; 249
    3b24:	11 82       	std	Z+1, r1	; 0x01
    3b26:	10 82       	st	Z, r1
    3b28:	80 e0       	ldi	r24, 0x00	; 0
    3b2a:	26 96       	adiw	r28, 0x06	; 6
    3b2c:	0f b6       	in	r0, 0x3f	; 63
    3b2e:	f8 94       	cli
    3b30:	de bf       	out	0x3e, r29	; 62
    3b32:	0f be       	out	0x3f, r0	; 63
    3b34:	cd bf       	out	0x3d, r28	; 61
    3b36:	df 91       	pop	r29
    3b38:	cf 91       	pop	r28
    3b3a:	1f 91       	pop	r17
    3b3c:	08 95       	ret

00003b3e <f_open>:
    3b3e:	3f 92       	push	r3
    3b40:	4f 92       	push	r4
    3b42:	5f 92       	push	r5
    3b44:	6f 92       	push	r6
    3b46:	7f 92       	push	r7
    3b48:	8f 92       	push	r8
    3b4a:	9f 92       	push	r9
    3b4c:	af 92       	push	r10
    3b4e:	bf 92       	push	r11
    3b50:	cf 92       	push	r12
    3b52:	df 92       	push	r13
    3b54:	ef 92       	push	r14
    3b56:	ff 92       	push	r15
    3b58:	0f 93       	push	r16
    3b5a:	1f 93       	push	r17
    3b5c:	cf 93       	push	r28
    3b5e:	df 93       	push	r29
    3b60:	cd b7       	in	r28, 0x3d	; 61
    3b62:	de b7       	in	r29, 0x3e	; 62
    3b64:	a4 97       	sbiw	r28, 0x24	; 36
    3b66:	0f b6       	in	r0, 0x3f	; 63
    3b68:	f8 94       	cli
    3b6a:	de bf       	out	0x3e, r29	; 62
    3b6c:	0f be       	out	0x3f, r0	; 63
    3b6e:	cd bf       	out	0x3d, r28	; 61
    3b70:	7c a3       	std	Y+36, r23	; 0x24
    3b72:	6b a3       	std	Y+35, r22	; 0x23
    3b74:	00 97       	sbiw	r24, 0x00	; 0
    3b76:	09 f4       	brne	.+2      	; 0x3b7a <f_open+0x3c>
    3b78:	ba c0       	rjmp	.+372    	; 0x3cee <f_open+0x1b0>
    3b7a:	d4 2e       	mov	r13, r20
    3b7c:	8c 01       	movw	r16, r24
    3b7e:	fc 01       	movw	r30, r24
    3b80:	11 82       	std	Z+1, r1	; 0x01
    3b82:	10 82       	st	Z, r1
    3b84:	4e 71       	andi	r20, 0x1E	; 30
    3b86:	be 01       	movw	r22, r28
    3b88:	6d 5d       	subi	r22, 0xDD	; 221
    3b8a:	7f 4f       	sbci	r23, 0xFF	; 255
    3b8c:	ce 01       	movw	r24, r28
    3b8e:	01 96       	adiw	r24, 0x01	; 1
    3b90:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <find_volume>
    3b94:	81 11       	cpse	r24, r1
    3b96:	d5 c0       	rjmp	.+426    	; 0x3d42 <f_open+0x204>
    3b98:	fd 2d       	mov	r31, r13
    3b9a:	ff 71       	andi	r31, 0x1F	; 31
    3b9c:	3f 2e       	mov	r3, r31
    3b9e:	ce 01       	movw	r24, r28
    3ba0:	47 96       	adiw	r24, 0x17	; 23
    3ba2:	9e 8b       	std	Y+22, r25	; 0x16
    3ba4:	8d 8b       	std	Y+21, r24	; 0x15
    3ba6:	6b a1       	ldd	r22, Y+35	; 0x23
    3ba8:	7c a1       	ldd	r23, Y+36	; 0x24
    3baa:	46 97       	sbiw	r24, 0x16	; 22
    3bac:	29 dd       	rcall	.-1454   	; 0x3600 <follow_path>
    3bae:	eb 88       	ldd	r14, Y+19	; 0x13
    3bb0:	fc 88       	ldd	r15, Y+20	; 0x14
    3bb2:	81 11       	cpse	r24, r1
    3bb4:	9e c0       	rjmp	.+316    	; 0x3cf2 <f_open+0x1b4>
    3bb6:	e1 14       	cp	r14, r1
    3bb8:	f1 04       	cpc	r15, r1
    3bba:	09 f0       	breq	.+2      	; 0x3bbe <f_open+0x80>
    3bbc:	a4 c0       	rjmp	.+328    	; 0x3d06 <f_open+0x1c8>
    3bbe:	9e c0       	rjmp	.+316    	; 0x3cfc <f_open+0x1be>
    3bc0:	84 30       	cpi	r24, 0x04	; 4
    3bc2:	09 f0       	breq	.+2      	; 0x3bc6 <f_open+0x88>
    3bc4:	b0 c0       	rjmp	.+352    	; 0x3d26 <f_open+0x1e8>
    3bc6:	ce 01       	movw	r24, r28
    3bc8:	01 96       	adiw	r24, 0x01	; 1
    3bca:	97 de       	rcall	.-722    	; 0x38fa <dir_register>
    3bcc:	23 2d       	mov	r18, r3
    3bce:	28 60       	ori	r18, 0x08	; 8
    3bd0:	32 2e       	mov	r3, r18
    3bd2:	eb 88       	ldd	r14, Y+19	; 0x13
    3bd4:	fc 88       	ldd	r15, Y+20	; 0x14
    3bd6:	88 23       	and	r24, r24
    3bd8:	41 f0       	breq	.+16     	; 0x3bea <f_open+0xac>
    3bda:	9d c0       	rjmp	.+314    	; 0x3d16 <f_open+0x1d8>
    3bdc:	f7 01       	movw	r30, r14
    3bde:	83 85       	ldd	r24, Z+11	; 0x0b
    3be0:	81 71       	andi	r24, 0x11	; 17
    3be2:	09 f0       	breq	.+2      	; 0x3be6 <f_open+0xa8>
    3be4:	ab c0       	rjmp	.+342    	; 0x3d3c <f_open+0x1fe>
    3be6:	d2 fc       	sbrc	r13, 2
    3be8:	ab c0       	rjmp	.+342    	; 0x3d40 <f_open+0x202>
    3bea:	33 fe       	sbrs	r3, 3
    3bec:	98 c0       	rjmp	.+304    	; 0x3d1e <f_open+0x1e0>
    3bee:	80 e0       	ldi	r24, 0x00	; 0
    3bf0:	90 e0       	ldi	r25, 0x00	; 0
    3bf2:	a9 e6       	ldi	r26, 0x69	; 105
    3bf4:	b5 e4       	ldi	r27, 0x45	; 69
    3bf6:	f7 01       	movw	r30, r14
    3bf8:	86 87       	std	Z+14, r24	; 0x0e
    3bfa:	97 87       	std	Z+15, r25	; 0x0f
    3bfc:	a0 8b       	std	Z+16, r26	; 0x10
    3bfe:	b1 8b       	std	Z+17, r27	; 0x11
    3c00:	13 86       	std	Z+11, r1	; 0x0b
    3c02:	14 8e       	std	Z+28, r1	; 0x1c
    3c04:	15 8e       	std	Z+29, r1	; 0x1d
    3c06:	16 8e       	std	Z+30, r1	; 0x1e
    3c08:	17 8e       	std	Z+31, r1	; 0x1f
    3c0a:	c9 80       	ldd	r12, Y+1	; 0x01
    3c0c:	da 80       	ldd	r13, Y+2	; 0x02
    3c0e:	b7 01       	movw	r22, r14
    3c10:	c6 01       	movw	r24, r12
    3c12:	0e 94 db 10 	call	0x21b6	; 0x21b6 <ld_clust>
    3c16:	2b 01       	movw	r4, r22
    3c18:	3c 01       	movw	r6, r24
    3c1a:	f7 01       	movw	r30, r14
    3c1c:	13 8e       	std	Z+27, r1	; 0x1b
    3c1e:	12 8e       	std	Z+26, r1	; 0x1a
    3c20:	15 8a       	std	Z+21, r1	; 0x15
    3c22:	14 8a       	std	Z+20, r1	; 0x14
    3c24:	81 e0       	ldi	r24, 0x01	; 1
    3c26:	f6 01       	movw	r30, r12
    3c28:	84 83       	std	Z+4, r24	; 0x04
    3c2a:	41 14       	cp	r4, r1
    3c2c:	51 04       	cpc	r5, r1
    3c2e:	61 04       	cpc	r6, r1
    3c30:	71 04       	cpc	r7, r1
    3c32:	09 f4       	brne	.+2      	; 0x3c36 <f_open+0xf8>
    3c34:	74 c0       	rjmp	.+232    	; 0x3d1e <f_open+0x1e0>
    3c36:	82 a4       	ldd	r8, Z+42	; 0x2a
    3c38:	93 a4       	ldd	r9, Z+43	; 0x2b
    3c3a:	a4 a4       	ldd	r10, Z+44	; 0x2c
    3c3c:	b5 a4       	ldd	r11, Z+45	; 0x2d
    3c3e:	b3 01       	movw	r22, r6
    3c40:	a2 01       	movw	r20, r4
    3c42:	c6 01       	movw	r24, r12
    3c44:	b2 de       	rcall	.-668    	; 0x39aa <remove_chain>
    3c46:	81 11       	cpse	r24, r1
    3c48:	66 c0       	rjmp	.+204    	; 0x3d16 <f_open+0x1d8>
    3c4a:	89 81       	ldd	r24, Y+1	; 0x01
    3c4c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c4e:	f1 e0       	ldi	r31, 0x01	; 1
    3c50:	4f 1a       	sub	r4, r31
    3c52:	51 08       	sbc	r5, r1
    3c54:	61 08       	sbc	r6, r1
    3c56:	71 08       	sbc	r7, r1
    3c58:	fc 01       	movw	r30, r24
    3c5a:	42 86       	std	Z+10, r4	; 0x0a
    3c5c:	53 86       	std	Z+11, r5	; 0x0b
    3c5e:	64 86       	std	Z+12, r6	; 0x0c
    3c60:	75 86       	std	Z+13, r7	; 0x0d
    3c62:	b5 01       	movw	r22, r10
    3c64:	a4 01       	movw	r20, r8
    3c66:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <move_window>
    3c6a:	88 23       	and	r24, r24
    3c6c:	31 f0       	breq	.+12     	; 0x3c7a <f_open+0x13c>
    3c6e:	69 c0       	rjmp	.+210    	; 0x3d42 <f_open+0x204>
    3c70:	d1 fe       	sbrs	r13, 1
    3c72:	55 c0       	rjmp	.+170    	; 0x3d1e <f_open+0x1e0>
    3c74:	80 fd       	sbrc	r24, 0
    3c76:	4c c0       	rjmp	.+152    	; 0x3d10 <f_open+0x1d2>
    3c78:	52 c0       	rjmp	.+164    	; 0x3d1e <f_open+0x1e0>
    3c7a:	f3 2d       	mov	r31, r3
    3c7c:	f0 62       	ori	r31, 0x20	; 32
    3c7e:	3f 2e       	mov	r3, r31
    3c80:	e9 81       	ldd	r30, Y+1	; 0x01
    3c82:	fa 81       	ldd	r31, Y+2	; 0x02
    3c84:	82 a5       	ldd	r24, Z+42	; 0x2a
    3c86:	93 a5       	ldd	r25, Z+43	; 0x2b
    3c88:	a4 a5       	ldd	r26, Z+44	; 0x2c
    3c8a:	b5 a5       	ldd	r27, Z+45	; 0x2d
    3c8c:	f8 01       	movw	r30, r16
    3c8e:	82 8f       	std	Z+26, r24	; 0x1a
    3c90:	93 8f       	std	Z+27, r25	; 0x1b
    3c92:	a4 8f       	std	Z+28, r26	; 0x1c
    3c94:	b5 8f       	std	Z+29, r27	; 0x1d
    3c96:	f7 8e       	std	Z+31, r15	; 0x1f
    3c98:	e6 8e       	std	Z+30, r14	; 0x1e
    3c9a:	f8 01       	movw	r30, r16
    3c9c:	34 82       	std	Z+4, r3	; 0x04
    3c9e:	15 82       	std	Z+5, r1	; 0x05
    3ca0:	c9 80       	ldd	r12, Y+1	; 0x01
    3ca2:	da 80       	ldd	r13, Y+2	; 0x02
    3ca4:	b7 01       	movw	r22, r14
    3ca6:	c6 01       	movw	r24, r12
    3ca8:	0e 94 db 10 	call	0x21b6	; 0x21b6 <ld_clust>
    3cac:	f8 01       	movw	r30, r16
    3cae:	66 87       	std	Z+14, r22	; 0x0e
    3cb0:	77 87       	std	Z+15, r23	; 0x0f
    3cb2:	80 8b       	std	Z+16, r24	; 0x10
    3cb4:	91 8b       	std	Z+17, r25	; 0x11
    3cb6:	f7 01       	movw	r30, r14
    3cb8:	84 8d       	ldd	r24, Z+28	; 0x1c
    3cba:	95 8d       	ldd	r25, Z+29	; 0x1d
    3cbc:	a6 8d       	ldd	r26, Z+30	; 0x1e
    3cbe:	b7 8d       	ldd	r27, Z+31	; 0x1f
    3cc0:	f8 01       	movw	r30, r16
    3cc2:	82 87       	std	Z+10, r24	; 0x0a
    3cc4:	93 87       	std	Z+11, r25	; 0x0b
    3cc6:	a4 87       	std	Z+12, r26	; 0x0c
    3cc8:	b5 87       	std	Z+13, r27	; 0x0d
    3cca:	16 82       	std	Z+6, r1	; 0x06
    3ccc:	17 82       	std	Z+7, r1	; 0x07
    3cce:	10 86       	std	Z+8, r1	; 0x08
    3cd0:	11 86       	std	Z+9, r1	; 0x09
    3cd2:	16 8a       	std	Z+22, r1	; 0x16
    3cd4:	17 8a       	std	Z+23, r1	; 0x17
    3cd6:	10 8e       	std	Z+24, r1	; 0x18
    3cd8:	11 8e       	std	Z+25, r1	; 0x19
    3cda:	d1 82       	std	Z+1, r13	; 0x01
    3cdc:	c0 82       	st	Z, r12
    3cde:	f6 01       	movw	r30, r12
    3ce0:	86 81       	ldd	r24, Z+6	; 0x06
    3ce2:	97 81       	ldd	r25, Z+7	; 0x07
    3ce4:	f8 01       	movw	r30, r16
    3ce6:	93 83       	std	Z+3, r25	; 0x03
    3ce8:	82 83       	std	Z+2, r24	; 0x02
    3cea:	80 e0       	ldi	r24, 0x00	; 0
    3cec:	2a c0       	rjmp	.+84     	; 0x3d42 <f_open+0x204>
    3cee:	89 e0       	ldi	r24, 0x09	; 9
    3cf0:	28 c0       	rjmp	.+80     	; 0x3d42 <f_open+0x204>
    3cf2:	4d 2d       	mov	r20, r13
    3cf4:	4c 71       	andi	r20, 0x1C	; 28
    3cf6:	09 f0       	breq	.+2      	; 0x3cfa <f_open+0x1bc>
    3cf8:	63 cf       	rjmp	.-314    	; 0x3bc0 <f_open+0x82>
    3cfa:	0d c0       	rjmp	.+26     	; 0x3d16 <f_open+0x1d8>
    3cfc:	4d 2d       	mov	r20, r13
    3cfe:	4c 71       	andi	r20, 0x1C	; 28
    3d00:	89 f4       	brne	.+34     	; 0x3d24 <f_open+0x1e6>
    3d02:	86 e0       	ldi	r24, 0x06	; 6
    3d04:	08 c0       	rjmp	.+16     	; 0x3d16 <f_open+0x1d8>
    3d06:	8d 2d       	mov	r24, r13
    3d08:	8c 71       	andi	r24, 0x1C	; 28
    3d0a:	09 f0       	breq	.+2      	; 0x3d0e <f_open+0x1d0>
    3d0c:	67 cf       	rjmp	.-306    	; 0x3bdc <f_open+0x9e>
    3d0e:	11 c0       	rjmp	.+34     	; 0x3d32 <f_open+0x1f4>
    3d10:	87 e0       	ldi	r24, 0x07	; 7
    3d12:	01 c0       	rjmp	.+2      	; 0x3d16 <f_open+0x1d8>
    3d14:	84 e0       	ldi	r24, 0x04	; 4
    3d16:	88 23       	and	r24, r24
    3d18:	09 f4       	brne	.+2      	; 0x3d1c <f_open+0x1de>
    3d1a:	bf cf       	rjmp	.-130    	; 0x3c9a <f_open+0x15c>
    3d1c:	12 c0       	rjmp	.+36     	; 0x3d42 <f_open+0x204>
    3d1e:	33 fc       	sbrc	r3, 3
    3d20:	ac cf       	rjmp	.-168    	; 0x3c7a <f_open+0x13c>
    3d22:	ae cf       	rjmp	.-164    	; 0x3c80 <f_open+0x142>
    3d24:	86 e0       	ldi	r24, 0x06	; 6
    3d26:	f3 2d       	mov	r31, r3
    3d28:	f8 60       	ori	r31, 0x08	; 8
    3d2a:	3f 2e       	mov	r3, r31
    3d2c:	eb 88       	ldd	r14, Y+19	; 0x13
    3d2e:	fc 88       	ldd	r15, Y+20	; 0x14
    3d30:	f2 cf       	rjmp	.-28     	; 0x3d16 <f_open+0x1d8>
    3d32:	f7 01       	movw	r30, r14
    3d34:	83 85       	ldd	r24, Z+11	; 0x0b
    3d36:	84 fd       	sbrc	r24, 4
    3d38:	ed cf       	rjmp	.-38     	; 0x3d14 <f_open+0x1d6>
    3d3a:	9a cf       	rjmp	.-204    	; 0x3c70 <f_open+0x132>
    3d3c:	87 e0       	ldi	r24, 0x07	; 7
    3d3e:	01 c0       	rjmp	.+2      	; 0x3d42 <f_open+0x204>
    3d40:	88 e0       	ldi	r24, 0x08	; 8
    3d42:	a4 96       	adiw	r28, 0x24	; 36
    3d44:	0f b6       	in	r0, 0x3f	; 63
    3d46:	f8 94       	cli
    3d48:	de bf       	out	0x3e, r29	; 62
    3d4a:	0f be       	out	0x3f, r0	; 63
    3d4c:	cd bf       	out	0x3d, r28	; 61
    3d4e:	df 91       	pop	r29
    3d50:	cf 91       	pop	r28
    3d52:	1f 91       	pop	r17
    3d54:	0f 91       	pop	r16
    3d56:	ff 90       	pop	r15
    3d58:	ef 90       	pop	r14
    3d5a:	df 90       	pop	r13
    3d5c:	cf 90       	pop	r12
    3d5e:	bf 90       	pop	r11
    3d60:	af 90       	pop	r10
    3d62:	9f 90       	pop	r9
    3d64:	8f 90       	pop	r8
    3d66:	7f 90       	pop	r7
    3d68:	6f 90       	pop	r6
    3d6a:	5f 90       	pop	r5
    3d6c:	4f 90       	pop	r4
    3d6e:	3f 90       	pop	r3
    3d70:	08 95       	ret

00003d72 <f_write>:
    3d72:	2f 92       	push	r2
    3d74:	3f 92       	push	r3
    3d76:	4f 92       	push	r4
    3d78:	5f 92       	push	r5
    3d7a:	6f 92       	push	r6
    3d7c:	7f 92       	push	r7
    3d7e:	8f 92       	push	r8
    3d80:	9f 92       	push	r9
    3d82:	af 92       	push	r10
    3d84:	bf 92       	push	r11
    3d86:	cf 92       	push	r12
    3d88:	df 92       	push	r13
    3d8a:	ef 92       	push	r14
    3d8c:	ff 92       	push	r15
    3d8e:	0f 93       	push	r16
    3d90:	1f 93       	push	r17
    3d92:	cf 93       	push	r28
    3d94:	df 93       	push	r29
    3d96:	ec 01       	movw	r28, r24
    3d98:	4b 01       	movw	r8, r22
    3d9a:	6a 01       	movw	r12, r20
    3d9c:	59 01       	movw	r10, r18
    3d9e:	f9 01       	movw	r30, r18
    3da0:	11 82       	std	Z+1, r1	; 0x01
    3da2:	10 82       	st	Z, r1
    3da4:	0e 94 57 12 	call	0x24ae	; 0x24ae <validate>
    3da8:	81 11       	cpse	r24, r1
    3daa:	6b c1       	rjmp	.+726    	; 0x4082 <f_write+0x310>
    3dac:	8d 81       	ldd	r24, Y+5	; 0x05
    3dae:	81 11       	cpse	r24, r1
    3db0:	68 c1       	rjmp	.+720    	; 0x4082 <f_write+0x310>
    3db2:	8c 81       	ldd	r24, Y+4	; 0x04
    3db4:	81 ff       	sbrs	r24, 1
    3db6:	64 c1       	rjmp	.+712    	; 0x4080 <f_write+0x30e>
    3db8:	8e 81       	ldd	r24, Y+6	; 0x06
    3dba:	9f 81       	ldd	r25, Y+7	; 0x07
    3dbc:	a8 85       	ldd	r26, Y+8	; 0x08
    3dbe:	b9 85       	ldd	r27, Y+9	; 0x09
    3dc0:	ac 01       	movw	r20, r24
    3dc2:	bd 01       	movw	r22, r26
    3dc4:	4c 0d       	add	r20, r12
    3dc6:	5d 1d       	adc	r21, r13
    3dc8:	61 1d       	adc	r22, r1
    3dca:	71 1d       	adc	r23, r1
    3dcc:	48 17       	cp	r20, r24
    3dce:	59 07       	cpc	r21, r25
    3dd0:	6a 07       	cpc	r22, r26
    3dd2:	7b 07       	cpc	r23, r27
    3dd4:	08 f4       	brcc	.+2      	; 0x3dd8 <f_write+0x66>
    3dd6:	3e c1       	rjmp	.+636    	; 0x4054 <f_write+0x2e2>
    3dd8:	c1 14       	cp	r12, r1
    3dda:	d1 04       	cpc	r13, r1
    3ddc:	09 f4       	brne	.+2      	; 0x3de0 <f_write+0x6e>
    3dde:	3a c1       	rjmp	.+628    	; 0x4054 <f_write+0x2e2>
    3de0:	4e 81       	ldd	r20, Y+6	; 0x06
    3de2:	5f 81       	ldd	r21, Y+7	; 0x07
    3de4:	68 85       	ldd	r22, Y+8	; 0x08
    3de6:	79 85       	ldd	r23, Y+9	; 0x09
    3de8:	db 01       	movw	r26, r22
    3dea:	ca 01       	movw	r24, r20
    3dec:	91 70       	andi	r25, 0x01	; 1
    3dee:	aa 27       	eor	r26, r26
    3df0:	bb 27       	eor	r27, r27
    3df2:	89 2b       	or	r24, r25
    3df4:	8a 2b       	or	r24, r26
    3df6:	8b 2b       	or	r24, r27
    3df8:	09 f0       	breq	.+2      	; 0x3dfc <f_write+0x8a>
    3dfa:	e6 c0       	rjmp	.+460    	; 0x3fc8 <f_write+0x256>
    3dfc:	e8 81       	ld	r30, Y
    3dfe:	f9 81       	ldd	r31, Y+1	; 0x01
    3e00:	12 81       	ldd	r17, Z+2	; 0x02
    3e02:	11 50       	subi	r17, 0x01	; 1
    3e04:	db 01       	movw	r26, r22
    3e06:	ca 01       	movw	r24, r20
    3e08:	07 2e       	mov	r0, r23
    3e0a:	79 e0       	ldi	r23, 0x09	; 9
    3e0c:	b6 95       	lsr	r27
    3e0e:	a7 95       	ror	r26
    3e10:	97 95       	ror	r25
    3e12:	87 95       	ror	r24
    3e14:	7a 95       	dec	r23
    3e16:	d1 f7       	brne	.-12     	; 0x3e0c <f_write+0x9a>
    3e18:	70 2d       	mov	r23, r0
    3e1a:	18 23       	and	r17, r24
    3e1c:	09 f0       	breq	.+2      	; 0x3e20 <f_write+0xae>
    3e1e:	40 c0       	rjmp	.+128    	; 0x3ea0 <f_write+0x12e>
    3e20:	45 2b       	or	r20, r21
    3e22:	46 2b       	or	r20, r22
    3e24:	47 2b       	or	r20, r23
    3e26:	79 f4       	brne	.+30     	; 0x3e46 <f_write+0xd4>
    3e28:	6e 85       	ldd	r22, Y+14	; 0x0e
    3e2a:	7f 85       	ldd	r23, Y+15	; 0x0f
    3e2c:	88 89       	ldd	r24, Y+16	; 0x10
    3e2e:	99 89       	ldd	r25, Y+17	; 0x11
    3e30:	61 15       	cp	r22, r1
    3e32:	71 05       	cpc	r23, r1
    3e34:	81 05       	cpc	r24, r1
    3e36:	91 05       	cpc	r25, r1
    3e38:	91 f4       	brne	.+36     	; 0x3e5e <f_write+0xec>
    3e3a:	40 e0       	ldi	r20, 0x00	; 0
    3e3c:	50 e0       	ldi	r21, 0x00	; 0
    3e3e:	ba 01       	movw	r22, r20
    3e40:	cf 01       	movw	r24, r30
    3e42:	94 d9       	rcall	.-3288   	; 0x316c <create_chain>
    3e44:	06 c0       	rjmp	.+12     	; 0x3e52 <f_write+0xe0>
    3e46:	4a 89       	ldd	r20, Y+18	; 0x12
    3e48:	5b 89       	ldd	r21, Y+19	; 0x13
    3e4a:	6c 89       	ldd	r22, Y+20	; 0x14
    3e4c:	7d 89       	ldd	r23, Y+21	; 0x15
    3e4e:	cf 01       	movw	r24, r30
    3e50:	8d d9       	rcall	.-3302   	; 0x316c <create_chain>
    3e52:	61 15       	cp	r22, r1
    3e54:	71 05       	cpc	r23, r1
    3e56:	81 05       	cpc	r24, r1
    3e58:	91 05       	cpc	r25, r1
    3e5a:	09 f4       	brne	.+2      	; 0x3e5e <f_write+0xec>
    3e5c:	fb c0       	rjmp	.+502    	; 0x4054 <f_write+0x2e2>
    3e5e:	61 30       	cpi	r22, 0x01	; 1
    3e60:	71 05       	cpc	r23, r1
    3e62:	81 05       	cpc	r24, r1
    3e64:	91 05       	cpc	r25, r1
    3e66:	19 f4       	brne	.+6      	; 0x3e6e <f_write+0xfc>
    3e68:	82 e0       	ldi	r24, 0x02	; 2
    3e6a:	8d 83       	std	Y+5, r24	; 0x05
    3e6c:	0a c1       	rjmp	.+532    	; 0x4082 <f_write+0x310>
    3e6e:	6f 3f       	cpi	r22, 0xFF	; 255
    3e70:	ff ef       	ldi	r31, 0xFF	; 255
    3e72:	7f 07       	cpc	r23, r31
    3e74:	8f 07       	cpc	r24, r31
    3e76:	9f 07       	cpc	r25, r31
    3e78:	19 f4       	brne	.+6      	; 0x3e80 <f_write+0x10e>
    3e7a:	81 e0       	ldi	r24, 0x01	; 1
    3e7c:	8d 83       	std	Y+5, r24	; 0x05
    3e7e:	01 c1       	rjmp	.+514    	; 0x4082 <f_write+0x310>
    3e80:	6a 8b       	std	Y+18, r22	; 0x12
    3e82:	7b 8b       	std	Y+19, r23	; 0x13
    3e84:	8c 8b       	std	Y+20, r24	; 0x14
    3e86:	9d 8b       	std	Y+21, r25	; 0x15
    3e88:	4e 84       	ldd	r4, Y+14	; 0x0e
    3e8a:	5f 84       	ldd	r5, Y+15	; 0x0f
    3e8c:	68 88       	ldd	r6, Y+16	; 0x10
    3e8e:	79 88       	ldd	r7, Y+17	; 0x11
    3e90:	45 28       	or	r4, r5
    3e92:	46 28       	or	r4, r6
    3e94:	47 28       	or	r4, r7
    3e96:	21 f4       	brne	.+8      	; 0x3ea0 <f_write+0x12e>
    3e98:	6e 87       	std	Y+14, r22	; 0x0e
    3e9a:	7f 87       	std	Y+15, r23	; 0x0f
    3e9c:	88 8b       	std	Y+16, r24	; 0x10
    3e9e:	99 8b       	std	Y+17, r25	; 0x11
    3ea0:	e8 81       	ld	r30, Y
    3ea2:	f9 81       	ldd	r31, Y+1	; 0x01
    3ea4:	42 a5       	ldd	r20, Z+42	; 0x2a
    3ea6:	53 a5       	ldd	r21, Z+43	; 0x2b
    3ea8:	64 a5       	ldd	r22, Z+44	; 0x2c
    3eaa:	75 a5       	ldd	r23, Z+45	; 0x2d
    3eac:	8e 89       	ldd	r24, Y+22	; 0x16
    3eae:	9f 89       	ldd	r25, Y+23	; 0x17
    3eb0:	a8 8d       	ldd	r26, Y+24	; 0x18
    3eb2:	b9 8d       	ldd	r27, Y+25	; 0x19
    3eb4:	48 17       	cp	r20, r24
    3eb6:	59 07       	cpc	r21, r25
    3eb8:	6a 07       	cpc	r22, r26
    3eba:	7b 07       	cpc	r23, r27
    3ebc:	41 f4       	brne	.+16     	; 0x3ece <f_write+0x15c>
    3ebe:	cf 01       	movw	r24, r30
    3ec0:	0e 94 78 11 	call	0x22f0	; 0x22f0 <sync_window>
    3ec4:	88 23       	and	r24, r24
    3ec6:	19 f0       	breq	.+6      	; 0x3ece <f_write+0x15c>
    3ec8:	81 e0       	ldi	r24, 0x01	; 1
    3eca:	8d 83       	std	Y+5, r24	; 0x05
    3ecc:	da c0       	rjmp	.+436    	; 0x4082 <f_write+0x310>
    3ece:	28 80       	ld	r2, Y
    3ed0:	39 80       	ldd	r3, Y+1	; 0x01
    3ed2:	4a 89       	ldd	r20, Y+18	; 0x12
    3ed4:	5b 89       	ldd	r21, Y+19	; 0x13
    3ed6:	6c 89       	ldd	r22, Y+20	; 0x14
    3ed8:	7d 89       	ldd	r23, Y+21	; 0x15
    3eda:	c1 01       	movw	r24, r2
    3edc:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <clust2sect>
    3ee0:	61 15       	cp	r22, r1
    3ee2:	71 05       	cpc	r23, r1
    3ee4:	81 05       	cpc	r24, r1
    3ee6:	91 05       	cpc	r25, r1
    3ee8:	19 f4       	brne	.+6      	; 0x3ef0 <f_write+0x17e>
    3eea:	82 e0       	ldi	r24, 0x02	; 2
    3eec:	8d 83       	std	Y+5, r24	; 0x05
    3eee:	c9 c0       	rjmp	.+402    	; 0x4082 <f_write+0x310>
    3ef0:	2b 01       	movw	r4, r22
    3ef2:	3c 01       	movw	r6, r24
    3ef4:	41 0e       	add	r4, r17
    3ef6:	51 1c       	adc	r5, r1
    3ef8:	61 1c       	adc	r6, r1
    3efa:	71 1c       	adc	r7, r1
    3efc:	76 01       	movw	r14, r12
    3efe:	ef 2c       	mov	r14, r15
    3f00:	ff 24       	eor	r15, r15
    3f02:	e6 94       	lsr	r14
    3f04:	e1 14       	cp	r14, r1
    3f06:	f1 04       	cpc	r15, r1
    3f08:	09 f4       	brne	.+2      	; 0x3f0c <f_write+0x19a>
    3f0a:	3f c0       	rjmp	.+126    	; 0x3f8a <f_write+0x218>
    3f0c:	f1 01       	movw	r30, r2
    3f0e:	42 81       	ldd	r20, Z+2	; 0x02
    3f10:	24 2f       	mov	r18, r20
    3f12:	30 e0       	ldi	r19, 0x00	; 0
    3f14:	c7 01       	movw	r24, r14
    3f16:	81 0f       	add	r24, r17
    3f18:	91 1d       	adc	r25, r1
    3f1a:	28 17       	cp	r18, r24
    3f1c:	39 07       	cpc	r19, r25
    3f1e:	18 f4       	brcc	.+6      	; 0x3f26 <f_write+0x1b4>
    3f20:	79 01       	movw	r14, r18
    3f22:	e1 1a       	sub	r14, r17
    3f24:	f1 08       	sbc	r15, r1
    3f26:	87 01       	movw	r16, r14
    3f28:	a3 01       	movw	r20, r6
    3f2a:	92 01       	movw	r18, r4
    3f2c:	b4 01       	movw	r22, r8
    3f2e:	f1 01       	movw	r30, r2
    3f30:	81 81       	ldd	r24, Z+1	; 0x01
    3f32:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <disk_write>
    3f36:	88 23       	and	r24, r24
    3f38:	19 f0       	breq	.+6      	; 0x3f40 <f_write+0x1ce>
    3f3a:	81 e0       	ldi	r24, 0x01	; 1
    3f3c:	8d 83       	std	Y+5, r24	; 0x05
    3f3e:	a1 c0       	rjmp	.+322    	; 0x4082 <f_write+0x310>
    3f40:	e8 81       	ld	r30, Y
    3f42:	f9 81       	ldd	r31, Y+1	; 0x01
    3f44:	82 a5       	ldd	r24, Z+42	; 0x2a
    3f46:	93 a5       	ldd	r25, Z+43	; 0x2b
    3f48:	a4 a5       	ldd	r26, Z+44	; 0x2c
    3f4a:	b5 a5       	ldd	r27, Z+45	; 0x2d
    3f4c:	84 19       	sub	r24, r4
    3f4e:	95 09       	sbc	r25, r5
    3f50:	a6 09       	sbc	r26, r6
    3f52:	b7 09       	sbc	r27, r7
    3f54:	a7 01       	movw	r20, r14
    3f56:	60 e0       	ldi	r22, 0x00	; 0
    3f58:	70 e0       	ldi	r23, 0x00	; 0
    3f5a:	84 17       	cp	r24, r20
    3f5c:	95 07       	cpc	r25, r21
    3f5e:	a6 07       	cpc	r26, r22
    3f60:	b7 07       	cpc	r27, r23
    3f62:	78 f4       	brcc	.+30     	; 0x3f82 <f_write+0x210>
    3f64:	98 2f       	mov	r25, r24
    3f66:	88 27       	eor	r24, r24
    3f68:	99 0f       	add	r25, r25
    3f6a:	b4 01       	movw	r22, r8
    3f6c:	68 0f       	add	r22, r24
    3f6e:	79 1f       	adc	r23, r25
    3f70:	40 e0       	ldi	r20, 0x00	; 0
    3f72:	52 e0       	ldi	r21, 0x02	; 2
    3f74:	cf 01       	movw	r24, r30
    3f76:	8e 96       	adiw	r24, 0x2e	; 46
    3f78:	0e 94 af 10 	call	0x215e	; 0x215e <mem_cpy>
    3f7c:	e8 81       	ld	r30, Y
    3f7e:	f9 81       	ldd	r31, Y+1	; 0x01
    3f80:	14 82       	std	Z+4, r1	; 0x04
    3f82:	fe 2c       	mov	r15, r14
    3f84:	ee 24       	eor	r14, r14
    3f86:	ff 0c       	add	r15, r15
    3f88:	4c c0       	rjmp	.+152    	; 0x4022 <f_write+0x2b0>
    3f8a:	4e 81       	ldd	r20, Y+6	; 0x06
    3f8c:	5f 81       	ldd	r21, Y+7	; 0x07
    3f8e:	68 85       	ldd	r22, Y+8	; 0x08
    3f90:	79 85       	ldd	r23, Y+9	; 0x09
    3f92:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f94:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f96:	ac 85       	ldd	r26, Y+12	; 0x0c
    3f98:	bd 85       	ldd	r27, Y+13	; 0x0d
    3f9a:	48 17       	cp	r20, r24
    3f9c:	59 07       	cpc	r21, r25
    3f9e:	6a 07       	cpc	r22, r26
    3fa0:	7b 07       	cpc	r23, r27
    3fa2:	70 f0       	brcs	.+28     	; 0x3fc0 <f_write+0x24e>
    3fa4:	c1 01       	movw	r24, r2
    3fa6:	0e 94 78 11 	call	0x22f0	; 0x22f0 <sync_window>
    3faa:	88 23       	and	r24, r24
    3fac:	19 f0       	breq	.+6      	; 0x3fb4 <f_write+0x242>
    3fae:	81 e0       	ldi	r24, 0x01	; 1
    3fb0:	8d 83       	std	Y+5, r24	; 0x05
    3fb2:	67 c0       	rjmp	.+206    	; 0x4082 <f_write+0x310>
    3fb4:	e8 81       	ld	r30, Y
    3fb6:	f9 81       	ldd	r31, Y+1	; 0x01
    3fb8:	42 a6       	std	Z+42, r4	; 0x2a
    3fba:	53 a6       	std	Z+43, r5	; 0x2b
    3fbc:	64 a6       	std	Z+44, r6	; 0x2c
    3fbe:	75 a6       	std	Z+45, r7	; 0x2d
    3fc0:	4e 8a       	std	Y+22, r4	; 0x16
    3fc2:	5f 8a       	std	Y+23, r5	; 0x17
    3fc4:	68 8e       	std	Y+24, r6	; 0x18
    3fc6:	79 8e       	std	Y+25, r7	; 0x19
    3fc8:	2e 81       	ldd	r18, Y+6	; 0x06
    3fca:	3f 81       	ldd	r19, Y+7	; 0x07
    3fcc:	31 70       	andi	r19, 0x01	; 1
    3fce:	80 e0       	ldi	r24, 0x00	; 0
    3fd0:	92 e0       	ldi	r25, 0x02	; 2
    3fd2:	82 1b       	sub	r24, r18
    3fd4:	93 0b       	sbc	r25, r19
    3fd6:	76 01       	movw	r14, r12
    3fd8:	8c 15       	cp	r24, r12
    3fda:	9d 05       	cpc	r25, r13
    3fdc:	08 f4       	brcc	.+2      	; 0x3fe0 <f_write+0x26e>
    3fde:	7c 01       	movw	r14, r24
    3fe0:	4e 89       	ldd	r20, Y+22	; 0x16
    3fe2:	5f 89       	ldd	r21, Y+23	; 0x17
    3fe4:	68 8d       	ldd	r22, Y+24	; 0x18
    3fe6:	79 8d       	ldd	r23, Y+25	; 0x19
    3fe8:	88 81       	ld	r24, Y
    3fea:	99 81       	ldd	r25, Y+1	; 0x01
    3fec:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <move_window>
    3ff0:	88 23       	and	r24, r24
    3ff2:	19 f0       	breq	.+6      	; 0x3ffa <f_write+0x288>
    3ff4:	81 e0       	ldi	r24, 0x01	; 1
    3ff6:	8d 83       	std	Y+5, r24	; 0x05
    3ff8:	44 c0       	rjmp	.+136    	; 0x4082 <f_write+0x310>
    3ffa:	8e 81       	ldd	r24, Y+6	; 0x06
    3ffc:	9f 81       	ldd	r25, Y+7	; 0x07
    3ffe:	a8 85       	ldd	r26, Y+8	; 0x08
    4000:	b9 85       	ldd	r27, Y+9	; 0x09
    4002:	91 70       	andi	r25, 0x01	; 1
    4004:	aa 27       	eor	r26, r26
    4006:	bb 27       	eor	r27, r27
    4008:	8e 96       	adiw	r24, 0x2e	; 46
    400a:	28 81       	ld	r18, Y
    400c:	39 81       	ldd	r19, Y+1	; 0x01
    400e:	a7 01       	movw	r20, r14
    4010:	b4 01       	movw	r22, r8
    4012:	82 0f       	add	r24, r18
    4014:	93 1f       	adc	r25, r19
    4016:	0e 94 af 10 	call	0x215e	; 0x215e <mem_cpy>
    401a:	e8 81       	ld	r30, Y
    401c:	f9 81       	ldd	r31, Y+1	; 0x01
    401e:	21 e0       	ldi	r18, 0x01	; 1
    4020:	24 83       	std	Z+4, r18	; 0x04
    4022:	8e 0c       	add	r8, r14
    4024:	9f 1c       	adc	r9, r15
    4026:	8e 81       	ldd	r24, Y+6	; 0x06
    4028:	9f 81       	ldd	r25, Y+7	; 0x07
    402a:	a8 85       	ldd	r26, Y+8	; 0x08
    402c:	b9 85       	ldd	r27, Y+9	; 0x09
    402e:	8e 0d       	add	r24, r14
    4030:	9f 1d       	adc	r25, r15
    4032:	a1 1d       	adc	r26, r1
    4034:	b1 1d       	adc	r27, r1
    4036:	8e 83       	std	Y+6, r24	; 0x06
    4038:	9f 83       	std	Y+7, r25	; 0x07
    403a:	a8 87       	std	Y+8, r26	; 0x08
    403c:	b9 87       	std	Y+9, r27	; 0x09
    403e:	f5 01       	movw	r30, r10
    4040:	80 81       	ld	r24, Z
    4042:	91 81       	ldd	r25, Z+1	; 0x01
    4044:	8e 0d       	add	r24, r14
    4046:	9f 1d       	adc	r25, r15
    4048:	91 83       	std	Z+1, r25	; 0x01
    404a:	80 83       	st	Z, r24
    404c:	ce 18       	sub	r12, r14
    404e:	df 08       	sbc	r13, r15
    4050:	09 f0       	breq	.+2      	; 0x4054 <f_write+0x2e2>
    4052:	c6 ce       	rjmp	.-628    	; 0x3de0 <f_write+0x6e>
    4054:	8e 81       	ldd	r24, Y+6	; 0x06
    4056:	9f 81       	ldd	r25, Y+7	; 0x07
    4058:	a8 85       	ldd	r26, Y+8	; 0x08
    405a:	b9 85       	ldd	r27, Y+9	; 0x09
    405c:	4a 85       	ldd	r20, Y+10	; 0x0a
    405e:	5b 85       	ldd	r21, Y+11	; 0x0b
    4060:	6c 85       	ldd	r22, Y+12	; 0x0c
    4062:	7d 85       	ldd	r23, Y+13	; 0x0d
    4064:	48 17       	cp	r20, r24
    4066:	59 07       	cpc	r21, r25
    4068:	6a 07       	cpc	r22, r26
    406a:	7b 07       	cpc	r23, r27
    406c:	20 f4       	brcc	.+8      	; 0x4076 <f_write+0x304>
    406e:	8a 87       	std	Y+10, r24	; 0x0a
    4070:	9b 87       	std	Y+11, r25	; 0x0b
    4072:	ac 87       	std	Y+12, r26	; 0x0c
    4074:	bd 87       	std	Y+13, r27	; 0x0d
    4076:	8c 81       	ldd	r24, Y+4	; 0x04
    4078:	80 62       	ori	r24, 0x20	; 32
    407a:	8c 83       	std	Y+4, r24	; 0x04
    407c:	80 e0       	ldi	r24, 0x00	; 0
    407e:	01 c0       	rjmp	.+2      	; 0x4082 <f_write+0x310>
    4080:	87 e0       	ldi	r24, 0x07	; 7
    4082:	df 91       	pop	r29
    4084:	cf 91       	pop	r28
    4086:	1f 91       	pop	r17
    4088:	0f 91       	pop	r16
    408a:	ff 90       	pop	r15
    408c:	ef 90       	pop	r14
    408e:	df 90       	pop	r13
    4090:	cf 90       	pop	r12
    4092:	bf 90       	pop	r11
    4094:	af 90       	pop	r10
    4096:	9f 90       	pop	r9
    4098:	8f 90       	pop	r8
    409a:	7f 90       	pop	r7
    409c:	6f 90       	pop	r6
    409e:	5f 90       	pop	r5
    40a0:	4f 90       	pop	r4
    40a2:	3f 90       	pop	r3
    40a4:	2f 90       	pop	r2
    40a6:	08 95       	ret

000040a8 <f_sync>:
    40a8:	cf 93       	push	r28
    40aa:	df 93       	push	r29
    40ac:	ec 01       	movw	r28, r24
    40ae:	0e 94 57 12 	call	0x24ae	; 0x24ae <validate>
    40b2:	81 11       	cpse	r24, r1
    40b4:	37 c0       	rjmp	.+110    	; 0x4124 <f_sync+0x7c>
    40b6:	9c 81       	ldd	r25, Y+4	; 0x04
    40b8:	95 ff       	sbrs	r25, 5
    40ba:	34 c0       	rjmp	.+104    	; 0x4124 <f_sync+0x7c>
    40bc:	4a 8d       	ldd	r20, Y+26	; 0x1a
    40be:	5b 8d       	ldd	r21, Y+27	; 0x1b
    40c0:	6c 8d       	ldd	r22, Y+28	; 0x1c
    40c2:	7d 8d       	ldd	r23, Y+29	; 0x1d
    40c4:	88 81       	ld	r24, Y
    40c6:	99 81       	ldd	r25, Y+1	; 0x01
    40c8:	0e 94 e1 11 	call	0x23c2	; 0x23c2 <move_window>
    40cc:	81 11       	cpse	r24, r1
    40ce:	2a c0       	rjmp	.+84     	; 0x4124 <f_sync+0x7c>
    40d0:	ee 8d       	ldd	r30, Y+30	; 0x1e
    40d2:	ff 8d       	ldd	r31, Y+31	; 0x1f
    40d4:	83 85       	ldd	r24, Z+11	; 0x0b
    40d6:	80 62       	ori	r24, 0x20	; 32
    40d8:	83 87       	std	Z+11, r24	; 0x0b
    40da:	8a 85       	ldd	r24, Y+10	; 0x0a
    40dc:	9b 85       	ldd	r25, Y+11	; 0x0b
    40de:	ac 85       	ldd	r26, Y+12	; 0x0c
    40e0:	bd 85       	ldd	r27, Y+13	; 0x0d
    40e2:	84 8f       	std	Z+28, r24	; 0x1c
    40e4:	95 8f       	std	Z+29, r25	; 0x1d
    40e6:	a6 8f       	std	Z+30, r26	; 0x1e
    40e8:	b7 8f       	std	Z+31, r27	; 0x1f
    40ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    40ec:	9f 85       	ldd	r25, Y+15	; 0x0f
    40ee:	a8 89       	ldd	r26, Y+16	; 0x10
    40f0:	b9 89       	ldd	r27, Y+17	; 0x11
    40f2:	93 8f       	std	Z+27, r25	; 0x1b
    40f4:	82 8f       	std	Z+26, r24	; 0x1a
    40f6:	b5 8b       	std	Z+21, r27	; 0x15
    40f8:	a4 8b       	std	Z+20, r26	; 0x14
    40fa:	80 e0       	ldi	r24, 0x00	; 0
    40fc:	90 e0       	ldi	r25, 0x00	; 0
    40fe:	a9 e6       	ldi	r26, 0x69	; 105
    4100:	b5 e4       	ldi	r27, 0x45	; 69
    4102:	86 8b       	std	Z+22, r24	; 0x16
    4104:	97 8b       	std	Z+23, r25	; 0x17
    4106:	a0 8f       	std	Z+24, r26	; 0x18
    4108:	b1 8f       	std	Z+25, r27	; 0x19
    410a:	13 8a       	std	Z+19, r1	; 0x13
    410c:	12 8a       	std	Z+18, r1	; 0x12
    410e:	8c 81       	ldd	r24, Y+4	; 0x04
    4110:	8f 7d       	andi	r24, 0xDF	; 223
    4112:	8c 83       	std	Y+4, r24	; 0x04
    4114:	e8 81       	ld	r30, Y
    4116:	f9 81       	ldd	r31, Y+1	; 0x01
    4118:	81 e0       	ldi	r24, 0x01	; 1
    411a:	84 83       	std	Z+4, r24	; 0x04
    411c:	88 81       	ld	r24, Y
    411e:	99 81       	ldd	r25, Y+1	; 0x01
    4120:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <sync_fs>
    4124:	df 91       	pop	r29
    4126:	cf 91       	pop	r28
    4128:	08 95       	ret

0000412a <f_close>:
    412a:	cf 93       	push	r28
    412c:	df 93       	push	r29
    412e:	ec 01       	movw	r28, r24
    4130:	bb df       	rcall	.-138    	; 0x40a8 <f_sync>
    4132:	81 11       	cpse	r24, r1
    4134:	07 c0       	rjmp	.+14     	; 0x4144 <f_close+0x1a>
    4136:	ce 01       	movw	r24, r28
    4138:	0e 94 57 12 	call	0x24ae	; 0x24ae <validate>
    413c:	81 11       	cpse	r24, r1
    413e:	02 c0       	rjmp	.+4      	; 0x4144 <f_close+0x1a>
    4140:	19 82       	std	Y+1, r1	; 0x01
    4142:	18 82       	st	Y, r1
    4144:	df 91       	pop	r29
    4146:	cf 91       	pop	r28
    4148:	08 95       	ret

0000414a <f_lseek>:
    414a:	2f 92       	push	r2
    414c:	3f 92       	push	r3
    414e:	4f 92       	push	r4
    4150:	5f 92       	push	r5
    4152:	6f 92       	push	r6
    4154:	7f 92       	push	r7
    4156:	8f 92       	push	r8
    4158:	9f 92       	push	r9
    415a:	af 92       	push	r10
    415c:	bf 92       	push	r11
    415e:	cf 92       	push	r12
    4160:	df 92       	push	r13
    4162:	ef 92       	push	r14
    4164:	ff 92       	push	r15
    4166:	0f 93       	push	r16
    4168:	1f 93       	push	r17
    416a:	cf 93       	push	r28
    416c:	df 93       	push	r29
    416e:	00 d0       	rcall	.+0      	; 0x4170 <f_lseek+0x26>
    4170:	00 d0       	rcall	.+0      	; 0x4172 <f_lseek+0x28>
    4172:	cd b7       	in	r28, 0x3d	; 61
    4174:	de b7       	in	r29, 0x3e	; 62
    4176:	1c 01       	movw	r2, r24
    4178:	6a 01       	movw	r12, r20
    417a:	7b 01       	movw	r14, r22
    417c:	0e 94 57 12 	call	0x24ae	; 0x24ae <validate>
    4180:	81 11       	cpse	r24, r1
    4182:	83 c1       	rjmp	.+774    	; 0x448a <f_lseek+0x340>
    4184:	d1 01       	movw	r26, r2
    4186:	15 96       	adiw	r26, 0x05	; 5
    4188:	8c 91       	ld	r24, X
    418a:	15 97       	sbiw	r26, 0x05	; 5
    418c:	81 11       	cpse	r24, r1
    418e:	7d c1       	rjmp	.+762    	; 0x448a <f_lseek+0x340>
    4190:	1a 96       	adiw	r26, 0x0a	; 10
    4192:	8d 91       	ld	r24, X+
    4194:	9d 91       	ld	r25, X+
    4196:	0d 90       	ld	r0, X+
    4198:	bc 91       	ld	r27, X
    419a:	a0 2d       	mov	r26, r0
    419c:	8c 15       	cp	r24, r12
    419e:	9d 05       	cpc	r25, r13
    41a0:	ae 05       	cpc	r26, r14
    41a2:	bf 05       	cpc	r27, r15
    41a4:	30 f4       	brcc	.+12     	; 0x41b2 <f_lseek+0x68>
    41a6:	f1 01       	movw	r30, r2
    41a8:	24 81       	ldd	r18, Z+4	; 0x04
    41aa:	21 fd       	sbrc	r18, 1
    41ac:	02 c0       	rjmp	.+4      	; 0x41b2 <f_lseek+0x68>
    41ae:	6c 01       	movw	r12, r24
    41b0:	7d 01       	movw	r14, r26
    41b2:	d1 01       	movw	r26, r2
    41b4:	16 96       	adiw	r26, 0x06	; 6
    41b6:	4d 90       	ld	r4, X+
    41b8:	5d 90       	ld	r5, X+
    41ba:	6d 90       	ld	r6, X+
    41bc:	7c 90       	ld	r7, X
    41be:	19 97       	sbiw	r26, 0x09	; 9
    41c0:	f1 01       	movw	r30, r2
    41c2:	16 82       	std	Z+6, r1	; 0x06
    41c4:	17 82       	std	Z+7, r1	; 0x07
    41c6:	10 86       	std	Z+8, r1	; 0x08
    41c8:	11 86       	std	Z+9, r1	; 0x09
    41ca:	c1 14       	cp	r12, r1
    41cc:	d1 04       	cpc	r13, r1
    41ce:	e1 04       	cpc	r14, r1
    41d0:	f1 04       	cpc	r15, r1
    41d2:	09 f4       	brne	.+2      	; 0x41d6 <f_lseek+0x8c>
    41d4:	57 c1       	rjmp	.+686    	; 0x4484 <f_lseek+0x33a>
    41d6:	00 81       	ld	r16, Z
    41d8:	11 81       	ldd	r17, Z+1	; 0x01
    41da:	d8 01       	movw	r26, r16
    41dc:	12 96       	adiw	r26, 0x02	; 2
    41de:	8c 90       	ld	r8, X
    41e0:	91 2c       	mov	r9, r1
    41e2:	a1 2c       	mov	r10, r1
    41e4:	b1 2c       	mov	r11, r1
    41e6:	07 2e       	mov	r0, r23
    41e8:	79 e0       	ldi	r23, 0x09	; 9
    41ea:	88 0c       	add	r8, r8
    41ec:	99 1c       	adc	r9, r9
    41ee:	aa 1c       	adc	r10, r10
    41f0:	bb 1c       	adc	r11, r11
    41f2:	7a 95       	dec	r23
    41f4:	d1 f7       	brne	.-12     	; 0x41ea <f_lseek+0xa0>
    41f6:	70 2d       	mov	r23, r0
    41f8:	41 14       	cp	r4, r1
    41fa:	51 04       	cpc	r5, r1
    41fc:	61 04       	cpc	r6, r1
    41fe:	71 04       	cpc	r7, r1
    4200:	09 f4       	brne	.+2      	; 0x4204 <f_lseek+0xba>
    4202:	3f c0       	rjmp	.+126    	; 0x4282 <f_lseek+0x138>
    4204:	b1 e0       	ldi	r27, 0x01	; 1
    4206:	4b 1a       	sub	r4, r27
    4208:	51 08       	sbc	r5, r1
    420a:	61 08       	sbc	r6, r1
    420c:	71 08       	sbc	r7, r1
    420e:	c7 01       	movw	r24, r14
    4210:	b6 01       	movw	r22, r12
    4212:	61 50       	subi	r22, 0x01	; 1
    4214:	71 09       	sbc	r23, r1
    4216:	81 09       	sbc	r24, r1
    4218:	91 09       	sbc	r25, r1
    421a:	a5 01       	movw	r20, r10
    421c:	94 01       	movw	r18, r8
    421e:	0e 94 07 39 	call	0x720e	; 0x720e <__udivmodsi4>
    4222:	29 83       	std	Y+1, r18	; 0x01
    4224:	3a 83       	std	Y+2, r19	; 0x02
    4226:	4b 83       	std	Y+3, r20	; 0x03
    4228:	5c 83       	std	Y+4, r21	; 0x04
    422a:	c3 01       	movw	r24, r6
    422c:	b2 01       	movw	r22, r4
    422e:	a5 01       	movw	r20, r10
    4230:	94 01       	movw	r18, r8
    4232:	0e 94 07 39 	call	0x720e	; 0x720e <__udivmodsi4>
    4236:	89 81       	ldd	r24, Y+1	; 0x01
    4238:	9a 81       	ldd	r25, Y+2	; 0x02
    423a:	ab 81       	ldd	r26, Y+3	; 0x03
    423c:	bc 81       	ldd	r27, Y+4	; 0x04
    423e:	82 17       	cp	r24, r18
    4240:	93 07       	cpc	r25, r19
    4242:	a4 07       	cpc	r26, r20
    4244:	b5 07       	cpc	r27, r21
    4246:	e8 f0       	brcs	.+58     	; 0x4282 <f_lseek+0x138>
    4248:	88 27       	eor	r24, r24
    424a:	99 27       	eor	r25, r25
    424c:	dc 01       	movw	r26, r24
    424e:	88 19       	sub	r24, r8
    4250:	99 09       	sbc	r25, r9
    4252:	aa 09       	sbc	r26, r10
    4254:	bb 09       	sbc	r27, r11
    4256:	48 22       	and	r4, r24
    4258:	59 22       	and	r5, r25
    425a:	6a 22       	and	r6, r26
    425c:	7b 22       	and	r7, r27
    425e:	d1 01       	movw	r26, r2
    4260:	16 96       	adiw	r26, 0x06	; 6
    4262:	4d 92       	st	X+, r4
    4264:	5d 92       	st	X+, r5
    4266:	6d 92       	st	X+, r6
    4268:	7c 92       	st	X, r7
    426a:	19 97       	sbiw	r26, 0x09	; 9
    426c:	c4 18       	sub	r12, r4
    426e:	d5 08       	sbc	r13, r5
    4270:	e6 08       	sbc	r14, r6
    4272:	f7 08       	sbc	r15, r7
    4274:	52 96       	adiw	r26, 0x12	; 18
    4276:	4d 91       	ld	r20, X+
    4278:	5d 91       	ld	r21, X+
    427a:	6d 91       	ld	r22, X+
    427c:	7c 91       	ld	r23, X
    427e:	55 97       	sbiw	r26, 0x15	; 21
    4280:	32 c0       	rjmp	.+100    	; 0x42e6 <f_lseek+0x19c>
    4282:	f1 01       	movw	r30, r2
    4284:	46 85       	ldd	r20, Z+14	; 0x0e
    4286:	57 85       	ldd	r21, Z+15	; 0x0f
    4288:	60 89       	ldd	r22, Z+16	; 0x10
    428a:	71 89       	ldd	r23, Z+17	; 0x11
    428c:	41 15       	cp	r20, r1
    428e:	51 05       	cpc	r21, r1
    4290:	61 05       	cpc	r22, r1
    4292:	71 05       	cpc	r23, r1
    4294:	19 f5       	brne	.+70     	; 0x42dc <f_lseek+0x192>
    4296:	40 e0       	ldi	r20, 0x00	; 0
    4298:	50 e0       	ldi	r21, 0x00	; 0
    429a:	ba 01       	movw	r22, r20
    429c:	c8 01       	movw	r24, r16
    429e:	0e 94 b6 18 	call	0x316c	; 0x316c <create_chain>
    42a2:	ab 01       	movw	r20, r22
    42a4:	bc 01       	movw	r22, r24
    42a6:	41 30       	cpi	r20, 0x01	; 1
    42a8:	51 05       	cpc	r21, r1
    42aa:	61 05       	cpc	r22, r1
    42ac:	71 05       	cpc	r23, r1
    42ae:	29 f4       	brne	.+10     	; 0x42ba <f_lseek+0x170>
    42b0:	82 e0       	ldi	r24, 0x02	; 2
    42b2:	d1 01       	movw	r26, r2
    42b4:	15 96       	adiw	r26, 0x05	; 5
    42b6:	8c 93       	st	X, r24
    42b8:	e8 c0       	rjmp	.+464    	; 0x448a <f_lseek+0x340>
    42ba:	4f 3f       	cpi	r20, 0xFF	; 255
    42bc:	bf ef       	ldi	r27, 0xFF	; 255
    42be:	5b 07       	cpc	r21, r27
    42c0:	6b 07       	cpc	r22, r27
    42c2:	7b 07       	cpc	r23, r27
    42c4:	21 f4       	brne	.+8      	; 0x42ce <f_lseek+0x184>
    42c6:	81 e0       	ldi	r24, 0x01	; 1
    42c8:	f1 01       	movw	r30, r2
    42ca:	85 83       	std	Z+5, r24	; 0x05
    42cc:	de c0       	rjmp	.+444    	; 0x448a <f_lseek+0x340>
    42ce:	d1 01       	movw	r26, r2
    42d0:	1e 96       	adiw	r26, 0x0e	; 14
    42d2:	4d 93       	st	X+, r20
    42d4:	5d 93       	st	X+, r21
    42d6:	6d 93       	st	X+, r22
    42d8:	7c 93       	st	X, r23
    42da:	51 97       	sbiw	r26, 0x11	; 17
    42dc:	f1 01       	movw	r30, r2
    42de:	42 8b       	std	Z+18, r20	; 0x12
    42e0:	53 8b       	std	Z+19, r21	; 0x13
    42e2:	64 8b       	std	Z+20, r22	; 0x14
    42e4:	75 8b       	std	Z+21, r23	; 0x15
    42e6:	41 15       	cp	r20, r1
    42e8:	51 05       	cpc	r21, r1
    42ea:	61 05       	cpc	r22, r1
    42ec:	71 05       	cpc	r23, r1
    42ee:	09 f4       	brne	.+2      	; 0x42f2 <f_lseek+0x1a8>
    42f0:	94 c0       	rjmp	.+296    	; 0x441a <f_lseek+0x2d0>
    42f2:	8c 14       	cp	r8, r12
    42f4:	9d 04       	cpc	r9, r13
    42f6:	ae 04       	cpc	r10, r14
    42f8:	bf 04       	cpc	r11, r15
    42fa:	08 f0       	brcs	.+2      	; 0x42fe <f_lseek+0x1b4>
    42fc:	5c c0       	rjmp	.+184    	; 0x43b6 <f_lseek+0x26c>
    42fe:	d1 01       	movw	r26, r2
    4300:	14 96       	adiw	r26, 0x04	; 4
    4302:	8c 91       	ld	r24, X
    4304:	14 97       	sbiw	r26, 0x04	; 4
    4306:	81 ff       	sbrs	r24, 1
    4308:	0c c0       	rjmp	.+24     	; 0x4322 <f_lseek+0x1d8>
    430a:	8d 91       	ld	r24, X+
    430c:	9c 91       	ld	r25, X
    430e:	0e 94 b6 18 	call	0x316c	; 0x316c <create_chain>
    4312:	ab 01       	movw	r20, r22
    4314:	bc 01       	movw	r22, r24
    4316:	41 15       	cp	r20, r1
    4318:	51 05       	cpc	r21, r1
    431a:	61 05       	cpc	r22, r1
    431c:	71 05       	cpc	r23, r1
    431e:	41 f4       	brne	.+16     	; 0x4330 <f_lseek+0x1e6>
    4320:	48 c0       	rjmp	.+144    	; 0x43b2 <f_lseek+0x268>
    4322:	f1 01       	movw	r30, r2
    4324:	80 81       	ld	r24, Z
    4326:	91 81       	ldd	r25, Z+1	; 0x01
    4328:	0e 94 f7 15 	call	0x2bee	; 0x2bee <get_fat>
    432c:	ab 01       	movw	r20, r22
    432e:	bc 01       	movw	r22, r24
    4330:	4f 3f       	cpi	r20, 0xFF	; 255
    4332:	ff ef       	ldi	r31, 0xFF	; 255
    4334:	5f 07       	cpc	r21, r31
    4336:	6f 07       	cpc	r22, r31
    4338:	7f 07       	cpc	r23, r31
    433a:	29 f4       	brne	.+10     	; 0x4346 <f_lseek+0x1fc>
    433c:	81 e0       	ldi	r24, 0x01	; 1
    433e:	d1 01       	movw	r26, r2
    4340:	15 96       	adiw	r26, 0x05	; 5
    4342:	8c 93       	st	X, r24
    4344:	a2 c0       	rjmp	.+324    	; 0x448a <f_lseek+0x340>
    4346:	42 30       	cpi	r20, 0x02	; 2
    4348:	51 05       	cpc	r21, r1
    434a:	61 05       	cpc	r22, r1
    434c:	71 05       	cpc	r23, r1
    434e:	60 f0       	brcs	.+24     	; 0x4368 <f_lseek+0x21e>
    4350:	d1 01       	movw	r26, r2
    4352:	ed 91       	ld	r30, X+
    4354:	fc 91       	ld	r31, X
    4356:	82 89       	ldd	r24, Z+18	; 0x12
    4358:	93 89       	ldd	r25, Z+19	; 0x13
    435a:	a4 89       	ldd	r26, Z+20	; 0x14
    435c:	b5 89       	ldd	r27, Z+21	; 0x15
    435e:	48 17       	cp	r20, r24
    4360:	59 07       	cpc	r21, r25
    4362:	6a 07       	cpc	r22, r26
    4364:	7b 07       	cpc	r23, r27
    4366:	20 f0       	brcs	.+8      	; 0x4370 <f_lseek+0x226>
    4368:	82 e0       	ldi	r24, 0x02	; 2
    436a:	f1 01       	movw	r30, r2
    436c:	85 83       	std	Z+5, r24	; 0x05
    436e:	8d c0       	rjmp	.+282    	; 0x448a <f_lseek+0x340>
    4370:	d1 01       	movw	r26, r2
    4372:	52 96       	adiw	r26, 0x12	; 18
    4374:	4d 93       	st	X+, r20
    4376:	5d 93       	st	X+, r21
    4378:	6d 93       	st	X+, r22
    437a:	7c 93       	st	X, r23
    437c:	55 97       	sbiw	r26, 0x15	; 21
    437e:	16 96       	adiw	r26, 0x06	; 6
    4380:	8d 91       	ld	r24, X+
    4382:	9d 91       	ld	r25, X+
    4384:	0d 90       	ld	r0, X+
    4386:	bc 91       	ld	r27, X
    4388:	a0 2d       	mov	r26, r0
    438a:	88 0d       	add	r24, r8
    438c:	99 1d       	adc	r25, r9
    438e:	aa 1d       	adc	r26, r10
    4390:	bb 1d       	adc	r27, r11
    4392:	f1 01       	movw	r30, r2
    4394:	86 83       	std	Z+6, r24	; 0x06
    4396:	97 83       	std	Z+7, r25	; 0x07
    4398:	a0 87       	std	Z+8, r26	; 0x08
    439a:	b1 87       	std	Z+9, r27	; 0x09
    439c:	c8 18       	sub	r12, r8
    439e:	d9 08       	sbc	r13, r9
    43a0:	ea 08       	sbc	r14, r10
    43a2:	fb 08       	sbc	r15, r11
    43a4:	8c 14       	cp	r8, r12
    43a6:	9d 04       	cpc	r9, r13
    43a8:	ae 04       	cpc	r10, r14
    43aa:	bf 04       	cpc	r11, r15
    43ac:	08 f4       	brcc	.+2      	; 0x43b0 <f_lseek+0x266>
    43ae:	a7 cf       	rjmp	.-178    	; 0x42fe <f_lseek+0x1b4>
    43b0:	02 c0       	rjmp	.+4      	; 0x43b6 <f_lseek+0x26c>
    43b2:	75 01       	movw	r14, r10
    43b4:	64 01       	movw	r12, r8
    43b6:	f1 01       	movw	r30, r2
    43b8:	86 81       	ldd	r24, Z+6	; 0x06
    43ba:	97 81       	ldd	r25, Z+7	; 0x07
    43bc:	a0 85       	ldd	r26, Z+8	; 0x08
    43be:	b1 85       	ldd	r27, Z+9	; 0x09
    43c0:	8c 0d       	add	r24, r12
    43c2:	9d 1d       	adc	r25, r13
    43c4:	ae 1d       	adc	r26, r14
    43c6:	bf 1d       	adc	r27, r15
    43c8:	86 83       	std	Z+6, r24	; 0x06
    43ca:	97 83       	std	Z+7, r25	; 0x07
    43cc:	a0 87       	std	Z+8, r26	; 0x08
    43ce:	b1 87       	std	Z+9, r27	; 0x09
    43d0:	d7 01       	movw	r26, r14
    43d2:	c6 01       	movw	r24, r12
    43d4:	91 70       	andi	r25, 0x01	; 1
    43d6:	aa 27       	eor	r26, r26
    43d8:	bb 27       	eor	r27, r27
    43da:	89 2b       	or	r24, r25
    43dc:	8a 2b       	or	r24, r26
    43de:	8b 2b       	or	r24, r27
    43e0:	01 f1       	breq	.+64     	; 0x4422 <f_lseek+0x2d8>
    43e2:	80 81       	ld	r24, Z
    43e4:	91 81       	ldd	r25, Z+1	; 0x01
    43e6:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <clust2sect>
    43ea:	61 15       	cp	r22, r1
    43ec:	71 05       	cpc	r23, r1
    43ee:	81 05       	cpc	r24, r1
    43f0:	91 05       	cpc	r25, r1
    43f2:	29 f4       	brne	.+10     	; 0x43fe <f_lseek+0x2b4>
    43f4:	82 e0       	ldi	r24, 0x02	; 2
    43f6:	d1 01       	movw	r26, r2
    43f8:	15 96       	adiw	r26, 0x05	; 5
    43fa:	8c 93       	st	X, r24
    43fc:	46 c0       	rjmp	.+140    	; 0x448a <f_lseek+0x340>
    43fe:	0b 2e       	mov	r0, r27
    4400:	b9 e0       	ldi	r27, 0x09	; 9
    4402:	f6 94       	lsr	r15
    4404:	e7 94       	ror	r14
    4406:	d7 94       	ror	r13
    4408:	c7 94       	ror	r12
    440a:	ba 95       	dec	r27
    440c:	d1 f7       	brne	.-12     	; 0x4402 <f_lseek+0x2b8>
    440e:	b0 2d       	mov	r27, r0
    4410:	c6 0e       	add	r12, r22
    4412:	d7 1e       	adc	r13, r23
    4414:	e8 1e       	adc	r14, r24
    4416:	f9 1e       	adc	r15, r25
    4418:	07 c0       	rjmp	.+14     	; 0x4428 <f_lseek+0x2de>
    441a:	c1 2c       	mov	r12, r1
    441c:	d1 2c       	mov	r13, r1
    441e:	76 01       	movw	r14, r12
    4420:	03 c0       	rjmp	.+6      	; 0x4428 <f_lseek+0x2de>
    4422:	c1 2c       	mov	r12, r1
    4424:	d1 2c       	mov	r13, r1
    4426:	76 01       	movw	r14, r12
    4428:	f1 01       	movw	r30, r2
    442a:	86 81       	ldd	r24, Z+6	; 0x06
    442c:	97 81       	ldd	r25, Z+7	; 0x07
    442e:	a0 85       	ldd	r26, Z+8	; 0x08
    4430:	b1 85       	ldd	r27, Z+9	; 0x09
    4432:	ac 01       	movw	r20, r24
    4434:	bd 01       	movw	r22, r26
    4436:	51 70       	andi	r21, 0x01	; 1
    4438:	66 27       	eor	r22, r22
    443a:	77 27       	eor	r23, r23
    443c:	45 2b       	or	r20, r21
    443e:	46 2b       	or	r20, r22
    4440:	47 2b       	or	r20, r23
    4442:	69 f0       	breq	.+26     	; 0x445e <f_lseek+0x314>
    4444:	46 89       	ldd	r20, Z+22	; 0x16
    4446:	57 89       	ldd	r21, Z+23	; 0x17
    4448:	60 8d       	ldd	r22, Z+24	; 0x18
    444a:	71 8d       	ldd	r23, Z+25	; 0x19
    444c:	4c 15       	cp	r20, r12
    444e:	5d 05       	cpc	r21, r13
    4450:	6e 05       	cpc	r22, r14
    4452:	7f 05       	cpc	r23, r15
    4454:	21 f0       	breq	.+8      	; 0x445e <f_lseek+0x314>
    4456:	c6 8a       	std	Z+22, r12	; 0x16
    4458:	d7 8a       	std	Z+23, r13	; 0x17
    445a:	e0 8e       	std	Z+24, r14	; 0x18
    445c:	f1 8e       	std	Z+25, r15	; 0x19
    445e:	f1 01       	movw	r30, r2
    4460:	42 85       	ldd	r20, Z+10	; 0x0a
    4462:	53 85       	ldd	r21, Z+11	; 0x0b
    4464:	64 85       	ldd	r22, Z+12	; 0x0c
    4466:	75 85       	ldd	r23, Z+13	; 0x0d
    4468:	48 17       	cp	r20, r24
    446a:	59 07       	cpc	r21, r25
    446c:	6a 07       	cpc	r22, r26
    446e:	7b 07       	cpc	r23, r27
    4470:	58 f4       	brcc	.+22     	; 0x4488 <f_lseek+0x33e>
    4472:	82 87       	std	Z+10, r24	; 0x0a
    4474:	93 87       	std	Z+11, r25	; 0x0b
    4476:	a4 87       	std	Z+12, r26	; 0x0c
    4478:	b5 87       	std	Z+13, r27	; 0x0d
    447a:	84 81       	ldd	r24, Z+4	; 0x04
    447c:	80 62       	ori	r24, 0x20	; 32
    447e:	84 83       	std	Z+4, r24	; 0x04
    4480:	80 e0       	ldi	r24, 0x00	; 0
    4482:	03 c0       	rjmp	.+6      	; 0x448a <f_lseek+0x340>
    4484:	80 e0       	ldi	r24, 0x00	; 0
    4486:	01 c0       	rjmp	.+2      	; 0x448a <f_lseek+0x340>
    4488:	80 e0       	ldi	r24, 0x00	; 0
    448a:	0f 90       	pop	r0
    448c:	0f 90       	pop	r0
    448e:	0f 90       	pop	r0
    4490:	0f 90       	pop	r0
    4492:	df 91       	pop	r29
    4494:	cf 91       	pop	r28
    4496:	1f 91       	pop	r17
    4498:	0f 91       	pop	r16
    449a:	ff 90       	pop	r15
    449c:	ef 90       	pop	r14
    449e:	df 90       	pop	r13
    44a0:	cf 90       	pop	r12
    44a2:	bf 90       	pop	r11
    44a4:	af 90       	pop	r10
    44a6:	9f 90       	pop	r9
    44a8:	8f 90       	pop	r8
    44aa:	7f 90       	pop	r7
    44ac:	6f 90       	pop	r6
    44ae:	5f 90       	pop	r5
    44b0:	4f 90       	pop	r4
    44b2:	3f 90       	pop	r3
    44b4:	2f 90       	pop	r2
    44b6:	08 95       	ret

000044b8 <f_stat>:

FRESULT f_stat (
	const TCHAR* path,	/* Pointer to the file path */
	FILINFO* fno		/* Pointer to file information to return */
)
{
    44b8:	ef 92       	push	r14
    44ba:	ff 92       	push	r15
    44bc:	1f 93       	push	r17
    44be:	cf 93       	push	r28
    44c0:	df 93       	push	r29
    44c2:	cd b7       	in	r28, 0x3d	; 61
    44c4:	de b7       	in	r29, 0x3e	; 62
    44c6:	a4 97       	sbiw	r28, 0x24	; 36
    44c8:	0f b6       	in	r0, 0x3f	; 63
    44ca:	f8 94       	cli
    44cc:	de bf       	out	0x3e, r29	; 62
    44ce:	0f be       	out	0x3f, r0	; 63
    44d0:	cd bf       	out	0x3d, r28	; 61
    44d2:	9c a3       	std	Y+36, r25	; 0x24
    44d4:	8b a3       	std	Y+35, r24	; 0x23
    44d6:	7b 01       	movw	r14, r22
	DIR dj;
	DEF_NAMEBUF;


	/* Get logical drive number */
	res = find_volume(&dj.fs, &path, 0);
    44d8:	40 e0       	ldi	r20, 0x00	; 0
    44da:	be 01       	movw	r22, r28
    44dc:	6d 5d       	subi	r22, 0xDD	; 221
    44de:	7f 4f       	sbci	r23, 0xFF	; 255
    44e0:	ce 01       	movw	r24, r28
    44e2:	01 96       	adiw	r24, 0x01	; 1
    44e4:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <find_volume>
    44e8:	18 2f       	mov	r17, r24
	if (res == FR_OK) {
    44ea:	81 11       	cpse	r24, r1
    44ec:	19 c0       	rjmp	.+50     	; 0x4520 <f_stat+0x68>
		INIT_BUF(dj);
    44ee:	ce 01       	movw	r24, r28
    44f0:	47 96       	adiw	r24, 0x17	; 23
    44f2:	9e 8b       	std	Y+22, r25	; 0x16
    44f4:	8d 8b       	std	Y+21, r24	; 0x15
		res = follow_path(&dj, path);	/* Follow the file path */
    44f6:	6b a1       	ldd	r22, Y+35	; 0x23
    44f8:	7c a1       	ldd	r23, Y+36	; 0x24
    44fa:	46 97       	sbiw	r24, 0x16	; 22
    44fc:	81 d8       	rcall	.-3838   	; 0x3600 <follow_path>
    44fe:	18 2f       	mov	r17, r24
		if (res == FR_OK) {				/* Follow completed */
    4500:	81 11       	cpse	r24, r1
    4502:	0e c0       	rjmp	.+28     	; 0x4520 <f_stat+0x68>
			if (dj.dir) {		/* Found an object */
    4504:	8b 89       	ldd	r24, Y+19	; 0x13
    4506:	9c 89       	ldd	r25, Y+20	; 0x14
    4508:	89 2b       	or	r24, r25
    450a:	49 f0       	breq	.+18     	; 0x451e <f_stat+0x66>
				if (fno) get_fileinfo(&dj, fno);
    450c:	e1 14       	cp	r14, r1
    450e:	f1 04       	cpc	r15, r1
    4510:	39 f0       	breq	.+14     	; 0x4520 <f_stat+0x68>
    4512:	b7 01       	movw	r22, r14
    4514:	ce 01       	movw	r24, r28
    4516:	01 96       	adiw	r24, 0x01	; 1
    4518:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <get_fileinfo>
    451c:	01 c0       	rjmp	.+2      	; 0x4520 <f_stat+0x68>
			} else {			/* It is root directory */
				res = FR_INVALID_NAME;
    451e:	16 e0       	ldi	r17, 0x06	; 6
		}
		FREE_BUF();
	}

	LEAVE_FF(dj.fs, res);
}
    4520:	81 2f       	mov	r24, r17
    4522:	a4 96       	adiw	r28, 0x24	; 36
    4524:	0f b6       	in	r0, 0x3f	; 63
    4526:	f8 94       	cli
    4528:	de bf       	out	0x3e, r29	; 62
    452a:	0f be       	out	0x3f, r0	; 63
    452c:	cd bf       	out	0x3d, r28	; 61
    452e:	df 91       	pop	r29
    4530:	cf 91       	pop	r28
    4532:	1f 91       	pop	r17
    4534:	ff 90       	pop	r15
    4536:	ef 90       	pop	r14
    4538:	08 95       	ret

0000453a <SCSI_Command_ReadWrite_10>:
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_ReadWrite_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                      const bool IsDataRead)
{
    453a:	bf 92       	push	r11
    453c:	cf 92       	push	r12
    453e:	df 92       	push	r13
    4540:	ef 92       	push	r14
    4542:	ff 92       	push	r15
    4544:	0f 93       	push	r16
    4546:	1f 93       	push	r17
    4548:	cf 93       	push	r28
    454a:	df 93       	push	r29
    454c:	ec 01       	movw	r28, r24
    454e:	b6 2e       	mov	r11, r22

				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
    4550:	c8 a0       	ldd	r12, Y+32	; 0x20
    4552:	df 8c       	ldd	r13, Y+31	; 0x1f
    4554:	ee 8c       	ldd	r14, Y+30	; 0x1e
    4556:	fd 8c       	ldd	r15, Y+29	; 0x1d

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
    4558:	0b a1       	ldd	r16, Y+35	; 0x23
    455a:	1a a1       	ldd	r17, Y+34	; 0x22

	/* Load in the 16-bit total blocks (SCSI uses big-endian, so have to reverse the byte order) */
	TotalBlocks  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[7]);

	/* Check if the block address is outside the maximum allowable value for the LUN */
	if (BlockAddress >= get_num_of_sectors())
    455c:	0e 94 0f 0b 	call	0x161e	; 0x161e <get_num_of_sectors>
    4560:	c6 16       	cp	r12, r22
    4562:	d7 06       	cpc	r13, r23
    4564:	e8 06       	cpc	r14, r24
    4566:	f9 06       	cpc	r15, r25
    4568:	68 f0       	brcs	.+26     	; 0x4584 <SCSI_Command_ReadWrite_10+0x4a>
	{
		/* Block address is invalid, update SENSE key and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    456a:	e0 e1       	ldi	r30, 0x10	; 16
    456c:	f1 e0       	ldi	r31, 0x01	; 1
    456e:	80 81       	ld	r24, Z
    4570:	80 7f       	andi	r24, 0xF0	; 240
    4572:	85 60       	ori	r24, 0x05	; 5
    4574:	80 83       	st	Z, r24
    4576:	ee e0       	ldi	r30, 0x0E	; 14
    4578:	f1 e0       	ldi	r31, 0x01	; 1
    457a:	81 e2       	ldi	r24, 0x21	; 33
    457c:	84 87       	std	Z+12, r24	; 0x0c
    457e:	15 86       	std	Z+13, r1	; 0x0d
		               SCSI_ASENSE_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
    4580:	80 e0       	ldi	r24, 0x00	; 0
    4582:	28 c0       	rjmp	.+80     	; 0x45d4 <SCSI_Command_ReadWrite_10+0x9a>
	}

	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
    4584:	bb 20       	and	r11, r11
    4586:	31 f0       	breq	.+12     	; 0x4594 <SCSI_Command_ReadWrite_10+0x5a>
	  //SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
	  SDCardManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
    4588:	98 01       	movw	r18, r16
    458a:	b7 01       	movw	r22, r14
    458c:	a6 01       	movw	r20, r12
    458e:	ce 01       	movw	r24, r28
    4590:	bf d2       	rcall	.+1406   	; 0x4b10 <SDCardManager_ReadBlocks>
    4592:	05 c0       	rjmp	.+10     	; 0x459e <SCSI_Command_ReadWrite_10+0x64>
	else
	  SDCardManager_WriteBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
    4594:	98 01       	movw	r18, r16
    4596:	b7 01       	movw	r22, r14
    4598:	a6 01       	movw	r20, r12
    459a:	ce 01       	movw	r24, r28
    459c:	1b d2       	rcall	.+1078   	; 0x49d4 <SDCardManager_WriteBlocks>

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= ((uint32_t)TotalBlocks * VIRTUAL_MEMORY_BLOCK_SIZE);
    459e:	c8 01       	movw	r24, r16
    45a0:	a0 e0       	ldi	r26, 0x00	; 0
    45a2:	b0 e0       	ldi	r27, 0x00	; 0
    45a4:	07 2e       	mov	r0, r23
    45a6:	79 e0       	ldi	r23, 0x09	; 9
    45a8:	88 0f       	add	r24, r24
    45aa:	99 1f       	adc	r25, r25
    45ac:	aa 1f       	adc	r26, r26
    45ae:	bb 1f       	adc	r27, r27
    45b0:	7a 95       	dec	r23
    45b2:	d1 f7       	brne	.-12     	; 0x45a8 <SCSI_Command_ReadWrite_10+0x6e>
    45b4:	70 2d       	mov	r23, r0
    45b6:	4c 89       	ldd	r20, Y+20	; 0x14
    45b8:	5d 89       	ldd	r21, Y+21	; 0x15
    45ba:	6e 89       	ldd	r22, Y+22	; 0x16
    45bc:	7f 89       	ldd	r23, Y+23	; 0x17
    45be:	8a 01       	movw	r16, r20
    45c0:	9b 01       	movw	r18, r22
    45c2:	08 1b       	sub	r16, r24
    45c4:	19 0b       	sbc	r17, r25
    45c6:	2a 0b       	sbc	r18, r26
    45c8:	3b 0b       	sbc	r19, r27
    45ca:	0c 8b       	std	Y+20, r16	; 0x14
    45cc:	1d 8b       	std	Y+21, r17	; 0x15
    45ce:	2e 8b       	std	Y+22, r18	; 0x16
    45d0:	3f 8b       	std	Y+23, r19	; 0x17

	return true;
    45d2:	81 e0       	ldi	r24, 0x01	; 1
}
    45d4:	df 91       	pop	r29
    45d6:	cf 91       	pop	r28
    45d8:	1f 91       	pop	r17
    45da:	0f 91       	pop	r16
    45dc:	ff 90       	pop	r15
    45de:	ef 90       	pop	r14
    45e0:	df 90       	pop	r13
    45e2:	cf 90       	pop	r12
    45e4:	bf 90       	pop	r11
    45e6:	08 95       	ret

000045e8 <SCSI_DecodeSCSICommand>:
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise
 */
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    45e8:	cf 92       	push	r12
    45ea:	df 92       	push	r13
    45ec:	ef 92       	push	r14
    45ee:	ff 92       	push	r15
    45f0:	0f 93       	push	r16
    45f2:	1f 93       	push	r17
    45f4:	cf 93       	push	r28
    45f6:	df 93       	push	r29
    45f8:	cd b7       	in	r28, 0x3d	; 61
    45fa:	de b7       	in	r29, 0x3e	; 62
    45fc:	28 97       	sbiw	r28, 0x08	; 8
    45fe:	0f b6       	in	r0, 0x3f	; 63
    4600:	f8 94       	cli
    4602:	de bf       	out	0x3e, r29	; 62
    4604:	0f be       	out	0x3f, r0	; 63
    4606:	cd bf       	out	0x3d, r28	; 61
    4608:	8c 01       	movw	r16, r24
	bool CommandSuccess = false;



	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
    460a:	fc 01       	movw	r30, r24
    460c:	93 8d       	ldd	r25, Z+27	; 0x1b
    460e:	9d 31       	cpi	r25, 0x1D	; 29
    4610:	09 f4       	brne	.+2      	; 0x4614 <SCSI_DecodeSCSICommand+0x2c>
    4612:	db c0       	rjmp	.+438    	; 0x47ca <SCSI_DecodeSCSICommand+0x1e2>
    4614:	88 f4       	brcc	.+34     	; 0x4638 <SCSI_DecodeSCSICommand+0x50>
    4616:	92 31       	cpi	r25, 0x12	; 18
    4618:	09 f1       	breq	.+66     	; 0x465c <SCSI_DecodeSCSICommand+0x74>
    461a:	38 f4       	brcc	.+14     	; 0x462a <SCSI_DecodeSCSICommand+0x42>
    461c:	99 23       	and	r25, r25
    461e:	09 f4       	brne	.+2      	; 0x4622 <SCSI_DecodeSCSICommand+0x3a>
    4620:	46 c1       	rjmp	.+652    	; 0x48ae <SCSI_DecodeSCSICommand+0x2c6>
    4622:	93 30       	cpi	r25, 0x03	; 3
    4624:	09 f4       	brne	.+2      	; 0x4628 <SCSI_DecodeSCSICommand+0x40>
    4626:	5a c0       	rjmp	.+180    	; 0x46dc <SCSI_DecodeSCSICommand+0xf4>
    4628:	5c c1       	rjmp	.+696    	; 0x48e2 <SCSI_DecodeSCSICommand+0x2fa>
    462a:	9a 31       	cpi	r25, 0x1A	; 26
    462c:	09 f4       	brne	.+2      	; 0x4630 <SCSI_DecodeSCSICommand+0x48>
    462e:	21 c1       	rjmp	.+578    	; 0x4872 <SCSI_DecodeSCSICommand+0x28a>
    4630:	9b 31       	cpi	r25, 0x1B	; 27
    4632:	09 f4       	brne	.+2      	; 0x4636 <SCSI_DecodeSCSICommand+0x4e>
    4634:	36 c1       	rjmp	.+620    	; 0x48a2 <SCSI_DecodeSCSICommand+0x2ba>
    4636:	55 c1       	rjmp	.+682    	; 0x48e2 <SCSI_DecodeSCSICommand+0x2fa>
    4638:	98 32       	cpi	r25, 0x28	; 40
    463a:	09 f4       	brne	.+2      	; 0x463e <SCSI_DecodeSCSICommand+0x56>
    463c:	02 c1       	rjmp	.+516    	; 0x4842 <SCSI_DecodeSCSICommand+0x25a>
    463e:	38 f4       	brcc	.+14     	; 0x464e <SCSI_DecodeSCSICommand+0x66>
    4640:	9e 31       	cpi	r25, 0x1E	; 30
    4642:	09 f4       	brne	.+2      	; 0x4646 <SCSI_DecodeSCSICommand+0x5e>
    4644:	2e c1       	rjmp	.+604    	; 0x48a2 <SCSI_DecodeSCSICommand+0x2ba>
    4646:	95 32       	cpi	r25, 0x25	; 37
    4648:	09 f4       	brne	.+2      	; 0x464c <SCSI_DecodeSCSICommand+0x64>
    464a:	76 c0       	rjmp	.+236    	; 0x4738 <SCSI_DecodeSCSICommand+0x150>
    464c:	4a c1       	rjmp	.+660    	; 0x48e2 <SCSI_DecodeSCSICommand+0x2fa>
    464e:	9a 32       	cpi	r25, 0x2A	; 42
    4650:	09 f4       	brne	.+2      	; 0x4654 <SCSI_DecodeSCSICommand+0x6c>
    4652:	df c0       	rjmp	.+446    	; 0x4812 <SCSI_DecodeSCSICommand+0x22a>
    4654:	9f 32       	cpi	r25, 0x2F	; 47
    4656:	09 f4       	brne	.+2      	; 0x465a <SCSI_DecodeSCSICommand+0x72>
    4658:	24 c1       	rjmp	.+584    	; 0x48a2 <SCSI_DecodeSCSICommand+0x2ba>
    465a:	43 c1       	rjmp	.+646    	; 0x48e2 <SCSI_DecodeSCSICommand+0x2fa>
    465c:	f8 01       	movw	r30, r16
    465e:	e7 8c       	ldd	r14, Z+31	; 0x1f
    4660:	f6 8c       	ldd	r15, Z+30	; 0x1e
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));

	/* Only the standard INQUIRY data is supported, check if any optional INQUIRY bits set */
	if ((MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & ((1 << 0) | (1 << 1))) ||
    4662:	94 8d       	ldd	r25, Z+28	; 0x1c
    4664:	93 70       	andi	r25, 0x03	; 3
    4666:	19 f4       	brne	.+6      	; 0x466e <SCSI_DecodeSCSICommand+0x86>
    4668:	85 8d       	ldd	r24, Z+29	; 0x1d
    466a:	88 23       	and	r24, r24
    466c:	61 f0       	breq	.+24     	; 0x4686 <SCSI_DecodeSCSICommand+0x9e>
	     MSInterfaceInfo->State.CommandBlock.SCSICommandData[2])
	{
		/* Optional but unsupported bits set - update the SENSE key and fail the request */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    466e:	e0 e1       	ldi	r30, 0x10	; 16
    4670:	f1 e0       	ldi	r31, 0x01	; 1
    4672:	80 81       	ld	r24, Z
    4674:	80 7f       	andi	r24, 0xF0	; 240
    4676:	85 60       	ori	r24, 0x05	; 5
    4678:	80 83       	st	Z, r24
    467a:	ee e0       	ldi	r30, 0x0E	; 14
    467c:	f1 e0       	ldi	r31, 0x01	; 1
    467e:	84 e2       	ldi	r24, 0x24	; 36
    4680:	84 87       	std	Z+12, r24	; 0x0c
    4682:	15 86       	std	Z+13, r1	; 0x0d
    4684:	49 c1       	rjmp	.+658    	; 0x4918 <SCSI_DecodeSCSICommand+0x330>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));
    4686:	67 01       	movw	r12, r14
    4688:	f5 e2       	ldi	r31, 0x25	; 37
    468a:	ef 16       	cp	r14, r31
    468c:	f1 04       	cpc	r15, r1
    468e:	28 f0       	brcs	.+10     	; 0x469a <SCSI_DecodeSCSICommand+0xb2>
    4690:	0f 2e       	mov	r0, r31
    4692:	f4 e2       	ldi	r31, 0x24	; 36
    4694:	cf 2e       	mov	r12, r31
    4696:	d1 2c       	mov	r13, r1
    4698:	f0 2d       	mov	r31, r0
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
	}

	Endpoint_Write_Stream_LE(&InquiryData, BytesTransferred, NULL);
    469a:	40 e0       	ldi	r20, 0x00	; 0
    469c:	50 e0       	ldi	r21, 0x00	; 0
    469e:	b6 01       	movw	r22, r12
    46a0:	86 ea       	ldi	r24, 0xA6	; 166
    46a2:	93 e0       	ldi	r25, 0x03	; 3
    46a4:	0e 94 63 32 	call	0x64c6	; 0x64c6 <Endpoint_Write_Stream_LE>

	/* Pad out remaining bytes with 0x00 */
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
    46a8:	60 e0       	ldi	r22, 0x00	; 0
    46aa:	70 e0       	ldi	r23, 0x00	; 0
    46ac:	c7 01       	movw	r24, r14
    46ae:	8c 19       	sub	r24, r12
    46b0:	9d 09       	sbc	r25, r13
    46b2:	0e 94 14 32 	call	0x6428	; 0x6428 <Endpoint_Null_Stream>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    46b6:	e8 ee       	ldi	r30, 0xE8	; 232
    46b8:	f0 e0       	ldi	r31, 0x00	; 0
    46ba:	80 81       	ld	r24, Z
    46bc:	8e 77       	andi	r24, 0x7E	; 126
    46be:	80 83       	st	Z, r24

	/* Finalize the stream transfer to send the last packet */
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
    46c0:	f8 01       	movw	r30, r16
    46c2:	84 89       	ldd	r24, Z+20	; 0x14
    46c4:	95 89       	ldd	r25, Z+21	; 0x15
    46c6:	a6 89       	ldd	r26, Z+22	; 0x16
    46c8:	b7 89       	ldd	r27, Z+23	; 0x17
    46ca:	8c 19       	sub	r24, r12
    46cc:	9d 09       	sbc	r25, r13
    46ce:	a1 09       	sbc	r26, r1
    46d0:	b1 09       	sbc	r27, r1
    46d2:	84 8b       	std	Z+20, r24	; 0x14
    46d4:	95 8b       	std	Z+21, r25	; 0x15
    46d6:	a6 8b       	std	Z+22, r26	; 0x16
    46d8:	b7 8b       	std	Z+23, r27	; 0x17
    46da:	11 c1       	rjmp	.+546    	; 0x48fe <SCSI_DecodeSCSICommand+0x316>
 *
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint8_t  AllocationLength = MSInterfaceInfo->State.CommandBlock.SCSICommandData[4];
    46dc:	f8 01       	movw	r30, r16
    46de:	f7 8c       	ldd	r15, Z+31	; 0x1f
	uint8_t  BytesTransferred = MIN(AllocationLength, sizeof(SenseData));
    46e0:	ef 2c       	mov	r14, r15
    46e2:	f2 e1       	ldi	r31, 0x12	; 18
    46e4:	ff 15       	cp	r31, r15
    46e6:	20 f4       	brcc	.+8      	; 0x46f0 <SCSI_DecodeSCSICommand+0x108>
    46e8:	0f 2e       	mov	r0, r31
    46ea:	f2 e1       	ldi	r31, 0x12	; 18
    46ec:	ef 2e       	mov	r14, r31
    46ee:	f0 2d       	mov	r31, r0

	Endpoint_Write_Stream_LE(&SenseData, BytesTransferred, NULL);
    46f0:	ce 2c       	mov	r12, r14
    46f2:	d1 2c       	mov	r13, r1
    46f4:	40 e0       	ldi	r20, 0x00	; 0
    46f6:	50 e0       	ldi	r21, 0x00	; 0
    46f8:	b6 01       	movw	r22, r12
    46fa:	8e e0       	ldi	r24, 0x0E	; 14
    46fc:	91 e0       	ldi	r25, 0x01	; 1
    46fe:	0e 94 63 32 	call	0x64c6	; 0x64c6 <Endpoint_Write_Stream_LE>
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
    4702:	8f 2d       	mov	r24, r15
    4704:	90 e0       	ldi	r25, 0x00	; 0
    4706:	60 e0       	ldi	r22, 0x00	; 0
    4708:	70 e0       	ldi	r23, 0x00	; 0
    470a:	8c 19       	sub	r24, r12
    470c:	9d 09       	sbc	r25, r13
    470e:	0e 94 14 32 	call	0x6428	; 0x6428 <Endpoint_Null_Stream>
    4712:	e8 ee       	ldi	r30, 0xE8	; 232
    4714:	f0 e0       	ldi	r31, 0x00	; 0
    4716:	80 81       	ld	r24, Z
    4718:	8e 77       	andi	r24, 0x7E	; 126
    471a:	80 83       	st	Z, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
    471c:	f8 01       	movw	r30, r16
    471e:	84 89       	ldd	r24, Z+20	; 0x14
    4720:	95 89       	ldd	r25, Z+21	; 0x15
    4722:	a6 89       	ldd	r26, Z+22	; 0x16
    4724:	b7 89       	ldd	r27, Z+23	; 0x17
    4726:	8e 19       	sub	r24, r14
    4728:	91 09       	sbc	r25, r1
    472a:	a1 09       	sbc	r26, r1
    472c:	b1 09       	sbc	r27, r1
    472e:	84 8b       	std	Z+20, r24	; 0x14
    4730:	95 8b       	std	Z+21, r25	; 0x15
    4732:	a6 8b       	std	Z+22, r26	; 0x16
    4734:	b7 8b       	std	Z+23, r27	; 0x17
		case SCSI_CMD_INQUIRY:
			CommandSuccess = SCSI_Command_Inquiry(MSInterfaceInfo);
			break;
		case SCSI_CMD_REQUEST_SENSE:
			CommandSuccess = SCSI_Command_Request_Sense(MSInterfaceInfo);
			break;
    4736:	e3 c0       	rjmp	.+454    	; 0x48fe <SCSI_DecodeSCSICommand+0x316>
		case SCSI_CMD_READ_CAPACITY_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    4738:	4a d2       	rcall	.+1172   	; 0x4bce <SDCardManager_CheckSDCardOperation>
    473a:	88 23       	and	r24, r24
    473c:	21 f0       	breq	.+8      	; 0x4746 <SCSI_DecodeSCSICommand+0x15e>
    473e:	80 91 28 08 	lds	r24, 0x0828
    4742:	81 30       	cpi	r24, 0x01	; 1
    4744:	69 f0       	breq	.+26     	; 0x4760 <SCSI_DecodeSCSICommand+0x178>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
    4746:	e0 e1       	ldi	r30, 0x10	; 16
    4748:	f1 e0       	ldi	r31, 0x01	; 1
    474a:	80 81       	ld	r24, Z
    474c:	80 7f       	andi	r24, 0xF0	; 240
    474e:	82 60       	ori	r24, 0x02	; 2
    4750:	80 83       	st	Z, r24
    4752:	ee e0       	ldi	r30, 0x0E	; 14
    4754:	f1 e0       	ldi	r31, 0x01	; 1
    4756:	8a e3       	ldi	r24, 0x3A	; 58
    4758:	84 87       	std	Z+12, r24	; 0x0c
    475a:	15 86       	std	Z+13, r1	; 0x0d
				return false; //return with an error flag -- send a failure response to host.
    475c:	80 e0       	ldi	r24, 0x00	; 0
    475e:	dd c0       	rjmp	.+442    	; 0x491a <SCSI_DecodeSCSICommand+0x332>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Read_Capacity_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint32_t LastBlockAddressInLUN;
	uint32_t MediaBlockSize        = VIRTUAL_MEMORY_BLOCK_SIZE;
    4760:	80 e0       	ldi	r24, 0x00	; 0
    4762:	92 e0       	ldi	r25, 0x02	; 2
    4764:	a0 e0       	ldi	r26, 0x00	; 0
    4766:	b0 e0       	ldi	r27, 0x00	; 0
    4768:	89 83       	std	Y+1, r24	; 0x01
    476a:	9a 83       	std	Y+2, r25	; 0x02
    476c:	ab 83       	std	Y+3, r26	; 0x03
    476e:	bc 83       	std	Y+4, r27	; 0x04

	LastBlockAddressInLUN = get_num_of_sectors()-1;
    4770:	0e 94 0f 0b 	call	0x161e	; 0x161e <get_num_of_sectors>
    4774:	dc 01       	movw	r26, r24
    4776:	cb 01       	movw	r24, r22
    4778:	01 97       	sbiw	r24, 0x01	; 1
    477a:	a1 09       	sbc	r26, r1
    477c:	b1 09       	sbc	r27, r1
    477e:	8d 83       	std	Y+5, r24	; 0x05
    4780:	9e 83       	std	Y+6, r25	; 0x06
    4782:	af 83       	std	Y+7, r26	; 0x07
    4784:	b8 87       	std	Y+8, r27	; 0x08

	Endpoint_Write_Stream_BE(&LastBlockAddressInLUN, sizeof(LastBlockAddressInLUN), NULL);
    4786:	40 e0       	ldi	r20, 0x00	; 0
    4788:	50 e0       	ldi	r21, 0x00	; 0
    478a:	64 e0       	ldi	r22, 0x04	; 4
    478c:	70 e0       	ldi	r23, 0x00	; 0
    478e:	ce 01       	movw	r24, r28
    4790:	05 96       	adiw	r24, 0x05	; 5
    4792:	0e 94 c0 32 	call	0x6580	; 0x6580 <Endpoint_Write_Stream_BE>
	Endpoint_Write_Stream_BE(&MediaBlockSize, sizeof(MediaBlockSize), NULL);
    4796:	40 e0       	ldi	r20, 0x00	; 0
    4798:	50 e0       	ldi	r21, 0x00	; 0
    479a:	64 e0       	ldi	r22, 0x04	; 4
    479c:	70 e0       	ldi	r23, 0x00	; 0
    479e:	ce 01       	movw	r24, r28
    47a0:	01 96       	adiw	r24, 0x01	; 1
    47a2:	0e 94 c0 32 	call	0x6580	; 0x6580 <Endpoint_Write_Stream_BE>
    47a6:	e8 ee       	ldi	r30, 0xE8	; 232
    47a8:	f0 e0       	ldi	r31, 0x00	; 0
    47aa:	80 81       	ld	r24, Z
    47ac:	8e 77       	andi	r24, 0x7E	; 126
    47ae:	80 83       	st	Z, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 8;
    47b0:	f8 01       	movw	r30, r16
    47b2:	84 89       	ldd	r24, Z+20	; 0x14
    47b4:	95 89       	ldd	r25, Z+21	; 0x15
    47b6:	a6 89       	ldd	r26, Z+22	; 0x16
    47b8:	b7 89       	ldd	r27, Z+23	; 0x17
    47ba:	08 97       	sbiw	r24, 0x08	; 8
    47bc:	a1 09       	sbc	r26, r1
    47be:	b1 09       	sbc	r27, r1
    47c0:	84 8b       	std	Z+20, r24	; 0x14
    47c2:	95 8b       	std	Z+21, r25	; 0x15
    47c4:	a6 8b       	std	Z+22, r26	; 0x16
    47c6:	b7 8b       	std	Z+23, r27	; 0x17
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
				return false; //return with an error flag -- send a failure response to host.
			}
			CommandSuccess = SCSI_Command_Read_Capacity_10(MSInterfaceInfo);
			break;
    47c8:	9a c0       	rjmp	.+308    	; 0x48fe <SCSI_DecodeSCSICommand+0x316>
 *  \return Boolean \c true if the command completed successfully, \c false otherwise.
 */
static bool SCSI_Command_Send_Diagnostic(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	/* Check to see if the SELF TEST bit is not set */
	if (!(MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & (1 << 2)))
    47ca:	f8 01       	movw	r30, r16
    47cc:	84 8d       	ldd	r24, Z+28	; 0x1c
    47ce:	82 fd       	sbrc	r24, 2
    47d0:	0c c0       	rjmp	.+24     	; 0x47ea <SCSI_DecodeSCSICommand+0x202>
	{
		/* Only self-test supported - update SENSE key and fail the command */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    47d2:	e0 e1       	ldi	r30, 0x10	; 16
    47d4:	f1 e0       	ldi	r31, 0x01	; 1
    47d6:	80 81       	ld	r24, Z
    47d8:	80 7f       	andi	r24, 0xF0	; 240
    47da:	85 60       	ori	r24, 0x05	; 5
    47dc:	80 83       	st	Z, r24
    47de:	ee e0       	ldi	r30, 0x0E	; 14
    47e0:	f1 e0       	ldi	r31, 0x01	; 1
    47e2:	84 e2       	ldi	r24, 0x24	; 36
    47e4:	84 87       	std	Z+12, r24	; 0x0c
    47e6:	15 86       	std	Z+13, r1	; 0x0d
    47e8:	97 c0       	rjmp	.+302    	; 0x4918 <SCSI_DecodeSCSICommand+0x330>

		return false;
	}

	/* Check to see if all attached Dataflash ICs are functional */
	if (!(SDCardManager_CheckSDCardOperation()))
    47ea:	f1 d1       	rcall	.+994    	; 0x4bce <SDCardManager_CheckSDCardOperation>
    47ec:	81 11       	cpse	r24, r1
    47ee:	0b c0       	rjmp	.+22     	; 0x4806 <SCSI_DecodeSCSICommand+0x21e>
	{
		/* Update SENSE key with a hardware error condition and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_HARDWARE_ERROR,
    47f0:	e0 e1       	ldi	r30, 0x10	; 16
    47f2:	f1 e0       	ldi	r31, 0x01	; 1
    47f4:	80 81       	ld	r24, Z
    47f6:	80 7f       	andi	r24, 0xF0	; 240
    47f8:	84 60       	ori	r24, 0x04	; 4
    47fa:	80 83       	st	Z, r24
    47fc:	ee e0       	ldi	r30, 0x0E	; 14
    47fe:	f1 e0       	ldi	r31, 0x01	; 1
    4800:	14 86       	std	Z+12, r1	; 0x0c
    4802:	15 86       	std	Z+13, r1	; 0x0d
    4804:	89 c0       	rjmp	.+274    	; 0x4918 <SCSI_DecodeSCSICommand+0x330>

		return false;
	}

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
    4806:	f8 01       	movw	r30, r16
    4808:	14 8a       	std	Z+20, r1	; 0x14
    480a:	15 8a       	std	Z+21, r1	; 0x15
    480c:	16 8a       	std	Z+22, r1	; 0x16
    480e:	17 8a       	std	Z+23, r1	; 0x17
    4810:	76 c0       	rjmp	.+236    	; 0x48fe <SCSI_DecodeSCSICommand+0x316>
			break;
		case SCSI_CMD_SEND_DIAGNOSTIC:
			CommandSuccess = SCSI_Command_Send_Diagnostic(MSInterfaceInfo);
			break;
		case SCSI_CMD_WRITE_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    4812:	dd d1       	rcall	.+954    	; 0x4bce <SDCardManager_CheckSDCardOperation>
    4814:	88 23       	and	r24, r24
    4816:	21 f0       	breq	.+8      	; 0x4820 <SCSI_DecodeSCSICommand+0x238>
    4818:	80 91 28 08 	lds	r24, 0x0828
    481c:	81 30       	cpi	r24, 0x01	; 1
    481e:	69 f0       	breq	.+26     	; 0x483a <SCSI_DecodeSCSICommand+0x252>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
    4820:	e0 e1       	ldi	r30, 0x10	; 16
    4822:	f1 e0       	ldi	r31, 0x01	; 1
    4824:	80 81       	ld	r24, Z
    4826:	80 7f       	andi	r24, 0xF0	; 240
    4828:	82 60       	ori	r24, 0x02	; 2
    482a:	80 83       	st	Z, r24
    482c:	ee e0       	ldi	r30, 0x0E	; 14
    482e:	f1 e0       	ldi	r31, 0x01	; 1
    4830:	8a e3       	ldi	r24, 0x3A	; 58
    4832:	84 87       	std	Z+12, r24	; 0x0c
    4834:	15 86       	std	Z+13, r1	; 0x0d
				return false; //return with an error flag -- send a failure response to host.
    4836:	80 e0       	ldi	r24, 0x00	; 0
    4838:	70 c0       	rjmp	.+224    	; 0x491a <SCSI_DecodeSCSICommand+0x332>
			}
			
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_WRITE);
    483a:	60 e0       	ldi	r22, 0x00	; 0
    483c:	c8 01       	movw	r24, r16
    483e:	7d de       	rcall	.-774    	; 0x453a <SCSI_Command_ReadWrite_10>
			break;
    4840:	5c c0       	rjmp	.+184    	; 0x48fa <SCSI_DecodeSCSICommand+0x312>
		case SCSI_CMD_READ_10:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    4842:	c5 d1       	rcall	.+906    	; 0x4bce <SDCardManager_CheckSDCardOperation>
    4844:	88 23       	and	r24, r24
    4846:	21 f0       	breq	.+8      	; 0x4850 <SCSI_DecodeSCSICommand+0x268>
    4848:	80 91 28 08 	lds	r24, 0x0828
    484c:	81 30       	cpi	r24, 0x01	; 1
    484e:	69 f0       	breq	.+26     	; 0x486a <SCSI_DecodeSCSICommand+0x282>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
    4850:	e0 e1       	ldi	r30, 0x10	; 16
    4852:	f1 e0       	ldi	r31, 0x01	; 1
    4854:	80 81       	ld	r24, Z
    4856:	80 7f       	andi	r24, 0xF0	; 240
    4858:	82 60       	ori	r24, 0x02	; 2
    485a:	80 83       	st	Z, r24
    485c:	ee e0       	ldi	r30, 0x0E	; 14
    485e:	f1 e0       	ldi	r31, 0x01	; 1
    4860:	8a e3       	ldi	r24, 0x3A	; 58
    4862:	84 87       	std	Z+12, r24	; 0x0c
    4864:	15 86       	std	Z+13, r1	; 0x0d
				return false; //return with an error flag -- send a failure response to host.
    4866:	80 e0       	ldi	r24, 0x00	; 0
    4868:	58 c0       	rjmp	.+176    	; 0x491a <SCSI_DecodeSCSICommand+0x332>
			}
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
    486a:	61 e0       	ldi	r22, 0x01	; 1
    486c:	c8 01       	movw	r24, r16
    486e:	65 de       	rcall	.-822    	; 0x453a <SCSI_Command_ReadWrite_10>
			break;
    4870:	44 c0       	rjmp	.+136    	; 0x48fa <SCSI_DecodeSCSICommand+0x312>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4872:	e1 ef       	ldi	r30, 0xF1	; 241
    4874:	f0 e0       	ldi	r31, 0x00	; 0
    4876:	10 82       	st	Z, r1
    4878:	10 82       	st	Z, r1
    487a:	10 82       	st	Z, r1
    487c:	10 82       	st	Z, r1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    487e:	e8 ee       	ldi	r30, 0xE8	; 232
    4880:	f0 e0       	ldi	r31, 0x00	; 0
    4882:	80 81       	ld	r24, Z
    4884:	8e 77       	andi	r24, 0x7E	; 126
    4886:	80 83       	st	Z, r24
	Endpoint_Write_8(DISK_READ_ONLY ? 0x80 : 0x00);
	Endpoint_Write_8(0x00);
	Endpoint_ClearIN();

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 4;
    4888:	f8 01       	movw	r30, r16
    488a:	84 89       	ldd	r24, Z+20	; 0x14
    488c:	95 89       	ldd	r25, Z+21	; 0x15
    488e:	a6 89       	ldd	r26, Z+22	; 0x16
    4890:	b7 89       	ldd	r27, Z+23	; 0x17
    4892:	04 97       	sbiw	r24, 0x04	; 4
    4894:	a1 09       	sbc	r26, r1
    4896:	b1 09       	sbc	r27, r1
    4898:	84 8b       	std	Z+20, r24	; 0x14
    489a:	95 8b       	std	Z+21, r25	; 0x15
    489c:	a6 8b       	std	Z+22, r26	; 0x16
    489e:	b7 8b       	std	Z+23, r27	; 0x17
			}
				CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
			break;
		case SCSI_CMD_MODE_SENSE_6:
			CommandSuccess = SCSI_Command_ModeSense_6(MSInterfaceInfo);
			break;
    48a0:	2e c0       	rjmp	.+92     	; 0x48fe <SCSI_DecodeSCSICommand+0x316>
		case SCSI_CMD_START_STOP_UNIT:
		case SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
		case SCSI_CMD_VERIFY_10:
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
    48a2:	f8 01       	movw	r30, r16
    48a4:	14 8a       	std	Z+20, r1	; 0x14
    48a6:	15 8a       	std	Z+21, r1	; 0x15
    48a8:	16 8a       	std	Z+22, r1	; 0x16
    48aa:	17 8a       	std	Z+23, r1	; 0x17
			break;
    48ac:	28 c0       	rjmp	.+80     	; 0x48fe <SCSI_DecodeSCSICommand+0x316>
		case SCSI_CMD_TEST_UNIT_READY:
			if (!SDCardManager_CheckSDCardOperation() || (Typewriter_Mode != USB_COMBO_MODE)){ //if SD Card is missing or malfunctioned
    48ae:	8f d1       	rcall	.+798    	; 0x4bce <SDCardManager_CheckSDCardOperation>
    48b0:	88 23       	and	r24, r24
    48b2:	21 f0       	breq	.+8      	; 0x48bc <SCSI_DecodeSCSICommand+0x2d4>
    48b4:	80 91 28 08 	lds	r24, 0x0828
    48b8:	81 30       	cpi	r24, 0x01	; 1
    48ba:	69 f0       	breq	.+26     	; 0x48d6 <SCSI_DecodeSCSICommand+0x2ee>
				SCSI_SET_SENSE(	SCSI_SENSE_KEY_NOT_READY,SCSI_ASENSE_MEDIUM_NOT_PRESENT,SCSI_ASENSEQ_NO_QUALIFIER);//explain why unit is not ready.
    48bc:	e0 e1       	ldi	r30, 0x10	; 16
    48be:	f1 e0       	ldi	r31, 0x01	; 1
    48c0:	80 81       	ld	r24, Z
    48c2:	80 7f       	andi	r24, 0xF0	; 240
    48c4:	82 60       	ori	r24, 0x02	; 2
    48c6:	80 83       	st	Z, r24
    48c8:	ee e0       	ldi	r30, 0x0E	; 14
    48ca:	f1 e0       	ldi	r31, 0x01	; 1
    48cc:	8a e3       	ldi	r24, 0x3A	; 58
    48ce:	84 87       	std	Z+12, r24	; 0x0c
    48d0:	15 86       	std	Z+13, r1	; 0x0d
				return false; //return with an error flag -- send a failure response to host.
    48d2:	80 e0       	ldi	r24, 0x00	; 0
    48d4:	22 c0       	rjmp	.+68     	; 0x491a <SCSI_DecodeSCSICommand+0x332>
			}
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
    48d6:	f8 01       	movw	r30, r16
    48d8:	14 8a       	std	Z+20, r1	; 0x14
    48da:	15 8a       	std	Z+21, r1	; 0x15
    48dc:	16 8a       	std	Z+22, r1	; 0x16
    48de:	17 8a       	std	Z+23, r1	; 0x17
			break;
    48e0:	0e c0       	rjmp	.+28     	; 0x48fe <SCSI_DecodeSCSICommand+0x316>
		default:
			/* Update the SENSE key to reflect the invalid command */
			SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
    48e2:	e0 e1       	ldi	r30, 0x10	; 16
    48e4:	f1 e0       	ldi	r31, 0x01	; 1
    48e6:	80 81       	ld	r24, Z
    48e8:	80 7f       	andi	r24, 0xF0	; 240
    48ea:	85 60       	ori	r24, 0x05	; 5
    48ec:	80 83       	st	Z, r24
    48ee:	ee e0       	ldi	r30, 0x0E	; 14
    48f0:	f1 e0       	ldi	r31, 0x01	; 1
    48f2:	80 e2       	ldi	r24, 0x20	; 32
    48f4:	84 87       	std	Z+12, r24	; 0x0c
    48f6:	15 86       	std	Z+13, r1	; 0x0d
		                   SCSI_ASENSE_INVALID_COMMAND,
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
    48f8:	0f c0       	rjmp	.+30     	; 0x4918 <SCSI_DecodeSCSICommand+0x330>
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
    48fa:	88 23       	and	r24, r24
    48fc:	59 f0       	breq	.+22     	; 0x4914 <SCSI_DecodeSCSICommand+0x32c>
	{
		SCSI_SET_SENSE(SCSI_SENSE_KEY_GOOD,
    48fe:	e0 e1       	ldi	r30, 0x10	; 16
    4900:	f1 e0       	ldi	r31, 0x01	; 1
    4902:	80 81       	ld	r24, Z
    4904:	80 7f       	andi	r24, 0xF0	; 240
    4906:	80 83       	st	Z, r24
    4908:	ee e0       	ldi	r30, 0x0E	; 14
    490a:	f1 e0       	ldi	r31, 0x01	; 1
    490c:	14 86       	std	Z+12, r1	; 0x0c
    490e:	15 86       	std	Z+13, r1	; 0x0d
		               SCSI_ASENSE_NO_ADDITIONAL_INFORMATION,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return true;
    4910:	81 e0       	ldi	r24, 0x01	; 1
    4912:	03 c0       	rjmp	.+6      	; 0x491a <SCSI_DecodeSCSICommand+0x332>
	}

	return false;
    4914:	80 e0       	ldi	r24, 0x00	; 0
    4916:	01 c0       	rjmp	.+2      	; 0x491a <SCSI_DecodeSCSICommand+0x332>
    4918:	80 e0       	ldi	r24, 0x00	; 0
}
    491a:	28 96       	adiw	r28, 0x08	; 8
    491c:	0f b6       	in	r0, 0x3f	; 63
    491e:	f8 94       	cli
    4920:	de bf       	out	0x3e, r29	; 62
    4922:	0f be       	out	0x3f, r0	; 63
    4924:	cd bf       	out	0x3d, r28	; 61
    4926:	df 91       	pop	r29
    4928:	cf 91       	pop	r28
    492a:	1f 91       	pop	r17
    492c:	0f 91       	pop	r16
    492e:	ff 90       	pop	r15
    4930:	ef 90       	pop	r14
    4932:	df 90       	pop	r13
    4934:	cf 90       	pop	r12
    4936:	08 95       	ret

00004938 <SDCardManager_Init>:
static bool SDCard_Present= false;

void SDCardManager_Init(void)
{

	if(disk_initialize(0)==FR_OK){ //if the disk initializes correctly
    4938:	80 e0       	ldi	r24, 0x00	; 0
    493a:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <disk_initialize>
    493e:	81 11       	cpse	r24, r1
    4940:	04 c0       	rjmp	.+8      	; 0x494a <SDCardManager_Init+0x12>
		SDCard_Present = true;
    4942:	81 e0       	ldi	r24, 0x01	; 1
    4944:	80 93 28 06 	sts	0x0628, r24
    4948:	08 95       	ret
	}
	else{
		SDCard_Present = false; //tell other functions that the SD Card is missing/malfunctioned
    494a:	10 92 28 06 	sts	0x0628, r1
    494e:	08 95       	ret

00004950 <SDCardManager_WriteBlockHandler>:
	}
}


uintptr_t SDCardManager_WriteBlockHandler(uint8_t* buffer, uint16_t offset)
{
    4950:	0f 93       	push	r16
    4952:	1f 93       	push	r17
    4954:	cf 93       	push	r28
    4956:	df 93       	push	r29
    4958:	8c 01       	movw	r16, r24
    495a:	eb 01       	movw	r28, r22
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    495c:	90 91 e8 00 	lds	r25, 0x00E8

	/* Check if the endpoint is currently empty */
	if (!(Endpoint_IsReadWriteAllowed()))
    4960:	95 fd       	sbrc	r25, 5
    4962:	09 c0       	rjmp	.+18     	; 0x4976 <SDCardManager_WriteBlockHandler+0x26>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4964:	e8 ee       	ldi	r30, 0xE8	; 232
    4966:	f0 e0       	ldi	r31, 0x00	; 0
    4968:	80 81       	ld	r24, Z
    496a:	8b 77       	andi	r24, 0x7B	; 123
    496c:	80 83       	st	Z, r24
	{
		/* Clear the current endpoint bank */
		Endpoint_ClearOUT();
		
		/* Wait until the host has sent another packet */
		if (Endpoint_WaitUntilReady())
    496e:	0e 94 ef 35 	call	0x6bde	; 0x6bde <Endpoint_WaitUntilReady>
    4972:	81 11       	cpse	r24, r1
    4974:	28 c0       	rjmp	.+80     	; 0x49c6 <SDCardManager_WriteBlockHandler+0x76>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    4976:	a1 ef       	ldi	r26, 0xF1	; 241
    4978:	b0 e0       	ldi	r27, 0x00	; 0
    497a:	8c 91       	ld	r24, X
		  return 0;
	}
	
	/* Write one 16-byte chunk of data to the dataflash */
	buffer[0+offset] = Endpoint_Read_8();
    497c:	f8 01       	movw	r30, r16
    497e:	ec 0f       	add	r30, r28
    4980:	fd 1f       	adc	r31, r29
    4982:	80 83       	st	Z, r24
    4984:	8c 91       	ld	r24, X
	buffer[1+offset] = Endpoint_Read_8();
    4986:	81 83       	std	Z+1, r24	; 0x01
    4988:	8c 91       	ld	r24, X
	buffer[2+offset] = Endpoint_Read_8();
    498a:	82 83       	std	Z+2, r24	; 0x02
    498c:	8c 91       	ld	r24, X
	buffer[3+offset] = Endpoint_Read_8();
    498e:	83 83       	std	Z+3, r24	; 0x03
    4990:	8c 91       	ld	r24, X
	buffer[4+offset] = Endpoint_Read_8();
    4992:	84 83       	std	Z+4, r24	; 0x04
    4994:	8c 91       	ld	r24, X
	buffer[5+offset] = Endpoint_Read_8();
    4996:	85 83       	std	Z+5, r24	; 0x05
    4998:	8c 91       	ld	r24, X
	buffer[6+offset] = Endpoint_Read_8();
    499a:	86 83       	std	Z+6, r24	; 0x06
    499c:	8c 91       	ld	r24, X
	buffer[7+offset] = Endpoint_Read_8();
    499e:	87 83       	std	Z+7, r24	; 0x07
    49a0:	8c 91       	ld	r24, X
	buffer[8+offset] = Endpoint_Read_8();
    49a2:	80 87       	std	Z+8, r24	; 0x08
    49a4:	8c 91       	ld	r24, X
	buffer[9+offset] = Endpoint_Read_8();
    49a6:	81 87       	std	Z+9, r24	; 0x09
    49a8:	8c 91       	ld	r24, X
	buffer[10+offset] = Endpoint_Read_8();
    49aa:	82 87       	std	Z+10, r24	; 0x0a
    49ac:	8c 91       	ld	r24, X
	buffer[11+offset] = Endpoint_Read_8();
    49ae:	83 87       	std	Z+11, r24	; 0x0b
    49b0:	8c 91       	ld	r24, X
	buffer[12+offset] = Endpoint_Read_8();
    49b2:	84 87       	std	Z+12, r24	; 0x0c
    49b4:	8c 91       	ld	r24, X
	buffer[13+offset] = Endpoint_Read_8();
    49b6:	85 87       	std	Z+13, r24	; 0x0d
    49b8:	8c 91       	ld	r24, X
	buffer[14+offset] = Endpoint_Read_8();
    49ba:	86 87       	std	Z+14, r24	; 0x0e
    49bc:	8c 91       	ld	r24, X
	buffer[15+offset] = Endpoint_Read_8();
    49be:	87 87       	std	Z+15, r24	; 0x0f
	
	return 16;
    49c0:	80 e1       	ldi	r24, 0x10	; 16
    49c2:	90 e0       	ldi	r25, 0x00	; 0
    49c4:	02 c0       	rjmp	.+4      	; 0x49ca <SDCardManager_WriteBlockHandler+0x7a>
		/* Clear the current endpoint bank */
		Endpoint_ClearOUT();
		
		/* Wait until the host has sent another packet */
		if (Endpoint_WaitUntilReady())
		  return 0;
    49c6:	80 e0       	ldi	r24, 0x00	; 0
    49c8:	90 e0       	ldi	r25, 0x00	; 0
	buffer[13+offset] = Endpoint_Read_8();
	buffer[14+offset] = Endpoint_Read_8();
	buffer[15+offset] = Endpoint_Read_8();
	
	return 16;
}
    49ca:	df 91       	pop	r29
    49cc:	cf 91       	pop	r28
    49ce:	1f 91       	pop	r17
    49d0:	0f 91       	pop	r16
    49d2:	08 95       	ret

000049d4 <SDCardManager_WriteBlocks>:
 *
 *  \param[in] BlockAddress  Data block starting address for the write sequence
 *  \param[in] TotalBlocks   Number of blocks of data to write
 */
void SDCardManager_WriteBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo, uint32_t BlockAddress, uint16_t TotalBlocks)
{
    49d4:	6f 92       	push	r6
    49d6:	7f 92       	push	r7
    49d8:	8f 92       	push	r8
    49da:	9f 92       	push	r9
    49dc:	af 92       	push	r10
    49de:	bf 92       	push	r11
    49e0:	cf 92       	push	r12
    49e2:	df 92       	push	r13
    49e4:	ef 92       	push	r14
    49e6:	ff 92       	push	r15
    49e8:	0f 93       	push	r16
    49ea:	1f 93       	push	r17
    49ec:	cf 93       	push	r28
    49ee:	df 93       	push	r29
    49f0:	7c 01       	movw	r14, r24
    49f2:	4a 01       	movw	r8, r20
    49f4:	5b 01       	movw	r10, r22
    49f6:	69 01       	movw	r12, r18
	uint16_t  BytesWritten;

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
    49f8:	0e 94 ef 35 	call	0x6bde	; 0x6bde <Endpoint_WaitUntilReady>
    49fc:	81 11       	cpse	r24, r1
    49fe:	36 c0       	rjmp	.+108    	; 0x4a6c <SDCardManager_WriteBlocks+0x98>
	  return;
	
	while (TotalBlocks)
    4a00:	c1 14       	cp	r12, r1
    4a02:	d1 04       	cpc	r13, r1
    4a04:	49 f1       	breq	.+82     	; 0x4a58 <SDCardManager_WriteBlocks+0x84>
	{
		set_low(RED_LED); //red LED indicates busy status
		
		//Reset BytesWritten every time you finish writing a block, Dummy!
		BytesWritten = 0;
    4a06:	61 2c       	mov	r6, r1
    4a08:	71 2c       	mov	r7, r1
	if (Endpoint_WaitUntilReady())
	  return;
	
	while (TotalBlocks)
	{
		set_low(RED_LED); //red LED indicates busy status
    4a0a:	2e 98       	cbi	0x05, 6	; 5
		
		//Reset BytesWritten every time you finish writing a block, Dummy!
		BytesWritten = 0;
    4a0c:	c6 2d       	mov	r28, r6
    4a0e:	d7 2d       	mov	r29, r7
		
		while((BytesWritten<512)){
			BytesWritten += SDCardManager_WriteBlockHandler((uint8_t*)SD_Buffer, BytesWritten);
    4a10:	be 01       	movw	r22, r28
    4a12:	89 e2       	ldi	r24, 0x29	; 41
    4a14:	98 e0       	ldi	r25, 0x08	; 8
    4a16:	9c df       	rcall	.-200    	; 0x4950 <SDCardManager_WriteBlockHandler>
    4a18:	c8 0f       	add	r28, r24
    4a1a:	d9 1f       	adc	r29, r25
			if (USB_DeviceState != DEVICE_STATE_Configured){return;}//if the device is not configured, exit out of this
    4a1c:	90 91 6d 0a 	lds	r25, 0x0A6D
    4a20:	94 30       	cpi	r25, 0x04	; 4
    4a22:	21 f5       	brne	.+72     	; 0x4a6c <SDCardManager_WriteBlocks+0x98>
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
    4a24:	f7 01       	movw	r30, r14
    4a26:	90 ad       	ldd	r25, Z+56	; 0x38
    4a28:	91 11       	cpse	r25, r1
    4a2a:	20 c0       	rjmp	.+64     	; 0x4a6c <SDCardManager_WriteBlocks+0x98>
		set_low(RED_LED); //red LED indicates busy status
		
		//Reset BytesWritten every time you finish writing a block, Dummy!
		BytesWritten = 0;
		
		while((BytesWritten<512)){
    4a2c:	c1 15       	cp	r28, r1
    4a2e:	f2 e0       	ldi	r31, 0x02	; 2
    4a30:	df 07       	cpc	r29, r31
    4a32:	70 f3       	brcs	.-36     	; 0x4a10 <SDCardManager_WriteBlocks+0x3c>
			BytesWritten += SDCardManager_WriteBlockHandler((uint8_t*)SD_Buffer, BytesWritten);
			if (USB_DeviceState != DEVICE_STATE_Configured){return;}//if the device is not configured, exit out of this
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
		}
		
		disk_write (0, (uint8_t*)SD_Buffer, BlockAddress, 1);//write to disk 0, from Buffer array, into BlockAddress, Write only 1 sector (block);
    4a34:	01 e0       	ldi	r16, 0x01	; 1
    4a36:	10 e0       	ldi	r17, 0x00	; 0
    4a38:	a5 01       	movw	r20, r10
    4a3a:	94 01       	movw	r18, r8
    4a3c:	69 e2       	ldi	r22, 0x29	; 41
    4a3e:	78 e0       	ldi	r23, 0x08	; 8
    4a40:	80 e0       	ldi	r24, 0x00	; 0
    4a42:	0e 94 99 0f 	call	0x1f32	; 0x1f32 <disk_write>
	
		/* Decrement the blocks remaining counter and reset the sub block counter */
		BlockAddress++;
    4a46:	8f ef       	ldi	r24, 0xFF	; 255
    4a48:	88 1a       	sub	r8, r24
    4a4a:	98 0a       	sbc	r9, r24
    4a4c:	a8 0a       	sbc	r10, r24
    4a4e:	b8 0a       	sbc	r11, r24
		TotalBlocks--;			
    4a50:	e1 e0       	ldi	r30, 0x01	; 1
    4a52:	ce 1a       	sub	r12, r30
    4a54:	d1 08       	sbc	r13, r1

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;
	
	while (TotalBlocks)
    4a56:	c9 f6       	brne	.-78     	; 0x4a0a <SDCardManager_WriteBlocks+0x36>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4a58:	80 91 e8 00 	lds	r24, 0x00E8
		TotalBlocks--;			
		
	}

	/* If the endpoint is empty, clear it ready for the next packet from the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    4a5c:	85 fd       	sbrc	r24, 5
    4a5e:	05 c0       	rjmp	.+10     	; 0x4a6a <SDCardManager_WriteBlocks+0x96>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4a60:	e8 ee       	ldi	r30, 0xE8	; 232
    4a62:	f0 e0       	ldi	r31, 0x00	; 0
    4a64:	80 81       	ld	r24, Z
    4a66:	8b 77       	andi	r24, 0x7B	; 123
    4a68:	80 83       	st	Z, r24
	  Endpoint_ClearOUT();
	  
	  set_high(RED_LED);
    4a6a:	2e 9a       	sbi	0x05, 6	; 5
}
    4a6c:	df 91       	pop	r29
    4a6e:	cf 91       	pop	r28
    4a70:	1f 91       	pop	r17
    4a72:	0f 91       	pop	r16
    4a74:	ff 90       	pop	r15
    4a76:	ef 90       	pop	r14
    4a78:	df 90       	pop	r13
    4a7a:	cf 90       	pop	r12
    4a7c:	bf 90       	pop	r11
    4a7e:	af 90       	pop	r10
    4a80:	9f 90       	pop	r9
    4a82:	8f 90       	pop	r8
    4a84:	7f 90       	pop	r7
    4a86:	6f 90       	pop	r6
    4a88:	08 95       	ret

00004a8a <SDCardManager_ReadBlockHandler>:
 *  \param[in] BlockAddress  Data block starting address for the read sequence
 *  \param[in] TotalBlocks   Number of blocks of data to read
 *  \output -- number of bytes forwarded successfully.  Return 16 if they are forwarded successfully, 0 if host rejects them.
 */
uint8_t SDCardManager_ReadBlockHandler(uint8_t* buffer, uint16_t offset)
{
    4a8a:	ef 92       	push	r14
    4a8c:	ff 92       	push	r15
    4a8e:	0f 93       	push	r16
    4a90:	1f 93       	push	r17
    4a92:	cf 93       	push	r28
    4a94:	7c 01       	movw	r14, r24
    4a96:	8b 01       	movw	r16, r22
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4a98:	90 91 e8 00 	lds	r25, 0x00E8

	/* Check if the endpoint is currently full */
	if (!(Endpoint_IsReadWriteAllowed()))
    4a9c:	c9 2f       	mov	r28, r25
    4a9e:	c0 72       	andi	r28, 0x20	; 32
    4aa0:	95 fd       	sbrc	r25, 5
    4aa2:	09 c0       	rjmp	.+18     	; 0x4ab6 <SDCardManager_ReadBlockHandler+0x2c>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4aa4:	e8 ee       	ldi	r30, 0xE8	; 232
    4aa6:	f0 e0       	ldi	r31, 0x00	; 0
    4aa8:	80 81       	ld	r24, Z
    4aaa:	8e 77       	andi	r24, 0x7E	; 126
    4aac:	80 83       	st	Z, r24
	{
		/* Clear the endpoint bank to send its contents to the host */
		Endpoint_ClearIN();
		
		/* Wait until the endpoint is ready for more data */
		if (Endpoint_WaitUntilReady())
    4aae:	0e 94 ef 35 	call	0x6bde	; 0x6bde <Endpoint_WaitUntilReady>
    4ab2:	81 11       	cpse	r24, r1
    4ab4:	26 c0       	rjmp	.+76     	; 0x4b02 <SDCardManager_ReadBlockHandler+0x78>
		return 0;
	}
	
	Endpoint_Write_8(buffer[0+offset]);
    4ab6:	f7 01       	movw	r30, r14
    4ab8:	e0 0f       	add	r30, r16
    4aba:	f1 1f       	adc	r31, r17
    4abc:	80 81       	ld	r24, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4abe:	a1 ef       	ldi	r26, 0xF1	; 241
    4ac0:	b0 e0       	ldi	r27, 0x00	; 0
    4ac2:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[1+offset]);
    4ac4:	81 81       	ldd	r24, Z+1	; 0x01
    4ac6:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[2+offset]);
    4ac8:	82 81       	ldd	r24, Z+2	; 0x02
    4aca:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[3+offset]);
    4acc:	83 81       	ldd	r24, Z+3	; 0x03
    4ace:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[4+offset]);
    4ad0:	84 81       	ldd	r24, Z+4	; 0x04
    4ad2:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[5+offset]);
    4ad4:	85 81       	ldd	r24, Z+5	; 0x05
    4ad6:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[6+offset]);
    4ad8:	86 81       	ldd	r24, Z+6	; 0x06
    4ada:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[7+offset]);
    4adc:	87 81       	ldd	r24, Z+7	; 0x07
    4ade:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[8+offset]);
    4ae0:	80 85       	ldd	r24, Z+8	; 0x08
    4ae2:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[9+offset]);
    4ae4:	81 85       	ldd	r24, Z+9	; 0x09
    4ae6:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[10+offset]);
    4ae8:	82 85       	ldd	r24, Z+10	; 0x0a
    4aea:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[11+offset]);
    4aec:	83 85       	ldd	r24, Z+11	; 0x0b
    4aee:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[12+offset]);
    4af0:	84 85       	ldd	r24, Z+12	; 0x0c
    4af2:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[13+offset]);
    4af4:	85 85       	ldd	r24, Z+13	; 0x0d
    4af6:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[14+offset]);
    4af8:	86 85       	ldd	r24, Z+14	; 0x0e
    4afa:	8c 93       	st	X, r24
	Endpoint_Write_8(buffer[15+offset]);
    4afc:	87 85       	ldd	r24, Z+15	; 0x0f
    4afe:	8c 93       	st	X, r24
	
	return 16;
    4b00:	c0 e1       	ldi	r28, 0x10	; 16
}
    4b02:	8c 2f       	mov	r24, r28
    4b04:	cf 91       	pop	r28
    4b06:	1f 91       	pop	r17
    4b08:	0f 91       	pop	r16
    4b0a:	ff 90       	pop	r15
    4b0c:	ef 90       	pop	r14
    4b0e:	08 95       	ret

00004b10 <SDCardManager_ReadBlocks>:
 *
 *  \param[in] BlockAddress  Data block starting address for the read sequence
 *  \param[in] TotalBlocks   Number of blocks of data to read
 */
void SDCardManager_ReadBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo, uint32_t BlockAddress, uint16_t TotalBlocks)
{
    4b10:	6f 92       	push	r6
    4b12:	7f 92       	push	r7
    4b14:	8f 92       	push	r8
    4b16:	9f 92       	push	r9
    4b18:	af 92       	push	r10
    4b1a:	bf 92       	push	r11
    4b1c:	cf 92       	push	r12
    4b1e:	df 92       	push	r13
    4b20:	ef 92       	push	r14
    4b22:	ff 92       	push	r15
    4b24:	0f 93       	push	r16
    4b26:	1f 93       	push	r17
    4b28:	cf 93       	push	r28
    4b2a:	df 93       	push	r29
    4b2c:	7c 01       	movw	r14, r24
    4b2e:	4a 01       	movw	r8, r20
    4b30:	5b 01       	movw	r10, r22
    4b32:	69 01       	movw	r12, r18
	uint16_t BytesRead;
	
	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
    4b34:	0e 94 ef 35 	call	0x6bde	; 0x6bde <Endpoint_WaitUntilReady>
    4b38:	81 11       	cpse	r24, r1
    4b3a:	3a c0       	rjmp	.+116    	; 0x4bb0 <SDCardManager_ReadBlocks+0xa0>
	  return;
	
	while (TotalBlocks)
    4b3c:	c1 14       	cp	r12, r1
    4b3e:	d1 04       	cpc	r13, r1
    4b40:	69 f1       	breq	.+90     	; 0x4b9c <SDCardManager_ReadBlocks+0x8c>
	{		
		set_low(RED_LED); //red LED indicates busy status
		//Reset tally of BytesRead every time a new block is accessed.  
		BytesRead = 0;
    4b42:	61 2c       	mov	r6, r1
    4b44:	71 2c       	mov	r7, r1
	if (Endpoint_WaitUntilReady())
	  return;
	
	while (TotalBlocks)
	{		
		set_low(RED_LED); //red LED indicates busy status
    4b46:	2e 98       	cbi	0x05, 6	; 5
		//Reset tally of BytesRead every time a new block is accessed.  
		BytesRead = 0;
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)
    4b48:	01 e0       	ldi	r16, 0x01	; 1
    4b4a:	10 e0       	ldi	r17, 0x00	; 0
    4b4c:	a5 01       	movw	r20, r10
    4b4e:	94 01       	movw	r18, r8
    4b50:	69 e2       	ldi	r22, 0x29	; 41
    4b52:	78 e0       	ldi	r23, 0x08	; 8
    4b54:	80 e0       	ldi	r24, 0x00	; 0
    4b56:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <disk_read>
	
	while (TotalBlocks)
	{		
		set_low(RED_LED); //red LED indicates busy status
		//Reset tally of BytesRead every time a new block is accessed.  
		BytesRead = 0;
    4b5a:	c6 2d       	mov	r28, r6
    4b5c:	d7 2d       	mov	r29, r7
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)

		while(BytesRead<512){  //send the results to the usb endpoint buffer, 16 bytes at a time.
			BytesRead += SDCardManager_ReadBlockHandler((uint8_t*)SD_Buffer, BytesRead); // BytesRead increases 16 every time handler is called, if all goes well.
    4b5e:	be 01       	movw	r22, r28
    4b60:	89 e2       	ldi	r24, 0x29	; 41
    4b62:	98 e0       	ldi	r25, 0x08	; 8
    4b64:	92 df       	rcall	.-220    	; 0x4a8a <SDCardManager_ReadBlockHandler>
    4b66:	c8 0f       	add	r28, r24
    4b68:	d1 1d       	adc	r29, r1
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
    4b6a:	f7 01       	movw	r30, r14
    4b6c:	90 ad       	ldd	r25, Z+56	; 0x38
    4b6e:	91 11       	cpse	r25, r1
    4b70:	1f c0       	rjmp	.+62     	; 0x4bb0 <SDCardManager_ReadBlocks+0xa0>
			if (USB_DeviceState != DEVICE_STATE_Configured){Typewriter_Mode = PANIC_MODE; return;}
    4b72:	90 91 6d 0a 	lds	r25, 0x0A6D
    4b76:	94 30       	cpi	r25, 0x04	; 4
    4b78:	21 f0       	breq	.+8      	; 0x4b82 <SDCardManager_ReadBlocks+0x72>
    4b7a:	8a e0       	ldi	r24, 0x0A	; 10
    4b7c:	80 93 28 08 	sts	0x0828, r24
    4b80:	17 c0       	rjmp	.+46     	; 0x4bb0 <SDCardManager_ReadBlocks+0xa0>
		BytesRead = 0;
		
		/* Read a data block from the SD card */		
		disk_read (0, (uint8_t *) SD_Buffer, BlockAddress, 1);//  read disk 0,  into Buffer,  starting at block address,  read only 1 sector (block=sector)

		while(BytesRead<512){  //send the results to the usb endpoint buffer, 16 bytes at a time.
    4b82:	c1 15       	cp	r28, r1
    4b84:	f2 e0       	ldi	r31, 0x02	; 2
    4b86:	df 07       	cpc	r29, r31
    4b88:	50 f3       	brcs	.-44     	; 0x4b5e <SDCardManager_ReadBlocks+0x4e>
			BytesRead += SDCardManager_ReadBlockHandler((uint8_t*)SD_Buffer, BytesRead); // BytesRead increases 16 every time handler is called, if all goes well.
			if (MSInterfaceInfo->State.IsMassStoreReset){return;}
			if (USB_DeviceState != DEVICE_STATE_Configured){Typewriter_Mode = PANIC_MODE; return;}
		}
		/* Decrement the blocks remaining counter */
		BlockAddress++;
    4b8a:	8f ef       	ldi	r24, 0xFF	; 255
    4b8c:	88 1a       	sub	r8, r24
    4b8e:	98 0a       	sbc	r9, r24
    4b90:	a8 0a       	sbc	r10, r24
    4b92:	b8 0a       	sbc	r11, r24
		TotalBlocks--;
    4b94:	e1 e0       	ldi	r30, 0x01	; 1
    4b96:	ce 1a       	sub	r12, r30
    4b98:	d1 08       	sbc	r13, r1
	
	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;
	
	while (TotalBlocks)
    4b9a:	a9 f6       	brne	.-86     	; 0x4b46 <SDCardManager_ReadBlocks+0x36>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4b9c:	80 91 e8 00 	lds	r24, 0x00E8
		BlockAddress++;
		TotalBlocks--;
	}
	
	/* If the endpoint is full, send its contents to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
    4ba0:	85 fd       	sbrc	r24, 5
    4ba2:	05 c0       	rjmp	.+10     	; 0x4bae <SDCardManager_ReadBlocks+0x9e>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4ba4:	e8 ee       	ldi	r30, 0xE8	; 232
    4ba6:	f0 e0       	ldi	r31, 0x00	; 0
    4ba8:	80 81       	ld	r24, Z
    4baa:	8e 77       	andi	r24, 0x7E	; 126
    4bac:	80 83       	st	Z, r24
	  Endpoint_ClearIN();
	 
	 set_high(RED_LED);
    4bae:	2e 9a       	sbi	0x05, 6	; 5
}
    4bb0:	df 91       	pop	r29
    4bb2:	cf 91       	pop	r28
    4bb4:	1f 91       	pop	r17
    4bb6:	0f 91       	pop	r16
    4bb8:	ff 90       	pop	r15
    4bba:	ef 90       	pop	r14
    4bbc:	df 90       	pop	r13
    4bbe:	cf 90       	pop	r12
    4bc0:	bf 90       	pop	r11
    4bc2:	af 90       	pop	r10
    4bc4:	9f 90       	pop	r9
    4bc6:	8f 90       	pop	r8
    4bc8:	7f 90       	pop	r7
    4bca:	6f 90       	pop	r6
    4bcc:	08 95       	ret

00004bce <SDCardManager_CheckSDCardOperation>:
 *  \return Boolean true if all media chips are working, false otherwise
 */
bool SDCardManager_CheckSDCardOperation(void)
{	
	return SDCard_Present; //return whether or not sd card is present and working.
}
    4bce:	80 91 28 06 	lds	r24, 0x0628
    4bd2:	08 95       	ret

00004bd4 <__vector_25>:
ISR (UART0_RECEIVE_INTERRUPT)	
/*************************************************************************
Function: UART Receive Complete interrupt
Purpose:  called when the UART has received a character
**************************************************************************/
{
    4bd4:	1f 92       	push	r1
    4bd6:	0f 92       	push	r0
    4bd8:	0f b6       	in	r0, 0x3f	; 63
    4bda:	0f 92       	push	r0
    4bdc:	11 24       	eor	r1, r1
    4bde:	2f 93       	push	r18
    4be0:	8f 93       	push	r24
    4be2:	9f 93       	push	r25
    4be4:	ef 93       	push	r30
    4be6:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART0_STATUS;
    4be8:	80 91 c8 00 	lds	r24, 0x00C8
    data = UART0_DATA;
    4bec:	20 91 ce 00 	lds	r18, 0x00CE
    
    /* */
#if defined( AT90_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
    4bf0:	88 71       	andi	r24, 0x18	; 24
#elif defined( AT90USB_USART )
    lastRxError = (usr & (_BV(FE1)|_BV(DOR1)) );
#endif
        
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    4bf2:	e0 91 2b 06 	lds	r30, 0x062B
    4bf6:	ef 5f       	subi	r30, 0xFF	; 255
    4bf8:	ef 73       	andi	r30, 0x3F	; 63
    
    if ( tmphead == UART_RxTail ) {
    4bfa:	90 91 2a 06 	lds	r25, 0x062A
    4bfe:	e9 17       	cp	r30, r25
    4c00:	39 f0       	breq	.+14     	; 0x4c10 <__vector_25+0x3c>
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART_RxHead = tmphead;
    4c02:	e0 93 2b 06 	sts	0x062B, r30
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    4c06:	f0 e0       	ldi	r31, 0x00	; 0
    4c08:	e2 5d       	subi	r30, 0xD2	; 210
    4c0a:	f9 4f       	sbci	r31, 0xF9	; 249
    4c0c:	20 83       	st	Z, r18
    4c0e:	01 c0       	rjmp	.+2      	; 0x4c12 <__vector_25+0x3e>
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    
    if ( tmphead == UART_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    4c10:	82 e0       	ldi	r24, 0x02	; 2
        /* store new index */
        UART_RxHead = tmphead;
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    }
    UART_LastRxError |= lastRxError;   
    4c12:	90 91 29 06 	lds	r25, 0x0629
    4c16:	89 2b       	or	r24, r25
    4c18:	80 93 29 06 	sts	0x0629, r24
}
    4c1c:	ff 91       	pop	r31
    4c1e:	ef 91       	pop	r30
    4c20:	9f 91       	pop	r25
    4c22:	8f 91       	pop	r24
    4c24:	2f 91       	pop	r18
    4c26:	0f 90       	pop	r0
    4c28:	0f be       	out	0x3f, r0	; 63
    4c2a:	0f 90       	pop	r0
    4c2c:	1f 90       	pop	r1
    4c2e:	18 95       	reti

00004c30 <__vector_26>:
ISR (UART0_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/
{
    4c30:	1f 92       	push	r1
    4c32:	0f 92       	push	r0
    4c34:	0f b6       	in	r0, 0x3f	; 63
    4c36:	0f 92       	push	r0
    4c38:	11 24       	eor	r1, r1
    4c3a:	8f 93       	push	r24
    4c3c:	9f 93       	push	r25
    4c3e:	ef 93       	push	r30
    4c40:	ff 93       	push	r31
    unsigned char tmptail;
    
    if ( UART_TxHead != UART_TxTail) {
    4c42:	90 91 2d 06 	lds	r25, 0x062D
    4c46:	80 91 2c 06 	lds	r24, 0x062C
    4c4a:	98 17       	cp	r25, r24
    4c4c:	69 f0       	breq	.+26     	; 0x4c68 <__vector_26+0x38>
        /* calculate and store new buffer index */
        tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
    4c4e:	e0 91 2c 06 	lds	r30, 0x062C
    4c52:	ef 5f       	subi	r30, 0xFF	; 255
    4c54:	ef 70       	andi	r30, 0x0F	; 15
        UART_TxTail = tmptail;
    4c56:	e0 93 2c 06 	sts	0x062C, r30
        /* get one byte from buffer and write it to UART */
        UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
    4c5a:	f0 e0       	ldi	r31, 0x00	; 0
    4c5c:	e2 59       	subi	r30, 0x92	; 146
    4c5e:	f9 4f       	sbci	r31, 0xF9	; 249
    4c60:	80 81       	ld	r24, Z
    4c62:	80 93 ce 00 	sts	0x00CE, r24
    4c66:	05 c0       	rjmp	.+10     	; 0x4c72 <__vector_26+0x42>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART0_CONTROL &= ~_BV(UART0_UDRIE);
    4c68:	e9 ec       	ldi	r30, 0xC9	; 201
    4c6a:	f0 e0       	ldi	r31, 0x00	; 0
    4c6c:	80 81       	ld	r24, Z
    4c6e:	8f 7d       	andi	r24, 0xDF	; 223
    4c70:	80 83       	st	Z, r24
    }
}
    4c72:	ff 91       	pop	r31
    4c74:	ef 91       	pop	r30
    4c76:	9f 91       	pop	r25
    4c78:	8f 91       	pop	r24
    4c7a:	0f 90       	pop	r0
    4c7c:	0f be       	out	0x3f, r0	; 63
    4c7e:	0f 90       	pop	r0
    4c80:	1f 90       	pop	r1
    4c82:	18 95       	reti

00004c84 <uart_init>:
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart_init(unsigned int baudrate)
{
    UART_TxHead = 0;
    4c84:	10 92 2d 06 	sts	0x062D, r1
    UART_TxTail = 0;
    4c88:	10 92 2c 06 	sts	0x062C, r1
    UART_RxHead = 0;
    4c8c:	10 92 2b 06 	sts	0x062B, r1
    UART_RxTail = 0;
    4c90:	10 92 2a 06 	sts	0x062A, r1
    /* enable UART receiver and transmmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);

#elif defined (ATMEGA_USART)
    /* Set baud rate */
    if ( baudrate & 0x8000 )
    4c94:	99 23       	and	r25, r25
    4c96:	24 f4       	brge	.+8      	; 0x4ca0 <uart_init+0x1c>
    {
    	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
    4c98:	22 e0       	ldi	r18, 0x02	; 2
    4c9a:	20 93 c8 00 	sts	0x00C8, r18
    	 baudrate &= ~0x8000;
    4c9e:	9f 77       	andi	r25, 0x7F	; 127
    }
    UBRRH = (unsigned char)(baudrate>>8);
    4ca0:	90 93 cd 00 	sts	0x00CD, r25
    UBRRL = (unsigned char) baudrate;
    4ca4:	80 93 cc 00 	sts	0x00CC, r24
   
    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
    4ca8:	88 e9       	ldi	r24, 0x98	; 152
    4caa:	80 93 c9 00 	sts	0x00C9, r24
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
    #ifdef URSEL
    UCSRC = (1<<URSEL)|(3<<UCSZ0);
    #else
    UCSRC = (3<<UCSZ0);
    4cae:	86 e0       	ldi	r24, 0x06	; 6
    4cb0:	80 93 ca 00 	sts	0x00CA, r24
    4cb4:	08 95       	ret

00004cb6 <uart_getc>:
{    
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
    4cb6:	90 91 2b 06 	lds	r25, 0x062B
    4cba:	80 91 2a 06 	lds	r24, 0x062A
    4cbe:	98 17       	cp	r25, r24
    4cc0:	81 f0       	breq	.+32     	; 0x4ce2 <uart_getc+0x2c>
        return UART_NO_DATA;   /* no data available */
    }
    
    /* calculate /store buffer index */
    tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
    4cc2:	e0 91 2a 06 	lds	r30, 0x062A
    4cc6:	ef 5f       	subi	r30, 0xFF	; 255
    4cc8:	ef 73       	andi	r30, 0x3F	; 63
    UART_RxTail = tmptail; 
    4cca:	e0 93 2a 06 	sts	0x062A, r30
    
    /* get data from receive buffer */
    data = UART_RxBuf[tmptail];
    4cce:	f0 e0       	ldi	r31, 0x00	; 0
    4cd0:	e2 5d       	subi	r30, 0xD2	; 210
    4cd2:	f9 4f       	sbci	r31, 0xF9	; 249
    4cd4:	80 81       	ld	r24, Z
    
    data = (UART_LastRxError << 8) + data;
    4cd6:	90 91 29 06 	lds	r25, 0x0629
    UART_LastRxError = 0;
    4cda:	10 92 29 06 	sts	0x0629, r1
    return data;
    4cde:	90 e0       	ldi	r25, 0x00	; 0
    4ce0:	08 95       	ret
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
        return UART_NO_DATA;   /* no data available */
    4ce2:	80 e0       	ldi	r24, 0x00	; 0
    4ce4:	91 e0       	ldi	r25, 0x01	; 1
    
    data = (UART_LastRxError << 8) + data;
    UART_LastRxError = 0;
    return data;

}/* uart_getc */
    4ce6:	08 95       	ret

00004ce8 <uart_clear_rx_buffer>:

void uart_clear_rx_buffer(){
//the head and tail define the buffer index of the first and last byte of the received data.  
//If they are equal to each other, no data has been received (buffer empty)
	UART_RxHead = 0;
    4ce8:	10 92 2b 06 	sts	0x062B, r1
	UART_RxTail = 0; 
    4cec:	10 92 2a 06 	sts	0x062A, r1
    4cf0:	08 95       	ret

00004cf2 <uart_putc>:
**************************************************************************/
void uart_putc(unsigned char data)
{
    unsigned char tmphead;
    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
    4cf2:	20 91 2d 06 	lds	r18, 0x062D
    4cf6:	2f 5f       	subi	r18, 0xFF	; 255
    4cf8:	2f 70       	andi	r18, 0x0F	; 15
    
    while ( tmphead == UART_TxTail ){
    4cfa:	90 91 2c 06 	lds	r25, 0x062C
    4cfe:	29 17       	cp	r18, r25
    4d00:	e1 f3       	breq	.-8      	; 0x4cfa <uart_putc+0x8>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
    4d02:	e2 2f       	mov	r30, r18
    4d04:	f0 e0       	ldi	r31, 0x00	; 0
    4d06:	e2 59       	subi	r30, 0x92	; 146
    4d08:	f9 4f       	sbci	r31, 0xF9	; 249
    4d0a:	80 83       	st	Z, r24
    UART_TxHead = tmphead;
    4d0c:	20 93 2d 06 	sts	0x062D, r18

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
    4d10:	e9 ec       	ldi	r30, 0xC9	; 201
    4d12:	f0 e0       	ldi	r31, 0x00	; 0
    4d14:	80 81       	ld	r24, Z
    4d16:	80 62       	ori	r24, 0x20	; 32
    4d18:	80 83       	st	Z, r24
    4d1a:	08 95       	ret

00004d1c <__vector_17>:
		return false;
	}
	else{
		return true;
	}
}
    4d1c:	1f 92       	push	r1
    4d1e:	0f 92       	push	r0
    4d20:	0f b6       	in	r0, 0x3f	; 63
    4d22:	0f 92       	push	r0
    4d24:	11 24       	eor	r1, r1
    4d26:	2f 93       	push	r18
    4d28:	3f 93       	push	r19
    4d2a:	4f 93       	push	r20
    4d2c:	5f 93       	push	r21
    4d2e:	6f 93       	push	r22
    4d30:	7f 93       	push	r23
    4d32:	8f 93       	push	r24
    4d34:	9f 93       	push	r25
    4d36:	af 93       	push	r26
    4d38:	bf 93       	push	r27
    4d3a:	ef 93       	push	r30
    4d3c:	ff 93       	push	r31
    4d3e:	80 91 1f 07 	lds	r24, 0x071F
    4d42:	90 91 20 07 	lds	r25, 0x0720
    4d46:	01 96       	adiw	r24, 0x01	; 1
    4d48:	90 93 20 07 	sts	0x0720, r25
    4d4c:	80 93 1f 07 	sts	0x071F, r24
    4d50:	80 91 26 08 	lds	r24, 0x0826
    4d54:	90 91 27 08 	lds	r25, 0x0827
    4d58:	01 96       	adiw	r24, 0x01	; 1
    4d5a:	90 93 27 08 	sts	0x0827, r25
    4d5e:	80 93 26 08 	sts	0x0826, r24
    4d62:	80 91 28 08 	lds	r24, 0x0828
    4d66:	81 30       	cpi	r24, 0x01	; 1
    4d68:	79 f0       	breq	.+30     	; 0x4d88 <__vector_17+0x6c>
    4d6a:	80 91 28 08 	lds	r24, 0x0828
    4d6e:	8d 30       	cpi	r24, 0x0D	; 13
    4d70:	59 f0       	breq	.+22     	; 0x4d88 <__vector_17+0x6c>
    4d72:	80 e3       	ldi	r24, 0x30	; 48
    4d74:	91 e0       	ldi	r25, 0x01	; 1
    4d76:	0e 94 d9 30 	call	0x61b2	; 0x61b2 <MS_Device_USBTask>
    4d7a:	80 e2       	ldi	r24, 0x20	; 32
    4d7c:	91 e0       	ldi	r25, 0x01	; 1
    4d7e:	0e 94 c1 2f 	call	0x5f82	; 0x5f82 <HID_Device_USBTask>
    4d82:	0e 94 da 38 	call	0x71b4	; 0x71b4 <USB_USBTask>
    4d86:	03 c0       	rjmp	.+6      	; 0x4d8e <__vector_17+0x72>
    4d88:	81 e0       	ldi	r24, 0x01	; 1
    4d8a:	80 93 d8 06 	sts	0x06D8, r24
    4d8e:	ff 91       	pop	r31
    4d90:	ef 91       	pop	r30
    4d92:	bf 91       	pop	r27
    4d94:	af 91       	pop	r26
    4d96:	9f 91       	pop	r25
    4d98:	8f 91       	pop	r24
    4d9a:	7f 91       	pop	r23
    4d9c:	6f 91       	pop	r22
    4d9e:	5f 91       	pop	r21
    4da0:	4f 91       	pop	r20
    4da2:	3f 91       	pop	r19
    4da4:	2f 91       	pop	r18
    4da6:	0f 90       	pop	r0
    4da8:	0f be       	out	0x3f, r0	; 63
    4daa:	0f 90       	pop	r0
    4dac:	1f 90       	pop	r1
    4dae:	18 95       	reti

00004db0 <Task_Manager>:
    4db0:	80 91 d8 06 	lds	r24, 0x06D8
    4db4:	81 30       	cpi	r24, 0x01	; 1
    4db6:	59 f4       	brne	.+22     	; 0x4dce <Task_Manager+0x1e>
    4db8:	80 e3       	ldi	r24, 0x30	; 48
    4dba:	91 e0       	ldi	r25, 0x01	; 1
    4dbc:	0e 94 d9 30 	call	0x61b2	; 0x61b2 <MS_Device_USBTask>
    4dc0:	80 e2       	ldi	r24, 0x20	; 32
    4dc2:	91 e0       	ldi	r25, 0x01	; 1
    4dc4:	0e 94 c1 2f 	call	0x5f82	; 0x5f82 <HID_Device_USBTask>
    4dc8:	0e 94 da 38 	call	0x71b4	; 0x71b4 <USB_USBTask>
    4dcc:	15 c0       	rjmp	.+42     	; 0x4df8 <Task_Manager+0x48>
    4dce:	80 91 d8 06 	lds	r24, 0x06D8
    4dd2:	83 30       	cpi	r24, 0x03	; 3
    4dd4:	39 f4       	brne	.+14     	; 0x4de4 <Task_Manager+0x34>
    4dd6:	80 e2       	ldi	r24, 0x20	; 32
    4dd8:	91 e0       	ldi	r25, 0x01	; 1
    4dda:	0e 94 c1 2f 	call	0x5f82	; 0x5f82 <HID_Device_USBTask>
    4dde:	0e 94 da 38 	call	0x71b4	; 0x71b4 <USB_USBTask>
    4de2:	0a c0       	rjmp	.+20     	; 0x4df8 <Task_Manager+0x48>
    4de4:	80 91 d8 06 	lds	r24, 0x06D8
    4de8:	82 30       	cpi	r24, 0x02	; 2
    4dea:	31 f4       	brne	.+12     	; 0x4df8 <Task_Manager+0x48>
    4dec:	80 e3       	ldi	r24, 0x30	; 48
    4dee:	91 e0       	ldi	r25, 0x01	; 1
    4df0:	0e 94 d9 30 	call	0x61b2	; 0x61b2 <MS_Device_USBTask>
    4df4:	0e 94 da 38 	call	0x71b4	; 0x71b4 <USB_USBTask>
    4df8:	10 92 d8 06 	sts	0x06D8, r1
    4dfc:	08 95       	ret

00004dfe <SetupHardware>:
/** Configures the board hardware and chip peripherals for functionality. */
void SetupHardware()
{

	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
    4dfe:	84 b7       	in	r24, 0x34	; 52
    4e00:	87 7f       	andi	r24, 0xF7	; 247
    4e02:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    4e04:	0f b6       	in	r0, 0x3f	; 63
    4e06:	f8 94       	cli
    4e08:	a8 95       	wdr
    4e0a:	80 91 60 00 	lds	r24, 0x0060
    4e0e:	88 61       	ori	r24, 0x18	; 24
    4e10:	80 93 60 00 	sts	0x0060, r24
    4e14:	10 92 60 00 	sts	0x0060, r1
    4e18:	0f be       	out	0x3f, r0	; 63
	wdt_disable();
	
	/* Disable JTAG on PortF -- enables Port F pins to function normally.  Datasheet requires this pin to be written repeatedly in order for it to work. 
	("The application software must write this bit to the desired value twice within four cycles to change its value."*/
	MCUCR |= (1 << JTD); 
    4e1a:	85 b7       	in	r24, 0x35	; 53
    4e1c:	80 68       	ori	r24, 0x80	; 128
    4e1e:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4e20:	85 b7       	in	r24, 0x35	; 53
    4e22:	80 68       	ori	r24, 0x80	; 128
    4e24:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4e26:	85 b7       	in	r24, 0x35	; 53
    4e28:	80 68       	ori	r24, 0x80	; 128
    4e2a:	85 bf       	out	0x35, r24	; 53
	MCUCR |= (1 << JTD); 
    4e2c:	85 b7       	in	r24, 0x35	; 53
    4e2e:	80 68       	ori	r24, 0x80	; 128
    4e30:	85 bf       	out	0x35, r24	; 53
from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
    4e32:	90 e0       	ldi	r25, 0x00	; 0
    4e34:	80 e8       	ldi	r24, 0x80	; 128
    4e36:	0f b6       	in	r0, 0x3f	; 63
    4e38:	f8 94       	cli
    4e3a:	80 93 61 00 	sts	0x0061, r24
    4e3e:	90 93 61 00 	sts	0x0061, r25
    4e42:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
	Config_Interrupts();
    4e44:	0e 94 b8 09 	call	0x1370	; 0x1370 <Config_Interrupts>
	
	/* Hardware Initialization */
	Config_IO();
    4e48:	0e 94 cc 09 	call	0x1398	; 0x1398 <Config_IO>
    4e4c:	2f e7       	ldi	r18, 0x7F	; 127
    4e4e:	88 e3       	ldi	r24, 0x38	; 56
    4e50:	91 e0       	ldi	r25, 0x01	; 1
    4e52:	21 50       	subi	r18, 0x01	; 1
    4e54:	80 40       	sbci	r24, 0x00	; 0
    4e56:	90 40       	sbci	r25, 0x00	; 0
    4e58:	e1 f7       	brne	.-8      	; 0x4e52 <SetupHardware+0x54>
    4e5a:	00 c0       	rjmp	.+0      	; 0x4e5c <SetupHardware+0x5e>
    4e5c:	00 00       	nop
	Delay_MS(50); //DELAY 50ms after setting IO.
	
	Reed1Polarity = eeprom_read_byte((uint8_t *)REED_1_POLARITY_ADDR);
    4e5e:	86 e0       	ldi	r24, 0x06	; 6
    4e60:	92 e0       	ldi	r25, 0x02	; 2
    4e62:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    4e66:	91 e0       	ldi	r25, 0x01	; 1
    4e68:	81 11       	cpse	r24, r1
    4e6a:	01 c0       	rjmp	.+2      	; 0x4e6e <SetupHardware+0x70>
    4e6c:	90 e0       	ldi	r25, 0x00	; 0
    4e6e:	90 93 25 07 	sts	0x0725, r25
	Reed2Polarity= eeprom_read_byte((uint8_t *)REED_2_POLARITY_ADDR);
    4e72:	87 e0       	ldi	r24, 0x07	; 7
    4e74:	92 e0       	ldi	r25, 0x02	; 2
    4e76:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    4e7a:	91 e0       	ldi	r25, 0x01	; 1
    4e7c:	81 11       	cpse	r24, r1
    4e7e:	01 c0       	rjmp	.+2      	; 0x4e82 <SetupHardware+0x84>
    4e80:	90 e0       	ldi	r25, 0x00	; 0
    4e82:	90 93 d5 06 	sts	0x06D5, r25
	Reed3Polarity = eeprom_read_byte((uint8_t *)REED_3_POLARITY_ADDR);
    4e86:	88 e0       	ldi	r24, 0x08	; 8
    4e88:	92 e0       	ldi	r25, 0x02	; 2
    4e8a:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    4e8e:	91 e0       	ldi	r25, 0x01	; 1
    4e90:	81 11       	cpse	r24, r1
    4e92:	01 c0       	rjmp	.+2      	; 0x4e96 <SetupHardware+0x98>
    4e94:	90 e0       	ldi	r25, 0x00	; 0
    4e96:	90 93 a7 07 	sts	0x07A7, r25
	Reed4Polarity = eeprom_read_byte((uint8_t *)REED_4_POLARITY_ADDR);
    4e9a:	89 e0       	ldi	r24, 0x09	; 9
    4e9c:	92 e0       	ldi	r25, 0x02	; 2
    4e9e:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    4ea2:	91 e0       	ldi	r25, 0x01	; 1
    4ea4:	81 11       	cpse	r24, r1
    4ea6:	01 c0       	rjmp	.+2      	; 0x4eaa <SetupHardware+0xac>
    4ea8:	90 e0       	ldi	r25, 0x00	; 0
    4eaa:	90 93 e5 07 	sts	0x07E5, r25
    4eae:	08 95       	ret

00004eb0 <EVENT_USB_Device_Connect>:
	
}

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
    4eb0:	08 95       	ret

00004eb2 <EVENT_USB_Device_Disconnect>:
}

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	if(SDCardManager_CheckSDCardOperation()){ //if there is an SD Card present, flip into sd mode if the computer is shut off.
    4eb2:	8d de       	rcall	.-742    	; 0x4bce <SDCardManager_CheckSDCardOperation>
    4eb4:	88 23       	and	r24, r24
    4eb6:	19 f0       	breq	.+6      	; 0x4ebe <EVENT_USB_Device_Disconnect+0xc>
		Typewriter_Mode = SD_MODE;
    4eb8:	82 e0       	ldi	r24, 0x02	; 2
    4eba:	80 93 28 08 	sts	0x0828, r24
    4ebe:	08 95       	ret

00004ec0 <EVENT_USB_Device_Suspend>:
	}

}

void EVENT_USB_Device_Suspend(void){
    4ec0:	08 95       	ret

00004ec2 <EVENT_USB_Device_WakeUp>:
	
}

void EVENT_USB_Device_WakeUp(void){
    4ec2:	08 95       	ret

00004ec4 <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= HID_Device_ConfigureEndpoints(&Keyboard_HID_Interface);
    4ec4:	80 e2       	ldi	r24, 0x20	; 32
    4ec6:	91 e0       	ldi	r25, 0x01	; 1
    4ec8:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <HID_Device_ConfigureEndpoints>
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
    4ecc:	80 e3       	ldi	r24, 0x30	; 48
    4ece:	91 e0       	ldi	r25, 0x01	; 1
    4ed0:	0e 94 bf 30 	call	0x617e	; 0x617e <MS_Device_ConfigureEndpoints>
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
    4ed4:	e2 ee       	ldi	r30, 0xE2	; 226
    4ed6:	f0 e0       	ldi	r31, 0x00	; 0
    4ed8:	80 81       	ld	r24, Z
    4eda:	84 60       	ori	r24, 0x04	; 4
    4edc:	80 83       	st	Z, r24
    4ede:	08 95       	ret

00004ee0 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	MS_Device_ProcessControlRequest(&Disk_MS_Interface);
    4ee0:	80 e3       	ldi	r24, 0x30	; 48
    4ee2:	91 e0       	ldi	r25, 0x01	; 1
    4ee4:	0e 94 82 30 	call	0x6104	; 0x6104 <MS_Device_ProcessControlRequest>
	HID_Device_ProcessControlRequest(&Keyboard_HID_Interface);
    4ee8:	80 e2       	ldi	r24, 0x20	; 32
    4eea:	91 e0       	ldi	r25, 0x01	; 1
    4eec:	eb c6       	rjmp	.+3542   	; 0x5cc4 <HID_Device_ProcessControlRequest>
    4eee:	08 95       	ret

00004ef0 <EVENT_USB_Device_StartOfFrame>:
			 *  \param[in,out] HIDInterfaceInfo  Pointer to a structure containing a HID Class configuration and state.
			 */
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo) ATTR_ALWAYS_INLINE ATTR_NON_NULL_PTR_ARG(1);
			static inline void HID_Device_MillisecondElapsed(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
			{
				if (HIDInterfaceInfo->State.IdleMSRemaining)
    4ef0:	80 91 2e 01 	lds	r24, 0x012E
    4ef4:	90 91 2f 01 	lds	r25, 0x012F
    4ef8:	00 97       	sbiw	r24, 0x00	; 0
    4efa:	29 f0       	breq	.+10     	; 0x4f06 <EVENT_USB_Device_StartOfFrame+0x16>
				  HIDInterfaceInfo->State.IdleMSRemaining--;
    4efc:	01 97       	sbiw	r24, 0x01	; 1
    4efe:	90 93 2f 01 	sts	0x012F, r25
    4f02:	80 93 2e 01 	sts	0x012E, r24
    4f06:	08 95       	ret

00004f08 <CALLBACK_MS_Device_SCSICommandReceived>:
 */
bool CALLBACK_MS_Device_SCSICommandReceived(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	bool CommandSuccess;

	CommandSuccess = SCSI_DecodeSCSICommand(MSInterfaceInfo);
    4f08:	6f cb       	rjmp	.-2338   	; 0x45e8 <SCSI_DecodeSCSICommand>

	return CommandSuccess;
}
    4f0a:	08 95       	ret

00004f0c <CALLBACK_HID_Device_CreateHIDReport>:
bool CALLBACK_HID_Device_CreateHIDReport(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo,
                                         uint8_t* const ReportID,
                                         const uint8_t ReportType,
                                         void* ReportData,
                                         uint16_t* const ReportSize)
{
    4f0c:	0f 93       	push	r16
    4f0e:	1f 93       	push	r17
	USB_KeyboardReport_Data_t* KeyboardReport = (USB_KeyboardReport_Data_t*)ReportData;

//	memcpy((void*)KeyboardReport->KeyCode, (void*)KeyBuffer->KeyCode, 6); //copy the keybuffer into the keyboard report being sent to host.
	KeyboardReport->KeyCode[0] = KeyBuffer->KeyCode[0];
    4f10:	e0 91 22 07 	lds	r30, 0x0722
    4f14:	f0 91 23 07 	lds	r31, 0x0723
    4f18:	82 81       	ldd	r24, Z+2	; 0x02
    4f1a:	f9 01       	movw	r30, r18
    4f1c:	82 83       	std	Z+2, r24	; 0x02

	if (KeyboardReport->KeyCode[0]){ //if there is a key waiting to be sent, then use the modifier that goes with that key.
    4f1e:	88 23       	and	r24, r24
    4f20:	21 f0       	breq	.+8      	; 0x4f2a <CALLBACK_HID_Device_CreateHIDReport+0x1e>
		KeyboardReport->Modifier = KeyBufferMod;
    4f22:	80 91 da 06 	lds	r24, 0x06DA
    4f26:	80 83       	st	Z, r24
    4f28:	02 c0       	rjmp	.+4      	; 0x4f2e <CALLBACK_HID_Device_CreateHIDReport+0x22>
	}
	else {
		KeyboardReport->Modifier = 0; //otherwise, clear the modifiers so the host doesn't think we are holding down shift or alt or whatever for no reason.
    4f2a:	f9 01       	movw	r30, r18
    4f2c:	10 82       	st	Z, r1
	}
	
//	memset((void*)KeyBuffer->KeyCode,0,6);  //clear keybuffer to clear room for the next key.  This indicates to other routines that the USB buffer is available for sending.
	KeyBuffer->KeyCode[0] = 0;
    4f2e:	e0 91 22 07 	lds	r30, 0x0722
    4f32:	f0 91 23 07 	lds	r31, 0x0723
    4f36:	12 82       	std	Z+2, r1	; 0x02
	KeyBufferMod= 0;
    4f38:	10 92 da 06 	sts	0x06DA, r1

	*ReportSize = sizeof(USB_KeyboardReport_Data_t);
    4f3c:	88 e0       	ldi	r24, 0x08	; 8
    4f3e:	90 e0       	ldi	r25, 0x00	; 0
    4f40:	f8 01       	movw	r30, r16
    4f42:	91 83       	std	Z+1, r25	; 0x01
    4f44:	80 83       	st	Z, r24
	return false;
}
    4f46:	80 e0       	ldi	r24, 0x00	; 0
    4f48:	1f 91       	pop	r17
    4f4a:	0f 91       	pop	r16
    4f4c:	08 95       	ret

00004f4e <CALLBACK_HID_Device_ProcessHIDReport>:
                                          const uint16_t ReportSize)
{

	uint8_t* LEDReport = (uint8_t*)ReportData;

	if (*LEDReport & HID_KEYBOARD_LED_NUMLOCK) //if numlock is somehow active,
    4f4e:	f9 01       	movw	r30, r18
    4f50:	80 81       	ld	r24, Z
    4f52:	80 ff       	sbrs	r24, 0
    4f54:	07 c0       	rjmp	.+14     	; 0x4f64 <CALLBACK_HID_Device_ProcessHIDReport+0x16>
	  KeyBuffer->KeyCode[0] = HID_KEYBOARD_LED_NUMLOCK; //press numlock key to deactivate it.
    4f56:	e0 91 22 07 	lds	r30, 0x0722
    4f5a:	f0 91 23 07 	lds	r31, 0x0723
    4f5e:	81 e0       	ldi	r24, 0x01	; 1
    4f60:	82 83       	std	Z+2, r24	; 0x02
    4f62:	08 95       	ret

	else if (*LEDReport & HID_KEYBOARD_LED_CAPSLOCK) //if capslock is somehow active,
    4f64:	81 ff       	sbrs	r24, 1
    4f66:	07 c0       	rjmp	.+14     	; 0x4f76 <CALLBACK_HID_Device_ProcessHIDReport+0x28>
	  KeyBuffer ->KeyCode[0] = HID_KEYBOARD_LED_CAPSLOCK; //press capslock key to deactivate it.
    4f68:	e0 91 22 07 	lds	r30, 0x0722
    4f6c:	f0 91 23 07 	lds	r31, 0x0723
    4f70:	82 e0       	ldi	r24, 0x02	; 2
    4f72:	82 83       	std	Z+2, r24	; 0x02
    4f74:	08 95       	ret

	else if (*LEDReport & HID_KEYBOARD_LED_SCROLLLOCK) //if scrolllock is somehow active,
    4f76:	82 ff       	sbrs	r24, 2
    4f78:	06 c0       	rjmp	.+12     	; 0x4f86 <CALLBACK_HID_Device_ProcessHIDReport+0x38>
	  KeyBuffer ->KeyCode[0] = HID_KEYBOARD_LED_SCROLLLOCK; //press scrolllock key to deactivate it.
    4f7a:	e0 91 22 07 	lds	r30, 0x0722
    4f7e:	f0 91 23 07 	lds	r31, 0x0723
    4f82:	84 e0       	ldi	r24, 0x04	; 4
    4f84:	82 83       	std	Z+2, r24	; 0x02
    4f86:	08 95       	ret

00004f88 <Init_Mode>:

}


void Init_Mode(){
    4f88:	cf 93       	push	r28
	uint8_t key;
	uint8_t code;
	uint8_t Default_Mode;
	
	Default_Mode = eeprom_read_byte((uint8_t*)DEFAULT_MODE_ADDR);
    4f8a:	8d e0       	ldi	r24, 0x0D	; 13
    4f8c:	92 e0       	ldi	r25, 0x02	; 2
    4f8e:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    4f92:	c8 2f       	mov	r28, r24
	
	key = GetKeySimple(); //read the key that is being held during startup (if any)
    4f94:	d8 d3       	rcall	.+1968   	; 0x5746 <GetKeySimple>
	code = GetASCIIKeyCode(key,UPPER);
    4f96:	62 e0       	ldi	r22, 0x02	; 2
    4f98:	94 d5       	rcall	.+2856   	; 0x5ac2 <GetASCIIKeyCode>
	
	if (is_low(S1)&&is_low(S2)&&is_low(S3)){ //reset device to known state
    4f9a:	7c 99       	sbic	0x0f, 4	; 15
    4f9c:	0d c0       	rjmp	.+26     	; 0x4fb8 <Init_Mode+0x30>
    4f9e:	7d 99       	sbic	0x0f, 5	; 15
    4fa0:	0b c0       	rjmp	.+22     	; 0x4fb8 <Init_Mode+0x30>
    4fa2:	7e 99       	sbic	0x0f, 6	; 15
    4fa4:	09 c0       	rjmp	.+18     	; 0x4fb8 <Init_Mode+0x30>
			Typewriter_Mode = USB_COMBO_MODE;
    4fa6:	81 e0       	ldi	r24, 0x01	; 1
    4fa8:	80 93 28 08 	sts	0x0828, r24
			Default_Mode = USB_COMBO_MODE;
			GlowGreenLED(SLOW,GLOWING);
    4fac:	60 e0       	ldi	r22, 0x00	; 0
    4fae:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <GlowGreenLED>
			RestoreFactoryDefaults();			
    4fb2:	31 d6       	rcall	.+3170   	; 0x5c16 <RestoreFactoryDefaults>
	key = GetKeySimple(); //read the key that is being held during startup (if any)
	code = GetASCIIKeyCode(key,UPPER);
	
	if (is_low(S1)&&is_low(S2)&&is_low(S3)){ //reset device to known state
			Typewriter_Mode = USB_COMBO_MODE;
			Default_Mode = USB_COMBO_MODE;
    4fb4:	c1 e0       	ldi	r28, 0x01	; 1
			GlowGreenLED(SLOW,GLOWING);
			RestoreFactoryDefaults();			
    4fb6:	95 c0       	rjmp	.+298    	; 0x50e2 <Init_Mode+0x15a>
	}
	else if(is_low(S2)&&is_low(S3)){ //configure bluetooth and test bluetooth -- reset bluetooth module  -- force initialization next time bluetooth is used.
    4fb8:	7d 99       	sbic	0x0f, 5	; 15
    4fba:	1f c0       	rjmp	.+62     	; 0x4ffa <Init_Mode+0x72>
    4fbc:	7e 99       	sbic	0x0f, 6	; 15
    4fbe:	1d c0       	rjmp	.+58     	; 0x4ffa <Init_Mode+0x72>
			if(Bluetooth_Configure()){
    4fc0:	0e 94 78 03 	call	0x6f0	; 0x6f0 <Bluetooth_Configure>
    4fc4:	88 23       	and	r24, r24
    4fc6:	71 f0       	breq	.+28     	; 0x4fe4 <Init_Mode+0x5c>
					//this test mode resets the bluetooth channel.
					BluetoothInquire();//clear paired device list and try to pair.
    4fc8:	0e 94 b0 03 	call	0x760	; 0x760 <BluetoothInquire>
					BluetoothConfigured = 0;// even though it has been configured, save it as "not configured" to force configuration next time (on customer's end.)
    4fcc:	10 92 1b 07 	sts	0x071B, r1
					eeprom_update_byte((uint8_t*)BLUETOOTH_CONFIGURED_ADDR, BluetoothConfigured); 	
    4fd0:	60 e0       	ldi	r22, 0x00	; 0
    4fd2:	80 e1       	ldi	r24, 0x10	; 16
    4fd4:	92 e0       	ldi	r25, 0x02	; 2
    4fd6:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
					Typewriter_Mode = BLUETOOTH_MODE;
    4fda:	89 e0       	ldi	r24, 0x09	; 9
    4fdc:	80 93 28 08 	sts	0x0828, r24
					Default_Mode = BLUETOOTH_MODE;  //Do not set bluetooth mode as the default, since this mode only tests the bluetooth
    4fe0:	c9 e0       	ldi	r28, 0x09	; 9
    4fe2:	7f c0       	rjmp	.+254    	; 0x50e2 <Init_Mode+0x15a>
			}
			else{ //if something goes wrong during configuration...
				BluetoothConfigured = 0;
    4fe4:	10 92 1b 07 	sts	0x071B, r1
				eeprom_update_byte((uint8_t*)BLUETOOTH_CONFIGURED_ADDR, BluetoothConfigured); //remember that bluetooth has not been configured already.
    4fe8:	60 e0       	ldi	r22, 0x00	; 0
    4fea:	80 e1       	ldi	r24, 0x10	; 16
    4fec:	92 e0       	ldi	r25, 0x02	; 2
    4fee:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
				Typewriter_Mode = PANIC_MODE; //don't change default mode
    4ff2:	8a e0       	ldi	r24, 0x0A	; 10
    4ff4:	80 93 28 08 	sts	0x0828, r24
    4ff8:	74 c0       	rjmp	.+232    	; 0x50e2 <Init_Mode+0x15a>
			}
	}
	else if(is_low(S1)&&is_low(S2)){
    4ffa:	7c 99       	sbic	0x0f, 4	; 15
    4ffc:	06 c0       	rjmp	.+12     	; 0x500a <Init_Mode+0x82>
    4ffe:	7d 99       	sbic	0x0f, 5	; 15
    5000:	04 c0       	rjmp	.+8      	; 0x500a <Init_Mode+0x82>
			Typewriter_Mode = SD_MODE;
    5002:	82 e0       	ldi	r24, 0x02	; 2
    5004:	80 93 28 08 	sts	0x0828, r24
    5008:	6c c0       	rjmp	.+216    	; 0x50e2 <Init_Mode+0x15a>
	}
	else if(is_low(S1)&&is_low(S3)){//quick calibration mode
    500a:	7c 99       	sbic	0x0f, 4	; 15
    500c:	06 c0       	rjmp	.+12     	; 0x501a <Init_Mode+0x92>
    500e:	7e 99       	sbic	0x0f, 6	; 15
    5010:	04 c0       	rjmp	.+8      	; 0x501a <Init_Mode+0x92>
			Typewriter_Mode = QUICK_CAL_MODE;
    5012:	86 e0       	ldi	r24, 0x06	; 6
    5014:	80 93 28 08 	sts	0x0828, r24
    5018:	64 c0       	rjmp	.+200    	; 0x50e2 <Init_Mode+0x15a>
	}
	else if (is_low(S1)){ //hold down S1 during initialization to calibrate
    501a:	7c 99       	sbic	0x0f, 4	; 15
    501c:	04 c0       	rjmp	.+8      	; 0x5026 <Init_Mode+0x9e>
			Typewriter_Mode = CAL_MODE;
    501e:	85 e0       	ldi	r24, 0x05	; 5
    5020:	80 93 28 08 	sts	0x0828, r24
    5024:	5e c0       	rjmp	.+188    	; 0x50e2 <Init_Mode+0x15a>
	}
	else if(is_low(S2)){
    5026:	7d 99       	sbic	0x0f, 5	; 15
    5028:	04 c0       	rjmp	.+8      	; 0x5032 <Init_Mode+0xaa>
		Typewriter_Mode = SENSITIVITY_MODE;
    502a:	83 e0       	ldi	r24, 0x03	; 3
    502c:	80 93 28 08 	sts	0x0828, r24
    5030:	58 c0       	rjmp	.+176    	; 0x50e2 <Init_Mode+0x15a>
	}
	else if (is_low(S3)){ //hold down S3 to enter LED indication mode to test reed switches.
    5032:	7e 99       	sbic	0x0f, 6	; 15
    5034:	04 c0       	rjmp	.+8      	; 0x503e <Init_Mode+0xb6>
		Typewriter_Mode = TEST_MODE;
    5036:	84 e0       	ldi	r24, 0x04	; 4
    5038:	80 93 28 08 	sts	0x0828, r24
    503c:	52 c0       	rjmp	.+164    	; 0x50e2 <Init_Mode+0x15a>
	}
	else if(code == 'U'){ //if the letter U is being held by user
    503e:	85 35       	cpi	r24, 0x55	; 85
    5040:	39 f4       	brne	.+14     	; 0x5050 <Init_Mode+0xc8>
		Typewriter_Mode = USB_COMBO_MODE;
    5042:	81 e0       	ldi	r24, 0x01	; 1
    5044:	80 93 28 08 	sts	0x0828, r24
		Default_Mode = USB_COMBO_MODE;	
		Ignore_Flag = 1; //tell sensor routine to ignore this U.
    5048:	80 93 21 07 	sts	0x0721, r24
	else if (is_low(S3)){ //hold down S3 to enter LED indication mode to test reed switches.
		Typewriter_Mode = TEST_MODE;
	}
	else if(code == 'U'){ //if the letter U is being held by user
		Typewriter_Mode = USB_COMBO_MODE;
		Default_Mode = USB_COMBO_MODE;	
    504c:	c1 e0       	ldi	r28, 0x01	; 1
    504e:	49 c0       	rjmp	.+146    	; 0x50e2 <Init_Mode+0x15a>
		Ignore_Flag = 1; //tell sensor routine to ignore this U.
	}
	else if(code == 'S'){//if the letter S is being held by the user
    5050:	83 35       	cpi	r24, 0x53	; 83
    5052:	81 f4       	brne	.+32     	; 0x5074 <Init_Mode+0xec>
		if(SDCardManager_CheckSDCardOperation()){ //if an sd card is present and working, put typewriter into sd mode
    5054:	bc dd       	rcall	.-1160   	; 0x4bce <SDCardManager_CheckSDCardOperation>
    5056:	88 23       	and	r24, r24
    5058:	41 f0       	breq	.+16     	; 0x506a <Init_Mode+0xe2>
			Typewriter_Mode = SD_MODE;
    505a:	82 e0       	ldi	r24, 0x02	; 2
    505c:	80 93 28 08 	sts	0x0828, r24
			Default_Mode = SD_MODE;
			Ignore_Flag = 1; //tell sensor routine to ignore this S.
    5060:	81 e0       	ldi	r24, 0x01	; 1
    5062:	80 93 21 07 	sts	0x0721, r24
		Ignore_Flag = 1; //tell sensor routine to ignore this U.
	}
	else if(code == 'S'){//if the letter S is being held by the user
		if(SDCardManager_CheckSDCardOperation()){ //if an sd card is present and working, put typewriter into sd mode
			Typewriter_Mode = SD_MODE;
			Default_Mode = SD_MODE;
    5066:	c2 e0       	ldi	r28, 0x02	; 2
    5068:	3c c0       	rjmp	.+120    	; 0x50e2 <Init_Mode+0x15a>
			Ignore_Flag = 1; //tell sensor routine to ignore this S.
		}
		else{
			Typewriter_Mode = PANIC_MODE; //otherwise, panic to indicate malfunction ... don't change default mode.
    506a:	8a e0       	ldi	r24, 0x0A	; 10
    506c:	80 93 28 08 	sts	0x0828, r24
			Default_Mode = SD_MODE; //even so, sd mode next time you plug in.
    5070:	c2 e0       	ldi	r28, 0x02	; 2
    5072:	37 c0       	rjmp	.+110    	; 0x50e2 <Init_Mode+0x15a>
		}
	}
	else if(code == 'B'){ //if the letter B is being held by the user
    5074:	82 34       	cpi	r24, 0x42	; 66
    5076:	61 f5       	brne	.+88     	; 0x50d0 <Init_Mode+0x148>
		USB_Disable();
    5078:	0e 94 30 36 	call	0x6c60	; 0x6c60 <USB_Disable>
		if(BluetoothConfigured){
    507c:	80 91 1b 07 	lds	r24, 0x071B
    5080:	88 23       	and	r24, r24
    5082:	39 f0       	breq	.+14     	; 0x5092 <Init_Mode+0x10a>
			BluetoothInquire();//get a new device to pair with when you hold b key down.
    5084:	0e 94 b0 03 	call	0x760	; 0x760 <BluetoothInquire>
			Typewriter_Mode = BLUETOOTH_MODE; // for now, this is commented out
    5088:	89 e0       	ldi	r24, 0x09	; 9
    508a:	80 93 28 08 	sts	0x0828, r24
			Default_Mode = BLUETOOTH_MODE;
    508e:	c9 e0       	ldi	r28, 0x09	; 9
    5090:	28 c0       	rjmp	.+80     	; 0x50e2 <Init_Mode+0x15a>
		}
		else if(Bluetooth_Configure()){ // attempt to configure.
    5092:	0e 94 78 03 	call	0x6f0	; 0x6f0 <Bluetooth_Configure>
    5096:	88 23       	and	r24, r24
    5098:	81 f0       	breq	.+32     	; 0x50ba <Init_Mode+0x132>
			BluetoothConfigured = 1;
    509a:	81 e0       	ldi	r24, 0x01	; 1
    509c:	80 93 1b 07 	sts	0x071B, r24
			BluetoothInquire(); //get a new device to pair with when you hold b key down.
    50a0:	0e 94 b0 03 	call	0x760	; 0x760 <BluetoothInquire>
			eeprom_update_byte((uint8_t*)BLUETOOTH_CONFIGURED_ADDR, BluetoothConfigured); //remember that bluetooth has been configured already.	
    50a4:	60 91 1b 07 	lds	r22, 0x071B
    50a8:	80 e1       	ldi	r24, 0x10	; 16
    50aa:	92 e0       	ldi	r25, 0x02	; 2
    50ac:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
			Typewriter_Mode = BLUETOOTH_MODE;
    50b0:	89 e0       	ldi	r24, 0x09	; 9
    50b2:	80 93 28 08 	sts	0x0828, r24
			Default_Mode = BLUETOOTH_MODE;
    50b6:	c9 e0       	ldi	r28, 0x09	; 9
    50b8:	14 c0       	rjmp	.+40     	; 0x50e2 <Init_Mode+0x15a>
		}
		else{ //if something goes wrong during configuration...
			BluetoothConfigured = 0;
    50ba:	10 92 1b 07 	sts	0x071B, r1
			eeprom_update_byte((uint8_t*)BLUETOOTH_CONFIGURED_ADDR, BluetoothConfigured); //remember that bluetooth has NOT been configured successfully.
    50be:	60 e0       	ldi	r22, 0x00	; 0
    50c0:	80 e1       	ldi	r24, 0x10	; 16
    50c2:	92 e0       	ldi	r25, 0x02	; 2
    50c4:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
			Typewriter_Mode = PANIC_MODE; //indicate error
    50c8:	8a e0       	ldi	r24, 0x0A	; 10
    50ca:	80 93 28 08 	sts	0x0828, r24
    50ce:	09 c0       	rjmp	.+18     	; 0x50e2 <Init_Mode+0x15a>
		}
	}
	else if(code == 'L'){
    50d0:	8c 34       	cpi	r24, 0x4C	; 76
    50d2:	29 f4       	brne	.+10     	; 0x50de <Init_Mode+0x156>
			Typewriter_Mode = USB_LIGHT_MODE;
    50d4:	8d e0       	ldi	r24, 0x0D	; 13
    50d6:	80 93 28 08 	sts	0x0828, r24
			Default_Mode = USB_LIGHT_MODE;
    50da:	cd e0       	ldi	r28, 0x0D	; 13
    50dc:	02 c0       	rjmp	.+4      	; 0x50e2 <Init_Mode+0x15a>
	}

	else{
		Typewriter_Mode = Default_Mode; //otherwise just go into the last mode selected by user.
    50de:	c0 93 28 08 	sts	0x0828, r28
	}
	
	eeprom_update_byte((uint8_t*)DEFAULT_MODE_ADDR,Default_Mode);  //Save the new default mode (if changed)
    50e2:	6c 2f       	mov	r22, r28
    50e4:	8d e0       	ldi	r24, 0x0D	; 13
    50e6:	92 e0       	ldi	r25, 0x02	; 2
    50e8:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
}
    50ec:	cf 91       	pop	r28
    50ee:	08 95       	ret

000050f0 <main>:
	uint8_t key;
	uint8_t code;
	uint8_t modifier;
	uint8_t parity;
	
	Typewriter_Mode = INITIALIZING;
    50f0:	8c e0       	ldi	r24, 0x0C	; 12
    50f2:	80 93 28 08 	sts	0x0828, r24

	SetupHardware();
    50f6:	83 de       	rcall	.-762    	; 0x4dfe <SetupHardware>
	InitializeEeprom();//sets all EEPROM entries to zero if the checksum is incorrect
    50f8:	be d5       	rcall	.+2940   	; 0x5c76 <InitializeEeprom>
	LoadEepromParameters();
    50fa:	2a d5       	rcall	.+2644   	; 0x5b50 <LoadEepromParameters>
	LoadKeyCodeTables();
    50fc:	00 d5       	rcall	.+2560   	; 0x5afe <LoadKeyCodeTables>
	SDCardManager_Init(); 
    50fe:	1c dc       	rcall	.-1992   	; 0x4938 <SDCardManager_Init>
	USB_Init();//DEBUG ONLY
    5100:	0e 94 88 36 	call	0x6d10	; 0x6d10 <USB_Init>
	uart_init(UART_BAUD_SELECT(9600,F_CPU));//initialize the uart with a baud rate of x bps
    5104:	83 e3       	ldi	r24, 0x33	; 51
    5106:	90 e0       	ldi	r25, 0x00	; 0
    5108:	bd dd       	rcall	.-1158   	; 0x4c84 <uart_init>
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    510a:	78 94       	sei

	//USB_Init(); COMMENTED FOR DEBUGGING
	GlobalInterruptEnable();
	
	Init_Mode();
    510c:	3d df       	rcall	.-390    	; 0x4f88 <Init_Mode>
				USB_Disable(); //make sure no host is connected before accessing SD card.
				LogKeystrokes();
			break;
			case CAL_MODE:
				Calibrate();
				Typewriter_Mode = USB_LIGHT_MODE; //after calibrating, go to usb light mode.
    510e:	1d e0       	ldi	r17, 0x0D	; 13
			case SENSITIVITY_MODE:
				Adjust_Sensitivity();
				Typewriter_Mode = USB_LIGHT_MODE;
			break;
			default:
				Typewriter_Mode = PANIC_MODE;
    5110:	0a e0       	ldi	r16, 0x0A	; 10
	
	Init_Mode();
//	Delay_MS(INIT_DELAY);
	
	while(1){
		switch (Typewriter_Mode){
    5112:	80 91 28 08 	lds	r24, 0x0828
    5116:	85 30       	cpi	r24, 0x05	; 5
    5118:	09 f4       	brne	.+2      	; 0x511c <main+0x2c>
    511a:	80 c0       	rjmp	.+256    	; 0x521c <main+0x12c>
    511c:	74 f4       	brge	.+28     	; 0x513a <main+0x4a>
    511e:	82 30       	cpi	r24, 0x02	; 2
    5120:	09 f4       	brne	.+2      	; 0x5124 <main+0x34>
    5122:	71 c0       	rjmp	.+226    	; 0x5206 <main+0x116>
    5124:	1c f4       	brge	.+6      	; 0x512c <main+0x3c>
    5126:	81 30       	cpi	r24, 0x01	; 1
    5128:	c9 f0       	breq	.+50     	; 0x515c <main+0x6c>
    512a:	dd c0       	rjmp	.+442    	; 0x52e6 <main+0x1f6>
    512c:	83 30       	cpi	r24, 0x03	; 3
    512e:	09 f4       	brne	.+2      	; 0x5132 <main+0x42>
    5130:	d5 c0       	rjmp	.+426    	; 0x52dc <main+0x1ec>
    5132:	84 30       	cpi	r24, 0x04	; 4
    5134:	09 f4       	brne	.+2      	; 0x5138 <main+0x48>
    5136:	39 c0       	rjmp	.+114    	; 0x51aa <main+0xba>
    5138:	d6 c0       	rjmp	.+428    	; 0x52e6 <main+0x1f6>
    513a:	8a 30       	cpi	r24, 0x0A	; 10
    513c:	09 f4       	brne	.+2      	; 0x5140 <main+0x50>
    513e:	b5 c0       	rjmp	.+362    	; 0x52aa <main+0x1ba>
    5140:	3c f4       	brge	.+14     	; 0x5150 <main+0x60>
    5142:	86 30       	cpi	r24, 0x06	; 6
    5144:	09 f4       	brne	.+2      	; 0x5148 <main+0x58>
    5146:	6f c0       	rjmp	.+222    	; 0x5226 <main+0x136>
    5148:	89 30       	cpi	r24, 0x09	; 9
    514a:	09 f4       	brne	.+2      	; 0x514e <main+0x5e>
    514c:	71 c0       	rjmp	.+226    	; 0x5230 <main+0x140>
    514e:	cb c0       	rjmp	.+406    	; 0x52e6 <main+0x1f6>
    5150:	8b 30       	cpi	r24, 0x0B	; 11
    5152:	09 f4       	brne	.+2      	; 0x5156 <main+0x66>
    5154:	54 c0       	rjmp	.+168    	; 0x51fe <main+0x10e>
    5156:	8d 30       	cpi	r24, 0x0D	; 13
    5158:	09 f0       	breq	.+2      	; 0x515c <main+0x6c>
    515a:	c5 c0       	rjmp	.+394    	; 0x52e6 <main+0x1f6>
			case USB_LIGHT_MODE:
			case USB_COMBO_MODE:				
			MountFilesystem();//mount the filesystem so that we have info on it
    515c:	0e 94 02 0b 	call	0x1604	; 0x1604 <MountFilesystem>
			while(1){
				key = GetKey();
    5160:	1a d3       	rcall	.+1588   	; 0x5796 <GetKey>
    5162:	c8 2f       	mov	r28, r24
				modifier = GetModifier(); 
    5164:	e5 d1       	rcall	.+970    	; 0x5530 <GetModifier>
    5166:	d8 2f       	mov	r29, r24
				code = GetHIDKeyCode(key, modifier);
    5168:	68 2f       	mov	r22, r24
    516a:	8c 2f       	mov	r24, r28
    516c:	92 d4       	rcall	.+2340   	; 0x5a92 <GetHIDKeyCode>
				
				if(FnKeyCodeLookUpTable[key]){modifier &= ~HID_KEYBOARD_MODIFIER_LEFTALT;}// if the key is in the function table, it is a special key.  The alt modifier should not be sent..
    516e:	ec 2f       	mov	r30, r28
    5170:	f0 e0       	ldi	r31, 0x00	; 0
    5172:	e7 5d       	subi	r30, 0xD7	; 215
    5174:	f5 4f       	sbci	r31, 0xF5	; 245
    5176:	90 81       	ld	r25, Z
    5178:	91 11       	cpse	r25, r1
    517a:	db 7f       	andi	r29, 0xFB	; 251
					
				if(code){//if the code is valid, send it
    517c:	88 23       	and	r24, r24
    517e:	51 f0       	breq	.+20     	; 0x5194 <main+0xa4>
						if ((code == KEY_U)&&Ignore_Flag) code = 0; //if user is holding down U on startup, don't add this U to file.
    5180:	88 31       	cpi	r24, 0x18	; 24
    5182:	21 f4       	brne	.+8      	; 0x518c <main+0x9c>
    5184:	90 91 21 07 	lds	r25, 0x0721
    5188:	91 11       	cpse	r25, r1
    518a:	80 e0       	ldi	r24, 0x00	; 0
						Ignore_Flag = 0;
    518c:	10 92 21 07 	sts	0x0721, r1
						USBSend(code,modifier);
    5190:	6d 2f       	mov	r22, r29
    5192:	ac d0       	rcall	.+344    	; 0x52ec <USBSend>
    5194:	8f ec       	ldi	r24, 0xCF	; 207
    5196:	97 e0       	ldi	r25, 0x07	; 7
    5198:	01 97       	sbiw	r24, 0x01	; 1
    519a:	f1 f7       	brne	.-4      	; 0x5198 <main+0xa8>
    519c:	00 c0       	rjmp	.+0      	; 0x519e <main+0xae>
    519e:	00 00       	nop
				}
				Delay_MS(SENSE_DELAY);//perform this loop every X ms.
				HID_Device_USBTask(&Keyboard_HID_Interface);
    51a0:	80 e2       	ldi	r24, 0x20	; 32
    51a2:	91 e0       	ldi	r25, 0x01	; 1
    51a4:	ee d6       	rcall	.+3548   	; 0x5f82 <HID_Device_USBTask>
				Task_Manager(); //do the required usb upkeep tasks, then update the list of scheduled tasks.
    51a6:	04 de       	rcall	.-1016   	; 0x4db0 <Task_Manager>
				
			}
    51a8:	db cf       	rjmp	.-74     	; 0x5160 <main+0x70>
			break;
			case TEST_MODE:
				USB_Disable(); //USB not needed for testing
    51aa:	0e 94 30 36 	call	0x6c60	; 0x6c60 <USB_Disable>
				while(1){
					UseHallSensor = HALL_NOT_PRESENT;//make sure hall sensor bit is not zeroed out by ReadSensor() as soon as it is read;
					parity = (uint8_t)is_low(REED_1) + (uint8_t)is_low(REED_2)+ (uint8_t)is_low(REED_3) + (uint8_t)is_low(REED_4) + (uint8_t)getHallState();
    51ae:	d1 e0       	ldi	r29, 0x01	; 1
			}
			break;
			case TEST_MODE:
				USB_Disable(); //USB not needed for testing
				while(1){
					UseHallSensor = HALL_NOT_PRESENT;//make sure hall sensor bit is not zeroed out by ReadSensor() as soon as it is read;
    51b0:	10 92 a8 07 	sts	0x07A8, r1
					parity = (uint8_t)is_low(REED_1) + (uint8_t)is_low(REED_2)+ (uint8_t)is_low(REED_3) + (uint8_t)is_low(REED_4) + (uint8_t)getHallState();
    51b4:	89 b1       	in	r24, 0x09	; 9
    51b6:	c9 b1       	in	r28, 0x09	; 9
    51b8:	29 b1       	in	r18, 0x09	; 9
    51ba:	93 b1       	in	r25, 0x03	; 3
    51bc:	c6 fb       	bst	r28, 6
    51be:	cc 27       	eor	r28, r28
    51c0:	c0 f9       	bld	r28, 0
    51c2:	cd 27       	eor	r28, r29
    51c4:	82 95       	swap	r24
    51c6:	81 70       	andi	r24, 0x01	; 1
    51c8:	8d 27       	eor	r24, r29
    51ca:	c8 0f       	add	r28, r24
    51cc:	20 95       	com	r18
    51ce:	22 1f       	adc	r18, r18
    51d0:	22 27       	eor	r18, r18
    51d2:	22 1f       	adc	r18, r18
    51d4:	c2 0f       	add	r28, r18
    51d6:	92 95       	swap	r25
    51d8:	91 70       	andi	r25, 0x01	; 1
    51da:	9d 27       	eor	r25, r29
    51dc:	c9 0f       	add	r28, r25
    51de:	86 d4       	rcall	.+2316   	; 0x5aec <getHallState>
    51e0:	8c 0f       	add	r24, r28
				
					if (parity & 1){  //if first bit of parity is 1, then an odd number of sensors are active.
    51e2:	80 ff       	sbrs	r24, 0
    51e4:	03 c0       	rjmp	.+6      	; 0x51ec <main+0xfc>
						set_high(LED1);
    51e6:	46 9a       	sbi	0x08, 6	; 8
						set_low(LED2);
    51e8:	2e 98       	cbi	0x05, 6	; 5
    51ea:	02 c0       	rjmp	.+4      	; 0x51f0 <main+0x100>
					}
					else{ //otherwise, an even number (or zero) are active.
						set_low(LED1);
    51ec:	46 98       	cbi	0x08, 6	; 8
						set_high(LED2);
    51ee:	2e 9a       	sbi	0x05, 6	; 5
    51f0:	8f ec       	ldi	r24, 0xCF	; 207
    51f2:	97 e0       	ldi	r25, 0x07	; 7
    51f4:	01 97       	sbiw	r24, 0x01	; 1
    51f6:	f1 f7       	brne	.-4      	; 0x51f4 <main+0x104>
    51f8:	00 c0       	rjmp	.+0      	; 0x51fa <main+0x10a>
    51fa:	00 00       	nop
    51fc:	d9 cf       	rjmp	.-78     	; 0x51b0 <main+0xc0>
					}
					Delay_MS(SENSE_DELAY);
				}
			break;
			case HARDWARE_TEST:				
				USB_Disable(); //make sure no host is connected before accessing SD card.
    51fe:	0e 94 30 36 	call	0x6c60	; 0x6c60 <USB_Disable>
				TestSDHardware();
    5202:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <TestSDHardware>
			case SD_MODE:
				if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
    5206:	80 91 d6 06 	lds	r24, 0x06D6
    520a:	88 23       	and	r24, r24
    520c:	11 f0       	breq	.+4      	; 0x5212 <main+0x122>
    520e:	5d 98       	cbi	0x0b, 5	; 11
    5210:	55 9a       	sbi	0x0a, 5	; 10
				USB_Disable(); //make sure no host is connected before accessing SD card.
    5212:	0e 94 30 36 	call	0x6c60	; 0x6c60 <USB_Disable>
				LogKeystrokes();
    5216:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <LogKeystrokes>
			break;
    521a:	7b cf       	rjmp	.-266    	; 0x5112 <main+0x22>
			case CAL_MODE:
				Calibrate();
    521c:	0e 94 ed 05 	call	0xbda	; 0xbda <Calibrate>
				Typewriter_Mode = USB_LIGHT_MODE; //after calibrating, go to usb light mode.
    5220:	10 93 28 08 	sts	0x0828, r17
			break;
    5224:	76 cf       	rjmp	.-276    	; 0x5112 <main+0x22>
			case QUICK_CAL_MODE:
				QuickCalibrate();
    5226:	0e 94 99 05 	call	0xb32	; 0xb32 <QuickCalibrate>
				Typewriter_Mode = USB_LIGHT_MODE;//after calibrating, go to usb light mode.
    522a:	10 93 28 08 	sts	0x0828, r17
			break;
    522e:	71 cf       	rjmp	.-286    	; 0x5112 <main+0x22>
			case BLUETOOTH_MODE:
				//#ifndef DEBUG
				//	USB_Disable();//don't disable usb if it is debug mode.
				//#endif
				if(Get_Bluetooth_State() != INITIALIZED){Bluetooth_Init();};//initialize bluetooth if it hasn't been already.
    5230:	0e 94 b5 03 	call	0x76a	; 0x76a <Get_Bluetooth_State>
    5234:	81 30       	cpi	r24, 0x01	; 1
    5236:	11 f0       	breq	.+4      	; 0x523c <main+0x14c>
    5238:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <Bluetooth_Init>
				if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
    523c:	80 91 d6 06 	lds	r24, 0x06D6
    5240:	88 23       	and	r24, r24
    5242:	11 f0       	breq	.+4      	; 0x5248 <main+0x158>
    5244:	5d 98       	cbi	0x0b, 5	; 11
    5246:	55 9a       	sbi	0x0a, 5	; 10
				
				while(is_low(BT_CONNECTED)){
    5248:	79 99       	sbic	0x0f, 1	; 15
    524a:	0f c0       	rjmp	.+30     	; 0x526a <main+0x17a>
					set_low(RED_LED);
    524c:	2e 98       	cbi	0x05, 6	; 5
					set_high(GREEN_LED);
    524e:	46 9a       	sbi	0x08, 6	; 8
					Bluetooth_Connect();
    5250:	0e 94 b8 03 	call	0x770	; 0x770 <Bluetooth_Connect>
    5254:	9f ef       	ldi	r25, 0xFF	; 255
    5256:	27 ea       	ldi	r18, 0xA7	; 167
    5258:	81 e6       	ldi	r24, 0x61	; 97
    525a:	91 50       	subi	r25, 0x01	; 1
    525c:	20 40       	sbci	r18, 0x00	; 0
    525e:	80 40       	sbci	r24, 0x00	; 0
    5260:	e1 f7       	brne	.-8      	; 0x525a <main+0x16a>
    5262:	00 c0       	rjmp	.+0      	; 0x5264 <main+0x174>
    5264:	00 00       	nop
				//	USB_Disable();//don't disable usb if it is debug mode.
				//#endif
				if(Get_Bluetooth_State() != INITIALIZED){Bluetooth_Init();};//initialize bluetooth if it hasn't been already.
				if(UseDummyLoad){set_low(DUMMY_LOAD);configure_as_output(DUMMY_LOAD);}
				
				while(is_low(BT_CONNECTED)){
    5266:	79 9b       	sbis	0x0f, 1	; 15
    5268:	f1 cf       	rjmp	.-30     	; 0x524c <main+0x15c>
					set_high(GREEN_LED);
					Bluetooth_Connect();
					Delay_MS(4000);					
				}//wait for connection to happen, glow red until then.
				
				set_high(RED_LED);//turn off red led if bt is connected.
    526a:	2e 9a       	sbi	0x05, 6	; 5
				set_low(GREEN_LED);
    526c:	46 98       	cbi	0x08, 6	; 8
				while(is_high(BT_CONNECTED)){
    526e:	79 9b       	sbis	0x0f, 1	; 15
    5270:	50 cf       	rjmp	.-352    	; 0x5112 <main+0x22>
					key = GetKey();
    5272:	91 d2       	rcall	.+1314   	; 0x5796 <GetKey>
    5274:	c8 2f       	mov	r28, r24
					modifier = GetModifier();
    5276:	5c d1       	rcall	.+696    	; 0x5530 <GetModifier>
    5278:	d8 2f       	mov	r29, r24
									
					code = GetHIDKeyCode(key, modifier);
    527a:	68 2f       	mov	r22, r24
    527c:	8c 2f       	mov	r24, r28
    527e:	09 d4       	rcall	.+2066   	; 0x5a92 <GetHIDKeyCode>
					
					if(FnKeyCodeLookUpTable[key]){modifier &= ~HID_KEYBOARD_MODIFIER_LEFTALT;}// if the key is in the function table, it is a special key.  The alt modifier should not be sent..
    5280:	ec 2f       	mov	r30, r28
    5282:	f0 e0       	ldi	r31, 0x00	; 0
    5284:	e7 5d       	subi	r30, 0xD7	; 215
    5286:	f5 4f       	sbci	r31, 0xF5	; 245
    5288:	90 81       	ld	r25, Z
    528a:	91 11       	cpse	r25, r1
    528c:	db 7f       	andi	r29, 0xFB	; 251
									
						if(code){
    528e:	88 23       	and	r24, r24
    5290:	19 f0       	breq	.+6      	; 0x5298 <main+0x1a8>
						Bluetooth_Send(code,modifier);
    5292:	6d 2f       	mov	r22, r29
    5294:	0e 94 f5 02 	call	0x5ea	; 0x5ea <Bluetooth_Send>
    5298:	8f ec       	ldi	r24, 0xCF	; 207
    529a:	97 e0       	ldi	r25, 0x07	; 7
    529c:	01 97       	sbiw	r24, 0x01	; 1
    529e:	f1 f7       	brne	.-4      	; 0x529c <main+0x1ac>
    52a0:	00 c0       	rjmp	.+0      	; 0x52a2 <main+0x1b2>
    52a2:	00 00       	nop
					Delay_MS(4000);					
				}//wait for connection to happen, glow red until then.
				
				set_high(RED_LED);//turn off red led if bt is connected.
				set_low(GREEN_LED);
				while(is_high(BT_CONNECTED)){
    52a4:	79 99       	sbic	0x0f, 1	; 15
    52a6:	e5 cf       	rjmp	.-54     	; 0x5272 <main+0x182>
    52a8:	34 cf       	rjmp	.-408    	; 0x5112 <main+0x22>
					}
					Delay_MS(SENSE_DELAY);//perform this loop every X ms.
				}
			break;
			case PANIC_MODE:
				USB_Disable();
    52aa:	0e 94 30 36 	call	0x6c60	; 0x6c60 <USB_Disable>
				while(1){
					set_high(LED2);
    52ae:	2e 9a       	sbi	0x05, 6	; 5
					set_low(LED1);
    52b0:	46 98       	cbi	0x08, 6	; 8
    52b2:	9f ef       	ldi	r25, 0xFF	; 255
    52b4:	21 ee       	ldi	r18, 0xE1	; 225
    52b6:	84 e0       	ldi	r24, 0x04	; 4
    52b8:	91 50       	subi	r25, 0x01	; 1
    52ba:	20 40       	sbci	r18, 0x00	; 0
    52bc:	80 40       	sbci	r24, 0x00	; 0
    52be:	e1 f7       	brne	.-8      	; 0x52b8 <main+0x1c8>
    52c0:	00 c0       	rjmp	.+0      	; 0x52c2 <main+0x1d2>
    52c2:	00 00       	nop
					Delay_MS(200);
					set_high(LED1);
    52c4:	46 9a       	sbi	0x08, 6	; 8
					set_low(LED2);
    52c6:	2e 98       	cbi	0x05, 6	; 5
    52c8:	9f ef       	ldi	r25, 0xFF	; 255
    52ca:	21 ee       	ldi	r18, 0xE1	; 225
    52cc:	84 e0       	ldi	r24, 0x04	; 4
    52ce:	91 50       	subi	r25, 0x01	; 1
    52d0:	20 40       	sbci	r18, 0x00	; 0
    52d2:	80 40       	sbci	r24, 0x00	; 0
    52d4:	e1 f7       	brne	.-8      	; 0x52ce <main+0x1de>
    52d6:	00 c0       	rjmp	.+0      	; 0x52d8 <main+0x1e8>
    52d8:	00 00       	nop
    52da:	e9 cf       	rjmp	.-46     	; 0x52ae <main+0x1be>
					Delay_MS(200);
				}		
			break;
			case SENSITIVITY_MODE:
				Adjust_Sensitivity();
    52dc:	0e 94 9c 08 	call	0x1138	; 0x1138 <Adjust_Sensitivity>
				Typewriter_Mode = USB_LIGHT_MODE;
    52e0:	10 93 28 08 	sts	0x0828, r17
			break;
    52e4:	16 cf       	rjmp	.-468    	; 0x5112 <main+0x22>
			default:
				Typewriter_Mode = PANIC_MODE;
    52e6:	00 93 28 08 	sts	0x0828, r16
			break;
    52ea:	13 cf       	rjmp	.-474    	; 0x5112 <main+0x22>

000052ec <USBSend>:
#include <ctype.h> // allows toupper()

extern USB_ClassInfo_HID_Device_t Keyboard_HID_Interface; //import the keyboard interface object from main routine so we can call usbtask on it.

/*Send a character over usb with a given modifier (shift, ctrl, etc)*/
void USBSend(uint8_t code,uint8_t mod){	
    52ec:	cf 93       	push	r28
    52ee:	df 93       	push	r29
    52f0:	c8 2f       	mov	r28, r24
    52f2:	d6 2f       	mov	r29, r22
	
	TMR1_Count = 0;
    52f4:	10 92 20 07 	sts	0x0720, r1
    52f8:	10 92 1f 07 	sts	0x071F, r1
	while (KeyBuffer->KeyCode[0] && TMR1_Count < USB_SEND_TIMEOUT) {
    52fc:	0b c0       	rjmp	.+22     	; 0x5314 <USBSend+0x28>
		if((Typewriter_Mode == USB_COMBO_MODE) || (Typewriter_Mode == USB_LIGHT_MODE)){ //interrupts do not handle keyboard stuff during this mode.
    52fe:	90 91 28 08 	lds	r25, 0x0828
    5302:	91 30       	cpi	r25, 0x01	; 1
    5304:	21 f0       	breq	.+8      	; 0x530e <USBSend+0x22>
    5306:	90 91 28 08 	lds	r25, 0x0828
    530a:	9d 30       	cpi	r25, 0x0D	; 13
    530c:	19 f4       	brne	.+6      	; 0x5314 <USBSend+0x28>
			HID_Device_USBTask(&Keyboard_HID_Interface);
    530e:	80 e2       	ldi	r24, 0x20	; 32
    5310:	91 e0       	ldi	r25, 0x01	; 1
    5312:	37 d6       	rcall	.+3182   	; 0x5f82 <HID_Device_USBTask>

/*Send a character over usb with a given modifier (shift, ctrl, etc)*/
void USBSend(uint8_t code,uint8_t mod){	
	
	TMR1_Count = 0;
	while (KeyBuffer->KeyCode[0] && TMR1_Count < USB_SEND_TIMEOUT) {
    5314:	e0 91 22 07 	lds	r30, 0x0722
    5318:	f0 91 23 07 	lds	r31, 0x0723
    531c:	92 81       	ldd	r25, Z+2	; 0x02
    531e:	99 23       	and	r25, r25
    5320:	39 f0       	breq	.+14     	; 0x5330 <USBSend+0x44>
    5322:	20 91 1f 07 	lds	r18, 0x071F
    5326:	30 91 20 07 	lds	r19, 0x0720
    532a:	24 36       	cpi	r18, 0x64	; 100
    532c:	31 05       	cpc	r19, r1
    532e:	38 f3       	brcs	.-50     	; 0x52fe <USBSend+0x12>
		if((Typewriter_Mode == USB_COMBO_MODE) || (Typewriter_Mode == USB_LIGHT_MODE)){ //interrupts do not handle keyboard stuff during this mode.
			HID_Device_USBTask(&Keyboard_HID_Interface);
		} //if buffer is full, wait.  If timeout expires, stop waiting.
	}
	
	if (code&FORCE_UPPER){ //in this program, we use the MSB of code to indicate that this key MUST be sent as upper case.
    5330:	cc 23       	and	r28, r28
    5332:	14 f4       	brge	.+4      	; 0x5338 <USBSend+0x4c>
		reg_clr(code,FORCE_UPPER); //clear the MSB,  
    5334:	cf 77       	andi	r28, 0x7F	; 127
		mod = UPPER; //and set the modifier to upper case.
    5336:	d2 e0       	ldi	r29, 0x02	; 2
	}
	
	if(code == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
    5338:	c4 37       	cpi	r28, 0x74	; 116
    533a:	11 f4       	brne	.+4      	; 0x5340 <USBSend+0x54>
		code = KEY_ENTER;
		mod = HID_KEYBOARD_MODIFIER_LEFTCTRL;
    533c:	d1 e0       	ldi	r29, 0x01	; 1
		reg_clr(code,FORCE_UPPER); //clear the MSB,  
		mod = UPPER; //and set the modifier to upper case.
	}
	
	if(code == KEY_EXECUTE){ // the "execute" command is for posting emails -- it actually sends a "CTRL+ENTER" command.
		code = KEY_ENTER;
    533e:	c8 e2       	ldi	r28, 0x28	; 40
		mod = HID_KEYBOARD_MODIFIER_LEFTCTRL;
	}
	
	cli();//make sure there are no interrupts between setting code and setting the modifier that goes with it.
    5340:	f8 94       	cli
	KeyBuffer->KeyCode[0] = code; //cue up keycode to be sent during next LUFA HID callback function.
    5342:	e0 91 22 07 	lds	r30, 0x0722
    5346:	f0 91 23 07 	lds	r31, 0x0723
    534a:	c2 83       	std	Z+2, r28	; 0x02
	KeyBufferMod = mod;
    534c:	d0 93 da 06 	sts	0x06DA, r29
	HID_Device_USBTask(&Keyboard_HID_Interface); //Dean Camera says to call this function regularly -- right after sending a character seems like an appropriate time.
    5350:	80 e2       	ldi	r24, 0x20	; 32
    5352:	91 e0       	ldi	r25, 0x01	; 1
    5354:	16 d6       	rcall	.+3116   	; 0x5f82 <HID_Device_USBTask>
	sei();//re-enable the interrupts.
    5356:	78 94       	sei
    5358:	8f e2       	ldi	r24, 0x2F	; 47
    535a:	95 e7       	ldi	r25, 0x75	; 117
    535c:	01 97       	sbiw	r24, 0x01	; 1
    535e:	f1 f7       	brne	.-4      	; 0x535c <USBSend+0x70>
    5360:	00 c0       	rjmp	.+0      	; 0x5362 <USBSend+0x76>
    5362:	00 00       	nop
	
	Delay_MS(USB_SEND_DELAY);// wait X ms after sending each character.
	
	cli();//make sure no interrupts occur during the usb task.
    5364:	f8 94       	cli
	HID_Device_USBTask(&Keyboard_HID_Interface); //do LUFA hid usb tasks
    5366:	80 e2       	ldi	r24, 0x20	; 32
    5368:	91 e0       	ldi	r25, 0x01	; 1
    536a:	0b d6       	rcall	.+3094   	; 0x5f82 <HID_Device_USBTask>
	sei();
    536c:	78 94       	sei
}
    536e:	df 91       	pop	r29
    5370:	cf 91       	pop	r28
    5372:	08 95       	ret

00005374 <USBSendString>:

/*Send a string over USB. Only supports some characters.*/
void USBSendString(char *str){
    5374:	df 92       	push	r13
    5376:	ef 92       	push	r14
    5378:	ff 92       	push	r15
    537a:	0f 93       	push	r16
    537c:	1f 93       	push	r17
    537e:	cf 93       	push	r28
    5380:	df 93       	push	r29
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
    5382:	fc 01       	movw	r30, r24
    5384:	01 90       	ld	r0, Z+
    5386:	00 20       	and	r0, r0
    5388:	e9 f7       	brne	.-6      	; 0x5384 <USBSendString+0x10>
    538a:	31 97       	sbiw	r30, 0x01	; 1
    538c:	e8 1b       	sub	r30, r24
    538e:	f9 0b       	sbc	r31, r25
	for (int i=0; i<length; i++){
    5390:	1e 16       	cp	r1, r30
    5392:	1f 06       	cpc	r1, r31
    5394:	0c f0       	brlt	.+2      	; 0x5398 <USBSendString+0x24>
    5396:	65 c0       	rjmp	.+202    	; 0x5462 <USBSendString+0xee>
    5398:	ec 01       	movw	r28, r24
    539a:	8c 01       	movw	r16, r24
    539c:	0e 0f       	add	r16, r30
    539e:	1f 1f       	adc	r17, r31
		modifier = LOWER;
    53a0:	f1 2c       	mov	r15, r1
		if(str[i] == ' '){
			code = KEY_SPACE;
		}
		else if(str[i] == '('){
			code = KEY_9;
			modifier = UPPER;
    53a2:	68 94       	set
    53a4:	ee 24       	eor	r14, r14
    53a6:	e1 f8       	bld	r14, 1
		else if(str[i] == '='){
			code = KEY_EQ;
			modifier = LOWER;
		}
		else if(str[i] == '!'){
			code = KEY_1;
    53a8:	0f 2e       	mov	r0, r31
    53aa:	fe e1       	ldi	r31, 0x1E	; 30
    53ac:	df 2e       	mov	r13, r31
    53ae:	f0 2d       	mov	r31, r0
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
		if(str[i] == ' '){
    53b0:	99 91       	ld	r25, Y+
    53b2:	90 32       	cpi	r25, 0x20	; 32
    53b4:	29 f1       	breq	.+74     	; 0x5400 <USBSendString+0x8c>
			code = KEY_SPACE;
		}
		else if(str[i] == '('){
    53b6:	98 32       	cpi	r25, 0x28	; 40
    53b8:	31 f1       	breq	.+76     	; 0x5406 <USBSendString+0x92>
			code = KEY_9;
			modifier = UPPER;
		}
		else if(str[i] == ')'){
    53ba:	99 32       	cpi	r25, 0x29	; 41
    53bc:	39 f1       	breq	.+78     	; 0x540c <USBSendString+0x98>
			code = KEY_0;
			modifier = UPPER;
		}
		else if(str[i] == '/'){
    53be:	9f 32       	cpi	r25, 0x2F	; 47
    53c0:	41 f1       	breq	.+80     	; 0x5412 <USBSendString+0x9e>
			code = KEY_SLASH;
		}
		else if(str[i] == '?'){
    53c2:	9f 33       	cpi	r25, 0x3F	; 63
    53c4:	49 f1       	breq	.+82     	; 0x5418 <USBSendString+0xa4>
			code = KEY_SLASH;
			modifier = UPPER;
		}
		else if(str[i] == ':'){
    53c6:	9a 33       	cpi	r25, 0x3A	; 58
    53c8:	51 f1       	breq	.+84     	; 0x541e <USBSendString+0xaa>
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
    53ca:	9d 30       	cpi	r25, 0x0D	; 13
    53cc:	59 f1       	breq	.+86     	; 0x5424 <USBSendString+0xb0>
    53ce:	9a 30       	cpi	r25, 0x0A	; 10
    53d0:	61 f1       	breq	.+88     	; 0x542a <USBSendString+0xb6>
			code = KEY_ENTER;
		}
		else if(str[i] == '.'){
    53d2:	9e 32       	cpi	r25, 0x2E	; 46
    53d4:	69 f1       	breq	.+90     	; 0x5430 <USBSendString+0xbc>
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if(str[i] == '='){
    53d6:	9d 33       	cpi	r25, 0x3D	; 61
    53d8:	71 f1       	breq	.+92     	; 0x5436 <USBSendString+0xc2>
			code = KEY_EQ;
			modifier = LOWER;
		}
		else if(str[i] == '!'){
    53da:	91 32       	cpi	r25, 0x21	; 33
    53dc:	79 f1       	breq	.+94     	; 0x543c <USBSendString+0xc8>
			code = KEY_1;
			modifier = UPPER;
		}
		else if(str[i] == '0'){
    53de:	90 33       	cpi	r25, 0x30	; 48
    53e0:	81 f1       	breq	.+96     	; 0x5442 <USBSendString+0xce>
			code = KEY_0;
		}
		else if((str[i] >= ASCII_1 )&&(str[i] <= ASCII_9)){
    53e2:	8f ec       	ldi	r24, 0xCF	; 207
    53e4:	89 0f       	add	r24, r25
    53e6:	89 30       	cpi	r24, 0x09	; 9
    53e8:	20 f4       	brcc	.+8      	; 0x53f2 <USBSendString+0x7e>
			code = str[i] - ASCII_1 + KEY_1; //translate ascii to hid number code 
    53ea:	8d ee       	ldi	r24, 0xED	; 237
    53ec:	89 0f       	add	r24, r25
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    53ee:	6f 2d       	mov	r22, r15
    53f0:	2a c0       	rjmp	.+84     	; 0x5446 <USBSendString+0xd2>
		}
		else if((str[i] >= ASCII_1 )&&(str[i] <= ASCII_9)){
			code = str[i] - ASCII_1 + KEY_1; //translate ascii to hid number code 
		}
		else{
			code = toupper(str[i]);//make sure code is uppercase.
    53f2:	89 2f       	mov	r24, r25
    53f4:	90 e0       	ldi	r25, 0x00	; 0
    53f6:	0e 94 ba 39 	call	0x7374	; 0x7374 <toupper>
			code = code-ASCII_A+KEY_A;  //Convert the character (which is uppercase Ascii)  to an USB HID Keycode.
    53fa:	8d 53       	subi	r24, 0x3D	; 61
			modifier = UPPER;
    53fc:	6e 2d       	mov	r22, r14
    53fe:	23 c0       	rjmp	.+70     	; 0x5446 <USBSendString+0xd2>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5400:	6f 2d       	mov	r22, r15
		if(str[i] == ' '){
			code = KEY_SPACE;
    5402:	8c e2       	ldi	r24, 0x2C	; 44
    5404:	20 c0       	rjmp	.+64     	; 0x5446 <USBSendString+0xd2>
		}
		else if(str[i] == '('){
			code = KEY_9;
			modifier = UPPER;
    5406:	6e 2d       	mov	r22, r14
		modifier = LOWER;
		if(str[i] == ' '){
			code = KEY_SPACE;
		}
		else if(str[i] == '('){
			code = KEY_9;
    5408:	86 e2       	ldi	r24, 0x26	; 38
    540a:	1d c0       	rjmp	.+58     	; 0x5446 <USBSendString+0xd2>
			modifier = UPPER;
		}
		else if(str[i] == ')'){
			code = KEY_0;
			modifier = UPPER;
    540c:	6e 2d       	mov	r22, r14
		else if(str[i] == '('){
			code = KEY_9;
			modifier = UPPER;
		}
		else if(str[i] == ')'){
			code = KEY_0;
    540e:	87 e2       	ldi	r24, 0x27	; 39
    5410:	1a c0       	rjmp	.+52     	; 0x5446 <USBSendString+0xd2>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5412:	6f 2d       	mov	r22, r15
		else if(str[i] == ')'){
			code = KEY_0;
			modifier = UPPER;
		}
		else if(str[i] == '/'){
			code = KEY_SLASH;
    5414:	88 e3       	ldi	r24, 0x38	; 56
    5416:	17 c0       	rjmp	.+46     	; 0x5446 <USBSendString+0xd2>
		}
		else if(str[i] == '?'){
			code = KEY_SLASH;
			modifier = UPPER;
    5418:	6e 2d       	mov	r22, r14
		}
		else if(str[i] == '/'){
			code = KEY_SLASH;
		}
		else if(str[i] == '?'){
			code = KEY_SLASH;
    541a:	88 e3       	ldi	r24, 0x38	; 56
    541c:	14 c0       	rjmp	.+40     	; 0x5446 <USBSendString+0xd2>
			modifier = UPPER;
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
    541e:	6e 2d       	mov	r22, r14
		else if(str[i] == '?'){
			code = KEY_SLASH;
			modifier = UPPER;
		}
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
    5420:	83 e3       	ldi	r24, 0x33	; 51
    5422:	11 c0       	rjmp	.+34     	; 0x5446 <USBSendString+0xd2>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5424:	6f 2d       	mov	r22, r15
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
			code = KEY_ENTER;
    5426:	88 e2       	ldi	r24, 0x28	; 40
    5428:	0e c0       	rjmp	.+28     	; 0x5446 <USBSendString+0xd2>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    542a:	6f 2d       	mov	r22, r15
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
			code = KEY_ENTER;
    542c:	88 e2       	ldi	r24, 0x28	; 40
    542e:	0b c0       	rjmp	.+22     	; 0x5446 <USBSendString+0xd2>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5430:	6f 2d       	mov	r22, r15
		}
		else if((str[i] == '\r')||(str[i] == '\n')){
			code = KEY_ENTER;
		}
		else if(str[i] == '.'){
			code = KEY_PERIOD;
    5432:	87 e3       	ldi	r24, 0x37	; 55
    5434:	08 c0       	rjmp	.+16     	; 0x5446 <USBSendString+0xd2>
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if(str[i] == '='){
			code = KEY_EQ;
			modifier = LOWER;
    5436:	6f 2d       	mov	r22, r15
		else if(str[i] == ':'){
			code = HID_KEYBOARD_SC_SEMICOLON_AND_COLON;
			modifier = UPPER;
		}
		else if(str[i] == '='){
			code = KEY_EQ;
    5438:	8e e2       	ldi	r24, 0x2E	; 46
    543a:	05 c0       	rjmp	.+10     	; 0x5446 <USBSendString+0xd2>
			modifier = LOWER;
		}
		else if(str[i] == '!'){
			code = KEY_1;
			modifier = UPPER;
    543c:	6e 2d       	mov	r22, r14
		else if(str[i] == '='){
			code = KEY_EQ;
			modifier = LOWER;
		}
		else if(str[i] == '!'){
			code = KEY_1;
    543e:	8d 2d       	mov	r24, r13
    5440:	02 c0       	rjmp	.+4      	; 0x5446 <USBSendString+0xd2>
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
		modifier = LOWER;
    5442:	6f 2d       	mov	r22, r15
		else if(str[i] == '!'){
			code = KEY_1;
			modifier = UPPER;
		}
		else if(str[i] == '0'){
			code = KEY_0;
    5444:	87 e2       	ldi	r24, 0x27	; 39
		else{
			code = toupper(str[i]);//make sure code is uppercase.
			code = code-ASCII_A+KEY_A;  //Convert the character (which is uppercase Ascii)  to an USB HID Keycode.
			modifier = UPPER;
		}
		USBSend(code,modifier);
    5446:	52 df       	rcall	.-348    	; 0x52ec <USBSend>
    5448:	2f e7       	ldi	r18, 0x7F	; 127
    544a:	88 e3       	ldi	r24, 0x38	; 56
    544c:	91 e0       	ldi	r25, 0x01	; 1
    544e:	21 50       	subi	r18, 0x01	; 1
    5450:	80 40       	sbci	r24, 0x00	; 0
    5452:	90 40       	sbci	r25, 0x00	; 0
    5454:	e1 f7       	brne	.-8      	; 0x544e <USBSendString+0xda>
    5456:	00 c0       	rjmp	.+0      	; 0x5458 <USBSendString+0xe4>
    5458:	00 00       	nop
void USBSendString(char *str){
	int length;
	uint8_t code;
	uint8_t modifier;
	length = strlen(str);
	for (int i=0; i<length; i++){
    545a:	c0 17       	cp	r28, r16
    545c:	d1 07       	cpc	r29, r17
    545e:	09 f0       	breq	.+2      	; 0x5462 <USBSendString+0xee>
    5460:	a7 cf       	rjmp	.-178    	; 0x53b0 <USBSendString+0x3c>
			modifier = UPPER;
		}
		USBSend(code,modifier);
		Delay_MS(STRING_SEND_DELAY);
	}
} 
    5462:	df 91       	pop	r29
    5464:	cf 91       	pop	r28
    5466:	1f 91       	pop	r17
    5468:	0f 91       	pop	r16
    546a:	ff 90       	pop	r15
    546c:	ef 90       	pop	r14
    546e:	df 90       	pop	r13
    5470:	08 95       	ret

00005472 <USBSendPROGString>:

/*Send a string literal over USB, using a string stored in program memory instead of data memory (this saves on data RAM)*/
void USBSendPROGString(const char*  ProgStr){
	strcpy_P(StringBuffer, (char*) ProgStr);
    5472:	bc 01       	movw	r22, r24
    5474:	89 ea       	ldi	r24, 0xA9	; 169
    5476:	97 e0       	ldi	r25, 0x07	; 7
    5478:	0e 94 c2 39 	call	0x7384	; 0x7384 <strcpy_P>
	USBSendString(StringBuffer);
    547c:	89 ea       	ldi	r24, 0xA9	; 169
    547e:	97 e0       	ldi	r25, 0x07	; 7
    5480:	79 cf       	rjmp	.-270    	; 0x5374 <USBSendString>
    5482:	08 95       	ret

00005484 <USBSendNumber>:
}

/*Send a number between 0 and 255 over usb)*/
void USBSendNumber(uint8_t number){
    5484:	1f 93       	push	r17
    5486:	cf 93       	push	r28
    5488:	df 93       	push	r29
    548a:	28 2f       	mov	r18, r24
	uint8_t ones ;
	uint8_t tens;
	
	ones = number%10;
    548c:	cd ec       	ldi	r28, 0xCD	; 205
    548e:	8c 9f       	mul	r24, r28
    5490:	c1 2d       	mov	r28, r1
    5492:	11 24       	eor	r1, r1
    5494:	c6 95       	lsr	r28
    5496:	c6 95       	lsr	r28
    5498:	c6 95       	lsr	r28
    549a:	cc 0f       	add	r28, r28
    549c:	8c 2f       	mov	r24, r28
    549e:	88 0f       	add	r24, r24
    54a0:	88 0f       	add	r24, r24
    54a2:	c8 0f       	add	r28, r24
    54a4:	82 2f       	mov	r24, r18
    54a6:	8c 1b       	sub	r24, r28
    54a8:	c8 2f       	mov	r28, r24
	tens = ((number - ones)%100)/10;
    54aa:	82 2f       	mov	r24, r18
    54ac:	90 e0       	ldi	r25, 0x00	; 0
    54ae:	8c 1b       	sub	r24, r28
    54b0:	91 09       	sbc	r25, r1
    54b2:	64 e6       	ldi	r22, 0x64	; 100
    54b4:	70 e0       	ldi	r23, 0x00	; 0
    54b6:	0e 94 f4 38 	call	0x71e8	; 0x71e8 <__divmodhi4>
    54ba:	6a e0       	ldi	r22, 0x0A	; 10
    54bc:	70 e0       	ldi	r23, 0x00	; 0
    54be:	0e 94 f4 38 	call	0x71e8	; 0x71e8 <__divmodhi4>
    54c2:	d6 2f       	mov	r29, r22
    54c4:	16 2f       	mov	r17, r22
	
	if (number >= 200){
    54c6:	28 3c       	cpi	r18, 0xC8	; 200
    54c8:	20 f0       	brcs	.+8      	; 0x54d2 <USBSendNumber+0x4e>
		USBSend(KEY_2,LOWER);
    54ca:	60 e0       	ldi	r22, 0x00	; 0
    54cc:	8f e1       	ldi	r24, 0x1F	; 31
    54ce:	0e df       	rcall	.-484    	; 0x52ec <USBSend>
    54d0:	05 c0       	rjmp	.+10     	; 0x54dc <USBSendNumber+0x58>
	}
	else if (number >= 100){
    54d2:	24 36       	cpi	r18, 0x64	; 100
    54d4:	18 f0       	brcs	.+6      	; 0x54dc <USBSendNumber+0x58>
		USBSend(KEY_1,LOWER);
    54d6:	60 e0       	ldi	r22, 0x00	; 0
    54d8:	8e e1       	ldi	r24, 0x1E	; 30
    54da:	08 df       	rcall	.-496    	; 0x52ec <USBSend>
	}
	
	if (tens != 0){
    54dc:	11 23       	and	r17, r17
    54de:	29 f0       	breq	.+10     	; 0x54ea <USBSendNumber+0x66>
		USBSend(29+tens,LOWER);
    54e0:	60 e0       	ldi	r22, 0x00	; 0
    54e2:	8d e1       	ldi	r24, 0x1D	; 29
    54e4:	8d 0f       	add	r24, r29
    54e6:	02 df       	rcall	.-508    	; 0x52ec <USBSend>
    54e8:	03 c0       	rjmp	.+6      	; 0x54f0 <USBSendNumber+0x6c>
	}
	else{
		USBSend(39,LOWER);
    54ea:	60 e0       	ldi	r22, 0x00	; 0
    54ec:	87 e2       	ldi	r24, 0x27	; 39
    54ee:	fe de       	rcall	.-516    	; 0x52ec <USBSend>
    54f0:	9f ef       	ldi	r25, 0xFF	; 255
    54f2:	20 e7       	ldi	r18, 0x70	; 112
    54f4:	82 e0       	ldi	r24, 0x02	; 2
    54f6:	91 50       	subi	r25, 0x01	; 1
    54f8:	20 40       	sbci	r18, 0x00	; 0
    54fa:	80 40       	sbci	r24, 0x00	; 0
    54fc:	e1 f7       	brne	.-8      	; 0x54f6 <USBSendNumber+0x72>
    54fe:	00 c0       	rjmp	.+0      	; 0x5500 <USBSendNumber+0x7c>
    5500:	00 00       	nop
	}

	Delay_MS(100);
	
	if (ones!=0){
    5502:	cc 23       	and	r28, r28
    5504:	29 f0       	breq	.+10     	; 0x5510 <USBSendNumber+0x8c>
		USBSend(29+ones,LOWER);
    5506:	60 e0       	ldi	r22, 0x00	; 0
    5508:	8d e1       	ldi	r24, 0x1D	; 29
    550a:	8c 0f       	add	r24, r28
    550c:	ef de       	rcall	.-546    	; 0x52ec <USBSend>
    550e:	03 c0       	rjmp	.+6      	; 0x5516 <USBSendNumber+0x92>
	}
	else{
		USBSend(39,LOWER);
    5510:	60 e0       	ldi	r22, 0x00	; 0
    5512:	87 e2       	ldi	r24, 0x27	; 39
    5514:	eb de       	rcall	.-554    	; 0x52ec <USBSend>
    5516:	9f ef       	ldi	r25, 0xFF	; 255
    5518:	20 e7       	ldi	r18, 0x70	; 112
    551a:	82 e0       	ldi	r24, 0x02	; 2
    551c:	91 50       	subi	r25, 0x01	; 1
    551e:	20 40       	sbci	r18, 0x00	; 0
    5520:	80 40       	sbci	r24, 0x00	; 0
    5522:	e1 f7       	brne	.-8      	; 0x551c <USBSendNumber+0x98>
    5524:	00 c0       	rjmp	.+0      	; 0x5526 <USBSendNumber+0xa2>
    5526:	00 00       	nop
	}
	
	Delay_MS(100);

}
    5528:	df 91       	pop	r29
    552a:	cf 91       	pop	r28
    552c:	1f 91       	pop	r17
    552e:	08 95       	ret

00005530 <GetModifier>:

uint8_t GetModifier(){
	uint8_t Modifier = 0;
	bool ShiftIsPressed = false;
	
	switch (Shift_Reed){
    5530:	80 91 1e 07 	lds	r24, 0x071E
    5534:	82 30       	cpi	r24, 0x02	; 2
    5536:	99 f0       	breq	.+38     	; 0x555e <GetModifier+0x2e>
    5538:	18 f4       	brcc	.+6      	; 0x5540 <GetModifier+0x10>
    553a:	81 30       	cpi	r24, 0x01	; 1
    553c:	31 f0       	breq	.+12     	; 0x554a <GetModifier+0x1a>
    553e:	2f c0       	rjmp	.+94     	; 0x559e <GetModifier+0x6e>
    5540:	83 30       	cpi	r24, 0x03	; 3
    5542:	c1 f0       	breq	.+48     	; 0x5574 <GetModifier+0x44>
    5544:	84 30       	cpi	r24, 0x04	; 4
    5546:	09 f1       	breq	.+66     	; 0x558a <GetModifier+0x5a>
    5548:	2a c0       	rjmp	.+84     	; 0x559e <GetModifier+0x6e>
	case 0: ShiftIsPressed = false; break;// if shift reed is 0, no shift key has been programed;
	case 1: ShiftIsPressed = (is_high(REED_1) == Reed1Polarity); break; //test if reed_1 is at the active level (high/low) indicated by reed1polarity
    554a:	99 b1       	in	r25, 0x09	; 9
    554c:	92 95       	swap	r25
    554e:	91 70       	andi	r25, 0x01	; 1
    5550:	81 e0       	ldi	r24, 0x01	; 1
    5552:	20 91 25 07 	lds	r18, 0x0725
    5556:	92 17       	cp	r25, r18
    5558:	19 f1       	breq	.+70     	; 0x55a0 <GetModifier+0x70>
    555a:	80 e0       	ldi	r24, 0x00	; 0
    555c:	21 c0       	rjmp	.+66     	; 0x55a0 <GetModifier+0x70>
	case 2: ShiftIsPressed = (is_high(REED_2) == Reed2Polarity); break;
    555e:	99 b1       	in	r25, 0x09	; 9
    5560:	96 fb       	bst	r25, 6
    5562:	99 27       	eor	r25, r25
    5564:	90 f9       	bld	r25, 0
    5566:	81 e0       	ldi	r24, 0x01	; 1
    5568:	20 91 d5 06 	lds	r18, 0x06D5
    556c:	92 17       	cp	r25, r18
    556e:	c1 f0       	breq	.+48     	; 0x55a0 <GetModifier+0x70>
    5570:	80 e0       	ldi	r24, 0x00	; 0
    5572:	16 c0       	rjmp	.+44     	; 0x55a0 <GetModifier+0x70>
	case 3: ShiftIsPressed = (is_high(REED_3) == Reed3Polarity); break;
    5574:	99 b1       	in	r25, 0x09	; 9
    5576:	99 1f       	adc	r25, r25
    5578:	99 27       	eor	r25, r25
    557a:	99 1f       	adc	r25, r25
    557c:	81 e0       	ldi	r24, 0x01	; 1
    557e:	20 91 a7 07 	lds	r18, 0x07A7
    5582:	92 17       	cp	r25, r18
    5584:	69 f0       	breq	.+26     	; 0x55a0 <GetModifier+0x70>
    5586:	80 e0       	ldi	r24, 0x00	; 0
    5588:	0b c0       	rjmp	.+22     	; 0x55a0 <GetModifier+0x70>
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
    558a:	93 b1       	in	r25, 0x03	; 3
    558c:	92 95       	swap	r25
    558e:	91 70       	andi	r25, 0x01	; 1
    5590:	81 e0       	ldi	r24, 0x01	; 1
    5592:	20 91 e5 07 	lds	r18, 0x07E5
    5596:	92 17       	cp	r25, r18
    5598:	19 f0       	breq	.+6      	; 0x55a0 <GetModifier+0x70>
    559a:	80 e0       	ldi	r24, 0x00	; 0
    559c:	01 c0       	rjmp	.+2      	; 0x55a0 <GetModifier+0x70>
uint8_t GetModifier(){
	uint8_t Modifier = 0;
	bool ShiftIsPressed = false;
	
	switch (Shift_Reed){
	case 0: ShiftIsPressed = false; break;// if shift reed is 0, no shift key has been programed;
    559e:	80 e0       	ldi	r24, 0x00	; 0
	case 3: ShiftIsPressed = (is_high(REED_3) == Reed3Polarity); break;
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
	default: ShiftIsPressed = false;
	}
	
	if(ShiftIsPressed) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTSHIFT;}
    55a0:	88 23       	and	r24, r24
    55a2:	11 f0       	breq	.+4      	; 0x55a8 <GetModifier+0x78>
    55a4:	82 e0       	ldi	r24, 0x02	; 2
    55a6:	01 c0       	rjmp	.+2      	; 0x55aa <GetModifier+0x7a>

const uint8_t REED_BITS[] = {62,61,60,59}; //these are the bits of the sensor array that represent the reed switches


uint8_t GetModifier(){
	uint8_t Modifier = 0;
    55a8:	80 e0       	ldi	r24, 0x00	; 0
	case 4: ShiftIsPressed = (is_high(REED_4) == Reed4Polarity); break;
	default: ShiftIsPressed = false;
	}
	
	if(ShiftIsPressed) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTSHIFT;}
	if(is_low(CTRL_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTCTRL;}
    55aa:	7c 9b       	sbis	0x0f, 4	; 15
    55ac:	81 60       	ori	r24, 0x01	; 1
	if(is_low(ALT_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTALT;}
    55ae:	7d 9b       	sbis	0x0f, 5	; 15
    55b0:	84 60       	ori	r24, 0x04	; 4
	if(is_low(CMD_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTGUI;}
    55b2:	7e 9b       	sbis	0x0f, 6	; 15
    55b4:	88 60       	ori	r24, 0x08	; 8
	
	return Modifier;
}
    55b6:	08 95       	ret

000055b8 <ReadSensor>:
			return 0; //if no keys or reeds need sending, return 0
		}

}

unsigned long long ReadSensor(){
    55b8:	4f 92       	push	r4
    55ba:	5f 92       	push	r5
    55bc:	6f 92       	push	r6
    55be:	7f 92       	push	r7
    55c0:	8f 92       	push	r8
    55c2:	9f 92       	push	r9
    55c4:	af 92       	push	r10
    55c6:	bf 92       	push	r11
    55c8:	df 92       	push	r13
    55ca:	ef 92       	push	r14
    55cc:	ff 92       	push	r15
    55ce:	0f 93       	push	r16
    55d0:	1f 93       	push	r17
    55d2:	cf 93       	push	r28
    55d4:	df 93       	push	r29
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    55d6:	f8 94       	cli
		unsigned long long Readout = 0;	
		bool HallReading;
		
		GlobalInterruptDisable();
		set_high(SENSE_CLK);
    55d8:	72 9a       	sbi	0x0e, 2	; 14
    55da:	8f ec       	ldi	r24, 0xCF	; 207
    55dc:	97 e0       	ldi	r25, 0x07	; 7
    55de:	01 97       	sbiw	r24, 0x01	; 1
    55e0:	f1 f7       	brne	.-4      	; 0x55de <ReadSensor+0x26>
    55e2:	00 c0       	rjmp	.+0      	; 0x55e4 <ReadSensor+0x2c>
    55e4:	00 00       	nop
		Delay_MS(1); //Sensor board has an LP filter and an inverter on the _LOAD signal.  Wait X ms for the low-pass filter on the _LOAD signal to fire low. 
		set_low(SENSE_CLK);
    55e6:	72 98       	cbi	0x0e, 2	; 14
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    55e8:	78 94       	sei
    55ea:	8f ec       	ldi	r24, 0xCF	; 207
    55ec:	97 e0       	ldi	r25, 0x07	; 7
    55ee:	01 97       	sbiw	r24, 0x01	; 1
    55f0:	f1 f7       	brne	.-4      	; 0x55ee <ReadSensor+0x36>
    55f2:	00 c0       	rjmp	.+0      	; 0x55f4 <ReadSensor+0x3c>
    55f4:	00 00       	nop
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
    55f6:	e0 e0       	ldi	r30, 0x00	; 0
    55f8:	f0 e0       	ldi	r31, 0x00	; 0
		}

}

unsigned long long ReadSensor(){
		unsigned long long Readout = 0;	
    55fa:	d1 2c       	mov	r13, r1
    55fc:	e1 2c       	mov	r14, r1
    55fe:	f1 2c       	mov	r15, r1
    5600:	10 e0       	ldi	r17, 0x00	; 0
    5602:	d0 e0       	ldi	r29, 0x00	; 0
    5604:	c0 e0       	ldi	r28, 0x00	; 0
    5606:	b0 e0       	ldi	r27, 0x00	; 0
    5608:	a0 e0       	ldi	r26, 0x00	; 0
		set_low(SENSE_CLK);
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
			if (is_low(SENSE_SER)) { 
    560a:	1d 99       	sbic	0x03, 5	; 3
    560c:	13 c0       	rjmp	.+38     	; 0x5634 <ReadSensor+0x7c>
				longlongbit_set(Readout,i);// if the readout for one of the sensor pins comes back low, that key has been pressed -- store it as a 1 in the readout.
    560e:	21 e0       	ldi	r18, 0x01	; 1
    5610:	30 e0       	ldi	r19, 0x00	; 0
    5612:	40 e0       	ldi	r20, 0x00	; 0
    5614:	50 e0       	ldi	r21, 0x00	; 0
    5616:	60 e0       	ldi	r22, 0x00	; 0
    5618:	70 e0       	ldi	r23, 0x00	; 0
    561a:	80 e0       	ldi	r24, 0x00	; 0
    561c:	90 e0       	ldi	r25, 0x00	; 0
    561e:	0e 2f       	mov	r16, r30
    5620:	0e 94 3b 39 	call	0x7276	; 0x7276 <__ashldi3>
    5624:	d2 2a       	or	r13, r18
    5626:	e3 2a       	or	r14, r19
    5628:	f4 2a       	or	r15, r20
    562a:	15 2b       	or	r17, r21
    562c:	d6 2b       	or	r29, r22
    562e:	c7 2b       	or	r28, r23
    5630:	b8 2b       	or	r27, r24
    5632:	a9 2b       	or	r26, r25
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    5634:	f8 94       	cli
			}	
			
			GlobalInterruptDisable();//if sense clk stays high too long, it could falsely trigger _Load signal.
			set_high(SENSE_CLK);
    5636:	72 9a       	sbi	0x0e, 2	; 14
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5638:	9a e1       	ldi	r25, 0x1A	; 26
    563a:	9a 95       	dec	r25
    563c:	f1 f7       	brne	.-4      	; 0x563a <ReadSensor+0x82>
    563e:	00 c0       	rjmp	.+0      	; 0x5640 <ReadSensor+0x88>
			_delay_us(CLK_POS_PULSE); //delay for the required pulsewidth
			set_low(SENSE_CLK);
    5640:	72 98       	cbi	0x0e, 2	; 14
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    5642:	78 94       	sei
    5644:	8a e6       	ldi	r24, 0x6A	; 106
    5646:	8a 95       	dec	r24
    5648:	f1 f7       	brne	.-4      	; 0x5646 <ReadSensor+0x8e>
    564a:	00 c0       	rjmp	.+0      	; 0x564c <ReadSensor+0x94>
		Delay_MS(1); //Sensor board has an LP filter and an inverter on the _LOAD signal.  Wait X ms for the low-pass filter on the _LOAD signal to fire low. 
		set_low(SENSE_CLK);
		GlobalInterruptEnable();
		Delay_MS(1); //Discharge the LP filter, sending _LOAD high.  This also takes X ms
		
		for (int i=0;i<SHIFT_REGISTER_PINS;i++){   //loop through every bit in readout. i=0 is the first contact (actually the 8th one on the board)
    564c:	31 96       	adiw	r30, 0x01	; 1
    564e:	e0 33       	cpi	r30, 0x30	; 48
    5650:	f1 05       	cpc	r31, r1
    5652:	d9 f6       	brne	.-74     	; 0x560a <ReadSensor+0x52>

		}
		
		/*The hall effect sensor on the end of the sensor board is only installed in certain cases -
		- its job is to tell if the entire crossbar has moved(active), or if it is at rest (therefore no keys should be detected)*/
		if(UseHallSensor == HALL_ACTIVE){ //when the hall effect sensor is installed and activated
    5654:	80 91 a8 07 	lds	r24, 0x07A8
    5658:	82 30       	cpi	r24, 0x02	; 2
    565a:	f1 f4       	brne	.+60     	; 0x5698 <ReadSensor+0xe0>
			HallReading = Readout & LONGLONGBIT(HALL_SENSOR_BIT); //one of the bits of the sensor readout gives the state of the hall sensor
    565c:	2d 2d       	mov	r18, r13
    565e:	3e 2d       	mov	r19, r14
    5660:	4f 2d       	mov	r20, r15
    5662:	51 2f       	mov	r21, r17
    5664:	6d 2f       	mov	r22, r29
    5666:	7c 2f       	mov	r23, r28
    5668:	8b 2f       	mov	r24, r27
    566a:	9a 2f       	mov	r25, r26
    566c:	0c e2       	ldi	r16, 0x2C	; 44
    566e:	0e 94 56 39 	call	0x72ac	; 0x72ac <__lshrdi3>
    5672:	42 2e       	mov	r4, r18
    5674:	53 2e       	mov	r5, r19
    5676:	c2 01       	movw	r24, r4
    5678:	81 70       	andi	r24, 0x01	; 1
    567a:	99 27       	eor	r25, r25
			if(HallReading != HallSensorPolarity){
    567c:	20 91 24 07 	lds	r18, 0x0724
    5680:	30 e0       	ldi	r19, 0x00	; 0
    5682:	82 17       	cp	r24, r18
    5684:	93 07       	cpc	r25, r19
    5686:	41 f0       	breq	.+16     	; 0x5698 <ReadSensor+0xe0>
				Readout = 0; //then if the hall effect sensor is not triggered, readout of keys is invalid -- clear it (including the hall sensor bit). 
    5688:	d1 2c       	mov	r13, r1
    568a:	e1 2c       	mov	r14, r1
    568c:	f1 2c       	mov	r15, r1
    568e:	10 e0       	ldi	r17, 0x00	; 0
    5690:	d0 e0       	ldi	r29, 0x00	; 0
    5692:	c0 e0       	ldi	r28, 0x00	; 0
    5694:	b0 e0       	ldi	r27, 0x00	; 0
    5696:	a0 e0       	ldi	r26, 0x00	; 0
			}
		}

		//add the reed switches to the last 4 bits of the readout array -- if the reed switch is for the shift key, ignore it!
		if (Shift_Reed != 1 && is_high(REED_1)==(bool)Reed1Polarity){ Readout |= LONGLONGBIT(REED_BITS[0]);} //63rd bit of readout (or something like that) represents Reed1
    5698:	80 91 1e 07 	lds	r24, 0x071E
    569c:	81 30       	cpi	r24, 0x01	; 1
    569e:	49 f1       	breq	.+82     	; 0x56f2 <ReadSensor+0x13a>
    56a0:	99 b1       	in	r25, 0x09	; 9
    56a2:	92 95       	swap	r25
    56a4:	91 70       	andi	r25, 0x01	; 1
    56a6:	20 91 25 07 	lds	r18, 0x0725
    56aa:	92 13       	cpse	r25, r18
    56ac:	01 c0       	rjmp	.+2      	; 0x56b0 <ReadSensor+0xf8>
    56ae:	a0 64       	ori	r26, 0x40	; 64
		if (Shift_Reed != 2 && is_high(REED_2)==(bool)Reed2Polarity){ Readout |= LONGLONGBIT(REED_BITS[1]);} //62nd bit of readout (or something like that) represents Reed2
    56b0:	82 30       	cpi	r24, 0x02	; 2
    56b2:	41 f1       	breq	.+80     	; 0x5704 <ReadSensor+0x14c>
    56b4:	99 b1       	in	r25, 0x09	; 9
    56b6:	96 fb       	bst	r25, 6
    56b8:	99 27       	eor	r25, r25
    56ba:	90 f9       	bld	r25, 0
    56bc:	20 91 d5 06 	lds	r18, 0x06D5
    56c0:	92 13       	cpse	r25, r18
    56c2:	01 c0       	rjmp	.+2      	; 0x56c6 <ReadSensor+0x10e>
    56c4:	a0 62       	ori	r26, 0x20	; 32
		if (Shift_Reed != 3 && is_high(REED_3)==(bool)Reed3Polarity){ Readout |= LONGLONGBIT(REED_BITS[2]);} //61st bit of readout (or something like that) represents Reed3
    56c6:	83 30       	cpi	r24, 0x03	; 3
    56c8:	59 f0       	breq	.+22     	; 0x56e0 <ReadSensor+0x128>
    56ca:	99 b1       	in	r25, 0x09	; 9
    56cc:	99 1f       	adc	r25, r25
    56ce:	99 27       	eor	r25, r25
    56d0:	99 1f       	adc	r25, r25
    56d2:	20 91 a7 07 	lds	r18, 0x07A7
    56d6:	92 13       	cpse	r25, r18
    56d8:	01 c0       	rjmp	.+2      	; 0x56dc <ReadSensor+0x124>
    56da:	a0 61       	ori	r26, 0x10	; 16
		if (Shift_Reed != 4 && is_high(REED_4)==(bool)Reed4Polarity){ Readout |= LONGLONGBIT(REED_BITS[3]);} //60th bit of readout (or something like that) represents Reed4
    56dc:	84 30       	cpi	r24, 0x04	; 4
    56de:	d9 f0       	breq	.+54     	; 0x5716 <ReadSensor+0x15e>
    56e0:	83 b1       	in	r24, 0x03	; 3
    56e2:	82 95       	swap	r24
    56e4:	81 70       	andi	r24, 0x01	; 1
    56e6:	90 91 e5 07 	lds	r25, 0x07E5
    56ea:	89 13       	cpse	r24, r25
    56ec:	14 c0       	rjmp	.+40     	; 0x5716 <ReadSensor+0x15e>
    56ee:	a8 60       	ori	r26, 0x08	; 8
    56f0:	12 c0       	rjmp	.+36     	; 0x5716 <ReadSensor+0x15e>
			}
		}

		//add the reed switches to the last 4 bits of the readout array -- if the reed switch is for the shift key, ignore it!
		if (Shift_Reed != 1 && is_high(REED_1)==(bool)Reed1Polarity){ Readout |= LONGLONGBIT(REED_BITS[0]);} //63rd bit of readout (or something like that) represents Reed1
		if (Shift_Reed != 2 && is_high(REED_2)==(bool)Reed2Polarity){ Readout |= LONGLONGBIT(REED_BITS[1]);} //62nd bit of readout (or something like that) represents Reed2
    56f2:	99 b1       	in	r25, 0x09	; 9
    56f4:	96 fb       	bst	r25, 6
    56f6:	99 27       	eor	r25, r25
    56f8:	90 f9       	bld	r25, 0
    56fa:	20 91 d5 06 	lds	r18, 0x06D5
    56fe:	92 13       	cpse	r25, r18
    5700:	e4 cf       	rjmp	.-56     	; 0x56ca <ReadSensor+0x112>
    5702:	e0 cf       	rjmp	.-64     	; 0x56c4 <ReadSensor+0x10c>
		if (Shift_Reed != 3 && is_high(REED_3)==(bool)Reed3Polarity){ Readout |= LONGLONGBIT(REED_BITS[2]);} //61st bit of readout (or something like that) represents Reed3
    5704:	99 b1       	in	r25, 0x09	; 9
    5706:	99 1f       	adc	r25, r25
    5708:	99 27       	eor	r25, r25
    570a:	99 1f       	adc	r25, r25
    570c:	20 91 a7 07 	lds	r18, 0x07A7
    5710:	92 13       	cpse	r25, r18
    5712:	e6 cf       	rjmp	.-52     	; 0x56e0 <ReadSensor+0x128>
    5714:	e2 cf       	rjmp	.-60     	; 0x56da <ReadSensor+0x122>
		if (Shift_Reed != 4 && is_high(REED_4)==(bool)Reed4Polarity){ Readout |= LONGLONGBIT(REED_BITS[3]);} //60th bit of readout (or something like that) represents Reed4
		
		return Readout;
}
    5716:	2d 2d       	mov	r18, r13
    5718:	3e 2d       	mov	r19, r14
    571a:	4f 2d       	mov	r20, r15
    571c:	51 2f       	mov	r21, r17
    571e:	6d 2f       	mov	r22, r29
    5720:	7c 2f       	mov	r23, r28
    5722:	8b 2f       	mov	r24, r27
    5724:	9a 2f       	mov	r25, r26
    5726:	df 91       	pop	r29
    5728:	cf 91       	pop	r28
    572a:	1f 91       	pop	r17
    572c:	0f 91       	pop	r16
    572e:	ff 90       	pop	r15
    5730:	ef 90       	pop	r14
    5732:	df 90       	pop	r13
    5734:	bf 90       	pop	r11
    5736:	af 90       	pop	r10
    5738:	9f 90       	pop	r9
    573a:	8f 90       	pop	r8
    573c:	7f 90       	pop	r7
    573e:	6f 90       	pop	r6
    5740:	5f 90       	pop	r5
    5742:	4f 90       	pop	r4
    5744:	08 95       	ret

00005746 <GetKeySimple>:
	if(is_low(CMD_KEY)) {Modifier |= HID_KEYBOARD_MODIFIER_LEFTGUI;}
	
	return Modifier;
}

uint8_t GetKeySimple(){
    5746:	ff 92       	push	r15
    5748:	0f 93       	push	r16
    574a:	1f 93       	push	r17
    574c:	cf 93       	push	r28
    574e:	df 93       	push	r29
	unsigned long long SensorReadout; //create 64-bit "long long" binary variable and set it all to 0s.
	uint8_t Key;
	
	Key=0;//by default, there is no key to send, unless one is detected later.
	
	SensorReadout = ReadSensor();
    5750:	33 df       	rcall	.-410    	; 0x55b8 <ReadSensor>
    5752:	f2 2e       	mov	r15, r18
    5754:	03 2f       	mov	r16, r19
    5756:	14 2f       	mov	r17, r20
    5758:	d5 2f       	mov	r29, r21
    575a:	c6 2f       	mov	r28, r22
    575c:	e7 2f       	mov	r30, r23
    575e:	b8 2f       	mov	r27, r24
    5760:	f9 2f       	mov	r31, r25
	if(UseHallSensor != HALL_NOT_PRESENT){
    5762:	80 91 a8 07 	lds	r24, 0x07A8
    5766:	81 11       	cpse	r24, r1
		SensorReadout &= ~LONGLONGBIT(HALL_SENSOR_BIT); //discard the hall effect bit of the array -- it is not an actual key, so don't report it as one.
    5768:	ef 7e       	andi	r30, 0xEF	; 239
	}

	if(SensorReadout){
    576a:	2f 2d       	mov	r18, r15
    576c:	30 2f       	mov	r19, r16
    576e:	41 2f       	mov	r20, r17
    5770:	5d 2f       	mov	r21, r29
    5772:	6c 2f       	mov	r22, r28
    5774:	7e 2f       	mov	r23, r30
    5776:	8b 2f       	mov	r24, r27
    5778:	9f 2f       	mov	r25, r31
    577a:	a0 e0       	ldi	r26, 0x00	; 0
    577c:	0e 94 72 39 	call	0x72e4	; 0x72e4 <__cmpdi2_s8>
    5780:	19 f0       	breq	.+6      	; 0x5788 <GetKeySimple+0x42>
		Key = (uint8_t) __builtin_clzll(SensorReadout); //this function finds the first nonzero bit in the bitfield SensorReadout (by counting leading zeros)
    5782:	0e 94 33 39 	call	0x7266	; 0x7266 <__clzdi2>
    5786:	01 c0       	rjmp	.+2      	; 0x578a <GetKeySimple+0x44>
	}
	else{
		Key = 0;
    5788:	80 e0       	ldi	r24, 0x00	; 0
	}
	return  Key;
	
}
    578a:	df 91       	pop	r29
    578c:	cf 91       	pop	r28
    578e:	1f 91       	pop	r17
    5790:	0f 91       	pop	r16
    5792:	ff 90       	pop	r15
    5794:	08 95       	ret

00005796 <GetKey>:
	
uint8_t GetKey(){
    5796:	2f 92       	push	r2
    5798:	3f 92       	push	r3
    579a:	4f 92       	push	r4
    579c:	5f 92       	push	r5
    579e:	6f 92       	push	r6
    57a0:	7f 92       	push	r7
    57a2:	8f 92       	push	r8
    57a4:	9f 92       	push	r9
    57a6:	af 92       	push	r10
    57a8:	bf 92       	push	r11
    57aa:	cf 92       	push	r12
    57ac:	df 92       	push	r13
    57ae:	ef 92       	push	r14
    57b0:	ff 92       	push	r15
    57b2:	0f 93       	push	r16
    57b4:	1f 93       	push	r17
    57b6:	cf 93       	push	r28
    57b8:	df 93       	push	r29
    57ba:	00 d0       	rcall	.+0      	; 0x57bc <GetKey+0x26>
    57bc:	1f 92       	push	r1
    57be:	cd b7       	in	r28, 0x3d	; 61
    57c0:	de b7       	in	r29, 0x3e	; 62
		bool OKtoSendReed = false; //go ahead to send a reed switch
		
		uint8_t ReedToSend = 0;
	
/*READ INPUT FROM SENSOR STRIP*/	
		SensorReadout = ReadSensor();
    57c2:	fa de       	rcall	.-524    	; 0x55b8 <ReadSensor>
    57c4:	82 2e       	mov	r8, r18
    57c6:	93 2e       	mov	r9, r19
    57c8:	a4 2e       	mov	r10, r20
    57ca:	b5 2e       	mov	r11, r21
    57cc:	16 2f       	mov	r17, r22
    57ce:	68 2e       	mov	r6, r24
    57d0:	49 2e       	mov	r4, r25
		
		if (UseHallSensor != HALL_NOT_PRESENT){ //if the user has not installed the hall sensor, don't do this part.
    57d2:	80 91 a8 07 	lds	r24, 0x07A8
    57d6:	81 11       	cpse	r24, r1
			SensorReadout &= ~LONGLONGBIT(HALL_SENSOR_BIT); //after detecting it, discard the hall effect bit of the array -- it is not an actual key, so don't report it as one.
    57d8:	7f 7e       	andi	r23, 0xEF	; 239
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
			int reednumber = i+1;
			int j;
			
			if (Reeds_Are_Independent) j = i; //
    57da:	70 90 d7 06 	lds	r7, 0x06D7
			else j = 0; //setting j = 0 means "If any reed is active, all reeds are considered active also (and are therefore won't be sent when pressed)
			
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
				if (ReedDebounce[i] < ReedHoldTime){//increment the debounce entry if not already maxed out.
    57de:	30 90 1c 07 	lds	r3, 0x071C
    57e2:	8f e8       	ldi	r24, 0x8F	; 143
    57e4:	96 e0       	ldi	r25, 0x06	; 6
    57e6:	0f 2e       	mov	r0, r31
    57e8:	fa ec       	ldi	r31, 0xCA	; 202
    57ea:	ef 2e       	mov	r14, r31
    57ec:	f3 e0       	ldi	r31, 0x03	; 3
    57ee:	ff 2e       	mov	r15, r31
    57f0:	f0 2d       	mov	r31, r0
    57f2:	e0 e0       	ldi	r30, 0x00	; 0
    57f4:	f0 e0       	ldi	r31, 0x00	; 0
		static uint8_t ReedDebounce[4]; //array tracking the debounce times of all four reed switches.  
		
		bool OKtoSendKey = false; //non static bool that gives the go-ahead to send a key over the usb/bluetooth bus.  Indicates that the key has been pressed first time.
		bool OKtoSendReed = false; //go ahead to send a reed switch
		
		uint8_t ReedToSend = 0;
    57f6:	21 2c       	mov	r2, r1
		static uint8_t KeyReleaseCounter;
		static bool ActiveReeds[4];//array showing all currently active reeds.
		static uint8_t ReedDebounce[4]; //array tracking the debounce times of all four reed switches.  
		
		bool OKtoSendKey = false; //non static bool that gives the go-ahead to send a key over the usb/bluetooth bus.  Indicates that the key has been pressed first time.
		bool OKtoSendReed = false; //go ahead to send a reed switch
    57f8:	51 2c       	mov	r5, r1
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
				if (ReedDebounce[i] < ReedHoldTime){//increment the debounce entry if not already maxed out.
					ReedDebounce[i] ++;
				} 
				else if (!ActiveReeds[j]){ //if the debounce has reached KeyHoldTime, but the reed isn't already listed as active
						ActiveReeds[j] = true; //then list it as active.
    57fa:	9b 83       	std	Y+3, r25	; 0x03
    57fc:	8a 83       	std	Y+2, r24	; 0x02
    57fe:	79 83       	std	Y+1, r23	; 0x01
/*READ AND DEBOUNCE REED SWITCH INPUTS*/

		/*Detect which reeds have been pressed, and if they have been sent to the host already or if they still need to be*/
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
			int reednumber = i+1;
    5800:	6f 01       	movw	r12, r30
			int j;
			
			if (Reeds_Are_Independent) j = i; //
    5802:	71 10       	cpse	r7, r1
    5804:	13 c1       	rjmp	.+550    	; 0x5a2c <GetKey+0x296>
    5806:	f8 c0       	rjmp	.+496    	; 0x59f8 <GetKey+0x262>
			else j = 0; //setting j = 0 means "If any reed is active, all reeds are considered active also (and are therefore won't be sent when pressed)
    5808:	c1 2c       	mov	r12, r1
    580a:	d1 2c       	mov	r13, r1
			
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
				if (ReedDebounce[i] < ReedHoldTime){//increment the debounce entry if not already maxed out.
    580c:	aa 81       	ldd	r26, Y+2	; 0x02
    580e:	bb 81       	ldd	r27, Y+3	; 0x03
    5810:	8c 91       	ld	r24, X
    5812:	83 15       	cp	r24, r3
    5814:	18 f4       	brcc	.+6      	; 0x581c <GetKey+0x86>
					ReedDebounce[i] ++;
    5816:	8f 5f       	subi	r24, 0xFF	; 255
    5818:	8c 93       	st	X, r24
    581a:	3b c0       	rjmp	.+118    	; 0x5892 <GetKey+0xfc>
				} 
				else if (!ActiveReeds[j]){ //if the debounce has reached KeyHoldTime, but the reed isn't already listed as active
    581c:	c6 01       	movw	r24, r12
    581e:	85 57       	subi	r24, 0x75	; 117
    5820:	99 4f       	sbci	r25, 0xF9	; 249
    5822:	dc 01       	movw	r26, r24
    5824:	8c 91       	ld	r24, X
    5826:	81 11       	cpse	r24, r1
    5828:	34 c0       	rjmp	.+104    	; 0x5892 <GetKey+0xfc>
						ActiveReeds[j] = true; //then list it as active.
    582a:	21 e0       	ldi	r18, 0x01	; 1
    582c:	2c 93       	st	X, r18
    582e:	22 24       	eor	r2, r2
    5830:	23 94       	inc	r2
    5832:	2e 0e       	add	r2, r30
						ReedToSend = reednumber; //code 1,2,3, or 4 indicates which reed has been pressed
						OKtoSendReed = true;//and tell the routine to send it
    5834:	55 24       	eor	r5, r5
    5836:	53 94       	inc	r5
    5838:	2c c0       	rjmp	.+88     	; 0x5892 <GetKey+0xfc>
				}
			} 
			else if (Reeds_Are_Independent){//if the reed is not detected, and we are tracking them separately.
				if(ReedDebounce[i] == 0) ActiveReeds[j] = false; //then if the debounce counter has run down, consider the reed to be released.
    583a:	aa 81       	ldd	r26, Y+2	; 0x02
    583c:	bb 81       	ldd	r27, Y+3	; 0x03
    583e:	8c 91       	ld	r24, X
    5840:	81 11       	cpse	r24, r1
    5842:	06 c0       	rjmp	.+12     	; 0x5850 <GetKey+0xba>
    5844:	cf 01       	movw	r24, r30
    5846:	85 57       	subi	r24, 0x75	; 117
    5848:	99 4f       	sbci	r25, 0xF9	; 249
    584a:	dc 01       	movw	r26, r24
    584c:	1c 92       	st	X, r1
    584e:	21 c0       	rjmp	.+66     	; 0x5892 <GetKey+0xfc>
				else ReedDebounce[i]--; //if not already zero, decrement the counter
    5850:	81 50       	subi	r24, 0x01	; 1
    5852:	aa 81       	ldd	r26, Y+2	; 0x02
    5854:	bb 81       	ldd	r27, Y+3	; 0x03
    5856:	8c 93       	st	X, r24
    5858:	1c c0       	rjmp	.+56     	; 0x5892 <GetKey+0xfc>
			}
			else if (!Reeds_Are_Independent){ //if reeds are not considered independent, all reeds must be released before another can fire.
				if((ReedDebounce[0] == 0)&&(ReedDebounce[1] == 0)&&(ReedDebounce[2]== 0)&&(ReedDebounce[3]==0)){ //so wait for all reeds to be released
    585a:	af e8       	ldi	r26, 0x8F	; 143
    585c:	b6 e0       	ldi	r27, 0x06	; 6
    585e:	8c 91       	ld	r24, X
    5860:	81 11       	cpse	r24, r1
    5862:	10 c0       	rjmp	.+32     	; 0x5884 <GetKey+0xee>
    5864:	80 91 90 06 	lds	r24, 0x0690
    5868:	81 11       	cpse	r24, r1
    586a:	0c c0       	rjmp	.+24     	; 0x5884 <GetKey+0xee>
    586c:	80 91 91 06 	lds	r24, 0x0691
    5870:	81 11       	cpse	r24, r1
    5872:	08 c0       	rjmp	.+16     	; 0x5884 <GetKey+0xee>
    5874:	80 91 92 06 	lds	r24, 0x0692
    5878:	81 11       	cpse	r24, r1
    587a:	04 c0       	rjmp	.+8      	; 0x5884 <GetKey+0xee>
					ActiveReeds[j] = false; // only if all reeds are released do we allow a new reed to be pressed.
    587c:	ab e8       	ldi	r26, 0x8B	; 139
    587e:	b6 e0       	ldi	r27, 0x06	; 6
    5880:	1c 92       	st	X, r1
    5882:	07 c0       	rjmp	.+14     	; 0x5892 <GetKey+0xfc>
				}
				else if (ReedDebounce[i]) {ReedDebounce[i]--;} //decrement debounce counter for this reed.
    5884:	aa 81       	ldd	r26, Y+2	; 0x02
    5886:	bb 81       	ldd	r27, Y+3	; 0x03
    5888:	8c 91       	ld	r24, X
    588a:	88 23       	and	r24, r24
    588c:	11 f0       	breq	.+4      	; 0x5892 <GetKey+0xfc>
    588e:	81 50       	subi	r24, 0x01	; 1
    5890:	8c 93       	st	X, r24
    5892:	31 96       	adiw	r30, 0x01	; 1
    5894:	8a 81       	ldd	r24, Y+2	; 0x02
    5896:	9b 81       	ldd	r25, Y+3	; 0x03
    5898:	01 96       	adiw	r24, 0x01	; 1
    589a:	9b 83       	std	Y+3, r25	; 0x03
    589c:	8a 83       	std	Y+2, r24	; 0x02
    589e:	9f ef       	ldi	r25, 0xFF	; 255
    58a0:	e9 1a       	sub	r14, r25
    58a2:	f9 0a       	sbc	r15, r25
		
/*READ AND DEBOUNCE REED SWITCH INPUTS*/

		/*Detect which reeds have been pressed, and if they have been sent to the host already or if they still need to be*/
		/*Note: In this code, the term "Active" means that a key is being held down.  If a key is already active, it will not be sent if detected)*/
		for (uint8_t i=0; i<4; i++){
    58a4:	e4 30       	cpi	r30, 0x04	; 4
    58a6:	f1 05       	cpc	r31, r1
    58a8:	09 f0       	breq	.+2      	; 0x58ac <GetKey+0x116>
    58aa:	aa cf       	rjmp	.-172    	; 0x5800 <GetKey+0x6a>
    58ac:	79 81       	ldd	r23, Y+1	; 0x01
		

		

/*APPLY VARIOUS MASKS TO SIMPLIFY SENSOR READOUT*/	
		SensorReadout = SensorReadout & KEY_SENSOR_MASK;//discard the reed switch bits and the sensor bit -- look only at the key sensor contacts.
    58ae:	e8 2c       	mov	r14, r8
    58b0:	f9 2c       	mov	r15, r9
    58b2:	ca 2c       	mov	r12, r10
    58b4:	bb 2d       	mov	r27, r11
    58b6:	f1 2f       	mov	r31, r17
    58b8:	e7 2f       	mov	r30, r23
    58ba:	d1 2c       	mov	r13, r1
    58bc:	00 e0       	ldi	r16, 0x00	; 0
		if (SensorReadout == KEY_SENSOR_MASK){
    58be:	28 2d       	mov	r18, r8
    58c0:	39 2d       	mov	r19, r9
    58c2:	4a 2d       	mov	r20, r10
    58c4:	5b 2d       	mov	r21, r11
    58c6:	61 2f       	mov	r22, r17
    58c8:	80 e0       	ldi	r24, 0x00	; 0
    58ca:	90 e0       	ldi	r25, 0x00	; 0
    58cc:	2f 3f       	cpi	r18, 0xFF	; 255
    58ce:	af ef       	ldi	r26, 0xFF	; 255
    58d0:	3a 07       	cpc	r19, r26
    58d2:	4a 07       	cpc	r20, r26
    58d4:	5a 07       	cpc	r21, r26
    58d6:	6a 07       	cpc	r22, r26
    58d8:	7a 07       	cpc	r23, r26
    58da:	81 05       	cpc	r24, r1
    58dc:	91 05       	cpc	r25, r1
    58de:	09 f4       	brne	.+2      	; 0x58e2 <GetKey+0x14c>
    58e0:	5f c0       	rjmp	.+190    	; 0x59a0 <GetKey+0x20a>
			SensorReadout = 0;// if masked sensor readout is all ones, sensor is probably not plugged in -- discard.
		}
		else if(ActiveKey){
    58e2:	80 91 8a 06 	lds	r24, 0x068A
    58e6:	88 23       	and	r24, r24
    58e8:	a9 f0       	breq	.+42     	; 0x5914 <GetKey+0x17e>
			SensorReadout = (SensorReadout & KEYMASK(ActiveKey)); //if a key was detected last time, mask all others -- only look at that key this time -- prevents confusion from multiple keys.
    58ea:	0f e3       	ldi	r16, 0x3F	; 63
    58ec:	10 e0       	ldi	r17, 0x00	; 0
    58ee:	08 1b       	sub	r16, r24
    58f0:	11 09       	sbc	r17, r1
    58f2:	21 e0       	ldi	r18, 0x01	; 1
    58f4:	30 e0       	ldi	r19, 0x00	; 0
    58f6:	40 e0       	ldi	r20, 0x00	; 0
    58f8:	50 e0       	ldi	r21, 0x00	; 0
    58fa:	60 e0       	ldi	r22, 0x00	; 0
    58fc:	70 e0       	ldi	r23, 0x00	; 0
    58fe:	80 e0       	ldi	r24, 0x00	; 0
    5900:	0e 94 3b 39 	call	0x7276	; 0x7276 <__ashldi3>
    5904:	e2 22       	and	r14, r18
    5906:	f3 22       	and	r15, r19
    5908:	c4 22       	and	r12, r20
    590a:	b5 23       	and	r27, r21
    590c:	f6 23       	and	r31, r22
    590e:	e7 23       	and	r30, r23
    5910:	00 e0       	ldi	r16, 0x00	; 0
    5912:	2e c0       	rjmp	.+92     	; 0x5970 <GetKey+0x1da>
		}
		else if(PreviousKey){ //if no key was detected, but a key was recently detected (maybe it was just released, or maybe it bounced off)
    5914:	90 91 89 06 	lds	r25, 0x0689
    5918:	99 23       	and	r25, r25
    591a:	51 f1       	breq	.+84     	; 0x5970 <GetKey+0x1da>
			DoubleTapCounter++;
    591c:	80 91 88 06 	lds	r24, 0x0688
    5920:	8f 5f       	subi	r24, 0xFF	; 255
    5922:	80 93 88 06 	sts	0x0688, r24
			if (DoubleTapCounter >= DoubleTapTime){ //once the double tap timer has expired, reset everything and stop ignoring previous key.
    5926:	20 91 1d 07 	lds	r18, 0x071D
    592a:	82 17       	cp	r24, r18
    592c:	28 f0       	brcs	.+10     	; 0x5938 <GetKey+0x1a2>
				DoubleTapCounter = 0;
    592e:	10 92 88 06 	sts	0x0688, r1
				PreviousKey = 0; 
    5932:	10 92 89 06 	sts	0x0689, r1
    5936:	1c c0       	rjmp	.+56     	; 0x5970 <GetKey+0x1da>
			}		
			else{ //if timer has not expired yet, ignore the previous key pressed.
				SensorReadout = (SensorReadout & ~KEYMASK(PreviousKey)); //whatever the previous active key pressed was, ignore it.
    5938:	0f e3       	ldi	r16, 0x3F	; 63
    593a:	10 e0       	ldi	r17, 0x00	; 0
    593c:	09 1b       	sub	r16, r25
    593e:	11 09       	sbc	r17, r1
    5940:	21 e0       	ldi	r18, 0x01	; 1
    5942:	30 e0       	ldi	r19, 0x00	; 0
    5944:	40 e0       	ldi	r20, 0x00	; 0
    5946:	50 e0       	ldi	r21, 0x00	; 0
    5948:	60 e0       	ldi	r22, 0x00	; 0
    594a:	70 e0       	ldi	r23, 0x00	; 0
    594c:	80 e0       	ldi	r24, 0x00	; 0
    594e:	90 e0       	ldi	r25, 0x00	; 0
    5950:	0e 94 3b 39 	call	0x7276	; 0x7276 <__ashldi3>
    5954:	20 95       	com	r18
    5956:	30 95       	com	r19
    5958:	40 95       	com	r20
    595a:	50 95       	com	r21
    595c:	60 95       	com	r22
    595e:	70 95       	com	r23
    5960:	e2 22       	and	r14, r18
    5962:	f3 22       	and	r15, r19
    5964:	c4 22       	and	r12, r20
    5966:	b5 23       	and	r27, r21
    5968:	f6 23       	and	r31, r22
    596a:	e7 23       	and	r30, r23
    596c:	d1 2c       	mov	r13, r1
    596e:	00 e0       	ldi	r16, 0x00	; 0
			}
		}
		
/*DETERMINE WHICH CONTACT, IF ANY, HAS DETECTED A KEY THIS ROUND*/	
		if(SensorReadout){ //if sensor readout is not all zeros
    5970:	2e 2d       	mov	r18, r14
    5972:	3f 2d       	mov	r19, r15
    5974:	4c 2d       	mov	r20, r12
    5976:	5b 2f       	mov	r21, r27
    5978:	6f 2f       	mov	r22, r31
    597a:	7e 2f       	mov	r23, r30
    597c:	8d 2d       	mov	r24, r13
    597e:	90 2f       	mov	r25, r16
    5980:	a0 e0       	ldi	r26, 0x00	; 0
    5982:	0e 94 72 39 	call	0x72e4	; 0x72e4 <__cmpdi2_s8>
    5986:	61 f0       	breq	.+24     	; 0x59a0 <GetKey+0x20a>
			DetectedKey = (uint8_t) __builtin_clzll(SensorReadout); //get the position of the first "one" in the sparse key detection array 
    5988:	0e 94 33 39 	call	0x7266	; 0x7266 <__clzdi2>
		else{
			DetectedKey = 0;
		}
		
/*DEBOUNCE KEY READING*/
		if(DetectedKey){//if there is a detected key this time,
    598c:	88 23       	and	r24, r24
    598e:	41 f0       	breq	.+16     	; 0x59a0 <GetKey+0x20a>
			 KeyHoldCounter++;  
    5990:	90 91 87 06 	lds	r25, 0x0687
    5994:	9f 5f       	subi	r25, 0xFF	; 255
    5996:	90 93 87 06 	sts	0x0687, r25
			 KeyReleaseCounter=0;		 
    599a:	10 92 86 06 	sts	0x0686, r1
    599e:	08 c0       	rjmp	.+16     	; 0x59b0 <GetKey+0x21a>
		}
		else {
			KeyReleaseCounter++; 
    59a0:	80 91 86 06 	lds	r24, 0x0686
    59a4:	8f 5f       	subi	r24, 0xFF	; 255
    59a6:	80 93 86 06 	sts	0x0686, r24
			KeyHoldCounter = 0;  
    59aa:	10 92 87 06 	sts	0x0687, r1
    59ae:	80 e0       	ldi	r24, 0x00	; 0
		}
		
		if (KeyHoldCounter >= KeyHoldTime){
    59b0:	90 91 66 07 	lds	r25, 0x0766
    59b4:	20 91 87 06 	lds	r18, 0x0687
    59b8:	29 17       	cp	r18, r25
    59ba:	60 f0       	brcs	.+24     	; 0x59d4 <GetKey+0x23e>
			KeyHoldCounter = KeyHoldTime; // can't get higher than keyholdtime
    59bc:	90 93 87 06 	sts	0x0687, r25
			if (DetectedKey != ActiveKey){ // if this is a new active key (just pressed) then set the active key to the new value, and give go-ahead to send it.
    59c0:	90 91 8a 06 	lds	r25, 0x068A
    59c4:	89 17       	cp	r24, r25
    59c6:	09 f4       	brne	.+2      	; 0x59ca <GetKey+0x234>
    59c8:	4b c0       	rjmp	.+150    	; 0x5a60 <GetKey+0x2ca>
				ActiveKey = DetectedKey; //the current key is the new active key
    59ca:	80 93 8a 06 	sts	0x068A, r24
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
    59ce:	51 10       	cpse	r5, r1
    59d0:	11 c0       	rjmp	.+34     	; 0x59f4 <GetKey+0x25e>
    59d2:	49 c0       	rjmp	.+146    	; 0x5a66 <GetKey+0x2d0>
			if (DetectedKey != ActiveKey){ // if this is a new active key (just pressed) then set the active key to the new value, and give go-ahead to send it.
				ActiveKey = DetectedKey; //the current key is the new active key
				OKtoSendKey = true;
			}
		}
		else if (KeyReleaseCounter >= KeyReleaseTime){
    59d4:	80 91 d9 06 	lds	r24, 0x06D9
    59d8:	90 91 86 06 	lds	r25, 0x0686
    59dc:	98 17       	cp	r25, r24
    59de:	08 f4       	brcc	.+2      	; 0x59e2 <GetKey+0x24c>
    59e0:	3f c0       	rjmp	.+126    	; 0x5a60 <GetKey+0x2ca>
			KeyReleaseCounter = KeyReleaseTime; //
    59e2:	80 93 86 06 	sts	0x0686, r24
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
    59e6:	80 91 8a 06 	lds	r24, 0x068A
    59ea:	80 93 89 06 	sts	0x0689, r24
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
    59ee:	10 92 8a 06 	sts	0x068A, r1
    59f2:	36 c0       	rjmp	.+108    	; 0x5a60 <GetKey+0x2ca>
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
			return ReedToSend;
    59f4:	82 2d       	mov	r24, r2
    59f6:	37 c0       	rjmp	.+110    	; 0x5a66 <GetKey+0x2d0>
			int j;
			
			if (Reeds_Are_Independent) j = i; //
			else j = 0; //setting j = 0 means "If any reed is active, all reeds are considered active also (and are therefore won't be sent when pressed)
			
			if (SensorReadout & LONGLONGBIT(REED_BITS[i])){ //if the reed is detected,
    59f8:	d7 01       	movw	r26, r14
    59fa:	0c 91       	ld	r16, X
    59fc:	28 2d       	mov	r18, r8
    59fe:	39 2d       	mov	r19, r9
    5a00:	4a 2d       	mov	r20, r10
    5a02:	5b 2d       	mov	r21, r11
    5a04:	61 2f       	mov	r22, r17
    5a06:	79 81       	ldd	r23, Y+1	; 0x01
    5a08:	86 2d       	mov	r24, r6
    5a0a:	94 2d       	mov	r25, r4
    5a0c:	0e 94 56 39 	call	0x72ac	; 0x72ac <__lshrdi3>
    5a10:	21 70       	andi	r18, 0x01	; 1
    5a12:	30 e0       	ldi	r19, 0x00	; 0
    5a14:	40 e0       	ldi	r20, 0x00	; 0
    5a16:	50 e0       	ldi	r21, 0x00	; 0
    5a18:	60 e0       	ldi	r22, 0x00	; 0
    5a1a:	70 e0       	ldi	r23, 0x00	; 0
    5a1c:	80 e0       	ldi	r24, 0x00	; 0
    5a1e:	90 e0       	ldi	r25, 0x00	; 0
    5a20:	a0 e0       	ldi	r26, 0x00	; 0
    5a22:	0e 94 72 39 	call	0x72e4	; 0x72e4 <__cmpdi2_s8>
    5a26:	09 f0       	breq	.+2      	; 0x5a2a <GetKey+0x294>
    5a28:	ef ce       	rjmp	.-546    	; 0x5808 <GetKey+0x72>
    5a2a:	17 cf       	rjmp	.-466    	; 0x585a <GetKey+0xc4>
    5a2c:	d7 01       	movw	r26, r14
    5a2e:	0c 91       	ld	r16, X
    5a30:	28 2d       	mov	r18, r8
    5a32:	39 2d       	mov	r19, r9
    5a34:	4a 2d       	mov	r20, r10
    5a36:	5b 2d       	mov	r21, r11
    5a38:	61 2f       	mov	r22, r17
    5a3a:	79 81       	ldd	r23, Y+1	; 0x01
    5a3c:	86 2d       	mov	r24, r6
    5a3e:	94 2d       	mov	r25, r4
    5a40:	0e 94 56 39 	call	0x72ac	; 0x72ac <__lshrdi3>
    5a44:	21 70       	andi	r18, 0x01	; 1
    5a46:	30 e0       	ldi	r19, 0x00	; 0
    5a48:	40 e0       	ldi	r20, 0x00	; 0
    5a4a:	50 e0       	ldi	r21, 0x00	; 0
    5a4c:	60 e0       	ldi	r22, 0x00	; 0
    5a4e:	70 e0       	ldi	r23, 0x00	; 0
    5a50:	80 e0       	ldi	r24, 0x00	; 0
    5a52:	90 e0       	ldi	r25, 0x00	; 0
    5a54:	a0 e0       	ldi	r26, 0x00	; 0
    5a56:	0e 94 72 39 	call	0x72e4	; 0x72e4 <__cmpdi2_s8>
    5a5a:	09 f0       	breq	.+2      	; 0x5a5e <GetKey+0x2c8>
    5a5c:	d7 ce       	rjmp	.-594    	; 0x580c <GetKey+0x76>
    5a5e:	ed ce       	rjmp	.-550    	; 0x583a <GetKey+0xa4>
			PreviousKey = ActiveKey; //save the current active key as the previous key pressed.
			ActiveKey = 0; //return 0 for the active key -- meaning, no keys are pressed, or the current active key was just released.
		}
		
/*SEND RESULTS, IF ANY, BACK TO MAIN ROUTINE*/
		if(OKtoSendReed){//if there is a reed switch that needs sending, report it
    5a60:	51 10       	cpse	r5, r1
    5a62:	c8 cf       	rjmp	.-112    	; 0x59f4 <GetKey+0x25e>
		}
		else if(OKtoSendKey){ //otherwise, if there is a key to send, report it
			return ActiveKey; 
		}
		else{
			return 0; //if no keys or reeds need sending, return 0
    5a64:	80 e0       	ldi	r24, 0x00	; 0
		}

}
    5a66:	0f 90       	pop	r0
    5a68:	0f 90       	pop	r0
    5a6a:	0f 90       	pop	r0
    5a6c:	df 91       	pop	r29
    5a6e:	cf 91       	pop	r28
    5a70:	1f 91       	pop	r17
    5a72:	0f 91       	pop	r16
    5a74:	ff 90       	pop	r15
    5a76:	ef 90       	pop	r14
    5a78:	df 90       	pop	r13
    5a7a:	cf 90       	pop	r12
    5a7c:	bf 90       	pop	r11
    5a7e:	af 90       	pop	r10
    5a80:	9f 90       	pop	r9
    5a82:	8f 90       	pop	r8
    5a84:	7f 90       	pop	r7
    5a86:	6f 90       	pop	r6
    5a88:	5f 90       	pop	r5
    5a8a:	4f 90       	pop	r4
    5a8c:	3f 90       	pop	r3
    5a8e:	2f 90       	pop	r2
    5a90:	08 95       	ret

00005a92 <GetHIDKeyCode>:
		if (Shift_Reed != 4 && is_high(REED_4)==(bool)Reed4Polarity){ Readout |= LONGLONGBIT(REED_BITS[3]);} //60th bit of readout (or something like that) represents Reed4
		
		return Readout;
}

uint8_t GetHIDKeyCode(uint8_t key, uint8_t modifier){ 
    5a92:	e8 2f       	mov	r30, r24
	uint8_t code;

	if ((modifier & HID_KEYBOARD_MODIFIER_LEFTALT) && FnKeyCodeLookUpTable[key]){ //if the FN key is held down, look up key in FN array.
    5a94:	62 ff       	sbrs	r22, 2
    5a96:	07 c0       	rjmp	.+14     	; 0x5aa6 <GetHIDKeyCode+0x14>
    5a98:	a8 2f       	mov	r26, r24
    5a9a:	b0 e0       	ldi	r27, 0x00	; 0
    5a9c:	a7 5d       	subi	r26, 0xD7	; 215
    5a9e:	b5 4f       	sbci	r27, 0xF5	; 245
    5aa0:	8c 91       	ld	r24, X
    5aa2:	81 11       	cpse	r24, r1
    5aa4:	0d c0       	rjmp	.+26     	; 0x5ac0 <GetHIDKeyCode+0x2e>
		code = FnKeyCodeLookUpTable[key];
	}
	else if ((modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT) && ShiftKeyCodeLookUpTable[key]){
    5aa6:	61 ff       	sbrs	r22, 1
    5aa8:	07 c0       	rjmp	.+14     	; 0x5ab8 <GetHIDKeyCode+0x26>
    5aaa:	ae 2f       	mov	r26, r30
    5aac:	b0 e0       	ldi	r27, 0x00	; 0
    5aae:	aa 5d       	subi	r26, 0xDA	; 218
    5ab0:	b8 4f       	sbci	r27, 0xF8	; 248
    5ab2:	8c 91       	ld	r24, X
    5ab4:	81 11       	cpse	r24, r1
    5ab6:	04 c0       	rjmp	.+8      	; 0x5ac0 <GetHIDKeyCode+0x2e>
		code = ShiftKeyCodeLookUpTable[key];
	}
	else {
		code = KeyCodeLookUpTable[key]; //otherwise, look up the key in the regular array.
    5ab8:	f0 e0       	ldi	r31, 0x00	; 0
    5aba:	e5 52       	subi	r30, 0x25	; 37
    5abc:	f9 4f       	sbci	r31, 0xF9	; 249
    5abe:	80 81       	ld	r24, Z
	}
	return code;
}
    5ac0:	08 95       	ret

00005ac2 <GetASCIIKeyCode>:

uint8_t GetASCIIKeyCode(uint8_t key, uint8_t modifier){
	uint8_t code;
	
	if(key == 0){
    5ac2:	88 23       	and	r24, r24
    5ac4:	79 f0       	breq	.+30     	; 0x5ae4 <GetASCIIKeyCode+0x22>
		return 0;
	}
	
	if ((modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT) && ASCIIShiftLookUpTable[key]){
    5ac6:	61 ff       	sbrs	r22, 1
    5ac8:	07 c0       	rjmp	.+14     	; 0x5ad8 <GetASCIIKeyCode+0x16>
    5aca:	e8 2f       	mov	r30, r24
    5acc:	f0 e0       	ldi	r31, 0x00	; 0
    5ace:	e9 59       	subi	r30, 0x99	; 153
    5ad0:	f8 4f       	sbci	r31, 0xF8	; 248
    5ad2:	90 81       	ld	r25, Z
    5ad4:	91 11       	cpse	r25, r1
    5ad6:	08 c0       	rjmp	.+16     	; 0x5ae8 <GetASCIIKeyCode+0x26>
		code = ASCIIShiftLookUpTable[key];
	}
	else {
		code = ASCIILookUpTable[key];
    5ad8:	e8 2f       	mov	r30, r24
    5ada:	f0 e0       	ldi	r31, 0x00	; 0
    5adc:	ea 51       	subi	r30, 0x1A	; 26
    5ade:	f8 4f       	sbci	r31, 0xF8	; 248
    5ae0:	80 81       	ld	r24, Z
    5ae2:	08 95       	ret

uint8_t GetASCIIKeyCode(uint8_t key, uint8_t modifier){
	uint8_t code;
	
	if(key == 0){
		return 0;
    5ae4:	80 e0       	ldi	r24, 0x00	; 0
    5ae6:	08 95       	ret
	}
	
	if ((modifier & HID_KEYBOARD_MODIFIER_LEFTSHIFT) && ASCIIShiftLookUpTable[key]){
		code = ASCIIShiftLookUpTable[key];
    5ae8:	89 2f       	mov	r24, r25
	}
	else {
		code = ASCIILookUpTable[key];
	}
	return code;
}
    5aea:	08 95       	ret

00005aec <getHallState>:

bool getHallState(){ //don't call this function from inside ReadSensor !  It will cause an infinite loop...
    5aec:	0f 93       	push	r16
	bool hallstate;
	hallstate = (ReadSensor() & LONGLONGBIT(HALL_SENSOR_BIT));
    5aee:	64 dd       	rcall	.-1336   	; 0x55b8 <ReadSensor>
    5af0:	0c e2       	ldi	r16, 0x2C	; 44
    5af2:	0e 94 56 39 	call	0x72ac	; 0x72ac <__lshrdi3>
	return hallstate;
}
    5af6:	82 2f       	mov	r24, r18
    5af8:	81 70       	andi	r24, 0x01	; 1
    5afa:	0f 91       	pop	r16
    5afc:	08 95       	ret

00005afe <LoadKeyCodeTables>:

	

void LoadKeyCodeTables(){
	 eeprom_read_block (( void *) KeyCodeLookUpTable, (void *) KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    5afe:	40 e4       	ldi	r20, 0x40	; 64
    5b00:	50 e0       	ldi	r21, 0x00	; 0
    5b02:	60 e0       	ldi	r22, 0x00	; 0
    5b04:	70 e0       	ldi	r23, 0x00	; 0
    5b06:	8b ed       	ldi	r24, 0xDB	; 219
    5b08:	96 e0       	ldi	r25, 0x06	; 6
    5b0a:	0e 94 9f 3c 	call	0x793e	; 0x793e <eeprom_read_block>
	 eeprom_read_block (( void *) FnKeyCodeLookUpTable, (void *) FN_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    5b0e:	40 e4       	ldi	r20, 0x40	; 64
    5b10:	50 e0       	ldi	r21, 0x00	; 0
    5b12:	60 e4       	ldi	r22, 0x40	; 64
    5b14:	70 e0       	ldi	r23, 0x00	; 0
    5b16:	89 e2       	ldi	r24, 0x29	; 41
    5b18:	9a e0       	ldi	r25, 0x0A	; 10
    5b1a:	0e 94 9f 3c 	call	0x793e	; 0x793e <eeprom_read_block>
	 eeprom_read_block (( void *) ShiftKeyCodeLookUpTable, (void *) SHIFT_KEYCODE_ADDR, KEYCODE_ARRAY_LENGTH);
    5b1e:	40 e4       	ldi	r20, 0x40	; 64
    5b20:	50 e0       	ldi	r21, 0x00	; 0
    5b22:	60 e8       	ldi	r22, 0x80	; 128
    5b24:	70 e0       	ldi	r23, 0x00	; 0
    5b26:	86 e2       	ldi	r24, 0x26	; 38
    5b28:	97 e0       	ldi	r25, 0x07	; 7
    5b2a:	0e 94 9f 3c 	call	0x793e	; 0x793e <eeprom_read_block>
	 eeprom_read_block (( void *) ASCIILookUpTable, (void *) ASCII_ADDR, KEYCODE_ARRAY_LENGTH);
    5b2e:	40 e4       	ldi	r20, 0x40	; 64
    5b30:	50 e0       	ldi	r21, 0x00	; 0
    5b32:	60 ec       	ldi	r22, 0xC0	; 192
    5b34:	70 e0       	ldi	r23, 0x00	; 0
    5b36:	86 ee       	ldi	r24, 0xE6	; 230
    5b38:	97 e0       	ldi	r25, 0x07	; 7
    5b3a:	0e 94 9f 3c 	call	0x793e	; 0x793e <eeprom_read_block>
	 eeprom_read_block (( void *) ASCIIShiftLookUpTable, (void *) ASCII_SHIFT_ADDR, KEYCODE_ARRAY_LENGTH);
    5b3e:	40 e4       	ldi	r20, 0x40	; 64
    5b40:	50 e0       	ldi	r21, 0x00	; 0
    5b42:	60 e0       	ldi	r22, 0x00	; 0
    5b44:	71 e0       	ldi	r23, 0x01	; 1
    5b46:	87 e6       	ldi	r24, 0x67	; 103
    5b48:	97 e0       	ldi	r25, 0x07	; 7
    5b4a:	0c 94 9f 3c 	jmp	0x793e	; 0x793e <eeprom_read_block>
    5b4e:	08 95       	ret

00005b50 <LoadEepromParameters>:

}

void LoadEepromParameters(){	
	 KeyReleaseTime = eeprom_read_byte((uint8_t *)RELEASE_TIME_ADDR);
    5b50:	82 e0       	ldi	r24, 0x02	; 2
    5b52:	92 e0       	ldi	r25, 0x02	; 2
    5b54:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    5b58:	80 93 d9 06 	sts	0x06D9, r24
	 KeyHoldTime = eeprom_read_byte((uint8_t *)HOLD_TIME_ADDR);
    5b5c:	81 e0       	ldi	r24, 0x01	; 1
    5b5e:	92 e0       	ldi	r25, 0x02	; 2
    5b60:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    5b64:	80 93 66 07 	sts	0x0766, r24
	 DoubleTapTime = eeprom_read_byte((uint8_t *)DOUBLE_TAP_ADDR);
    5b68:	80 e0       	ldi	r24, 0x00	; 0
    5b6a:	92 e0       	ldi	r25, 0x02	; 2
    5b6c:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    5b70:	80 93 1d 07 	sts	0x071D, r24
	 ReedHoldTime = eeprom_read_byte((uint8_t *)REED_HOLD_TIME_ADDR);
    5b74:	8c e0       	ldi	r24, 0x0C	; 12
    5b76:	92 e0       	ldi	r25, 0x02	; 2
    5b78:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    5b7c:	80 93 1c 07 	sts	0x071C, r24
	 UseHallSensor = eeprom_read_byte((uint8_t *)USE_HALL_SENSOR_ADDR);
    5b80:	83 e0       	ldi	r24, 0x03	; 3
    5b82:	92 e0       	ldi	r25, 0x02	; 2
    5b84:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    5b88:	80 93 a8 07 	sts	0x07A8, r24
	 HallSensorPolarity = eeprom_read_byte((uint8_t *)HALL_SENSOR_POLARITY_ADDR);
    5b8c:	84 e0       	ldi	r24, 0x04	; 4
    5b8e:	92 e0       	ldi	r25, 0x02	; 2
    5b90:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    5b94:	80 93 24 07 	sts	0x0724, r24
	 Shift_Reed = eeprom_read_byte((uint8_t *)SHIFT_REED_ADDR);
    5b98:	85 e0       	ldi	r24, 0x05	; 5
    5b9a:	92 e0       	ldi	r25, 0x02	; 2
    5b9c:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    5ba0:	80 93 1e 07 	sts	0x071E, r24
	 Reeds_Are_Independent = eeprom_read_byte((uint8_t *)REEDS_INDEPENDENT_ADDR);
    5ba4:	8e e0       	ldi	r24, 0x0E	; 14
    5ba6:	92 e0       	ldi	r25, 0x02	; 2
    5ba8:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    5bac:	80 93 d7 06 	sts	0x06D7, r24
	 UseDummyLoad = eeprom_read_byte((uint8_t*)DUMMY_LOAD_ADDR);
    5bb0:	8f e0       	ldi	r24, 0x0F	; 15
    5bb2:	92 e0       	ldi	r25, 0x02	; 2
    5bb4:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    5bb8:	80 93 d6 06 	sts	0x06D6, r24
	 BluetoothConfigured = eeprom_read_byte((uint8_t*)BLUETOOTH_CONFIGURED_ADDR);
    5bbc:	80 e1       	ldi	r24, 0x10	; 16
    5bbe:	92 e0       	ldi	r25, 0x02	; 2
    5bc0:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    5bc4:	80 93 1b 07 	sts	0x071B, r24
    5bc8:	08 95       	ret

00005bca <ClearKeyCodeTables>:
}

void ClearKeyCodeTables(){
	memset (&KeyCodeLookUpTable[0] , 0, KEYCODE_ARRAY_LENGTH);
    5bca:	80 e4       	ldi	r24, 0x40	; 64
    5bcc:	eb ed       	ldi	r30, 0xDB	; 219
    5bce:	f6 e0       	ldi	r31, 0x06	; 6
    5bd0:	df 01       	movw	r26, r30
    5bd2:	98 2f       	mov	r25, r24
    5bd4:	1d 92       	st	X+, r1
    5bd6:	9a 95       	dec	r25
    5bd8:	e9 f7       	brne	.-6      	; 0x5bd4 <ClearKeyCodeTables+0xa>
	memset (&FnKeyCodeLookUpTable[0] , 0, KEYCODE_ARRAY_LENGTH);
    5bda:	e9 e2       	ldi	r30, 0x29	; 41
    5bdc:	fa e0       	ldi	r31, 0x0A	; 10
    5bde:	df 01       	movw	r26, r30
    5be0:	98 2f       	mov	r25, r24
    5be2:	1d 92       	st	X+, r1
    5be4:	9a 95       	dec	r25
    5be6:	e9 f7       	brne	.-6      	; 0x5be2 <ClearKeyCodeTables+0x18>
	memset (&ShiftKeyCodeLookUpTable[0], 0, KEYCODE_ARRAY_LENGTH);
    5be8:	e6 e2       	ldi	r30, 0x26	; 38
    5bea:	f7 e0       	ldi	r31, 0x07	; 7
    5bec:	df 01       	movw	r26, r30
    5bee:	98 2f       	mov	r25, r24
    5bf0:	1d 92       	st	X+, r1
    5bf2:	9a 95       	dec	r25
    5bf4:	e9 f7       	brne	.-6      	; 0x5bf0 <ClearKeyCodeTables+0x26>
	memset (&ASCIILookUpTable[0],0,KEYCODE_ARRAY_LENGTH);
    5bf6:	e6 ee       	ldi	r30, 0xE6	; 230
    5bf8:	f7 e0       	ldi	r31, 0x07	; 7
    5bfa:	df 01       	movw	r26, r30
    5bfc:	98 2f       	mov	r25, r24
    5bfe:	1d 92       	st	X+, r1
    5c00:	9a 95       	dec	r25
    5c02:	e9 f7       	brne	.-6      	; 0x5bfe <ClearKeyCodeTables+0x34>
	memset (&ASCIIShiftLookUpTable[0],0,KEYCODE_ARRAY_LENGTH);
    5c04:	e7 e6       	ldi	r30, 0x67	; 103
    5c06:	f7 e0       	ldi	r31, 0x07	; 7
    5c08:	df 01       	movw	r26, r30
    5c0a:	1d 92       	st	X+, r1
    5c0c:	8a 95       	dec	r24
    5c0e:	e9 f7       	brne	.-6      	; 0x5c0a <ClearKeyCodeTables+0x40>

	Shift_Reed = 0;
    5c10:	10 92 1e 07 	sts	0x071E, r1
    5c14:	08 95       	ret

00005c16 <RestoreFactoryDefaults>:
		eeprom_write_byte((uint8_t*)EEP_CHECKSUM_ADDR, EEP_CHECKSUM);//write the checksum to the eeprom to indicate that eeprom has been properly initialized.
	}
}

void RestoreFactoryDefaults(){
			eeprom_update_byte((uint8_t*)DOUBLE_TAP_ADDR, DEFAULT_DOUBLE_TAP_TIME);
    5c16:	65 e0       	ldi	r22, 0x05	; 5
    5c18:	80 e0       	ldi	r24, 0x00	; 0
    5c1a:	92 e0       	ldi	r25, 0x02	; 2
    5c1c:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)HOLD_TIME_ADDR, DEFAULT_HOLD_TIME);
    5c20:	66 e0       	ldi	r22, 0x06	; 6
    5c22:	81 e0       	ldi	r24, 0x01	; 1
    5c24:	92 e0       	ldi	r25, 0x02	; 2
    5c26:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)RELEASE_TIME_ADDR, DEFAULT_RELEASE_TIME);
    5c2a:	63 e0       	ldi	r22, 0x03	; 3
    5c2c:	82 e0       	ldi	r24, 0x02	; 2
    5c2e:	92 e0       	ldi	r25, 0x02	; 2
    5c30:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)REED_HOLD_TIME_ADDR, DEFAULT_REED_HOLD_TIME);
    5c34:	63 e0       	ldi	r22, 0x03	; 3
    5c36:	8c e0       	ldi	r24, 0x0C	; 12
    5c38:	92 e0       	ldi	r25, 0x02	; 2
    5c3a:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)REEDS_INDEPENDENT_ADDR,REEDS_ARE_INDEPENDENT_BY_DEFAULT);
    5c3e:	60 e0       	ldi	r22, 0x00	; 0
    5c40:	8e e0       	ldi	r24, 0x0E	; 14
    5c42:	92 e0       	ldi	r25, 0x02	; 2
    5c44:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)DEFAULT_MODE_ADDR,USB_COMBO_MODE);
    5c48:	61 e0       	ldi	r22, 0x01	; 1
    5c4a:	8d e0       	ldi	r24, 0x0D	; 13
    5c4c:	92 e0       	ldi	r25, 0x02	; 2
    5c4e:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
			eeprom_update_byte((uint8_t*)DUMMY_LOAD_ADDR,0); //do not use dummy load unless told to.
    5c52:	60 e0       	ldi	r22, 0x00	; 0
    5c54:	8f e0       	ldi	r24, 0x0F	; 15
    5c56:	92 e0       	ldi	r25, 0x02	; 2
    5c58:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
			eeprom_write_word((uint16_t *)FILENUM_ADDR,0);//reset sd card file number to zero.
    5c5c:	60 e0       	ldi	r22, 0x00	; 0
    5c5e:	70 e0       	ldi	r23, 0x00	; 0
    5c60:	8a e0       	ldi	r24, 0x0A	; 10
    5c62:	92 e0       	ldi	r25, 0x02	; 2
    5c64:	0e 94 e5 3c 	call	0x79ca	; 0x79ca <eeprom_write_word>
			eeprom_write_byte((uint8_t*)USE_HALL_SENSOR_ADDR,HALL_NOT_PRESENT);
    5c68:	60 e0       	ldi	r22, 0x00	; 0
    5c6a:	83 e0       	ldi	r24, 0x03	; 3
    5c6c:	92 e0       	ldi	r25, 0x02	; 2
    5c6e:	0e 94 d7 3c 	call	0x79ae	; 0x79ae <eeprom_write_byte>
			
			LoadEepromParameters(); //load new defaults into RAM
    5c72:	6e cf       	rjmp	.-292    	; 0x5b50 <LoadEepromParameters>
    5c74:	08 95       	ret

00005c76 <InitializeEeprom>:

	Shift_Reed = 0;
//	UseHallSensor = HALL_NOT_PRESENT;	
}

void InitializeEeprom(){
    5c76:	cf 93       	push	r28
    5c78:	df 93       	push	r29
	int i;
	if (eeprom_read_byte((uint8_t*)EEP_CHECKSUM_ADDR) != EEP_CHECKSUM){
    5c7a:	8f ef       	ldi	r24, 0xFF	; 255
    5c7c:	93 e0       	ldi	r25, 0x03	; 3
    5c7e:	0e 94 af 3c 	call	0x795e	; 0x795e <eeprom_read_byte>
    5c82:	87 34       	cpi	r24, 0x47	; 71
    5c84:	e1 f0       	breq	.+56     	; 0x5cbe <InitializeEeprom+0x48>
    5c86:	c0 e0       	ldi	r28, 0x00	; 0
    5c88:	d0 e0       	ldi	r29, 0x00	; 0
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
    5c8a:	60 e0       	ldi	r22, 0x00	; 0
    5c8c:	ce 01       	movw	r24, r28
    5c8e:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>

void InitializeEeprom(){
	int i;
	if (eeprom_read_byte((uint8_t*)EEP_CHECKSUM_ADDR) != EEP_CHECKSUM){
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
    5c92:	21 96       	adiw	r28, 0x01	; 1
    5c94:	c1 35       	cpi	r28, 0x51	; 81
    5c96:	81 e0       	ldi	r24, 0x01	; 1
    5c98:	d8 07       	cpc	r29, r24
    5c9a:	b9 f7       	brne	.-18     	; 0x5c8a <InitializeEeprom+0x14>
    5c9c:	c0 e0       	ldi	r28, 0x00	; 0
    5c9e:	d2 e0       	ldi	r29, 0x02	; 2
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		for(i=EEP_BANK2; i<=EEP_BANK2_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
    5ca0:	60 e0       	ldi	r22, 0x00	; 0
    5ca2:	ce 01       	movw	r24, r28
    5ca4:	0e 94 bc 3c 	call	0x7978	; 0x7978 <eeprom_update_byte>
		
		for(i=EEP_BANK0; i<=EEP_BANK0_END; i++){
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		for(i=EEP_BANK2; i<=EEP_BANK2_END; i++){
    5ca8:	21 96       	adiw	r28, 0x01	; 1
    5caa:	c2 31       	cpi	r28, 0x12	; 18
    5cac:	82 e0       	ldi	r24, 0x02	; 2
    5cae:	d8 07       	cpc	r29, r24
    5cb0:	b9 f7       	brne	.-18     	; 0x5ca0 <InitializeEeprom+0x2a>
			  eeprom_update_byte((uint8_t*)i,0); // clear contents of eeprom to 0
		}
		
		RestoreFactoryDefaults();
    5cb2:	b1 df       	rcall	.-158    	; 0x5c16 <RestoreFactoryDefaults>

		eeprom_write_byte((uint8_t*)EEP_CHECKSUM_ADDR, EEP_CHECKSUM);//write the checksum to the eeprom to indicate that eeprom has been properly initialized.
    5cb4:	67 e4       	ldi	r22, 0x47	; 71
    5cb6:	8f ef       	ldi	r24, 0xFF	; 255
    5cb8:	93 e0       	ldi	r25, 0x03	; 3
    5cba:	0e 94 d7 3c 	call	0x79ae	; 0x79ae <eeprom_write_byte>
	}
}
    5cbe:	df 91       	pop	r29
    5cc0:	cf 91       	pop	r28
    5cc2:	08 95       	ret

00005cc4 <HID_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_HID_DRIVER
#define  __INCLUDE_FROM_HID_DEVICE_C
#include "HIDClassDevice.h"

void HID_Device_ProcessControlRequest(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
    5cc4:	3f 92       	push	r3
    5cc6:	4f 92       	push	r4
    5cc8:	5f 92       	push	r5
    5cca:	6f 92       	push	r6
    5ccc:	7f 92       	push	r7
    5cce:	8f 92       	push	r8
    5cd0:	9f 92       	push	r9
    5cd2:	af 92       	push	r10
    5cd4:	bf 92       	push	r11
    5cd6:	cf 92       	push	r12
    5cd8:	df 92       	push	r13
    5cda:	ef 92       	push	r14
    5cdc:	ff 92       	push	r15
    5cde:	0f 93       	push	r16
    5ce0:	1f 93       	push	r17
    5ce2:	cf 93       	push	r28
    5ce4:	df 93       	push	r29
    5ce6:	00 d0       	rcall	.+0      	; 0x5ce8 <HID_Device_ProcessControlRequest+0x24>
    5ce8:	1f 92       	push	r1
    5cea:	cd b7       	in	r28, 0x3d	; 61
    5cec:	de b7       	in	r29, 0x3e	; 62
    5cee:	6c 01       	movw	r12, r24
				Endpoint_ClearStatusStage();
			}

			break;
	}
}
    5cf0:	ed b6       	in	r14, 0x3d	; 61
    5cf2:	fe b6       	in	r15, 0x3e	; 62
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    5cf4:	80 91 e8 00 	lds	r24, 0x00E8
#define  __INCLUDE_FROM_HID_DEVICE_C
#include "HIDClassDevice.h"

void HID_Device_ProcessControlRequest(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	if (!(Endpoint_IsSETUPReceived()))
    5cf8:	83 ff       	sbrs	r24, 3
    5cfa:	15 c1       	rjmp	.+554    	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
	  return;

	if (USB_ControlRequest.wIndex != HIDInterfaceInfo->Config.InterfaceNumber)
    5cfc:	f6 01       	movw	r30, r12
    5cfe:	80 81       	ld	r24, Z
    5d00:	90 e0       	ldi	r25, 0x00	; 0
    5d02:	20 91 72 0a 	lds	r18, 0x0A72
    5d06:	30 91 73 0a 	lds	r19, 0x0A73
    5d0a:	28 17       	cp	r18, r24
    5d0c:	39 07       	cpc	r19, r25
    5d0e:	09 f0       	breq	.+2      	; 0x5d12 <HID_Device_ProcessControlRequest+0x4e>
    5d10:	0a c1       	rjmp	.+532    	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
	  return;

	switch (USB_ControlRequest.bRequest)
    5d12:	80 91 6f 0a 	lds	r24, 0x0A6F
    5d16:	83 30       	cpi	r24, 0x03	; 3
    5d18:	09 f4       	brne	.+2      	; 0x5d1c <HID_Device_ProcessControlRequest+0x58>
    5d1a:	a2 c0       	rjmp	.+324    	; 0x5e60 <HID_Device_ProcessControlRequest+0x19c>
    5d1c:	30 f4       	brcc	.+12     	; 0x5d2a <HID_Device_ProcessControlRequest+0x66>
    5d1e:	81 30       	cpi	r24, 0x01	; 1
    5d20:	71 f0       	breq	.+28     	; 0x5d3e <HID_Device_ProcessControlRequest+0x7a>
    5d22:	82 30       	cpi	r24, 0x02	; 2
    5d24:	09 f4       	brne	.+2      	; 0x5d28 <HID_Device_ProcessControlRequest+0x64>
    5d26:	e4 c0       	rjmp	.+456    	; 0x5ef0 <HID_Device_ProcessControlRequest+0x22c>
    5d28:	fe c0       	rjmp	.+508    	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
    5d2a:	8a 30       	cpi	r24, 0x0A	; 10
    5d2c:	09 f4       	brne	.+2      	; 0x5d30 <HID_Device_ProcessControlRequest+0x6c>
    5d2e:	c4 c0       	rjmp	.+392    	; 0x5eb8 <HID_Device_ProcessControlRequest+0x1f4>
    5d30:	8b 30       	cpi	r24, 0x0B	; 11
    5d32:	09 f4       	brne	.+2      	; 0x5d36 <HID_Device_ProcessControlRequest+0x72>
    5d34:	ad c0       	rjmp	.+346    	; 0x5e90 <HID_Device_ProcessControlRequest+0x1cc>
    5d36:	89 30       	cpi	r24, 0x09	; 9
    5d38:	09 f0       	breq	.+2      	; 0x5d3c <HID_Device_ProcessControlRequest+0x78>
    5d3a:	f5 c0       	rjmp	.+490    	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
    5d3c:	53 c0       	rjmp	.+166    	; 0x5de4 <HID_Device_ProcessControlRequest+0x120>
	{
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    5d3e:	80 91 6e 0a 	lds	r24, 0x0A6E
    5d42:	81 3a       	cpi	r24, 0xA1	; 161
    5d44:	09 f0       	breq	.+2      	; 0x5d48 <HID_Device_ProcessControlRequest+0x84>
    5d46:	ef c0       	rjmp	.+478    	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
    5d48:	ad b6       	in	r10, 0x3d	; 61
    5d4a:	be b6       	in	r11, 0x3e	; 62
			{
				uint16_t ReportSize = 0;
    5d4c:	1a 82       	std	Y+2, r1	; 0x02
    5d4e:	19 82       	std	Y+1, r1	; 0x01
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
    5d50:	ee e6       	ldi	r30, 0x6E	; 110
    5d52:	fa e0       	ldi	r31, 0x0A	; 10
    5d54:	82 81       	ldd	r24, Z+2	; 0x02
    5d56:	13 81       	ldd	r17, Z+3	; 0x03
    5d58:	8b 83       	std	Y+3, r24	; 0x03
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
				uint8_t  ReportData[HIDInterfaceInfo->Config.PrevReportINBufferSize];
    5d5a:	f6 01       	movw	r30, r12
    5d5c:	80 85       	ldd	r24, Z+8	; 0x08
    5d5e:	48 2f       	mov	r20, r24
    5d60:	50 e0       	ldi	r21, 0x00	; 0
    5d62:	8d b7       	in	r24, 0x3d	; 61
    5d64:	9e b7       	in	r25, 0x3e	; 62
    5d66:	84 1b       	sub	r24, r20
    5d68:	95 0b       	sbc	r25, r21
    5d6a:	0f b6       	in	r0, 0x3f	; 63
    5d6c:	f8 94       	cli
    5d6e:	9e bf       	out	0x3e, r25	; 62
    5d70:	0f be       	out	0x3f, r0	; 63
    5d72:	8d bf       	out	0x3d, r24	; 61
    5d74:	ed b7       	in	r30, 0x3d	; 61
    5d76:	fe b7       	in	r31, 0x3e	; 62
    5d78:	31 96       	adiw	r30, 0x01	; 1
    5d7a:	4f 01       	movw	r8, r30

				memset(ReportData, 0, sizeof(ReportData));
    5d7c:	60 e0       	ldi	r22, 0x00	; 0
    5d7e:	70 e0       	ldi	r23, 0x00	; 0
    5d80:	cf 01       	movw	r24, r30
    5d82:	0e 94 e2 39 	call	0x73c4	; 0x73c4 <memset>
		case HID_REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				uint16_t ReportSize = 0;
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
    5d86:	4f ef       	ldi	r20, 0xFF	; 255
    5d88:	41 0f       	add	r20, r17
				uint8_t  ReportData[HIDInterfaceInfo->Config.PrevReportINBufferSize];

				memset(ReportData, 0, sizeof(ReportData));

				CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, ReportType, ReportData, &ReportSize);
    5d8a:	8e 01       	movw	r16, r28
    5d8c:	0f 5f       	subi	r16, 0xFF	; 255
    5d8e:	1f 4f       	sbci	r17, 0xFF	; 255
    5d90:	94 01       	movw	r18, r8
    5d92:	be 01       	movw	r22, r28
    5d94:	6d 5f       	subi	r22, 0xFD	; 253
    5d96:	7f 4f       	sbci	r23, 0xFF	; 255
    5d98:	c6 01       	movw	r24, r12
    5d9a:	b8 d8       	rcall	.-3728   	; 0x4f0c <CALLBACK_HID_Device_CreateHIDReport>

				if (HIDInterfaceInfo->Config.PrevReportINBuffer != NULL)
    5d9c:	f6 01       	movw	r30, r12
    5d9e:	86 81       	ldd	r24, Z+6	; 0x06
    5da0:	97 81       	ldd	r25, Z+7	; 0x07
    5da2:	00 97       	sbiw	r24, 0x00	; 0
    5da4:	29 f0       	breq	.+10     	; 0x5db0 <HID_Device_ProcessControlRequest+0xec>
				{
					memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportData,
    5da6:	40 85       	ldd	r20, Z+8	; 0x08
    5da8:	50 e0       	ldi	r21, 0x00	; 0
    5daa:	b4 01       	movw	r22, r8
    5dac:	0e 94 d9 39 	call	0x73b2	; 0x73b2 <memcpy>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5db0:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5db4:	e8 ee       	ldi	r30, 0xE8	; 232
    5db6:	f0 e0       	ldi	r31, 0x00	; 0
    5db8:	80 81       	ld	r24, Z
    5dba:	87 7f       	andi	r24, 0xF7	; 247
    5dbc:	80 83       	st	Z, r24

				Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

				Endpoint_ClearSETUP();

				if (ReportID)
    5dbe:	8b 81       	ldd	r24, Y+3	; 0x03
    5dc0:	81 11       	cpse	r24, r1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5dc2:	80 93 f1 00 	sts	0x00F1, r24
				  Endpoint_Write_8(ReportID);

				Endpoint_Write_Control_Stream_LE(ReportData, ReportSize);
    5dc6:	69 81       	ldd	r22, Y+1	; 0x01
    5dc8:	7a 81       	ldd	r23, Y+2	; 0x02
    5dca:	c4 01       	movw	r24, r8
    5dcc:	98 d4       	rcall	.+2352   	; 0x66fe <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    5dce:	e8 ee       	ldi	r30, 0xE8	; 232
    5dd0:	f0 e0       	ldi	r31, 0x00	; 0
    5dd2:	80 81       	ld	r24, Z
    5dd4:	8b 77       	andi	r24, 0x7B	; 123
    5dd6:	80 83       	st	Z, r24
    5dd8:	0f b6       	in	r0, 0x3f	; 63
    5dda:	f8 94       	cli
    5ddc:	be be       	out	0x3e, r11	; 62
    5dde:	0f be       	out	0x3f, r0	; 63
    5de0:	ad be       	out	0x3d, r10	; 61
    5de2:	a1 c0       	rjmp	.+322    	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
				Endpoint_ClearOUT();
			}

			break;
		case HID_REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5de4:	80 91 6e 0a 	lds	r24, 0x0A6E
    5de8:	81 32       	cpi	r24, 0x21	; 33
    5dea:	09 f0       	breq	.+2      	; 0x5dee <HID_Device_ProcessControlRequest+0x12a>
    5dec:	9c c0       	rjmp	.+312    	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
    5dee:	6d b6       	in	r6, 0x3d	; 61
    5df0:	7e b6       	in	r7, 0x3e	; 62
			{
				uint16_t ReportSize = USB_ControlRequest.wLength;
    5df2:	ee e6       	ldi	r30, 0x6E	; 110
    5df4:	fa e0       	ldi	r31, 0x0A	; 10
    5df6:	06 81       	ldd	r16, Z+6	; 0x06
    5df8:	17 81       	ldd	r17, Z+7	; 0x07
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
    5dfa:	52 80       	ldd	r5, Z+2	; 0x02
    5dfc:	43 80       	ldd	r4, Z+3	; 0x03
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
				uint8_t  ReportData[ReportSize];
    5dfe:	8d b7       	in	r24, 0x3d	; 61
    5e00:	9e b7       	in	r25, 0x3e	; 62
    5e02:	80 1b       	sub	r24, r16
    5e04:	91 0b       	sbc	r25, r17
    5e06:	0f b6       	in	r0, 0x3f	; 63
    5e08:	f8 94       	cli
    5e0a:	9e bf       	out	0x3e, r25	; 62
    5e0c:	0f be       	out	0x3f, r0	; 63
    5e0e:	8d bf       	out	0x3d, r24	; 61
    5e10:	ed b7       	in	r30, 0x3d	; 61
    5e12:	fe b7       	in	r31, 0x3e	; 62
    5e14:	31 96       	adiw	r30, 0x01	; 1
    5e16:	4f 01       	movw	r8, r30
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5e18:	0f 2e       	mov	r0, r31
    5e1a:	f8 ee       	ldi	r31, 0xE8	; 232
    5e1c:	af 2e       	mov	r10, r31
    5e1e:	b1 2c       	mov	r11, r1
    5e20:	f0 2d       	mov	r31, r0
    5e22:	f5 01       	movw	r30, r10
    5e24:	80 81       	ld	r24, Z
    5e26:	87 7f       	andi	r24, 0xF7	; 247
    5e28:	80 83       	st	Z, r24

				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(ReportData, ReportSize);
    5e2a:	b8 01       	movw	r22, r16
    5e2c:	c4 01       	movw	r24, r8
    5e2e:	eb d4       	rcall	.+2518   	; 0x6806 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5e30:	f5 01       	movw	r30, r10
    5e32:	80 81       	ld	r24, Z
    5e34:	8e 77       	andi	r24, 0x7E	; 126
    5e36:	80 83       	st	Z, r24
				Endpoint_ClearIN();

				CALLBACK_HID_Device_ProcessHIDReport(HIDInterfaceInfo, ReportID, ReportType,
    5e38:	21 e0       	ldi	r18, 0x01	; 1
    5e3a:	51 10       	cpse	r5, r1
    5e3c:	01 c0       	rjmp	.+2      	; 0x5e40 <HID_Device_ProcessControlRequest+0x17c>
    5e3e:	20 e0       	ldi	r18, 0x00	; 0
    5e40:	30 e0       	ldi	r19, 0x00	; 0
    5e42:	02 1b       	sub	r16, r18
    5e44:	13 0b       	sbc	r17, r19
				                                     &ReportData[ReportID ? 1 : 0], ReportSize - (ReportID ? 1 : 0));
    5e46:	28 0d       	add	r18, r8
    5e48:	39 1d       	adc	r19, r9
		case HID_REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				uint16_t ReportSize = USB_ControlRequest.wLength;
				uint8_t  ReportID   = (USB_ControlRequest.wValue & 0xFF);
				uint8_t  ReportType = (USB_ControlRequest.wValue >> 8) - 1;
    5e4a:	4f ef       	ldi	r20, 0xFF	; 255
    5e4c:	44 0d       	add	r20, r4

				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(ReportData, ReportSize);
				Endpoint_ClearIN();

				CALLBACK_HID_Device_ProcessHIDReport(HIDInterfaceInfo, ReportID, ReportType,
    5e4e:	65 2d       	mov	r22, r5
    5e50:	c6 01       	movw	r24, r12
    5e52:	7d d8       	rcall	.-3846   	; 0x4f4e <CALLBACK_HID_Device_ProcessHIDReport>
    5e54:	0f b6       	in	r0, 0x3f	; 63
    5e56:	f8 94       	cli
    5e58:	7e be       	out	0x3e, r7	; 62
    5e5a:	0f be       	out	0x3f, r0	; 63
    5e5c:	6d be       	out	0x3d, r6	; 61
    5e5e:	63 c0       	rjmp	.+198    	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
				                                     &ReportData[ReportID ? 1 : 0], ReportSize - (ReportID ? 1 : 0));
			}

			break;
		case HID_REQ_GetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    5e60:	80 91 6e 0a 	lds	r24, 0x0A6E
    5e64:	81 3a       	cpi	r24, 0xA1	; 161
    5e66:	09 f0       	breq	.+2      	; 0x5e6a <HID_Device_ProcessControlRequest+0x1a6>
    5e68:	5e c0       	rjmp	.+188    	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5e6a:	e8 ee       	ldi	r30, 0xE8	; 232
    5e6c:	f0 e0       	ldi	r31, 0x00	; 0
    5e6e:	80 81       	ld	r24, Z
    5e70:	87 7f       	andi	r24, 0xF7	; 247
    5e72:	80 83       	st	Z, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5e74:	80 81       	ld	r24, Z
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    5e76:	80 ff       	sbrs	r24, 0
    5e78:	fd cf       	rjmp	.-6      	; 0x5e74 <HID_Device_ProcessControlRequest+0x1b0>
				Endpoint_Write_8(HIDInterfaceInfo->State.UsingReportProtocol);
    5e7a:	f6 01       	movw	r30, r12
    5e7c:	81 85       	ldd	r24, Z+9	; 0x09
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5e7e:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5e82:	e8 ee       	ldi	r30, 0xE8	; 232
    5e84:	f0 e0       	ldi	r31, 0x00	; 0
    5e86:	80 81       	ld	r24, Z
    5e88:	8e 77       	andi	r24, 0x7E	; 126
    5e8a:	80 83       	st	Z, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    5e8c:	84 d6       	rcall	.+3336   	; 0x6b96 <Endpoint_ClearStatusStage>
    5e8e:	4b c0       	rjmp	.+150    	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
			}

			break;
		case HID_REQ_SetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5e90:	80 91 6e 0a 	lds	r24, 0x0A6E
    5e94:	81 32       	cpi	r24, 0x21	; 33
    5e96:	09 f0       	breq	.+2      	; 0x5e9a <HID_Device_ProcessControlRequest+0x1d6>
    5e98:	46 c0       	rjmp	.+140    	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    5e9a:	e8 ee       	ldi	r30, 0xE8	; 232
    5e9c:	f0 e0       	ldi	r31, 0x00	; 0
    5e9e:	80 81       	ld	r24, Z
    5ea0:	87 7f       	andi	r24, 0xF7	; 247
    5ea2:	80 83       	st	Z, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    5ea4:	78 d6       	rcall	.+3312   	; 0x6b96 <Endpoint_ClearStatusStage>

				HIDInterfaceInfo->State.UsingReportProtocol = ((USB_ControlRequest.wValue & 0xFF) != 0x00);
    5ea6:	90 91 70 0a 	lds	r25, 0x0A70
    5eaa:	81 e0       	ldi	r24, 0x01	; 1
    5eac:	91 11       	cpse	r25, r1
    5eae:	01 c0       	rjmp	.+2      	; 0x5eb2 <HID_Device_ProcessControlRequest+0x1ee>
    5eb0:	80 e0       	ldi	r24, 0x00	; 0
    5eb2:	f6 01       	movw	r30, r12
    5eb4:	81 87       	std	Z+9, r24	; 0x09
    5eb6:	37 c0       	rjmp	.+110    	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
			}

			break;
		case HID_REQ_SetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    5eb8:	80 91 6e 0a 	lds	r24, 0x0A6E
    5ebc:	81 32       	cpi	r24, 0x21	; 33
    5ebe:	99 f5       	brne	.+102    	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
    5ec0:	e8 ee       	ldi	r30, 0xE8	; 232
    5ec2:	f0 e0       	ldi	r31, 0x00	; 0
    5ec4:	80 81       	ld	r24, Z
    5ec6:	87 7f       	andi	r24, 0xF7	; 247
    5ec8:	80 83       	st	Z, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    5eca:	65 d6       	rcall	.+3274   	; 0x6b96 <Endpoint_ClearStatusStage>

				HIDInterfaceInfo->State.IdleCount = ((USB_ControlRequest.wValue & 0xFF00) >> 6);
    5ecc:	80 91 70 0a 	lds	r24, 0x0A70
    5ed0:	90 91 71 0a 	lds	r25, 0x0A71
    5ed4:	88 27       	eor	r24, r24
    5ed6:	00 24       	eor	r0, r0
    5ed8:	88 0f       	add	r24, r24
    5eda:	99 1f       	adc	r25, r25
    5edc:	00 1c       	adc	r0, r0
    5ede:	88 0f       	add	r24, r24
    5ee0:	99 1f       	adc	r25, r25
    5ee2:	00 1c       	adc	r0, r0
    5ee4:	89 2f       	mov	r24, r25
    5ee6:	90 2d       	mov	r25, r0
    5ee8:	f6 01       	movw	r30, r12
    5eea:	95 87       	std	Z+13, r25	; 0x0d
    5eec:	84 87       	std	Z+12, r24	; 0x0c
    5eee:	1b c0       	rjmp	.+54     	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
			}

			break;
		case HID_REQ_GetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    5ef0:	80 91 6e 0a 	lds	r24, 0x0A6E
    5ef4:	81 3a       	cpi	r24, 0xA1	; 161
    5ef6:	b9 f4       	brne	.+46     	; 0x5f26 <HID_Device_ProcessControlRequest+0x262>
    5ef8:	e8 ee       	ldi	r30, 0xE8	; 232
    5efa:	f0 e0       	ldi	r31, 0x00	; 0
    5efc:	80 81       	ld	r24, Z
    5efe:	87 7f       	andi	r24, 0xF7	; 247
    5f00:	80 83       	st	Z, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    5f02:	80 81       	ld	r24, Z
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    5f04:	80 ff       	sbrs	r24, 0
    5f06:	fd cf       	rjmp	.-6      	; 0x5f02 <HID_Device_ProcessControlRequest+0x23e>
				Endpoint_Write_8(HIDInterfaceInfo->State.IdleCount >> 2);
    5f08:	f6 01       	movw	r30, r12
    5f0a:	84 85       	ldd	r24, Z+12	; 0x0c
    5f0c:	95 85       	ldd	r25, Z+13	; 0x0d
    5f0e:	96 95       	lsr	r25
    5f10:	87 95       	ror	r24
    5f12:	96 95       	lsr	r25
    5f14:	87 95       	ror	r24
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    5f16:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5f1a:	e8 ee       	ldi	r30, 0xE8	; 232
    5f1c:	f0 e0       	ldi	r31, 0x00	; 0
    5f1e:	80 81       	ld	r24, Z
    5f20:	8e 77       	andi	r24, 0x7E	; 126
    5f22:	80 83       	st	Z, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    5f24:	38 d6       	rcall	.+3184   	; 0x6b96 <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    5f26:	0f b6       	in	r0, 0x3f	; 63
    5f28:	f8 94       	cli
    5f2a:	fe be       	out	0x3e, r15	; 62
    5f2c:	0f be       	out	0x3f, r0	; 63
    5f2e:	ed be       	out	0x3d, r14	; 61
    5f30:	0f 90       	pop	r0
    5f32:	0f 90       	pop	r0
    5f34:	0f 90       	pop	r0
    5f36:	df 91       	pop	r29
    5f38:	cf 91       	pop	r28
    5f3a:	1f 91       	pop	r17
    5f3c:	0f 91       	pop	r16
    5f3e:	ff 90       	pop	r15
    5f40:	ef 90       	pop	r14
    5f42:	df 90       	pop	r13
    5f44:	cf 90       	pop	r12
    5f46:	bf 90       	pop	r11
    5f48:	af 90       	pop	r10
    5f4a:	9f 90       	pop	r9
    5f4c:	8f 90       	pop	r8
    5f4e:	7f 90       	pop	r7
    5f50:	6f 90       	pop	r6
    5f52:	5f 90       	pop	r5
    5f54:	4f 90       	pop	r4
    5f56:	3f 90       	pop	r3
    5f58:	08 95       	ret

00005f5a <HID_Device_ConfigureEndpoints>:

bool HID_Device_ConfigureEndpoints(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	memset(&HIDInterfaceInfo->State, 0x00, sizeof(HIDInterfaceInfo->State));
    5f5a:	fc 01       	movw	r30, r24
    5f5c:	39 96       	adiw	r30, 0x09	; 9
    5f5e:	27 e0       	ldi	r18, 0x07	; 7
    5f60:	df 01       	movw	r26, r30
    5f62:	1d 92       	st	X+, r1
    5f64:	2a 95       	dec	r18
    5f66:	e9 f7       	brne	.-6      	; 0x5f62 <HID_Device_ConfigureEndpoints+0x8>
	HIDInterfaceInfo->State.UsingReportProtocol = true;
    5f68:	21 e0       	ldi	r18, 0x01	; 1
    5f6a:	fc 01       	movw	r30, r24
    5f6c:	21 87       	std	Z+9, r18	; 0x09
	HIDInterfaceInfo->State.IdleCount           = 500;
    5f6e:	24 ef       	ldi	r18, 0xF4	; 244
    5f70:	31 e0       	ldi	r19, 0x01	; 1
    5f72:	35 87       	std	Z+13, r19	; 0x0d
    5f74:	24 87       	std	Z+12, r18	; 0x0c

	HIDInterfaceInfo->Config.ReportINEndpoint.Type = EP_TYPE_INTERRUPT;
    5f76:	23 e0       	ldi	r18, 0x03	; 3
    5f78:	24 83       	std	Z+4, r18	; 0x04

	if (!(Endpoint_ConfigureEndpointTable(&HIDInterfaceInfo->Config.ReportINEndpoint, 1)))
    5f7a:	61 e0       	ldi	r22, 0x01	; 1
    5f7c:	01 96       	adiw	r24, 0x01	; 1
    5f7e:	a5 c5       	rjmp	.+2890   	; 0x6aca <Endpoint_ConfigureEndpointTable>
	  return false;

	return true;
}
    5f80:	08 95       	ret

00005f82 <HID_Device_USBTask>:

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
    5f82:	5f 92       	push	r5
    5f84:	6f 92       	push	r6
    5f86:	7f 92       	push	r7
    5f88:	8f 92       	push	r8
    5f8a:	9f 92       	push	r9
    5f8c:	af 92       	push	r10
    5f8e:	bf 92       	push	r11
    5f90:	cf 92       	push	r12
    5f92:	df 92       	push	r13
    5f94:	ef 92       	push	r14
    5f96:	ff 92       	push	r15
    5f98:	0f 93       	push	r16
    5f9a:	1f 93       	push	r17
    5f9c:	cf 93       	push	r28
    5f9e:	df 93       	push	r29
    5fa0:	00 d0       	rcall	.+0      	; 0x5fa2 <HID_Device_USBTask+0x20>
    5fa2:	1f 92       	push	r1
    5fa4:	cd b7       	in	r28, 0x3d	; 61
    5fa6:	de b7       	in	r29, 0x3e	; 62
    5fa8:	7c 01       	movw	r14, r24
			Endpoint_ClearIN();
		}

		HIDInterfaceInfo->State.PrevFrameNum = USB_Device_GetFrameNumber();
	}
}
    5faa:	ad b6       	in	r10, 0x3d	; 61
    5fac:	be b6       	in	r11, 0x3e	; 62
	return true;
}

void HID_Device_USBTask(USB_ClassInfo_HID_Device_t* const HIDInterfaceInfo)
{
	if (USB_DeviceState != DEVICE_STATE_Configured)
    5fae:	80 91 6d 0a 	lds	r24, 0x0A6D
    5fb2:	84 30       	cpi	r24, 0x04	; 4
    5fb4:	09 f0       	breq	.+2      	; 0x5fb8 <HID_Device_USBTask+0x36>
    5fb6:	8e c0       	rjmp	.+284    	; 0x60d4 <HID_Device_USBTask+0x152>
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    5fb8:	80 91 e4 00 	lds	r24, 0x00E4
    5fbc:	90 91 e5 00 	lds	r25, 0x00E5
	  return;

	if (HIDInterfaceInfo->State.PrevFrameNum == USB_Device_GetFrameNumber())
    5fc0:	f7 01       	movw	r30, r14
    5fc2:	22 85       	ldd	r18, Z+10	; 0x0a
    5fc4:	33 85       	ldd	r19, Z+11	; 0x0b
    5fc6:	28 17       	cp	r18, r24
    5fc8:	39 07       	cpc	r19, r25
    5fca:	09 f4       	brne	.+2      	; 0x5fce <HID_Device_USBTask+0x4c>
    5fcc:	83 c0       	rjmp	.+262    	; 0x60d4 <HID_Device_USBTask+0x152>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5fce:	81 81       	ldd	r24, Z+1	; 0x01
    5fd0:	8f 70       	andi	r24, 0x0F	; 15
    5fd2:	80 93 e9 00 	sts	0x00E9, r24
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    5fd6:	80 91 e8 00 	lds	r24, 0x00E8
		#endif
	}

	Endpoint_SelectEndpoint(HIDInterfaceInfo->Config.ReportINEndpoint.Address);

	if (Endpoint_IsReadWriteAllowed())
    5fda:	85 ff       	sbrs	r24, 5
    5fdc:	7b c0       	rjmp	.+246    	; 0x60d4 <HID_Device_USBTask+0x152>
    5fde:	8d b6       	in	r8, 0x3d	; 61
    5fe0:	9e b6       	in	r9, 0x3e	; 62
	{
		uint8_t  ReportINData[HIDInterfaceInfo->Config.PrevReportINBufferSize];
    5fe2:	40 85       	ldd	r20, Z+8	; 0x08
    5fe4:	50 e0       	ldi	r21, 0x00	; 0
    5fe6:	8d b7       	in	r24, 0x3d	; 61
    5fe8:	9e b7       	in	r25, 0x3e	; 62
    5fea:	84 1b       	sub	r24, r20
    5fec:	95 0b       	sbc	r25, r21
    5fee:	0f b6       	in	r0, 0x3f	; 63
    5ff0:	f8 94       	cli
    5ff2:	9e bf       	out	0x3e, r25	; 62
    5ff4:	0f be       	out	0x3f, r0	; 63
    5ff6:	8d bf       	out	0x3d, r24	; 61
    5ff8:	ed b7       	in	r30, 0x3d	; 61
    5ffa:	fe b7       	in	r31, 0x3e	; 62
    5ffc:	31 96       	adiw	r30, 0x01	; 1
    5ffe:	6f 01       	movw	r12, r30
		uint8_t  ReportID     = 0;
    6000:	1b 82       	std	Y+3, r1	; 0x03
		uint16_t ReportINSize = 0;
    6002:	1a 82       	std	Y+2, r1	; 0x02
    6004:	19 82       	std	Y+1, r1	; 0x01

		memset(ReportINData, 0, sizeof(ReportINData));
    6006:	60 e0       	ldi	r22, 0x00	; 0
    6008:	70 e0       	ldi	r23, 0x00	; 0
    600a:	cf 01       	movw	r24, r30
    600c:	0e 94 e2 39 	call	0x73c4	; 0x73c4 <memset>

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
    6010:	8e 01       	movw	r16, r28
    6012:	0f 5f       	subi	r16, 0xFF	; 255
    6014:	1f 4f       	sbci	r17, 0xFF	; 255
    6016:	96 01       	movw	r18, r12
    6018:	40 e0       	ldi	r20, 0x00	; 0
    601a:	be 01       	movw	r22, r28
    601c:	6d 5f       	subi	r22, 0xFD	; 253
    601e:	7f 4f       	sbci	r23, 0xFF	; 255
    6020:	c7 01       	movw	r24, r14
    6022:	0e 94 86 27 	call	0x4f0c	; 0x4f0c <CALLBACK_HID_Device_CreateHIDReport>
    6026:	58 2e       	mov	r5, r24
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
		bool IdlePeriodElapsed = (HIDInterfaceInfo->State.IdleCount && !(HIDInterfaceInfo->State.IdleMSRemaining));
    6028:	f7 01       	movw	r30, r14
    602a:	84 85       	ldd	r24, Z+12	; 0x0c
    602c:	95 85       	ldd	r25, Z+13	; 0x0d
    602e:	89 2b       	or	r24, r25
    6030:	41 f0       	breq	.+16     	; 0x6042 <HID_Device_USBTask+0xc0>
    6032:	81 e0       	ldi	r24, 0x01	; 1
    6034:	26 85       	ldd	r18, Z+14	; 0x0e
    6036:	37 85       	ldd	r19, Z+15	; 0x0f
    6038:	23 2b       	or	r18, r19
    603a:	09 f0       	breq	.+2      	; 0x603e <HID_Device_USBTask+0xbc>
    603c:	80 e0       	ldi	r24, 0x00	; 0
    603e:	78 2e       	mov	r7, r24
    6040:	01 c0       	rjmp	.+2      	; 0x6044 <HID_Device_USBTask+0xc2>
    6042:	71 2c       	mov	r7, r1

		if (HIDInterfaceInfo->Config.PrevReportINBuffer != NULL)
    6044:	f7 01       	movw	r30, r14
    6046:	06 81       	ldd	r16, Z+6	; 0x06
    6048:	17 81       	ldd	r17, Z+7	; 0x07
    604a:	01 15       	cp	r16, r1
    604c:	11 05       	cpc	r17, r1
    604e:	99 f0       	breq	.+38     	; 0x6076 <HID_Device_USBTask+0xf4>
		{
			StatesChanged = (memcmp(ReportINData, HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINSize) != 0);
    6050:	49 81       	ldd	r20, Y+1	; 0x01
    6052:	5a 81       	ldd	r21, Y+2	; 0x02
    6054:	b8 01       	movw	r22, r16
    6056:	c6 01       	movw	r24, r12
    6058:	0e 94 cc 39 	call	0x7398	; 0x7398 <memcmp>
    605c:	66 24       	eor	r6, r6
    605e:	63 94       	inc	r6
    6060:	89 2b       	or	r24, r25
    6062:	09 f4       	brne	.+2      	; 0x6066 <HID_Device_USBTask+0xe4>
    6064:	61 2c       	mov	r6, r1
			memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINData, HIDInterfaceInfo->Config.PrevReportINBufferSize);
    6066:	f7 01       	movw	r30, r14
    6068:	40 85       	ldd	r20, Z+8	; 0x08
    606a:	50 e0       	ldi	r21, 0x00	; 0
    606c:	b6 01       	movw	r22, r12
    606e:	c8 01       	movw	r24, r16
    6070:	0e 94 d9 39 	call	0x73b2	; 0x73b2 <memcpy>
    6074:	01 c0       	rjmp	.+2      	; 0x6078 <HID_Device_USBTask+0xf6>

		memset(ReportINData, 0, sizeof(ReportINData));

		bool ForceSend         = CALLBACK_HID_Device_CreateHIDReport(HIDInterfaceInfo, &ReportID, HID_REPORT_ITEM_In,
		                                                             ReportINData, &ReportINSize);
		bool StatesChanged     = false;
    6076:	61 2c       	mov	r6, r1
		{
			StatesChanged = (memcmp(ReportINData, HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINSize) != 0);
			memcpy(HIDInterfaceInfo->Config.PrevReportINBuffer, ReportINData, HIDInterfaceInfo->Config.PrevReportINBufferSize);
		}

		if (ReportINSize && (ForceSend || StatesChanged || IdlePeriodElapsed))
    6078:	89 81       	ldd	r24, Y+1	; 0x01
    607a:	9a 81       	ldd	r25, Y+2	; 0x02
    607c:	89 2b       	or	r24, r25
    607e:	f1 f0       	breq	.+60     	; 0x60bc <HID_Device_USBTask+0x13a>
    6080:	51 10       	cpse	r5, r1
    6082:	04 c0       	rjmp	.+8      	; 0x608c <HID_Device_USBTask+0x10a>
    6084:	61 10       	cpse	r6, r1
    6086:	02 c0       	rjmp	.+4      	; 0x608c <HID_Device_USBTask+0x10a>
    6088:	70 fe       	sbrs	r7, 0
    608a:	18 c0       	rjmp	.+48     	; 0x60bc <HID_Device_USBTask+0x13a>
		{
			HIDInterfaceInfo->State.IdleMSRemaining = HIDInterfaceInfo->State.IdleCount;
    608c:	f7 01       	movw	r30, r14
    608e:	84 85       	ldd	r24, Z+12	; 0x0c
    6090:	95 85       	ldd	r25, Z+13	; 0x0d
    6092:	97 87       	std	Z+15, r25	; 0x0f
    6094:	86 87       	std	Z+14, r24	; 0x0e
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6096:	81 81       	ldd	r24, Z+1	; 0x01
    6098:	8f 70       	andi	r24, 0x0F	; 15
    609a:	80 93 e9 00 	sts	0x00E9, r24

			Endpoint_SelectEndpoint(HIDInterfaceInfo->Config.ReportINEndpoint.Address);

			if (ReportID)
    609e:	8b 81       	ldd	r24, Y+3	; 0x03
    60a0:	81 11       	cpse	r24, r1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    60a2:	80 93 f1 00 	sts	0x00F1, r24
			  Endpoint_Write_8(ReportID);

			Endpoint_Write_Stream_LE(ReportINData, ReportINSize, NULL);
    60a6:	69 81       	ldd	r22, Y+1	; 0x01
    60a8:	7a 81       	ldd	r23, Y+2	; 0x02
    60aa:	40 e0       	ldi	r20, 0x00	; 0
    60ac:	50 e0       	ldi	r21, 0x00	; 0
    60ae:	c6 01       	movw	r24, r12
    60b0:	0a d2       	rcall	.+1044   	; 0x64c6 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    60b2:	e8 ee       	ldi	r30, 0xE8	; 232
    60b4:	f0 e0       	ldi	r31, 0x00	; 0
    60b6:	80 81       	ld	r24, Z
    60b8:	8e 77       	andi	r24, 0x7E	; 126
    60ba:	80 83       	st	Z, r24
    60bc:	80 91 e4 00 	lds	r24, 0x00E4
    60c0:	90 91 e5 00 	lds	r25, 0x00E5

			Endpoint_ClearIN();
		}

		HIDInterfaceInfo->State.PrevFrameNum = USB_Device_GetFrameNumber();
    60c4:	f7 01       	movw	r30, r14
    60c6:	93 87       	std	Z+11, r25	; 0x0b
    60c8:	82 87       	std	Z+10, r24	; 0x0a
    60ca:	0f b6       	in	r0, 0x3f	; 63
    60cc:	f8 94       	cli
    60ce:	9e be       	out	0x3e, r9	; 62
    60d0:	0f be       	out	0x3f, r0	; 63
    60d2:	8d be       	out	0x3d, r8	; 61
	}
}
    60d4:	0f b6       	in	r0, 0x3f	; 63
    60d6:	f8 94       	cli
    60d8:	be be       	out	0x3e, r11	; 62
    60da:	0f be       	out	0x3f, r0	; 63
    60dc:	ad be       	out	0x3d, r10	; 61
    60de:	0f 90       	pop	r0
    60e0:	0f 90       	pop	r0
    60e2:	0f 90       	pop	r0
    60e4:	df 91       	pop	r29
    60e6:	cf 91       	pop	r28
    60e8:	1f 91       	pop	r17
    60ea:	0f 91       	pop	r16
    60ec:	ff 90       	pop	r15
    60ee:	ef 90       	pop	r14
    60f0:	df 90       	pop	r13
    60f2:	cf 90       	pop	r12
    60f4:	bf 90       	pop	r11
    60f6:	af 90       	pop	r10
    60f8:	9f 90       	pop	r9
    60fa:	8f 90       	pop	r8
    60fc:	7f 90       	pop	r7
    60fe:	6f 90       	pop	r6
    6100:	5f 90       	pop	r5
    6102:	08 95       	ret

00006104 <MS_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_MS_DRIVER
#define  __INCLUDE_FROM_MASSSTORAGE_DEVICE_C
#include "MassStorageClassDevice.h"

void MS_Device_ProcessControlRequest(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    6104:	cf 93       	push	r28
    6106:	df 93       	push	r29
    6108:	fc 01       	movw	r30, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    610a:	90 91 e8 00 	lds	r25, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    610e:	93 ff       	sbrs	r25, 3
    6110:	33 c0       	rjmp	.+102    	; 0x6178 <MS_Device_ProcessControlRequest+0x74>
	  return;

	if (USB_ControlRequest.wIndex != MSInterfaceInfo->Config.InterfaceNumber)
    6112:	20 81       	ld	r18, Z
    6114:	30 e0       	ldi	r19, 0x00	; 0
    6116:	80 91 72 0a 	lds	r24, 0x0A72
    611a:	90 91 73 0a 	lds	r25, 0x0A73
    611e:	82 17       	cp	r24, r18
    6120:	93 07       	cpc	r25, r19
    6122:	51 f5       	brne	.+84     	; 0x6178 <MS_Device_ProcessControlRequest+0x74>
    6124:	ef 01       	movw	r28, r30
	  return;

	switch (USB_ControlRequest.bRequest)
    6126:	80 91 6f 0a 	lds	r24, 0x0A6F
    612a:	8e 3f       	cpi	r24, 0xFE	; 254
    612c:	79 f0       	breq	.+30     	; 0x614c <MS_Device_ProcessControlRequest+0x48>
    612e:	8f 3f       	cpi	r24, 0xFF	; 255
    6130:	19 f5       	brne	.+70     	; 0x6178 <MS_Device_ProcessControlRequest+0x74>
	{
		case MS_REQ_MassStorageReset:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    6132:	80 91 6e 0a 	lds	r24, 0x0A6E
    6136:	81 32       	cpi	r24, 0x21	; 33
    6138:	f9 f4       	brne	.+62     	; 0x6178 <MS_Device_ProcessControlRequest+0x74>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    613a:	e8 ee       	ldi	r30, 0xE8	; 232
    613c:	f0 e0       	ldi	r31, 0x00	; 0
    613e:	80 81       	ld	r24, Z
    6140:	87 7f       	andi	r24, 0xF7	; 247
    6142:	80 83       	st	Z, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    6144:	28 d5       	rcall	.+2640   	; 0x6b96 <Endpoint_ClearStatusStage>

				MSInterfaceInfo->State.IsMassStoreReset = true;
    6146:	81 e0       	ldi	r24, 0x01	; 1
    6148:	88 af       	std	Y+56, r24	; 0x38
    614a:	16 c0       	rjmp	.+44     	; 0x6178 <MS_Device_ProcessControlRequest+0x74>
			}

			break;
		case MS_REQ_GetMaxLUN:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    614c:	80 91 6e 0a 	lds	r24, 0x0A6E
    6150:	81 3a       	cpi	r24, 0xA1	; 161
    6152:	91 f4       	brne	.+36     	; 0x6178 <MS_Device_ProcessControlRequest+0x74>
    6154:	e8 ee       	ldi	r30, 0xE8	; 232
    6156:	f0 e0       	ldi	r31, 0x00	; 0
    6158:	80 81       	ld	r24, Z
    615a:	87 7f       	andi	r24, 0xF7	; 247
    615c:	80 83       	st	Z, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    615e:	80 81       	ld	r24, Z
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    6160:	80 ff       	sbrs	r24, 0
    6162:	fd cf       	rjmp	.-6      	; 0x615e <MS_Device_ProcessControlRequest+0x5a>
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
    6164:	8b 85       	ldd	r24, Y+11	; 0x0b
    6166:	81 50       	subi	r24, 0x01	; 1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    6168:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    616c:	e8 ee       	ldi	r30, 0xE8	; 232
    616e:	f0 e0       	ldi	r31, 0x00	; 0
    6170:	80 81       	ld	r24, Z
    6172:	8e 77       	andi	r24, 0x7E	; 126
    6174:	80 83       	st	Z, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    6176:	0f d5       	rcall	.+2590   	; 0x6b96 <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    6178:	df 91       	pop	r29
    617a:	cf 91       	pop	r28
    617c:	08 95       	ret

0000617e <MS_Device_ConfigureEndpoints>:

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    617e:	cf 93       	push	r28
    6180:	df 93       	push	r29
    6182:	ec 01       	movw	r28, r24
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));
    6184:	fc 01       	movw	r30, r24
    6186:	3c 96       	adiw	r30, 0x0c	; 12
    6188:	8d e2       	ldi	r24, 0x2D	; 45
    618a:	df 01       	movw	r26, r30
    618c:	1d 92       	st	X+, r1
    618e:	8a 95       	dec	r24
    6190:	e9 f7       	brne	.-6      	; 0x618c <MS_Device_ConfigureEndpoints+0xe>

	MSInterfaceInfo->Config.DataINEndpoint.Type  = EP_TYPE_BULK;
    6192:	82 e0       	ldi	r24, 0x02	; 2
    6194:	8c 83       	std	Y+4, r24	; 0x04
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;
    6196:	89 87       	std	Y+9, r24	; 0x09

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
    6198:	61 e0       	ldi	r22, 0x01	; 1
    619a:	ce 01       	movw	r24, r28
    619c:	01 96       	adiw	r24, 0x01	; 1
    619e:	95 d4       	rcall	.+2346   	; 0x6aca <Endpoint_ConfigureEndpointTable>
    61a0:	88 23       	and	r24, r24
    61a2:	21 f0       	breq	.+8      	; 0x61ac <MS_Device_ConfigureEndpoints+0x2e>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
    61a4:	61 e0       	ldi	r22, 0x01	; 1
    61a6:	ce 01       	movw	r24, r28
    61a8:	06 96       	adiw	r24, 0x06	; 6
    61aa:	8f d4       	rcall	.+2334   	; 0x6aca <Endpoint_ConfigureEndpointTable>
	  return false;

	return true;
}
    61ac:	df 91       	pop	r29
    61ae:	cf 91       	pop	r28
    61b0:	08 95       	ret

000061b2 <MS_Device_USBTask>:

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    61b2:	ef 92       	push	r14
    61b4:	ff 92       	push	r15
    61b6:	0f 93       	push	r16
    61b8:	1f 93       	push	r17
    61ba:	cf 93       	push	r28
    61bc:	df 93       	push	r29
    61be:	00 d0       	rcall	.+0      	; 0x61c0 <MS_Device_USBTask+0xe>
    61c0:	cd b7       	in	r28, 0x3d	; 61
    61c2:	de b7       	in	r29, 0x3e	; 62
    61c4:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    61c6:	90 91 6d 0a 	lds	r25, 0x0A6D
    61ca:	94 30       	cpi	r25, 0x04	; 4
    61cc:	09 f0       	breq	.+2      	; 0x61d0 <MS_Device_USBTask+0x1e>
    61ce:	23 c1       	rjmp	.+582    	; 0x6416 <MS_Device_USBTask+0x264>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    61d0:	d8 01       	movw	r26, r16
    61d2:	16 96       	adiw	r26, 0x06	; 6
    61d4:	8c 91       	ld	r24, X
    61d6:	16 97       	sbiw	r26, 0x06	; 6
    61d8:	8f 70       	andi	r24, 0x0F	; 15
    61da:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    61de:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	if (Endpoint_IsOUTReceived())
    61e2:	82 ff       	sbrs	r24, 2
    61e4:	dd c0       	rjmp	.+442    	; 0x63a0 <MS_Device_USBTask+0x1ee>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    61e6:	16 96       	adiw	r26, 0x06	; 6
    61e8:	8c 91       	ld	r24, X
    61ea:	8f 70       	andi	r24, 0x0F	; 15
    61ec:	80 93 e9 00 	sts	0x00E9, r24
{
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	BytesProcessed = 0;
    61f0:	1a 82       	std	Y+2, r1	; 0x02
    61f2:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    61f4:	78 01       	movw	r14, r16
    61f6:	bc e0       	ldi	r27, 0x0C	; 12
    61f8:	eb 0e       	add	r14, r27
    61fa:	f1 1c       	adc	r15, r1
    61fc:	04 c0       	rjmp	.+8      	; 0x6206 <MS_Device_USBTask+0x54>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    61fe:	f8 01       	movw	r30, r16
    6200:	90 ad       	ldd	r25, Z+56	; 0x38
    6202:	91 11       	cpse	r25, r1
    6204:	cd c0       	rjmp	.+410    	; 0x63a0 <MS_Device_USBTask+0x1ee>
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    6206:	ae 01       	movw	r20, r28
    6208:	4f 5f       	subi	r20, 0xFF	; 255
    620a:	5f 4f       	sbci	r21, 0xFF	; 255
    620c:	6f e0       	ldi	r22, 0x0F	; 15
    620e:	70 e0       	ldi	r23, 0x00	; 0
    6210:	c7 01       	movw	r24, r14
    6212:	18 d2       	rcall	.+1072   	; 0x6644 <Endpoint_Read_Stream_LE>
    6214:	85 30       	cpi	r24, 0x05	; 5
    6216:	99 f3       	breq	.-26     	; 0x61fe <MS_Device_USBTask+0x4c>
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
    6218:	f8 01       	movw	r30, r16
    621a:	84 85       	ldd	r24, Z+12	; 0x0c
    621c:	95 85       	ldd	r25, Z+13	; 0x0d
    621e:	a6 85       	ldd	r26, Z+14	; 0x0e
    6220:	b7 85       	ldd	r27, Z+15	; 0x0f
    6222:	85 35       	cpi	r24, 0x55	; 85
    6224:	93 45       	sbci	r25, 0x53	; 83
    6226:	a2 44       	sbci	r26, 0x42	; 66
    6228:	b3 44       	sbci	r27, 0x43	; 67
    622a:	99 f4       	brne	.+38     	; 0x6252 <MS_Device_USBTask+0xa0>
    622c:	d8 01       	movw	r26, r16
    622e:	59 96       	adiw	r26, 0x19	; 25
    6230:	9c 91       	ld	r25, X
    6232:	59 97       	sbiw	r26, 0x19	; 25
    6234:	1b 96       	adiw	r26, 0x0b	; 11
    6236:	8c 91       	ld	r24, X
    6238:	1b 97       	sbiw	r26, 0x0b	; 11
    623a:	98 17       	cp	r25, r24
    623c:	50 f4       	brcc	.+20     	; 0x6252 <MS_Device_USBTask+0xa0>
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    623e:	58 96       	adiw	r26, 0x18	; 24
    6240:	8c 91       	ld	r24, X
    6242:	58 97       	sbiw	r26, 0x18	; 24
    6244:	8f 71       	andi	r24, 0x1F	; 31
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
    6246:	29 f4       	brne	.+10     	; 0x6252 <MS_Device_USBTask+0xa0>
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    6248:	5a 96       	adiw	r26, 0x1a	; 26
    624a:	8c 91       	ld	r24, X
    624c:	81 50       	subi	r24, 0x01	; 1
    624e:	80 31       	cpi	r24, 0x10	; 16
    6250:	78 f0       	brcs	.+30     	; 0x6270 <MS_Device_USBTask+0xbe>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6252:	eb ee       	ldi	r30, 0xEB	; 235
    6254:	f0 e0       	ldi	r31, 0x00	; 0
    6256:	80 81       	ld	r24, Z
    6258:	80 62       	ori	r24, 0x20	; 32
    625a:	80 83       	st	Z, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    625c:	d8 01       	movw	r26, r16
    625e:	11 96       	adiw	r26, 0x01	; 1
    6260:	8c 91       	ld	r24, X
    6262:	8f 70       	andi	r24, 0x0F	; 15
    6264:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6268:	80 81       	ld	r24, Z
    626a:	80 62       	ori	r24, 0x20	; 32
    626c:	80 83       	st	Z, r24
    626e:	98 c0       	rjmp	.+304    	; 0x63a0 <MS_Device_USBTask+0x1ee>
		Endpoint_StallTransaction();

		return false;
	}

	BytesProcessed = 0;
    6270:	1a 82       	std	Y+2, r1	; 0x02
    6272:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    6274:	78 01       	movw	r14, r16
    6276:	bb e1       	ldi	r27, 0x1B	; 27
    6278:	eb 0e       	add	r14, r27
    627a:	f1 1c       	adc	r15, r1
    627c:	04 c0       	rjmp	.+8      	; 0x6286 <MS_Device_USBTask+0xd4>
	                                MSInterfaceInfo->State.CommandBlock.SCSICommandLength, &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    627e:	f8 01       	movw	r30, r16
    6280:	90 ad       	ldd	r25, Z+56	; 0x38
    6282:	91 11       	cpse	r25, r1
    6284:	8d c0       	rjmp	.+282    	; 0x63a0 <MS_Device_USBTask+0x1ee>

		return false;
	}

	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    6286:	d8 01       	movw	r26, r16
    6288:	5a 96       	adiw	r26, 0x1a	; 26
    628a:	6c 91       	ld	r22, X
    628c:	70 e0       	ldi	r23, 0x00	; 0
    628e:	ae 01       	movw	r20, r28
    6290:	4f 5f       	subi	r20, 0xFF	; 255
    6292:	5f 4f       	sbci	r21, 0xFF	; 255
    6294:	c7 01       	movw	r24, r14
    6296:	d6 d1       	rcall	.+940    	; 0x6644 <Endpoint_Read_Stream_LE>
    6298:	85 30       	cpi	r24, 0x05	; 5
    629a:	89 f3       	breq	.-30     	; 0x627e <MS_Device_USBTask+0xcc>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    629c:	e8 ee       	ldi	r30, 0xE8	; 232
    629e:	f0 e0       	ldi	r31, 0x00	; 0
    62a0:	80 81       	ld	r24, Z
    62a2:	8b 77       	andi	r24, 0x7B	; 123
    62a4:	80 83       	st	Z, r24

	if (Endpoint_IsOUTReceived())
	{
		if (MS_Device_ReadInCommandBlock(MSInterfaceInfo))
		{
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
    62a6:	f8 01       	movw	r30, r16
    62a8:	80 8d       	ldd	r24, Z+24	; 0x18
    62aa:	88 23       	and	r24, r24
    62ac:	24 f4       	brge	.+8      	; 0x62b6 <MS_Device_USBTask+0x104>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    62ae:	81 81       	ldd	r24, Z+1	; 0x01
    62b0:	8f 70       	andi	r24, 0x0F	; 15
    62b2:	80 93 e9 00 	sts	0x00E9, r24
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

			bool SCSICommandResult = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo);
    62b6:	c8 01       	movw	r24, r16
    62b8:	0e 94 84 27 	call	0x4f08	; 0x4f08 <CALLBACK_MS_Device_SCSICommandReceived>

			MSInterfaceInfo->State.CommandStatus.Status              = (SCSICommandResult) ? MS_SCSI_COMMAND_Pass : MS_SCSI_COMMAND_Fail;
    62bc:	91 e0       	ldi	r25, 0x01	; 1
    62be:	98 27       	eor	r25, r24
    62c0:	d8 01       	movw	r26, r16
    62c2:	d7 96       	adiw	r26, 0x37	; 55
    62c4:	9c 93       	st	X, r25
    62c6:	d7 97       	sbiw	r26, 0x37	; 55
			MSInterfaceInfo->State.CommandStatus.Signature           = CPU_TO_LE32(MS_CSW_SIGNATURE);
    62c8:	45 e5       	ldi	r20, 0x55	; 85
    62ca:	53 e5       	ldi	r21, 0x53	; 83
    62cc:	62 e4       	ldi	r22, 0x42	; 66
    62ce:	73 e5       	ldi	r23, 0x53	; 83
    62d0:	f8 01       	movw	r30, r16
    62d2:	43 a7       	std	Z+43, r20	; 0x2b
    62d4:	54 a7       	std	Z+44, r21	; 0x2c
    62d6:	65 a7       	std	Z+45, r22	; 0x2d
    62d8:	76 a7       	std	Z+46, r23	; 0x2e
			MSInterfaceInfo->State.CommandStatus.Tag                 = MSInterfaceInfo->State.CommandBlock.Tag;
    62da:	40 89       	ldd	r20, Z+16	; 0x10
    62dc:	51 89       	ldd	r21, Z+17	; 0x11
    62de:	62 89       	ldd	r22, Z+18	; 0x12
    62e0:	73 89       	ldd	r23, Z+19	; 0x13
    62e2:	9f 96       	adiw	r26, 0x2f	; 47
    62e4:	4d 93       	st	X+, r20
    62e6:	5d 93       	st	X+, r21
    62e8:	6d 93       	st	X+, r22
    62ea:	7c 93       	st	X, r23
    62ec:	d2 97       	sbiw	r26, 0x32	; 50
			MSInterfaceInfo->State.CommandStatus.DataTransferResidue = MSInterfaceInfo->State.CommandBlock.DataTransferLength;
    62ee:	54 96       	adiw	r26, 0x14	; 20
    62f0:	4d 91       	ld	r20, X+
    62f2:	5d 91       	ld	r21, X+
    62f4:	6d 91       	ld	r22, X+
    62f6:	7c 91       	ld	r23, X
    62f8:	57 97       	sbiw	r26, 0x17	; 23
    62fa:	43 ab       	std	Z+51, r20	; 0x33
    62fc:	54 ab       	std	Z+52, r21	; 0x34
    62fe:	65 ab       	std	Z+53, r22	; 0x35
    6300:	76 ab       	std	Z+54, r23	; 0x36

			if (!(SCSICommandResult) && (le32_to_cpu(MSInterfaceInfo->State.CommandStatus.DataTransferResidue)))
    6302:	81 11       	cpse	r24, r1
    6304:	09 c0       	rjmp	.+18     	; 0x6318 <MS_Device_USBTask+0x166>
    6306:	45 2b       	or	r20, r21
    6308:	46 2b       	or	r20, r22
    630a:	47 2b       	or	r20, r23
    630c:	29 f0       	breq	.+10     	; 0x6318 <MS_Device_USBTask+0x166>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    630e:	eb ee       	ldi	r30, 0xEB	; 235
    6310:	f0 e0       	ldi	r31, 0x00	; 0
    6312:	80 81       	ld	r24, Z
    6314:	80 62       	ori	r24, 0x20	; 32
    6316:	80 83       	st	Z, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6318:	d8 01       	movw	r26, r16
    631a:	16 96       	adiw	r26, 0x06	; 6
    631c:	8c 91       	ld	r24, X
    631e:	8f 70       	andi	r24, 0x0F	; 15
    6320:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    6324:	0f 2e       	mov	r0, r31
    6326:	fb ee       	ldi	r31, 0xEB	; 235
    6328:	ef 2e       	mov	r14, r31
    632a:	f1 2c       	mov	r15, r1
    632c:	f0 2d       	mov	r31, r0
    632e:	05 c0       	rjmp	.+10     	; 0x633a <MS_Device_USBTask+0x188>
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	while (Endpoint_IsStalled())
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
    6330:	41 d7       	rcall	.+3714   	; 0x71b4 <USB_USBTask>
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    6332:	f8 01       	movw	r30, r16
    6334:	80 ad       	ldd	r24, Z+56	; 0x38
    6336:	81 11       	cpse	r24, r1
    6338:	33 c0       	rjmp	.+102    	; 0x63a0 <MS_Device_USBTask+0x1ee>
    633a:	d7 01       	movw	r26, r14
    633c:	8c 91       	ld	r24, X

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	while (Endpoint_IsStalled())
    633e:	85 fd       	sbrc	r24, 5
    6340:	f7 cf       	rjmp	.-18     	; 0x6330 <MS_Device_USBTask+0x17e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6342:	f8 01       	movw	r30, r16
    6344:	81 81       	ldd	r24, Z+1	; 0x01
    6346:	8f 70       	andi	r24, 0x0F	; 15
    6348:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    634c:	0f 2e       	mov	r0, r31
    634e:	fb ee       	ldi	r31, 0xEB	; 235
    6350:	ef 2e       	mov	r14, r31
    6352:	f1 2c       	mov	r15, r1
    6354:	f0 2d       	mov	r31, r0
    6356:	06 c0       	rjmp	.+12     	; 0x6364 <MS_Device_USBTask+0x1b2>
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

	while (Endpoint_IsStalled())
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
    6358:	2d d7       	rcall	.+3674   	; 0x71b4 <USB_USBTask>
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    635a:	d8 01       	movw	r26, r16
    635c:	d8 96       	adiw	r26, 0x38	; 56
    635e:	8c 91       	ld	r24, X
    6360:	81 11       	cpse	r24, r1
    6362:	1e c0       	rjmp	.+60     	; 0x63a0 <MS_Device_USBTask+0x1ee>
    6364:	f7 01       	movw	r30, r14
    6366:	80 81       	ld	r24, Z
		  return;
	}

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

	while (Endpoint_IsStalled())
    6368:	85 fd       	sbrc	r24, 5
    636a:	f6 cf       	rjmp	.-20     	; 0x6358 <MS_Device_USBTask+0x1a6>

		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	uint16_t BytesProcessed = 0;
    636c:	1a 82       	std	Y+2, r1	; 0x02
    636e:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    6370:	78 01       	movw	r14, r16
    6372:	fb e2       	ldi	r31, 0x2B	; 43
    6374:	ef 0e       	add	r14, r31
    6376:	f1 1c       	adc	r15, r1
    6378:	05 c0       	rjmp	.+10     	; 0x6384 <MS_Device_USBTask+0x1d2>
	                                sizeof(MS_CommandStatusWrapper_t), &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    637a:	d8 01       	movw	r26, r16
    637c:	d8 96       	adiw	r26, 0x38	; 56
    637e:	9c 91       	ld	r25, X
    6380:	91 11       	cpse	r25, r1
    6382:	0e c0       	rjmp	.+28     	; 0x63a0 <MS_Device_USBTask+0x1ee>
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	uint16_t BytesProcessed = 0;
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    6384:	ae 01       	movw	r20, r28
    6386:	4f 5f       	subi	r20, 0xFF	; 255
    6388:	5f 4f       	sbci	r21, 0xFF	; 255
    638a:	6d e0       	ldi	r22, 0x0D	; 13
    638c:	70 e0       	ldi	r23, 0x00	; 0
    638e:	c7 01       	movw	r24, r14
    6390:	9a d0       	rcall	.+308    	; 0x64c6 <Endpoint_Write_Stream_LE>
    6392:	85 30       	cpi	r24, 0x05	; 5
    6394:	91 f3       	breq	.-28     	; 0x637a <MS_Device_USBTask+0x1c8>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6396:	e8 ee       	ldi	r30, 0xE8	; 232
    6398:	f0 e0       	ldi	r31, 0x00	; 0
    639a:	80 81       	ld	r24, Z
    639c:	8e 77       	andi	r24, 0x7E	; 126
    639e:	80 83       	st	Z, r24

			MS_Device_ReturnCommandStatus(MSInterfaceInfo);
		}
	}

	if (MSInterfaceInfo->State.IsMassStoreReset)
    63a0:	f8 01       	movw	r30, r16
    63a2:	80 ad       	ldd	r24, Z+56	; 0x38
    63a4:	88 23       	and	r24, r24
    63a6:	b9 f1       	breq	.+110    	; 0x6416 <MS_Device_USBTask+0x264>
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    63a8:	26 81       	ldd	r18, Z+6	; 0x06
    63aa:	2f 70       	andi	r18, 0x0F	; 15
    63ac:	81 e0       	ldi	r24, 0x01	; 1
    63ae:	90 e0       	ldi	r25, 0x00	; 0
    63b0:	ac 01       	movw	r20, r24
    63b2:	02 c0       	rjmp	.+4      	; 0x63b8 <MS_Device_USBTask+0x206>
    63b4:	44 0f       	add	r20, r20
    63b6:	55 1f       	adc	r21, r21
    63b8:	2a 95       	dec	r18
    63ba:	e2 f7       	brpl	.-8      	; 0x63b4 <MS_Device_USBTask+0x202>
    63bc:	ea ee       	ldi	r30, 0xEA	; 234
    63be:	f0 e0       	ldi	r31, 0x00	; 0
    63c0:	40 83       	st	Z, r20
				UERST = 0;
    63c2:	10 82       	st	Z, r1
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    63c4:	d8 01       	movw	r26, r16
    63c6:	11 96       	adiw	r26, 0x01	; 1
    63c8:	2c 91       	ld	r18, X
    63ca:	11 97       	sbiw	r26, 0x01	; 1
    63cc:	2f 70       	andi	r18, 0x0F	; 15
    63ce:	02 c0       	rjmp	.+4      	; 0x63d4 <MS_Device_USBTask+0x222>
    63d0:	88 0f       	add	r24, r24
    63d2:	99 1f       	adc	r25, r25
    63d4:	2a 95       	dec	r18
    63d6:	e2 f7       	brpl	.-8      	; 0x63d0 <MS_Device_USBTask+0x21e>
    63d8:	80 83       	st	Z, r24
				UERST = 0;
    63da:	10 82       	st	Z, r1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    63dc:	16 96       	adiw	r26, 0x06	; 6
    63de:	8c 91       	ld	r24, X
    63e0:	16 97       	sbiw	r26, 0x06	; 6
    63e2:	8f 70       	andi	r24, 0x0F	; 15
    63e4:	29 ee       	ldi	r18, 0xE9	; 233
    63e6:	30 e0       	ldi	r19, 0x00	; 0
    63e8:	f9 01       	movw	r30, r18
    63ea:	80 83       	st	Z, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    63ec:	eb ee       	ldi	r30, 0xEB	; 235
    63ee:	f0 e0       	ldi	r31, 0x00	; 0
    63f0:	80 81       	ld	r24, Z
    63f2:	80 61       	ori	r24, 0x10	; 16
    63f4:	80 83       	st	Z, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    63f6:	80 81       	ld	r24, Z
    63f8:	88 60       	ori	r24, 0x08	; 8
    63fa:	80 83       	st	Z, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    63fc:	11 96       	adiw	r26, 0x01	; 1
    63fe:	8c 91       	ld	r24, X
    6400:	8f 70       	andi	r24, 0x0F	; 15
    6402:	d9 01       	movw	r26, r18
    6404:	8c 93       	st	X, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6406:	80 81       	ld	r24, Z
    6408:	80 61       	ori	r24, 0x10	; 16
    640a:	80 83       	st	Z, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    640c:	80 81       	ld	r24, Z
    640e:	88 60       	ori	r24, 0x08	; 8
    6410:	80 83       	st	Z, r24
		Endpoint_ResetDataToggle();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);
		Endpoint_ClearStall();
		Endpoint_ResetDataToggle();

		MSInterfaceInfo->State.IsMassStoreReset = false;
    6412:	f8 01       	movw	r30, r16
    6414:	10 ae       	std	Z+56, r1	; 0x38
	}
}
    6416:	0f 90       	pop	r0
    6418:	0f 90       	pop	r0
    641a:	df 91       	pop	r29
    641c:	cf 91       	pop	r28
    641e:	1f 91       	pop	r17
    6420:	0f 91       	pop	r16
    6422:	ff 90       	pop	r15
    6424:	ef 90       	pop	r14
    6426:	08 95       	ret

00006428 <Endpoint_Null_Stream>:
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    6428:	af 92       	push	r10
    642a:	bf 92       	push	r11
    642c:	cf 92       	push	r12
    642e:	df 92       	push	r13
    6430:	ef 92       	push	r14
    6432:	ff 92       	push	r15
    6434:	0f 93       	push	r16
    6436:	1f 93       	push	r17
    6438:	cf 93       	push	r28
    643a:	df 93       	push	r29
    643c:	ec 01       	movw	r28, r24
    643e:	6b 01       	movw	r12, r22
    6440:	ce d3       	rcall	.+1948   	; 0x6bde <Endpoint_WaitUntilReady>
    6442:	81 11       	cpse	r24, r1
    6444:	35 c0       	rjmp	.+106    	; 0x64b0 <Endpoint_Null_Stream+0x88>
    6446:	c1 14       	cp	r12, r1
    6448:	d1 04       	cpc	r13, r1
    644a:	29 f0       	breq	.+10     	; 0x6456 <Endpoint_Null_Stream+0x2e>
    644c:	f6 01       	movw	r30, r12
    644e:	80 81       	ld	r24, Z
    6450:	91 81       	ldd	r25, Z+1	; 0x01
    6452:	c8 1b       	sub	r28, r24
    6454:	d9 0b       	sbc	r29, r25
    6456:	20 97       	sbiw	r28, 0x00	; 0
    6458:	51 f1       	breq	.+84     	; 0x64ae <Endpoint_Null_Stream+0x86>
    645a:	e1 2c       	mov	r14, r1
    645c:	f1 2c       	mov	r15, r1
    645e:	08 ee       	ldi	r16, 0xE8	; 232
    6460:	10 e0       	ldi	r17, 0x00	; 0
    6462:	0f 2e       	mov	r0, r31
    6464:	f1 ef       	ldi	r31, 0xF1	; 241
    6466:	af 2e       	mov	r10, r31
    6468:	b1 2c       	mov	r11, r1
    646a:	f0 2d       	mov	r31, r0
    646c:	f8 01       	movw	r30, r16
    646e:	80 81       	ld	r24, Z
    6470:	85 fd       	sbrc	r24, 5
    6472:	13 c0       	rjmp	.+38     	; 0x649a <Endpoint_Null_Stream+0x72>
    6474:	80 81       	ld	r24, Z
    6476:	8e 77       	andi	r24, 0x7E	; 126
    6478:	80 83       	st	Z, r24
    647a:	c1 14       	cp	r12, r1
    647c:	d1 04       	cpc	r13, r1
    647e:	49 f0       	breq	.+18     	; 0x6492 <Endpoint_Null_Stream+0x6a>
    6480:	f6 01       	movw	r30, r12
    6482:	80 81       	ld	r24, Z
    6484:	91 81       	ldd	r25, Z+1	; 0x01
    6486:	e8 0e       	add	r14, r24
    6488:	f9 1e       	adc	r15, r25
    648a:	f1 82       	std	Z+1, r15	; 0x01
    648c:	e0 82       	st	Z, r14
    648e:	85 e0       	ldi	r24, 0x05	; 5
    6490:	0f c0       	rjmp	.+30     	; 0x64b0 <Endpoint_Null_Stream+0x88>
    6492:	a5 d3       	rcall	.+1866   	; 0x6bde <Endpoint_WaitUntilReady>
    6494:	88 23       	and	r24, r24
    6496:	39 f0       	breq	.+14     	; 0x64a6 <Endpoint_Null_Stream+0x7e>
    6498:	0b c0       	rjmp	.+22     	; 0x64b0 <Endpoint_Null_Stream+0x88>
    649a:	f5 01       	movw	r30, r10
    649c:	10 82       	st	Z, r1
    649e:	21 97       	sbiw	r28, 0x01	; 1
    64a0:	ff ef       	ldi	r31, 0xFF	; 255
    64a2:	ef 1a       	sub	r14, r31
    64a4:	ff 0a       	sbc	r15, r31
    64a6:	20 97       	sbiw	r28, 0x00	; 0
    64a8:	09 f7       	brne	.-62     	; 0x646c <Endpoint_Null_Stream+0x44>
    64aa:	80 e0       	ldi	r24, 0x00	; 0
    64ac:	01 c0       	rjmp	.+2      	; 0x64b0 <Endpoint_Null_Stream+0x88>
    64ae:	80 e0       	ldi	r24, 0x00	; 0
    64b0:	df 91       	pop	r29
    64b2:	cf 91       	pop	r28
    64b4:	1f 91       	pop	r17
    64b6:	0f 91       	pop	r16
    64b8:	ff 90       	pop	r15
    64ba:	ef 90       	pop	r14
    64bc:	df 90       	pop	r13
    64be:	cf 90       	pop	r12
    64c0:	bf 90       	pop	r11
    64c2:	af 90       	pop	r10
    64c4:	08 95       	ret

000064c6 <Endpoint_Write_Stream_LE>:
    64c6:	8f 92       	push	r8
    64c8:	9f 92       	push	r9
    64ca:	af 92       	push	r10
    64cc:	bf 92       	push	r11
    64ce:	cf 92       	push	r12
    64d0:	df 92       	push	r13
    64d2:	ef 92       	push	r14
    64d4:	ff 92       	push	r15
    64d6:	0f 93       	push	r16
    64d8:	1f 93       	push	r17
    64da:	cf 93       	push	r28
    64dc:	df 93       	push	r29
    64de:	8c 01       	movw	r16, r24
    64e0:	eb 01       	movw	r28, r22
    64e2:	5a 01       	movw	r10, r20
    64e4:	7c d3       	rcall	.+1784   	; 0x6bde <Endpoint_WaitUntilReady>
    64e6:	81 11       	cpse	r24, r1
    64e8:	3e c0       	rjmp	.+124    	; 0x6566 <Endpoint_Write_Stream_LE+0xa0>
    64ea:	a1 14       	cp	r10, r1
    64ec:	b1 04       	cpc	r11, r1
    64ee:	39 f0       	breq	.+14     	; 0x64fe <Endpoint_Write_Stream_LE+0x38>
    64f0:	f5 01       	movw	r30, r10
    64f2:	80 81       	ld	r24, Z
    64f4:	91 81       	ldd	r25, Z+1	; 0x01
    64f6:	c8 1b       	sub	r28, r24
    64f8:	d9 0b       	sbc	r29, r25
    64fa:	08 0f       	add	r16, r24
    64fc:	19 1f       	adc	r17, r25
    64fe:	20 97       	sbiw	r28, 0x00	; 0
    6500:	89 f1       	breq	.+98     	; 0x6564 <Endpoint_Write_Stream_LE+0x9e>
    6502:	e1 2c       	mov	r14, r1
    6504:	f1 2c       	mov	r15, r1
    6506:	0f 2e       	mov	r0, r31
    6508:	f8 ee       	ldi	r31, 0xE8	; 232
    650a:	8f 2e       	mov	r8, r31
    650c:	91 2c       	mov	r9, r1
    650e:	f0 2d       	mov	r31, r0
    6510:	0f 2e       	mov	r0, r31
    6512:	f1 ef       	ldi	r31, 0xF1	; 241
    6514:	cf 2e       	mov	r12, r31
    6516:	d1 2c       	mov	r13, r1
    6518:	f0 2d       	mov	r31, r0
    651a:	f4 01       	movw	r30, r8
    651c:	80 81       	ld	r24, Z
    651e:	85 fd       	sbrc	r24, 5
    6520:	14 c0       	rjmp	.+40     	; 0x654a <Endpoint_Write_Stream_LE+0x84>
    6522:	80 81       	ld	r24, Z
    6524:	8e 77       	andi	r24, 0x7E	; 126
    6526:	80 83       	st	Z, r24
    6528:	45 d6       	rcall	.+3210   	; 0x71b4 <USB_USBTask>
    652a:	a1 14       	cp	r10, r1
    652c:	b1 04       	cpc	r11, r1
    652e:	49 f0       	breq	.+18     	; 0x6542 <Endpoint_Write_Stream_LE+0x7c>
    6530:	f5 01       	movw	r30, r10
    6532:	80 81       	ld	r24, Z
    6534:	91 81       	ldd	r25, Z+1	; 0x01
    6536:	e8 0e       	add	r14, r24
    6538:	f9 1e       	adc	r15, r25
    653a:	f1 82       	std	Z+1, r15	; 0x01
    653c:	e0 82       	st	Z, r14
    653e:	85 e0       	ldi	r24, 0x05	; 5
    6540:	12 c0       	rjmp	.+36     	; 0x6566 <Endpoint_Write_Stream_LE+0xa0>
    6542:	4d d3       	rcall	.+1690   	; 0x6bde <Endpoint_WaitUntilReady>
    6544:	88 23       	and	r24, r24
    6546:	51 f0       	breq	.+20     	; 0x655c <Endpoint_Write_Stream_LE+0x96>
    6548:	0e c0       	rjmp	.+28     	; 0x6566 <Endpoint_Write_Stream_LE+0xa0>
    654a:	f8 01       	movw	r30, r16
    654c:	81 91       	ld	r24, Z+
    654e:	8f 01       	movw	r16, r30
    6550:	f6 01       	movw	r30, r12
    6552:	80 83       	st	Z, r24
    6554:	21 97       	sbiw	r28, 0x01	; 1
    6556:	ff ef       	ldi	r31, 0xFF	; 255
    6558:	ef 1a       	sub	r14, r31
    655a:	ff 0a       	sbc	r15, r31
    655c:	20 97       	sbiw	r28, 0x00	; 0
    655e:	e9 f6       	brne	.-70     	; 0x651a <Endpoint_Write_Stream_LE+0x54>
    6560:	80 e0       	ldi	r24, 0x00	; 0
    6562:	01 c0       	rjmp	.+2      	; 0x6566 <Endpoint_Write_Stream_LE+0xa0>
    6564:	80 e0       	ldi	r24, 0x00	; 0
    6566:	df 91       	pop	r29
    6568:	cf 91       	pop	r28
    656a:	1f 91       	pop	r17
    656c:	0f 91       	pop	r16
    656e:	ff 90       	pop	r15
    6570:	ef 90       	pop	r14
    6572:	df 90       	pop	r13
    6574:	cf 90       	pop	r12
    6576:	bf 90       	pop	r11
    6578:	af 90       	pop	r10
    657a:	9f 90       	pop	r9
    657c:	8f 90       	pop	r8
    657e:	08 95       	ret

00006580 <Endpoint_Write_Stream_BE>:
    6580:	8f 92       	push	r8
    6582:	9f 92       	push	r9
    6584:	af 92       	push	r10
    6586:	bf 92       	push	r11
    6588:	cf 92       	push	r12
    658a:	df 92       	push	r13
    658c:	ef 92       	push	r14
    658e:	ff 92       	push	r15
    6590:	0f 93       	push	r16
    6592:	1f 93       	push	r17
    6594:	cf 93       	push	r28
    6596:	df 93       	push	r29
    6598:	8c 01       	movw	r16, r24
    659a:	eb 01       	movw	r28, r22
    659c:	5a 01       	movw	r10, r20
    659e:	1f d3       	rcall	.+1598   	; 0x6bde <Endpoint_WaitUntilReady>
    65a0:	81 11       	cpse	r24, r1
    65a2:	43 c0       	rjmp	.+134    	; 0x662a <Endpoint_Write_Stream_BE+0xaa>
    65a4:	ce 01       	movw	r24, r28
    65a6:	01 97       	sbiw	r24, 0x01	; 1
    65a8:	08 0f       	add	r16, r24
    65aa:	19 1f       	adc	r17, r25
    65ac:	a1 14       	cp	r10, r1
    65ae:	b1 04       	cpc	r11, r1
    65b0:	39 f0       	breq	.+14     	; 0x65c0 <Endpoint_Write_Stream_BE+0x40>
    65b2:	f5 01       	movw	r30, r10
    65b4:	80 81       	ld	r24, Z
    65b6:	91 81       	ldd	r25, Z+1	; 0x01
    65b8:	c8 1b       	sub	r28, r24
    65ba:	d9 0b       	sbc	r29, r25
    65bc:	08 1b       	sub	r16, r24
    65be:	19 0b       	sbc	r17, r25
    65c0:	20 97       	sbiw	r28, 0x00	; 0
    65c2:	91 f1       	breq	.+100    	; 0x6628 <Endpoint_Write_Stream_BE+0xa8>
    65c4:	e1 2c       	mov	r14, r1
    65c6:	f1 2c       	mov	r15, r1
    65c8:	0f 2e       	mov	r0, r31
    65ca:	f8 ee       	ldi	r31, 0xE8	; 232
    65cc:	8f 2e       	mov	r8, r31
    65ce:	91 2c       	mov	r9, r1
    65d0:	f0 2d       	mov	r31, r0
    65d2:	0f 2e       	mov	r0, r31
    65d4:	f1 ef       	ldi	r31, 0xF1	; 241
    65d6:	cf 2e       	mov	r12, r31
    65d8:	d1 2c       	mov	r13, r1
    65da:	f0 2d       	mov	r31, r0
    65dc:	f4 01       	movw	r30, r8
    65de:	80 81       	ld	r24, Z
    65e0:	85 fd       	sbrc	r24, 5
    65e2:	14 c0       	rjmp	.+40     	; 0x660c <Endpoint_Write_Stream_BE+0x8c>
    65e4:	80 81       	ld	r24, Z
    65e6:	8e 77       	andi	r24, 0x7E	; 126
    65e8:	80 83       	st	Z, r24
    65ea:	e4 d5       	rcall	.+3016   	; 0x71b4 <USB_USBTask>
    65ec:	a1 14       	cp	r10, r1
    65ee:	b1 04       	cpc	r11, r1
    65f0:	49 f0       	breq	.+18     	; 0x6604 <Endpoint_Write_Stream_BE+0x84>
    65f2:	f5 01       	movw	r30, r10
    65f4:	80 81       	ld	r24, Z
    65f6:	91 81       	ldd	r25, Z+1	; 0x01
    65f8:	e8 0e       	add	r14, r24
    65fa:	f9 1e       	adc	r15, r25
    65fc:	f1 82       	std	Z+1, r15	; 0x01
    65fe:	e0 82       	st	Z, r14
    6600:	85 e0       	ldi	r24, 0x05	; 5
    6602:	13 c0       	rjmp	.+38     	; 0x662a <Endpoint_Write_Stream_BE+0xaa>
    6604:	ec d2       	rcall	.+1496   	; 0x6bde <Endpoint_WaitUntilReady>
    6606:	88 23       	and	r24, r24
    6608:	59 f0       	breq	.+22     	; 0x6620 <Endpoint_Write_Stream_BE+0xa0>
    660a:	0f c0       	rjmp	.+30     	; 0x662a <Endpoint_Write_Stream_BE+0xaa>
    660c:	f8 01       	movw	r30, r16
    660e:	80 81       	ld	r24, Z
    6610:	f6 01       	movw	r30, r12
    6612:	80 83       	st	Z, r24
    6614:	01 50       	subi	r16, 0x01	; 1
    6616:	11 09       	sbc	r17, r1
    6618:	21 97       	sbiw	r28, 0x01	; 1
    661a:	ff ef       	ldi	r31, 0xFF	; 255
    661c:	ef 1a       	sub	r14, r31
    661e:	ff 0a       	sbc	r15, r31
    6620:	20 97       	sbiw	r28, 0x00	; 0
    6622:	e1 f6       	brne	.-72     	; 0x65dc <Endpoint_Write_Stream_BE+0x5c>
    6624:	80 e0       	ldi	r24, 0x00	; 0
    6626:	01 c0       	rjmp	.+2      	; 0x662a <Endpoint_Write_Stream_BE+0xaa>
    6628:	80 e0       	ldi	r24, 0x00	; 0
    662a:	df 91       	pop	r29
    662c:	cf 91       	pop	r28
    662e:	1f 91       	pop	r17
    6630:	0f 91       	pop	r16
    6632:	ff 90       	pop	r15
    6634:	ef 90       	pop	r14
    6636:	df 90       	pop	r13
    6638:	cf 90       	pop	r12
    663a:	bf 90       	pop	r11
    663c:	af 90       	pop	r10
    663e:	9f 90       	pop	r9
    6640:	8f 90       	pop	r8
    6642:	08 95       	ret

00006644 <Endpoint_Read_Stream_LE>:
    6644:	8f 92       	push	r8
    6646:	9f 92       	push	r9
    6648:	af 92       	push	r10
    664a:	bf 92       	push	r11
    664c:	cf 92       	push	r12
    664e:	df 92       	push	r13
    6650:	ef 92       	push	r14
    6652:	ff 92       	push	r15
    6654:	0f 93       	push	r16
    6656:	1f 93       	push	r17
    6658:	cf 93       	push	r28
    665a:	df 93       	push	r29
    665c:	8c 01       	movw	r16, r24
    665e:	eb 01       	movw	r28, r22
    6660:	5a 01       	movw	r10, r20
    6662:	bd d2       	rcall	.+1402   	; 0x6bde <Endpoint_WaitUntilReady>
    6664:	81 11       	cpse	r24, r1
    6666:	3e c0       	rjmp	.+124    	; 0x66e4 <Endpoint_Read_Stream_LE+0xa0>
    6668:	a1 14       	cp	r10, r1
    666a:	b1 04       	cpc	r11, r1
    666c:	39 f0       	breq	.+14     	; 0x667c <Endpoint_Read_Stream_LE+0x38>
    666e:	f5 01       	movw	r30, r10
    6670:	80 81       	ld	r24, Z
    6672:	91 81       	ldd	r25, Z+1	; 0x01
    6674:	c8 1b       	sub	r28, r24
    6676:	d9 0b       	sbc	r29, r25
    6678:	08 0f       	add	r16, r24
    667a:	19 1f       	adc	r17, r25
    667c:	20 97       	sbiw	r28, 0x00	; 0
    667e:	89 f1       	breq	.+98     	; 0x66e2 <Endpoint_Read_Stream_LE+0x9e>
    6680:	e1 2c       	mov	r14, r1
    6682:	f1 2c       	mov	r15, r1
    6684:	0f 2e       	mov	r0, r31
    6686:	f8 ee       	ldi	r31, 0xE8	; 232
    6688:	8f 2e       	mov	r8, r31
    668a:	91 2c       	mov	r9, r1
    668c:	f0 2d       	mov	r31, r0
    668e:	0f 2e       	mov	r0, r31
    6690:	f1 ef       	ldi	r31, 0xF1	; 241
    6692:	cf 2e       	mov	r12, r31
    6694:	d1 2c       	mov	r13, r1
    6696:	f0 2d       	mov	r31, r0
    6698:	f4 01       	movw	r30, r8
    669a:	80 81       	ld	r24, Z
    669c:	85 fd       	sbrc	r24, 5
    669e:	14 c0       	rjmp	.+40     	; 0x66c8 <Endpoint_Read_Stream_LE+0x84>
    66a0:	80 81       	ld	r24, Z
    66a2:	8b 77       	andi	r24, 0x7B	; 123
    66a4:	80 83       	st	Z, r24
    66a6:	86 d5       	rcall	.+2828   	; 0x71b4 <USB_USBTask>
    66a8:	a1 14       	cp	r10, r1
    66aa:	b1 04       	cpc	r11, r1
    66ac:	49 f0       	breq	.+18     	; 0x66c0 <Endpoint_Read_Stream_LE+0x7c>
    66ae:	f5 01       	movw	r30, r10
    66b0:	80 81       	ld	r24, Z
    66b2:	91 81       	ldd	r25, Z+1	; 0x01
    66b4:	e8 0e       	add	r14, r24
    66b6:	f9 1e       	adc	r15, r25
    66b8:	f1 82       	std	Z+1, r15	; 0x01
    66ba:	e0 82       	st	Z, r14
    66bc:	85 e0       	ldi	r24, 0x05	; 5
    66be:	12 c0       	rjmp	.+36     	; 0x66e4 <Endpoint_Read_Stream_LE+0xa0>
    66c0:	8e d2       	rcall	.+1308   	; 0x6bde <Endpoint_WaitUntilReady>
    66c2:	88 23       	and	r24, r24
    66c4:	51 f0       	breq	.+20     	; 0x66da <Endpoint_Read_Stream_LE+0x96>
    66c6:	0e c0       	rjmp	.+28     	; 0x66e4 <Endpoint_Read_Stream_LE+0xa0>
    66c8:	f6 01       	movw	r30, r12
    66ca:	80 81       	ld	r24, Z
    66cc:	f8 01       	movw	r30, r16
    66ce:	81 93       	st	Z+, r24
    66d0:	8f 01       	movw	r16, r30
    66d2:	21 97       	sbiw	r28, 0x01	; 1
    66d4:	ff ef       	ldi	r31, 0xFF	; 255
    66d6:	ef 1a       	sub	r14, r31
    66d8:	ff 0a       	sbc	r15, r31
    66da:	20 97       	sbiw	r28, 0x00	; 0
    66dc:	e9 f6       	brne	.-70     	; 0x6698 <Endpoint_Read_Stream_LE+0x54>
    66de:	80 e0       	ldi	r24, 0x00	; 0
    66e0:	01 c0       	rjmp	.+2      	; 0x66e4 <Endpoint_Read_Stream_LE+0xa0>
    66e2:	80 e0       	ldi	r24, 0x00	; 0
    66e4:	df 91       	pop	r29
    66e6:	cf 91       	pop	r28
    66e8:	1f 91       	pop	r17
    66ea:	0f 91       	pop	r16
    66ec:	ff 90       	pop	r15
    66ee:	ef 90       	pop	r14
    66f0:	df 90       	pop	r13
    66f2:	cf 90       	pop	r12
    66f4:	bf 90       	pop	r11
    66f6:	af 90       	pop	r10
    66f8:	9f 90       	pop	r9
    66fa:	8f 90       	pop	r8
    66fc:	08 95       	ret

000066fe <Endpoint_Write_Control_Stream_LE>:
    66fe:	cf 92       	push	r12
    6700:	df 92       	push	r13
    6702:	ff 92       	push	r15
    6704:	0f 93       	push	r16
    6706:	1f 93       	push	r17
    6708:	cf 93       	push	r28
    670a:	df 93       	push	r29
    670c:	20 91 74 0a 	lds	r18, 0x0A74
    6710:	30 91 75 0a 	lds	r19, 0x0A75
    6714:	26 17       	cp	r18, r22
    6716:	37 07       	cpc	r19, r23
    6718:	58 f0       	brcs	.+22     	; 0x6730 <Endpoint_Write_Control_Stream_LE+0x32>
    671a:	61 15       	cp	r22, r1
    671c:	71 05       	cpc	r23, r1
    671e:	39 f4       	brne	.+14     	; 0x672e <Endpoint_Write_Control_Stream_LE+0x30>
    6720:	e8 ee       	ldi	r30, 0xE8	; 232
    6722:	f0 e0       	ldi	r31, 0x00	; 0
    6724:	20 81       	ld	r18, Z
    6726:	2e 77       	andi	r18, 0x7E	; 126
    6728:	20 83       	st	Z, r18
    672a:	9b 01       	movw	r18, r22
    672c:	01 c0       	rjmp	.+2      	; 0x6730 <Endpoint_Write_Control_Stream_LE+0x32>
    672e:	9b 01       	movw	r18, r22
    6730:	a8 2f       	mov	r26, r24
    6732:	b9 2f       	mov	r27, r25
    6734:	10 e0       	ldi	r17, 0x00	; 0
    6736:	e8 ee       	ldi	r30, 0xE8	; 232
    6738:	f0 e0       	ldi	r31, 0x00	; 0
    673a:	63 ef       	ldi	r22, 0xF3	; 243
    673c:	70 e0       	ldi	r23, 0x00	; 0
    673e:	42 ef       	ldi	r20, 0xF2	; 242
    6740:	50 e0       	ldi	r21, 0x00	; 0
    6742:	0f 2e       	mov	r0, r31
    6744:	f1 ef       	ldi	r31, 0xF1	; 241
    6746:	cf 2e       	mov	r12, r31
    6748:	d1 2c       	mov	r13, r1
    674a:	f0 2d       	mov	r31, r0
    674c:	01 e0       	ldi	r16, 0x01	; 1
    674e:	f1 2c       	mov	r15, r1
    6750:	30 c0       	rjmp	.+96     	; 0x67b2 <Endpoint_Write_Control_Stream_LE+0xb4>
    6752:	80 91 6d 0a 	lds	r24, 0x0A6D
    6756:	88 23       	and	r24, r24
    6758:	09 f4       	brne	.+2      	; 0x675c <Endpoint_Write_Control_Stream_LE+0x5e>
    675a:	42 c0       	rjmp	.+132    	; 0x67e0 <Endpoint_Write_Control_Stream_LE+0xe2>
    675c:	85 30       	cpi	r24, 0x05	; 5
    675e:	09 f4       	brne	.+2      	; 0x6762 <Endpoint_Write_Control_Stream_LE+0x64>
    6760:	41 c0       	rjmp	.+130    	; 0x67e4 <Endpoint_Write_Control_Stream_LE+0xe6>
    6762:	80 81       	ld	r24, Z
    6764:	83 fd       	sbrc	r24, 3
    6766:	40 c0       	rjmp	.+128    	; 0x67e8 <Endpoint_Write_Control_Stream_LE+0xea>
    6768:	80 81       	ld	r24, Z
    676a:	82 fd       	sbrc	r24, 2
    676c:	32 c0       	rjmp	.+100    	; 0x67d2 <Endpoint_Write_Control_Stream_LE+0xd4>
    676e:	80 81       	ld	r24, Z
    6770:	80 ff       	sbrs	r24, 0
    6772:	1f c0       	rjmp	.+62     	; 0x67b2 <Endpoint_Write_Control_Stream_LE+0xb4>
    6774:	eb 01       	movw	r28, r22
    6776:	18 81       	ld	r17, Y
    6778:	ea 01       	movw	r28, r20
    677a:	88 81       	ld	r24, Y
    677c:	90 e0       	ldi	r25, 0x00	; 0
    677e:	91 2b       	or	r25, r17
    6780:	21 15       	cp	r18, r1
    6782:	31 05       	cpc	r19, r1
    6784:	79 f0       	breq	.+30     	; 0x67a4 <Endpoint_Write_Control_Stream_LE+0xa6>
    6786:	88 30       	cpi	r24, 0x08	; 8
    6788:	91 05       	cpc	r25, r1
    678a:	60 f4       	brcc	.+24     	; 0x67a4 <Endpoint_Write_Control_Stream_LE+0xa6>
    678c:	1d 91       	ld	r17, X+
    678e:	e6 01       	movw	r28, r12
    6790:	18 83       	st	Y, r17
    6792:	21 50       	subi	r18, 0x01	; 1
    6794:	31 09       	sbc	r19, r1
    6796:	01 96       	adiw	r24, 0x01	; 1
    6798:	21 15       	cp	r18, r1
    679a:	31 05       	cpc	r19, r1
    679c:	19 f0       	breq	.+6      	; 0x67a4 <Endpoint_Write_Control_Stream_LE+0xa6>
    679e:	88 30       	cpi	r24, 0x08	; 8
    67a0:	91 05       	cpc	r25, r1
    67a2:	a1 f7       	brne	.-24     	; 0x678c <Endpoint_Write_Control_Stream_LE+0x8e>
    67a4:	10 2f       	mov	r17, r16
    67a6:	08 97       	sbiw	r24, 0x08	; 8
    67a8:	09 f0       	breq	.+2      	; 0x67ac <Endpoint_Write_Control_Stream_LE+0xae>
    67aa:	1f 2d       	mov	r17, r15
    67ac:	80 81       	ld	r24, Z
    67ae:	8e 77       	andi	r24, 0x7E	; 126
    67b0:	80 83       	st	Z, r24
    67b2:	21 15       	cp	r18, r1
    67b4:	31 05       	cpc	r19, r1
    67b6:	69 f6       	brne	.-102    	; 0x6752 <Endpoint_Write_Control_Stream_LE+0x54>
    67b8:	11 11       	cpse	r17, r1
    67ba:	cb cf       	rjmp	.-106    	; 0x6752 <Endpoint_Write_Control_Stream_LE+0x54>
    67bc:	0a c0       	rjmp	.+20     	; 0x67d2 <Endpoint_Write_Control_Stream_LE+0xd4>
    67be:	80 91 6d 0a 	lds	r24, 0x0A6D
    67c2:	88 23       	and	r24, r24
    67c4:	99 f0       	breq	.+38     	; 0x67ec <Endpoint_Write_Control_Stream_LE+0xee>
    67c6:	85 30       	cpi	r24, 0x05	; 5
    67c8:	99 f0       	breq	.+38     	; 0x67f0 <Endpoint_Write_Control_Stream_LE+0xf2>
    67ca:	80 81       	ld	r24, Z
    67cc:	83 ff       	sbrs	r24, 3
    67ce:	03 c0       	rjmp	.+6      	; 0x67d6 <Endpoint_Write_Control_Stream_LE+0xd8>
    67d0:	11 c0       	rjmp	.+34     	; 0x67f4 <Endpoint_Write_Control_Stream_LE+0xf6>
    67d2:	e8 ee       	ldi	r30, 0xE8	; 232
    67d4:	f0 e0       	ldi	r31, 0x00	; 0
    67d6:	80 81       	ld	r24, Z
    67d8:	82 ff       	sbrs	r24, 2
    67da:	f1 cf       	rjmp	.-30     	; 0x67be <Endpoint_Write_Control_Stream_LE+0xc0>
    67dc:	80 e0       	ldi	r24, 0x00	; 0
    67de:	0b c0       	rjmp	.+22     	; 0x67f6 <Endpoint_Write_Control_Stream_LE+0xf8>
    67e0:	82 e0       	ldi	r24, 0x02	; 2
    67e2:	09 c0       	rjmp	.+18     	; 0x67f6 <Endpoint_Write_Control_Stream_LE+0xf8>
    67e4:	83 e0       	ldi	r24, 0x03	; 3
    67e6:	07 c0       	rjmp	.+14     	; 0x67f6 <Endpoint_Write_Control_Stream_LE+0xf8>
    67e8:	81 e0       	ldi	r24, 0x01	; 1
    67ea:	05 c0       	rjmp	.+10     	; 0x67f6 <Endpoint_Write_Control_Stream_LE+0xf8>
    67ec:	82 e0       	ldi	r24, 0x02	; 2
    67ee:	03 c0       	rjmp	.+6      	; 0x67f6 <Endpoint_Write_Control_Stream_LE+0xf8>
    67f0:	83 e0       	ldi	r24, 0x03	; 3
    67f2:	01 c0       	rjmp	.+2      	; 0x67f6 <Endpoint_Write_Control_Stream_LE+0xf8>
    67f4:	81 e0       	ldi	r24, 0x01	; 1
    67f6:	df 91       	pop	r29
    67f8:	cf 91       	pop	r28
    67fa:	1f 91       	pop	r17
    67fc:	0f 91       	pop	r16
    67fe:	ff 90       	pop	r15
    6800:	df 90       	pop	r13
    6802:	cf 90       	pop	r12
    6804:	08 95       	ret

00006806 <Endpoint_Read_Control_Stream_LE>:
    6806:	ef 92       	push	r14
    6808:	ff 92       	push	r15
    680a:	1f 93       	push	r17
    680c:	cf 93       	push	r28
    680e:	df 93       	push	r29
    6810:	61 15       	cp	r22, r1
    6812:	71 05       	cpc	r23, r1
    6814:	29 f4       	brne	.+10     	; 0x6820 <Endpoint_Read_Control_Stream_LE+0x1a>
    6816:	e8 ee       	ldi	r30, 0xE8	; 232
    6818:	f0 e0       	ldi	r31, 0x00	; 0
    681a:	20 81       	ld	r18, Z
    681c:	2b 77       	andi	r18, 0x7B	; 123
    681e:	20 83       	st	Z, r18
    6820:	a8 2f       	mov	r26, r24
    6822:	b9 2f       	mov	r27, r25
    6824:	e8 ee       	ldi	r30, 0xE8	; 232
    6826:	f0 e0       	ldi	r31, 0x00	; 0
    6828:	23 ef       	ldi	r18, 0xF3	; 243
    682a:	30 e0       	ldi	r19, 0x00	; 0
    682c:	0f 2e       	mov	r0, r31
    682e:	f2 ef       	ldi	r31, 0xF2	; 242
    6830:	ef 2e       	mov	r14, r31
    6832:	f1 2c       	mov	r15, r1
    6834:	f0 2d       	mov	r31, r0
    6836:	41 ef       	ldi	r20, 0xF1	; 241
    6838:	50 e0       	ldi	r21, 0x00	; 0
    683a:	1e c0       	rjmp	.+60     	; 0x6878 <Endpoint_Read_Control_Stream_LE+0x72>
    683c:	80 91 6d 0a 	lds	r24, 0x0A6D
    6840:	88 23       	and	r24, r24
    6842:	c1 f1       	breq	.+112    	; 0x68b4 <Endpoint_Read_Control_Stream_LE+0xae>
    6844:	85 30       	cpi	r24, 0x05	; 5
    6846:	c1 f1       	breq	.+112    	; 0x68b8 <Endpoint_Read_Control_Stream_LE+0xb2>
    6848:	80 81       	ld	r24, Z
    684a:	83 fd       	sbrc	r24, 3
    684c:	37 c0       	rjmp	.+110    	; 0x68bc <Endpoint_Read_Control_Stream_LE+0xb6>
    684e:	80 81       	ld	r24, Z
    6850:	82 ff       	sbrs	r24, 2
    6852:	f4 cf       	rjmp	.-24     	; 0x683c <Endpoint_Read_Control_Stream_LE+0x36>
    6854:	3f c0       	rjmp	.+126    	; 0x68d4 <Endpoint_Read_Control_Stream_LE+0xce>
    6856:	ea 01       	movw	r28, r20
    6858:	88 81       	ld	r24, Y
    685a:	8d 93       	st	X+, r24
    685c:	61 50       	subi	r22, 0x01	; 1
    685e:	71 09       	sbc	r23, r1
    6860:	41 f0       	breq	.+16     	; 0x6872 <Endpoint_Read_Control_Stream_LE+0x6c>
    6862:	e9 01       	movw	r28, r18
    6864:	18 81       	ld	r17, Y
    6866:	e7 01       	movw	r28, r14
    6868:	88 81       	ld	r24, Y
    686a:	90 e0       	ldi	r25, 0x00	; 0
    686c:	91 2b       	or	r25, r17
    686e:	89 2b       	or	r24, r25
    6870:	91 f7       	brne	.-28     	; 0x6856 <Endpoint_Read_Control_Stream_LE+0x50>
    6872:	80 81       	ld	r24, Z
    6874:	8b 77       	andi	r24, 0x7B	; 123
    6876:	80 83       	st	Z, r24
    6878:	61 15       	cp	r22, r1
    687a:	71 05       	cpc	r23, r1
    687c:	a1 f0       	breq	.+40     	; 0x68a6 <Endpoint_Read_Control_Stream_LE+0xa0>
    687e:	80 91 6d 0a 	lds	r24, 0x0A6D
    6882:	88 23       	and	r24, r24
    6884:	e9 f0       	breq	.+58     	; 0x68c0 <Endpoint_Read_Control_Stream_LE+0xba>
    6886:	85 30       	cpi	r24, 0x05	; 5
    6888:	e9 f0       	breq	.+58     	; 0x68c4 <Endpoint_Read_Control_Stream_LE+0xbe>
    688a:	80 81       	ld	r24, Z
    688c:	83 fd       	sbrc	r24, 3
    688e:	1c c0       	rjmp	.+56     	; 0x68c8 <Endpoint_Read_Control_Stream_LE+0xc2>
    6890:	80 81       	ld	r24, Z
    6892:	82 fd       	sbrc	r24, 2
    6894:	1f c0       	rjmp	.+62     	; 0x68d4 <Endpoint_Read_Control_Stream_LE+0xce>
    6896:	d2 cf       	rjmp	.-92     	; 0x683c <Endpoint_Read_Control_Stream_LE+0x36>
    6898:	80 91 6d 0a 	lds	r24, 0x0A6D
    689c:	88 23       	and	r24, r24
    689e:	b1 f0       	breq	.+44     	; 0x68cc <Endpoint_Read_Control_Stream_LE+0xc6>
    68a0:	85 30       	cpi	r24, 0x05	; 5
    68a2:	19 f4       	brne	.+6      	; 0x68aa <Endpoint_Read_Control_Stream_LE+0xa4>
    68a4:	15 c0       	rjmp	.+42     	; 0x68d0 <Endpoint_Read_Control_Stream_LE+0xca>
    68a6:	e8 ee       	ldi	r30, 0xE8	; 232
    68a8:	f0 e0       	ldi	r31, 0x00	; 0
    68aa:	80 81       	ld	r24, Z
    68ac:	80 ff       	sbrs	r24, 0
    68ae:	f4 cf       	rjmp	.-24     	; 0x6898 <Endpoint_Read_Control_Stream_LE+0x92>
    68b0:	80 e0       	ldi	r24, 0x00	; 0
    68b2:	1a c0       	rjmp	.+52     	; 0x68e8 <Endpoint_Read_Control_Stream_LE+0xe2>
    68b4:	82 e0       	ldi	r24, 0x02	; 2
    68b6:	18 c0       	rjmp	.+48     	; 0x68e8 <Endpoint_Read_Control_Stream_LE+0xe2>
    68b8:	83 e0       	ldi	r24, 0x03	; 3
    68ba:	16 c0       	rjmp	.+44     	; 0x68e8 <Endpoint_Read_Control_Stream_LE+0xe2>
    68bc:	81 e0       	ldi	r24, 0x01	; 1
    68be:	14 c0       	rjmp	.+40     	; 0x68e8 <Endpoint_Read_Control_Stream_LE+0xe2>
    68c0:	82 e0       	ldi	r24, 0x02	; 2
    68c2:	12 c0       	rjmp	.+36     	; 0x68e8 <Endpoint_Read_Control_Stream_LE+0xe2>
    68c4:	83 e0       	ldi	r24, 0x03	; 3
    68c6:	10 c0       	rjmp	.+32     	; 0x68e8 <Endpoint_Read_Control_Stream_LE+0xe2>
    68c8:	81 e0       	ldi	r24, 0x01	; 1
    68ca:	0e c0       	rjmp	.+28     	; 0x68e8 <Endpoint_Read_Control_Stream_LE+0xe2>
    68cc:	82 e0       	ldi	r24, 0x02	; 2
    68ce:	0c c0       	rjmp	.+24     	; 0x68e8 <Endpoint_Read_Control_Stream_LE+0xe2>
    68d0:	83 e0       	ldi	r24, 0x03	; 3
    68d2:	0a c0       	rjmp	.+20     	; 0x68e8 <Endpoint_Read_Control_Stream_LE+0xe2>
    68d4:	e9 01       	movw	r28, r18
    68d6:	18 81       	ld	r17, Y
    68d8:	e7 01       	movw	r28, r14
    68da:	88 81       	ld	r24, Y
    68dc:	90 e0       	ldi	r25, 0x00	; 0
    68de:	91 2b       	or	r25, r17
    68e0:	89 2b       	or	r24, r25
    68e2:	09 f0       	breq	.+2      	; 0x68e6 <Endpoint_Read_Control_Stream_LE+0xe0>
    68e4:	b8 cf       	rjmp	.-144    	; 0x6856 <Endpoint_Read_Control_Stream_LE+0x50>
    68e6:	c5 cf       	rjmp	.-118    	; 0x6872 <Endpoint_Read_Control_Stream_LE+0x6c>
    68e8:	df 91       	pop	r29
    68ea:	cf 91       	pop	r28
    68ec:	1f 91       	pop	r17
    68ee:	ff 90       	pop	r15
    68f0:	ef 90       	pop	r14
    68f2:	08 95       	ret

000068f4 <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    68f4:	cf 92       	push	r12
    68f6:	df 92       	push	r13
    68f8:	ff 92       	push	r15
    68fa:	0f 93       	push	r16
    68fc:	1f 93       	push	r17
    68fe:	cf 93       	push	r28
    6900:	df 93       	push	r29
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    6902:	20 91 74 0a 	lds	r18, 0x0A74
    6906:	30 91 75 0a 	lds	r19, 0x0A75
    690a:	26 17       	cp	r18, r22
    690c:	37 07       	cpc	r19, r23
    690e:	58 f0       	brcs	.+22     	; 0x6926 <Endpoint_Write_Control_PStream_LE+0x32>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    6910:	61 15       	cp	r22, r1
    6912:	71 05       	cpc	r23, r1
    6914:	39 f4       	brne	.+14     	; 0x6924 <Endpoint_Write_Control_PStream_LE+0x30>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6916:	e8 ee       	ldi	r30, 0xE8	; 232
    6918:	f0 e0       	ldi	r31, 0x00	; 0
    691a:	20 81       	ld	r18, Z
    691c:	2e 77       	andi	r18, 0x7E	; 126
    691e:	20 83       	st	Z, r18
    6920:	9b 01       	movw	r18, r22
    6922:	01 c0       	rjmp	.+2      	; 0x6926 <Endpoint_Write_Control_PStream_LE+0x32>
    6924:	9b 01       	movw	r18, r22
    6926:	e8 2f       	mov	r30, r24
    6928:	f9 2f       	mov	r31, r25
    692a:	10 e0       	ldi	r17, 0x00	; 0
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    692c:	a8 ee       	ldi	r26, 0xE8	; 232
    692e:	b0 e0       	ldi	r27, 0x00	; 0
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
    6930:	63 ef       	ldi	r22, 0xF3	; 243
    6932:	70 e0       	ldi	r23, 0x00	; 0
    6934:	42 ef       	ldi	r20, 0xF2	; 242
    6936:	50 e0       	ldi	r21, 0x00	; 0
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    6938:	0f 2e       	mov	r0, r31
    693a:	f1 ef       	ldi	r31, 0xF1	; 241
    693c:	cf 2e       	mov	r12, r31
    693e:	d1 2c       	mov	r13, r1
    6940:	f0 2d       	mov	r31, r0
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    6942:	01 e0       	ldi	r16, 0x01	; 1
    6944:	f1 2c       	mov	r15, r1
    6946:	31 c0       	rjmp	.+98     	; 0x69aa <Endpoint_Write_Control_PStream_LE+0xb6>
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    6948:	80 91 6d 0a 	lds	r24, 0x0A6D

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    694c:	88 23       	and	r24, r24
    694e:	09 f4       	brne	.+2      	; 0x6952 <Endpoint_Write_Control_PStream_LE+0x5e>
    6950:	43 c0       	rjmp	.+134    	; 0x69d8 <Endpoint_Write_Control_PStream_LE+0xe4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    6952:	85 30       	cpi	r24, 0x05	; 5
    6954:	09 f4       	brne	.+2      	; 0x6958 <Endpoint_Write_Control_PStream_LE+0x64>
    6956:	42 c0       	rjmp	.+132    	; 0x69dc <Endpoint_Write_Control_PStream_LE+0xe8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6958:	8c 91       	ld	r24, X
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    695a:	83 fd       	sbrc	r24, 3
    695c:	41 c0       	rjmp	.+130    	; 0x69e0 <Endpoint_Write_Control_PStream_LE+0xec>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    695e:	8c 91       	ld	r24, X
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    6960:	82 fd       	sbrc	r24, 2
    6962:	33 c0       	rjmp	.+102    	; 0x69ca <Endpoint_Write_Control_PStream_LE+0xd6>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6964:	8c 91       	ld	r24, X
		  break;

		if (Endpoint_IsINReady())
    6966:	80 ff       	sbrs	r24, 0
    6968:	20 c0       	rjmp	.+64     	; 0x69aa <Endpoint_Write_Control_PStream_LE+0xb6>
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
    696a:	eb 01       	movw	r28, r22
    696c:	18 81       	ld	r17, Y
    696e:	ea 01       	movw	r28, r20
    6970:	88 81       	ld	r24, Y
    6972:	90 e0       	ldi	r25, 0x00	; 0
    6974:	91 2b       	or	r25, r17
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    6976:	21 15       	cp	r18, r1
    6978:	31 05       	cpc	r19, r1
    697a:	81 f0       	breq	.+32     	; 0x699c <Endpoint_Write_Control_PStream_LE+0xa8>
    697c:	88 30       	cpi	r24, 0x08	; 8
    697e:	91 05       	cpc	r25, r1
    6980:	68 f4       	brcc	.+26     	; 0x699c <Endpoint_Write_Control_PStream_LE+0xa8>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    6982:	14 91       	lpm	r17, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    6984:	e6 01       	movw	r28, r12
    6986:	18 83       	st	Y, r17
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    6988:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    698a:	21 50       	subi	r18, 0x01	; 1
    698c:	31 09       	sbc	r19, r1
				BytesInEndpoint++;
    698e:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    6990:	21 15       	cp	r18, r1
    6992:	31 05       	cpc	r19, r1
    6994:	19 f0       	breq	.+6      	; 0x699c <Endpoint_Write_Control_PStream_LE+0xa8>
    6996:	88 30       	cpi	r24, 0x08	; 8
    6998:	91 05       	cpc	r25, r1
    699a:	99 f7       	brne	.-26     	; 0x6982 <Endpoint_Write_Control_PStream_LE+0x8e>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    699c:	10 2f       	mov	r17, r16
    699e:	08 97       	sbiw	r24, 0x08	; 8
    69a0:	09 f0       	breq	.+2      	; 0x69a4 <Endpoint_Write_Control_PStream_LE+0xb0>
    69a2:	1f 2d       	mov	r17, r15
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    69a4:	8c 91       	ld	r24, X
    69a6:	8e 77       	andi	r24, 0x7E	; 126
    69a8:	8c 93       	st	X, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    69aa:	21 15       	cp	r18, r1
    69ac:	31 05       	cpc	r19, r1
    69ae:	61 f6       	brne	.-104    	; 0x6948 <Endpoint_Write_Control_PStream_LE+0x54>
    69b0:	11 11       	cpse	r17, r1
    69b2:	ca cf       	rjmp	.-108    	; 0x6948 <Endpoint_Write_Control_PStream_LE+0x54>
    69b4:	0a c0       	rjmp	.+20     	; 0x69ca <Endpoint_Write_Control_PStream_LE+0xd6>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    69b6:	80 91 6d 0a 	lds	r24, 0x0A6D

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    69ba:	88 23       	and	r24, r24
    69bc:	99 f0       	breq	.+38     	; 0x69e4 <Endpoint_Write_Control_PStream_LE+0xf0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    69be:	85 30       	cpi	r24, 0x05	; 5
    69c0:	99 f0       	breq	.+38     	; 0x69e8 <Endpoint_Write_Control_PStream_LE+0xf4>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    69c2:	80 81       	ld	r24, Z
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    69c4:	83 ff       	sbrs	r24, 3
    69c6:	03 c0       	rjmp	.+6      	; 0x69ce <Endpoint_Write_Control_PStream_LE+0xda>
    69c8:	11 c0       	rjmp	.+34     	; 0x69ec <Endpoint_Write_Control_PStream_LE+0xf8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    69ca:	e8 ee       	ldi	r30, 0xE8	; 232
    69cc:	f0 e0       	ldi	r31, 0x00	; 0
    69ce:	80 81       	ld	r24, Z
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    69d0:	82 ff       	sbrs	r24, 2
    69d2:	f1 cf       	rjmp	.-30     	; 0x69b6 <Endpoint_Write_Control_PStream_LE+0xc2>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    69d4:	80 e0       	ldi	r24, 0x00	; 0
    69d6:	0b c0       	rjmp	.+22     	; 0x69ee <Endpoint_Write_Control_PStream_LE+0xfa>
	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    69d8:	82 e0       	ldi	r24, 0x02	; 2
    69da:	09 c0       	rjmp	.+18     	; 0x69ee <Endpoint_Write_Control_PStream_LE+0xfa>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    69dc:	83 e0       	ldi	r24, 0x03	; 3
    69de:	07 c0       	rjmp	.+14     	; 0x69ee <Endpoint_Write_Control_PStream_LE+0xfa>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    69e0:	81 e0       	ldi	r24, 0x01	; 1
    69e2:	05 c0       	rjmp	.+10     	; 0x69ee <Endpoint_Write_Control_PStream_LE+0xfa>
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    69e4:	82 e0       	ldi	r24, 0x02	; 2
    69e6:	03 c0       	rjmp	.+6      	; 0x69ee <Endpoint_Write_Control_PStream_LE+0xfa>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    69e8:	83 e0       	ldi	r24, 0x03	; 3
    69ea:	01 c0       	rjmp	.+2      	; 0x69ee <Endpoint_Write_Control_PStream_LE+0xfa>
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    69ec:	81 e0       	ldi	r24, 0x01	; 1
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    69ee:	df 91       	pop	r29
    69f0:	cf 91       	pop	r28
    69f2:	1f 91       	pop	r17
    69f4:	0f 91       	pop	r16
    69f6:	ff 90       	pop	r15
    69f8:	df 90       	pop	r13
    69fa:	cf 90       	pop	r12
    69fc:	08 95       	ret

000069fe <Endpoint_ConfigureEndpoint_Prv>:
		UEIENX  = 0;
		UEINTX  = 0;
		UECFG1X = 0;
		Endpoint_DisableEndpoint();
	}
}
    69fe:	8f 92       	push	r8
    6a00:	9f 92       	push	r9
    6a02:	bf 92       	push	r11
    6a04:	cf 92       	push	r12
    6a06:	df 92       	push	r13
    6a08:	ef 92       	push	r14
    6a0a:	ff 92       	push	r15
    6a0c:	0f 93       	push	r16
    6a0e:	1f 93       	push	r17
    6a10:	cf 93       	push	r28
    6a12:	df 93       	push	r29
    6a14:	87 30       	cpi	r24, 0x07	; 7
    6a16:	70 f1       	brcs	.+92     	; 0x6a74 <Endpoint_ConfigureEndpoint_Prv+0x76>
    6a18:	26 c0       	rjmp	.+76     	; 0x6a66 <Endpoint_ConfigureEndpoint_Prv+0x68>
    6a1a:	29 2f       	mov	r18, r25
    6a1c:	2f 70       	andi	r18, 0x0F	; 15
    6a1e:	e7 01       	movw	r28, r14
    6a20:	28 83       	st	Y, r18
    6a22:	89 17       	cp	r24, r25
    6a24:	31 f0       	breq	.+12     	; 0x6a32 <Endpoint_ConfigureEndpoint_Prv+0x34>
    6a26:	e8 01       	movw	r28, r16
    6a28:	78 81       	ld	r23, Y
    6a2a:	20 81       	ld	r18, Z
    6a2c:	e4 01       	movw	r28, r8
    6a2e:	58 81       	ld	r21, Y
    6a30:	03 c0       	rjmp	.+6      	; 0x6a38 <Endpoint_ConfigureEndpoint_Prv+0x3a>
    6a32:	24 2f       	mov	r18, r20
    6a34:	76 2f       	mov	r23, r22
    6a36:	5b 2d       	mov	r21, r11
    6a38:	21 ff       	sbrs	r18, 1
    6a3a:	12 c0       	rjmp	.+36     	; 0x6a60 <Endpoint_ConfigureEndpoint_Prv+0x62>
    6a3c:	3c 91       	ld	r19, X
    6a3e:	3e 7f       	andi	r19, 0xFE	; 254
    6a40:	3c 93       	st	X, r19
    6a42:	30 81       	ld	r19, Z
    6a44:	3d 7f       	andi	r19, 0xFD	; 253
    6a46:	30 83       	st	Z, r19
    6a48:	3c 91       	ld	r19, X
    6a4a:	31 60       	ori	r19, 0x01	; 1
    6a4c:	3c 93       	st	X, r19
    6a4e:	e8 01       	movw	r28, r16
    6a50:	78 83       	st	Y, r23
    6a52:	20 83       	st	Z, r18
    6a54:	e4 01       	movw	r28, r8
    6a56:	58 83       	st	Y, r21
    6a58:	e6 01       	movw	r28, r12
    6a5a:	28 81       	ld	r18, Y
    6a5c:	22 23       	and	r18, r18
    6a5e:	44 f4       	brge	.+16     	; 0x6a70 <Endpoint_ConfigureEndpoint_Prv+0x72>
    6a60:	9f 5f       	subi	r25, 0xFF	; 255
    6a62:	97 30       	cpi	r25, 0x07	; 7
    6a64:	d1 f6       	brne	.-76     	; 0x6a1a <Endpoint_ConfigureEndpoint_Prv+0x1c>
    6a66:	8f 70       	andi	r24, 0x0F	; 15
    6a68:	80 93 e9 00 	sts	0x00E9, r24
    6a6c:	81 e0       	ldi	r24, 0x01	; 1
    6a6e:	21 c0       	rjmp	.+66     	; 0x6ab2 <Endpoint_ConfigureEndpoint_Prv+0xb4>
    6a70:	80 e0       	ldi	r24, 0x00	; 0
    6a72:	1f c0       	rjmp	.+62     	; 0x6ab2 <Endpoint_ConfigureEndpoint_Prv+0xb4>
    6a74:	98 2f       	mov	r25, r24
    6a76:	9f 70       	andi	r25, 0x0F	; 15
    6a78:	90 93 e9 00 	sts	0x00E9, r25
    6a7c:	98 2f       	mov	r25, r24
    6a7e:	24 2f       	mov	r18, r20
    6a80:	76 2f       	mov	r23, r22
    6a82:	50 e0       	ldi	r21, 0x00	; 0
    6a84:	ab ee       	ldi	r26, 0xEB	; 235
    6a86:	b0 e0       	ldi	r27, 0x00	; 0
    6a88:	ed ee       	ldi	r30, 0xED	; 237
    6a8a:	f0 e0       	ldi	r31, 0x00	; 0
    6a8c:	0c ee       	ldi	r16, 0xEC	; 236
    6a8e:	10 e0       	ldi	r17, 0x00	; 0
    6a90:	0f 2e       	mov	r0, r31
    6a92:	f0 ef       	ldi	r31, 0xF0	; 240
    6a94:	8f 2e       	mov	r8, r31
    6a96:	91 2c       	mov	r9, r1
    6a98:	f0 2d       	mov	r31, r0
    6a9a:	0f 2e       	mov	r0, r31
    6a9c:	fe ee       	ldi	r31, 0xEE	; 238
    6a9e:	cf 2e       	mov	r12, r31
    6aa0:	d1 2c       	mov	r13, r1
    6aa2:	f0 2d       	mov	r31, r0
    6aa4:	0f 2e       	mov	r0, r31
    6aa6:	f9 ee       	ldi	r31, 0xE9	; 233
    6aa8:	ef 2e       	mov	r14, r31
    6aaa:	f1 2c       	mov	r15, r1
    6aac:	f0 2d       	mov	r31, r0
    6aae:	b1 2c       	mov	r11, r1
    6ab0:	c3 cf       	rjmp	.-122    	; 0x6a38 <Endpoint_ConfigureEndpoint_Prv+0x3a>
    6ab2:	df 91       	pop	r29
    6ab4:	cf 91       	pop	r28
    6ab6:	1f 91       	pop	r17
    6ab8:	0f 91       	pop	r16
    6aba:	ff 90       	pop	r15
    6abc:	ef 90       	pop	r14
    6abe:	df 90       	pop	r13
    6ac0:	cf 90       	pop	r12
    6ac2:	bf 90       	pop	r11
    6ac4:	9f 90       	pop	r9
    6ac6:	8f 90       	pop	r8
    6ac8:	08 95       	ret

00006aca <Endpoint_ConfigureEndpointTable>:
    6aca:	9f 92       	push	r9
    6acc:	af 92       	push	r10
    6ace:	bf 92       	push	r11
    6ad0:	cf 92       	push	r12
    6ad2:	df 92       	push	r13
    6ad4:	ef 92       	push	r14
    6ad6:	ff 92       	push	r15
    6ad8:	0f 93       	push	r16
    6ada:	1f 93       	push	r17
    6adc:	cf 93       	push	r28
    6ade:	df 93       	push	r29
    6ae0:	66 23       	and	r22, r22
    6ae2:	09 f4       	brne	.+2      	; 0x6ae6 <Endpoint_ConfigureEndpointTable+0x1c>
    6ae4:	49 c0       	rjmp	.+146    	; 0x6b78 <Endpoint_ConfigureEndpointTable+0xae>
    6ae6:	e6 2e       	mov	r14, r22
    6ae8:	8c 01       	movw	r16, r24
    6aea:	ec 01       	movw	r28, r24
    6aec:	0c 5f       	subi	r16, 0xFC	; 252
    6aee:	1f 4f       	sbci	r17, 0xFF	; 255
    6af0:	f1 2c       	mov	r15, r1
    6af2:	d1 2c       	mov	r13, r1
    6af4:	68 94       	set
    6af6:	bb 24       	eor	r11, r11
    6af8:	b3 f8       	bld	r11, 3
    6afa:	c1 2c       	mov	r12, r1
    6afc:	0f 2e       	mov	r0, r31
    6afe:	f6 e0       	ldi	r31, 0x06	; 6
    6b00:	af 2e       	mov	r10, r31
    6b02:	f0 2d       	mov	r31, r0
    6b04:	68 94       	set
    6b06:	99 24       	eor	r9, r9
    6b08:	91 f8       	bld	r9, 1
    6b0a:	58 81       	ld	r21, Y
    6b0c:	55 23       	and	r21, r21
    6b0e:	61 f1       	breq	.+88     	; 0x6b68 <Endpoint_ConfigureEndpointTable+0x9e>
    6b10:	f8 01       	movw	r30, r16
    6b12:	90 81       	ld	r25, Z
    6b14:	e9 81       	ldd	r30, Y+1	; 0x01
    6b16:	fa 81       	ldd	r31, Y+2	; 0x02
    6b18:	d8 01       	movw	r26, r16
    6b1a:	11 97       	sbiw	r26, 0x01	; 1
    6b1c:	6c 91       	ld	r22, X
    6b1e:	85 2f       	mov	r24, r21
    6b20:	8f 70       	andi	r24, 0x0F	; 15
    6b22:	87 30       	cpi	r24, 0x07	; 7
    6b24:	58 f5       	brcc	.+86     	; 0x6b7c <Endpoint_ConfigureEndpointTable+0xb2>
    6b26:	92 30       	cpi	r25, 0x02	; 2
    6b28:	10 f4       	brcc	.+4      	; 0x6b2e <Endpoint_ConfigureEndpointTable+0x64>
    6b2a:	49 2d       	mov	r20, r9
    6b2c:	01 c0       	rjmp	.+2      	; 0x6b30 <Endpoint_ConfigureEndpointTable+0x66>
    6b2e:	4a 2d       	mov	r20, r10
    6b30:	e9 30       	cpi	r30, 0x09	; 9
    6b32:	f1 05       	cpc	r31, r1
    6b34:	50 f0       	brcs	.+20     	; 0x6b4a <Endpoint_ConfigureEndpointTable+0x80>
    6b36:	2b 2d       	mov	r18, r11
    6b38:	3c 2d       	mov	r19, r12
    6b3a:	9d 2d       	mov	r25, r13
    6b3c:	9f 5f       	subi	r25, 0xFF	; 255
    6b3e:	22 0f       	add	r18, r18
    6b40:	33 1f       	adc	r19, r19
    6b42:	2e 17       	cp	r18, r30
    6b44:	3f 07       	cpc	r19, r31
    6b46:	d0 f3       	brcs	.-12     	; 0x6b3c <Endpoint_ConfigureEndpointTable+0x72>
    6b48:	01 c0       	rjmp	.+2      	; 0x6b4c <Endpoint_ConfigureEndpointTable+0x82>
    6b4a:	9d 2d       	mov	r25, r13
    6b4c:	92 95       	swap	r25
    6b4e:	90 7f       	andi	r25, 0xF0	; 240
    6b50:	49 2b       	or	r20, r25
    6b52:	f0 e4       	ldi	r31, 0x40	; 64
    6b54:	6f 9f       	mul	r22, r31
    6b56:	b0 01       	movw	r22, r0
    6b58:	11 24       	eor	r1, r1
    6b5a:	55 1f       	adc	r21, r21
    6b5c:	55 27       	eor	r21, r21
    6b5e:	55 1f       	adc	r21, r21
    6b60:	65 2b       	or	r22, r21
    6b62:	4d df       	rcall	.-358    	; 0x69fe <Endpoint_ConfigureEndpoint_Prv>
    6b64:	88 23       	and	r24, r24
    6b66:	59 f0       	breq	.+22     	; 0x6b7e <Endpoint_ConfigureEndpointTable+0xb4>
    6b68:	f3 94       	inc	r15
    6b6a:	25 96       	adiw	r28, 0x05	; 5
    6b6c:	0b 5f       	subi	r16, 0xFB	; 251
    6b6e:	1f 4f       	sbci	r17, 0xFF	; 255
    6b70:	fe 10       	cpse	r15, r14
    6b72:	cb cf       	rjmp	.-106    	; 0x6b0a <Endpoint_ConfigureEndpointTable+0x40>
    6b74:	81 e0       	ldi	r24, 0x01	; 1
    6b76:	03 c0       	rjmp	.+6      	; 0x6b7e <Endpoint_ConfigureEndpointTable+0xb4>
    6b78:	81 e0       	ldi	r24, 0x01	; 1
    6b7a:	01 c0       	rjmp	.+2      	; 0x6b7e <Endpoint_ConfigureEndpointTable+0xb4>
    6b7c:	80 e0       	ldi	r24, 0x00	; 0
    6b7e:	df 91       	pop	r29
    6b80:	cf 91       	pop	r28
    6b82:	1f 91       	pop	r17
    6b84:	0f 91       	pop	r16
    6b86:	ff 90       	pop	r15
    6b88:	ef 90       	pop	r14
    6b8a:	df 90       	pop	r13
    6b8c:	cf 90       	pop	r12
    6b8e:	bf 90       	pop	r11
    6b90:	af 90       	pop	r10
    6b92:	9f 90       	pop	r9
    6b94:	08 95       	ret

00006b96 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    6b96:	80 91 6e 0a 	lds	r24, 0x0A6E
    6b9a:	88 23       	and	r24, r24
    6b9c:	44 f0       	brlt	.+16     	; 0x6bae <Endpoint_ClearStatusStage+0x18>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6b9e:	e8 ee       	ldi	r30, 0xE8	; 232
    6ba0:	f0 e0       	ldi	r31, 0x00	; 0
    6ba2:	14 c0       	rjmp	.+40     	; 0x6bcc <Endpoint_ClearStatusStage+0x36>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    6ba4:	80 91 6d 0a 	lds	r24, 0x0A6D
    6ba8:	81 11       	cpse	r24, r1
    6baa:	03 c0       	rjmp	.+6      	; 0x6bb2 <Endpoint_ClearStatusStage+0x1c>
    6bac:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6bae:	e8 ee       	ldi	r30, 0xE8	; 232
    6bb0:	f0 e0       	ldi	r31, 0x00	; 0
    6bb2:	80 81       	ld	r24, Z

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    6bb4:	82 ff       	sbrs	r24, 2
    6bb6:	f6 cf       	rjmp	.-20     	; 0x6ba4 <Endpoint_ClearStatusStage+0xe>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6bb8:	e8 ee       	ldi	r30, 0xE8	; 232
    6bba:	f0 e0       	ldi	r31, 0x00	; 0
    6bbc:	80 81       	ld	r24, Z
    6bbe:	8b 77       	andi	r24, 0x7B	; 123
    6bc0:	80 83       	st	Z, r24
    6bc2:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    6bc4:	80 91 6d 0a 	lds	r24, 0x0A6D
    6bc8:	88 23       	and	r24, r24
    6bca:	41 f0       	breq	.+16     	; 0x6bdc <Endpoint_ClearStatusStage+0x46>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6bcc:	80 81       	ld	r24, Z

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    6bce:	80 ff       	sbrs	r24, 0
    6bd0:	f9 cf       	rjmp	.-14     	; 0x6bc4 <Endpoint_ClearStatusStage+0x2e>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6bd2:	e8 ee       	ldi	r30, 0xE8	; 232
    6bd4:	f0 e0       	ldi	r31, 0x00	; 0
    6bd6:	80 81       	ld	r24, Z
    6bd8:	8e 77       	andi	r24, 0x7E	; 126
    6bda:	80 83       	st	Z, r24
    6bdc:	08 95       	ret

00006bde <Endpoint_WaitUntilReady>:
	}
}

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
    6bde:	0f 93       	push	r16
    6be0:	1f 93       	push	r17
    6be2:	cf 93       	push	r28
    6be4:	df 93       	push	r29
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    6be6:	20 91 e4 00 	lds	r18, 0x00E4
    6bea:	30 91 e5 00 	lds	r19, 0x00E5
    6bee:	65 e6       	ldi	r22, 0x65	; 101
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    6bf0:	ac ee       	ldi	r26, 0xEC	; 236
    6bf2:	b0 e0       	ldi	r27, 0x00	; 0
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6bf4:	e8 ee       	ldi	r30, 0xE8	; 232
    6bf6:	f0 e0       	ldi	r31, 0x00	; 0
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    6bf8:	0b ee       	ldi	r16, 0xEB	; 235
    6bfa:	10 e0       	ldi	r17, 0x00	; 0
    6bfc:	44 ee       	ldi	r20, 0xE4	; 228
    6bfe:	50 e0       	ldi	r21, 0x00	; 0
    6c00:	01 c0       	rjmp	.+2      	; 0x6c04 <Endpoint_WaitUntilReady+0x26>
    6c02:	9c 01       	movw	r18, r24
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    6c04:	9c 91       	ld	r25, X
    6c06:	89 2f       	mov	r24, r25
    6c08:	81 70       	andi	r24, 0x01	; 1
    6c0a:	90 fd       	sbrc	r25, 0
    6c0c:	1d c0       	rjmp	.+58     	; 0x6c48 <Endpoint_WaitUntilReady+0x6a>
    6c0e:	20 c0       	rjmp	.+64     	; 0x6c50 <Endpoint_WaitUntilReady+0x72>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    6c10:	80 91 6d 0a 	lds	r24, 0x0A6D

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    6c14:	88 23       	and	r24, r24
    6c16:	81 f0       	breq	.+32     	; 0x6c38 <Endpoint_WaitUntilReady+0x5a>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    6c18:	85 30       	cpi	r24, 0x05	; 5
    6c1a:	81 f0       	breq	.+32     	; 0x6c3c <Endpoint_WaitUntilReady+0x5e>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    6c1c:	e8 01       	movw	r28, r16
    6c1e:	88 81       	ld	r24, Y
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    6c20:	85 fd       	sbrc	r24, 5
    6c22:	0e c0       	rjmp	.+28     	; 0x6c40 <Endpoint_WaitUntilReady+0x62>
    6c24:	ea 01       	movw	r28, r20
    6c26:	88 81       	ld	r24, Y
    6c28:	99 81       	ldd	r25, Y+1	; 0x01
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    6c2a:	28 17       	cp	r18, r24
    6c2c:	39 07       	cpc	r19, r25
    6c2e:	51 f3       	breq	.-44     	; 0x6c04 <Endpoint_WaitUntilReady+0x26>
    6c30:	61 50       	subi	r22, 0x01	; 1
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    6c32:	39 f7       	brne	.-50     	; 0x6c02 <Endpoint_WaitUntilReady+0x24>
			  return ENDPOINT_READYWAIT_Timeout;
    6c34:	84 e0       	ldi	r24, 0x04	; 4
    6c36:	0f c0       	rjmp	.+30     	; 0x6c56 <Endpoint_WaitUntilReady+0x78>
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    6c38:	82 e0       	ldi	r24, 0x02	; 2
    6c3a:	0d c0       	rjmp	.+26     	; 0x6c56 <Endpoint_WaitUntilReady+0x78>
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    6c3c:	83 e0       	ldi	r24, 0x03	; 3
    6c3e:	0b c0       	rjmp	.+22     	; 0x6c56 <Endpoint_WaitUntilReady+0x78>
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    6c40:	81 e0       	ldi	r24, 0x01	; 1
    6c42:	09 c0       	rjmp	.+18     	; 0x6c56 <Endpoint_WaitUntilReady+0x78>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    6c44:	80 e0       	ldi	r24, 0x00	; 0
    6c46:	07 c0       	rjmp	.+14     	; 0x6c56 <Endpoint_WaitUntilReady+0x78>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6c48:	80 81       	ld	r24, Z

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    6c4a:	80 ff       	sbrs	r24, 0
    6c4c:	e1 cf       	rjmp	.-62     	; 0x6c10 <Endpoint_WaitUntilReady+0x32>
    6c4e:	fa cf       	rjmp	.-12     	; 0x6c44 <Endpoint_WaitUntilReady+0x66>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6c50:	90 81       	ld	r25, Z
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    6c52:	92 ff       	sbrs	r25, 2
    6c54:	dd cf       	rjmp	.-70     	; 0x6c10 <Endpoint_WaitUntilReady+0x32>

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    6c56:	df 91       	pop	r29
    6c58:	cf 91       	pop	r28
    6c5a:	1f 91       	pop	r17
    6c5c:	0f 91       	pop	r16
    6c5e:	08 95       	ret

00006c60 <USB_Disable>:
	USB_ResetInterface();
}

void USB_Disable(void)
{
	USB_INT_DisableAllInterrupts();
    6c60:	68 d0       	rcall	.+208    	; 0x6d32 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    6c62:	6f d0       	rcall	.+222    	; 0x6d42 <USB_INT_ClearAllInterrupts>
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    6c64:	e0 ee       	ldi	r30, 0xE0	; 224
    6c66:	f0 e0       	ldi	r31, 0x00	; 0
    6c68:	80 81       	ld	r24, Z
    6c6a:	81 60       	ori	r24, 0x01	; 1
    6c6c:	80 83       	st	Z, r24
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USBCON &= ~(1 << USBE);
    6c6e:	e8 ed       	ldi	r30, 0xD8	; 216
    6c70:	f0 e0       	ldi	r31, 0x00	; 0
    6c72:	80 81       	ld	r24, Z
    6c74:	8f 77       	andi	r24, 0x7F	; 127
    6c76:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    6c78:	19 bc       	out	0x29, r1	; 41

			static inline void USB_REG_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_Off(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON &= ~(1 << UVREGE);
    6c7a:	a7 ed       	ldi	r26, 0xD7	; 215
    6c7c:	b0 e0       	ldi	r27, 0x00	; 0
    6c7e:	8c 91       	ld	r24, X
    6c80:	8e 7f       	andi	r24, 0xFE	; 254
    6c82:	8c 93       	st	X, r24
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    6c84:	80 81       	ld	r24, Z
    6c86:	8f 7e       	andi	r24, 0xEF	; 239
    6c88:	80 83       	st	Z, r24

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
    6c8a:	10 92 6c 0a 	sts	0x0A6C, r1
    6c8e:	08 95       	ret

00006c90 <USB_ResetInterface>:
}

void USB_ResetInterface(void)
{
    6c90:	0f 93       	push	r16
    6c92:	1f 93       	push	r17
    6c94:	cf 93       	push	r28
    6c96:	df 93       	push	r29
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    6c98:	4c d0       	rcall	.+152    	; 0x6d32 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    6c9a:	53 d0       	rcall	.+166    	; 0x6d42 <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    6c9c:	c8 ed       	ldi	r28, 0xD8	; 216
    6c9e:	d0 e0       	ldi	r29, 0x00	; 0
    6ca0:	88 81       	ld	r24, Y
    6ca2:	8f 77       	andi	r24, 0x7F	; 127
    6ca4:	88 83       	st	Y, r24
				USBCON |=  (1 << USBE);
    6ca6:	88 81       	ld	r24, Y
    6ca8:	80 68       	ori	r24, 0x80	; 128
    6caa:	88 83       	st	Y, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    6cac:	88 81       	ld	r24, Y
    6cae:	8f 7d       	andi	r24, 0xDF	; 223
    6cb0:	88 83       	st	Y, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    6cb2:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    6cb4:	10 92 6d 0a 	sts	0x0A6D, r1
	USB_Device_ConfigurationNumber  = 0;
    6cb8:	10 92 69 0a 	sts	0x0A69, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    6cbc:	10 92 6b 0a 	sts	0x0A6B, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    6cc0:	10 92 6a 0a 	sts	0x0A6A, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    6cc4:	00 ee       	ldi	r16, 0xE0	; 224
    6cc6:	10 e0       	ldi	r17, 0x00	; 0
    6cc8:	f8 01       	movw	r30, r16
    6cca:	80 81       	ld	r24, Z
    6ccc:	8b 7f       	andi	r24, 0xFB	; 251
    6cce:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    6cd0:	88 81       	ld	r24, Y
    6cd2:	81 60       	ori	r24, 0x01	; 1
    6cd4:	88 83       	st	Y, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    6cd6:	42 e0       	ldi	r20, 0x02	; 2
    6cd8:	60 e0       	ldi	r22, 0x00	; 0
    6cda:	80 e0       	ldi	r24, 0x00	; 0
    6cdc:	90 de       	rcall	.-736    	; 0x69fe <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    6cde:	e1 ee       	ldi	r30, 0xE1	; 225
    6ce0:	f0 e0       	ldi	r31, 0x00	; 0
    6ce2:	80 81       	ld	r24, Z
    6ce4:	8e 7f       	andi	r24, 0xFE	; 254
    6ce6:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    6ce8:	e2 ee       	ldi	r30, 0xE2	; 226
    6cea:	f0 e0       	ldi	r31, 0x00	; 0
    6cec:	80 81       	ld	r24, Z
    6cee:	81 60       	ori	r24, 0x01	; 1
    6cf0:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    6cf2:	80 81       	ld	r24, Z
    6cf4:	88 60       	ori	r24, 0x08	; 8
    6cf6:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    6cf8:	f8 01       	movw	r30, r16
    6cfa:	80 81       	ld	r24, Z
    6cfc:	8e 7f       	andi	r24, 0xFE	; 254
    6cfe:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    6d00:	88 81       	ld	r24, Y
    6d02:	80 61       	ori	r24, 0x10	; 16
    6d04:	88 83       	st	Y, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    6d06:	df 91       	pop	r29
    6d08:	cf 91       	pop	r28
    6d0a:	1f 91       	pop	r17
    6d0c:	0f 91       	pop	r16
    6d0e:	08 95       	ret

00006d10 <USB_Init>:
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    6d10:	e8 ed       	ldi	r30, 0xD8	; 216
    6d12:	f0 e0       	ldi	r31, 0x00	; 0
    6d14:	80 81       	ld	r24, Z
    6d16:	8f 7e       	andi	r24, 0xEF	; 239
    6d18:	80 83       	st	Z, r24

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    6d1a:	e7 ed       	ldi	r30, 0xD7	; 215
    6d1c:	f0 e0       	ldi	r31, 0x00	; 0
    6d1e:	80 81       	ld	r24, Z
    6d20:	81 60       	ori	r24, 0x01	; 1
    6d22:	80 83       	st	Z, r24
	  USB_REG_Off();

	if (!(USB_Options & USB_OPT_MANUAL_PLL))
	{
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = (1 << PDIV2);
    6d24:	84 e0       	ldi	r24, 0x04	; 4
    6d26:	82 bf       	out	0x32, r24	; 50
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    6d28:	81 e0       	ldi	r24, 0x01	; 1
    6d2a:	80 93 6c 0a 	sts	0x0A6C, r24

	USB_ResetInterface();
    6d2e:	b0 cf       	rjmp	.-160    	; 0x6c90 <USB_ResetInterface>
    6d30:	08 95       	ret

00006d32 <USB_INT_DisableAllInterrupts>:
void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
    6d32:	e8 ed       	ldi	r30, 0xD8	; 216
    6d34:	f0 e0       	ldi	r31, 0x00	; 0
    6d36:	80 81       	ld	r24, Z
    6d38:	8e 7f       	andi	r24, 0xFE	; 254
    6d3a:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    6d3c:	10 92 e2 00 	sts	0x00E2, r1
    6d40:	08 95       	ret

00006d42 <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    6d42:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    6d46:	10 92 e1 00 	sts	0x00E1, r1
    6d4a:	08 95       	ret

00006d4c <__vector_10>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    6d4c:	1f 92       	push	r1
    6d4e:	0f 92       	push	r0
    6d50:	0f b6       	in	r0, 0x3f	; 63
    6d52:	0f 92       	push	r0
    6d54:	11 24       	eor	r1, r1
    6d56:	2f 93       	push	r18
    6d58:	3f 93       	push	r19
    6d5a:	4f 93       	push	r20
    6d5c:	5f 93       	push	r21
    6d5e:	6f 93       	push	r22
    6d60:	7f 93       	push	r23
    6d62:	8f 93       	push	r24
    6d64:	9f 93       	push	r25
    6d66:	af 93       	push	r26
    6d68:	bf 93       	push	r27
    6d6a:	ef 93       	push	r30
    6d6c:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    6d6e:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    6d72:	82 ff       	sbrs	r24, 2
    6d74:	0b c0       	rjmp	.+22     	; 0x6d8c <__vector_10+0x40>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    6d76:	80 91 e2 00 	lds	r24, 0x00E2
    6d7a:	82 ff       	sbrs	r24, 2
    6d7c:	07 c0       	rjmp	.+14     	; 0x6d8c <__vector_10+0x40>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    6d7e:	e1 ee       	ldi	r30, 0xE1	; 225
    6d80:	f0 e0       	ldi	r31, 0x00	; 0
    6d82:	80 81       	ld	r24, Z
    6d84:	8b 7f       	andi	r24, 0xFB	; 251
    6d86:	80 83       	st	Z, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    6d88:	0e 94 78 27 	call	0x4ef0	; 0x4ef0 <EVENT_USB_Device_StartOfFrame>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    6d8c:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    6d90:	80 ff       	sbrs	r24, 0
    6d92:	1e c0       	rjmp	.+60     	; 0x6dd0 <__vector_10+0x84>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    6d94:	80 91 d8 00 	lds	r24, 0x00D8
    6d98:	80 ff       	sbrs	r24, 0
    6d9a:	1a c0       	rjmp	.+52     	; 0x6dd0 <__vector_10+0x84>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    6d9c:	ea ed       	ldi	r30, 0xDA	; 218
    6d9e:	f0 e0       	ldi	r31, 0x00	; 0
    6da0:	80 81       	ld	r24, Z
    6da2:	8e 7f       	andi	r24, 0xFE	; 254
    6da4:	80 83       	st	Z, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    6da6:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    6daa:	80 ff       	sbrs	r24, 0
    6dac:	0c c0       	rjmp	.+24     	; 0x6dc6 <__vector_10+0x7a>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    6dae:	19 bc       	out	0x29, r1	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    6db0:	82 e0       	ldi	r24, 0x02	; 2
    6db2:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    6db4:	09 b4       	in	r0, 0x29	; 41
    6db6:	00 fe       	sbrs	r0, 0
    6db8:	fd cf       	rjmp	.-6      	; 0x6db4 <__vector_10+0x68>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    6dba:	81 e0       	ldi	r24, 0x01	; 1
    6dbc:	80 93 6d 0a 	sts	0x0A6D, r24
			EVENT_USB_Device_Connect();
    6dc0:	0e 94 58 27 	call	0x4eb0	; 0x4eb0 <EVENT_USB_Device_Connect>
    6dc4:	05 c0       	rjmp	.+10     	; 0x6dd0 <__vector_10+0x84>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    6dc6:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    6dc8:	10 92 6d 0a 	sts	0x0A6D, r1
			EVENT_USB_Device_Disconnect();
    6dcc:	0e 94 59 27 	call	0x4eb2	; 0x4eb2 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    6dd0:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    6dd4:	80 ff       	sbrs	r24, 0
    6dd6:	17 c0       	rjmp	.+46     	; 0x6e06 <__vector_10+0xba>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    6dd8:	80 91 e2 00 	lds	r24, 0x00E2
    6ddc:	80 ff       	sbrs	r24, 0
    6dde:	13 c0       	rjmp	.+38     	; 0x6e06 <__vector_10+0xba>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    6de0:	e2 ee       	ldi	r30, 0xE2	; 226
    6de2:	f0 e0       	ldi	r31, 0x00	; 0
    6de4:	80 81       	ld	r24, Z
    6de6:	8e 7f       	andi	r24, 0xFE	; 254
    6de8:	80 83       	st	Z, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    6dea:	80 81       	ld	r24, Z
    6dec:	80 61       	ori	r24, 0x10	; 16
    6dee:	80 83       	st	Z, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    6df0:	e8 ed       	ldi	r30, 0xD8	; 216
    6df2:	f0 e0       	ldi	r31, 0x00	; 0
    6df4:	80 81       	ld	r24, Z
    6df6:	80 62       	ori	r24, 0x20	; 32
    6df8:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    6dfa:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    6dfc:	85 e0       	ldi	r24, 0x05	; 5
    6dfe:	80 93 6d 0a 	sts	0x0A6D, r24
		EVENT_USB_Device_Suspend();
    6e02:	0e 94 60 27 	call	0x4ec0	; 0x4ec0 <EVENT_USB_Device_Suspend>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    6e06:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    6e0a:	84 ff       	sbrs	r24, 4
    6e0c:	2f c0       	rjmp	.+94     	; 0x6e6c <__vector_10+0x120>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    6e0e:	80 91 e2 00 	lds	r24, 0x00E2
    6e12:	84 ff       	sbrs	r24, 4
    6e14:	2b c0       	rjmp	.+86     	; 0x6e6c <__vector_10+0x120>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    6e16:	19 bc       	out	0x29, r1	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    6e18:	82 e0       	ldi	r24, 0x02	; 2
    6e1a:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    6e1c:	09 b4       	in	r0, 0x29	; 41
    6e1e:	00 fe       	sbrs	r0, 0
    6e20:	fd cf       	rjmp	.-6      	; 0x6e1c <__vector_10+0xd0>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    6e22:	e8 ed       	ldi	r30, 0xD8	; 216
    6e24:	f0 e0       	ldi	r31, 0x00	; 0
    6e26:	80 81       	ld	r24, Z
    6e28:	8f 7d       	andi	r24, 0xDF	; 223
    6e2a:	80 83       	st	Z, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    6e2c:	e1 ee       	ldi	r30, 0xE1	; 225
    6e2e:	f0 e0       	ldi	r31, 0x00	; 0
    6e30:	80 81       	ld	r24, Z
    6e32:	8f 7e       	andi	r24, 0xEF	; 239
    6e34:	80 83       	st	Z, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    6e36:	e2 ee       	ldi	r30, 0xE2	; 226
    6e38:	f0 e0       	ldi	r31, 0x00	; 0
    6e3a:	80 81       	ld	r24, Z
    6e3c:	8f 7e       	andi	r24, 0xEF	; 239
    6e3e:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    6e40:	80 81       	ld	r24, Z
    6e42:	81 60       	ori	r24, 0x01	; 1
    6e44:	80 83       	st	Z, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    6e46:	80 91 69 0a 	lds	r24, 0x0A69
    6e4a:	88 23       	and	r24, r24
    6e4c:	21 f0       	breq	.+8      	; 0x6e56 <__vector_10+0x10a>
		  USB_DeviceState = DEVICE_STATE_Configured;
    6e4e:	84 e0       	ldi	r24, 0x04	; 4
    6e50:	80 93 6d 0a 	sts	0x0A6D, r24
    6e54:	09 c0       	rjmp	.+18     	; 0x6e68 <__vector_10+0x11c>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    6e56:	80 91 e3 00 	lds	r24, 0x00E3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
    6e5a:	88 23       	and	r24, r24
    6e5c:	14 f0       	brlt	.+4      	; 0x6e62 <__vector_10+0x116>
    6e5e:	81 e0       	ldi	r24, 0x01	; 1
    6e60:	01 c0       	rjmp	.+2      	; 0x6e64 <__vector_10+0x118>
    6e62:	83 e0       	ldi	r24, 0x03	; 3
    6e64:	80 93 6d 0a 	sts	0x0A6D, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    6e68:	0e 94 61 27 	call	0x4ec2	; 0x4ec2 <EVENT_USB_Device_WakeUp>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    6e6c:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    6e70:	83 ff       	sbrs	r24, 3
    6e72:	1e c0       	rjmp	.+60     	; 0x6eb0 <__vector_10+0x164>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    6e74:	80 91 e2 00 	lds	r24, 0x00E2
    6e78:	83 ff       	sbrs	r24, 3
    6e7a:	1a c0       	rjmp	.+52     	; 0x6eb0 <__vector_10+0x164>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    6e7c:	e1 ee       	ldi	r30, 0xE1	; 225
    6e7e:	f0 e0       	ldi	r31, 0x00	; 0
    6e80:	80 81       	ld	r24, Z
    6e82:	87 7f       	andi	r24, 0xF7	; 247
    6e84:	80 83       	st	Z, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    6e86:	82 e0       	ldi	r24, 0x02	; 2
    6e88:	80 93 6d 0a 	sts	0x0A6D, r24
		USB_Device_ConfigurationNumber = 0;
    6e8c:	10 92 69 0a 	sts	0x0A69, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    6e90:	80 81       	ld	r24, Z
    6e92:	8e 7f       	andi	r24, 0xFE	; 254
    6e94:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    6e96:	e2 ee       	ldi	r30, 0xE2	; 226
    6e98:	f0 e0       	ldi	r31, 0x00	; 0
    6e9a:	80 81       	ld	r24, Z
    6e9c:	8e 7f       	andi	r24, 0xFE	; 254
    6e9e:	80 83       	st	Z, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    6ea0:	80 81       	ld	r24, Z
    6ea2:	80 61       	ori	r24, 0x10	; 16
    6ea4:	80 83       	st	Z, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    6ea6:	42 e0       	ldi	r20, 0x02	; 2
    6ea8:	60 e0       	ldi	r22, 0x00	; 0
    6eaa:	80 e0       	ldi	r24, 0x00	; 0
    6eac:	a8 dd       	rcall	.-1200   	; 0x69fe <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    6eae:	81 d1       	rcall	.+770    	; 0x71b2 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    6eb0:	ff 91       	pop	r31
    6eb2:	ef 91       	pop	r30
    6eb4:	bf 91       	pop	r27
    6eb6:	af 91       	pop	r26
    6eb8:	9f 91       	pop	r25
    6eba:	8f 91       	pop	r24
    6ebc:	7f 91       	pop	r23
    6ebe:	6f 91       	pop	r22
    6ec0:	5f 91       	pop	r21
    6ec2:	4f 91       	pop	r20
    6ec4:	3f 91       	pop	r19
    6ec6:	2f 91       	pop	r18
    6ec8:	0f 90       	pop	r0
    6eca:	0f be       	out	0x3f, r0	; 63
    6ecc:	0f 90       	pop	r0
    6ece:	1f 90       	pop	r1
    6ed0:	18 95       	reti

00006ed2 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    6ed2:	0f 93       	push	r16
    6ed4:	1f 93       	push	r17
    6ed6:	cf 93       	push	r28
    6ed8:	df 93       	push	r29
    6eda:	cd b7       	in	r28, 0x3d	; 61
    6edc:	de b7       	in	r29, 0x3e	; 62
    6ede:	aa 97       	sbiw	r28, 0x2a	; 42
    6ee0:	0f b6       	in	r0, 0x3f	; 63
    6ee2:	f8 94       	cli
    6ee4:	de bf       	out	0x3e, r29	; 62
    6ee6:	0f be       	out	0x3f, r0	; 63
    6ee8:	cd bf       	out	0x3d, r28	; 61
    6eea:	ee e6       	ldi	r30, 0x6E	; 110
    6eec:	fa e0       	ldi	r31, 0x0A	; 10
    6eee:	26 e7       	ldi	r18, 0x76	; 118
    6ef0:	3a e0       	ldi	r19, 0x0A	; 10
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    6ef2:	a1 ef       	ldi	r26, 0xF1	; 241
    6ef4:	b0 e0       	ldi	r27, 0x00	; 0
    6ef6:	8c 91       	ld	r24, X
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    6ef8:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    6efa:	e2 17       	cp	r30, r18
    6efc:	f3 07       	cpc	r31, r19
    6efe:	d9 f7       	brne	.-10     	; 0x6ef6 <USB_Device_ProcessControlRequest+0x24>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    6f00:	0e 94 70 27 	call	0x4ee0	; 0x4ee0 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6f04:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    6f08:	83 ff       	sbrs	r24, 3
    6f0a:	2e c1       	rjmp	.+604    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    6f0c:	ee e6       	ldi	r30, 0x6E	; 110
    6f0e:	fa e0       	ldi	r31, 0x0A	; 10
    6f10:	90 81       	ld	r25, Z

		switch (USB_ControlRequest.bRequest)
    6f12:	81 81       	ldd	r24, Z+1	; 0x01
    6f14:	85 30       	cpi	r24, 0x05	; 5
    6f16:	09 f4       	brne	.+2      	; 0x6f1a <USB_Device_ProcessControlRequest+0x48>
    6f18:	79 c0       	rjmp	.+242    	; 0x700c <USB_Device_ProcessControlRequest+0x13a>
    6f1a:	30 f4       	brcc	.+12     	; 0x6f28 <USB_Device_ProcessControlRequest+0x56>
    6f1c:	81 30       	cpi	r24, 0x01	; 1
    6f1e:	b1 f1       	breq	.+108    	; 0x6f8c <USB_Device_ProcessControlRequest+0xba>
    6f20:	68 f0       	brcs	.+26     	; 0x6f3c <USB_Device_ProcessControlRequest+0x6a>
    6f22:	83 30       	cpi	r24, 0x03	; 3
    6f24:	99 f1       	breq	.+102    	; 0x6f8c <USB_Device_ProcessControlRequest+0xba>
    6f26:	20 c1       	rjmp	.+576    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
    6f28:	88 30       	cpi	r24, 0x08	; 8
    6f2a:	09 f4       	brne	.+2      	; 0x6f2e <USB_Device_ProcessControlRequest+0x5c>
    6f2c:	ea c0       	rjmp	.+468    	; 0x7102 <USB_Device_ProcessControlRequest+0x230>
    6f2e:	89 30       	cpi	r24, 0x09	; 9
    6f30:	09 f4       	brne	.+2      	; 0x6f34 <USB_Device_ProcessControlRequest+0x62>
    6f32:	f7 c0       	rjmp	.+494    	; 0x7122 <USB_Device_ProcessControlRequest+0x250>
    6f34:	86 30       	cpi	r24, 0x06	; 6
    6f36:	09 f0       	breq	.+2      	; 0x6f3a <USB_Device_ProcessControlRequest+0x68>
    6f38:	17 c1       	rjmp	.+558    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
    6f3a:	8b c0       	rjmp	.+278    	; 0x7052 <USB_Device_ProcessControlRequest+0x180>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    6f3c:	90 38       	cpi	r25, 0x80	; 128
    6f3e:	21 f0       	breq	.+8      	; 0x6f48 <USB_Device_ProcessControlRequest+0x76>
    6f40:	92 38       	cpi	r25, 0x82	; 130
    6f42:	09 f0       	breq	.+2      	; 0x6f46 <USB_Device_ProcessControlRequest+0x74>
    6f44:	11 c1       	rjmp	.+546    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
    6f46:	08 c0       	rjmp	.+16     	; 0x6f58 <USB_Device_ProcessControlRequest+0x86>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    6f48:	80 91 6a 0a 	lds	r24, 0x0A6A
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    6f4c:	90 91 6b 0a 	lds	r25, 0x0A6B
    6f50:	99 23       	and	r25, r25
    6f52:	71 f0       	breq	.+28     	; 0x6f70 <USB_Device_ProcessControlRequest+0x9e>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    6f54:	82 60       	ori	r24, 0x02	; 2
    6f56:	0c c0       	rjmp	.+24     	; 0x6f70 <USB_Device_ProcessControlRequest+0x9e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6f58:	80 91 72 0a 	lds	r24, 0x0A72
    6f5c:	8f 70       	andi	r24, 0x0F	; 15
    6f5e:	e9 ee       	ldi	r30, 0xE9	; 233
    6f60:	f0 e0       	ldi	r31, 0x00	; 0
    6f62:	80 83       	st	Z, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    6f64:	80 91 eb 00 	lds	r24, 0x00EB
    6f68:	85 fb       	bst	r24, 5
    6f6a:	88 27       	eor	r24, r24
    6f6c:	80 f9       	bld	r24, 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6f6e:	10 82       	st	Z, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6f70:	e8 ee       	ldi	r30, 0xE8	; 232
    6f72:	f0 e0       	ldi	r31, 0x00	; 0
    6f74:	90 81       	ld	r25, Z
    6f76:	97 7f       	andi	r25, 0xF7	; 247
    6f78:	90 83       	st	Z, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    6f7a:	a1 ef       	ldi	r26, 0xF1	; 241
    6f7c:	b0 e0       	ldi	r27, 0x00	; 0
    6f7e:	8c 93       	st	X, r24
				UEDATX = (Data >> 8);
    6f80:	1c 92       	st	X, r1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6f82:	80 81       	ld	r24, Z
    6f84:	8e 77       	andi	r24, 0x7E	; 126
    6f86:	80 83       	st	Z, r24
	Endpoint_ClearSETUP();

	Endpoint_Write_16_LE(CurrentStatus);
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    6f88:	06 de       	rcall	.-1012   	; 0x6b96 <Endpoint_ClearStatusStage>
    6f8a:	ee c0       	rjmp	.+476    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    6f8c:	99 23       	and	r25, r25
    6f8e:	09 f4       	brne	.+2      	; 0x6f92 <USB_Device_ProcessControlRequest+0xc0>
    6f90:	fa c0       	rjmp	.+500    	; 0x7186 <USB_Device_ProcessControlRequest+0x2b4>
    6f92:	92 30       	cpi	r25, 0x02	; 2
    6f94:	09 f0       	breq	.+2      	; 0x6f98 <USB_Device_ProcessControlRequest+0xc6>
    6f96:	e8 c0       	rjmp	.+464    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
    6f98:	fb c0       	rjmp	.+502    	; 0x7190 <USB_Device_ProcessControlRequest+0x2be>
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    6f9a:	91 e0       	ldi	r25, 0x01	; 1
    6f9c:	83 30       	cpi	r24, 0x03	; 3
    6f9e:	09 f0       	breq	.+2      	; 0x6fa2 <USB_Device_ProcessControlRequest+0xd0>
    6fa0:	90 e0       	ldi	r25, 0x00	; 0
    6fa2:	90 93 6b 0a 	sts	0x0A6B, r25
    6fa6:	29 c0       	rjmp	.+82     	; 0x6ffa <USB_Device_ProcessControlRequest+0x128>
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    6fa8:	80 91 72 0a 	lds	r24, 0x0A72
    6fac:	8f 70       	andi	r24, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    6fae:	09 f4       	brne	.+2      	; 0x6fb2 <USB_Device_ProcessControlRequest+0xe0>
    6fb0:	db c0       	rjmp	.+438    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6fb2:	80 93 e9 00 	sts	0x00E9, r24
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    6fb6:	90 91 eb 00 	lds	r25, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    6fba:	90 ff       	sbrs	r25, 0
    6fbc:	1e c0       	rjmp	.+60     	; 0x6ffa <USB_Device_ProcessControlRequest+0x128>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    6fbe:	90 91 6f 0a 	lds	r25, 0x0A6F
    6fc2:	93 30       	cpi	r25, 0x03	; 3
    6fc4:	31 f4       	brne	.+12     	; 0x6fd2 <USB_Device_ProcessControlRequest+0x100>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6fc6:	eb ee       	ldi	r30, 0xEB	; 235
    6fc8:	f0 e0       	ldi	r31, 0x00	; 0
    6fca:	80 81       	ld	r24, Z
    6fcc:	80 62       	ori	r24, 0x20	; 32
    6fce:	80 83       	st	Z, r24
    6fd0:	14 c0       	rjmp	.+40     	; 0x6ffa <USB_Device_ProcessControlRequest+0x128>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6fd2:	eb ee       	ldi	r30, 0xEB	; 235
    6fd4:	f0 e0       	ldi	r31, 0x00	; 0
    6fd6:	90 81       	ld	r25, Z
    6fd8:	90 61       	ori	r25, 0x10	; 16
    6fda:	90 83       	st	Z, r25
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    6fdc:	21 e0       	ldi	r18, 0x01	; 1
    6fde:	30 e0       	ldi	r19, 0x00	; 0
    6fe0:	a9 01       	movw	r20, r18
    6fe2:	02 c0       	rjmp	.+4      	; 0x6fe8 <USB_Device_ProcessControlRequest+0x116>
    6fe4:	44 0f       	add	r20, r20
    6fe6:	55 1f       	adc	r21, r21
    6fe8:	8a 95       	dec	r24
    6fea:	e2 f7       	brpl	.-8      	; 0x6fe4 <USB_Device_ProcessControlRequest+0x112>
    6fec:	aa ee       	ldi	r26, 0xEA	; 234
    6fee:	b0 e0       	ldi	r27, 0x00	; 0
    6ff0:	4c 93       	st	X, r20
				UERST = 0;
    6ff2:	1c 92       	st	X, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    6ff4:	80 81       	ld	r24, Z
    6ff6:	88 60       	ori	r24, 0x08	; 8
    6ff8:	80 83       	st	Z, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6ffa:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6ffe:	e8 ee       	ldi	r30, 0xE8	; 232
    7000:	f0 e0       	ldi	r31, 0x00	; 0
    7002:	80 81       	ld	r24, Z
    7004:	87 7f       	andi	r24, 0xF7	; 247
    7006:	80 83       	st	Z, r24

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    7008:	c6 dd       	rcall	.-1140   	; 0x6b96 <Endpoint_ClearStatusStage>
    700a:	ae c0       	rjmp	.+348    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    700c:	91 11       	cpse	r25, r1
    700e:	ac c0       	rjmp	.+344    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    7010:	10 91 70 0a 	lds	r17, 0x0A70
    7014:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    7016:	e3 ee       	ldi	r30, 0xE3	; 227
    7018:	f0 e0       	ldi	r31, 0x00	; 0
    701a:	80 81       	ld	r24, Z
    701c:	80 78       	andi	r24, 0x80	; 128
    701e:	81 2b       	or	r24, r17
    7020:	80 83       	st	Z, r24
    7022:	e8 ee       	ldi	r30, 0xE8	; 232
    7024:	f0 e0       	ldi	r31, 0x00	; 0
    7026:	80 81       	ld	r24, Z
    7028:	87 7f       	andi	r24, 0xF7	; 247
    702a:	80 83       	st	Z, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    702c:	b4 dd       	rcall	.-1176   	; 0x6b96 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    702e:	e8 ee       	ldi	r30, 0xE8	; 232
    7030:	f0 e0       	ldi	r31, 0x00	; 0
    7032:	80 81       	ld	r24, Z

	while (!(Endpoint_IsINReady()));
    7034:	80 ff       	sbrs	r24, 0
    7036:	fd cf       	rjmp	.-6      	; 0x7032 <USB_Device_ProcessControlRequest+0x160>
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;

				UDADDR |= (1 << ADDEN);
    7038:	e3 ee       	ldi	r30, 0xE3	; 227
    703a:	f0 e0       	ldi	r31, 0x00	; 0
    703c:	80 81       	ld	r24, Z
    703e:	80 68       	ori	r24, 0x80	; 128
    7040:	80 83       	st	Z, r24

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    7042:	11 11       	cpse	r17, r1
    7044:	02 c0       	rjmp	.+4      	; 0x704a <USB_Device_ProcessControlRequest+0x178>
    7046:	82 e0       	ldi	r24, 0x02	; 2
    7048:	01 c0       	rjmp	.+2      	; 0x704c <USB_Device_ProcessControlRequest+0x17a>
    704a:	83 e0       	ldi	r24, 0x03	; 3
    704c:	80 93 6d 0a 	sts	0x0A6D, r24
    7050:	8b c0       	rjmp	.+278    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    7052:	90 58       	subi	r25, 0x80	; 128
    7054:	92 30       	cpi	r25, 0x02	; 2
    7056:	08 f0       	brcs	.+2      	; 0x705a <USB_Device_ProcessControlRequest+0x188>
    7058:	87 c0       	rjmp	.+270    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    705a:	80 91 70 0a 	lds	r24, 0x0A70
    705e:	90 91 71 0a 	lds	r25, 0x0A71
    7062:	8c 3d       	cpi	r24, 0xDC	; 220
    7064:	53 e0       	ldi	r21, 0x03	; 3
    7066:	95 07       	cpc	r25, r21
    7068:	99 f5       	brne	.+102    	; 0x70d0 <USB_Device_ProcessControlRequest+0x1fe>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    706a:	83 e0       	ldi	r24, 0x03	; 3
    706c:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    706e:	8a e2       	ldi	r24, 0x2A	; 42
    7070:	89 83       	std	Y+1, r24	; 0x01
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    7072:	5f b7       	in	r21, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    7074:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    7076:	de 01       	movw	r26, r28
    7078:	13 96       	adiw	r26, 0x03	; 3
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    707a:	20 e0       	ldi	r18, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    707c:	3e e0       	ldi	r19, 0x0E	; 14

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    707e:	41 e2       	ldi	r20, 0x21	; 33
    7080:	e3 2f       	mov	r30, r19
    7082:	f0 e0       	ldi	r31, 0x00	; 0
    7084:	40 93 57 00 	sts	0x0057, r20
    7088:	84 91       	lpm	r24, Z

					if (SerialCharNum & 0x01)
    708a:	20 ff       	sbrs	r18, 0
    708c:	03 c0       	rjmp	.+6      	; 0x7094 <USB_Device_ProcessControlRequest+0x1c2>
					{
						SerialByte >>= 4;
    708e:	82 95       	swap	r24
    7090:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    7092:	3f 5f       	subi	r19, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    7094:	8f 70       	andi	r24, 0x0F	; 15

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    7096:	8a 30       	cpi	r24, 0x0A	; 10
    7098:	18 f0       	brcs	.+6      	; 0x70a0 <USB_Device_ProcessControlRequest+0x1ce>
    709a:	90 e0       	ldi	r25, 0x00	; 0
    709c:	c7 96       	adiw	r24, 0x37	; 55
    709e:	02 c0       	rjmp	.+4      	; 0x70a4 <USB_Device_ProcessControlRequest+0x1d2>
    70a0:	90 e0       	ldi	r25, 0x00	; 0
    70a2:	c0 96       	adiw	r24, 0x30	; 48
    70a4:	8d 93       	st	X+, r24
    70a6:	9d 93       	st	X+, r25
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    70a8:	2f 5f       	subi	r18, 0xFF	; 255
    70aa:	24 31       	cpi	r18, 0x14	; 20
    70ac:	49 f7       	brne	.-46     	; 0x7080 <USB_Device_ProcessControlRequest+0x1ae>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    70ae:	5f bf       	out	0x3f, r21	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    70b0:	08 ee       	ldi	r16, 0xE8	; 232
    70b2:	10 e0       	ldi	r17, 0x00	; 0
    70b4:	f8 01       	movw	r30, r16
    70b6:	80 81       	ld	r24, Z
    70b8:	87 7f       	andi	r24, 0xF7	; 247
    70ba:	80 83       	st	Z, r24

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    70bc:	6a e2       	ldi	r22, 0x2A	; 42
    70be:	70 e0       	ldi	r23, 0x00	; 0
    70c0:	ce 01       	movw	r24, r28
    70c2:	01 96       	adiw	r24, 0x01	; 1
    70c4:	1c db       	rcall	.-2504   	; 0x66fe <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    70c6:	f8 01       	movw	r30, r16
    70c8:	80 81       	ld	r24, Z
    70ca:	8b 77       	andi	r24, 0x7B	; 123
    70cc:	80 83       	st	Z, r24
    70ce:	4c c0       	rjmp	.+152    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    70d0:	ae 01       	movw	r20, r28
    70d2:	4f 5f       	subi	r20, 0xFF	; 255
    70d4:	5f 4f       	sbci	r21, 0xFF	; 255
    70d6:	60 91 72 0a 	lds	r22, 0x0A72
    70da:	0e 94 82 0a 	call	0x1504	; 0x1504 <CALLBACK_USB_GetDescriptor>
    70de:	bc 01       	movw	r22, r24
    70e0:	89 2b       	or	r24, r25
    70e2:	09 f4       	brne	.+2      	; 0x70e6 <USB_Device_ProcessControlRequest+0x214>
    70e4:	41 c0       	rjmp	.+130    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    70e6:	08 ee       	ldi	r16, 0xE8	; 232
    70e8:	10 e0       	ldi	r17, 0x00	; 0
    70ea:	f8 01       	movw	r30, r16
    70ec:	90 81       	ld	r25, Z
    70ee:	97 7f       	andi	r25, 0xF7	; 247
    70f0:	90 83       	st	Z, r25
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    70f2:	89 81       	ldd	r24, Y+1	; 0x01
    70f4:	9a 81       	ldd	r25, Y+2	; 0x02
    70f6:	fe db       	rcall	.-2052   	; 0x68f4 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    70f8:	f8 01       	movw	r30, r16
    70fa:	80 81       	ld	r24, Z
    70fc:	8b 77       	andi	r24, 0x7B	; 123
    70fe:	80 83       	st	Z, r24
    7100:	33 c0       	rjmp	.+102    	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    7102:	90 38       	cpi	r25, 0x80	; 128
    7104:	89 f5       	brne	.+98     	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7106:	e8 ee       	ldi	r30, 0xE8	; 232
    7108:	f0 e0       	ldi	r31, 0x00	; 0
    710a:	80 81       	ld	r24, Z
    710c:	87 7f       	andi	r24, 0xF7	; 247
    710e:	80 83       	st	Z, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    7110:	80 91 69 0a 	lds	r24, 0x0A69
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    7114:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    7118:	80 81       	ld	r24, Z
    711a:	8e 77       	andi	r24, 0x7E	; 126
    711c:	80 83       	st	Z, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    711e:	3b dd       	rcall	.-1418   	; 0x6b96 <Endpoint_ClearStatusStage>
    7120:	23 c0       	rjmp	.+70     	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    7122:	91 11       	cpse	r25, r1
    7124:	21 c0       	rjmp	.+66     	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    7126:	80 91 70 0a 	lds	r24, 0x0A70
    712a:	82 30       	cpi	r24, 0x02	; 2
    712c:	e8 f4       	brcc	.+58     	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    712e:	e8 ee       	ldi	r30, 0xE8	; 232
    7130:	f0 e0       	ldi	r31, 0x00	; 0
    7132:	80 81       	ld	r24, Z
    7134:	87 7f       	andi	r24, 0xF7	; 247
    7136:	80 83       	st	Z, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    7138:	80 91 70 0a 	lds	r24, 0x0A70
    713c:	80 93 69 0a 	sts	0x0A69, r24

	Endpoint_ClearStatusStage();
    7140:	2a dd       	rcall	.-1452   	; 0x6b96 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    7142:	80 91 69 0a 	lds	r24, 0x0A69
    7146:	88 23       	and	r24, r24
    7148:	21 f0       	breq	.+8      	; 0x7152 <USB_Device_ProcessControlRequest+0x280>
	  USB_DeviceState = DEVICE_STATE_Configured;
    714a:	84 e0       	ldi	r24, 0x04	; 4
    714c:	80 93 6d 0a 	sts	0x0A6D, r24
    7150:	09 c0       	rjmp	.+18     	; 0x7164 <USB_Device_ProcessControlRequest+0x292>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    7152:	80 91 e3 00 	lds	r24, 0x00E3
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    7156:	88 23       	and	r24, r24
    7158:	14 f0       	brlt	.+4      	; 0x715e <USB_Device_ProcessControlRequest+0x28c>
    715a:	81 e0       	ldi	r24, 0x01	; 1
    715c:	01 c0       	rjmp	.+2      	; 0x7160 <USB_Device_ProcessControlRequest+0x28e>
    715e:	84 e0       	ldi	r24, 0x04	; 4
    7160:	80 93 6d 0a 	sts	0x0A6D, r24

	EVENT_USB_Device_ConfigurationChanged();
    7164:	0e 94 62 27 	call	0x4ec4	; 0x4ec4 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    7168:	80 91 e8 00 	lds	r24, 0x00E8
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    716c:	83 ff       	sbrs	r24, 3
    716e:	16 c0       	rjmp	.+44     	; 0x719c <USB_Device_ProcessControlRequest+0x2ca>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    7170:	e8 ee       	ldi	r30, 0xE8	; 232
    7172:	f0 e0       	ldi	r31, 0x00	; 0
    7174:	80 81       	ld	r24, Z
    7176:	87 7f       	andi	r24, 0xF7	; 247
    7178:	80 83       	st	Z, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    717a:	eb ee       	ldi	r30, 0xEB	; 235
    717c:	f0 e0       	ldi	r31, 0x00	; 0
    717e:	80 81       	ld	r24, Z
    7180:	80 62       	ori	r24, 0x20	; 32
    7182:	80 83       	st	Z, r24
    7184:	0b c0       	rjmp	.+22     	; 0x719c <USB_Device_ProcessControlRequest+0x2ca>
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    7186:	90 91 70 0a 	lds	r25, 0x0A70
    718a:	91 30       	cpi	r25, 0x01	; 1
    718c:	69 f7       	brne	.-38     	; 0x7168 <USB_Device_ProcessControlRequest+0x296>
    718e:	05 cf       	rjmp	.-502    	; 0x6f9a <USB_Device_ProcessControlRequest+0xc8>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    7190:	80 91 70 0a 	lds	r24, 0x0A70
    7194:	88 23       	and	r24, r24
    7196:	09 f4       	brne	.+2      	; 0x719a <USB_Device_ProcessControlRequest+0x2c8>
    7198:	07 cf       	rjmp	.-498    	; 0x6fa8 <USB_Device_ProcessControlRequest+0xd6>
    719a:	2f cf       	rjmp	.-418    	; 0x6ffa <USB_Device_ProcessControlRequest+0x128>
	if (Endpoint_IsSETUPReceived())
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    719c:	aa 96       	adiw	r28, 0x2a	; 42
    719e:	0f b6       	in	r0, 0x3f	; 63
    71a0:	f8 94       	cli
    71a2:	de bf       	out	0x3e, r29	; 62
    71a4:	0f be       	out	0x3f, r0	; 63
    71a6:	cd bf       	out	0x3d, r28	; 61
    71a8:	df 91       	pop	r29
    71aa:	cf 91       	pop	r28
    71ac:	1f 91       	pop	r17
    71ae:	0f 91       	pop	r16
    71b0:	08 95       	ret

000071b2 <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
    71b2:	08 95       	ret

000071b4 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    71b4:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    71b6:	80 91 6d 0a 	lds	r24, 0x0A6D
    71ba:	88 23       	and	r24, r24
    71bc:	99 f0       	breq	.+38     	; 0x71e4 <USB_USBTask+0x30>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    71be:	c0 91 e9 00 	lds	r28, 0x00E9
    71c2:	cf 70       	andi	r28, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    71c4:	80 91 ec 00 	lds	r24, 0x00EC
    71c8:	98 2f       	mov	r25, r24
    71ca:	91 70       	andi	r25, 0x01	; 1
    71cc:	80 fd       	sbrc	r24, 0
    71ce:	90 e8       	ldi	r25, 0x80	; 128
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    71d0:	c9 2b       	or	r28, r25
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    71d2:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    71d6:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    71da:	83 fd       	sbrc	r24, 3
	  USB_Device_ProcessControlRequest();
    71dc:	7a de       	rcall	.-780    	; 0x6ed2 <USB_Device_ProcessControlRequest>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    71de:	cf 70       	andi	r28, 0x0F	; 15
    71e0:	c0 93 e9 00 	sts	0x00E9, r28
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    71e4:	cf 91       	pop	r28
    71e6:	08 95       	ret

000071e8 <__divmodhi4>:
    71e8:	97 fb       	bst	r25, 7
    71ea:	07 2e       	mov	r0, r23
    71ec:	16 f4       	brtc	.+4      	; 0x71f2 <__divmodhi4+0xa>
    71ee:	00 94       	com	r0
    71f0:	06 d0       	rcall	.+12     	; 0x71fe <__divmodhi4_neg1>
    71f2:	77 fd       	sbrc	r23, 7
    71f4:	08 d0       	rcall	.+16     	; 0x7206 <__divmodhi4_neg2>
    71f6:	82 d0       	rcall	.+260    	; 0x72fc <__udivmodhi4>
    71f8:	07 fc       	sbrc	r0, 7
    71fa:	05 d0       	rcall	.+10     	; 0x7206 <__divmodhi4_neg2>
    71fc:	3e f4       	brtc	.+14     	; 0x720c <__divmodhi4_exit>

000071fe <__divmodhi4_neg1>:
    71fe:	90 95       	com	r25
    7200:	81 95       	neg	r24
    7202:	9f 4f       	sbci	r25, 0xFF	; 255
    7204:	08 95       	ret

00007206 <__divmodhi4_neg2>:
    7206:	70 95       	com	r23
    7208:	61 95       	neg	r22
    720a:	7f 4f       	sbci	r23, 0xFF	; 255

0000720c <__divmodhi4_exit>:
    720c:	08 95       	ret

0000720e <__udivmodsi4>:
    720e:	a1 e2       	ldi	r26, 0x21	; 33
    7210:	1a 2e       	mov	r1, r26
    7212:	aa 1b       	sub	r26, r26
    7214:	bb 1b       	sub	r27, r27
    7216:	fd 01       	movw	r30, r26
    7218:	0d c0       	rjmp	.+26     	; 0x7234 <__udivmodsi4_ep>

0000721a <__udivmodsi4_loop>:
    721a:	aa 1f       	adc	r26, r26
    721c:	bb 1f       	adc	r27, r27
    721e:	ee 1f       	adc	r30, r30
    7220:	ff 1f       	adc	r31, r31
    7222:	a2 17       	cp	r26, r18
    7224:	b3 07       	cpc	r27, r19
    7226:	e4 07       	cpc	r30, r20
    7228:	f5 07       	cpc	r31, r21
    722a:	20 f0       	brcs	.+8      	; 0x7234 <__udivmodsi4_ep>
    722c:	a2 1b       	sub	r26, r18
    722e:	b3 0b       	sbc	r27, r19
    7230:	e4 0b       	sbc	r30, r20
    7232:	f5 0b       	sbc	r31, r21

00007234 <__udivmodsi4_ep>:
    7234:	66 1f       	adc	r22, r22
    7236:	77 1f       	adc	r23, r23
    7238:	88 1f       	adc	r24, r24
    723a:	99 1f       	adc	r25, r25
    723c:	1a 94       	dec	r1
    723e:	69 f7       	brne	.-38     	; 0x721a <__udivmodsi4_loop>
    7240:	60 95       	com	r22
    7242:	70 95       	com	r23
    7244:	80 95       	com	r24
    7246:	90 95       	com	r25
    7248:	9b 01       	movw	r18, r22
    724a:	ac 01       	movw	r20, r24
    724c:	bd 01       	movw	r22, r26
    724e:	cf 01       	movw	r24, r30
    7250:	08 95       	ret

00007252 <__muluhisi3>:
    7252:	81 d0       	rcall	.+258    	; 0x7356 <__umulhisi3>
    7254:	a5 9f       	mul	r26, r21
    7256:	90 0d       	add	r25, r0
    7258:	b4 9f       	mul	r27, r20
    725a:	90 0d       	add	r25, r0
    725c:	a4 9f       	mul	r26, r20
    725e:	80 0d       	add	r24, r0
    7260:	91 1d       	adc	r25, r1
    7262:	11 24       	eor	r1, r1
    7264:	08 95       	ret

00007266 <__clzdi2>:
    7266:	5e d0       	rcall	.+188    	; 0x7324 <__clzsi2>
    7268:	85 ff       	sbrs	r24, 5
    726a:	08 95       	ret
    726c:	b9 01       	movw	r22, r18
    726e:	ca 01       	movw	r24, r20
    7270:	59 d0       	rcall	.+178    	; 0x7324 <__clzsi2>
    7272:	80 5e       	subi	r24, 0xE0	; 224
    7274:	08 95       	ret

00007276 <__ashldi3>:
    7276:	0f 93       	push	r16
    7278:	08 30       	cpi	r16, 0x08	; 8
    727a:	90 f0       	brcs	.+36     	; 0x72a0 <__ashldi3+0x2a>
    727c:	98 2f       	mov	r25, r24
    727e:	87 2f       	mov	r24, r23
    7280:	76 2f       	mov	r23, r22
    7282:	65 2f       	mov	r22, r21
    7284:	54 2f       	mov	r21, r20
    7286:	43 2f       	mov	r20, r19
    7288:	32 2f       	mov	r19, r18
    728a:	22 27       	eor	r18, r18
    728c:	08 50       	subi	r16, 0x08	; 8
    728e:	f4 cf       	rjmp	.-24     	; 0x7278 <__ashldi3+0x2>
    7290:	22 0f       	add	r18, r18
    7292:	33 1f       	adc	r19, r19
    7294:	44 1f       	adc	r20, r20
    7296:	55 1f       	adc	r21, r21
    7298:	66 1f       	adc	r22, r22
    729a:	77 1f       	adc	r23, r23
    729c:	88 1f       	adc	r24, r24
    729e:	99 1f       	adc	r25, r25
    72a0:	0a 95       	dec	r16
    72a2:	b2 f7       	brpl	.-20     	; 0x7290 <__ashldi3+0x1a>
    72a4:	0f 91       	pop	r16
    72a6:	08 95       	ret

000072a8 <__ashrdi3>:
    72a8:	97 fb       	bst	r25, 7
    72aa:	10 f8       	bld	r1, 0

000072ac <__lshrdi3>:
    72ac:	16 94       	lsr	r1
    72ae:	00 08       	sbc	r0, r0
    72b0:	0f 93       	push	r16
    72b2:	08 30       	cpi	r16, 0x08	; 8
    72b4:	98 f0       	brcs	.+38     	; 0x72dc <__lshrdi3+0x30>
    72b6:	08 50       	subi	r16, 0x08	; 8
    72b8:	23 2f       	mov	r18, r19
    72ba:	34 2f       	mov	r19, r20
    72bc:	45 2f       	mov	r20, r21
    72be:	56 2f       	mov	r21, r22
    72c0:	67 2f       	mov	r22, r23
    72c2:	78 2f       	mov	r23, r24
    72c4:	89 2f       	mov	r24, r25
    72c6:	90 2d       	mov	r25, r0
    72c8:	f4 cf       	rjmp	.-24     	; 0x72b2 <__lshrdi3+0x6>
    72ca:	05 94       	asr	r0
    72cc:	97 95       	ror	r25
    72ce:	87 95       	ror	r24
    72d0:	77 95       	ror	r23
    72d2:	67 95       	ror	r22
    72d4:	57 95       	ror	r21
    72d6:	47 95       	ror	r20
    72d8:	37 95       	ror	r19
    72da:	27 95       	ror	r18
    72dc:	0a 95       	dec	r16
    72de:	aa f7       	brpl	.-22     	; 0x72ca <__lshrdi3+0x1e>
    72e0:	0f 91       	pop	r16
    72e2:	08 95       	ret

000072e4 <__cmpdi2_s8>:
    72e4:	00 24       	eor	r0, r0
    72e6:	a7 fd       	sbrc	r26, 7
    72e8:	00 94       	com	r0
    72ea:	2a 17       	cp	r18, r26
    72ec:	30 05       	cpc	r19, r0
    72ee:	40 05       	cpc	r20, r0
    72f0:	50 05       	cpc	r21, r0
    72f2:	60 05       	cpc	r22, r0
    72f4:	70 05       	cpc	r23, r0
    72f6:	80 05       	cpc	r24, r0
    72f8:	90 05       	cpc	r25, r0
    72fa:	08 95       	ret

000072fc <__udivmodhi4>:
    72fc:	aa 1b       	sub	r26, r26
    72fe:	bb 1b       	sub	r27, r27
    7300:	51 e1       	ldi	r21, 0x11	; 17
    7302:	07 c0       	rjmp	.+14     	; 0x7312 <__udivmodhi4_ep>

00007304 <__udivmodhi4_loop>:
    7304:	aa 1f       	adc	r26, r26
    7306:	bb 1f       	adc	r27, r27
    7308:	a6 17       	cp	r26, r22
    730a:	b7 07       	cpc	r27, r23
    730c:	10 f0       	brcs	.+4      	; 0x7312 <__udivmodhi4_ep>
    730e:	a6 1b       	sub	r26, r22
    7310:	b7 0b       	sbc	r27, r23

00007312 <__udivmodhi4_ep>:
    7312:	88 1f       	adc	r24, r24
    7314:	99 1f       	adc	r25, r25
    7316:	5a 95       	dec	r21
    7318:	a9 f7       	brne	.-22     	; 0x7304 <__udivmodhi4_loop>
    731a:	80 95       	com	r24
    731c:	90 95       	com	r25
    731e:	bc 01       	movw	r22, r24
    7320:	cd 01       	movw	r24, r26
    7322:	08 95       	ret

00007324 <__clzsi2>:
    7324:	06 d0       	rcall	.+12     	; 0x7332 <__clzhi2>
    7326:	84 ff       	sbrs	r24, 4
    7328:	08 95       	ret
    732a:	cb 01       	movw	r24, r22
    732c:	02 d0       	rcall	.+4      	; 0x7332 <__clzhi2>
    732e:	80 5f       	subi	r24, 0xF0	; 240
    7330:	08 95       	ret

00007332 <__clzhi2>:
    7332:	aa 27       	eor	r26, r26
    7334:	99 23       	and	r25, r25
    7336:	29 f4       	brne	.+10     	; 0x7342 <__clzhi2+0x10>
    7338:	a8 5f       	subi	r26, 0xF8	; 248
    733a:	98 2b       	or	r25, r24
    733c:	11 f4       	brne	.+4      	; 0x7342 <__clzhi2+0x10>
    733e:	80 e1       	ldi	r24, 0x10	; 16
    7340:	08 95       	ret
    7342:	90 31       	cpi	r25, 0x10	; 16
    7344:	18 f4       	brcc	.+6      	; 0x734c <__clzhi2+0x1a>
    7346:	ad 5f       	subi	r26, 0xFD	; 253
    7348:	92 95       	swap	r25
    734a:	a3 95       	inc	r26
    734c:	99 0f       	add	r25, r25
    734e:	e8 f7       	brcc	.-6      	; 0x734a <__clzhi2+0x18>
    7350:	8a 2f       	mov	r24, r26
    7352:	99 27       	eor	r25, r25
    7354:	08 95       	ret

00007356 <__umulhisi3>:
    7356:	a2 9f       	mul	r26, r18
    7358:	b0 01       	movw	r22, r0
    735a:	b3 9f       	mul	r27, r19
    735c:	c0 01       	movw	r24, r0
    735e:	a3 9f       	mul	r26, r19
    7360:	70 0d       	add	r23, r0
    7362:	81 1d       	adc	r24, r1
    7364:	11 24       	eor	r1, r1
    7366:	91 1d       	adc	r25, r1
    7368:	b2 9f       	mul	r27, r18
    736a:	70 0d       	add	r23, r0
    736c:	81 1d       	adc	r24, r1
    736e:	11 24       	eor	r1, r1
    7370:	91 1d       	adc	r25, r1
    7372:	08 95       	ret

00007374 <toupper>:
    7374:	91 11       	cpse	r25, r1
    7376:	08 95       	ret
    7378:	81 56       	subi	r24, 0x61	; 97
    737a:	8a 51       	subi	r24, 0x1A	; 26
    737c:	08 f4       	brcc	.+2      	; 0x7380 <toupper+0xc>
    737e:	80 52       	subi	r24, 0x20	; 32
    7380:	85 58       	subi	r24, 0x85	; 133
    7382:	08 95       	ret

00007384 <strcpy_P>:
    7384:	fb 01       	movw	r30, r22
    7386:	dc 01       	movw	r26, r24
    7388:	05 90       	lpm	r0, Z+
    738a:	0d 92       	st	X+, r0
    738c:	00 20       	and	r0, r0
    738e:	e1 f7       	brne	.-8      	; 0x7388 <strcpy_P+0x4>
    7390:	08 95       	ret

00007392 <strtok>:
    7392:	4e ec       	ldi	r20, 0xCE	; 206
    7394:	53 e0       	ldi	r21, 0x03	; 3
    7396:	1d c0       	rjmp	.+58     	; 0x73d2 <strtok_r>

00007398 <memcmp>:
    7398:	fb 01       	movw	r30, r22
    739a:	dc 01       	movw	r26, r24
    739c:	04 c0       	rjmp	.+8      	; 0x73a6 <memcmp+0xe>
    739e:	8d 91       	ld	r24, X+
    73a0:	01 90       	ld	r0, Z+
    73a2:	80 19       	sub	r24, r0
    73a4:	21 f4       	brne	.+8      	; 0x73ae <memcmp+0x16>
    73a6:	41 50       	subi	r20, 0x01	; 1
    73a8:	50 40       	sbci	r21, 0x00	; 0
    73aa:	c8 f7       	brcc	.-14     	; 0x739e <memcmp+0x6>
    73ac:	88 1b       	sub	r24, r24
    73ae:	99 0b       	sbc	r25, r25
    73b0:	08 95       	ret

000073b2 <memcpy>:
    73b2:	fb 01       	movw	r30, r22
    73b4:	dc 01       	movw	r26, r24
    73b6:	02 c0       	rjmp	.+4      	; 0x73bc <memcpy+0xa>
    73b8:	01 90       	ld	r0, Z+
    73ba:	0d 92       	st	X+, r0
    73bc:	41 50       	subi	r20, 0x01	; 1
    73be:	50 40       	sbci	r21, 0x00	; 0
    73c0:	d8 f7       	brcc	.-10     	; 0x73b8 <memcpy+0x6>
    73c2:	08 95       	ret

000073c4 <memset>:
    73c4:	dc 01       	movw	r26, r24
    73c6:	01 c0       	rjmp	.+2      	; 0x73ca <memset+0x6>
    73c8:	6d 93       	st	X+, r22
    73ca:	41 50       	subi	r20, 0x01	; 1
    73cc:	50 40       	sbci	r21, 0x00	; 0
    73ce:	e0 f7       	brcc	.-8      	; 0x73c8 <memset+0x4>
    73d0:	08 95       	ret

000073d2 <strtok_r>:
    73d2:	fa 01       	movw	r30, r20
    73d4:	a1 91       	ld	r26, Z+
    73d6:	b0 81       	ld	r27, Z
    73d8:	00 97       	sbiw	r24, 0x00	; 0
    73da:	19 f4       	brne	.+6      	; 0x73e2 <strtok_r+0x10>
    73dc:	10 97       	sbiw	r26, 0x00	; 0
    73de:	e1 f0       	breq	.+56     	; 0x7418 <strtok_r+0x46>
    73e0:	cd 01       	movw	r24, r26
    73e2:	dc 01       	movw	r26, r24
    73e4:	cd 01       	movw	r24, r26
    73e6:	0d 90       	ld	r0, X+
    73e8:	00 20       	and	r0, r0
    73ea:	11 f4       	brne	.+4      	; 0x73f0 <strtok_r+0x1e>
    73ec:	c0 01       	movw	r24, r0
    73ee:	13 c0       	rjmp	.+38     	; 0x7416 <strtok_r+0x44>
    73f0:	fb 01       	movw	r30, r22
    73f2:	21 91       	ld	r18, Z+
    73f4:	22 23       	and	r18, r18
    73f6:	19 f0       	breq	.+6      	; 0x73fe <strtok_r+0x2c>
    73f8:	20 15       	cp	r18, r0
    73fa:	d9 f7       	brne	.-10     	; 0x73f2 <strtok_r+0x20>
    73fc:	f3 cf       	rjmp	.-26     	; 0x73e4 <strtok_r+0x12>
    73fe:	fb 01       	movw	r30, r22
    7400:	21 91       	ld	r18, Z+
    7402:	20 15       	cp	r18, r0
    7404:	19 f4       	brne	.+6      	; 0x740c <strtok_r+0x3a>
    7406:	1e 92       	st	-X, r1
    7408:	11 96       	adiw	r26, 0x01	; 1
    740a:	06 c0       	rjmp	.+12     	; 0x7418 <strtok_r+0x46>
    740c:	22 23       	and	r18, r18
    740e:	c1 f7       	brne	.-16     	; 0x7400 <strtok_r+0x2e>
    7410:	0d 90       	ld	r0, X+
    7412:	00 20       	and	r0, r0
    7414:	a1 f7       	brne	.-24     	; 0x73fe <strtok_r+0x2c>
    7416:	d0 01       	movw	r26, r0
    7418:	fa 01       	movw	r30, r20
    741a:	a1 93       	st	Z+, r26
    741c:	b0 83       	st	Z, r27
    741e:	08 95       	ret

00007420 <sprintf>:
    7420:	ae e0       	ldi	r26, 0x0E	; 14
    7422:	b0 e0       	ldi	r27, 0x00	; 0
    7424:	e5 e1       	ldi	r30, 0x15	; 21
    7426:	fa e3       	ldi	r31, 0x3A	; 58
    7428:	e1 c2       	rjmp	.+1474   	; 0x79ec <__prologue_saves__+0x1c>
    742a:	0d 89       	ldd	r16, Y+21	; 0x15
    742c:	1e 89       	ldd	r17, Y+22	; 0x16
    742e:	86 e0       	ldi	r24, 0x06	; 6
    7430:	8c 83       	std	Y+4, r24	; 0x04
    7432:	1a 83       	std	Y+2, r17	; 0x02
    7434:	09 83       	std	Y+1, r16	; 0x01
    7436:	8f ef       	ldi	r24, 0xFF	; 255
    7438:	9f e7       	ldi	r25, 0x7F	; 127
    743a:	9e 83       	std	Y+6, r25	; 0x06
    743c:	8d 83       	std	Y+5, r24	; 0x05
    743e:	ae 01       	movw	r20, r28
    7440:	47 5e       	subi	r20, 0xE7	; 231
    7442:	5f 4f       	sbci	r21, 0xFF	; 255
    7444:	6f 89       	ldd	r22, Y+23	; 0x17
    7446:	78 8d       	ldd	r23, Y+24	; 0x18
    7448:	ce 01       	movw	r24, r28
    744a:	01 96       	adiw	r24, 0x01	; 1
    744c:	09 d0       	rcall	.+18     	; 0x7460 <vfprintf>
    744e:	2f 81       	ldd	r18, Y+7	; 0x07
    7450:	38 85       	ldd	r19, Y+8	; 0x08
    7452:	f8 01       	movw	r30, r16
    7454:	e2 0f       	add	r30, r18
    7456:	f3 1f       	adc	r31, r19
    7458:	10 82       	st	Z, r1
    745a:	2e 96       	adiw	r28, 0x0e	; 14
    745c:	e4 e0       	ldi	r30, 0x04	; 4
    745e:	e2 c2       	rjmp	.+1476   	; 0x7a24 <__epilogue_restores__+0x1c>

00007460 <vfprintf>:
    7460:	ac e0       	ldi	r26, 0x0C	; 12
    7462:	b0 e0       	ldi	r27, 0x00	; 0
    7464:	e5 e3       	ldi	r30, 0x35	; 53
    7466:	fa e3       	ldi	r31, 0x3A	; 58
    7468:	b3 c2       	rjmp	.+1382   	; 0x79d0 <__prologue_saves__>
    746a:	7c 01       	movw	r14, r24
    746c:	6b 01       	movw	r12, r22
    746e:	8a 01       	movw	r16, r20
    7470:	fc 01       	movw	r30, r24
    7472:	17 82       	std	Z+7, r1	; 0x07
    7474:	16 82       	std	Z+6, r1	; 0x06
    7476:	83 81       	ldd	r24, Z+3	; 0x03
    7478:	81 ff       	sbrs	r24, 1
    747a:	b0 c1       	rjmp	.+864    	; 0x77dc <vfprintf+0x37c>
    747c:	ce 01       	movw	r24, r28
    747e:	01 96       	adiw	r24, 0x01	; 1
    7480:	4c 01       	movw	r8, r24
    7482:	f7 01       	movw	r30, r14
    7484:	93 81       	ldd	r25, Z+3	; 0x03
    7486:	f6 01       	movw	r30, r12
    7488:	93 fd       	sbrc	r25, 3
    748a:	85 91       	lpm	r24, Z+
    748c:	93 ff       	sbrs	r25, 3
    748e:	81 91       	ld	r24, Z+
    7490:	6f 01       	movw	r12, r30
    7492:	88 23       	and	r24, r24
    7494:	09 f4       	brne	.+2      	; 0x7498 <vfprintf+0x38>
    7496:	9e c1       	rjmp	.+828    	; 0x77d4 <vfprintf+0x374>
    7498:	85 32       	cpi	r24, 0x25	; 37
    749a:	39 f4       	brne	.+14     	; 0x74aa <vfprintf+0x4a>
    749c:	93 fd       	sbrc	r25, 3
    749e:	85 91       	lpm	r24, Z+
    74a0:	93 ff       	sbrs	r25, 3
    74a2:	81 91       	ld	r24, Z+
    74a4:	6f 01       	movw	r12, r30
    74a6:	85 32       	cpi	r24, 0x25	; 37
    74a8:	21 f4       	brne	.+8      	; 0x74b2 <vfprintf+0x52>
    74aa:	b7 01       	movw	r22, r14
    74ac:	90 e0       	ldi	r25, 0x00	; 0
    74ae:	b1 d1       	rcall	.+866    	; 0x7812 <fputc>
    74b0:	e8 cf       	rjmp	.-48     	; 0x7482 <vfprintf+0x22>
    74b2:	51 2c       	mov	r5, r1
    74b4:	31 2c       	mov	r3, r1
    74b6:	20 e0       	ldi	r18, 0x00	; 0
    74b8:	20 32       	cpi	r18, 0x20	; 32
    74ba:	a0 f4       	brcc	.+40     	; 0x74e4 <vfprintf+0x84>
    74bc:	8b 32       	cpi	r24, 0x2B	; 43
    74be:	69 f0       	breq	.+26     	; 0x74da <vfprintf+0x7a>
    74c0:	30 f4       	brcc	.+12     	; 0x74ce <vfprintf+0x6e>
    74c2:	80 32       	cpi	r24, 0x20	; 32
    74c4:	59 f0       	breq	.+22     	; 0x74dc <vfprintf+0x7c>
    74c6:	83 32       	cpi	r24, 0x23	; 35
    74c8:	69 f4       	brne	.+26     	; 0x74e4 <vfprintf+0x84>
    74ca:	20 61       	ori	r18, 0x10	; 16
    74cc:	2c c0       	rjmp	.+88     	; 0x7526 <vfprintf+0xc6>
    74ce:	8d 32       	cpi	r24, 0x2D	; 45
    74d0:	39 f0       	breq	.+14     	; 0x74e0 <vfprintf+0x80>
    74d2:	80 33       	cpi	r24, 0x30	; 48
    74d4:	39 f4       	brne	.+14     	; 0x74e4 <vfprintf+0x84>
    74d6:	21 60       	ori	r18, 0x01	; 1
    74d8:	26 c0       	rjmp	.+76     	; 0x7526 <vfprintf+0xc6>
    74da:	22 60       	ori	r18, 0x02	; 2
    74dc:	24 60       	ori	r18, 0x04	; 4
    74de:	23 c0       	rjmp	.+70     	; 0x7526 <vfprintf+0xc6>
    74e0:	28 60       	ori	r18, 0x08	; 8
    74e2:	21 c0       	rjmp	.+66     	; 0x7526 <vfprintf+0xc6>
    74e4:	27 fd       	sbrc	r18, 7
    74e6:	27 c0       	rjmp	.+78     	; 0x7536 <vfprintf+0xd6>
    74e8:	30 ed       	ldi	r19, 0xD0	; 208
    74ea:	38 0f       	add	r19, r24
    74ec:	3a 30       	cpi	r19, 0x0A	; 10
    74ee:	78 f4       	brcc	.+30     	; 0x750e <vfprintf+0xae>
    74f0:	26 ff       	sbrs	r18, 6
    74f2:	06 c0       	rjmp	.+12     	; 0x7500 <vfprintf+0xa0>
    74f4:	fa e0       	ldi	r31, 0x0A	; 10
    74f6:	5f 9e       	mul	r5, r31
    74f8:	30 0d       	add	r19, r0
    74fa:	11 24       	eor	r1, r1
    74fc:	53 2e       	mov	r5, r19
    74fe:	13 c0       	rjmp	.+38     	; 0x7526 <vfprintf+0xc6>
    7500:	8a e0       	ldi	r24, 0x0A	; 10
    7502:	38 9e       	mul	r3, r24
    7504:	30 0d       	add	r19, r0
    7506:	11 24       	eor	r1, r1
    7508:	33 2e       	mov	r3, r19
    750a:	20 62       	ori	r18, 0x20	; 32
    750c:	0c c0       	rjmp	.+24     	; 0x7526 <vfprintf+0xc6>
    750e:	8e 32       	cpi	r24, 0x2E	; 46
    7510:	21 f4       	brne	.+8      	; 0x751a <vfprintf+0xba>
    7512:	26 fd       	sbrc	r18, 6
    7514:	5f c1       	rjmp	.+702    	; 0x77d4 <vfprintf+0x374>
    7516:	20 64       	ori	r18, 0x40	; 64
    7518:	06 c0       	rjmp	.+12     	; 0x7526 <vfprintf+0xc6>
    751a:	8c 36       	cpi	r24, 0x6C	; 108
    751c:	11 f4       	brne	.+4      	; 0x7522 <vfprintf+0xc2>
    751e:	20 68       	ori	r18, 0x80	; 128
    7520:	02 c0       	rjmp	.+4      	; 0x7526 <vfprintf+0xc6>
    7522:	88 36       	cpi	r24, 0x68	; 104
    7524:	41 f4       	brne	.+16     	; 0x7536 <vfprintf+0xd6>
    7526:	f6 01       	movw	r30, r12
    7528:	93 fd       	sbrc	r25, 3
    752a:	85 91       	lpm	r24, Z+
    752c:	93 ff       	sbrs	r25, 3
    752e:	81 91       	ld	r24, Z+
    7530:	6f 01       	movw	r12, r30
    7532:	81 11       	cpse	r24, r1
    7534:	c1 cf       	rjmp	.-126    	; 0x74b8 <vfprintf+0x58>
    7536:	98 2f       	mov	r25, r24
    7538:	9f 7d       	andi	r25, 0xDF	; 223
    753a:	95 54       	subi	r25, 0x45	; 69
    753c:	93 30       	cpi	r25, 0x03	; 3
    753e:	28 f4       	brcc	.+10     	; 0x754a <vfprintf+0xea>
    7540:	0c 5f       	subi	r16, 0xFC	; 252
    7542:	1f 4f       	sbci	r17, 0xFF	; 255
    7544:	ff e3       	ldi	r31, 0x3F	; 63
    7546:	f9 83       	std	Y+1, r31	; 0x01
    7548:	0d c0       	rjmp	.+26     	; 0x7564 <vfprintf+0x104>
    754a:	83 36       	cpi	r24, 0x63	; 99
    754c:	31 f0       	breq	.+12     	; 0x755a <vfprintf+0xfa>
    754e:	83 37       	cpi	r24, 0x73	; 115
    7550:	71 f0       	breq	.+28     	; 0x756e <vfprintf+0x10e>
    7552:	83 35       	cpi	r24, 0x53	; 83
    7554:	09 f0       	breq	.+2      	; 0x7558 <vfprintf+0xf8>
    7556:	57 c0       	rjmp	.+174    	; 0x7606 <vfprintf+0x1a6>
    7558:	21 c0       	rjmp	.+66     	; 0x759c <vfprintf+0x13c>
    755a:	f8 01       	movw	r30, r16
    755c:	80 81       	ld	r24, Z
    755e:	89 83       	std	Y+1, r24	; 0x01
    7560:	0e 5f       	subi	r16, 0xFE	; 254
    7562:	1f 4f       	sbci	r17, 0xFF	; 255
    7564:	44 24       	eor	r4, r4
    7566:	43 94       	inc	r4
    7568:	51 2c       	mov	r5, r1
    756a:	54 01       	movw	r10, r8
    756c:	14 c0       	rjmp	.+40     	; 0x7596 <vfprintf+0x136>
    756e:	38 01       	movw	r6, r16
    7570:	f2 e0       	ldi	r31, 0x02	; 2
    7572:	6f 0e       	add	r6, r31
    7574:	71 1c       	adc	r7, r1
    7576:	f8 01       	movw	r30, r16
    7578:	a0 80       	ld	r10, Z
    757a:	b1 80       	ldd	r11, Z+1	; 0x01
    757c:	26 ff       	sbrs	r18, 6
    757e:	03 c0       	rjmp	.+6      	; 0x7586 <vfprintf+0x126>
    7580:	65 2d       	mov	r22, r5
    7582:	70 e0       	ldi	r23, 0x00	; 0
    7584:	02 c0       	rjmp	.+4      	; 0x758a <vfprintf+0x12a>
    7586:	6f ef       	ldi	r22, 0xFF	; 255
    7588:	7f ef       	ldi	r23, 0xFF	; 255
    758a:	c5 01       	movw	r24, r10
    758c:	2c 87       	std	Y+12, r18	; 0x0c
    758e:	36 d1       	rcall	.+620    	; 0x77fc <strnlen>
    7590:	2c 01       	movw	r4, r24
    7592:	83 01       	movw	r16, r6
    7594:	2c 85       	ldd	r18, Y+12	; 0x0c
    7596:	2f 77       	andi	r18, 0x7F	; 127
    7598:	22 2e       	mov	r2, r18
    759a:	16 c0       	rjmp	.+44     	; 0x75c8 <vfprintf+0x168>
    759c:	38 01       	movw	r6, r16
    759e:	f2 e0       	ldi	r31, 0x02	; 2
    75a0:	6f 0e       	add	r6, r31
    75a2:	71 1c       	adc	r7, r1
    75a4:	f8 01       	movw	r30, r16
    75a6:	a0 80       	ld	r10, Z
    75a8:	b1 80       	ldd	r11, Z+1	; 0x01
    75aa:	26 ff       	sbrs	r18, 6
    75ac:	03 c0       	rjmp	.+6      	; 0x75b4 <vfprintf+0x154>
    75ae:	65 2d       	mov	r22, r5
    75b0:	70 e0       	ldi	r23, 0x00	; 0
    75b2:	02 c0       	rjmp	.+4      	; 0x75b8 <vfprintf+0x158>
    75b4:	6f ef       	ldi	r22, 0xFF	; 255
    75b6:	7f ef       	ldi	r23, 0xFF	; 255
    75b8:	c5 01       	movw	r24, r10
    75ba:	2c 87       	std	Y+12, r18	; 0x0c
    75bc:	14 d1       	rcall	.+552    	; 0x77e6 <strnlen_P>
    75be:	2c 01       	movw	r4, r24
    75c0:	2c 85       	ldd	r18, Y+12	; 0x0c
    75c2:	20 68       	ori	r18, 0x80	; 128
    75c4:	22 2e       	mov	r2, r18
    75c6:	83 01       	movw	r16, r6
    75c8:	23 fc       	sbrc	r2, 3
    75ca:	19 c0       	rjmp	.+50     	; 0x75fe <vfprintf+0x19e>
    75cc:	83 2d       	mov	r24, r3
    75ce:	90 e0       	ldi	r25, 0x00	; 0
    75d0:	48 16       	cp	r4, r24
    75d2:	59 06       	cpc	r5, r25
    75d4:	a0 f4       	brcc	.+40     	; 0x75fe <vfprintf+0x19e>
    75d6:	b7 01       	movw	r22, r14
    75d8:	80 e2       	ldi	r24, 0x20	; 32
    75da:	90 e0       	ldi	r25, 0x00	; 0
    75dc:	1a d1       	rcall	.+564    	; 0x7812 <fputc>
    75de:	3a 94       	dec	r3
    75e0:	f5 cf       	rjmp	.-22     	; 0x75cc <vfprintf+0x16c>
    75e2:	f5 01       	movw	r30, r10
    75e4:	27 fc       	sbrc	r2, 7
    75e6:	85 91       	lpm	r24, Z+
    75e8:	27 fe       	sbrs	r2, 7
    75ea:	81 91       	ld	r24, Z+
    75ec:	5f 01       	movw	r10, r30
    75ee:	b7 01       	movw	r22, r14
    75f0:	90 e0       	ldi	r25, 0x00	; 0
    75f2:	0f d1       	rcall	.+542    	; 0x7812 <fputc>
    75f4:	31 10       	cpse	r3, r1
    75f6:	3a 94       	dec	r3
    75f8:	f1 e0       	ldi	r31, 0x01	; 1
    75fa:	4f 1a       	sub	r4, r31
    75fc:	51 08       	sbc	r5, r1
    75fe:	41 14       	cp	r4, r1
    7600:	51 04       	cpc	r5, r1
    7602:	79 f7       	brne	.-34     	; 0x75e2 <vfprintf+0x182>
    7604:	de c0       	rjmp	.+444    	; 0x77c2 <vfprintf+0x362>
    7606:	84 36       	cpi	r24, 0x64	; 100
    7608:	11 f0       	breq	.+4      	; 0x760e <vfprintf+0x1ae>
    760a:	89 36       	cpi	r24, 0x69	; 105
    760c:	31 f5       	brne	.+76     	; 0x765a <vfprintf+0x1fa>
    760e:	f8 01       	movw	r30, r16
    7610:	27 ff       	sbrs	r18, 7
    7612:	07 c0       	rjmp	.+14     	; 0x7622 <vfprintf+0x1c2>
    7614:	60 81       	ld	r22, Z
    7616:	71 81       	ldd	r23, Z+1	; 0x01
    7618:	82 81       	ldd	r24, Z+2	; 0x02
    761a:	93 81       	ldd	r25, Z+3	; 0x03
    761c:	0c 5f       	subi	r16, 0xFC	; 252
    761e:	1f 4f       	sbci	r17, 0xFF	; 255
    7620:	08 c0       	rjmp	.+16     	; 0x7632 <vfprintf+0x1d2>
    7622:	60 81       	ld	r22, Z
    7624:	71 81       	ldd	r23, Z+1	; 0x01
    7626:	07 2e       	mov	r0, r23
    7628:	00 0c       	add	r0, r0
    762a:	88 0b       	sbc	r24, r24
    762c:	99 0b       	sbc	r25, r25
    762e:	0e 5f       	subi	r16, 0xFE	; 254
    7630:	1f 4f       	sbci	r17, 0xFF	; 255
    7632:	2f 76       	andi	r18, 0x6F	; 111
    7634:	72 2e       	mov	r7, r18
    7636:	97 ff       	sbrs	r25, 7
    7638:	09 c0       	rjmp	.+18     	; 0x764c <vfprintf+0x1ec>
    763a:	90 95       	com	r25
    763c:	80 95       	com	r24
    763e:	70 95       	com	r23
    7640:	61 95       	neg	r22
    7642:	7f 4f       	sbci	r23, 0xFF	; 255
    7644:	8f 4f       	sbci	r24, 0xFF	; 255
    7646:	9f 4f       	sbci	r25, 0xFF	; 255
    7648:	20 68       	ori	r18, 0x80	; 128
    764a:	72 2e       	mov	r7, r18
    764c:	2a e0       	ldi	r18, 0x0A	; 10
    764e:	30 e0       	ldi	r19, 0x00	; 0
    7650:	a4 01       	movw	r20, r8
    7652:	17 d1       	rcall	.+558    	; 0x7882 <__ultoa_invert>
    7654:	a8 2e       	mov	r10, r24
    7656:	a8 18       	sub	r10, r8
    7658:	43 c0       	rjmp	.+134    	; 0x76e0 <vfprintf+0x280>
    765a:	85 37       	cpi	r24, 0x75	; 117
    765c:	29 f4       	brne	.+10     	; 0x7668 <vfprintf+0x208>
    765e:	2f 7e       	andi	r18, 0xEF	; 239
    7660:	b2 2e       	mov	r11, r18
    7662:	2a e0       	ldi	r18, 0x0A	; 10
    7664:	30 e0       	ldi	r19, 0x00	; 0
    7666:	25 c0       	rjmp	.+74     	; 0x76b2 <vfprintf+0x252>
    7668:	f2 2f       	mov	r31, r18
    766a:	f9 7f       	andi	r31, 0xF9	; 249
    766c:	bf 2e       	mov	r11, r31
    766e:	8f 36       	cpi	r24, 0x6F	; 111
    7670:	c1 f0       	breq	.+48     	; 0x76a2 <vfprintf+0x242>
    7672:	18 f4       	brcc	.+6      	; 0x767a <vfprintf+0x21a>
    7674:	88 35       	cpi	r24, 0x58	; 88
    7676:	79 f0       	breq	.+30     	; 0x7696 <vfprintf+0x236>
    7678:	ad c0       	rjmp	.+346    	; 0x77d4 <vfprintf+0x374>
    767a:	80 37       	cpi	r24, 0x70	; 112
    767c:	19 f0       	breq	.+6      	; 0x7684 <vfprintf+0x224>
    767e:	88 37       	cpi	r24, 0x78	; 120
    7680:	21 f0       	breq	.+8      	; 0x768a <vfprintf+0x22a>
    7682:	a8 c0       	rjmp	.+336    	; 0x77d4 <vfprintf+0x374>
    7684:	2f 2f       	mov	r18, r31
    7686:	20 61       	ori	r18, 0x10	; 16
    7688:	b2 2e       	mov	r11, r18
    768a:	b4 fe       	sbrs	r11, 4
    768c:	0d c0       	rjmp	.+26     	; 0x76a8 <vfprintf+0x248>
    768e:	8b 2d       	mov	r24, r11
    7690:	84 60       	ori	r24, 0x04	; 4
    7692:	b8 2e       	mov	r11, r24
    7694:	09 c0       	rjmp	.+18     	; 0x76a8 <vfprintf+0x248>
    7696:	24 ff       	sbrs	r18, 4
    7698:	0a c0       	rjmp	.+20     	; 0x76ae <vfprintf+0x24e>
    769a:	9f 2f       	mov	r25, r31
    769c:	96 60       	ori	r25, 0x06	; 6
    769e:	b9 2e       	mov	r11, r25
    76a0:	06 c0       	rjmp	.+12     	; 0x76ae <vfprintf+0x24e>
    76a2:	28 e0       	ldi	r18, 0x08	; 8
    76a4:	30 e0       	ldi	r19, 0x00	; 0
    76a6:	05 c0       	rjmp	.+10     	; 0x76b2 <vfprintf+0x252>
    76a8:	20 e1       	ldi	r18, 0x10	; 16
    76aa:	30 e0       	ldi	r19, 0x00	; 0
    76ac:	02 c0       	rjmp	.+4      	; 0x76b2 <vfprintf+0x252>
    76ae:	20 e1       	ldi	r18, 0x10	; 16
    76b0:	32 e0       	ldi	r19, 0x02	; 2
    76b2:	f8 01       	movw	r30, r16
    76b4:	b7 fe       	sbrs	r11, 7
    76b6:	07 c0       	rjmp	.+14     	; 0x76c6 <vfprintf+0x266>
    76b8:	60 81       	ld	r22, Z
    76ba:	71 81       	ldd	r23, Z+1	; 0x01
    76bc:	82 81       	ldd	r24, Z+2	; 0x02
    76be:	93 81       	ldd	r25, Z+3	; 0x03
    76c0:	0c 5f       	subi	r16, 0xFC	; 252
    76c2:	1f 4f       	sbci	r17, 0xFF	; 255
    76c4:	06 c0       	rjmp	.+12     	; 0x76d2 <vfprintf+0x272>
    76c6:	60 81       	ld	r22, Z
    76c8:	71 81       	ldd	r23, Z+1	; 0x01
    76ca:	80 e0       	ldi	r24, 0x00	; 0
    76cc:	90 e0       	ldi	r25, 0x00	; 0
    76ce:	0e 5f       	subi	r16, 0xFE	; 254
    76d0:	1f 4f       	sbci	r17, 0xFF	; 255
    76d2:	a4 01       	movw	r20, r8
    76d4:	d6 d0       	rcall	.+428    	; 0x7882 <__ultoa_invert>
    76d6:	a8 2e       	mov	r10, r24
    76d8:	a8 18       	sub	r10, r8
    76da:	fb 2d       	mov	r31, r11
    76dc:	ff 77       	andi	r31, 0x7F	; 127
    76de:	7f 2e       	mov	r7, r31
    76e0:	76 fe       	sbrs	r7, 6
    76e2:	0b c0       	rjmp	.+22     	; 0x76fa <vfprintf+0x29a>
    76e4:	37 2d       	mov	r19, r7
    76e6:	3e 7f       	andi	r19, 0xFE	; 254
    76e8:	a5 14       	cp	r10, r5
    76ea:	50 f4       	brcc	.+20     	; 0x7700 <vfprintf+0x2a0>
    76ec:	74 fe       	sbrs	r7, 4
    76ee:	0a c0       	rjmp	.+20     	; 0x7704 <vfprintf+0x2a4>
    76f0:	72 fc       	sbrc	r7, 2
    76f2:	08 c0       	rjmp	.+16     	; 0x7704 <vfprintf+0x2a4>
    76f4:	37 2d       	mov	r19, r7
    76f6:	3e 7e       	andi	r19, 0xEE	; 238
    76f8:	05 c0       	rjmp	.+10     	; 0x7704 <vfprintf+0x2a4>
    76fa:	ba 2c       	mov	r11, r10
    76fc:	37 2d       	mov	r19, r7
    76fe:	03 c0       	rjmp	.+6      	; 0x7706 <vfprintf+0x2a6>
    7700:	ba 2c       	mov	r11, r10
    7702:	01 c0       	rjmp	.+2      	; 0x7706 <vfprintf+0x2a6>
    7704:	b5 2c       	mov	r11, r5
    7706:	34 ff       	sbrs	r19, 4
    7708:	0d c0       	rjmp	.+26     	; 0x7724 <vfprintf+0x2c4>
    770a:	fe 01       	movw	r30, r28
    770c:	ea 0d       	add	r30, r10
    770e:	f1 1d       	adc	r31, r1
    7710:	80 81       	ld	r24, Z
    7712:	80 33       	cpi	r24, 0x30	; 48
    7714:	11 f4       	brne	.+4      	; 0x771a <vfprintf+0x2ba>
    7716:	39 7e       	andi	r19, 0xE9	; 233
    7718:	09 c0       	rjmp	.+18     	; 0x772c <vfprintf+0x2cc>
    771a:	32 ff       	sbrs	r19, 2
    771c:	06 c0       	rjmp	.+12     	; 0x772a <vfprintf+0x2ca>
    771e:	b3 94       	inc	r11
    7720:	b3 94       	inc	r11
    7722:	04 c0       	rjmp	.+8      	; 0x772c <vfprintf+0x2cc>
    7724:	83 2f       	mov	r24, r19
    7726:	86 78       	andi	r24, 0x86	; 134
    7728:	09 f0       	breq	.+2      	; 0x772c <vfprintf+0x2cc>
    772a:	b3 94       	inc	r11
    772c:	33 fd       	sbrc	r19, 3
    772e:	12 c0       	rjmp	.+36     	; 0x7754 <vfprintf+0x2f4>
    7730:	30 ff       	sbrs	r19, 0
    7732:	06 c0       	rjmp	.+12     	; 0x7740 <vfprintf+0x2e0>
    7734:	5a 2c       	mov	r5, r10
    7736:	b3 14       	cp	r11, r3
    7738:	18 f4       	brcc	.+6      	; 0x7740 <vfprintf+0x2e0>
    773a:	53 0c       	add	r5, r3
    773c:	5b 18       	sub	r5, r11
    773e:	b3 2c       	mov	r11, r3
    7740:	b3 14       	cp	r11, r3
    7742:	60 f4       	brcc	.+24     	; 0x775c <vfprintf+0x2fc>
    7744:	b7 01       	movw	r22, r14
    7746:	80 e2       	ldi	r24, 0x20	; 32
    7748:	90 e0       	ldi	r25, 0x00	; 0
    774a:	3c 87       	std	Y+12, r19	; 0x0c
    774c:	62 d0       	rcall	.+196    	; 0x7812 <fputc>
    774e:	b3 94       	inc	r11
    7750:	3c 85       	ldd	r19, Y+12	; 0x0c
    7752:	f6 cf       	rjmp	.-20     	; 0x7740 <vfprintf+0x2e0>
    7754:	b3 14       	cp	r11, r3
    7756:	10 f4       	brcc	.+4      	; 0x775c <vfprintf+0x2fc>
    7758:	3b 18       	sub	r3, r11
    775a:	01 c0       	rjmp	.+2      	; 0x775e <vfprintf+0x2fe>
    775c:	31 2c       	mov	r3, r1
    775e:	34 ff       	sbrs	r19, 4
    7760:	11 c0       	rjmp	.+34     	; 0x7784 <vfprintf+0x324>
    7762:	b7 01       	movw	r22, r14
    7764:	80 e3       	ldi	r24, 0x30	; 48
    7766:	90 e0       	ldi	r25, 0x00	; 0
    7768:	3c 87       	std	Y+12, r19	; 0x0c
    776a:	53 d0       	rcall	.+166    	; 0x7812 <fputc>
    776c:	3c 85       	ldd	r19, Y+12	; 0x0c
    776e:	32 ff       	sbrs	r19, 2
    7770:	16 c0       	rjmp	.+44     	; 0x779e <vfprintf+0x33e>
    7772:	31 fd       	sbrc	r19, 1
    7774:	03 c0       	rjmp	.+6      	; 0x777c <vfprintf+0x31c>
    7776:	88 e7       	ldi	r24, 0x78	; 120
    7778:	90 e0       	ldi	r25, 0x00	; 0
    777a:	02 c0       	rjmp	.+4      	; 0x7780 <vfprintf+0x320>
    777c:	88 e5       	ldi	r24, 0x58	; 88
    777e:	90 e0       	ldi	r25, 0x00	; 0
    7780:	b7 01       	movw	r22, r14
    7782:	0c c0       	rjmp	.+24     	; 0x779c <vfprintf+0x33c>
    7784:	83 2f       	mov	r24, r19
    7786:	86 78       	andi	r24, 0x86	; 134
    7788:	51 f0       	breq	.+20     	; 0x779e <vfprintf+0x33e>
    778a:	31 ff       	sbrs	r19, 1
    778c:	02 c0       	rjmp	.+4      	; 0x7792 <vfprintf+0x332>
    778e:	8b e2       	ldi	r24, 0x2B	; 43
    7790:	01 c0       	rjmp	.+2      	; 0x7794 <vfprintf+0x334>
    7792:	80 e2       	ldi	r24, 0x20	; 32
    7794:	37 fd       	sbrc	r19, 7
    7796:	8d e2       	ldi	r24, 0x2D	; 45
    7798:	b7 01       	movw	r22, r14
    779a:	90 e0       	ldi	r25, 0x00	; 0
    779c:	3a d0       	rcall	.+116    	; 0x7812 <fputc>
    779e:	a5 14       	cp	r10, r5
    77a0:	30 f4       	brcc	.+12     	; 0x77ae <vfprintf+0x34e>
    77a2:	b7 01       	movw	r22, r14
    77a4:	80 e3       	ldi	r24, 0x30	; 48
    77a6:	90 e0       	ldi	r25, 0x00	; 0
    77a8:	34 d0       	rcall	.+104    	; 0x7812 <fputc>
    77aa:	5a 94       	dec	r5
    77ac:	f8 cf       	rjmp	.-16     	; 0x779e <vfprintf+0x33e>
    77ae:	aa 94       	dec	r10
    77b0:	f4 01       	movw	r30, r8
    77b2:	ea 0d       	add	r30, r10
    77b4:	f1 1d       	adc	r31, r1
    77b6:	80 81       	ld	r24, Z
    77b8:	b7 01       	movw	r22, r14
    77ba:	90 e0       	ldi	r25, 0x00	; 0
    77bc:	2a d0       	rcall	.+84     	; 0x7812 <fputc>
    77be:	a1 10       	cpse	r10, r1
    77c0:	f6 cf       	rjmp	.-20     	; 0x77ae <vfprintf+0x34e>
    77c2:	33 20       	and	r3, r3
    77c4:	09 f4       	brne	.+2      	; 0x77c8 <vfprintf+0x368>
    77c6:	5d ce       	rjmp	.-838    	; 0x7482 <vfprintf+0x22>
    77c8:	b7 01       	movw	r22, r14
    77ca:	80 e2       	ldi	r24, 0x20	; 32
    77cc:	90 e0       	ldi	r25, 0x00	; 0
    77ce:	21 d0       	rcall	.+66     	; 0x7812 <fputc>
    77d0:	3a 94       	dec	r3
    77d2:	f7 cf       	rjmp	.-18     	; 0x77c2 <vfprintf+0x362>
    77d4:	f7 01       	movw	r30, r14
    77d6:	86 81       	ldd	r24, Z+6	; 0x06
    77d8:	97 81       	ldd	r25, Z+7	; 0x07
    77da:	02 c0       	rjmp	.+4      	; 0x77e0 <vfprintf+0x380>
    77dc:	8f ef       	ldi	r24, 0xFF	; 255
    77de:	9f ef       	ldi	r25, 0xFF	; 255
    77e0:	2c 96       	adiw	r28, 0x0c	; 12
    77e2:	e2 e1       	ldi	r30, 0x12	; 18
    77e4:	11 c1       	rjmp	.+546    	; 0x7a08 <__epilogue_restores__>

000077e6 <strnlen_P>:
    77e6:	fc 01       	movw	r30, r24
    77e8:	05 90       	lpm	r0, Z+
    77ea:	61 50       	subi	r22, 0x01	; 1
    77ec:	70 40       	sbci	r23, 0x00	; 0
    77ee:	01 10       	cpse	r0, r1
    77f0:	d8 f7       	brcc	.-10     	; 0x77e8 <strnlen_P+0x2>
    77f2:	80 95       	com	r24
    77f4:	90 95       	com	r25
    77f6:	8e 0f       	add	r24, r30
    77f8:	9f 1f       	adc	r25, r31
    77fa:	08 95       	ret

000077fc <strnlen>:
    77fc:	fc 01       	movw	r30, r24
    77fe:	61 50       	subi	r22, 0x01	; 1
    7800:	70 40       	sbci	r23, 0x00	; 0
    7802:	01 90       	ld	r0, Z+
    7804:	01 10       	cpse	r0, r1
    7806:	d8 f7       	brcc	.-10     	; 0x77fe <strnlen+0x2>
    7808:	80 95       	com	r24
    780a:	90 95       	com	r25
    780c:	8e 0f       	add	r24, r30
    780e:	9f 1f       	adc	r25, r31
    7810:	08 95       	ret

00007812 <fputc>:
    7812:	0f 93       	push	r16
    7814:	1f 93       	push	r17
    7816:	cf 93       	push	r28
    7818:	df 93       	push	r29
    781a:	fb 01       	movw	r30, r22
    781c:	23 81       	ldd	r18, Z+3	; 0x03
    781e:	21 fd       	sbrc	r18, 1
    7820:	03 c0       	rjmp	.+6      	; 0x7828 <fputc+0x16>
    7822:	8f ef       	ldi	r24, 0xFF	; 255
    7824:	9f ef       	ldi	r25, 0xFF	; 255
    7826:	28 c0       	rjmp	.+80     	; 0x7878 <fputc+0x66>
    7828:	22 ff       	sbrs	r18, 2
    782a:	16 c0       	rjmp	.+44     	; 0x7858 <fputc+0x46>
    782c:	46 81       	ldd	r20, Z+6	; 0x06
    782e:	57 81       	ldd	r21, Z+7	; 0x07
    7830:	24 81       	ldd	r18, Z+4	; 0x04
    7832:	35 81       	ldd	r19, Z+5	; 0x05
    7834:	42 17       	cp	r20, r18
    7836:	53 07       	cpc	r21, r19
    7838:	44 f4       	brge	.+16     	; 0x784a <fputc+0x38>
    783a:	a0 81       	ld	r26, Z
    783c:	b1 81       	ldd	r27, Z+1	; 0x01
    783e:	9d 01       	movw	r18, r26
    7840:	2f 5f       	subi	r18, 0xFF	; 255
    7842:	3f 4f       	sbci	r19, 0xFF	; 255
    7844:	31 83       	std	Z+1, r19	; 0x01
    7846:	20 83       	st	Z, r18
    7848:	8c 93       	st	X, r24
    784a:	26 81       	ldd	r18, Z+6	; 0x06
    784c:	37 81       	ldd	r19, Z+7	; 0x07
    784e:	2f 5f       	subi	r18, 0xFF	; 255
    7850:	3f 4f       	sbci	r19, 0xFF	; 255
    7852:	37 83       	std	Z+7, r19	; 0x07
    7854:	26 83       	std	Z+6, r18	; 0x06
    7856:	10 c0       	rjmp	.+32     	; 0x7878 <fputc+0x66>
    7858:	eb 01       	movw	r28, r22
    785a:	09 2f       	mov	r16, r25
    785c:	18 2f       	mov	r17, r24
    785e:	00 84       	ldd	r0, Z+8	; 0x08
    7860:	f1 85       	ldd	r31, Z+9	; 0x09
    7862:	e0 2d       	mov	r30, r0
    7864:	09 95       	icall
    7866:	89 2b       	or	r24, r25
    7868:	e1 f6       	brne	.-72     	; 0x7822 <fputc+0x10>
    786a:	8e 81       	ldd	r24, Y+6	; 0x06
    786c:	9f 81       	ldd	r25, Y+7	; 0x07
    786e:	01 96       	adiw	r24, 0x01	; 1
    7870:	9f 83       	std	Y+7, r25	; 0x07
    7872:	8e 83       	std	Y+6, r24	; 0x06
    7874:	81 2f       	mov	r24, r17
    7876:	90 2f       	mov	r25, r16
    7878:	df 91       	pop	r29
    787a:	cf 91       	pop	r28
    787c:	1f 91       	pop	r17
    787e:	0f 91       	pop	r16
    7880:	08 95       	ret

00007882 <__ultoa_invert>:
    7882:	fa 01       	movw	r30, r20
    7884:	aa 27       	eor	r26, r26
    7886:	28 30       	cpi	r18, 0x08	; 8
    7888:	51 f1       	breq	.+84     	; 0x78de <__ultoa_invert+0x5c>
    788a:	20 31       	cpi	r18, 0x10	; 16
    788c:	81 f1       	breq	.+96     	; 0x78ee <__ultoa_invert+0x6c>
    788e:	e8 94       	clt
    7890:	6f 93       	push	r22
    7892:	6e 7f       	andi	r22, 0xFE	; 254
    7894:	6e 5f       	subi	r22, 0xFE	; 254
    7896:	7f 4f       	sbci	r23, 0xFF	; 255
    7898:	8f 4f       	sbci	r24, 0xFF	; 255
    789a:	9f 4f       	sbci	r25, 0xFF	; 255
    789c:	af 4f       	sbci	r26, 0xFF	; 255
    789e:	b1 e0       	ldi	r27, 0x01	; 1
    78a0:	3e d0       	rcall	.+124    	; 0x791e <__ultoa_invert+0x9c>
    78a2:	b4 e0       	ldi	r27, 0x04	; 4
    78a4:	3c d0       	rcall	.+120    	; 0x791e <__ultoa_invert+0x9c>
    78a6:	67 0f       	add	r22, r23
    78a8:	78 1f       	adc	r23, r24
    78aa:	89 1f       	adc	r24, r25
    78ac:	9a 1f       	adc	r25, r26
    78ae:	a1 1d       	adc	r26, r1
    78b0:	68 0f       	add	r22, r24
    78b2:	79 1f       	adc	r23, r25
    78b4:	8a 1f       	adc	r24, r26
    78b6:	91 1d       	adc	r25, r1
    78b8:	a1 1d       	adc	r26, r1
    78ba:	6a 0f       	add	r22, r26
    78bc:	71 1d       	adc	r23, r1
    78be:	81 1d       	adc	r24, r1
    78c0:	91 1d       	adc	r25, r1
    78c2:	a1 1d       	adc	r26, r1
    78c4:	20 d0       	rcall	.+64     	; 0x7906 <__ultoa_invert+0x84>
    78c6:	09 f4       	brne	.+2      	; 0x78ca <__ultoa_invert+0x48>
    78c8:	68 94       	set
    78ca:	3f 91       	pop	r19
    78cc:	2a e0       	ldi	r18, 0x0A	; 10
    78ce:	26 9f       	mul	r18, r22
    78d0:	11 24       	eor	r1, r1
    78d2:	30 19       	sub	r19, r0
    78d4:	30 5d       	subi	r19, 0xD0	; 208
    78d6:	31 93       	st	Z+, r19
    78d8:	de f6       	brtc	.-74     	; 0x7890 <__ultoa_invert+0xe>
    78da:	cf 01       	movw	r24, r30
    78dc:	08 95       	ret
    78de:	46 2f       	mov	r20, r22
    78e0:	47 70       	andi	r20, 0x07	; 7
    78e2:	40 5d       	subi	r20, 0xD0	; 208
    78e4:	41 93       	st	Z+, r20
    78e6:	b3 e0       	ldi	r27, 0x03	; 3
    78e8:	0f d0       	rcall	.+30     	; 0x7908 <__ultoa_invert+0x86>
    78ea:	c9 f7       	brne	.-14     	; 0x78de <__ultoa_invert+0x5c>
    78ec:	f6 cf       	rjmp	.-20     	; 0x78da <__ultoa_invert+0x58>
    78ee:	46 2f       	mov	r20, r22
    78f0:	4f 70       	andi	r20, 0x0F	; 15
    78f2:	40 5d       	subi	r20, 0xD0	; 208
    78f4:	4a 33       	cpi	r20, 0x3A	; 58
    78f6:	18 f0       	brcs	.+6      	; 0x78fe <__ultoa_invert+0x7c>
    78f8:	49 5d       	subi	r20, 0xD9	; 217
    78fa:	31 fd       	sbrc	r19, 1
    78fc:	40 52       	subi	r20, 0x20	; 32
    78fe:	41 93       	st	Z+, r20
    7900:	02 d0       	rcall	.+4      	; 0x7906 <__ultoa_invert+0x84>
    7902:	a9 f7       	brne	.-22     	; 0x78ee <__ultoa_invert+0x6c>
    7904:	ea cf       	rjmp	.-44     	; 0x78da <__ultoa_invert+0x58>
    7906:	b4 e0       	ldi	r27, 0x04	; 4
    7908:	a6 95       	lsr	r26
    790a:	97 95       	ror	r25
    790c:	87 95       	ror	r24
    790e:	77 95       	ror	r23
    7910:	67 95       	ror	r22
    7912:	ba 95       	dec	r27
    7914:	c9 f7       	brne	.-14     	; 0x7908 <__ultoa_invert+0x86>
    7916:	00 97       	sbiw	r24, 0x00	; 0
    7918:	61 05       	cpc	r22, r1
    791a:	71 05       	cpc	r23, r1
    791c:	08 95       	ret
    791e:	9b 01       	movw	r18, r22
    7920:	ac 01       	movw	r20, r24
    7922:	0a 2e       	mov	r0, r26
    7924:	06 94       	lsr	r0
    7926:	57 95       	ror	r21
    7928:	47 95       	ror	r20
    792a:	37 95       	ror	r19
    792c:	27 95       	ror	r18
    792e:	ba 95       	dec	r27
    7930:	c9 f7       	brne	.-14     	; 0x7924 <__ultoa_invert+0xa2>
    7932:	62 0f       	add	r22, r18
    7934:	73 1f       	adc	r23, r19
    7936:	84 1f       	adc	r24, r20
    7938:	95 1f       	adc	r25, r21
    793a:	a0 1d       	adc	r26, r0
    793c:	08 95       	ret

0000793e <eeprom_read_block>:
    793e:	dc 01       	movw	r26, r24
    7940:	cb 01       	movw	r24, r22

00007942 <eeprom_read_blraw>:
    7942:	fc 01       	movw	r30, r24
    7944:	f9 99       	sbic	0x1f, 1	; 31
    7946:	fe cf       	rjmp	.-4      	; 0x7944 <eeprom_read_blraw+0x2>
    7948:	06 c0       	rjmp	.+12     	; 0x7956 <eeprom_read_blraw+0x14>
    794a:	f2 bd       	out	0x22, r31	; 34
    794c:	e1 bd       	out	0x21, r30	; 33
    794e:	f8 9a       	sbi	0x1f, 0	; 31
    7950:	31 96       	adiw	r30, 0x01	; 1
    7952:	00 b4       	in	r0, 0x20	; 32
    7954:	0d 92       	st	X+, r0
    7956:	41 50       	subi	r20, 0x01	; 1
    7958:	50 40       	sbci	r21, 0x00	; 0
    795a:	b8 f7       	brcc	.-18     	; 0x794a <eeprom_read_blraw+0x8>
    795c:	08 95       	ret

0000795e <eeprom_read_byte>:
    795e:	f9 99       	sbic	0x1f, 1	; 31
    7960:	fe cf       	rjmp	.-4      	; 0x795e <eeprom_read_byte>
    7962:	92 bd       	out	0x22, r25	; 34
    7964:	81 bd       	out	0x21, r24	; 33
    7966:	f8 9a       	sbi	0x1f, 0	; 31
    7968:	99 27       	eor	r25, r25
    796a:	80 b5       	in	r24, 0x20	; 32
    796c:	08 95       	ret

0000796e <eeprom_read_word>:
    796e:	a8 e1       	ldi	r26, 0x18	; 24
    7970:	b0 e0       	ldi	r27, 0x00	; 0
    7972:	42 e0       	ldi	r20, 0x02	; 2
    7974:	50 e0       	ldi	r21, 0x00	; 0
    7976:	e5 cf       	rjmp	.-54     	; 0x7942 <eeprom_read_blraw>

00007978 <eeprom_update_byte>:
    7978:	26 2f       	mov	r18, r22

0000797a <eeprom_update_r18>:
    797a:	f9 99       	sbic	0x1f, 1	; 31
    797c:	fe cf       	rjmp	.-4      	; 0x797a <eeprom_update_r18>
    797e:	92 bd       	out	0x22, r25	; 34
    7980:	81 bd       	out	0x21, r24	; 33
    7982:	f8 9a       	sbi	0x1f, 0	; 31
    7984:	01 97       	sbiw	r24, 0x01	; 1
    7986:	00 b4       	in	r0, 0x20	; 32
    7988:	02 16       	cp	r0, r18
    798a:	39 f0       	breq	.+14     	; 0x799a <eeprom_update_r18+0x20>
    798c:	1f ba       	out	0x1f, r1	; 31
    798e:	20 bd       	out	0x20, r18	; 32
    7990:	0f b6       	in	r0, 0x3f	; 63
    7992:	f8 94       	cli
    7994:	fa 9a       	sbi	0x1f, 2	; 31
    7996:	f9 9a       	sbi	0x1f, 1	; 31
    7998:	0f be       	out	0x3f, r0	; 63
    799a:	08 95       	ret

0000799c <eeprom_write_block>:
    799c:	dc 01       	movw	r26, r24
    799e:	cb 01       	movw	r24, r22
    79a0:	02 c0       	rjmp	.+4      	; 0x79a6 <eeprom_write_block+0xa>
    79a2:	2d 91       	ld	r18, X+
    79a4:	05 d0       	rcall	.+10     	; 0x79b0 <eeprom_write_r18>
    79a6:	41 50       	subi	r20, 0x01	; 1
    79a8:	50 40       	sbci	r21, 0x00	; 0
    79aa:	d8 f7       	brcc	.-10     	; 0x79a2 <eeprom_write_block+0x6>
    79ac:	08 95       	ret

000079ae <eeprom_write_byte>:
    79ae:	26 2f       	mov	r18, r22

000079b0 <eeprom_write_r18>:
    79b0:	f9 99       	sbic	0x1f, 1	; 31
    79b2:	fe cf       	rjmp	.-4      	; 0x79b0 <eeprom_write_r18>
    79b4:	1f ba       	out	0x1f, r1	; 31
    79b6:	92 bd       	out	0x22, r25	; 34
    79b8:	81 bd       	out	0x21, r24	; 33
    79ba:	20 bd       	out	0x20, r18	; 32
    79bc:	0f b6       	in	r0, 0x3f	; 63
    79be:	f8 94       	cli
    79c0:	fa 9a       	sbi	0x1f, 2	; 31
    79c2:	f9 9a       	sbi	0x1f, 1	; 31
    79c4:	0f be       	out	0x3f, r0	; 63
    79c6:	01 96       	adiw	r24, 0x01	; 1
    79c8:	08 95       	ret

000079ca <eeprom_write_word>:
    79ca:	f1 df       	rcall	.-30     	; 0x79ae <eeprom_write_byte>
    79cc:	27 2f       	mov	r18, r23
    79ce:	f0 cf       	rjmp	.-32     	; 0x79b0 <eeprom_write_r18>

000079d0 <__prologue_saves__>:
    79d0:	2f 92       	push	r2
    79d2:	3f 92       	push	r3
    79d4:	4f 92       	push	r4
    79d6:	5f 92       	push	r5
    79d8:	6f 92       	push	r6
    79da:	7f 92       	push	r7
    79dc:	8f 92       	push	r8
    79de:	9f 92       	push	r9
    79e0:	af 92       	push	r10
    79e2:	bf 92       	push	r11
    79e4:	cf 92       	push	r12
    79e6:	df 92       	push	r13
    79e8:	ef 92       	push	r14
    79ea:	ff 92       	push	r15
    79ec:	0f 93       	push	r16
    79ee:	1f 93       	push	r17
    79f0:	cf 93       	push	r28
    79f2:	df 93       	push	r29
    79f4:	cd b7       	in	r28, 0x3d	; 61
    79f6:	de b7       	in	r29, 0x3e	; 62
    79f8:	ca 1b       	sub	r28, r26
    79fa:	db 0b       	sbc	r29, r27
    79fc:	0f b6       	in	r0, 0x3f	; 63
    79fe:	f8 94       	cli
    7a00:	de bf       	out	0x3e, r29	; 62
    7a02:	0f be       	out	0x3f, r0	; 63
    7a04:	cd bf       	out	0x3d, r28	; 61
    7a06:	09 94       	ijmp

00007a08 <__epilogue_restores__>:
    7a08:	2a 88       	ldd	r2, Y+18	; 0x12
    7a0a:	39 88       	ldd	r3, Y+17	; 0x11
    7a0c:	48 88       	ldd	r4, Y+16	; 0x10
    7a0e:	5f 84       	ldd	r5, Y+15	; 0x0f
    7a10:	6e 84       	ldd	r6, Y+14	; 0x0e
    7a12:	7d 84       	ldd	r7, Y+13	; 0x0d
    7a14:	8c 84       	ldd	r8, Y+12	; 0x0c
    7a16:	9b 84       	ldd	r9, Y+11	; 0x0b
    7a18:	aa 84       	ldd	r10, Y+10	; 0x0a
    7a1a:	b9 84       	ldd	r11, Y+9	; 0x09
    7a1c:	c8 84       	ldd	r12, Y+8	; 0x08
    7a1e:	df 80       	ldd	r13, Y+7	; 0x07
    7a20:	ee 80       	ldd	r14, Y+6	; 0x06
    7a22:	fd 80       	ldd	r15, Y+5	; 0x05
    7a24:	0c 81       	ldd	r16, Y+4	; 0x04
    7a26:	1b 81       	ldd	r17, Y+3	; 0x03
    7a28:	aa 81       	ldd	r26, Y+2	; 0x02
    7a2a:	b9 81       	ldd	r27, Y+1	; 0x01
    7a2c:	ce 0f       	add	r28, r30
    7a2e:	d1 1d       	adc	r29, r1
    7a30:	0f b6       	in	r0, 0x3f	; 63
    7a32:	f8 94       	cli
    7a34:	de bf       	out	0x3e, r29	; 62
    7a36:	0f be       	out	0x3f, r0	; 63
    7a38:	cd bf       	out	0x3d, r28	; 61
    7a3a:	ed 01       	movw	r28, r26
    7a3c:	08 95       	ret

00007a3e <_exit>:
    7a3e:	f8 94       	cli

00007a40 <__stop_program>:
    7a40:	ff cf       	rjmp	.-2      	; 0x7a40 <__stop_program>
